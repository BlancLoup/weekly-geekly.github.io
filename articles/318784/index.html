<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Can your code reason?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When we think about reasoning in programming, the first thing that comes to mind is logic programming and a rule-based approach, expert systems and bu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Can your code reason?</h1><div class="post__text post__text-html js-mediator-article"><p>  When we think about reasoning in programming, the first thing that comes to mind is logic programming and a rule-based approach, expert systems and business rule management systems (BRMS). </p><br><p>  The common multi-paradigm languages ‚Äã‚Äãpractically <a href="https://en.wikipedia.org/wiki/Comparison_of_multi-paradigm_programming_languages">do not include</a> these approaches, although they work with them through libraries and interfaces.  Why?  Because these languages ‚Äã‚Äãcan not include themselves forms, which in some sense contradict their essence.  Popular programming languages ‚Äã‚Äãusually work with determinism (expected data, usage scenarios, etc.), while approaches that use reasoning usually work with uncertainty (unpredictable data, usage scenarios, etc.).  The reasoning will be different in both cases too.  In the first, argues the architect or developer, in the second, the reasoning / rule engine argues. </p><br><a name="habracut"></a><br><p>  We cannot prefer this or that side of this dualism.  The external world is full of determinism and uncertainty, they are combined in the same things and phenomena.  For example, every day we can go home on the same shortest route.  We have already spent time in the past on its search, we know its features (so that we can go over it, almost "on the machine").  Using this route is very efficient, but not flexible.  If traffic jams and other circumstances, the shortest route may be the longest.  We can use the navigator, but it does not give a full guarantee.  A traffic jam can form when we are on the road and there are simply no turns to make a different route.  We ourselves can know that in 30 minutes there will be a daily traffic jam just on the route suggested by the navigator.  The conclusion is that it is better to have a choice between the decision that was once chosen (and not spend time on it again) and flexible ways (if circumstances have changed). </p><br><p>  Can we combine these approaches in code?  The most popular solutions for now are: plug-ins, customizations, domain-specific languages ‚Äã‚Äã(DSL), rules already mentioned, etc.  Plugins are limited to the need to write code and require a certain level of competence.  Customizations, rules, and domain-specific languages ‚Äã‚Äãare limited by the need to learn and the functionality of the application that is available to them.  Can we facilitate the study and give access to the greatest possible functionality of the application?  One possible solution: <a href="https://habrahabr.ru/post/317872/">meaning markup language</a> .  What can he do? </p><br><ul><li>  It is based on natural language, so learning may be minimal. </li><li>  Allows linking with code, forming a natural language interface for such code, which motivates a greater coverage of functionality as compared with customization, which is explicitly created for specific areas of code. </li><li>  Since it is based on natural language (which allows for uncertainty) and algorithms (which allow determinism rather), it can work with both sides of the ambiguity-determinism dualism. </li></ul><br><p>  Consider this on the example of calculating the volume of the planets.  A classic solution in an object-oriented language might look like this: </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ball</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> radius; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVolume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ball</span></span></span><span class="hljs-class"> </span></span>{ ... } Planet jupiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Planet(<span class="hljs-string"><span class="hljs-string">"Jupiter"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> vol = jupiter.getVolume();</code> </pre> <br><p>  In this code, reasoning is sufficient: in definitions, fields, methods, class hierarchies, etc.  For example, the fact that the planet is a ball, and Jupiter is a planet.  However, these arguments are implicit, cannot be reused, are highly interdependent (tightly coupled) with the code.  In similar code in JavaScript, the reasoning is hidden in conventions: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBallVolume</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jupiter = planet.getPlanet(<span class="hljs-string"><span class="hljs-string">'Jupiter'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> volume = getBallVolume(jupiter.diameter);</code> </pre> <br><p>  When we use meaning markup: </p><br><pre> <code class="javascript hljs">meaningful.register({ <span class="hljs-attr"><span class="hljs-attr">func</span></span>: planet.getPlanet, <span class="hljs-attr"><span class="hljs-attr">question</span></span>: <span class="hljs-string"><span class="hljs-string">' {_} {}  {} '</span></span>, <span class="hljs-attr"><span class="hljs-attr">input</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">planetName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> planetName ? planetName.toLowerCase() : <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } }], <span class="hljs-attr"><span class="hljs-attr">output</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.diameter; } }); meaningful.register({ <span class="hljs-attr"><span class="hljs-attr">func</span></span>: getBallVolume, <span class="hljs-attr"><span class="hljs-attr">question</span></span>: <span class="hljs-string"><span class="hljs-string">' {_} {}  {} '</span></span>, <span class="hljs-attr"><span class="hljs-attr">input</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }] }); meaningful.build([ <span class="hljs-string"><span class="hljs-string">' { } '</span></span>, <span class="hljs-string"><span class="hljs-string">' {} '</span></span> ]); expect(meaningful.query(<span class="hljs-string"><span class="hljs-string">' {_} {}  {} '</span></span>)).toEqual([ <span class="hljs-number"><span class="hljs-number">1530597322872155.8</span></span> ]);</code> </pre> <br><p>  But the situation is different because: </p><br><ul><li>  Functions directly correspond to questions of natural language "What is the diameter of the planet?"  or "What is the volume of the ball?". </li><li>  These questions can be used to integrate with other applications / interfaces / functions.  For example, this code can simulate a situation where we have (a) an application with data about the planets, (b) an application that can calculate the volume of various geometric objects.  The reasoning engine can now answer the question "What is the volume of Jupiter?". </li><li>  These questions can be used by search engines and natural language interface. </li><li>  It is possible to use differently (override) reasoning inherent in the code.  That is, we can more flexibly use similarity without changing them.  For example, we can apply the ball volume formula for pear-shaped objects, which most likely will not be inherited from spherical objects.  But, if we are satisfied with the approximation of such an object with a ball (or approximation of the upper and lower parts of this object with balls), we can use the similarity and calculate the volume of the pear-shaped body as a ball.  Of course, the same can be done with a design pattern (such as an Adapter).  However, the problem is that we cannot foresee all possible usage scenarios, when similarity will be used, and we cannot include them in the code in advance. </li><li>  We can use approaches that are not inherent in the language that we use.  In fact, extended similarity can be considered as a type of <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25BE%25D0%25B2">dynamic typing</a> .  Or we can essentially implement something like a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D1%2583%25D0%25BB%25D1%258C%25D1%2582%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">multimethod</a> . </li><li>  We can use local reasoning, which is specific only to this statement.  For example, the similarity of a pear-shaped object with a ball can extend only to one statement, and not appear as a general truth. </li></ul><br><p>  And it's all?  Not really.  Now we can enter into areas that are not in the main programming languages, for example, cause and effect.  Imagine that we are dealing with instructions on how to install the operating system OS_like_OS.  Modern software considers such instructions as textual documentation.  But we can assume that this is a set of causes of the OS installation.  And in this case we can get an answer to the question "How to install OS_like_OS?"  directly: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = [ <span class="hljs-string"><span class="hljs-string">'    '</span></span>, <span class="hljs-string"><span class="hljs-string">'    USB   '</span></span>, <span class="hljs-string"><span class="hljs-string">'   '</span></span>, <span class="hljs-string"><span class="hljs-string">'   '</span></span> ]; _.each(text, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ meaningful.build(<span class="hljs-string"><span class="hljs-string">' { } OS_like_OS { } '</span></span> + t); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = meaningful.query(<span class="hljs-string"><span class="hljs-string">'{_ @} { } OS_like_OS'</span></span>); expect(result).toEqual(text);</code> </pre> <br><p>  Very easy to reason?  But this is only the beginning.  After all, when answering such questions, we can operate not only with cause and effect, but with conditions and other relationships.  You can see <a href="">an example of a test</a> that queries the path to functionality with alternatives and conditions.  This is more than documentation.  These are explanations and a dependency map between the components of the application, which can be reused, including to answer the many questions "How?"  and why?". </p><br><p>  A similar situation with error handling.  Today, errors are, at best, readable messages with a stack of calls that can tell what happened.  In the worst case, it may be a runtime error message without any prompts.  What the markup of meaning and its integration with the code can improve is to help better clarify what actually happened, and, perhaps, help to correct the situation.  Let's look at the example of a function that adds items to the list: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  /   . var addEnabled = true; var planets = []; meaningful.register({ func: function(list, element) { if (addEnabled) eval(list + '.push(\'' + element + '\')'); else //    false,    throw " "; }, question: ' {}  {}  {} ', input: [ { name: 'list' }, { name: '' } ], error: function(err) { if (err === ' ') //          return ' {} '; } }); //   ,    meaningful.register({ func: function(list, element) { addEnabled = true; }, question: ' {} ' }); meaningful.build([ 'planets { } ' ]); meaningful.build([ ' { } ' ]); meaningful.build([ ' { } ' ]); meaningful.query(' {}  {}  {} planets', { execute: true }); //     , ..   true expect(planets).toEqual([ '' ]); //    . addEnabled = false; //      meaningful.query(' {}  {}  {} planets', { execute: true, error: function(err) { //      "" ,     meaningful.query(err, { execute: true }); }}); expect(planets).toEqual([ '' ]); meaningful.query(' {}  {}  {} planets', { execute: true }); //      expect(planets).toEqual([ '', '' ]);</span></span></code> </pre> <br><p>  As we can see, the result of error handling can be not only a message and a call stack, but also a complex of cause and effect, variable states, etc., all that can help answer the question "Why did this error happen?".  To make this possible, the preparation must begin at the stage of formulating the requirement, when we can construct layouts of the facts based on the textual description of the problem.  For example, this markup: </p><br><pre> <code class="hljs"> {}  { } 142984 4.1887902047864 { }  {}  {}  { } 2 1530597322872155.8 { }  {}  {}  { } 142984</code> </pre> <br><p>  Can be considered as the layout and expectations of the functions getPlanetDiameter () and getBallVolume ().  Based on this, true layout functions can be generated: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDiameterOfPlanet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">planet</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (planet === <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">142984</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVolumeOfBall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">diameter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diameter === <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4.1887902047864</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diameter === <span class="hljs-number"><span class="hljs-number">142984</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1530597322872155.8</span></span>; }</code> </pre> <br><p>  Such layout functions already allow reasoning (for example, to help calculate the volume of Jupiter), which can help assess how the future application can fit into an already existing data and code ecosystem.  Further, the developer can already replace the layout function with real code.  That is, thanks to the correspondence between requirements, code, tests, user interface, documentation (which is supported by compositing natural language constructs), we can work with a limited layout function, a real function, a corresponding part of the user interface and documentation in a similar way.  This allows us to further shorten the waiting cycle between various types of engineering activity, as is the case with reasoning: in order to work with them, we do not need to wait for full implementation. </p><br><p>  Naturally, the performance issue is critical for the execution phase, but, unlike the Semantic Web, which seeks to build the <a href="https://en.wikipedia.org/wiki/Giant_Global_Graph">Giant Global Data Graph</a> , your application can only be limited to its own data.  That will not lead to more flexible and global conclusions (since we are limited only by our application), but will also be more specific and verifiable (since we are limited only by our application). </p><br><p>  So can your code reason?  More precisely, rather, it will be done not by the code itself, but by the output machine based on your code, but it is feasible.  If only because we can be motivated by improved application development, due to the fact that it will be possible to better check the compliance of the code with the requirements, due to the fact that it will be easier to find what the given application or library provides (since the functionality will be available in the form of meaning markup), due to the fact that you can make more explicit causal chains for both the application logic and the one that led to the error. </p><br><p>  As for the dualism of uncertainty and determinism, perhaps we need to stop trying to reconcile the incompatible.  The work of any application can be represented in the form of (a) tightly coupled, statically typed code (with increased requirements for reliability, security, efficiency for specific scenarios) and (b) loosely coupled, dynamically typed and component constructions of a natural language (without reliability, security, which should be regulated by application level, and which can be flexibly applied for a wide range of scenarios).  Is it worth trying to make more flexible constructs that are optimized for determinism?  Is it worth trying to do more productive designs that focus more on uncertainty?  Most likely not and no.  Applications must be highly specialized, natural language adapt to any conditions, to each his own. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318784/">https://habr.com/ru/post/318784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318774/index.html">About recovery. Is RAID on a VPS SSD advisable in case of dedicated drives? Analog server until February for free</a></li>
<li><a href="../318776/index.html">Stylish Python code, or learning to use Flake8</a></li>
<li><a href="../318778/index.html">PHPixie Cache: PSR-6, PSR-16 and some interesting features</a></li>
<li><a href="../318780/index.html">Approaches to design in virtual reality</a></li>
<li><a href="../318782/index.html">Java socket framework</a></li>
<li><a href="../318786/index.html">Competitiveness: Cooperativeness</a></li>
<li><a href="../318788/index.html">42% of people who do not buy your product</a></li>
<li><a href="../318790/index.html">Creating a blog engine with Phoenix and Elixir / Part 7. Add comments / New Year's announcement in the conclusion</a></li>
<li><a href="../318792/index.html">FBI, CIA and Obama against PHP script</a></li>
<li><a href="../318796/index.html">Sending a GPS track via SMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>