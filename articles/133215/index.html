<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New old method of protection against email spam based on MTA Exim</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to provide a description of the method of protecting corporate mail from spam, which allows you to use the advantages of individual address fil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New old method of protection against email spam based on MTA Exim</h1><div class="post__text post__text-html js-mediator-article"> I want to provide a description of the method of protecting corporate mail from spam, which allows you to use the advantages of individual address filtering tools, while avoiding the drawbacks of the same methods. <br>  It can be emphasized that these techniques can be used on the SMTP proxy, which closes the corporate mail server located in the DMZ. <br><br>  Often, administrators avoid some effective filtering techniques, due to the shortcomings of this or that approach.  For example - DNSBL filters often give false positives to those nodes that fall into it by mistake - for example, as part of the whole block of addresses of an individual provider.  A frequently used filtering method based on a simple definition of a PTR record also has a tendency to fail when the A and PTR records do not match, or simply have problems with the DNS service. <br><br>  In this article, I want to show how to break individual filtering methods into smaller ones and operate with filtering on the totality of the data about the sending node, and not only on the result of one prohibiting rule. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This technique has existed for a long time, I met different implementations of this idea by different specialists, and this variation was described more briefly by me 5 years ago in the exim-users@exim.org mailing list (the article can still be found in <a href="http://www.mail-archive.com/exim-users%40exim.org/msg16357.html">the mailing list archive</a> ), but despite on the ease of implementation and availability of documentation, they are now rarely used by postal administrators. <br><br>  Using the example of the Horns'n'Hoofs company mail with the hornsnhoofs.com domain, we will try to consider not imaginary, but quite efficient ‚Äúin battle‚Äù filtering techniques. <br><a name="habracut"></a><br>  The main idea of ‚Äã‚Äãthis implementation is that none of the checks is ‚Äúcritical‚Äù, except for the server‚Äôs own blacklist stored in the SQL database.  In other words, we do not refuse to use DNSBL, nor check for direct and reverse DNS match tests or any other tests for host ‚Äúspam‚Äù, but do not prohibit the host to continue the SMTP session if it has not passed any This is a separate check (for example, it lights up in SpamHaus DSNBL). <br><br>  Each failed test only adds a certain amount of points to the ‚Äúspaminess‚Äù of the letter, and the decision to accept or reject is made based on the total amount of these points at several ‚Äúcontrol points‚Äù of the configuration.  This approach allows you to use a variety of tools for evaluating email senders and, at the same time, reduce the level of filter false positives (so-called false positives). <br>  The article assumes that the reader is able to install and configure Exim as a receiving server.  I also rely on the fact that the reader is able to write at least simple lookups for Exim. <br>  Of course, the SMTP protocol should be known to any competent admin, and the principles of his work are perfectly described in RFC 821, 2821 and 5321, whose translations into Russian can be easily found on the network.  A theoretical description of many ways to protect against spam can be found in RFC 2505. <br><br>  So, let's proceed to the description of the mail server configuration: <br>  The total points earned will be stored in the <code>$acl_c_spamscore</code> variable.  This is the main variable in the configuration program, all the other behavior of the MTA depends on its value. <br><br>  First, we set its initial value to 0. For example, in acl, which is responsible for checking the argument of the <s>HELO</s> MAIL FROM: <br><pre> <code class="hljs sql">acl_check_sender:    warn <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> acl_c_spamscore = <span class="hljs-number"><span class="hljs-number">0</span></span>    [...]    <span class="hljs-keyword"><span class="hljs-keyword">accept</span></span></code> </pre><br><br>  <b>UPD:</b> thanks to the <a href="http://habrahabr.ru/users/slimlv/">slimlv</a> user who noticed a logical error. <br><br>  Why initialization does not happen immediately when connected?  Very simple - the counter is also reset when the RSET command is sent, which restarts the SMTP session.  If this is not done, the number of points would remain the same and new points would be added to it for the same checks made before the RSET team. <br>  This is inconvenient when debugging the work of the MTA, in the combat system it doesn‚Äôt matter where the counter will be reset - immediately when the node is connected (in acl_smtp_connect), or after MAIL FROM transfer, as in the example. <br><br>  Another important variable is <code>$acl_c_bouncemessage</code> , in which messages are added about the results of all checks.  It is necessary for high-quality debugging of the MTA.  You will immediately see in the server log what checks were not passed and how many points were scored, and admins reading mail failures at the other end of the wire will be able to understand why the SMTP session was broken and correct the error (yeah, dreaming; 95% of them, alas , only scratches turnip).  However, there are so few false positives with a properly configured filtering system (I have only one over the last year) that I use this variable only for my own convenience when debugging. <br><br>  The bulk of the checks are enclosed in the <code>acl_check_sender</code> section (the phase of the SMTP session, coming after the transfer ‚ÄúMAIL FROM: &lt;email@address.any&gt;‚Äù): <br><br>  Start over: <br><br><pre> <code class="hljs sql">acl_check_sender:    [...]     warn <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> acl_c_spamscore = <span class="hljs-number"><span class="hljs-number">0</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">hosts</span></span> = +blacklisted_hosts         message = <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span> closed. IP [$sender_host_address] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Blacklist.    [...]    <span class="hljs-keyword"><span class="hljs-keyword">accept</span></span></code> </pre><br><br>  Once we have recorded in the server log, from which email and ip-address the letter was sent, you can disable (drop) the node if it is in the local ‚Äúblack list‚Äù of the server (in MySQL database), so as not to generate too much traffic with additional SMTP commands, as well as DNS and DNSBL queries. <br><br>  The blacklist itself is a table in a database consisting of two fields: <code>IP varchar(15)</code> and <code>Timestamp int(11)</code> , where the ip-address and the time it is added to the database are stored in the unix_time format (in this format, it is convenient to carry out operations seconds): <br><br>  An example of a request to the blacklist is very simple: <code>SELECT IP FROM antispam.blacklist WHERE IP='1.1.1.1' limit 1"</code> . <br><br>  Working with the database from the mail server is also implemented elementary.  To do this, add a directive to the main configuration section: <br><br><pre> <code class="hljs pgsql">hostlist blacklisted_hosts = ${lookup mysql {<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> IP <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> antispam.blacklist \                                            <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> IP=<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>} \                             }</code> </pre><br><br>  So we form a list of one ip-address (or from zero addresses, if the request did not return anything), which we later query as <code>+blacklisted_hosts</code> in access lists. <br><br>  Of course, you can not forget about the <code>hide mysql_servers = 127.0.0.1/antispam/mta/mtapass</code> directive <code>hide mysql_servers = 127.0.0.1/antispam/mta/mtapass</code> at the very beginning of the config, which contains the parameters for connecting to the database. <br><br>  The filling of the blacklist table with ip-addresses occurs automatically by the MTA itself, which will be shown below. <br><br>  And now we look at the anti-spam "warhead": <br><br><pre> <code class="hljs ruby">  warn !condition = ${lookup{$sender_address_domain}wildlsearch{<span class="hljs-regexp"><span class="hljs-regexp">/CONFIG_PREFIX/</span></span>\ additional/trusted_zones}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}       set acl_c_spamscore = ${<span class="hljs-symbol"><span class="hljs-symbol">eval:</span></span>$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">20</span></span>}       set acl_c_bouncemessage = $acl_c_bouncemessage Suspicious e-mail address;</code> </pre><br><br>  Where trusted_zones is a plain text file in the additional directory in the folder with the configuration of Exim.  It contains something like the following: <br><br><pre> <code class="hljs tex">^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.ru<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span> ^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.ua<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span> ^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.by<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span> ^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.com<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span> ^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.org<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span> ^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.net<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span> ^.*<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.edu<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span></span></code> </pre><br>  Regular expressions describe those domain zones, from whose email addresses (DNS has nothing to do with it), correspondence usually comes.  The example above contains the necessary minimum, which, if necessary, can and should be edited. <br><br>  The directive warn indicates to eczema that the letter should neither be accepted nor rejected.  It is only necessary to fulfill the condition and process the session further. <br><br>  From this, it turns out that a node sending a domain zone that is uncharacteristic of incoming mail in the sender's address (not to be confused with the ‚ÄúFrom:‚Äù header) will receive 20 points and move on: <br><br><pre> <code class="hljs dos">#-----------------------------DNS Records <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span>------------------------------------    warn !<span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> = reverse_host_lookup         <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> acl_c_spamscore = ${eval:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">30</span></span>}         <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> acl_c_bouncemessage = $acl_c_bouncemessage Reverse host lookup failed;</code> </pre><br>  +30 points - for the mismatch of direct (A) and reverse (PTR) DNS records. <br><br><pre> <code class="hljs perl">    <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> condition = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e<span class="hljs-string"><span class="hljs-string">q {$acl_c_reverse_zone}</span></span>{}}         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">50</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage No DNS PTR record found;</code> </pre><br><br>  Another 50 - for the lack of reverse (PTR) records. <br>  Eighty points are already enough to put the knot in the greylist, as will be shown later. <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#-----------------------------------------------------------------------------------</span></span></code> </pre><br><br>  You can see that the <code>$acl_c_reverse_zone</code> variable appeared here, which contains the result (the DNS value of the PTR of the node) of the following test: <br><br><pre> <code class="hljs ruby">         set acl_c_reverse_zone = ${<span class="hljs-symbol"><span class="hljs-symbol">escape:</span></span>${lookup dnsdb{ptr=$sender_host_address}}}</code> </pre><br>  Its value can be set when the node is connected (in <code>acl_smtp_connect</code> , which is more correct) or when checking the HELO argument in <code>acl_check_helo</code> where <br>  initialized <code>$acl_c_spamscore</code> .  The difference is small.  You can generally use the construction everywhere: <br><br><pre> <code class="hljs perl">    <span class="hljs-keyword"><span class="hljs-keyword">warn</span></span> condition = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e<span class="hljs-string"><span class="hljs-string">q {</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${escape:${lookup dnsdb{ptr=$sender_host_address}</span></span></span><span class="hljs-string">}</span></span>}}\ {}}</code> </pre><br><br>  But keep in mind that each such lookup will generate a DNS query.  With a large flow of mail (spam) it will create unnecessary burdens.  With a small flow, you can hardly even feel the difference. <br><br><pre> <code class="hljs delphi">#-----------------------------<span class="hljs-keyword"><span class="hljs-keyword">Dynamic</span></span> IP pools processing---------------------------    warn condition = $<span class="hljs-comment"><span class="hljs-comment">{lookup {$acl_c_reverse_zone}</span></span>wildlsearch<span class="hljs-comment"><span class="hljs-comment">{CONFIG_PREFIX/\ additional/dynamic_pools}</span></span><span class="hljs-comment"><span class="hljs-comment">{1}</span></span><span class="hljs-comment"><span class="hljs-comment">{0}</span></span>\                      }         <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> acl_c_spamscore = $<span class="hljs-comment"><span class="hljs-comment">{eval:$acl_c_spamscore+70}</span></span>         <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> acl_c_bouncemessage = $acl_c_bouncemessage Suspected PTR DNS <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> \ points <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> IP pool;</code> </pre><br><br>  The sending node will receive +70 points if its DNS record points to some dynamic address pool, since  such pools are a breeding ground for viruses and, as a result, good soil for botnets. <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#-----------------------------------------------------------------------------------</span></span></code> </pre><br><br>  The dynamic_pools file is similar in structure to the trusted_zones file and contains regular expressions for checking DNS records for modems, adsl users and other nodes with dynamically allocated ip: <br><br><pre> <code class="hljs markdown">^.<span class="hljs-emphasis"><span class="hljs-emphasis">*([0-9]+).([0-9]+).([0-9]+).([0-9]+).*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*host.([0-9]+).*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*dynamic.*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*dial.*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*ppp.*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*pptp.*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*broadband.*</span></span> ^.<span class="hljs-emphasis"><span class="hljs-emphasis">*dhcp.*</span></span></code> </pre><br>  You can add your own rules here, this is just the necessary minimum. <br><br><pre> <code class="hljs mel">#---------------------------Geographical DNS zone processing------------------------    warn !<span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup {$sender_host_name}wildlsearch{/CONFIG_PREFIX/\ additional/trusted_zones}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">20</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Untrusted domain zone;</code> </pre><br><br>  The same trusted_zones, which was previously used to verify emails, is now used to filter by real DNS records. <br><br>  +20 points if the mail comes from the Chinese, Mexican, Korean and other, not listed in the list of domain zones. <br><br><pre> <code class="hljs swift">#------------------------------------------------------------------------------------------ #-------------------<span class="hljs-type"><span class="hljs-type">Huge</span></span> <span class="hljs-type"><span class="hljs-type">DSL</span></span> &amp; <span class="hljs-type"><span class="hljs-type">DialUp</span></span> <span class="hljs-type"><span class="hljs-type">ISP's</span></span> <span class="hljs-type"><span class="hljs-type">DNS</span></span> zone processing---------------------    warn condition = ${lookup {$sender_host_name}wildlsearch{<span class="hljs-type"><span class="hljs-type">CONFIG_PREFIX</span></span>/\ additional/spamvertised_isp}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}         <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> acl_c_spamscore = ${eval:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">40</span></span>}         <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> acl_c_bouncemessage = $acl_c_bouncemessage <span class="hljs-type"><span class="hljs-type">Spamvertised</span></span> <span class="hljs-type"><span class="hljs-type">ISP</span></span> <span class="hljs-type"><span class="hljs-type">DNS</span></span> zone;</code> </pre><br><br>  +40 points to individual major providers who do not care about filtering outgoing traffic generated by botnets. <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#-----------------------------------------------------------------------------------</span></span></code> </pre><br><br>  The spamvertised_isp file lists many large providers that allow their modems to make outgoing connections to port 25 (calculated by logs): <br><br><pre> <code class="hljs css">^.*<span class="hljs-selector-tag"><span class="hljs-selector-tag">comcast</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.net</span></span> ^.*<span class="hljs-selector-tag"><span class="hljs-selector-tag">pppoe</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.mtu-net</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> ^.*<span class="hljs-selector-tag"><span class="hljs-selector-tag">qwerty</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span> ^.*<span class="hljs-selector-tag"><span class="hljs-selector-tag">ono</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span> ^.*<span class="hljs-selector-tag"><span class="hljs-selector-tag">virtua</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span>\\<span class="hljs-selector-class"><span class="hljs-selector-class">.br</span></span></code> </pre><br><br>  You can add your notes.  Even need. <br><br><pre> <code class="hljs tex">#----------------------------Handler for impossible HELO's-------------------------    warn condition = <span class="hljs-formula"><span class="hljs-formula">${if or {</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">                                {match{$</span></span>sender_helo_name}{localhost}}<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>                                {match{<span class="hljs-formula"><span class="hljs-formula">$sender_helo_name}{mail.hornsnhoofs.com}}</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">                                {match{$</span></span>sender_helo_name}{^127<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.0<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.0<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">\</span></span></span></span>.([0-9]+)}}<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>                            }{1}{0}<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>                     }         set acl_c_spamscore = <span class="hljs-formula"><span class="hljs-formula">${eval:$</span></span>acl_c_spamscore+60}         set acl_c_bouncemessage = <span class="hljs-formula"><span class="hljs-formula">$acl_c_bouncemessage HELO $</span></span>sender_helo_name is forged;</code> </pre><br><br>  +60 points to spammers, indicating as an argument HELO our mail server (receiving). <br><br><pre> <code class="hljs cpp">#---------------------------------------------------------------------------------- #------------------------------Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> wrong HELO's----------------------------    warn !condition = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {\                                 {match{$sender_helo_name}{^.+\\.((?i)[az]+)\$}}\                                 [...]                              }{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}\                       }         <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> acl_c_spamscore = ${eval:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">20</span></span>}         <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> acl_c_bouncemessage = $acl_c_bouncemessage HELO name is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> \ Fully Qualified Domain Name;</code> </pre><br><br>  +20 spam points if HELO is not a FQDN. <br><br><pre> <code class="hljs mel">#---------------------------------------------------------------------------------- #--------------------------Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> forged HELO arguments-----------------------    warn !<span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> or {\                                 {eq{$sender_helo_name}{$sender_host_name}}\                              }\                       }         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">20</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage HELO not equals Hostname;</code> </pre><br><br>  Another 20 if the HELO argument does not match the primary DNS record (A) for the sending host. <br><br><pre> <code class="hljs mel">#---------------------------------------------------------------------------------- #------------------------Handler <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> suspicious HELO arguments---------------------    warn !<span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup {$sender_helo_name}wildlsearch{/CONFIG_PREFIX/\ additional/trusted_zones}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">20</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Suspicious HELO argument;</code> </pre><br><br>  Good old trusted_zones is now used to check the HELO argument. <br>  +20 points to Chinese, Koreans and other Mexican Japanese. <br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#----------------------------------------------------------------------------------</span></span></code> </pre><br><br>  And finally - the correct implementation of the DNSBL system survey: <br><br>  In no case can you turn off a node that glows only in one such system.  There is a high probability that he got there by accident. <br><br>  Do not completely abandon the use of DNSBL - it is a powerful filtering tool. <br><br>  Only if you simultaneously hit two or more of these systems, you can declare a node as a spam sender. <br><br><pre> <code class="hljs mel">#-------------------------------DNSBL processing section---------------------------    warn dnslists = sbl.spamhaus.org         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">60</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> DNSBL $dnslist_domain;    warn dnslists = bl.spamcop.net         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">60</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> DNSBL $dnslist_domain;    warn dnslists = dnsbl.sorbs.net         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">60</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> DNSBL $dnslist_domain;    warn dnslists = dul.ru         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">60</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Listed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> DNSBL $dnslist_domain;</code> </pre><br><br>  +60 points for getting into any of the ‚Äúblack DNS lists‚Äù.  If you hit the two lists at the same time, the node will receive 120 points, which is enough to stop receiving mail from it, but not enough to automatically add to the local blacklist.  If the admin of the sending mail server has time to quickly unsubscribe from at least one DNSBL, then the transfer of mail will suffer minimally. <br><br>  DNSBL polling in combination with other checks - eliminates spammers very well and it is often these points that become decisive for placing the ip-address in the local blacklist for a week. <br><br><pre> <code class="hljs dos">#-----------------------------------------------------------------------------------    warn !<span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> = sender/callout=<span class="hljs-number"><span class="hljs-number">3</span></span>m,defer_ok         <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> acl_c_spamscore = ${eval:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">60</span></span>}         <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> acl_c_bouncemessage = $acl_c_bouncemessage Cannot complete sender <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span>;</code> </pre><br><br>  This is where callout is made.  The server is given a maximum of 3 minutes to check (otherwise there is a risk that the ‚Äúgood‚Äù sender will fall off without waiting for the end of the check, it hangs connected), the unavailability of the remote node is considered to be successful passing the check.  Those.  The node will receive 60 points if it sent mail from an absent (most often - fake) email address. <br><br>  That is why you should not make legitimate emails from addresses like www@webserver.example.org.  Callout is a common filtering method and is supported by many current implementations of MTA. <br><br><pre> <code class="hljs perl">    <span class="hljs-keyword"><span class="hljs-keyword">accept</span></span> condition = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> &gt;{$acl_c_spamscore}<span class="hljs-string"><span class="hljs-string">{145}</span></span>}</code> </pre><br>  There is a little trick - nodes with more than 145 points are true candidates for a local blacklist.  There is no need to check them more, we transfer them to the next acl and there is a strong ban. <br><br><pre> <code class="hljs perl">    <span class="hljs-keyword"><span class="hljs-keyword">accept</span></span> delay = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore/<span class="hljs-number"><span class="hljs-number">2</span></span>}<span class="hljs-keyword"><span class="hljs-keyword">s</span></span></code> </pre><br><br>  Who has not scored 145 points - passes the torture by delaying the session: the receiving MTA imitates a bad connection and ‚Äúhangs‚Äù for a number of seconds equal to half the number of ‚Äúspam points‚Äù.  For example, a node with 60 points will be ‚Äúsuspended‚Äù for 30 seconds. <br><br>  Usually spammers do not have that amount of time waiting for an answer and they fall off in 15-20 seconds. <br><br>  So we got to the last acl, checking the correctness of the parameters of the SMTP session (it works after RCPT TO :).  The ‚Äúsuspension‚Äù of the sum of points and the decision of the further fate of the letter occur in it: <br><br><pre> <code class="hljs mel">acl_check_rcpt: [...] #------Spamtraps check-------    warn <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup {$local_part@$domain}lsearch{/CONFIG_PREFIX/\ additional/spamtraps}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">50</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage Spamtrap hit;</code> </pre><br><br>  +50 points for getting into a spam trap. <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#----------------------------</span></span></code> </pre><br><br>  The list of trap addresses is in the spamtraps file, by email to the line: <br><br><pre> <code class="hljs scala">spamtrap<span class="hljs-meta"><span class="hljs-meta">@hornsnhoofs</span></span>.com honeypot<span class="hljs-meta"><span class="hljs-meta">@hornsnhoofs</span></span>.com</code> </pre><br><br>  And so on. <br><br>  Using your own spam traps is a good way to hide from the big mailers, digging internet bots for emails.  Then these addresses are transmitted, sold and just distributed as part of databases for mailings.  That is - spread by spammers among themselves. <br><br>  The difficulty arises in the initial distribution of such addresses, so that they would be sent to spammers.  For example, for this you can use a mechanism such as <a href="http://www.monkeys.com/wpoison/">wpoison</a> on the company's main site.  The main thing is not to forget about the prohibition of their indexing by search engines (via robots.txt or META CONTENT = ‚ÄúNOINDEX, NOFOLLOW‚Äù). <br><br>  Often, old domains already have abandoned or even never existed addresses, which, however, goes one spam.  These are ideal candidates for use as spamtraps.  The main thing is that they do not use such a box for a long time, and even better so that they are never used. <br><br>  Paradoxically, but the fact is that many of the trap addresses I use today have never existed anywhere except in spam databases.  It is not known how they appeared there, but they regularly send spam.  Study the logs of your mailer for a long period, for sure there will be something similar there. <br><br><pre> <code class="hljs mel">#---------------------------Blacklist Processing Section------------------------    drop !senders = :         !<span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> &lt;{$acl_c_spamscore}{<span class="hljs-number"><span class="hljs-number">150</span></span>}}         message = Connection closed. Spamscore threshold (<span class="hljs-number"><span class="hljs-number">150</span></span> points) reached. \                   Spamscore is $acl_c_spamscore! \                   Warning: IP [$sender_host_address] added to Blacklist. \                   Details: $acl_c_bouncemessage         <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                         {\                             insert into antispam.blacklist (IP,Timestamp)\                             values (<span class="hljs-string"><span class="hljs-string">'${sender_host_address}'</span></span>,${tod_epoch});\                         }\                      }</code> </pre><br><br>  Those who could score 150 points and more are declared champions!  Their ip-addresses are placed in the local blacklist and the fame of them does not cease the week. <br>  The nodes that are in it are dropped right after the ‚ÄúMAIL FROM:‚Äù command is sent. <br><br><pre> <code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#-------------------------------------------------------------------------------</span></span></code> </pre><br><br>  As already mentioned, the life of an entry in my blacklist is a week (604800 seconds).  Bases are cleaned with a crown every hour: <br><br><pre> <code class="hljs pgsql">#!/bin/bash echo "delete from blacklist where Timestamp &lt; `echo "\`<span class="hljs-type"><span class="hljs-type">date</span></span> +%s\`<span class="hljs-number"><span class="hljs-number">-604800</span></span>" | bc`;" | /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/mysql -u mta -pmtapass antispam echo "optimize table blacklist" | /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/bin/mysql -u mta -pmtapass antispam</code> </pre><br><pre> <code class="hljs mel">    deny <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> &gt;{$acl_c_spamscore}{<span class="hljs-number"><span class="hljs-number">100</span></span>}}         <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ={$acl_c_validrcpt}{<span class="hljs-number"><span class="hljs-number">1</span></span>}}         message = Message rejected. Spamscore threshold (<span class="hljs-number"><span class="hljs-number">100</span></span> points) reached. \                   Spamscore is $acl_c_spamscore! Details: acl_c_bouncemessage</code> </pre><br><br>  It's simple.  Scored more than 100 points - received "550 Message rejected.".  In this case, the log records the number of points scored and reports on checks inundated.  The same information goes along with the mail trap on the other side of the wire.  Suddenly someone will come in handy for debugging. <br><br>  It is important to send an bluff without breaking the session (not bringing the letter to the reception in acl and starting processing by routers and transports), otherwise the events may turn out not very good for you: in the worst case, your server can be used as a sender. <br><br>  Briefly about sending spam as a return: if you write a spam letter to a non-existent email address nosuchaddress@hornsnhoofs.com, pointing to ‚ÄúMAIL FROM:‚Äù address vasyapupkin@gmail.com, and the letter will be accepted by the mail server, and after receiving the mail the router determines that the destination address does not exist, then the server will wrap the spam letter in a new envelope, add the lines of its non-response and return it to the ‚Äúsender‚Äù - to the unsuspecting Vasya Pupkin on Gmail.com. <br><br>  Further, the corporation of dough will quickly add your server to the ‚Äúblack list‚Äù and block the reception of mail from its ip.  Now you are writing justification letters to tehsapport, and the little spammers giggle. <br><br>  However, this is a very brief description of the phenomenon and there are other ways to protect against it, but the tactics of transferring an arc pound without stopping the session are the most correct. <br><br>  You can also add this info to the service headers of the letter, for easier debugging.  But it is very optional. <br><pre> <code class="hljs mel">    accept <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> &lt;{$acl_c_spamscore}{<span class="hljs-number"><span class="hljs-number">70</span></span>}}           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ={$acl_c_validrcpt}{<span class="hljs-number"><span class="hljs-number">1</span></span>}}</code> </pre><br>  Nodes with less than 70 spam points are considered legitimate, we accept a letter from them if the recipient's address ( <code>$acl_c_validrcpt</code> ) exists. <br><br>  I will not describe how this variable gets its value, since  this depends on the way the data about the mail users is stored.  I will say that the true value (or just 1) from me it gets after checking the email address of the recipient in Active Directory through an LDAP search.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be done for any database with users, as long as it is supported by eczema. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most interesting thing happens with nodes that have collected from 70 to 100 points. We cannot refer them to either legitimate hosts or spam mailers. Therefore, we wrap them in a greylist for 29 minutes (the interval is chosen with the expectation of the MTA-sender for the second run of the mail queue):</font></font><br><br><pre> <code class="hljs mel">#--------------------------Greylist Processing Section--------------------------    defer <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ={$acl_c_validrcpt}{<span class="hljs-number"><span class="hljs-number">1</span></span>}}          <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> Source from antispam.greylist where \                              Source=<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span> \                              and Timestamp &gt; ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$tod_epoch<span class="hljs-number"><span class="hljs-number">-1740</span></span>} limit <span class="hljs-number"><span class="hljs-number">1</span></span>\                          }{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}\                       }          message = Message deferred. Try again later. You was been already greylisted.    accept <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup {$acl_c_reverse_zone}wildlsearch{CONFIG_PREFIX/\ additional/dynamic_pools}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ={$acl_c_validrcpt}{<span class="hljs-number"><span class="hljs-number">1</span></span>}}           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> Source from antispam.greylist where \                              Source=<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span> \                              and grey_hash = <span class="hljs-string"><span class="hljs-string">'${md5:${lc:$sender_address\ $local_part@$domain}}'</span></span> \                              and Timestamp &lt; ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$tod_epoch<span class="hljs-number"><span class="hljs-number">-1740</span></span>} limit <span class="hljs-number"><span class="hljs-number">1</span></span> \                          }{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}\                        }           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> from antispam.greylist where \                              Source=<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span> \                              and grey_hash = <span class="hljs-string"><span class="hljs-string">'${md5:${lc:$sender_address\ $local_part@$domain}}'</span></span> \                          }\                        }    accept !<span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup {$acl_c_reverse_zone}wildlsearch{CONFIG_PREFIX/\ additional/dynamic_pools}{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}}           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ={$acl_c_validrcpt}{<span class="hljs-number"><span class="hljs-number">1</span></span>}}           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> Source from antispam.greylist where \                              Source=<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span> \                              and grey_hash = <span class="hljs-string"><span class="hljs-string">'${md5:${lc:$sender_address\ $local_part@$domain}}'</span></span> \                              and Timestamp &lt; ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$tod_epoch<span class="hljs-number"><span class="hljs-number">-1740</span></span>} limit <span class="hljs-number"><span class="hljs-number">1</span></span> \                          }{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">0</span></span>}\                        }           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              insert into antispam.whitelist (IP, Timestamp) \                              values (<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span>,$tod_epoch) \                          }{<span class="hljs-number"><span class="hljs-number">1</span></span>}{<span class="hljs-number"><span class="hljs-number">1</span></span>}\                        }           <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> from antispam.greylist where \                              Source=<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span> \                              and grey_hash = <span class="hljs-string"><span class="hljs-string">'${md5:${lc:$sender_address\ $local_part@$domain}}'</span></span> \                          }\                        }    defer <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ={$acl_c_validrcpt}{<span class="hljs-number"><span class="hljs-number">1</span></span>}}          <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> &gt;={$acl_c_spamscore}{<span class="hljs-number"><span class="hljs-number">70</span></span>}}          <span class="hljs-keyword"><span class="hljs-keyword">condition</span></span> = ${lookup mysql \                          {\                              insert into antispam.greylist (Source,grey_hash,Timestamp) \                              values (<span class="hljs-string"><span class="hljs-string">'$sender_host_address'</span></span>,\ <span class="hljs-string"><span class="hljs-string">'${md5:${lc:$sender_address$local_part@$domain}}'</span></span>,\                              ${tod_epoch}); \                          }\                        }          message = Message deferred. Spamscore is $acl_c_spamscore! Try again later. \                    Greylisting <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> progress. Details: $acl_c_bouncemessage #-----------------------------------------------------------------------------</code> </pre><br>  defer  ,  c   4xx,             ,    . <br><br>             : SMTP-     451     ,        ¬´ ¬ª,        . <br><br>    ¬´¬ª,    :   ip-        . <br><br>   ,   ,     greylist,    : <code>Source varchar(15)</code> , <code>grey_hash varchar(32)</code> ,  <code>Timestamp int(11)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The Source field contains the sender's ip address, grey_hash the md5 hash from the sender and recipient addresses, and Timestamp the time to add the record in unix_time format. In addition to it, greylisting also requires a whitelist table, which allows you to add the addresses of nodes that have passed greylisting there. The whitelist table format completely repeats that for the blacklist table described above. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The tables are also cleared by the crown: the records are stored in the greylist for 24 hours, for whitelist - for the month.</font></font><br><br><pre> <code class="hljs perl">    deny message = Message rejected. No such user here. Relaying denied. $acl_c_support         set acl_c_spamscore = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore+<span class="hljs-number"><span class="hljs-number">5</span></span>}         set acl_c_bouncemessage = $acl_c_bouncemessage RCPT Fail;         delay = ${<span class="hljs-keyword"><span class="hljs-keyword">eval</span></span>:$acl_c_spamscore/<span class="hljs-number"><span class="hljs-number">2</span></span>}<span class="hljs-keyword"><span class="hljs-keyword">s</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last filtering rule, according to recommendations of the best dog breeders, is prohibiting His work is somewhat similar to the last rule in a ‚Äúclosed‚Äù firewall </font></font><code>deny ip from any to any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it only affects the SMTP session. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additionally, for each incorrect address in ‚ÄúRCPT TO:‚Äù (SMTP protocol allows you to specify several recipients for one letter), the node receives 5 additional spam points, up to and including the unconditional blocking threshold. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh yes - torture a delayed session after each ‚ÄúRCPT TO:‚Äù also has a place to be. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using at least these constructions in the mail server configuration will cut off about 90-95% of spam without increasing the number of false positives.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creative independent use of this technique (counting and weighing spam coefficients) makes it possible to get rid of spam almost completely (except, perhaps, mailings from public mail systems like gmail.com or mail.ru, but there, as a rule, the account is also monitored block) without the use of context filtering systems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if the context filter is also planned to be used, this way you can unload the text analyzer due to a strong reduction in the amount of input data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the article I didn‚Äôt deal with such technologies as SPF and DKIM, but if you wish, you can use them as ‚Äúwhitening functions‚Äù (reducing the number of spam points), working in the same way as those that were considered. </font><font style="vertical-align: inherit;">If the community has an interest in these systems, I will try to consider them separately.</font></font></div><p>Source: <a href="https://habr.com/ru/post/133215/">https://habr.com/ru/post/133215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133208/index.html">The source code of the Doom III engine is available under a free license.</a></li>
<li><a href="../133211/index.html">Guideman - guide on selected male attributes</a></li>
<li><a href="../133212/index.html">AnjLab SQL Profiler 1.2 released</a></li>
<li><a href="../133213/index.html">DCA / DCS Communications Error on high end Oracle Sun servers</a></li>
<li><a href="../133214/index.html">Qt Quick: best practices</a></li>
<li><a href="../133217/index.html">And again the curve of the state program</a></li>
<li><a href="../133219/index.html">How to: VM in files on local Citrix XenServer</a></li>
<li><a href="../133220/index.html">31 effective programming methods for Android</a></li>
<li><a href="../133221/index.html">MTS subscribers, change the password from the Internet Assistant</a></li>
<li><a href="../133227/index.html">Yahoo has disabled Site Explorer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>