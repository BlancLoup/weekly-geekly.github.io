<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stencil Buffer Implementation Example with CUDA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stencil buffer is used to mask reflections in places where they actually do not exist. The Stencil technique is used in OpenGL and DirectX. Before app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stencil Buffer Implementation Example with CUDA</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/547/70f/709/54770f709a792e306265314e0bd539b9.jpg"><br>  Stencil buffer is used to mask reflections in places where they actually do not exist.  The Stencil technique is used in OpenGL and DirectX.  Before applying the algorithm, the Stencil test is performed and in those places where there is no image the pixel shader will not be rendered.  So we stop the extra work. <br><a name="habracut"></a><br><br>  Stencil is stored in a buffer with depth.  For example, in the format D3DFMT_D24S8 24 bits - bits of depth and 8 bits - Stencil.  For simplicity, we will assume below that Stencil is stored in the last bit.  If this bit = 1, then the pixel is active.  Thus, the simplified algorithm presents the following steps: <br><br><ol><li>  Reset (fill with zeros) Stencil buffer. </li><li>  We start recording and draw a plane in Stencil buffer, relative to which we will consider the reflection.  Where there is a mirror, units will be stored, and where there is no mirror, zeros. </li><li>  We reflect all the geometry relative to the plane using a separate matrix, and then draw the reflection, simultaneously running the Stencil test. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, where the mirror was in the image, the reflection will be displayed.  And where there is none, nothing will change. <br><br><h2>  CUDA software implementation </h2><br><br>  CUDA, unfortunately, the mechanism Stencil-test is missing.  This is a very useful trick and I will explain how to get around this limitation in the next article, but for now let's look at the implementation details. <br><br>  So, we get stencil buffer size exactly (N / 32) * sizeof (int) bytes.  And we tie a texture to it. <br><br><pre><code class="cpp hljs">cudaMalloc((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**)&amp;m_stencilBuffer, N*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)/<span class="hljs-number"><span class="hljs-number">32</span></span>); cudaBindTexture(<span class="hljs-number"><span class="hljs-number">0</span></span>, stencil_tex, m_stencilBuffer, N*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)/<span class="hljs-number"><span class="hljs-number">32</span></span>);     -  (.h )  : Texture&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, cudaReadModeElementType&gt; stencil_tex; ,        : <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __device__ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g_stencilMask[<span class="hljs-number"><span class="hljs-number">32</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00000001</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000002</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000004</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000008</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000010</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000020</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000040</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000080</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000100</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000200</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000400</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000800</span></span>, <span class="hljs-number"><span class="hljs-number">0x00001000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00002000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00004000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00008000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00010000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00020000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00040000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00080000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00100000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00200000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400000</span></span>, <span class="hljs-number"><span class="hljs-number">0x00800000</span></span>, <span class="hljs-number"><span class="hljs-number">0x01000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x02000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x04000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x08000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x10000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x20000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x40000000</span></span>, <span class="hljs-number"><span class="hljs-number">0x80000000</span></span> };</code> </pre> <br><br>  For those kernels that only read the stencil buffer, the macro should be applied at the beginning of the kernel as follows: <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_kernel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(‚Ä¶)</span></span></span><span class="hljs-function"> </span></span>{ uint tid = blockDim.x * blockIdx.x + threadIdx.x; STENCIL_TEST(tid); <span class="hljs-comment"><span class="hljs-comment">// my code here }</span></span></code> </pre><br><br>  In practice (GTX560), such a stencil test is about 20-25% faster than a simple check of the check type: <br><br><pre> <code class="cpp hljs">uint activeFlag = a_flags[tid]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(activeFlag==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre><br><br>  However, taking into account memory savings, there is definitely a profit.  It should also be noted that on video cards with a less wide bus (for example, GTS450), the acceleration may be more significant. <br><br>  So, it remains to implement only the entry in the stencil buffer.  First, we read the value for everything in the warp from the stealth buffer to the variable activeWarp;  Then each thread gets its bit from this variable using the logical &amp; and stores it in the active variable.  At the end of the kernel, we will collect all active variables for the given warp value back into one 32-bit uint, and the zero warp stream will write the result back to memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// (tid &gt;&gt; 5) same as (tid/32) // (tid &amp; 0x1f) same as (tid%32) __global__ void my_kernel2(‚Ä¶,uint* a_stencilBuffer) { uint tid = blockDim.x * blockIdx.x + threadIdx.x; uint activeWarp = a_stencilBuffer[tid &gt;&gt; 5]; if(activeWarp==0) // all threads in warp inactive return; // each threads will store it's particular bit from group of 32 threads uint active = activeWarp &amp; g_stencilMask[tid&amp;0x1f]; if(!active) goto WRITE_BACK_STENCIL_DATA; // my code here WRITE_BACK_STENCIL_DATA: WriteStencilBit(tid, a_stencilBuffer, active); }</span></span></code> </pre><br>  If the stream is inactive, it will immediately go to the ridge of the kernel.  If for any reason you have decided within your code that this thread should be inactive, do this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(want to kill thread) { active = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> WRITE_BACK_STENCIL_DATA; }</code> </pre><br><br>  In the example, the label and the goto operator are intentionally used.  Although it is a bad programming style, in this case it adds security to your code.  The fact is that you are guaranteed to reach WriteStencilBit function code.  If for some reason you decide to make a return inside your code, everything will break down (let's discuss why later).  Instead of return, you need to put goto WRITE_BACK_STENCIL_DATA so that before exiting, all the threads from the warp can collect data, and the zero stream (zero inside the warp-a) will write it to the stencil buffer.  Actually, the WriteStencilBit function looks as follows: <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">device__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteStencilBit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, uint* a_stencilBuffer, uint value)</span></span></span><span class="hljs-function"> </span></span>{ uint stencilMask = __ballot(value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((tid &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// same as tid%32 == 0 a_stencilBuffer[tid &gt;&gt; 5] = stencilMask; }</span></span></code> </pre><br><br>  The __ballot () function returns uint, where each i-th bit is 1 if and only if what is in its argument is not zero.  That is, it does exactly what is needed there, stitching back into the uint flags from different threads inside the warp. <br><br>  The __ballot () function belongs to the so-called ‚Äúwarp vote functions‚Äù and works very quickly.  Unfortunately, it is only available for compute capability 2.0, that is, video cards with Fermi architecture.  Important note on her work, the following code will be wrong: <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">device__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteWrongStencilBit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, uint* a_stencilBuffer, uint value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((tid &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// same as tid%32 == 0 a_stencilBuffer[tid &gt;&gt; 5] = __ballot(value); }</span></span></code> </pre><br><br>  The fact is that __ballot () will always put 0 in those bits whose streams are currently masked.  And all streams with a number inside the warp that are not equal to zero (1..31) will be masked and will not fall inside the if operator, therefore 1..31 bits of the result of the __ballot () function for such a code will always be zero.  From here the truth follows an interesting conclusion.  If you are guaranteed to write for video cards with Fermi architecture, then even for kernels that are written in stencil buffer, you can kill the stream as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(want to kill thread) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre><br><br>  Thus, the threads for which you made return will be masked and __ballot () will return zeros for the corresponding bits in its result.  There is truth one subtlety.  At least for a zero stream inside the warp, you cannot do this, otherwise the result will simply not be written back.  Therefore, in fact, you can only do so. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(want to kill thread &amp;&amp; (tid&amp;<span class="hljs-number"><span class="hljs-number">0x1f</span></span>!=<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre><br><br>  Or use the form suggested above: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(want to kill thread) { active = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> WRITE_BACK_STENCIL_DATA; }</code> </pre><br><br>  Implementation features for older hardware (G80-GT200) <br><br>  Let us now consider which extensions must be made in order for the stencil to work effectively on older GPUs.  The __ballot () function is not supported on these video cards.  Let's rewrite the WriteStencilBit function in accordance with the capabilities that we have: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CURR_BLOCK_SIZE&gt; __<span class="hljs-function"><span class="hljs-function">device__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteStencilBit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, uint* a_stencilBuffer, uint value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> COMPUTE_CAPABILITY &gt;= COMPUTE_CAPABILITY_GF100 uint stencilMask = __ballot(value); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((tid &amp; 0x1f) == 0) a_stencilBuffer[tid &gt;&gt; 5] = stencilMask; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> COMPUTE_CAPABILITY &gt;= COMPUTE_CAPABILITY_GT200 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(__all(value==0)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((tid &amp; 0x1f) == 0) a_stencilBuffer[tid &gt;&gt; 5] = 0; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(__all(value)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((tid &amp; 0x1f) == 0) a_stencilBuffer[tid &gt;&gt; 5] = 0xffffffff; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { __shared__ uint active_threads[CURR_BLOCK_SIZE/32]; uint* pAddr = active_threads + (threadIdx.x &gt;&gt; 5); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((tid &amp; 0x1f) == 0) *pAddr = 0; atomicOr(pAddr, value); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((tid &amp; 0x1f) == 0) a_stencilBuffer[tid &gt;&gt; 5] = *pAddr; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> __shared__ uint active_threads[CURR_BLOCK_SIZE]; active_threads[threadIdx.x] = value; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((threadIdx.x &amp; 0x1) == 0) active_threads[threadIdx.x] = value | active_threads[threadIdx.x+1]; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((threadIdx.x &amp; 0x3) == 0) active_threads[threadIdx.x] = active_threads[threadIdx.x] | active_threads[threadIdx.x+2]; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((threadIdx.x &amp; 0x7) == 0) active_threads[threadIdx.x] = active_threads[threadIdx.x] | active_threads[threadIdx.x+4]; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((threadIdx.x &amp; 0xf) == 0) active_threads[threadIdx.x] = active_threads[threadIdx.x] | active_threads[threadIdx.x+8]; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((threadIdx.x &amp; 0x1f) == 0) active_threads[threadIdx.x] = active_threads[threadIdx.x] | active_threads[threadIdx.x+16]; uint* perWarpArray = active_threads + ((threadIdx.x &gt;&gt; 5) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 5); if((tid &amp; 0x1f) == 0) a_stencilBuffer[tid &gt;&gt; 5] = perWarpArray[0]; #endif }</span></span></span></span></code> </pre><br><br>  Thus, we can make atomics in shared memory + 2 voting functions are available, __any and __all, so that we can use them.  In other cases, only classical reduction remains. <br><br><h2>  Testing Stencil </h2><br>  For raytracing needs, this stencil buffer came up pretty well.  On my old laptop's GTX560, I get about 4 billion calls per second (i.e. 4 billion empty calls per second) - not bad, right ?!  As the tracing depth increased, performance dropped slightly according to how many real-world objects we see.  Tests were specifically made on the most simple reflective scene: <br><img src="https://habrastorage.org/storage2/547/70f/709/54770f709a792e306265314e0bd539b9.jpg"><br>  The FPS dynamics are as follows: 30, 25, 23.7, 20, 19.4, 18.8 </div><p>Source: <a href="https://habr.com/ru/post/151640/">https://habr.com/ru/post/151640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151634/index.html">About how I ported Java to donet</a></li>
<li><a href="../151635/index.html">Erasmus Mundus Scholarship for Higher Education in Europe</a></li>
<li><a href="../151637/index.html">Apple encodes video using JPEG, JSON and <canvas></a></li>
<li><a href="../151638/index.html">How Larry Laffer spoke in Russian or About the interpreters of the Sierra quests</a></li>
<li><a href="../151639/index.html">A simple but illustrative example of using TDD</a></li>
<li><a href="../151641/index.html">How I Invented the Bike, Learning Technology</a></li>
<li><a href="../151643/index.html">Admission to the magistracy in Germany</a></li>
<li><a href="../151646/index.html">We raise our own Git GitBlit server on Openshift hosting</a></li>
<li><a href="../151647/index.html">Debugging Incomprehensible Errors in Magento</a></li>
<li><a href="../151650/index.html">7 obvious rules for secure system administration of physical servers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>