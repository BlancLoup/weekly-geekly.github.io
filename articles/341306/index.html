<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a server for streaming video: a chapter from a book on PHP from our developer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Very talented people work in Skyeng. For example, Words backend developer Sergei Zhuk wrote a book about event-oriented PHP based on ReactPHP, based o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a server for streaming video: a chapter from a book on PHP from our developer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zq/xo/zi/zqxoziijipti0geomf1rz64w_ds.jpeg"><br><br>  Very talented people work in Skyeng.  For example, Words backend developer Sergei Zhuk wrote a book about event-oriented PHP based on ReactPHP, based on his blog‚Äôs publications.  The book is in English, we decided to translate one self-sufficient chapter in the hope that it would be useful to someone.  Well, give a discount link to all the work. <br><a name="habracut"></a><br><br>  In this chapter, we will look at creating an elementary asynchronous server for video streaming on the <a href="http/">ReactPHP Http Component</a> .  This is a high-level component that provides a simple asynchronous interface for handling incoming connections and HTTP requests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/3q/f0/lt/3qf0lt18xwmen2mb3ydnkkd1ldk.png"><br><br>  To raise the server we need two things: <br>  - server instance (React \ Http \ Server) for processing incoming requests; <br>  - socket (React \ Socket \ Server) for detecting incoming connections. <br><br>  First, let's make a very simple Hello world server to understand how it all works. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Socket</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span> <span class="hljs-title"><span class="hljs-title">as</span></span> <span class="hljs-title"><span class="hljs-title">SocketServer</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">Factory</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-comment"><span class="hljs-comment">// init the event loop $loop = Factory::create(); // set up the components $server = new Server( function (ServerRequestInterface $request) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], "Hello world\n" ); }); $socket = new SocketServer('127.0.0.1:8000', $loop); $server-&gt;listen($socket); echo 'Listening on ' . str_replace('tcp:', 'http:', $socket-&gt;getAddress()) . "\n"; // run the application $loop-&gt;run();</span></span></code> </pre> <br>  The main logic of this server is contained in a callback function that is passed to the server constructor.  Callback is performed in response to each incoming request.  It takes the instance of the <code>Request</code> object and returns a <code>Response</code> object.  The constructor of the <code>Response</code> class accepts the response code, the headers and the response body.  In our case, in response to each request, we return the same static line Hello world. <br><br>  If we run this script, it will run indefinitely.  A running server keeps track of incoming requests.  If we open the address <i>127.0.0.1:8000</i> in our browser, we will see the string Hello world.  Fine! <br><br><img src="https://habrastorage.org/webt/b7/rq/n_/b7rqn_bo88xov7l06ehbsmbqy-c.png"><br><br><h3>  Simple streaming video </h3><br>  Let's now try to do something more interesting.  The React \ Http \ Response constructor can accept a readable stream ( <code>ReadableStreamInterface</code> instance) as the response body, which allows us to transmit the <i>data stream</i> directly to the body.  For example, we can open the bunny.mp4 file (you can download it from <a href="http/media/bunn">Github</a> ) in read mode, create a <code>ReadableResourseStream</code> with it, and provide this stream as the response body: <br><br><pre> <code class="php hljs">$server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($loop)</span></span></span><span class="hljs-function"> </span></span>{ $video = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableResourceStream( fopen(<span class="hljs-string"><span class="hljs-string">'bunny.mp4'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), $loop ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'video/mp4'</span></span>], $video ); });</code> </pre> <br>  To create an <code>ReadableResponseStream</code> instance, we need a cycle of events, we have to pass it to the closure.  In addition, we changed the <code>Content-Type</code> header to <code>video/mp4</code> , so that the browser understands that in response we send it a video. <br><br>  You do not need to declare the <code>Content-Length</code> header, since ReactPHP automatically uses chunked transfer and sends the corresponding <code>Transfer_Encoding: chunked</code> header <code>Transfer_Encoding: chunked</code> . <br><br>  Let's now refresh the browser window and watch the streaming video: <br><br><img src="https://habrastorage.org/webt/od/w-/to/odw-toagfpz3apetjz6ezjm9_gw.png"><br><br>  Super!  We made a streaming video server with a few lines of code! <br><br>  It is important to create an <code>ReadableResourseStream</code> instance directly in the server's callback function.  Remember the asynchrony of our application.  If we create a stream outside the callback and just pass it, no streaming will happen.  Why?  Because the process of reading a video file and processing incoming server requests work asynchronously.  This means that while the server is waiting for new connections, we also begin to read the video file. <br><br>  To verify this, we can use stream events.  Each time a readable stream receives data from its source, it fires the <code>data</code> event.  We can assign a handler to this event that will issue a message every time we read the data from the file: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Server</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">Factory</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Stream</span></span>\<span class="hljs-title"><span class="hljs-title">ReadableResourceStream</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; $loop = Factory::create(); $video = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableResourceStream( fopen(<span class="hljs-string"><span class="hljs-string">'bunny.mp4'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), $loop ); $video-&gt;on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Reading file\n"</span></span>; }); $server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'video/mp4'</span></span>], $stream ); }); $socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \React\Socket\Server(<span class="hljs-string"><span class="hljs-string">'127.0.0.1:8000'</span></span>, $loop); $server-&gt;listen($socket); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Listening on '</span></span> . str_replace(<span class="hljs-string"><span class="hljs-string">'tcp:'</span></span>, <span class="hljs-string"><span class="hljs-string">'http:'</span></span>, $socket-&gt;getAddress()) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $loop-&gt;run();</code> </pre> <br>  When the interpreter reaches the last line <code>$loop-&gt;run();</code>  , the server starts to expect incoming requests, and at the same time we start reading the file. <br><br>  Therefore, there is a possibility that by the time when the first request comes to the server, we have already reached the end of the video file, and we will not have data for streaming.  When the request handler receives an already closed response stream, it simply sends an empty response body, which results in a blank browser page. <br><br><img src="https://habrastorage.org/webt/ac/0i/ga/ac0igagmg4dm_fljvqon4p9x4b8.png"><br><br><h3>  Improvements </h3><br>  Next we will try to improve our small server.  Suppose we want to give the user the ability to specify the name of the file for streaming directly in the query string.  For example, if you enter <i>127.0.0.1/?video=bunny.mp4</i> in the browser address bar, the server will start streaming the file bunny.mp4.  We will store the streaming files in the media directory.  Now we need to somehow get the parameters from the request.  The request object, which we get in the request handler, contains the <code>getQueryParams()</code> method, which returns a GET array, similarly to the <code>$_GET</code> global variable: <br><br><pre> <code class="php hljs">$server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($loop)</span></span></span><span class="hljs-function"> </span></span>{ $params = $request-&gt;getQueryParams(); $file = $params[<span class="hljs-string"><span class="hljs-string">'video'</span></span>] ?? <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Video streaming server'</span></span> ); } $filePath = <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . DIRECTORY_SEPARATOR . <span class="hljs-string"><span class="hljs-string">'media'</span></span> . DIRECTORY_SEPARATOR . $file; $video = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableResourceStream( fopen($filePath, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), $loop ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'video/mp4'</span></span>], $video ); });</code> </pre> <br>  Now, to watch the video bunny.mp4, we have to go to <i>127.0.0.1:8000?video=bunny.mp4</i> .  The server checks the incoming request for GET parameters.  If we find the <code>video</code> parameter, we think that this is the name of the video file that the user wants to see.  Then we build the path to this file, open the <i>readable stream</i> and pass it in response. <br><br>  But there are problems.  See them? <br><br>  - What if there is no such file on the server?  We must in this case return page 404. <br>  - Now we have a fixed <code>Content-Type</code> value in the header.  We need to define it in accordance with the specified file. <br>  - The user can request any file on the server.  We must limit the request to only those files that we are ready to give him. <br><br><h3>  Check for file </h3><br>  Before opening the file and creating the stream, we need to check if the file exists on the server at all.  If not, return 404: <br><br><pre> <code class="php hljs">$server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($loop)</span></span></span><span class="hljs-function"> </span></span>{ $params = $request-&gt;getQueryParams(); $file = $params[<span class="hljs-string"><span class="hljs-string">'video'</span></span>] ?? <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Video streaming server'</span></span> ); } $filePath = <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . DIRECTORY_SEPARATOR . <span class="hljs-string"><span class="hljs-string">'media'</span></span> . DIRECTORY_SEPARATOR . $file; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_exists($filePath)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">404</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">"Video $file doesn't exist on server."</span></span> ); } $video = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableResourceStream( fopen($filePath, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), $loop ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'video/mp4'</span></span>], $video ); });</code> </pre> <br>  Now our server will not crash if the user has requested the wrong file.  We give the correct answer: <br><br><img src="https://habrastorage.org/webt/pg/4z/6y/pg4z6yr6q5ykwyvoqn1n8kqan78.png"><br><br><h3>  Determining the MIME Type of a File </h3><br>  PHP has a great <code>mime_content_type()</code> function that returns the MIME type of a file.  With its help, we can determine the MIME type of the requested video file and replace it with the <code>Content-Type</code> value specified in the header: <br><br><pre> <code class="php hljs">$server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Server( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($loop)</span></span></span><span class="hljs-function"> </span></span>{ $params = $request-&gt;getQueryParams(); $file = $params[<span class="hljs-string"><span class="hljs-string">'video'</span></span>] ?? <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Video streaming server'</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_exists($filePath)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">404</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">"Video $file doesn't exist on server."</span></span> ); } $video = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableResourceStream( fopen($filePath, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), $loop ); $type = mime_content_type($filePath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; $type], $video ); });</code> </pre> <br>  Great, we removed the <code>Content-Type</code> value that is fixed in the header, now it is automatically determined according to the requested file. <br><br><h3>  Restriction on file requests </h3><br>  There is a problem with the request files.  The user can specify any file on the server in the query string.  For example, if the code of our server is in server.php and we specify such a request in the address bar of the browser: <i>127.0.0.1:8000/?video=../server.php</i> , then the result will be the following: <br><br><img src="https://habrastorage.org/webt/7s/by/az/7sbyaz7itvskgwcxtchha9pw-do.png"><br>  Not very safe ... To fix this, we can use the <code>basename()</code> function to take only the file name from the request, cutting the file path if it was specified: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ... $filePath = __DIR__ . DIRECTORY_SEPARATOR . 'media' . DIRECTORY_SEPARATOR . basename($file); // ...</span></span></code> </pre> <br>  Now the same query will give page 404. Fixed! <br><br><h3>  Refactoring </h3><br>  In general, our server is already ready, but its main logic, located in the request handler, does not look very good.  Of course, if you are not going to change it or expand it, you can leave it so, directly in the callback.  But if the server logic changes, for example, instead of plain text, we want to build HTML pages, this callback will grow and quickly become too confused for understanding and support.  Let's do a little refactoring, put the logic into our own <code>VideoStreaming</code> class.  To be able to use this class as a <i>call</i> handler for the request, we need to embed the magic <code>__invoke()</code> method into it.  After that, it will be enough for us to simply pass the instance of this class as a callback to the <code>Server</code> constructor: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ... $loop = Factory::create(); $videoStreaming = new VideoStreaming($loop); $server = new Server($videoStreaming);</span></span></code> </pre> <br>  Now you can build a class <code>VideoStreaming</code> .  It requires one dependency - the instance of the event loop, which will be embedded through the constructor  To begin with, you can simply copy the code from the callback to the <code>__invoke()</code> method, and then do its refactoring: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoStreaming</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * @param ServerRequestInterface $request * @return Response */ function __invoke(ServerRequestInterface $request) { $params = $request-&gt;getQueryParams(); $file = $params['video'] ?? ''; if (empty($file)) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Video streaming server' ); } $filePath = __DIR__ . DIRECTORY_SEPARATOR . 'media' . DIRECTORY_SEPARATOR . basename($file); if (!file_exists($filePath)) { return new Response( 404, ['Content-Type' =&gt; 'text/plain'], "Video $file doesn't exist on server." ); } $video = new ReadableResourceStream( fopen($filePath, 'r'), $this-&gt;eventLoop ); $type = mime_content_type($filePath); return new Response( 200, ['Content-Type' =&gt; $type], $video ); } }</span></span></code> </pre> <br>  Next, we will refactor the <code>__invoke()</code> method.  Let's see what is happening here: <br>  1. We parse the query string and determine which file the user needs. <br>  2. Create a stream from this file and send it as an answer. <br><br>  It turns out that we can distinguish two methods here: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoStreaming</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * @param ServerRequestInterface $request * @return Response */ function __invoke(ServerRequestInterface $request) { $file = $this-&gt;getFilePath($request); if (empty($file)) { return new Response( 200, ['Content-Type' =&gt; 'text/plain'], 'Video streaming server' ); } return $this-&gt;makeResponseFromFile($file); } /** * @param ServerRequestInterface $request * @return string */ protected function getFilePath(ServerRequestInterface $request) { // ... } /** * @param string $filePath * @return Response */ protected function makeResponseFromFile($filePath) { // ... } }</span></span></code> </pre> <br>  The first, <code>getFilePath()</code> , is very simple.  We get the request parameters using the <code>$request-&gt;getQueryParams()</code> method.  If they do not have the <code>file</code> key, we simply return a simple string indicating that the user has opened the server with no GET parameters.  In this case, we can show a static page or something like that.  Here we return a simple text message Video streaming server.  If the user specified a file in the GET request, we create the path to this file and return it: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoStreaming</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * @param ServerRequestInterface $request * @return string */ protected function getFilePath(ServerRequestInterface $request) { $file = $request-&gt;getQueryParams()['file'] ?? ''; if (empty($file)) return ''; return __DIR__ . DIRECTORY_SEPARATOR . 'media' . DIRECTORY_SEPARATOR . basename($file); } // ... }</span></span></code> </pre> <br>  The <code>makeResponseFromFile()</code> method is also very simple.  If there is no file for the specified path, we immediately return a 404 error. Otherwise, we open the requested file, create a readable stream and return it in the response body: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoStreaming</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * @param string $filePath * @return Response */ protected function makeResponseFromFile($filePath) { if (!file_exists($filePath)) { return new Response( 404, ['Content-Type' =&gt; 'text/plain'], "Video $filePath doesn't exist on server." ); } $stream = new ReadableResourceStream( fopen($filePath, 'r'), $this-&gt;eventLoop ); $type = mime_content_type($filePath); return new Response( 200, ['Content-Type' =&gt; $type], $stream ); } }</span></span></code> </pre> <br>  Here is the complete code for the VideoStreaming class: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Response</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">Factory</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">EventLoop</span></span>\<span class="hljs-title"><span class="hljs-title">LoopInterface</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Stream</span></span>\<span class="hljs-title"><span class="hljs-title">ReadableResourceStream</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Psr</span></span>\<span class="hljs-title"><span class="hljs-title">Http</span></span>\<span class="hljs-title"><span class="hljs-title">Message</span></span>\<span class="hljs-title"><span class="hljs-title">ServerRequestInterface</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoStreaming</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> LoopInterface */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $eventLoop; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> LoopInterface $eventLoop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LoopInterface $eventLoop)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;eventLoop = $eventLoop; } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> ServerRequestInterface $request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> Response */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ $file = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getFilePath($request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">'Video streaming server'</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;makeResponseFromFile($file); } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $filePath * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> Response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeResponseFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($filePath)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_exists($filePath)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">404</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span>], <span class="hljs-string"><span class="hljs-string">"Video $filePath doesn't exist on server."</span></span> ); } $stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableResourceStream( fopen($filePath, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;eventLoop ); $type = mime_content_type($filePath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response( <span class="hljs-number"><span class="hljs-number">200</span></span>, [<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span> =&gt; $type], $stream ); } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> ServerRequestInterface $request * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFilePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServerRequestInterface $request)</span></span></span><span class="hljs-function"> </span></span>{ $file = $request-&gt;getQueryParams()[<span class="hljs-string"><span class="hljs-string">'file'</span></span>] ?? <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($file)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . DIRECTORY_SEPARATOR . <span class="hljs-string"><span class="hljs-string">'media'</span></span> . DIRECTORY_SEPARATOR . basename($file); } }</code> </pre><br>  Of course, instead of simply calling the request handler, we now have three times the code, but if this code changes in the future, it will be much easier for us to make these changes and support our application. <br><br>  Examples from this chapter can be found on <a href="https://github.com/seregazhuk/reactphp-book/tree/master/video-streaming">GitHub</a> . <br><br>  Sergey also has a useful regularly updated <a href="http://sergeyzhuk.me/">English-language blog</a> . <br><br>  Finally, we remind you that we are always <a href="https://moikrug.ru/companies/skyeng/vacancies">looking for talented developers</a> !  Come, we have fun. <br><img src="https://habrastorage.org/getpro/habr/post_images/b79/8f4/ce7/b798f4ce7359fd815df4bdf76503b295.gif"><img src="https://habrastorage.org/getpro/habr/post_images/563/98e/76b/56398e76be6355ad5999b262208a17c9.gif"><img src="https://habrastorage.org/getpro/habr/post_images/df3/e56/7d6/df3e567d6f16d040326c7a0ea29a4f41.gif"><img src="https://habrastorage.org/getpro/habr/post_images/d89/746/888/d89746888da2d9510b64a9f031eaecd5.gif"></div><p>Source: <a href="https://habr.com/ru/post/341306/">https://habr.com/ru/post/341306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341296/index.html">An extraordinary charge: how we have automated the park</a></li>
<li><a href="../341298/index.html">Listen to traffic and increase the loyalty of bank customers: myth or reality</a></li>
<li><a href="../341300/index.html">Extreme Networks is making Network Fabrics a reality</a></li>
<li><a href="../341302/index.html">Beauty go</a></li>
<li><a href="../341304/index.html">Do not confuse software development and programming.</a></li>
<li><a href="../341308/index.html">Inkscape tutorial: draw a cartoon turkey</a></li>
<li><a href="../341310/index.html">94% of large and medium-sized companies are morally ready for the ‚Äúclouds‚Äù. But only 24% can do it right now.</a></li>
<li><a href="../341316/index.html">"5P": On the quality of data and common errors in their collection</a></li>
<li><a href="../341318/index.html">Bad Rabbit showed: ransomware encrypts backup data</a></li>
<li><a href="../341320/index.html">What is wrong with vulnerabilities in C # projects?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>