<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fear and Loathing DevSecOps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We had 2 code analyzers, 4 tools for dynamic testing, our own crafts and 250 scripts. Not that it was all necessary in the current process, but once I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fear and Loathing DevSecOps</h1><div class="post__text post__text-html js-mediator-article">  We had 2 code analyzers, 4 tools for dynamic testing, our own crafts and 250 scripts.  Not that it was all necessary in the current process, but once I started to implement DevSecOps, then you have to go to the end. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/025/c0d/7f2/025c0d7f278116e7cc5e2d098a2ff7c1.jpg"><br><br>  <i><a href="https://www.reddit.com/user/narkos">Source of</a></i>  <i>Characters: Justin Royland and Dan Harmon.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is SecDevOps?  And DevSecOps?  What are the differences?  Application Security - what is it about?  Why does the classic approach no longer work?  <b>Yury Shabalin</b> from <b>Swordfish Security</b> knows the answer to all these questions <b>.</b>  Yuri will answer and explain in detail everything about the problems of transition from the classical Application Security model to the DevSecOps process: how to approach the embedding of a secure development process into the DevOps process and not break anything, how to go through the main stages of security testing, what tools you can apply, than they differ and how to adjust them correctly to avoid pitfalls. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/sYMWGw5Lyu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>About Speaker:</b> <b>Yuri Shabalin -</b> Chief Security Architect at <b>Swordfish Security</b> .  Responsible for the implementation of SSDL, for the overall integration of application analysis tools into a single ecosystem of development and testing.  7 years experience in information security.  He worked at Alfa-Bank, Sberbank and Positive Technologies, which develops software and provides services.  Speaker of international conferences ZerONights, PHDays, RISSPA, OWASP. <br><br><h2>  Application Security: what is it about? </h2><br>  <b>Application Security</b> is a security section that is responsible for application security.  This does not apply to the infrastructure or network security, namely, what we write and what the developers are working on - these are the shortcomings and vulnerabilities of the application itself. <br><br>  The direction of <a href="https://docs.microsoft.com/ru-ru/ef/ef6/modeling/designer/advanced/edmx/ssdl-spec">SDL or SDLC</a> - <b>Security development lifecycle</b> - was developed by Microsoft.  The diagram shows the canonical SDLC model, the main task of which is to take part in security at every stage of development, from requirements to release and release to production.  Microsoft realized that there are too many bugs in the prom, there are more of them and we need to do something with it, and suggested this approach, which has become canonical. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d04/fd2/31f/d04fd231f3b7d52417049462e3b49ef0.png"><br><br>  Application Security and SSDL are not aimed at detecting vulnerabilities, as is commonly believed, but to prevent their occurrence.  Over time, the canonical approach from Microsoft was improved, developed, and a deeper, detailed immersion appeared. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/824/d35/7ef/824d357ef2ec10e907503a416226f931.png"><br><br>  Canonical SDLC is highly detailed in various methodologies - OpenSAMM, BSIMM, OWASP.  Methodologies are different, but, in general, are similar. <br><br><h3>  Building Security In Maturity Model </h3><br>  I prefer <b>BSIMM</b> most of all - <a href="https://www.bsimm.com/">Building Security In Maturity Model</a> .  The basis of the methodology is the division of the Application Security process into 4 domains: Governance, Intelligence, SSDL Touchpoints and Deployment.  In each domain there are 12 practices, which are presented in the form of 112 activities. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f4/3e2/6c5/1f43e26c57026ae938b7ba3664174d87.png"><br><br>  Each of the 112 activities has <b>3 levels of maturity</b> : beginner, intermediate and advanced.  All 12 practices can be studied by sections, select important things for you, understand how to implement them and gradually add elements, for example, static and dynamic code analysis or code review.  You paint the plan and work quietly on it as part of implementing the selected activities. <br><br><h2>  Why DevSecOps </h2><br><blockquote>  DevOps is a big process in which you need to take care of security. </blockquote><br>  <a href="https://ru.wikipedia.org/wiki/DevOps"><b>DevOps initially</b></a> assumed security checks.  In practice, the number of security teams was much smaller than they are now, and they did not act as participants in the process, but as a control and supervisory body that makes demands on it and checks the quality of the product at the end of the release.  This is a classic approach in which security teams were behind the wall from development and did not take part in the process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/255/c4c/75b/255c4c75bcb8fb48e4b9fa9e61cc26e3.png"><br><br>  The main problem is that the information security is separate from the development.  This is usually a kind of IB circuit and there are 2-3 large and expensive tools in it.  Every six months, the source code or application arrives that needs to be checked, and <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BF%25D1%258B%25D1%2582%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BD%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">pentests are</a> made once a year.  This all leads to the fact that the timing of the release in the industry is postponed, and a huge number of vulnerabilities from automated tools fall out on the developer.  All this can not be disassembled and repaired, because even in the previous six months the results were not dismantled, and here a new batch. <br><br>  In the course of our company's work, we see that safety in all areas and industries understands that it is time to catch up and spin with the development in one wheel - in <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D0%25B1%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F_%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B8"><b>Agile</b></a> .  The DevSecOps paradigm fits nicely on the methodology of agile development, on implementation, support and participation in each release and iteration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae6/800/8e8/ae68008e857c8dc2eb6ff272405a32f5.png"><br><br><h2>  Transition to DevSecOps </h2><br>  The most important word in the Security Development Lifecycle is <b>‚Äúprocess</b> . <b>‚Äù</b>  You need to understand this before thinking about buying tools. <br><br><blockquote>  Simply incorporating tools into the DevOps process is not enough - interaction and understanding between process participants is important. </blockquote><br><h3>  More people, not tools </h3><br>  Often planning for a secure development process begins with the selection and purchase of a tool, and ends with attempts to integrate the tool into the current process, which remain attempts.  This leads to sad consequences, because all the tools have their own characteristics and limitations. <br><br>  A common case is when the security department chose a good, expensive tool with ample opportunities, and came to the developers to embed it in the process.  But it does not come out - the process is structured so that the limitations of the instrument already purchased do not fall into the current paradigm. <br><br><blockquote>  First describe what result you want and how the process will look.  This will help to understand the role of the tool and safety in the process. </blockquote><br><h3>  Start with what is already used. </h3><br>  Before buying expensive tools, look at what you already have.  In each company there are safety requirements, which are presented to the development, there are checks, pentests - why not transform all this into a clear and convenient form for everyone? <br><br>  Usually the requirements - it is a paper talmud, which lies on the shelf.  There was a case when we come to the company to see the processes and ask to show the security requirements for the software.  The specialist who did this was looking for a long time: <br><br>  <i>- Now, somewhere in the notes there was a way where this document lies.</i> <br><br>  As a result, we received the document a week later. <br><br>  For requirements, checks and other things, create a page, for example, on <b>Confluence</b> - this is convenient for everyone. <br><br><blockquote>  Easier to reformat what is already there and use to start. </blockquote><br><h3>  Use Security Champions </h3><br>  Usually, in an average company, one security officer works for 100-200 developers, who performs several functions and does not physically have time to check everything.  Even if he tries his best - he alone will not check all the code that the development generates.  For such cases, the concept has been developed - <a href="https://www.owasp.org/index.php/Security_Champions"><b>Security Champions</b></a> . <br><br><blockquote>  Security Champions is a person within the development team who is interested in the security of your product. </blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f7/273/204/5f727320486d52cc2d14373f686af241.jpg"><br><br>  Security Champion is the entry point to the development team and security evangelist in one person. <br><br>  Usually, when the security team comes to the development team and indicates an error in the code, he gets a surprised answer: <br><br>  <i>- And who are you?</i>  <i>I see you for the first time.</i>  <i>Everything is good with me - I put a ‚Äúapply‚Äù on my senior comrade on code review, we move on!</i> <br><br>  This is a typical situation, because the elders or just teammates with whom the developer constantly interacts in work and in code review are much more trustworthy.  If, instead of the security officer, the Security Champion indicates an error and its consequences, then his word will have more weight. <br><br>  Also, developers know their code better than any security specialist.  For a person who has at least 5 projects in a static analysis tool, it is usually difficult to remember all the nuances.  Security Champions know their product: what interacts with what and what to look at first - they are more effective. <br><br>  So think about embedding Security Champions and expanding the influence of the security team.  It is also useful for the champion himself: professional development in the new field, expansion of the technical outlook, improvement of technical, managerial and leadership skills, increase in market value.  This is some element of social engineering, your ‚Äúeyes‚Äù in the development team. <br><br><h2>  Testing stages </h2><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%259F%25D0%25B0%25D1%2580%25D0%25B5%25D1%2582%25D0%25BE">A paradigm of 20 on 80</a> says that 20% of the effort gives 80% of the result.  These 20% are application analysis practices that can and should be automated.  Examples of such activities are static analysis ‚Äî <b>SAST</b> , dynamic analysis ‚Äî <b>DAST,</b> and <b>Open Source control</b> .  I'll tell you more about the activity, as well as about the tools, what features we usually encounter when they are introduced into the process, and how to do it correctly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/a18/819/ab8a18819718b9ad3edcf98a6ee88c6a.png"><br><br><h3>  The main problems of tools </h3><br>  I will highlight issues that are relevant to all tools that need attention.  I will analyze them in more detail, so as not to repeat further. <br><br>  <b>Long time analysis.</b>  If it takes 30 minutes to complete the tests and assembly, from the commit to the exit to the prod, the information security checks will take a day.  So no one will slow down the process.  Consider this feature and draw conclusions. <br><br>  <b>False Negative High or False Positive.</b>  All products are different, all use different frameworks and their own style of writing code.  On different code bases and technologies, tools can show different levels of False Negative and False Positive.  Therefore, look what exactly in <b>your</b> company and for <b>your</b> applications will show a good and reliable result. <br><br>  <b>No integration with existing tools</b> .  Look at the tools in terms of integrations, so that you already use.  For example, if you have Jenkins or TeamCity, check the integration of the tools with this particular software, and not with GitLab CI, which you are not using. <br><br>  <b>Absence or excessive complexity of customization.</b>  If the tool has no API, then why is it needed?  Everything that can be done in the interface should be accessible through the API.  Ideally, the tool should have the ability to customize the checks. <br><br>  <b>No roadmap of product development.</b>  Development does not stand still, we always use new frameworks and functions, we rewrite the old code into new languages.  We want to be sure that the tool we buy will support new frameworks and technologies.  Therefore, it is important to know that the product has a real and proper <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B4%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D0%25B0%25D1%2580%25D1%2582%25D0%25B0">Roadmap</a> development. <br><br><h3>  Process features </h3><br>  In addition to the features of the tools, consider the features of the development process.  For example, interfere with the development - this is a typical error.  Let's see what other features should be considered and what the security team should pay attention to. <br><br>  In order not to disrupt development and release dates, create <b>different rules</b> and different <b>show stoppers</b> ‚Äî criteria for stopping the build process in the presence of vulnerabilities ‚Äî <b>for different environments</b> .  For example, we understand that the current branch goes to the developer booth or UAT, which means we do not stop and do not say: <br><br>  <i>- You have vulnerabilities here, you will not go anywhere further!</i> <br><br>  At this stage, it is important to tell the developers that there are security issues that are worth paying attention to. <br><br>  <b>The presence of vulnerabilities is not an obstacle for further testing</b> : manual, integration or manual.  On the other hand, we need to somehow improve the safety of the product, and that the developers do not forget about what it finds safe.  Therefore, sometimes we do this: on the stand, when rolling out to the development environment, we simply notify the development: <br><br>  <i>- Guys, you have problems, please pay attention to them.</i> <br><br>  At the UAT stage, we again show warnings about vulnerabilities, and at the stage of exit in the prom we say: <br><br>  <i>- Guys, we warned several times that you didn‚Äôt do anything - we won‚Äôt let you go with that.</i> <br><br>  If we talk about code and dynamics, then it is necessary to show and warn about vulnerabilities only those features and code that was just written in this feature.  If the developer moved the button by 3 pixels and we tell him that he has a SQL injection there and therefore it is urgently necessary to correct it - this is wrong.  Look only at what is written now, and at the change that comes in the application. <br><br>  Suppose we have a certain functional defect - the way the application should not work: money is not transferred, when you click on the button there is no transition to the next page or the product is not loaded.  <b>Security defects</b> - these are the same defects, but not in the context of the application, and security. <br><br><blockquote>  Not all software quality problems are security problems.  But all security issues are related to software quality.  Sherif Mansour, Expedia. </blockquote><br>  Since all vulnerabilities are the same defects, they should be located in the same place as all development defects.  So forget about reports and scary pdfs that nobody reads. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c1/075/ec1/3c1075ec141698d9ac96c4bd6653e220.png"><br><br>  When I worked in a company that was developing, I received a report from the static analysis tools.  I opened it, was terrified, made coffee, looked through 350 pages, closed it and went on to work further.  <b>Big reports are dead reports</b> .  Usually they do not go anywhere, letters are deleted, forgotten, lost, or the business says that it takes risks. <br><br>  What to do?  Confirmed defects that have been found are simply converted into a form suitable for development, for example, we add them to the backlog in Jira.  We prioritize defects and eliminate them in order of priority, along with functional defects and defects of tests. <br><br><h2>  Static Analysis - SAST </h2><br>  <b>This is an analysis of the code for the presence of vulnerabilities</b> , but it is not the same as SonarQube.  We check not only by patterns or style.  In the analysis, a number of approaches are used: on the vulnerability tree, on <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">DataFlow</a> , on the analysis of configuration files.  This is all that concerns the code itself. <br><br>  <b>Advantages of the approach</b> : <b>identification of vulnerabilities in the code at an early stage of development</b> , when there are no stands and a finished tool, and the <b>possibility of incremental scanning</b> : scanning a section of code that has changed, and only the feature that we are doing now, which reduces the scan time. <br><br>  <b>The disadvantages</b> are the lack of support for the required languages. <br><br>  <b>The necessary integrations</b> that should be in the tools, in my subjective opinion: <br><br><ul><li>  Integration tool: Jenkins, TeamCity and Gitlab CI. <br></li><li>  Development environment: Intellij IDEA, Visual Studio.  It is more convenient for the developer not to climb into an incomprehensible interface that still needs to be remembered, but to see all the necessary integrations and vulnerabilities that he has found right in the workplace in his own development environment. <br></li><li>  Code review: SonarQube and manual review. <br></li><li>  Defect trackers: Jira and Bugzilla. <br></li></ul><br>  The picture shows some of the best representatives of static analysis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/988/8b2/b879888b216c43f8d0884375e0b3b2fc.png"><br><br>  Not the tools are important, but the process, so there are Open Source solutions that are also good for running the process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/420/f5c/146/420f5c14686f95ff771d295351d70a7b.png"><br><br>  SAST Open Source will not find a huge number of vulnerabilities or complex DataFlow, but you can and should use them when building the process.  They help to understand how the process will be built, who will respond to bugs, who will report, who - to report.  If you want to conduct the initial step of building the security of your code - use the Open Source solution. <br><br>  How can this be integrated if you are at the beginning of the journey, you have nothing: neither CI, nor Jenkins, nor TeamCity?  Consider integration into the process. <br><br><h3>  CVS level integration </h3><br>  If you have Bitbucket or GitLab, you can do the integration at the level of <a href="https://ru.wikipedia.org/wiki/CVS">Concurrent Versions System</a> . <br><br>  <b>On event</b> - pull request, commit.  You scan the code and, in the build status, show that the security check has passed or failed. <br><br>  <b>Feedback.</b>  Of course, feedback is always needed.  If you just performed on the security side, put it in a box and did not tell anyone about it, and then at the end of the month dumped a bunch of bugs - this is not right and not good. <br><br><h3>  Integration with code review system </h3><br>  Once, we set up a number of important projects as the default reviewer of the technical user AppSec.  Depending on whether errors are detected in the new code or there are no errors, at pull request, the reviewer puts the status on ‚Äúaccept‚Äù or ‚Äúneed work‚Äù - either everything is OK, or you need to refine and refer to what exactly to refine.  For integration with the version that goes to the prod, we had a ban on merge if the test on IB is not passed.  We included this in the manual code review, and the rest of the process saw the security statuses for this particular process. <br><br><h3>  Integration with SonarQube </h3><br>  Many have a <a href="https://de.wikipedia.org/wiki/Quality_Gate">quality gate</a> for code quality.  Here is the same thing - you can do the same gates only for SAST tools.  There will be the same interface, the same quality gate, only it will be called the <b>security gate</b> .  And also, if you have a process using the SonarQube, you can easily integrate everything there. <br><br><h3>  CI level integration </h3><br>  Here, too, everything is quite simple: <br><br><ul><li>  <b>At the same level with autotests</b> , unit tests. <br></li><li>  <b>Separation by development stages</b> : dev, test, prod.  Different sets of rules can be included, or different fail conditions: we stop the assembly, we do not stop the assembly. <br></li><li>  <b>Synchronous / asynchronous start</b> .  We are waiting for the end of testing security tests or not waiting.  That is, we simply launched them and move on, and then we receive the status that everything is good or bad. <br></li></ul><br>  This is all in a perfect pink world.  In real life, this is not, but we strive.  The result of performing security checks should be similar to the results of unit tests. <br><br>  For example, we took a big project and decided that now we will scan it with SAST, OK.  We crammed this project into SAST, it gave us 20,000 vulnerabilities, and we decided by good will that everything was fine.  20,000 vulnerabilities are our technical debt.  We will put the debt in the box, we will quietly rake and get bugs into the defect-trackers.  We will hire a company, do it all ourselves or Security Champions will help us - and technical debt will decrease. <br><br>  And all newly emerging vulnerabilities in the new code should be eliminated as well as errors in the unit or in the autotests.  Relatively speaking, the assembly started, drove out, two tests and two safety tests fell.  OK - we went, looked at what happened, corrected one, corrected the second, the next time they drove away - everything is fine, no new vulnerabilities have appeared, the tests are not failed.  If this task is deeper and you need to understand it well, or fixing vulnerabilities affects large layers of what lies under the hood: you have introduced a bug in the defect tracker, it is prioritized and corrected.  Unfortunately, the world is not perfect and tests sometimes fall. <br><br>  An example security gate is an analogue of the quality gate, in terms of the presence and number of vulnerabilities in the code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bec/d8e/ea7/becd8eea753d3375eca69531ad634d97.png">  We integrate with SonarQube - the plugin is installed, everything is very convenient and cool. <br><br><h3>  Integration with development environment </h3><br>  <b>Integration Capabilities:</b> <br><br><ul><li>  Starting a scan from the development environment before commit. <br></li><li>  View results. <br></li><li>  Analysis of the results. <br></li><li>  Synchronization with the server. <br></li></ul><br>  Something like this is getting the results from the server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37e/1f2/f94/37e1f2f94a2e79ab0022b7c84486ed93.png"><br><br>  In our <a href="https://www.jetbrains.com/idea/">Intellij IDEA</a> development environment, an additional item simply appears, which reports that such vulnerabilities were discovered during the scan.  You can immediately edit the code, watch recommendations and <a href="https://en.wikipedia.org/wiki/Control-flow_graph">Flow Graph</a> .  This is all located in the developer‚Äôs workplace, which is very convenient - you don‚Äôt need to follow the other links and watch something extra. <br><br><h2>  Open source </h2><br>  This is my favorite topic.  Everyone uses the Open Source library - why write a bunch of crutches and bicycles when you can get a ready-made library in which everything is already implemented? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e78/ce8/137/e78ce813740787dd20a57d1a1501b14c.png"><br><br>  Of course, this is true, but libraries are also written by people, also include certain risks and also there are vulnerabilities, which are periodically or permanently reported.  Therefore, there is the next step in Application Security - an analysis of the Open Source component. <br><br><h3>  Open Source Analysis - OSA </h3><br>  The tool includes three large stages. <br><br>  <b>Search for vulnerabilities in libraries.</b>  For example, the tool knows that we are using some kind of library, and that there are some vulnerabilities in <a href="https://ru.wikipedia.org/wiki/Common_Vulnerabilities_and_Exposures">CVE</a> or in bug trackers that relate to this version of the library.  If you try to use it, the tool will warn you that the library is vulnerable and advises using a different version where there are no vulnerabilities. <br><br>  <b>Analysis of license purity.</b>  With us this is not very popular yet, but if you work abroad, you can periodically get an atat for using open source components that cannot be used or modified.  According to the policy of the licensed library, we cannot do this.  Or, if we modified it and use it, then we have to lay out our code.  Of course, no one wants to upload the code of their products, but you can protect against this too. <br><br>  <b>Analysis of the components that are used in the industrial environment.</b>  Imagine a hypothetical situation that we finally completed the development and released the last release of our microservice in the prom.  He lives there remarkably - a week, a month, a year.  We do not collect it, we do not conduct security checks, everything seems to be fine.  But suddenly, two weeks after the release, there is a critical vulnerability in the Open Source component, which we use precisely in this assembly, in the industrial environment.  If we do not write down what and where we use, then this vulnerability will simply not be seen.  Some tools have the ability to monitor vulnerabilities in libraries that are now used in prom.  It is very useful. <br><br>  <b>Opportunities:</b> <br><br><ul><li>  Different policies for different stages of development. <br></li><li>  Component monitoring in industrial environment. <br></li><li>  Control libraries in the organization contour. <br></li><li>  Support for various build systems and languages. <br></li><li>  Analysis of Docker images. <br></li></ul><br>  A few examples of area leaders who are engaged in the analysis of Open Source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/285/220/a25285220400fd96e901fce31967a815.png"><br>  The only free one is OWASP's <a href="https://www.owasp.org/index.php/OWASP_Dependency_Check">Dependency-Check</a> .  You can turn it on at the first stages, see how it works and what it supports.  Basically, these are all cloud products, or on-premise, but behind their base they still go to the Internet.  They do not send your libraries, but hashes or their values, which they calculate, and fingerprints to their server to receive news of the presence of vulnerabilities. <br><br><h3>  Process integration </h3><br>  <b>Control perimeter libraries</b> that are downloaded from external sources.  We have external and internal repositories.  For example, inside Event Central stands Nexus, and we want to have no ‚Äúcritical‚Äù or ‚Äúhigh‚Äù status vulnerabilities inside our repository.  You can configure proxying using the Nexus Firewall Lifecycle tool so that such vulnerabilities are cut off and do not fall into the internal repository. <br><br>  <b>Integration into CI</b> .  On the same level as autotests, unit tests and development stages: dev, test, prod.  At each stage, you can download any library, use anything, but if there is something hard with a status of "critical", it is possible, you should pay attention to this developers at the stage of prom. <br><br>  <b>Integration with artifacts</b> : Nexus and JFrog. <br><br>  <b>Integration into the development environment.</b>  The tools you choose should be integrated with development environments.  The developer should have access to the scan results from his workplace, or be able to scan himself and check the code for vulnerabilities before committing to CVS. <br><br>  <b>CD integration.</b>  This is a cool feature that I really like and about which I have already said - monitoring the emergence of new vulnerabilities in the industrial environment.  It works like this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef4/7be/cd8/ef47becd8a99e5223a4967154b28d6d7.png"><br><br>  We have <b>Public Component Repositories</b> - some tools outside, and our internal repository.  We want to have only trusted components.  When proxying a request, we check that the library being downloaded does not have vulnerabilities.  If it falls under certain policies that we set and necessarily coordinate with the development, then we don‚Äôt download it, and the beating comes to use another version.  Accordingly, if there is something really critical and bad in the library, then the developer at the installation stage will not receive the library - let him use the version above or below. <br><br><ul><li>  With build, we check that nobody has slipped anything bad, that all components are safe and no one brought anything dangerous on the flash drive. <br></li><li>  In the repository we have only trusted components. <br></li><li>  When deploying, we once again check the package itself: war, jar, DL, or the Docker image that it complies with the policy. <br></li><li>  When entering the industry, we monitor what is happening in the industrial environment: critical vulnerabilities appear or do not appear. <br></li></ul><br><h2>  Dynamic Analysis - DAST </h2><br>  The tools of dynamic analysis are fundamentally different from everything that was said before.  This is a kind of imitation of user experience with the application.  If this is a web application, we send requests, imitating the work of the client, click on the buttons on the front, send artificial data from the form: quotes, brackets, characters in different encoding, to look at how the application works and processes external data. <br><br>  The same system allows you to check template vulnerabilities in Open Source.  Since DAST does not know which Open Source we are using, it simply throws ‚Äúmalicious‚Äù patterns and analyzes the server's responses: <br><br>  <i>- Yeah, there is a problem of deserialization, but not here.</i> <br><br>  There are big risks in this, because if you run this security test on the same stand with which testers work, unpleasant things can happen. <br><br><ul><li>  High load on the network \ application server. <br></li><li>  No integrations. <br></li><li>  The ability to change the settings of the analyzed application. <br></li><li>  No support for required technology. <br></li><li>  The complexity of the settings. <br></li></ul><br>  We had a situation when we finally launched AppScan: we knocked out access to the application for a long time, got 3 accounts and were delighted - finally we‚Äôll check everything!  They started the scan, and the first thing that AppScan did was to get into the admin panel, poke through all the buttons, change half of the data, and then kill the server with their own <a href="https://www.mailform.io/">mailform</a> queries.  Development with testing said: <br><br>  <i>- Guys, are you kidding me ?!</i>  <i>We gave you accounts, and you put a stand!</i> <br><br>  Consider the possible risks.  Ideally, prepare a separate stand for testing the IB, which will be isolated from the rest of the environment at least somehow, and conditionally check the admin panel preferably in manual mode.  This pentest is the remaining percentage of effort that we are not currently considering. <br><br>  It is worth considering that you can use it as an analogue of load testing.  At the first stage, you can turn on the dynamic scanner in 10-15 threads and see what happens, but usually, as practice shows, nothing good. <br><br>  Several resources that are commonly used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b26/34c/9d1/b2634c9d1eae68e5c84996570d438ec8.png"><br><br>  The <a href="https://portswigger.net/burp">Burp Suite</a> is a ‚ÄúSwiss knife‚Äù for any security professional.  It is used by everyone, and it is very convenient.    - enterprise edition.      stand alone   ,   -    ,       .  ,  . <br><br><h3>    </h3><br>      : <b>    </b>     <b>     </b> . <br><br>          mock-,     ‚Äî      ,      . <br><br><ul><li>  ‚Äî    . <br></li><li>      . <br></li><li>    ‚Äî  . <br></li></ul><br><h2>  Process </h2><br>          ,  .    ‚Äî      ,   ,    OpenSource,    - , ,   <a href="https://ru.wikipedia.org/wiki/Waf">Waf</a> . <br><br><blockquote>     . </blockquote><br>          ,     ,    ,     ,      -. <br><br>   .       ,       ,    .  ,      ,        .   ,           . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cde/31c/929/cde31c929b2ba4ddc178202c407cfb4f.png"><br><br>          API,   , ,    ,    ‚Äî    <b>AppSec </b> ,                 . <br><br>  ,   security-   ,    ,  ,    ,   ,  .     ,    ,    ‚Äî   Confluence    ,   Jira    -,    /   CI/CD. <br><br><h2> Key Takeaways </h2><br> <b>  .</b>    ‚Äî   .  ,  ,              .     ‚Äî   ¬´¬ª  ,     ‚Äî   - high mega super critical,    ,      . <br><br> <b> </b> <b>‚Äî  </b>  ,   .    , ,            .       DevSecOps, SecDevOps,       . <br><br> <b>  ,   </b> : , ,  , , .          ‚Äî <b> </b> .    ‚Äî <b></b>      . <br><br> <b>       </b> . <br><br> <b> </b> ,  . ,    ‚Äî   .  -  ,     . ,      . <br><br>      ‚Äî <b> Security Champions</b> . <br><br> , ,    ,       -  ‚Äî   .  <b> ,       </b> .    ,   community,    ,   . ,       . <br><br> <b>  .</b> <br><br><ul><li>   False Positive. <br></li><li>   . <br></li><li>  . <br></li><li>  . <br></li><li>  Roadmap  . <br></li><li>   . <br></li></ul><br><blockquote>        DevOpsConf 2018.             27  28     <a href="https://devopsconf.io/moscow-rit/2019">DevOpsConf</a>   <a href="https://ritfest.ru/2019"> ++</a> .   ,      ,  <a href="https://conf.ontico.ru/lectures/propose/%3Fconference%3Ddc2019-rit"> </a>    21 . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/448488/">https://habr.com/ru/post/448488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448478/index.html">Moon mission "Bereshit" - the preliminary cause of the accident was announced</a></li>
<li><a href="../448480/index.html">Docker user</a></li>
<li><a href="../448482/index.html">Factory testing of modular data center</a></li>
<li><a href="../448484/index.html">Aboriginal microbes</a></li>
<li><a href="../448486/index.html">‚ÄúIn November of 2018, we accidentally fell into spam on all fronts.‚Äù How I saved mailing with the company with a million base</a></li>
<li><a href="../448498/index.html">"Russia 404": How much is left to live free Internet</a></li>
<li><a href="../448500/index.html">Solve a simple crackme for Sega Mega Drive</a></li>
<li><a href="../448504/index.html">Collected all "Habrom" directory "Issued by whom ..." for passports. Download to health</a></li>
<li><a href="../448506/index.html">‚ÄúThe Matrix‚Äù is 20 years old: how Wachowski made the cyberpunk that set the agenda for a whole generation</a></li>
<li><a href="../448510/index.html">Acer in 2019: what if you remove all the trinkets from the gaming laptops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>