<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A couple of words in defense of the monolith</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We compare the features of microservice and monolithic architecture, their advantages and disadvantages. The article was prepared for Habr on the mate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A couple of words in defense of the monolith</h1><div class="post__text post__text-html js-mediator-article">  We compare the features of microservice and monolithic architecture, their advantages and disadvantages.  The article was prepared for Habr on the materials of our mitap <a href="https://vk.com/hot_backend">Hot Backend</a> , which was held in Samara on February 9, 2019.  We consider the factors of choice of architecture, depending on the specific task. <a name="habracut"></a><br><br>  Even 5 years ago no one had heard of microservices.  However, their popularity is increasing from year to year, according to Google Trends <a href="https://trends.google.ru/trends/explore%3Fq%3D%252Fm%252F011spz0k%26date%3Dtoday%25205-y">statistics</a> . <br><br><img src="https://habrastorage.org/webt/1_/of/jd/1_ofjdwx6pauxathtq1srtfdsas.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Monolith and microservices: examples </h2><br>  If the project uses a monolithic architecture, then the developer has only one application, all components and modules of which work with a single base. <br><br><img src="https://habrastorage.org/webt/8q/pt/px/8qptpxklg15wtydbx847sqk2c9o.jpeg"><br><br>  The microservice architecture assumes a breakdown into modules that run as separate processes and can have separate servers.  Each microservice works with its database, and all these services can communicate with each other both synchronously (http) and asynchronously.  At the same time to optimize the architecture, it is desirable to minimize the relationship between services. <br><br>  The diagram below is simplified, reflecting primarily the business components. <br><br><img src="https://habrastorage.org/webt/q2/gi/y-/q2giy-br8pq2amiqihkrkzmn2e4.jpeg"><br><br><h2>  Microservices: advantages </h2><br>  At least four advantages of microservice architecture can be distinguished: <br><br>  <b>Independent scaling and deployment</b> <br><br>  An independent deployment is provided for each microservice, and this is convenient when updating individual modules.  If the load on the module increases, the corresponding microservice can be scaled without affecting the rest.  This allows you to flexibly distribute the load and save resources. <br><br>  <b>Independent development</b> <br><br>  Each microservice (for example, a memory module) can be developed by one team in order to increase the speed of creating a software product. <br><br>  <b>Resilience</b> <br><br>  The failure of one microservice does not affect the performance of other modules. <br><br>  <b>Heterogeneity</b> <br><br>  Each team is free to choose its own language and technology implementation of microservices, however, it is desirable that they have compatible interfaces. <br><br>  Among the developers, you can hear the opinion that the monolithic architecture is outdated, it is difficult to accompany and scale, it quickly grows into a ‚Äúbig lump of dirt‚Äù and is practically anti-pattern, that is, its presence in the code is undesirable.  As proof of this view, large companies are often cited, for example, Netflix, which switched to microservice architecture in their projects. <br><br>  Let's see if everyone really should move from monolith to microservices following the example of the largest brands? <br><br><h2>  Transition to microservices: possible difficulties </h2><br>  <b>Problem one: decomposition</b> <br><br>  Ideally, the application should be divided into microservices in such a way that they interact with each other as little as possible, otherwise the application will be difficult to maintain.  In this case, decomposition is difficult to implement at the beginning of development, when business problems and the subject area may still change with the appearance of new requirements.  Refactoring is expensive. <br><br>  If it becomes necessary to transfer part of the functions from service A to service B, then there may be difficulties: for example, services are made in different languages, internal calls to services become networked, other libraries need to be connected.  We can check the correctness of refactoring only with the help of tests. <br><br><img src="https://habrastorage.org/webt/ms/sb/zd/mssbzdbu2gw0mkt3xxsxd7cozuo.jpeg"><br><br>  <b>Problem Two: Transactions</b> <br><br>  Another problem is connected with the fact that microservices do not have the concept of distributed transactions.  We can guarantee the architectural integrity of a business operation only within one microservice.  If the operation involves several microservices, different databases can be used there, and such a transaction will have to be abandoned.  To solve this problem, there are different methods used in business, when accessibility is more important than integrity.  At the same time, compensating mechanisms are provided in case something goes wrong.  For example, if the goods are not in stock, you need to make a refund to the buyer's account. <br><br>  If the monolith gives us architectural integrity automatically, then with microservices you need to invent your own mechanism and use libraries with ready-made solutions.  When distributing operations between services, it is better to request data synchronously, and perform subsequent actions asynchronously.  If it is impossible to access one of the services, the team will be queued as soon as it becomes available again. <br><br>  In this regard, it is necessary to revise the approach to the user interface.  The user should receive a notification that some actions are performed not immediately, but within a certain time.  When the application is processed, he receives an invitation to see the results. <br><br><img src="https://habrastorage.org/webt/j3/ms/1m/j3ms1mf_jzbabdwangp62th2uru.jpeg"><br><br>  <b>Problem Three: Report Building</b> <br><br>  If we use a monolithic architecture with a single database, to build a complex report, we can write select and pull up several data plates: sooner or later they will be output.  However, on microservices this data can be scattered across different databases. <br><br>  For example, we need to display a list of companies with certain metrics.  When displaying a simple list of companies, everything works.  And if you need to add metrics that are in a different database?  Yes, we can make an additional request and request a metric using the TIN.  And if this list needs to be filtered and sorted?  The list of companies can be very large, and then we have to enter an additional service with its database - reports. <br><br><img src="https://habrastorage.org/webt/lz/kq/sn/lzkqsn07kbbjovz9_rttgfqbfmg.jpeg"><br><br>  <b>Problem Four: High Complexity</b> <br><br>  Work on distributed services is more difficult: all requests are carried out over the network and can ‚Äúplug in‚Äù, you need to provide a callback mechanism (will it call again? How many times?).  These are ‚Äúbricks‚Äù that gradually accumulate and contribute to the increase in the complexity of the project. <br><br>  Services can be developed by several different teams, and you need to document them, keep the documentation up to date, warn other teams when changing versions.  These are additional labor costs. <br><br>  If each team has independent deployment, you need to maintain at least the previous version and disable it only after all consumers of the service switch to the new API. <br>  Of course, we can take out all the API in a kind of artifact that will be publicly available.  But, first, services can be written in different languages, and secondly, it is not recommended to do so.  For example, in one of our projects, we abandoned this at the request of the customer related to security concerns.  Each microservice has a separate repository, and the customer does not give access to them. <br><br>  In the development process, everything can work correctly, and then - no.  It happens that in case of exceptions, the application tries to process them endlessly, and this gives a big load - the whole system ‚Äúfalls‚Äù.  To avoid such situations, you need to configure everything, for example, limit the number of attempts, not return this call to the queue at the same second, etc. <br><br><img src="https://habrastorage.org/webt/_w/jd/oj/_wjdoj3ln-k7ysfb6wuh8kz1ycg.jpeg"><br><br><img src="https://habrastorage.org/webt/ae/rr/xc/aerrxc3udwi9pgafnmkzc7xy2du.jpeg"><br><br>  <b>Problem Five: the complexity of testing, tracing and debugging</b> <br><br>  To test any problem, you need to download all involved microservices.  Debugging becomes a non-trivial task, and all logs need to be collected somewhere in one place.  At the same time logs need as much as possible to figure out what happened.  To track the problem you need to understand the entire path that passed the message.  Unit tests are not enough here, since errors are likely at the interface of services.  When making changes, you can make sure that it works only after running on the stand.  We can limit each microservice to a certain amount of memory (for example, 500 megabytes), but there are times of peak load when it takes up to two gigabytes.  There are times when the system starts to slow down.  As a result, resources can be spent on something that does not belong to the immediate tasks of the client: for example, there are only two business microservices, and half of the resources are spent on three additional microservices that support the work of the others. <br><br><img src="https://habrastorage.org/webt/pl/bn/36/plbn36qdp9gnyslu-b0xbecfo7c.jpeg"><br><br><h2>  Microservice or monolith: selection criteria </h2><br>  When choosing between monolithic and microservice architecture, first of all you need to proceed from the complexity of the domain and the need for scaling. <br><br>  If the subject area is simple, and the global addition of the number of users is not expected, then microservices can be used without doubt.  In other cases, it is better to start development on a monolith and save resources if scaling is not required.  If the subject area is complex, and at the initial stage final requirements are not defined, it is also better to start with a monolith - in order not to redo microservices several times.  With the further development of the project, its individual parts can be singled out in microservices. <br><br><img src="https://habrastorage.org/webt/bl/5c/9e/bl5c9elyajqq00pivozpby_yauy.jpeg"><br><br>  The advantage is the presence of boundaries at the start of the project, because it will help not to disturb them in the development process.  It also makes sense to start with a single database, but define its scheme for each module (for example, a payment scheme).  Subsequently, this will help simplify the division of modules into microservices.  In this case, we observe the boundaries of the modules and can use microservices. <br><br>  Each module must have its own API, so that later it can be selected and made the module a microservice. <br><br><img src="https://habrastorage.org/webt/6i/rp/b9/6irpb9ewnkmgleylittjhh5z-f8.jpeg"><br><br>  Having determined the boundaries of the modules, you can proceed to decomposition into microservices, if necessary.  In about 90% of cases, it will be possible to stay on the monolith, but if necessary, it will be easier and cheaper for you to change the architecture. <br><br>  In our practice of working with monolith and microservices we came to the following conclusions: <br><ul><li>  Do not go to microservices just because they are used by Netflix, Twitter, Facebook </li><li>  Start with two or three microservices that interact with each other, work out all the non-functional requirements (security, fault tolerance, scalability, etc.) in detail, and only then proceed to the other services. </li><li>  Automate everything possible </li><li>  Set up monitoring </li><li>  Write autotests </li><li>  Do not use distributed transactions (but this is not a reason to refuse data integrity guarantees). </li><li>  If you want to use the microservice architecture, be prepared for the fact that the development can cost you about 3 times more expensive than the monolith.  However, both technologies have their own advantages and disadvantages, each of them has its own niche. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/453932/">https://habr.com/ru/post/453932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45391/index.html">Macroeconomics, our delusions, new risks and opportunities</a></li>
<li><a href="../453914/index.html">TON Test Client Installation Instructions</a></li>
<li><a href="../453920/index.html">How to take control of network infrastructure. Chapter Four Automation. Templates</a></li>
<li><a href="../453926/index.html">How the car-sharing service works</a></li>
<li><a href="../453930/index.html">Comparison and selection of data migration systems</a></li>
<li><a href="../453934/index.html">11 questions that need to be discussed before starting work</a></li>
<li><a href="../453938/index.html">Tracking a stolen bike using the NB-IoT protocol</a></li>
<li><a href="../45394/index.html">IBM supercomputer will think like a cat?</a></li>
<li><a href="../453942/index.html">About ethics on the example of the PMI code</a></li>
<li><a href="../453944/index.html">Masked bugs in embedda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>