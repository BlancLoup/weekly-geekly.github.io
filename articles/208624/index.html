<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Depreciation analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Today we talk about depreciation analysis. First, I will tell you what it is and give a toy example. And then I will tell you how to use ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Depreciation analysis</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Today we talk about depreciation analysis.  First, I will tell you what it is and give a toy example.  And then I will tell you how to use it for analyzing a system of disjoint sets. <br><br><a name="habracut"></a><br><h3>  Depreciation analysis </h3><br>  Depreciation analysis is used for algorithms that run several times.  The algorithm time can vary greatly, but we estimate the average or total time for all runs.  Most often, the algorithm implements some operation on the data structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The word "depreciation" came from finance.  It means small periodic payments to repay the loan.  In the lower case, it means that fast operations compensate for their costs for slow operations. <br><br>  Consider the sequence of operations <img src="https://habrastorage.org/getpro/habr/post_images/5aa/a59/a1c/5aaa59a1c6264f1f11bb88198f69885a.gif">  .  Every operation <img src="https://habrastorage.org/getpro/habr/post_images/102/889/f7b/102889f7b5d3f365dc15ef7362e2f654.gif">  in fact performed in time <img src="https://habrastorage.org/getpro/habr/post_images/e72/696/721/e726967211013e1df3adbd8f17aaccf0.gif">  .  This time is called actual.  For each operation <img src="https://habrastorage.org/getpro/habr/post_images/102/889/f7b/102889f7b5d3f365dc15ef7362e2f654.gif">  we calculate the amortization time <img src="https://habrastorage.org/getpro/habr/post_images/32f/5d9/5dc/32f5d95dc0413232545641757643450a.gif">  .  We enter this time to make it easier to evaluate. <img src="https://habrastorage.org/getpro/habr/post_images/f1a/834/f7c/f1a834f7c8cef63777eda20bbf906de0.gif">  .  From here two restrictions follow: a) formal - for any moment <img src="https://habrastorage.org/getpro/habr/post_images/6c0/41f/071/6c041f0719798776fc126b3a187118d1.gif">  inequality holds <img src="https://habrastorage.org/getpro/habr/post_images/636/67f/342/63667f342781cf31991004623d08a61f.gif">  , and b) informal - the sum of depreciation values ‚Äã‚Äãshould be easily considered. <br><br>  To have a concrete example in front of us, consider the data structure, inside which the stack lies.  The data structure supports the <code>op(m, x)</code> operation, which throws the last <img src="http://1450828402861163844240">  elements and then inserts the element <img src="http://1450828402934878545001">  . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stack, m, x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(m): stack.pop() stack.push(x)</code> </pre><br>  We will assume that the arguments are always correct, and they will never ask us to throw out more than what is on the stack.  In addition, we assume that <code>op(m, x)</code> is executed in <img src="https://habrastorage.org/getpro/habr/post_images/120/1b0/d9b/1201b0d9b5532db81306fd4017d61d20.gif">  step without <img src="https://habrastorage.org/getpro/habr/post_images/b73/d10/8f4/b73d108f42768d03e625be99e840c710.gif">  -notations  All our estimates can always be multiplied by a constant to get correct. <br><br>  Note that the time operation <code>op(m, x)</code> can last from one to <img src="https://habrastorage.org/getpro/habr/post_images/5e2/52f/7e4/5e252f7e45a49849d89bd57fa02ead91.gif">  steps.  A rough estimate will give time <img src="https://habrastorage.org/getpro/habr/post_images/021/899/b83/021899b83c49169fd0acf80d6eb30bec.gif">  to fulfill all <img src="http://1450828402386173878143">  operations. <br><br>  Depreciation analysis offers three valuation methods. <br><br><h4>  Banker method.  Time is money </h4><br>  Let every unit of time is a coin.  We will issue each operation <img src="https://habrastorage.org/getpro/habr/post_images/aa8/f6c/f14/aa8f6cf14c425f28abb706791033b3dc.gif">  coins and allow to spend <img src="https://habrastorage.org/getpro/habr/post_images/3bf/759/923/3bf759923987ff65c317f330116f92bd.gif">  .  All your coins transactions can be decomposed by data structure.  The depreciation value of one operation will be <img src="https://habrastorage.org/getpro/habr/post_images/6c2/372/830/6c23728309fe16b9570d18d9b1db97fc.gif">  . <br><br>  To maintain the invariant <img src="https://habrastorage.org/getpro/habr/post_images/636/67f/342/63667f342781cf31991004623d08a61f.gif">  , we will set a restriction: you cannot spend more coins than there are at the moment: <img src="https://habrastorage.org/getpro/habr/post_images/482/57a/d40/48257ad4097be8038470b8eae386381d.gif">  .  Insofar as <img src="https://habrastorage.org/getpro/habr/post_images/f10/75f/277/f1075f2773d6fd7719dd3307ed0807be.gif">  then <img src="https://habrastorage.org/getpro/habr/post_images/636/67f/342/63667f342781cf31991004623d08a61f.gif">  . <br><br>  For our example, we will issue one coin to each operation ( <img src="https://habrastorage.org/getpro/habr/post_images/c92/984/d64/c92984d648c59af58d8e0afb3b26072f.gif">  ).  Put it on the element that we just added to the stack.  So we paid for the future POP of this item. <br><br>  Note that at any time point on each element of the stack lies on the coin, i.e.  All POPs are prepaid. <br><br>  To throw out <img src="https://habrastorage.org/getpro/habr/post_images/1c2/fc1/60e/1c2fc160eed7ff72cf848c33c301ebc3.gif">  items we spend all the coins that lie on them ( <img src="https://habrastorage.org/getpro/habr/post_images/d66/ab8/fe5/d66ab8fe53e459a6039f5ff46b56edf5.gif">  ).  Then the depreciation value of each operation <img src="https://habrastorage.org/getpro/habr/post_images/bc1/d8d/789/bc1d8d78945f4b68ff6c154c3a670e84.gif">  .  It remains to be noted that <img src="https://habrastorage.org/getpro/habr/post_images/963/133/6bf/9631336bfc4f006976eac34acba360e9.gif">  .  We got the top linear score for execution <img src="http://1450828402386173878143">  operations. <br><br><h4>  Physics method.  Use your potential </h4><br>  Any data structure can take several possible states.  Let be <img src="https://habrastorage.org/getpro/habr/post_images/23a/9e5/c79/23a9e5c7982b614b9929e0b75810bb24.gif">  Is its initial state before all operations, and <img src="https://habrastorage.org/getpro/habr/post_images/0ed/86f/f27/0ed86ff27b71d69c44240869261517a6.gif">  - state after <img src="http://1450828402244982133357">  -th operation.  We will introduce the potential function <img src="https://habrastorage.org/getpro/habr/post_images/84c/c22/291/84cc22291effe8323068f35f4bcdc879.gif">  which takes as input the current state of the data structure and returns some non-negative number.  Potential <img src="https://habrastorage.org/getpro/habr/post_images/84c/c22/291/84cc22291effe8323068f35f4bcdc879.gif">  The initial state must be zero.  For simplicity, we denote <img src="https://habrastorage.org/getpro/habr/post_images/dc8/fa2/198/dc8fa2198e938f9406d6d9696fcd25d0.gif">  through <img src="https://habrastorage.org/getpro/habr/post_images/502/13e/038/50213e03844631a0379b39794be642ac.gif">  , but <img src="https://habrastorage.org/getpro/habr/post_images/bad/607/0be/bad6070be7eddd79f2540a305c214c5a.gif">  through <img src="https://habrastorage.org/getpro/habr/post_images/30d/24d/cc0/30d24dcc0d16c25853932aeee7e4e6ff.gif">  .  Depreciation value <img src="https://habrastorage.org/getpro/habr/post_images/be2/61f/304/be261f3044c53394b692f6f4e94d704c.gif">  . <br><br>  Invariant <img src="https://habrastorage.org/getpro/habr/post_images/636/67f/342/63667f342781cf31991004623d08a61f.gif">  follows from the definition of potential.  Really, <img src="https://habrastorage.org/getpro/habr/post_images/aaa/724/13d/aaa72413d1b6320b107b507b845be364.gif">  ;  everything <img src="https://habrastorage.org/getpro/habr/post_images/502/13e/038/50213e03844631a0379b39794be642ac.gif">  , except the first and last, are reduced and <img src="https://habrastorage.org/getpro/habr/post_images/94e/d52/55f/94ed5255f4621d50894d08481182bf92.gif">  .  Insofar as <img src="https://habrastorage.org/getpro/habr/post_images/672/ba7/f89/672ba7f89e2bfd48d45f576f38b175a0.gif">  then <img src="https://habrastorage.org/getpro/habr/post_images/636/67f/342/63667f342781cf31991004623d08a61f.gif">  . <br><br>  The general idea is to find such a potential function, which would have fallen heavily on expensive operations, compensating for the actual time, but on cheap ones it would grow a little.  For our example, the number of items in the stack is appropriate.  After <img src="http://1450828402861163844240">  <code>POP</code> and one <code>PUSH</code> <img src="https://habrastorage.org/getpro/habr/post_images/c72/e44/8ac/c72e448ace68e23381bea416a6e14d47.gif">  .  Then the depreciation value <img src="https://habrastorage.org/getpro/habr/post_images/9a5/5e8/7c6/9a55e87c62dac634f9ae2d1182145e67.gif">  , and again we obtain a linear estimate. <br><br><h4>  Aggregation method.  It is necessary to take and share everything </h4><br>  This method is a generalization of the previous two, and is to somehow count <img src="https://habrastorage.org/getpro/habr/post_images/f1a/834/f7c/f1a834f7c8cef63777eda20bbf906de0.gif">  and divide by the number of requests. <br><br>  In our case, this reasoning works.  Each <code>op(m, x)</code> operation performs one PUSH and several POPs.  You cannot throw more elements from the stack than you put there.  Just put in the stack <img src="http://1450828402386173878143">  elements, throw out no more <img src="http://1450828402386173878143">  .  So, the total time is <img src="https://habrastorage.org/getpro/habr/post_images/a3b/4e2/cce/a3b4e2cce0ae615b6f7288ca6027fe56.gif">  .  Amortization value of a single operation <img src="http://1450828402261639477430">  . <br><br><h3>  The system of disjoint sets </h3><br>  We were given <img src="http://1450828402386173878143">  items.  Elements can be combined into sets.  We want to make a data structure that supports three operations. <br><br><ul><li>  <code>make_set(key)</code> - creates a set of one element, </li><li>  <code>union(A, B)</code> - combines the sets <code>A</code> and <code>B</code> , </li><li>  <code>find(x)</code> - returns the set in which the element lies <img src="http://1450828402934878545001">  . </li></ul><br><br>  The data structure that supports these operations is called the disjoint-set (SNM) system (English disjoint-set data structure, union-find data structure or merge-find set). <br><br>  On Habr√© already wrote about SNM.  A detailed description of the algorithm and its application can be found <a href="http://habrahabr.ru/post/104772/">here</a> .  In this post, I briefly recall the algorithm itself and concentrate on the analysis. <br><br><h4>  Algorithm </h4><br>  Each set we will store as a tree.  The tree node stores a reference to the parent.  If the node is a root, the link points to <code>None</code> .  In addition, each node will have an additional <code>rank</code> field.  We will discuss it below. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> self.parent = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.rank = <span class="hljs-number"><span class="hljs-number">0</span></span> self.key = key</code> </pre><br>  To handle sets, we will select a representative for each set.  In our case, this will be the root of the tree.  If for two elements the representative matches, then they lie in one set.  To combine two sets, you need to hang one tree to the root of another.  We get a simple algorithm: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x.parent == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(x.parent) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">union</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> x = find(x) y = find(y) y.parent = x <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x</code> </pre><br>  To speed up the algorithm, two heuristics are used. <br><br>  <b>Ranks</b> .  Each node is assigned a rank, initially equal to zero.  The rank of the tree is the rank of its root.  When combining sets, we will hang a tree of lower rank to a larger tree.  If the ranks match, then first increase the rank of one of the trees by one. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">union</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> x = find(x) y = find(y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x.rank &lt; y.rank: x, y = y, x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x.rank == y.rank: x.rank += <span class="hljs-number"><span class="hljs-number">1</span></span> y.parent = x <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x</code> </pre><br>  Only one rank heuristic is enough to speed up the work of the SNM to <img src="http://1450828402111889118643">  for surgery at worst.  But we will go further. <br><br>  <b>Compression paths</b> .  Let we run <code>find</code> from the element <img src="http://1450828402934878545001">  .  You may notice that all the vertices on the way from <img src="http://1450828402934878545001">  until the root can be hung directly to the root. <br><br><img src="http://habrastorage.org/getpro/habr/post_images/f6f/041/073/f6f0410739ef598cc6d6e55aa5ec857b.png"><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x.parent == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x x.parent = find(x.parent) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.parent</code> </pre><br>  Surprisingly, together these two heuristics reduce the depreciation time of a single operation to almost a constant. <br><br><h4>  Analysis </h4><br>  In 1973, Hopcroft and Ullman showed that SNM with two heuristics processes <img src="http://1450828402861163844240">  operations for <img src="http://habrastorage.org/getpro/habr/post_images/1f1/629/5ff/1f16295ff54573a0984e5eb5dfc337f5.gif">  where <img src="http://1450828402238210543677">  - iterative logarithm.  Later, in 1975, Taryan showed that the SNM was working for <img src="http://habrastorage.org/getpro/habr/post_images/ebb/e70/c27/ebbe70c27ba27316ad984d415a1cda6d.gif">  where <img src="http://1450828402435617932700">  - the inverse function of Ackermann. <br><br>  My plan is to first analyze what kind of cunning functions are, then to prove a simple logarithmic estimate in the worst case, and at the end to analyze the estimate of Hopkroft and Ulman.  Tarjan's assessment is also actively using depreciation analysis, but contains more technical details. <br><br><h4>  Tricky features </h4><br>  Iterative logarithm is the function inverse to a power tower.  Let's imagine the number of the form <img src="http://1450828402720928646811">  where only twos will be <img src="http://1450828402697373274400">  .  Then <img src="http://1450828402238210543677">  - this is the minimum <img src="http://1450828402697373274400">  that power tower height <img src="http://1450828402697373274400">  there will be more <img src="http://1450828402386173878143">  .  Formally <br><br><ul><li><img src="http://habrastorage.org/getpro/habr/post_images/515/581/cc9/515581cc976706e327af17032fc53fe4.gif">  for anyone <img src="http://habrastorage.org/getpro/habr/post_images/c4d/d89/5f9/c4dd895f968a6d5bb316545491377422.gif">  ; </li><li><img src="http://habrastorage.org/getpro/habr/post_images/d9a/405/000/d9a4050003d36f68a7f27bfcafac5408.gif">  for <img src="http://habrastorage.org/getpro/habr/post_images/cbd/273/0f5/cbd2730f50cd842d201bebd04e03fd01.gif">  . </li></ul><br><br>  Exercise the reader to show that the iterative logarithm of the number of particles in the known part of the universe does not exceed five. <br><br>  One might think that the power tower is growing rapidly, but this was not enough for mathematicians of the early twentieth century, and they invented the function of Ackermann.  It is defined as: <br><br><ul><li><img src="http://habrastorage.org/getpro/habr/post_images/27a/bf3/9f8/27abf39f89661d5b7673591e1f106966.gif">  for <img src="http://habrastorage.org/getpro/habr/post_images/86e/26a/977/86e26a977f16adb788d557a219e973dd.gif">  ; </li><li><img src="http://habrastorage.org/getpro/habr/post_images/d05/ae6/aca/d05ae6aca0005337d7a7b19f15a247ae.gif">  for <img src="http://habrastorage.org/getpro/habr/post_images/07c/66d/7a2/07c66d7a224091c7ee7cd73f58c7dfe1.gif">  ; </li><li><img src="http://habrastorage.org/getpro/habr/post_images/856/f49/8f3/856f498f3fd629f4c455cec40b2f62ca.gif">  for <img src="http://habrastorage.org/getpro/habr/post_images/7ba/945/1dd/7ba9451dd8a076443c798fbd89801c9d.gif">  . </li></ul><br><br>  This feature is growing very fast.  With <img src="http://habrastorage.org/getpro/habr/post_images/fe6/b47/8d3/fe6b478d35385ef96251809fe6e7907c.gif">  It is a power tower.  With <img src="http://habrastorage.org/getpro/habr/post_images/52a/543/9f9/52a5439f9f7c34b32743f3319f969766.gif">  it is also a power tower, only now the number of twos in the tower is also a power tower, etc. <br><br>  If you want to take revenge on the enemy, ask him to calculate this function using only arithmetic operations, if-s and for-s (while-s and recursion cannot).  Akkerman proved that he will fail. <br><br>  Akkerman‚Äôs inverse function <img src="http://1450828402435617932700">  defined as the minimum <img src="http://1450828402244982133357">  such that <img src="http://habrastorage.org/getpro/habr/post_images/5c9/279/231/5c927923100328988eb7652aa626664b.gif">  .  It is easy to understand that it is growing very slowly. <br><br><h4>  Worst case score </h4><br>  First, note that each <code>union</code> is done in two <code>find</code> operations and some additional time constant.  So, it is enough to evaluate only <code>find</code> .  Estimation in the worst case follows from two simple observations. <br><br>  <b>Observation 1</b> .  Rank tree <img src="http://1450828402697373274400">  contains at least <img src="http://1450828402612494073707">  knots. <br><br>  This statement is proved by induction.  For a tree of rank 0, obviously.  To get a tree rank <img src="http://1450828402697373274400">  , you need to combine two trees of rank <img src="http://habrastorage.org/getpro/habr/post_images/9ad/547/33f/9ad54733fb77a4a1f52b31b20bb44b48.gif">  in each of which at least <img src="http://habrastorage.org/getpro/habr/post_images/1f0/2c2/2ac/1f02c22ac42342503cea146b58bd5cc9.gif">  knots.  So in the rank tree <img src="http://1450828402697373274400">  will be at least <img src="http://1450828402612494073707">  knots. <br><br>  As a result, at any given time, rank nodes <img src="http://1450828402697373274400">  will be no more <img src="http://habrastorage.org/getpro/habr/post_images/0f5/670/12f/0f567012f4b4bac7f7abeff773170d4d.gif">  and maximum node rank <img src="http://1450828402761387063171">  . <br><br>  <b>Remark 2</b> .  The rank of the parent is always greater than the rank of the child. <br><br>  It follows from the construction.  Since on the way from the top to the root the rank always increases, its length does not exceed <img src="http://1450828402761387063171">  and any <code>find</code> works for <img src="http://1450828402111889118643">  . <br><br><h4>  Evaluation of Hopcroft and Ulman </h4><br>  Prove that <img src="http://1450828402861163844240">  SNM operations over <img src="http://1450828402386173878143">  items can be held for <img src="http://1450828402854195895854">  . <br><br>  The <code>make_set</code> operation <code>make_set</code> performed in <img src="http://1450828402261639477430">  .  <code>union</code> operation <img src="http://1450828402261639477430">  plus the time for two <code>find</code> operations.  So, it suffices to show that <img src="http://1450828402861163844240">  <code>find</code> operations will be performed in <img src="http://1450828402854195895854">  . <br><br>  The execution time of the <code>find</code> operation is proportional to the length of the path that is required to pass from the specified node to the root.  Therefore, it is necessary to estimate the total number of passes through the nodes. <br><br>  Divide all ranks on <img src="http://1450828402238210543677">  sets: <img src="http://habrastorage.org/getpro/habr/post_images/97e/713/6ce/97e7136ce19774bfab3f236047400829.gif">  .  AT <img src="http://1450828402244982133357">  -th set will contain all ranks from the power tower <img src="http://1450828402720928646811">  heights <img src="http://habrastorage.org/getpro/habr/post_images/b83/4cf/f7c/b834cff7cf1e4a1208c8d33f4d8659aa.gif">  to tower height <img src="http://1450828402244982133357">  .  The number of the set in which the rank of a node lies is called the level of the node. <br><br>  We say that a node is good if it is the root of the tree, the immediate child of the root, or he and his parent have different levels.  The remaining nodes are called bad. <br><br>  Total levels no more <img src="http://1450828402238210543677">  .  Hence, the path from any node to the root contains at most <img src="http://habrastorage.org/getpro/habr/post_images/461/5f2/6f1/4615f26f1ba606ef7cd16a2c1cf9185d.gif">  good knots.  The total <code>find</code> will take no more than <img src="http://1450828402854195895854">  good knots. <br><br>  Estimate the number of passes on bad nodes.  Let the bad knot <img src="http://1450828402934878545001">  has rank <img src="http://1450828402813614927165">  and <img src="http://1450828402813614927165">  belongs to many <img src="http://1450828402170452928442">  .  Note that a bad node is not a root, and therefore its rank is fixed.  If <code>find</code> goes through the node <img src="http://1450828402934878545001">  then <img src="http://1450828402934878545001">  changes its parent to a new one with a big rank.  No more than <img src="http://1450828402612494073707">  passes through <img src="http://1450828402934878545001">  like a bad knot <img src="http://1450828402934878545001">  will be good. <br><br>  Total nodes rank <img src="http://1450828402813614927165">  no more <img src="http://habrastorage.org/getpro/habr/post_images/d4b/a60/d83/d4ba60d830c527a7c82da4a2d6e6e11a.gif">  .  So nodes with ranks from the set <img src="http://1450828402170452928442">  will be no more <img src="http://habrastorage.org/getpro/habr/post_images/1e8/0a4/bca/1e80a4bca486023e5fd98e0e87a68152.gif">  .  Each node has no more than <img src="http://1450828402612494073707">  passages, like a bad knot.  So in the amount of passes will be no more <img src="http://1450828402386173878143">  .  Total levels <img src="http://habrastorage.org/getpro/habr/post_images/e25/fdf/d6b/e25fdfd6b9b2943e75f5537c1da31b85.gif">  .  This means that there will be no more passes on bad nodes. <img src="http://1450828402854195895854">  . <br><br>  Total, got the top score <img src="http://1450828402854195895854">  for all transactions in the amount. <br><br><h3>  Literature </h3><br><ul><li>  Kormen, Leyzerson, Rivest "Algorithms: construction and analysis" </li><li>  Tarjan "Data Structures and Network Algorithms" </li><li>  Rebecca Fiebrink Amortized Analysis Explained </li></ul></div><p>Source: <a href="https://habr.com/ru/post/208624/">https://habr.com/ru/post/208624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208614/index.html">ReactOS came out on Kickstarter (but nobody knows about it)</a></li>
<li><a href="../208616/index.html">Results of CES 2014: Samsung Smart Control 2014</a></li>
<li><a href="../208618/index.html">Python-digest # 9. News, interesting projects, articles and interviews [December 27, 2013 - January 10, 2014]</a></li>
<li><a href="../208620/index.html">How we saved the polar bears in the "cloud"</a></li>
<li><a href="../208622/index.html">How to subscribe on the Internet</a></li>
<li><a href="../208628/index.html">HabraFAQ on cellular</a></li>
<li><a href="../208630/index.html">Turning a GoPro 3 action camera into a photo and camcorder with c-mount lenses</a></li>
<li><a href="../208632/index.html">RiderEcall is the commercial equivalent of ECall (and ERA-GLONASS) for motorcyclists. Epitaph</a></li>
<li><a href="../208634/index.html">Calendar IT-RENEWAL-2014 under Windows 8.1</a></li>
<li><a href="../208636/index.html">Six Reasons for Apple to Embed Video Trailers on the App Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>