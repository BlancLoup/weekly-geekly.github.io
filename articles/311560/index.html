<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shared pointers and multithreading. And again about them, again</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The chapter from the book "Modern Programming in C ++" is called "One hundred and first time about smart pointers". Everything would be fine, but the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shared pointers and multithreading. And again about them, again</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/ed3/c27/14b/ed3c2714b20d44f49daa617b7428dcce.png" align="left">  The chapter from the book "Modern Programming in C ++" is called "One hundred and first time about smart pointers".  Everything would be fine, but the book was published in 2001, so is it worth it again to return to this topic?  It seems to me that it is just now worth it.  Over these fifteen years, the point of view itself has changed, the angle at which we are looking at the problem.  In those days, the first de facto standard implementation, boost :: shared_ptr &lt;&gt;, was just released, before that everyone wrote an implementation on demand and at least imagined the details, the strengths and weaknesses of their code.  All books on C ++ at that time necessarily described one of the variations of smart pointers in the smallest detail. </p><br><p>  Now we are given a standard, and this is good.  But on the other hand, you no longer need to understand what is inside, instead, it is enough to repeat the mantra three times <em>"use smart pointers wherever you would use ordinary pointers"</em> , and this is not so good.  I suspect that not everyone is aware that this standard is only one of the possible interface options, not to mention the difference between the implementations of different vendors.  When choosing a standard, a choice was made between various possibilities, taking into account various factors, but, optimal or not, this choice is obviously not the only one. </p><br><p>  And on stackoverflow, for example, the question is asked again and again: "Are smart pointers from the standard library thread safe?".  Answers are usually categorical, but some are not very informative.  If I for example did not know what was going on, I probably would not have understood.  And by the way, all the relatively new books describing the new C ++ standard also pay little attention to this issue. </p><br><p>  So let's try to break the covers and deal with the details. </p><a name="habracut"></a><br><p>  We will immediately define the terminology, we are not talking about data protection to which the pointer refers, it can be an object of arbitrary complexity and multi-threaded access to it requires, in general, separate synchronization.  By the thread-safety of a smart pointer, we mean the security of the pointer itself to the data and the validity of the internal reference counter.  Figuratively speaking, if pointers are created via <em>std :: make_shared &lt;&gt; (),</em> then no assignments, transfers to functions or other streams, swaps, destruction, can cause it to be in an invalid state.  Until we call <em>reset ()</em> or <em>get ()</em> , we can expect the pointer to refer to some valid object, although not necessarily the one we mean. </p><br><p>  One of the popular answers to the heading question: " <em>It is only the control block itself which is thread-safe.</em> ".  So we will see what is meant specifically by the <em>control block</em> and <em>safe</em> . <br>  For experiments used <em>g ++ - 5.4.0</em> . </p><br><h4 id="nachnem-s-primera">  <strong>Let's start with an example</strong> </h4><br><p>  Let some information in the shared memory be packed into the structure and accessible through the pointer.  There is one or many independent streams that must read and use this data without modification, as a rule, it turns out that access speed is crucial for them.  At the same time, let there be one or several streams modifying this data with integrity violation, in practice it usually turns out that modifications happen much less frequently and the access speed there is not so important.  However, staying within the framework of the classic ( <em>exclusive lock</em> ) synchronization, we are forced to serialize read access even if no data changes have occurred.  Naturally, this is reflected in efficiency in the most fatal way, and this situation occurs so often, perhaps in a slightly different version, that I would venture to call it the main issue of multi-threaded programming. </p><br><p>  Of course, there are standard solutions, <em>boost :: shared_mutex</em> and his young scion <em>std :: shared_mutex</em> , which allow two access levels - shared for reading and exclusive for writing.  However, I, having heard that <em>std :: shared_ptr</em> gives thread-safe access to the <em>control block</em> (and not really understanding what this means), and also that the operations on it are implemented lock-free, I want to offer my elegant solution: </p><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   std::shared_ptr&lt;SHARED_DATA&gt; data; reading_thread { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       auto read_copy=data; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  read_copy } writing thread { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     auto update=std::make_shared&lt;SHARED_DATA&gt;(...args); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ (?)   data=update; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/          }</span></span></code> </pre> <br><p>  here we have to recreate the structure with the data each time for any update, but this is a fairly acceptable case in practice. </p><br><p>  So, will it work?  Of course <strong>not!</strong>  But <strong>why?</strong> </p><br><h4 id="kak-ono-ustroeno">  <strong>How it works</strong> </h4><br><p>  If you look at the structure of the shared pointer <br>  /usr/include/c++/5/bits/shared_ptr_base.h: 1175 </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _Tp, _Lock_policy _Lp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: _Tp* _M_ptr; <span class="hljs-comment"><span class="hljs-comment">// Contained pointer. __shared_count&lt;_Lp&gt; _M_refcount; // Reference counter. };</span></span></code> </pre> <br><p>  it can be seen that it consists of <strong>two</strong> members - a pointer to the actual data and the <em>control block itself</em> .  But the fact is that there is no way to change, assign, move, etc. atomically and without blocking.  both elements.  That is, shared pointers cannot be safe (.?) A point or a question mark?  Well, it seems to be a point, but some kind of vague, not final, somehow it is trivial and too simple.  We were told that "only access to the control unit is safe," and we did not check. </p><br><h4 id="davayte-razbiratsya-roem-glubzhe">  <strong>Let's figure it out, dig deeper</strong> </h4><br><pre> <code class="hljs ruby">auto data=std::make_shared&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); void read_data() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) auto read_copy=data; } int main() { std::thread(read_data).detach(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) data=std::make_shared&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Such a minimalist example implements the proposed idea and, in general, justifies the expectations - it falls with a crash just by winding several hundred cycles.  However, pay attention, we never address the data itself, the pointer is not dereferenced.  That is, something amiss is happening with the control unit?  But now we have a code with which you can work as a debugger.  But first, let's take a look at other possible options: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sp=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic_load(&amp;data); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">**argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread(read_data).detach(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic_exchange(&amp;data, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)); assert(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic_is_lock_free(&amp;data)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  here everything is fine work <del>  em </del>  if it were not for <em>assert ()</em> in the body of the loop.  That is, atomic operations on <em>std :: shared_ptr are</em> defined, but they are blocking.  Well, this is not our way, on mutexes I myself can.  Another option: </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; variant[]={ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data=variant[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sp=data; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread(read_data).detach(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n=<span class="hljs-number"><span class="hljs-number">0</span></span>;; ++n) { data=variant[n%<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  almost identical, but it works perfectly by fully loading two cores at 100%.  The difference is that here one of the threads never calls the destructor.  So, destructors of standard pointers are unsafe?  I do not believe.  Let's go back to the original version and </p><br><h4 id="kopnem-esche-poglubzhe">  <strong>Digging deeper</strong> </h4><br><p>  Consider a closer reading stream: </p><br><pre> <code class="hljs haskell"> auto sp=<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p>  Here, the copy constructor and destructor are all called in a loop. </p><br><div class="spoiler">  <b class="spoiler_title">here are the extracts from the source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//L1#shared_ptr_base.h : 662 __shared_count(const __shared_count&amp; __r) noexcept : _M_pi(__r._M_pi) { if (_M_pi != 0) _M_pi-&gt;_M_add_ref_copy(); } //L2#shared_ptr_base.h : 134 void _M_add_ref_copy() { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); } //L1#shared_ptr_base.h : 658 ~__shared_count() noexcept { if (_M_pi != nullptr) _M_pi-&gt;_M_release(); } //L2#shared_ptr_base.h : 147 if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1) { _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count); _M_dispose(); }</span></span></code> </pre> </div></div><br><br><p>  which, if we discard all unnecessary, come down to </p><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span> ctor __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, <span class="hljs-number"><span class="hljs-number">1</span></span>); // <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> instance dtor <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, <span class="hljs-number"><span class="hljs-number">-1</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span>) _M_dispose();</code> </pre> <br><p>  or if go to pseudocode </p><br><pre> <code class="hljs php">++_M_pi-&gt;_M_use_count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(--_M_pi-&gt;_M_use_count == <span class="hljs-number"><span class="hljs-number">0</span></span>) dispose();</code> </pre> <br><p>  Here, the increment and decrement operators are implied atomic, and the dispose () function clears the memory and, in particular, invalidates the pointer to the reference counter <em>_M_pi</em> .  I must say that for accustomed multithreading expression: </p><br><p>  <em>if (- cnt == 0)</em> <br>  <em>do_something ();</em> </p><br><p>  It looks like a grenade with a torn-out check, between these two lines can occur, and necessarily, literally anything happens.  The only thing from which such a construction reliably protects is from a similar call in another thread - no matter how many times the atomic decrement operator is called, only one of them will reset the counter. </p><br><p>  However, what happens at this time in a different, writing, stream? </p><br><ul><li>  The constructor of the new object is called.  This is a completely independent object, so we are not concerned in any way. </li><li>  another degenerate pointer is created </li><li>  over these three pointers the classic cyclic swap () is called </li><li>  the destructor of the temporary pointer (which now contains the original data) is called </li><li>  the destructor of the degenerate pointer is called, it also does not threaten us </li></ul><br><div class="spoiler">  <b class="spoiler_title">somewhere like this</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//L1#shared_ptr.h : 291 shared_ptr&amp; operator=(shared_ptr&amp;&amp; __r) noexcept { this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r)); //L2#shared_ptr_base.h : 997 __shared_ptr&amp; operator=(__shared_ptr&amp;&amp; __r) noexcept { __shared_ptr(std::move(__r)).swap(*this); //L#3shared_ptr_base.h : 932 __shared_ptr(__shared_ptr&amp;&amp; __r) noexcept : _M_ptr(__r._M_ptr), _M_refcount() { _M_refcount._M_swap(__r._M_refcount); //L#4shared_ptr_base.h : 684 void _M_swap(__shared_count&amp; __r) noexcept { _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi; __r._M_pi = _M_pi; _M_pi = __tmp; } //L2#shared_ptr_base.h : 1073 void swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other) noexcept { std::swap(_M_ptr, __other._M_ptr); _M_refcount._M_swap(__other._M_refcount); } //L3#shared_ptr_base.h : 684 void _M_swap(__shared_count&amp; __r) noexcept { _Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi; __r._M_pi = _M_pi; _M_pi = __tmp; } //L2#shared_ptr_base.h : 658 ~__shared_count() noexcept { if (_M_pi != nullptr) _M_pi-&gt;_M_release(); } //L3#shared_ptr_base.h : 142 void _M_release() noexcept { // Be race-detector-friendly. For more info see bits/c++config. _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count); if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1) { _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count); _M_dispose(); //L1#shared_ptr.h : 93 (destructor) //L2#shared_ptr_base.h : 658 ~__shared_count() noexcept { if (_M_pi != nullptr) //_M_pi == nullptr - true here _M_pi-&gt;_M_release(); }</span></span></code> </pre> </div></div><br><p>  If we drop all the excess, there will be approximately such code fragments: </p><br><pre> <code class="hljs markdown"> <span class="hljs-emphasis"><span class="hljs-emphasis">_Sp_</span></span>counted<span class="hljs-emphasis"><span class="hljs-emphasis">_base&lt;_</span></span>Lp&gt;* <span class="hljs-strong"><span class="hljs-strong">__tmp = __</span></span>r.<span class="hljs-emphasis"><span class="hljs-emphasis">_M_</span></span>pi; <span class="hljs-strong"><span class="hljs-strong">__r._M_pi = _M_pi; _M_pi = __</span></span>tmp; if (<span class="hljs-strong"><span class="hljs-strong">__gnu_cxx::__</span></span>exchange<span class="hljs-emphasis"><span class="hljs-emphasis">_and_</span></span>add<span class="hljs-emphasis"><span class="hljs-emphasis">_dispatch(&amp;_</span></span>M<span class="hljs-emphasis"><span class="hljs-emphasis">_use_</span></span>count, -1) == 1) <span class="hljs-emphasis"><span class="hljs-emphasis">_M_</span></span>dispose();</code> </pre> <br><p>  Again, the first three lines ( <em>swap ()</em> ) look extremely suspicious, but with careful analysis they turn out to be completely safe (of course only in this context) and all that remains is (pseudo-code). </p><br><pre> <code class="hljs lisp">if(<span class="hljs-name"><span class="hljs-name">--_M_pi-&gt;_M_use_count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) dispose()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  the very expression that we just considered safe.  Here comes the moment of truth: <br>  // assert (_M_use_count == 1); </p><br><table><thead><tr><th>  <strong>// writing thread</strong> </th><th>  <strong>// reading thread</strong> </th></tr></thead><tbody><tr><td>  if (--_ M_pi -&gt; _ M_use_count == 0) // true </td><td>  . </td></tr><tr><td>  . </td><td>  ++ _ M_pi -&gt; _ M_use_count;  // count = 1 </td></tr><tr><td>  . </td><td>  if (--_ M_pi -&gt; _ M_use_count == 0) // true </td></tr><tr><td>  dispose ();  // I am the first!  BANG !! </td><td>  dispose ();  // not me!  BANG !! </td></tr></tbody></table><br><p>  This is how the combination of atomic increment and atomic decrement leads to a race between threads and <em>std :: shared_ptr &lt;&gt; is</em> not thread-safe, even at the level of a control block.  Now really the point. </p><br><p>  A little later, I found an aphoristic summary of this principle in the documentation for <em>boost :: shared_ptr &lt;&gt;</em> .  It sounds like this: <strong>"Pointers are safe either only for writing or only for reading, and unsafe with concurrent reading / writing."</strong>  Having slightly developed this idea and realizing that bare writing without reading data is practically meaningless, we see that standard smart pointers are safe for reading, that is, just as safe are normal constant pointers.  That is, all this complex internal machinery is created in order to reach the level of ordinary pointers, but no more, a <strong>fat point</strong> . </p><br><h4 id="-vmesto-zaklyucheniya-ot-analiza-k-sintezu-">  <strong>Instead of a conclusion.</strong>  <strong>From analysis to synthesis</strong> </h4><br><p>  I would like to finish on a light note, that is, to offer, at least at the concept level, an algorithm that does not use blocking mutexes and allows safe operations with shared pointers from different threads.  However, I failed, moreover, I had the conviction that, on the basis of existing elementary non-blocking primitives, this is simply impossible.  Of course, it‚Äôs enough just to write a <em>spinlock</em> -based version, but it would be unsportsmanlike, I don‚Äôt consider such algorithms to be truly non-blocking.  You can take as a basis any existing multithreaded blocking implementation and replace each mutex with the corresponding <em>spinlock</em> , that is, algorithmically reduce the task to choosing a more efficient mutex type.  Obviously this is not our way. </p><br><p>  What are we missing for a full-fledged non-blocking implementation?  There is a very small number of non-blocking primitives working only with built-in types: </p><br><ul><li>  add an integer constant (postfix or prefix) - <em>atomic_fetch_and_add</em> and its variations </li><li>  the exchange of two values ‚Äã‚Äã(in fact, asymmetrical, only one of the operands changes atomically) - <em>atomic_swap</em> </li><li>  conditional exchange or assignment with equality test - <em>atomic_compare_and_swap</em> </li></ul><br><p>  Considering the unconditional ban on the <em>if ()</em> operator in non-blocking algorithms, only the latter is suitable for the role of the branch operator, but its most serious limitation is that it allows <em>checking</em> and <em>assignment</em> solely to the same variable.  In general, it is easy to notice something in common in all three primitives - they work atomically with one and only one memory area the size of a machine word, the reasons are obvious, I think.  Looking closely at the generalized structure of the shared pointer, we see that it <em>must</em> contain at least one pointer to the shared data (including the <em>control block</em> ), and somewhere <em>in</em> this block there should be a reference counter.  For any operations with the pointer itself, for example, assignment, we must <em>atomically</em> check the counter and simultaneously change the pointer to the control block, which is impossible using existing atomic primitives.  It follows that the creation of a full-fledged non-blocking shared pointer is impossible in principle. </p><br><p>  In fact, I would be happy to make a mistake, maybe there is something that I do not know or understand wrong?  Anyone wishing to challenge waiting in the comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/311560/">https://habr.com/ru/post/311560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311548/index.html">CompTIA certifications for IT professionals. Part 5 of 7. CompTIA CASP (Advanced Security Practitioner)</a></li>
<li><a href="../311552/index.html">The source code of the components of the Mirai IoT botnet is freely available.</a></li>
<li><a href="../311554/index.html">How to stop debugging asynchronous code and start living</a></li>
<li><a href="../311556/index.html">DDoS attacks and protection against them - how much does it cost Russian companies?</a></li>
<li><a href="../311558/index.html">AI Cradle</a></li>
<li><a href="../311562/index.html">Microcircuits from different sides: Nanometer ASIC, MIPSfpga and Connected MCU workshops in Russia, Ukraine and Kazakhstan</a></li>
<li><a href="../311566/index.html">Dot the ss</a></li>
<li><a href="../311568/index.html">Is your favorite C so fast or the native implementation of linear algebra on D</a></li>
<li><a href="../311572/index.html">"Write letters": Three techniques of layout of good emails</a></li>
<li><a href="../311574/index.html">Techleads Meetup in Badoo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>