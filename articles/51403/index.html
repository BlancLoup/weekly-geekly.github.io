<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Resource manager</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I want to talk about one of the components of modern games, or rather game engines. It is not discussed by gamers, they do not write about it in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Resource manager</h1><div class="post__text post__text-html js-mediator-article">  Today I want to talk about one of the components of modern games, or rather game engines.  It is not discussed by gamers, they do not write about it in advertising brochures and reviews, but without it it is impossible to create a modern graphic engine.  This composer is a resource manager. <br>  The resource manager does not directly affect the quality of the soundtrack of the game, nor its ‚Äúbeautifulness‚Äù; however, without a good resource manager, there will be neither a variety of soundtracks nor the riotousness of colors of the heaviest textures. <br>  In this article I will try to describe several manager implementations.  Each implementation is suitable for a project of its level, each has both advantages and disadvantages. <br><a name="habracut"></a><br><h2>  Basic concepts. </h2><br>  To talk about a resource manager, you must first enter a definition of a resource.  The managers that I will consider are dealing only with virtual renewable resources.  Next, I will adhere to this definition: <br><blockquote>  A resource is some object that can be accessed by reference.  This object can be created, used, deleted. </blockquote><br>  In games, resources are practically all that we see and hear (models, textures, sounds, and even, sometimes, code). <br><br><h2>  The implementation is zero (no implementation) </h2><br>  This implementation is that each module of the future game engine loads and stores all its data itself.  When creating a new game object (when loading a game), the disk is accessed; everything that needs to be loaded and saved somewhere inside the game object class.  This functionality is quickly implemented, the game is loaded and works on test textures.  However, with the appearance in the game of a large number of heavy textures, it starts loading and unloading for a very long time and takes up a huge amount of RAM.  The reason lies in the fact that each super-beautiful, but super heavyweight texture from your designers is loaded and stored separately for each game object.  That is, if there are 25 identical cubes in a game, then 25 copies of maps will be in memory, and when loading, the texture will be loaded 25 times from the disk.  Not bad, right? <br><br><h3>  Advantages of this approach: </h3><br>  Fast implementation on small projects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Cons of this approach: </h3><br>  Re-loading and storing identical data. <br><br><h2>  The first implementation (protomanager. Shared memory) </h2><br>  The texture of the cube is not unique, so it is quite possible to store one copy of it, and then just tell where this copy is to all the cubes-objects.  We allocate memory for texurs, we load them into it, and when we create an object, we simply tell it where its texture lies.  The main advantage of this method is the speed of implementation.  The main disadvantage is non-expandability.  For each new object, it is very difficult to write code loading its textures, properly transferring references to them, and monitoring the release of all memory areas with textures.  Also, since we do not know the time when the object was created, the entire load load falls on the moment the game or level is loaded.  Also a critical moment - the end of the game, when a huge amount of various resources will be unloaded from memory. <br><br><h3>  Advantages of this approach: </h3><br>  Texture is loaded only once. <br><br><h3>  Minuses: </h3><br>  The need for hands to prescribe where the texture is. <br>  Large load when loading and unloading the game (level). <br><br><h2>  The implementation of the second (Full functionality) </h2><br>  At this stage, you can already select the resource manager as a separate unit. <br>  A few words about how it looks: <br><br>  1. The manager works with the abstract concept of "resource", which he can create, give to use or destroy.  As a result, we will manage it all that we see and hear in the game.  (This item is optional, but if it works only with textures, it will be a texture manager, if models are models, etc.). <br>  2. Each resource has its own identifier that uniquely identifies this resource.  In essence, this is the path to the file for this resource. <br>  3. Work with the manager is reduced to two appeals from the outside: I want_to receive_resource (identifier) ‚Äã‚Äãand I_more_number_necessary_resource (identifier).  Whether this resource has already been uploaded is the business of the manager and it does not concern anyone anymore. <br><br><h3>  Advantages of this approach: </h3><br>  A resource is loaded only once and only when its first clone is needed. <br>  Relative ease of implementation. <br>  A new block appears, which begins to eat processor cycles, but cycles are spent only with the requirements and exemptions of the resource. <br><br><h3>  Minuses: </h3><br>  Data has to be packaged into a resource interface. <br>  Before the appearance of the first copy of a heavy resource, there will be a delay in loading (lag).  Most of these resources will turn to load, but some will remain. <br><br><h2>  The implementation of the third.  (Complicated) </h2><br>  In order for the drawing of a new resource not to be delayed, the notion of ‚Äúunloaded resource‚Äù is introduced.  That is, as soon as a request comes in, I want a resource like this, and this resource is not loaded, the manager immediately responds with a pointer to the memory where the resource will be located, but the resource itself is not there, but the flag is coded that it is not loaded.  Then there are two common options: <br>  The game continues to be played just without a resource.  This option is often acceptable.  For example, if you have a shooter and on the horizon (the border of the drawing) a building appeared for a couple of hundred thousand polikov, then until you reach it and it can make any contribution to the gameplay, it will be fully loaded. <br>  First, the load resource is loaded, which weighs very little. (You go in a shooter, and a cube with a grid texture appears in the distance. In the meantime, you come up with a model with windows and a porous concrete or brick texture.) <br><pre>  Note: Naturally, if you threw a grenade, and you do not have an explosion animation in memory, this approach will not help you. </pre><br>  As for the download itself, then it is necessary to allocate either a separate stream for downloading, or to implement the update method in the manager and from time to time to call it. <br><h3>  Advantages of this approach: </h3><br>  Quite discreet loading of heavy resources. <br>  All the advantages of an ordinary manager. <br><br><h3>  Minuses: </h3><br>  It is necessary to create additional threads. <br>  Complicated resource interface. <br>  The complexity of the manager interface (The need to create methods: issue a resource immediately). <br>  The appearance of additional threads (or the update method), and in consequence of the increased consumption of cycles. <br><br><h2>  What's next? </h2><br>  Then we can distinguish two approaches to resource management. <br>  1. This control all links to resources.  As soon as no one refers to the resource, then unload it.  Resource forgotten.  But this technology is already the Garbadge collector. <br>  2. Application of strategies to resources.  Suppose it is necessary to visualize the process of falling drops from a tap: a drop appears (loads), flies, falls into a bowl (unloaded) and after a second the drop appears again.  If you apply the unloading strategy not after everything has been forgotten about the resource, but only after some time, then you can save great time on reloading / unloading.  But the strategy will greatly increase the number of spent cycles. <br><br><h2>  Instead of a conclusion. </h2><br>  This gradation of managers was invented by me and does not pretend to absolute completeness and accuracy.  Many questions remained unsolved, for example, storage of resources and methods for their loading, but I hope that it shows the need to take into account and develop not only graphics / physics / voice acting in their projects, but also a whole layer of serving code. <br></div><p>Source: <a href="https://habr.com/ru/post/51403/">https://habr.com/ru/post/51403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../51396/index.html">Eclipse / pyDev contrast scheme under TextMate</a></li>
<li><a href="../51398/index.html">C ++ MythBusters. The myth of the virtual functions (addition)</a></li>
<li><a href="../51399/index.html">Number or label?</a></li>
<li><a href="../51400/index.html">In social networks more women.</a></li>
<li><a href="../51401/index.html">Happy birthday to Mendeleev</a></li>
<li><a href="../51404/index.html">ORM or simple filling of the class with data from the stored procedure</a></li>
<li><a href="../51406/index.html">"Favorite Internet"</a></li>
<li><a href="../51410/index.html">ReactOS - Open Source Windows?</a></li>
<li><a href="../51412/index.html">Functional programming :: recursive functions</a></li>
<li><a href="../51417/index.html">Music widgets 9 months later</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>