<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>std :: shared_ptr and custom allocator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Which of us doesn't like refactoring? I think that many times each of us, when refactoring old code, discovered something new or remembered something ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>std :: shared_ptr and custom allocator</h1><div class="post__text post__text-html js-mediator-article"><p>  Which of us doesn't like refactoring?  I think that many times each of us, when refactoring old code, discovered something new or remembered something important, but well forgotten.  Most recently, having somewhat refreshed my knowledge of how std :: shared_ptr works when using a custom allocator, I decided that you shouldn‚Äôt forget them anymore.  All that was refreshed managed collected in this article. </p><a name="habracut"></a><br><p>  In one of the projects, it was necessary to optimize performance.  Profiling pointed to a large number of calls to the new / delete operators and the corresponding calls to malloc / free, which not only lead to expensive locks in a multithreaded environment by themselves, but can also cause such heavy functions as malloc_consolidate at the most unexpected moment.  A large number of operations with dynamic memory was caused by intensive work with smart pointers std :: shared_ptr. </p><br><p>  There were not many classes whose objects were created in this way.  In addition, I did not want to rewrite the application.  Therefore, it was decided to investigate the possibility of using the pattern - object pool.  Those.  leave the use of shared_ptr, but redo the memory allocation mechanism in such a way as to get rid of the intensive acquisition / release of dynamic memory. </p><br><p>  Replacing the standard implementation of malloc with other variants (tcmalloc, jemalloc) was not considered, since  by experience, the replacement of the standard implementation did not affect the performance fundamentally, but the changes would have affected the entire program with possible consequences. </p><br><p>  Later, the idea was transformed into the use of its own memory pool and the implementation of a special allocator.  The advantage of using the memory pool in my case over the object pool is transparency for the calling code.  When using the allocator, objects will be placed in the already allocated memory (the placing operator new will be used) with the corresponding constructor call, and also cleared by explicit calls to the destructor.  Those.  additional actions that are characteristic of the object pool for initializing an object (when retrieving from a pool) and for bringing it to its initial state (before returning to the pool) are not required. </p><br><p>  Next, I will consider what interesting features of working with memory when using shared_ptr for me personally, I understood and put it on the shelves.  In order not to overload the text with details, the code will be simplified and will relate to the real project only in the most general terms.  First of all, I will focus not on the implementation of the allocator, but on the principle of working with std :: shared_ptr when using a custom allocator. </p><br><p>  The current pointer creation mechanism was using std :: make_shared: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;foo_struct&gt;();</code> </pre> <br><p>  As you know, this method of creating a pointer eliminates some of the potential problems associated with memory leaks that occur if you create a pointer for workers and peasants (although in some cases this option is also justified. For example, if you want to transfer a deleter): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;foo_struct&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> foo_struct);</code> </pre> <br><p>  The key idea in working with std :: shared_ptr memory in order to create a control block.  And we know that this is a special structure that makes the pointer smart.  And for her, you need to allocate memory accordingly. </p><br><p>  The ability to completely control the memory usage when working with std :: shared_ptr is provided to us via std :: allocate_shared.  When calling std :: allocate_shared, you can pass your own allocator: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::allocate_shared&lt;foo_struct&gt;(allocator);</code> </pre> <br><p>  If you override the new and delete operators, you can see how the necessary amount of memory is allocated for the structure from the example: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo_struct</span></span></span><span class="hljs-class"> {</span></span> foo_struct() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"foo_struct()"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ~foo_struct() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"~foo_struct()"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> value2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> value3 = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> value4 = <span class="hljs-number"><span class="hljs-number">4</span></span>; };</code> </pre> <br><p>  Take for example the simplest allocator: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">custom_allocator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type; custom_allocator() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">custom_allocator</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">custom_allocator</span></span></span><span class="hljs-class">&lt;U&gt;&amp;) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">noexcept</span></span></span><span class="hljs-class"> {</span></span>} <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;( ::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(n*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deallocate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T* p, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ ::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p)</span></span></span></span>; } };</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Look</b> <div class="spoiler_text"><pre> <code class="hljs cpp">---- Construct shared ---- <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: size = <span class="hljs-number"><span class="hljs-number">32</span></span> p = <span class="hljs-number"><span class="hljs-number">0x1742030</span></span> foo_struct() <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: size = <span class="hljs-number"><span class="hljs-number">24</span></span> p = <span class="hljs-number"><span class="hljs-number">0x1742060</span></span> ~foo_struct() <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>: p = <span class="hljs-number"><span class="hljs-number">0x1742030</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>: p = <span class="hljs-number"><span class="hljs-number">0x1742060</span></span> ---- Construct shared ----</code> </pre><br><pre> <code class="hljs cpp">---- Make shared ---- <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: size = <span class="hljs-number"><span class="hljs-number">48</span></span> p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> foo_struct() ~foo_struct() <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>: p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> ---- Make shared ----</code> </pre> <br><pre> <code class="hljs cpp">---- Allocate shared ---- <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: size = <span class="hljs-number"><span class="hljs-number">48</span></span> p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> foo_struct() ~foo_struct() <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>: p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> ---- Allocate shared ----</code> </pre> </div></div><br><p>  An important feature of using both std :: make_shared and a custom allocator when working with shared_ptr is, at first glance, an insignificant thing, the ability to allocate memory for both the object itself and for the control block in one call to the allocator.  This is often written in books, but it is poorly stored in memory until you come across this in practice. </p><br><p>  If you lose sight of this aspect, then the behavior of the system when creating a pointer seems rather strange.  We plan to use the allocator to allocate memory for a specific object to which the pointer should point, but in reality a request for memory allocation requires more space than the object should occupy.  And the type of the used allocator does not match our source. </p><br><div class="spoiler">  <b class="spoiler_title">Adding a bit of debugging output to the work of the allocator can be sure of this.</b> <div class="spoiler_text"><pre> <code class="hljs cpp">---- Allocate shared ---- Allocating: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: size = <span class="hljs-number"><span class="hljs-number">48</span></span> p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> foo_struct() ~foo_struct() Deallocating: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>: p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> ---- Allocate shared ----</code> </pre> </div></div><br><p>  Memory is not allocated to an object of class foo_struct.  More precisely, not only for foo_struct. </p><br><p>  Everything falls into place when we recall the std :: shared_ptr control block.  Now, if you add some more debugging output to the copy allocator of the allocator, you can see the type of object being created. </p><br><div class="spoiler">  <b class="spoiler_title">See</b> <div class="spoiler_text"><pre> <code class="hljs cpp">---- Allocate shared ---- <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> control_block_type: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> foo_struct: <span class="hljs-number"><span class="hljs-number">32</span></span> custom_allocator&lt;T&gt;::custom_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> custom_allocator&lt;U&gt;&amp;): T: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; U: foo_struct Allocating: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>: size = <span class="hljs-number"><span class="hljs-number">48</span></span> p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> foo_struct() ~foo_struct() custom_allocator&lt;T&gt;::custom_allocator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> custom_allocator&lt;U&gt;&amp;): T: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; U: foo_struct Deallocating: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>: p = <span class="hljs-number"><span class="hljs-number">0x1742080</span></span> ---- Allocate shared ----</code> </pre> </div></div><br><p>  In this case, the <strong>allocator rebind works</strong> .  Those.  getting one type of allocator from another type of allocator.  This "trick" is used not only in std :: shared_ptr, but also in other classes of the standard library such as std :: list or std :: map - where the actual stored object is different from the user.  At the same time, the necessary variant is created from the initial allocator to allocate the required amount of memory. </p><br><p>  So, when using a custom allocator, memory is allocated both for the control unit and for the object itself.  And all this for one call.  This should be considered when creating an allocator.  Especially if the memory used is pre-allocated in blocks of fixed length.  The problem here is to correctly determine the size of the memory block that will be really needed when running the allocator. </p><br><div class="spoiler">  <b class="spoiler_title">Determining the size of the memory block</b> <div class="spoiler_text"><p>  I haven‚Äôt yet found anything better than to use either a deliberately great value or a completely non-portable method: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> control_block_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::_Sp_counted_ptr_inplace&lt;foo_struct, custom_allocator&lt;foo_struct&gt;, (__gnu_cxx::_Lock_policy)<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> block_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(control_block_type);</code> </pre> <br><p>  By the way, depending on the version of the compiler, the size of the control block is different. </p><br><p>  I would be grateful for the hint how to solve this puzzle in a more elegant way. </p></div></div><br><p>  As a conclusion, I would like to repeat that an important result of using an alternative allocator was the ability to perform optimization without major modification of the existing code and interface of working with objects.  And of course, do not forget to periodically refresh the memory of various subtle aspects of the work of your programming language! </p><br><p>  The source code of the <a href="https://github.com/pirog-spb/allocator_example">github</a> example. </p><br><p>  Thanks for attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/304308/">https://habr.com/ru/post/304308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304296/index.html">Visualization with Google Chart Tools API</a></li>
<li><a href="../304298/index.html">WRIO Internet OS. Architecture: Linked Data and JSON-LD</a></li>
<li><a href="../304302/index.html">Cisco FirePOWER and ISE Integration</a></li>
<li><a href="../304304/index.html">The fight for code style or Bracket Wars</a></li>
<li><a href="../304306/index.html">NetApp ONTAP 9</a></li>
<li><a href="../304312/index.html">LoRa technology</a></li>
<li><a href="../304316/index.html">How to quickly create product descriptions for your store</a></li>
<li><a href="../304320/index.html">PostgreSQL based application performance: explicit and hidden latency</a></li>
<li><a href="../304322/index.html">How to make friends unit testing with a database</a></li>
<li><a href="../304324/index.html">Second rows of associations, or how to make the robot read "between the lines"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>