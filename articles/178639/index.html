<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Avatar rootkit: detailed analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In February 2013, information appeared about the new Avatar rootkit, which, judging from everything, has its origin in one of the underground forums. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Avatar rootkit: detailed analysis</h1><div class="post__text post__text-html js-mediator-article">  In February 2013, information appeared about the new <b>Avatar</b> rootkit, which, judging from everything, has its origin in one of the underground forums.  In particular, a description of its capabilities <a href="http://pastebin.com/ZJ9Gdhgm">was published</a> on the pastebin service.  Information about the new rootkit was hotly discussed in the security community, since the described capabilities of this rootkit were really impressive.  Among them, for example, the possibility of loading the driver without the participation of the hard disk, infection OS boot-drivers, new botnet protection schemes and others.  It also claimed to bypass several security / AV products and well-known anti-rootkits. <br><br><a name="habracut"></a>  When we found the droppers of this rootkit, we immediately began to analyze it.  I must say that it was added to our database as <a href="http://www.virusradar.com/en/Win32_Rootkit.Avatar/description">Win32 / Rootkit.Avatar</a> .  Colleagues <a href="https://twitter.com/cherepanov74">Anton Cherepanov</a> and <a href="https://twitter.com/matrosov">Alexander Matrosov</a> made a detailed analysis of this rootkit, its payload and basic capabilities. <br><br><img src="https://habrastorage.org/storage2/67c/bcf/5a6/67cbcf5a6df4a5e12d8795621a31ed45.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In March, our anti-virus laboratory discovered two droppers that interacted with different C &amp; C servers and had different compilation dates. <br><br><img src="https://habrastorage.org/storage2/f1e/be1/453/f1ebe1453255fa54636e156e088d6050.png"><br><br><img src="https://habrastorage.org/storage2/66d/c0a/0e1/66dc0a0e1e1e690fe41b1c50cb655295.png"><br><br>  As mentioned in the ad, Win32 / Rootkit.Avatar contains a driver infector, but besides this, it uses this technique twice: firstly in the dropper to bypass detection from the HIPS side and secondly in the driver for survival after a reboot.  In the first case, it takes advantage of loading the rootkit driver directly from kernel mode using the standard OS driver, and in the second case, the rootkit ensures its launch after a reboot.  Of course, this tactic has drawbacks from the point of view of violating the integrity of the file and monitoring integrity of the digital signature verification for drivers, so the rootkit can work only in x86 systems. <br><br>  <b>Droppers</b> <br><br>  Avatar uses a dropper approach consisting of several levels.  The first level dropper performs decompression (LZMA) for the second level dropper and driver.  In fact, the second level dropper and the driver itself are unique files generated each time they are unpacked, because the initial dropper generates random names for the mutexes and events that are used in their code and performs these modifications directly in the body of each of the modules.  The initial dropper uses an interesting trick as anti-debugging, it is based on a time comparison from the KUSER_SHARED_DATA.InterruptTime structure (KUSER_SHARED_DATA is located on a page that is accessible in both user mode and kernel mode).  The malicious code performs a modification of the <i>RtlDispatchException</i> function <i>call</i> inside another <i>KiUserExceptionDispatcher</i> function.  In the next step, an exception is generated and control passes to the desired exception handler. <br><br><img src="https://habrastorage.org/storage2/3a6/47c/745/3a647c7458480587374d425e55bddc2e.png"><br><br>  In this case, the current time for the measurement is taken from KUSER_SHARED_DATA.InterruptTime and then compared at subsequent stages of execution.  This mechanism allows to detect emulation and debugging of the dropper code. <br><br>  The second level dropper checks the environment for virtual machines, while using fairly well-known checks.  Before executing the code responsible for checking the VM, the dropper decrypts it using the explorer key. <br><br><img src="https://habrastorage.org/storage2/da9/1a0/5f3/da91a05f3c013ef5bb76bf328e8eb1b1.png"><br><br>  In the next step, the dropper checks the OS version and current privileges.  It uses two methods of elevating privileges: <br><br><ul><li>  Exploiting <a href="http://technet.microsoft.com/en-us/security/bulletin/ms11-080">MS11-080</a> vulnerability. </li><li>  <a href="http://www.pretentiousname.com/misc/win7_uac_whitelist2.html">COM Elevation</a> (UAC whitelist). </li></ul><br>  The process of system infection with a dropper is presented in the diagram below. <br><br><img src="https://habrastorage.org/storage2/6e8/938/b17/6e8938b1728ea4fc2092807b9d03668a.png"><br><br>  The exploit for MS11-080 exploits a code similar to the exploit code from the <a href="http:">Metasploit Framework</a> , but with some minor changes.  After checking the version of the afd.sys driver, the dropper uses the following code for operation. <br><br><img src="https://habrastorage.org/storage2/e8f/645/9fc/e8f6459fc2b289fa7899046b26780b78.png"><br><br>  The following screenshot shows the code that, using IOCTL 0x000120BB, calls the <i>afd! AFDJoinLeaf function</i> to rewrite the pointer in the <i>HalDispatchTable</i> to the desired rootkit function. <br><br><img src="https://habrastorage.org/storage2/b03/d86/312/b03d86312121d1db653f2db3a8fe2676.png"><br><br>  After successful operation and transfer of control to the shell code, it initiates the download of the rootkit driver. <br><br><img src="https://habrastorage.org/storage2/4c6/23f/257/4c623f257346375582ef723fc568f06e.png"><br><br>  In fact, the rootkit driver is not stored on the disk as a separate file, but is loaded from the memory buffer.  Below is the call graph for the function that loads the driver. <br><br><img src="https://habrastorage.org/storage2/cbb/b25/8a0/cbbb258a056839c639515aa0c8562265.png"><br><br>  After successful privilege escalation, the malicious code searches for a suitable driver for infection in the% WINDIR% \ system32 \ drivers directory.  After the infection has been performed, the driver entry point ( <i>GsDriverEntry</i> ) is modified to execute the malicious code (stub).  The modified entry point looks like this: <br><br><img src="https://habrastorage.org/storage2/2e3/3cd/8bb/2e33cd8bb6ec0fa8ffd3e38ba2b4bdce.png"><br><br>  One of the main tasks of this stub is to connect to the process of executing the second level dropper and read the body of the rootkit driver into memory.  The stub code is shown in the figure below. <br><br><img src="https://habrastorage.org/storage2/70e/8ab/48f/70e8ab48f6453617560a3cb319cf1d1b.png"><br><br>  After a successful infection, the modified driver copies itself to the% TEMP% directory and tries to load itself using standard OS mechanisms (via the service control manager or directly via <i>ZwLoadDriver</i> ). <br><br><img src="https://habrastorage.org/storage2/d97/ad9/c3b/d97ad9c3b1e1ab9ecb87f3baf67ba268.png"><br><br>  Thus, the Avatar rootkit driver file is not really stored on the hard disk, but will be loaded with the code that is called by using MS11-080.  This method of downloading a rootkit, using the infection of the system driver, is an effective method of circumventing HIPS and allows you to load another kernel-mode module from a trusted system driver. <br><br>  <b>Driver</b> <br><br>  After the driver is successfully loaded into memory, the malicious code performs infection of the system driver in order to ensure its survival after a reboot.  To select the driver you use a special algorithm.  At the same time, Avatar randomly selects a driver and checks its name against a blacklist specific to different versions of the OS. <br><br><img src="https://habrastorage.org/storage2/aa0/0be/f50/aa00bef500edf1a3d449c8830ea9689e.png"><br><br>  The flow of code execution of an infected driver occurs in the following scenario: <br><br>  1. A stub is executed at the entry point. <br><br><img src="https://habrastorage.org/storage2/0d2/5a1/f99/0d25a1f994d0030f7a32a4a0723ad538.png"><br><br>  2. Then the Pnp Notify callback function is installed for the class GUID_DEVINTERFACE_DISK, in which the driver's body will be loaded from the hidden rootkit file system.  A similar technique was observed in <a href="http//go.eset.com/us/resources/white-papers/The_Evolution_of_TDL.pdf">TDL3</a> , <a href="http//go.eset.com/us/resources/white-papers/The_Evolution_of_TDL.pdf">TDL4</a> and Olmasco (MaxSS / SST). <br><br><img src="https://habrastorage.org/storage2/5ee/991/8df/5ee9918df52fc376383725f255001239.png"><br><br>  3. The original bytes of the entry point are restored. <br><br><img src="https://habrastorage.org/storage2/179/600/53c/17960053c1d86beac56d2c25584258d7.png"><br><br>  A rootkit driver can infect several system drivers without changing the original size of the original file. <br><br>  Avatar uses an interesting technique for discovering the virtual machine environment.  It calls the <i>nt! MmMapIoSpace function</i> to read the BIOS data at 0xF0000 and checks for the presence of the following lines: <br><br><ul><li>  Parallels software </li><li>  Virtual machine </li><li>  Virtualbox </li><li>  QEMU BIOS </li><li>  VMware </li><li>  Bochs </li></ul><br>  Also in the code there are additional checks for KVM and Hyper-V using the already known tricks of the CPUID instruction. <br><br>  Hidden FS is used to store user mode payloads and auxiliary files.  All files are encrypted using a symmetric algorithm.  Below is a call graph for a function that works with hidden FS. <br><br><img src="https://habrastorage.org/storage2/f6f/174/aa3/f6f174aa32512bc9d74f2f6c20a4ed9b.png"><br><br>  There are special attributes for files stored on hidden FS. <br><br><img src="https://habrastorage.org/storage2/c40/a57/6ed/c40a576ed87e8235ef192f14aba4d932.png"><br><br>  Malicious code allows booting from the network and further execution of additional payload in the form of user-mode and kernel-mode modules.  This payload is also stored in hidden FS.  Win32 / Rootkit.Avatar does not store any of its components on an NTFS volume, with the exception of the infected system driver.  This combination of hidden, encrypted FS, along with an infected system driver, makes it more difficult to use conventional forensic examination methods to investigate Avatar infections. <br><br>  To implement the user mode payload, the <i>KeInitializeApc</i> function is <i>used</i> to initialize the APC object, which is then used to execute the required rootkit function. <br><br><img src="https://habrastorage.org/storage2/ed1/151/b68/ed1151b6820516d0e27df08ad432012b.png"><br><br>  <b>Payload</b> <br><br>  The payload of the Avatar rootkit modification under investigation is not original.  Key features: <br><br><ul><li>  Interaction with team C &amp; C. </li><li>  Parsing configuration information. </li><li>  Work with hidden FS. </li><li>  Interaction with the rootkit driver. </li><li>  Installation in the system payload. </li></ul><br>  While researching this modification of the rootkit, we noticed that the payload in the form of avcmd.dll was implemented in the svchost.exe system process.  This module is responsible for working with C &amp; C, whose IP addresses are stored in the configuration file.  This file has the following structure. <br><br><ul><li>  Identifier (name) of the botnet. </li><li>  URL of C &amp; C command servers. </li><li>  1024-bit key for encryption algorithm. </li><li>  Public key for RSA-1024. </li><li>  The names of the processes for the implementation of the payload. </li></ul><br>  Examples of decoded configuration information from two different droppers are given below. <br><br>  For botnet identifier BTN1. <br><br><img src="https://habrastorage.org/storage2/1b1/cb9/573/1b1cb95737d3b847f25132c71ae044de.png"><br><br>  For botnet ID NET1. <br><br><img src="https://habrastorage.org/storage2/f05/4a1/ba6/f054a1ba65ddf0d110a1bc3ddae94375.png"><br><br>  In order to protect interactions with C &amp; C, Avatar uses its own base64 encryption algorithm.  At the same time, all user-mode networking is done using the usual WinInet API functions. <br><br>  Avatar also has an additional way to communicate with C &amp; C, if you have problems using other methods.  He is trying to search for messages in Yahoo groups using special parameters. <br><br><img src="https://habrastorage.org/storage2/2c0/eb9/0ba/2c0eb90bac6376cbcbd811e3782b9e78.png"><br><br><img src="https://habrastorage.org/storage2/6bb/ac9/b2a/6bbac9b2a979ba972d9a9f395a091682.png"><br><br>  Sequences are searched based on the following parameters (in our case, these are 17BTN1 and 17NET1). <br><br><img src="https://habrastorage.org/storage2/e3d/251/948/e3d251948441f615a2854822b681fbc5.png"><br><br>  After these strings are connected, the resulting byte sequence is encrypted using a proprietary algorithm using a 1024-bit key from the configuration file. <br><br>  BTN1 key = <i>6mQ98EXP3v7TKMdk704uOUzGqvikuoHt98n8IPp4K19</i> <i><br></i>  <i>a3qyZ96LoOc54sb3g9eJVyAs7VmPxQjkkM9R960ev275K24PQ550K1</i> <i><br></i>  <i>9fNk8305jRDUTb4cEut4579Zg9i32qU</i> <br><br>  NET1 key = <i>E623J5XKJ9NF4bseM5J2nkwhs1K2766DUOMUDSee3c</i> <i><br></i>  <i>7xu06Q9QayV61U4fm5H89ppuNgLt9M5D2XTCLcd0aS3m9CO1aZg9h9</i> <i><br></i>  <i>o2zb2EIC437IU3X1P3ec07481E0j2Tdr</i> <br><br>  After encryption, base64 is applied to the resulting sequence and then the letters are converted to upper case, with some characters being filtered out.  An example for a botnet with the identifier BTN1 is shown below. <br><br>  <i>SymFilter (UpperCase (Base64 (Encrypt (17BTN1)))) = EZTFDHWP</i> <br><br>  The string EZTFDHWP is used for a subsequent search query for the Yahoo group.  If such a request is successful, the next step is to check the numbers of the found group and read its description data. <br><br><img src="https://habrastorage.org/storage2/020/7e6/c79/0207e6c795c5f2b443683dcba6312802.png"><br><br>  Further, the group description is encrypted using RSA and a 1024-bit private key.  Such data can be decrypted by knowing the public key stored in the configuration file.  We believe that this information can be found in encrypted messages used to return control to the botnet in the absence of active C &amp; C servers. <br><br>  After finding this function, we checked for possible such messages on Yahoo Groups.  One group was found that falls under the given parameters (11BTN1 = EFS9KHRF).  The search query looks like this: <br><br>  hxxp: //groups.yahoo.com/search? query = EFS9KHRF &amp; sort = relevance <br><br><img src="https://habrastorage.org/storage2/439/597/fa1/439597fa12dd007089e3f238e5b2c4d2.png"><br><br>  It is seen that the encrypted message is present in the description of this group. <br><br><img src="https://habrastorage.org/storage2/390/aec/126/390aec1267d672a8f52e2fc52a567bcd.png"><br><br>  We decrypted this message using the RSA-1024 key found in one of the configuration files.  The key to the configuration file with the botnet identifier BTN1 was used. <br><br>  <i>dZ8FsJ4z0 :: http: //www.avatarbut.info <a href="http://www.avatarsbut.info/">www.avatarsbut.info</a></i> <br><br>  This information is similar to one of the C &amp; C URLs that we saw in the BTN1 configuration file itself.  It seems that this group was used by cybercriminals to test this way of interaction, because it includes information from the configuration file itself. <br><br>  Such a botnet maintenance scheme using a message in Yahoo groups provides excellent protection against botnet syncing attempts, since the information about the domains of C &amp; C servers is encrypted using an asymmetric RSA-based encryption algorithm.  In the process of research, reserchers can only extract the public key to decrypt messages, but this key cannot be used to encrypt new messages and create dummy groups. <br><br>  <b>Avatar Runtime Library</b> <br><br>  Win32 / Rootkit.Avatar malware has a special API for developing auxiliary components.  The use of this API is based on the Avatar Runtime Library and a special SDK that describes the development of additional user-mode modules.  These modules can also interact with the rootkit driver.  The Avatar Runtime Library includes the following APIs: <br><br><ul><li>  <i>aTakeProcessToken</i> - assign an access token for one process to another. </li><li>  <i>aExecute</i> - execute the module in the context of a remote process. </li><li>  <i>aLoadDriver</i> - load the driver from the location of the hidden FS. </li><li>  <i>aLoadFileFromAvatarDisk</i> - read a file from a hidden FS. </li><li>  <i>aSaveFileOrAttrToAvatarDisk</i> - write the file to the hidden FS. </li><li>  <i>aSendReport</i> - send information to a remote C &amp; C. </li></ul><br>  The structure of the storage of the payload that will be implemented in the processes looks like this. <br><br><img src="https://habrastorage.org/storage2/7b4/27e/ae6/7b427eae6c2a1cf64d8e566bee79470c.png"><br><br>  After analyzing the Avatar SDK, we concluded that this project was developed by quite skilled developers.  It is obvious that the developers of the malicious code worked on the rootkit code for at least six months in order to test the main functionality and ensure the necessary stability of the kernel mode component. <br><br>  <b>Conclusion</b> <br><br>  The Win32 / Rootkit.Avatar rootkit family contains interesting techniques for circumventing detection from the point of view of AV products.  The Avatar rootkit, along with the Gapz bootkit, can be used to ensure a long-term infection of the system.  Avatar does not store its files on a regular volume, but uses its hidden FS for this, besides it uses the technique of infecting standard drivers, which is a more difficult case to investigate from the point of view of conducting a forensic examination. <br><br>  The threat also has additional ways of maintaining control over the botnet if the command C &amp; C servers are unavailable.  In order to completely disinfect the infected system, first of all it is necessary to deactivate the rootkit driver and its user mode payload and after that try to restore the infected system driver. </div><p>Source: <a href="https://habr.com/ru/post/178639/">https://habr.com/ru/post/178639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178625/index.html">IT Brunch Free Online Conferencing Platform - ".NET brunch" May 18</a></li>
<li><a href="../178629/index.html">Let's make "Roscosmos" a little kinder</a></li>
<li><a href="../178633/index.html">6 buttons</a></li>
<li><a href="../178635/index.html">Valve has released Portal for Linux</a></li>
<li><a href="../178637/index.html">Correcting memory leaks in the Python application</a></li>
<li><a href="../178641/index.html">Princeton's bionic ear, capable of "hearing" radio waves</a></li>
<li><a href="../178645/index.html">At Harvard, created a miniature robot mosquito (+ video)</a></li>
<li><a href="../178647/index.html">Fresh Frozen Raspberry Pi</a></li>
<li><a href="../178649/index.html">Usability: let your mom try</a></li>
<li><a href="../178651/index.html">About Unite Nordic and Motivation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>