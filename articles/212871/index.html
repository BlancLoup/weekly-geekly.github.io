<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Masking the class under the Boost graph. Part 3: Finding the Way</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue: Boost Concepts 
 Part 1: Connection of associated types without interfering with the source class interface 
 Part 2: Completing the impleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Masking the class under the Boost graph. Part 3: Finding the Way</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/b7a/f80/e6ab7af80bd2bdba0d725529e3c5cc65.png" align="left"><br>  <a href="http://habrahabr.ru/post/210838/">Prologue: Boost Concepts</a> <br>  <a href="http://habrahabr.ru/post/211558/">Part 1: Connection of associated types without interfering with the source class interface</a> <br>  <a href="http://habrahabr.ru/post/212089/">Part 2: Completing the implementation of concept support</a> <br><br>  In the previous articles of the cycle, the process of adapting the class of the cellular playing field to the concepts of graphs boost was described.  Now we will consider the very thing for which everything was started - the search for a path in the cellular field.  The implementation of the boost search allows you to fine-tune the algorithm, in this article there will be only one example of such a parameterization - the ability to set different lengths of the graph edges. <br><a name="habracut"></a><br>  With the description of the parameter and begin.  You want to create an edge scale map that satisfies the <a href="http://habrahabr.ru/post/210838/">concept of</a> <a href="http://www.boost.org/doc/libs/1_55_0/libs/property_map/doc/ReadablePropertyMap.html">ReadablePropertyMapConcept</a> .  It is implemented quite simply - you need to define several types and the operator [], which, based on the key-edge, returns its length.  For simplicity, the calculations will be omitted - let's take the size of all edges equal to one. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EdgeWeightMap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> value_type reference; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Edge key_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::readable_property_map_tag category; reference <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](key_type e) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } };</code> </pre> <br>  With the help of a typedef, the key type (Edge), the return value type (double) and the label by which boost can understand that values ‚Äã‚Äãcan be obtained from the map (boost :: readable_property_map_tag) are determined.  <b>Edge</b> and other custom types are defined <a href="http://habrahabr.ru/post/211558/">in the first part of the article</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Next, you need to implement the function required by the concept.  But first we introduce short type aliases (for yourself) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::property_map&lt;GameField, boost::<span class="hljs-keyword"><span class="hljs-keyword">edge_weight_t</span></span>&gt;::const_type EdgeWeightMapConst; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::property_traits&lt;EdgeWeightMapConst&gt;::reference EdgeWeightMapValueType; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::property_traits&lt;EdgeWeightMapConst&gt;::key_type EdgeWeightMapKey;</code> </pre><br>  The function must return a value from the map by key. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EdgeWeightMapValueType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EdgeWeightMapConst pMap, EdgeWeightMapKey pKey)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pMap[pKey]; }</code> </pre><br>  Now you can set the edge scale map.  Note that the declaration is in the namespace boost. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property_map</span></span></span><span class="hljs-class">&lt; GameField, edge_weight_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> EdgeWeightMap type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> EdgeWeightMap const_type; }; }</code> </pre><br>  We check the concept <br><br><pre> <code class="cpp hljs">boost::function_requires&lt;boost::ReadablePropertyMapConcept&lt;EdgeWeightMap, Edge&gt; &gt;();</code> </pre><br>  You can also set the properties of the vertices - we will not do this, but we will have to create a stub so that boost can generate a map for the default vertices.  For this, it is enough to specify the type of vertex properties, let it be the type of the vertex index <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vertex_property_type</span></span></span><span class="hljs-class">&lt;GameField&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::vertex_descriptor type; }; }</code> </pre><br>  This definition must also be in the namespace boost. <br><br>  We implement the support of our graph to another concept - <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/PropertyGraph.html">ReadablePropertyGraphConcept</a> , i.e.  "Graph with properties".  To do this, you need to set two functions.  The first one creates a map of graph properties. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EdgeWeightMapConst </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boost::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">edge_weight_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField&amp; graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EdgeWeightMapConst(); }</code> </pre><br>  Please note that in this article the weight of the ribs is not calculated (equal to 1), therefore there is no need to save a pointer to the graph in it, respectively, and the <b>graph</b> parameter is not used.  Also set the function to determine the weight of the edge <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">EdgeWeightMapValueType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boost::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">edge_weight_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField&amp; g, EdgeWeightMapKey e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(tag, g)[e]; }</code> </pre><br>  On this with the next concept is completed, you can check <br><br><pre> <code class="cpp hljs">boost::function_requires&lt;boost::ReadablePropertyGraphConcept&lt;GameField, Edge, boost::<span class="hljs-keyword"><span class="hljs-keyword">edge_weight_t</span></span>&gt; &gt;();</code> </pre><br>  The algorithm for finding the path A * belongs to the class of <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA">informed</a> , and, therefore, it can (and should) be helped.  To do this, we define heuristics, which will allow us to find more effective search directions.  Heuristics is a <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">functor</a> that determines how far a given vertex is far from the target.  <a href="http://ru.wikipedia.org/wiki/%25D0%2595%25D0%25B2%25D0%25BA%25D0%25BB%25D0%25B8%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0_%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0">Euclidean metric used</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameFieldHeuristic</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::astar_heuristic&lt;GameField, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GameFieldHeuristic(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; gameField, Vertex goal) : mGameField(&amp;gameField) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; goalPosition = getCoordinates(goal, gameField); mGoalX = goalPosition.first; mGoalY = goalPosition.second; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vertex v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; position = getCoordinates(v, *mGameField); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = mGoalX - position.first; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = mGoalY - position.second; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result =dx * dx + dy * dy; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mGoalX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mGoalY; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField* mGameField; };</code> </pre><br>  The class is quite simple - the playing field and the index of the target vertex are passed to the constructor.  The index calculates the coordinates of the vertex on the cell field (more about this in the <a href="http://habrahabr.ru/post/211558/">first part of the article</a> ).  For the algorithm, it is important to increase or decrease the distance - the exact value is not required, therefore, the square of the distance is calculated (the square root in the formula is omitted). <br><br>  And finally, create a class that can signal the found solution.  We will <b>signal</b> through the exclusion of the <b>FoundGoal</b> exception. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FoundGoal</span></span></span><span class="hljs-class"> {</span></span>};</code> </pre><br>  Create a class visitor, whose <b>examine_vertex</b> method is called for each vertex the algorithm has reached.  As soon as we reach the top of the target, we will raise an exception <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstarGoalVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::default_astar_visitor { AstarGoalVisitor(Vertex goal) : mGoal(goal) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">examine_vertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vertex u, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (u == mGoal) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> FoundGoal(); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Vertex mGoal; };</code> </pre><br>  Finally, we write the function of finding a path from one point of the graph to another.  As parameters, it takes the coordinates of the source and target vertices, as well as a link to the graph <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;NextStep&gt; StepsList; <span class="hljs-function"><span class="hljs-function">StepsList </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sourceX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sourceY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameFieldMap&amp; graph)</span></span></span><span class="hljs-function"> </span></span>{ GraphVertex source = getVertex(sourceX, sourceY, graph); GraphVertex destination = getVertex(targetX, targetY, graph); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;GraphVertex&gt; predecessor(num_vertices(graph)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;edge_weight_map_value_type&gt; dist(num_vertices(graph)); StepsList result; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { astar_search(graph, source, GameFieldHeuristic(graph, destination), boost::visitor(AstarGoalVisitor(destination)). predecessor_map(&amp;predecessor[<span class="hljs-number"><span class="hljs-number">0</span></span>]). distance_map(&amp;dist[<span class="hljs-number"><span class="hljs-number">0</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FoundGoal f) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = destination; i != source; i = predecessor[i]) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; coordinates = getCoordinates(i, graph); result.push_front(NextStep(coordinates.first, coordinates.second)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  The function translates the vertex coordinates into integer indices.  Then a <b>predecessor</b> vector is created, from which the result and distance vector dist will be extracted. <br><br>  I will stop not a few moments.  First, the search function call <b>astar_search</b> .  At the beginning, nothing portends - the usual parameters go: the graph, the starting point, heuristics, but then the construction starts through a point instead of a comma.  This is not a typo.  For functions with a large number of optional parameters, boost offers its own way of passing named arguments (not to get confused), the subtleties of the mechanism do not apply to the article, just a few remarks. <br><br><ol><li>  The names of all parameters are defined in the namespace boost, but it must be specified only once at the beginning of the chain </li><li>  Parameters are passed as follows: the name of the parameter is written, then the value is in parentheses, the parameters are separated by a period </li><li>  The order of the parameters can be any </li></ol><br>  If we get into the catch block, the path is found.  It is <b>written</b> to the vector <b>predecessor</b> , in the form of a list of previous vertices.  That is, the position of the predecessor [vertex] is the index of the vertex, from which we get to the vertex.  In this way, turning one's predecessors one by one, one can get a more familiar way - a sequence of vertices that need to go from point A to point B. The result is written into the list of results. </div><p>Source: <a href="https://habr.com/ru/post/212871/">https://habr.com/ru/post/212871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212861/index.html">Scientists have been able to explain where the Martian ‚Äúwandering stone‚Äù came from</a></li>
<li><a href="../212863/index.html">How do we use the data processing infrastructure at Sports.ru and Tribuna.com?</a></li>
<li><a href="../212865/index.html">Xperia Z1 Compact Review</a></li>
<li><a href="../212867/index.html">Report on the course "Data Visualization"</a></li>
<li><a href="../212869/index.html">Published rating agencies of contextual advertising from CMS Magazine</a></li>
<li><a href="../212873/index.html">Mobile application development. Why is this business?</a></li>
<li><a href="../212875/index.html">How we test advertising technologies of Yandex, and how to learn it</a></li>
<li><a href="../212877/index.html">We use WEBKit instead of IE in Visual Basic.net applications.</a></li>
<li><a href="../212879/index.html">x3650 M4 - do you need HD?</a></li>
<li><a href="../212881/index.html">Documentation Development with DocBook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>