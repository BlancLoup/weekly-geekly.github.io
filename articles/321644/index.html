<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using expressions to filter data from a database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is based on a response to StackOverflow . I will begin with a description of the problem that I encountered. There are several entities in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using expressions to filter data from a database</h1><div class="post__text post__text-html js-mediator-article">  The article is based on a <a href="http://stackoverflow.com/questions/29448432/pass-expression-parameter-as-argument-to-another-expression">response to StackOverflow</a> .  I will begin with a description of the problem that I encountered.  There are several entities in the database that need to be displayed as tables on the UI.  Entity Framework is used to access the database.  For these tables there are filters, by the fields of these entities.  You need to write code to filter entities by parameters. <a name="habracut"></a><br><br>  For example, there are 2 User and Product entities. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Product</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Suppose we need to filter users by name, and products by name.  We write methods to filter each entity. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IQueryable&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterUsersByName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;User&gt; users, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users.Where(user =&gt; user.Name.Contains(text)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IQueryable&lt;Product&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterProductsByName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;Product&gt; products, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> products.Where(product =&gt; product.Name.Contains(text)); }</code> </pre> <br>  Immediately, we note that these two methods are almost identical and differ only in the property of the entity by which the data is filtered.  If we have dozens of entities, each of which has dozens of fields for which filtering is needed, this leads to some difficulties: difficulty in maintaining the code, mindless copying and, as a result, slow development and high probability of errors.  Paraphrasing Fowler, <a href="https://martinfowler.com/bliki/CodeSmell.html">begins to smack</a> .  I would like to write something more universal instead of duplicating the code.  Narimer: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IQueryable&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterUsersByName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;User&gt; users, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterContainsText(users, user =&gt; user.Name, text); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IQueryable&lt;Product&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterProductsByName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;Product&gt; products, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterContainsText(products, propduct =&gt; propduct.Name, text); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryable&lt;TEntity&gt; FilterContainsText&lt;TEntity&gt;(IQueryable&lt;TEntity&gt; entities, Func&lt;TEntity, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; getProperty, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entities.Where(entity =&gt; getProperty(entity).Contains(text)); }</code> </pre> <br>  Sorry if we try to filter <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Context()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filteredProducts = FilterProductsByName(context.Products, <span class="hljs-string"><span class="hljs-string">"name"</span></span>).ToArray(); } }</code> </pre> <br>  then we get the error ‚ÄúTest method ExpressionTests.ExpressionTest.TestFilter threw exception: <br>  <b>System.NotSupportedException</b> : The LINQ to Entities.  Because <br><br><img src="https://habrastorage.org/files/e8e/fdb/870/e8efdb8701aa40c499c94ab74251937f.jpg"><br><br><h3>  Expressions </h3><br>  Let's try to figure out what went wrong. <br><br>  The Where method takes a parameter of type Expression &lt;Func &lt;TEntity, bool &gt;&gt;.  Those.  Linq does not work with delegates, but with expression trees, which builds SQL queries. <br><br>  Expression describes a <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">syntax tree</a> node.  To better understand how they work, consider an expression that checks that the name is equal to the string <br><br><pre> <code class="cs hljs">Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; expected = product =&gt; product.Name == <span class="hljs-string"><span class="hljs-string">"target"</span></span>;</code> </pre> <br>  When debugging, you can see the structure of this expression (key properties are marked in red) <br><br><img src="https://habrastorage.org/files/5d0/e4f/63a/5d0e4f63af66426c82ea3a298d1b7cfc.png"><br><br>  It turns out about such a tree <br><br><img src="https://habrastorage.org/files/24a/bf1/498/24abf149878a44db923ee2bc7062bd2f.png"><br><br>  The fact is that when we pass a delegate as a parameter, another tree is formed in which, instead of accessing the property of the entity, the Invoke method of the parameter (delegate) is called.  When Linq tries to build a SQL query on this tree, he does not know how to interpret the Invoke method and throws a NotSupportedException exception. <br><br>  Thus, our task is to replace the reference to the property of the entity (the part of the tree that is highlighted in red) with the expression passed through the parameter.  Let's try: <br><br><pre> <code class="cs hljs">Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; propertyGetter = product =&gt; product.Name; Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; filter = product =&gt; propertyGetter(product) == <span class="hljs-string"><span class="hljs-string">"target"</span></span></code> </pre> <br>  Now we see the error "Method name expected" already at the compilation stage. <br><br><img src="https://habrastorage.org/files/b3a/373/f04/b3a373f04abc4c0785eb4d58f3c3ed04.jpg"><br><br>  The problem is that the expression is a class that represents the nodes of the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">syntactic tree</a> , not the delegate itself and cannot be called directly.  Now the main task is to find a way to form an expression, passing it another parameter as a parameter. <br><br><h3>  The visitor </h3><br>  After a short googling, I found a solution to a similar problem on <a href="http://stackoverflow.com/a/29471092/722552">StackOverflow</a> . <br><br>  To work with expressions, there is a special class <a href="https://msdn.microsoft.com/en-us/library/system.linq.expressions.expressionvisitor(v%3Dvs.110).aspx">ExpressionVisitor</a> that uses the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> pattern.  Its essence is that it bypasses all the nodes of the expression tree in the parsing order of the syntax tree and allows them to be modified or to return another node instead.  If neither the node itself nor its child nodes have changed, then the original expression is returned. <br><br>  Those.  inheriting from the ExpressionVisitor class, we can replace any tree node with an expression that we pass through the parameter.  Thus, we need to place in the tree some node-label, which we replace with the parameter during the crawl.  To do this, we write an extension method that will simulate an expression call and will be a label. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExpressionExtension</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TFunc Call&lt;TFunc&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Expression&lt;TFunc&gt; expression) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"This method should never be called. It is a marker for replacing."</span></span>); } }</code> </pre><br>  Now we can insert one expression into another <br><br><pre> <code class="cs hljs">Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; propertyGetter = product =&gt; product.Name; Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; filter = product =&gt; propertyGetter.Call()(product) == <span class="hljs-string"><span class="hljs-string">"target"</span></span>;</code> </pre> <br>  It remains to write a visitor, which in the expression tree will replace the call to the Call method with its parameter: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SubstituteExpressionCallVisitor</span></span> : <span class="hljs-title"><span class="hljs-title">ExpressionVisitor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MethodInfo _markerDesctiprion; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubstituteExpressionCallVisitor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _markerDesctiprion = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ExpressionExtension).GetMethod(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ExpressionExtension.Call)).GetGenericMethodDefinition(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitMethodCall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsMarker(node)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Visit(ExtractExpression(node)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.VisitMethodCall(node); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LambdaExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExtractExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = node.Arguments[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (LambdaExpression)Expression.Lambda(target).Compile().DynamicInvoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMarker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.Method.IsGenericMethod &amp;&amp; node.Method.GetGenericMethodDefinition() == _markerDesctiprion; } }</code> </pre> <br>  Now we can replace our marker. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expression&lt;TFunc&gt; SubstituteMarker&lt;TFunc&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Expression&lt;TFunc&gt; expression) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visitor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubstituteExpressionCallVisitor(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Expression&lt;TFunc&gt;)visitor.Visit(expression); } Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; propertyGetter = product =&gt; product.Name; Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; filter = product =&gt; propertyGetter.Call()(product).Contains(<span class="hljs-string"><span class="hljs-string">"123"</span></span>); Expression&lt;Func&lt;Product, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; finalFilter = filter.SubstituteMarker();</code> </pre> <br>  In the debug, we see that the expression did not turn out exactly as we expected.  The filter still contains an Invoke method. <br><br><img src="https://habrastorage.org/files/c5d/91c/894/c5d91c8940134b5b98741bba258b9b6d.png"><br><br>  The fact is that the parameterGetter expression and the finalFilter expression use two different arguments.  Therefore, we need to replace the argument in parameterGetter with the argument from finalFilter.  To do this, we write another visitor. <br><br><img src="https://habrastorage.org/files/984/4be/4d1/9844be4d18a24d20973e05cb7a1ec54d.jpg"><br><br>  As a result, we get the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SubstituteParameterVisitor</span></span> : <span class="hljs-title"><span class="hljs-title">ExpressionVisitor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LambdaExpression _expressionToVisit; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;ParameterExpression, Expression&gt; _substitutionByParameter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubstituteParameterVisitor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression[] parameterSubstitutions, LambdaExpression expressionToVisit</span></span></span><span class="hljs-function">)</span></span> { _expressionToVisit = expressionToVisit; _substitutionByParameter = expressionToVisit .Parameters .Select((parameter, index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> {Parameter = parameter, Index = index}) .ToDictionary(pair =&gt; pair.Parameter, pair =&gt; parameterSubstitutions[pair.Index]); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Replace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Visit(_expressionToVisit.Body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitParameter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ParameterExpression node</span></span></span><span class="hljs-function">)</span></span> { Expression substitution; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_substitutionByParameter.TryGetValue(node, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> substitution)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Visit(substitution); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.VisitParameter(node); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SubstituteExpressionCallVisitor</span></span> : <span class="hljs-title"><span class="hljs-title">ExpressionVisitor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> MethodInfo _markerDesctiprion; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SubstituteExpressionCallVisitor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _markerDesctiprion = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ExpressionExtensions) .GetMethod(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ExpressionExtensions.Call)) .GetGenericMethodDefinition(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitInvocation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">InvocationExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isMarkerCall = node.Expression.NodeType == ExpressionType.Call &amp;&amp; IsMarker((MethodCallExpression) node.Expression); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMarkerCall) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameterReplacer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubstituteParameterVisitor(node.Arguments.ToArray(), Unwrap((MethodCallExpression) node.Expression)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = parameterReplacer.Replace(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Visit(target); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.VisitInvocation(node); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LambdaExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = node.Arguments[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (LambdaExpression)Expression.Lambda(target).Compile().DynamicInvoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsMarker</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodCallExpression node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.Method.IsGenericMethod &amp;&amp; node.Method.GetGenericMethodDefinition() == _markerDesctiprion; } }</code> </pre> <br>  Now everything works as it should, and we can finally write our filtering method <br><br><img src="https://habrastorage.org/files/fb1/34d/407/fb134d407baf4339a87bdc21516ce576.png"><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryable&lt;TEntity&gt; FilterContainsText&lt;TEntity&gt;(IQueryable&lt;TEntity&gt; entities, Expression&lt;Func&lt;TEntity, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; getProperty, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text) { Expression&lt;Func&lt;TEntity, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; filter = entity =&gt; getProperty.Call()(entity).Contains(text); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entities.Where(filter.SubstituteMarker()); }</code> </pre> <br><h3>  Afterword </h3><br>  The expression substitution approach can be used not only for filtering, but also for sorting and in general for any queries to the database. <br><br>  Also, this method allows you to store expressions with business logic separately from the database requests themselves. <br><br>  Completely reload code on <a href="https://github.com/pssam/CodeFixture">githaba</a> . </div><p>Source: <a href="https://habr.com/ru/post/321644/">https://habr.com/ru/post/321644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321632/index.html">OpenPapyrus: [yet another] ERP-system open source</a></li>
<li><a href="../321634/index.html">PROTEQ - multigigabit exchange protocol for Xilinx FPGA</a></li>
<li><a href="../321636/index.html">Automount afuse</a></li>
<li><a href="../321638/index.html">Continuous Integration UWP Applications in Visual Studio Team Services</a></li>
<li><a href="../321640/index.html">Facebook Audience Network - a new word in the monetization of sites and applications</a></li>
<li><a href="../321646/index.html">Automatic 3CX configuration using the setupconfig.xml answer file</a></li>
<li><a href="../321648/index.html">J-bird</a></li>
<li><a href="../321652/index.html">UNIX-like systems contain a bunch of crutches. The collapse of the "UNIX philosophy"</a></li>
<li><a href="../321654/index.html">C ++ Russia: interview with speakers</a></li>
<li><a href="../321656/index.html">The basics of Juniper Contrail, and how to put it in the lab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>