<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gixy - open source from Yandex, which will make configuring Nginx safe</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nginx is definitely one of the coolest web servers. However, being rather simple, rather expandable and productive, it requires respect for yourself. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gixy - open source from Yandex, which will make configuring Nginx safe</h1><div class="post__text post__text-html js-mediator-article">  Nginx is definitely one of the coolest web servers.  However, being rather simple, rather expandable and productive, it requires respect for yourself.  However, this applies to almost any software on which the security and performance of the service depends.  I admit, we like Nginx.  In Yandex, it is represented by a huge number of installations with various configurations: from simple reverse proxy to full-fledged applications.  Due to this diversity, we have accumulated some experience of its [not] safe configuration, which we want to share. <br><br> <a href="https://habrahabr.ru/company/yandex/blog/327590/"><img src="https://habrastorage.org/files/dfb/469/db1/dfb469db172e4a2481e73438c87e3ae3.png"></a> <br><br>  But first things first.  We have long been tormented by the issue of the secure configuration of Nginx, because it is a full cube of the web application, which means that its configuration requires no less control on our part than the code of the application itself.  Last year it became obvious to us that this process requires serious automation.  Thus began the in-house <a href="https://github.com/yandex/gixy/">Gixy</a> project, the requirements for which we outlined as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - be simple; <br>  - but expandable; <br>  - with the possibility of convenient integration into testing processes; <br>  - it would be nice to be able to rekolvit incluses; <br>  - and work with variables; <br>  - and about regular expressions not to forget. <br><a name="habracut"></a><br>  Frankly, we have hesitated to the last with the choice of language (between Golang and Python).  As a result, Python was chosen with the hope that it is more common, which means it will be a little easier with development. <br><br><h3>  About problems </h3><br>  On this, we‚Äôll finish the introduction and go over to examples of common problems :) To avoid confusion in the future, the current mainline version of Nginx, 1.13.0, was used in all examples. <br><br>  <b>Server-Side-Request-Forgery</b> <br><br>  Server Side Request Forgery is a vulnerability that allows to perform various kinds of requests on behalf of a web application (in our case, on behalf of Nginx).  Occurs when an attacker can control the address of the proxied server, for example, in case of incorrect configuration of the <a href="https://www.nginx.com/resources/wiki/start/topics/examples/xsendfile/">XSendfile</a> . <br><br>  From my own experience I can say that often the vulnerability is associated with several errors: <br><br>  - lack of directive <a href="http_core_module.html">internal</a> .  Its meaning is to indicate that a particular location can only be used for internal requests; <br>  - unsafe internal redirection. <br><br>  If everything is clear with the first case, then with the internal redirection things are not so simple.  I believe many of you have seen / written a similar configuration: <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* ^/internal-proxy/(?&lt;proxy_proto&gt;https?)/(?&lt;proxy_host&gt;.*?)/(?&lt;proxy_path&gt;.*)$</span></span> { internal; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> <span class="hljs-variable"><span class="hljs-variable">$proxy_proto</span></span>://<span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span>/<span class="hljs-variable"><span class="hljs-variable">$proxy_path</span></span> ; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span>; }</code> </pre> <br>  Unfortunately, in this configuration you need to check at least all the rewrite and try_files directives, since according to the documentation: <br><br><blockquote>  Internal requests are: <br>  - queries redirected by the directives error_page, index, random_index and <b>try_files</b> ; <br>  - requests redirected using the ‚ÄúX-Accel-Redirect‚Äù field of the parent server's response header; <br>  - subqueries formed by the ‚Äúinclude virtual‚Äù command of the ngx_http_ssi_module module and the ngx_http_addition_module module directives; <br>  - queries modified by the <b>rewrite</b> directive. </blockquote><br>  It turns out that any careless rewrite will allow you to make a request in the internal location.  This is fairly easy to verify: <br><br>  - configuration: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* ^/internal-proxy/(?&lt;proxy_proto&gt;https?)/(?&lt;proxy_host&gt;.*?)/(?&lt;proxy_path&gt;.*)$</span></span> { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"proto: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$proxy_proto</span></span></span><span class="hljs-string">\nhost: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$proxy_host</span></span></span><span class="hljs-string">\npath: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$proxy_path</span></span></span><span class="hljs-string">"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">rewrite</span></span><span class="hljs-regexp"><span class="hljs-regexp"> ^/(?!_api)(.*)/\.files/(.*)$</span></span> /<span class="hljs-variable"><span class="hljs-variable">$1</span></span>/.download?file=<span class="hljs-variable"><span class="hljs-variable">$2</span></span> <span class="hljs-literal"><span class="hljs-literal">last</span></span>;</code> </pre> <br>  - exploitation: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">GET</span></span> /internal-proxy/http/evil.com/.files/some HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> Host: localhost HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Content-Length: <span class="hljs-number"><span class="hljs-number">42</span></span> Content-Type: application/octet-stream Date: Fri, <span class="hljs-number"><span class="hljs-number">28</span></span> Apr <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>:<span class="hljs-number"><span class="hljs-number">55</span></span>:<span class="hljs-number"><span class="hljs-number">51</span></span> GMT Server: nginx/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> proto: http host: evil.com path: .download</code> </pre><br>  In this situation, we usually recommend several practices: <br><br>  - use only internal location for proxying; <br>  - if possible, prohibit the transfer of user data; <br>  - secure the address of the proxied server: <br><br>  ‚Ä¢ if the number of proxied hosts is limited (for example, you have S3), then it is better to hard-code them and select using map or in any other way convenient for you; <br>  ‚Ä¢ if for some reason it is not possible to list all possible hosts for proxying, it is worth signing. <br><br>  <b>Bad regular expressions for validating a referrer or origin</b> <br><br><blockquote>  You have a problem.  You decide to use regular expressions to solve it. <br>  - Now you have two problems. </blockquote><br>  Often, validation of the ‚ÄúReferer‚Äù or ‚ÄúOrigin‚Äù request header is done using a regular expression.  Often this is necessary for conditional exposure of the X-Frame-Options header (ClickJacking protection) or Cross-Origin Resource Sharing ( <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a> ) implementation.  And if with the validation of ‚ÄúReferer‚Äù everything is a bit simpler and, with some conditions, you can refuse the regular expression in favor of the <a href="http_referer_module.html">ngx_http_referer_module</a> module, then with ‚ÄúOrigin‚Äù everything is not so simple. <br><br>  We distinguish two main classes of problems: <br><br>  - errors in the compilation of a regular expression; <br>  - permission of untrusted third-party domains. <br><br>  Problem configuration is as follows: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$http_origin</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* ((^https://www\.yandex\.ru)|(^https://ya\.ru)/))</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> <span class="hljs-string"><span class="hljs-string">'Access-Control-Allow-Origin'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_origin</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> <span class="hljs-string"><span class="hljs-string">'Access-Control-Allow-Credentials'</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span>; }</code> </pre> <br>  In fact, I have simplified the regular expression very much, but even in this example, seeing the problem from the first time is not so easy.  It is easier for people to write regular expressions than to read them. <br><br>  Fortunately, this problem is not typical for the machine, so Gixy is able to independently determine that this regular expression is www.matdex.ru.evil.com as a valid origin and will inform you about it: <br><br><pre> <code class="nginx hljs">$ <span class="hljs-attribute"><span class="hljs-attribute">gixy</span></span> --origins-domains yandex.ru,ya.ru /etc/nginx/nginx.conf ==================== Results =================== Problem: [origins] Validation regex for <span class="hljs-string"><span class="hljs-string">"origin"</span></span> or <span class="hljs-string"><span class="hljs-string">"referrer"</span></span> matches untrusted domain. Description: Improve the regular expression to match only trusted referrers. Additional <span class="hljs-literal"><span class="hljs-literal">info</span></span>: https://github.com/yandex/gixy/blob/master/docs/ru/plugins/origins.md Reason: Regex matches <span class="hljs-string"><span class="hljs-string">"https://www.yandex.ru.evil.com"</span></span> as a valid origin. Pseudo config: include /etc/nginx/sites/default.conf; <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> _; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$http_origin</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* ((^https://www\.yandex\.ru)|(^https://ya\.ru)/))</span></span> { } }</code> </pre> <br>  Or, if you assume ya.ru is not trusted enough, it will report the origins of <a href="https://ya.ru/">ya.ru</a> and <a href="https://www.yandex.ru.evil.com/">www.yandex.ru.evil.com</a> : <br><br><pre> <code class="nginx hljs">$ <span class="hljs-attribute"><span class="hljs-attribute">gixy</span></span> --origins-domains yandex.ru /etc/nginx/nginx.conf ==================== Results =================== Problem: [origins] Validation regex for <span class="hljs-string"><span class="hljs-string">"origin"</span></span> or <span class="hljs-string"><span class="hljs-string">"referrer"</span></span> matches untrusted domain. Description: Improve the regular expression to match only trusted referrers. Additional <span class="hljs-literal"><span class="hljs-literal">info</span></span>: https://github.com/yandex/gixy/blob/master/docs/ru/plugins/origins.md Reason: Regex matches <span class="hljs-string"><span class="hljs-string">"https://www.yandex.ru.evil.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://ya.ru/"</span></span> as a valid origin. Pseudo config: include /etc/nginx/sites/default.conf; <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> _; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$http_origin</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* ((^https://www\.yandex\.ru)|(^https://ya\.ru)/))</span></span> { } }</code> </pre> <br>  <b>HTTP Splitting</b> <br><br>  HTTP Splitting is used to attack an application that is behind Nginx (HTTP Request Splitting) or application clients (HTTP Response Splitting).  Vulnerability occurs when an attacker can embed a newline character \ n in a request or response generated by Nginx. <br><br>  I have no reliable advice (except how to be attentive), but you should always pay attention to several things: <br><br>  - which variables are used in the directives responsible for creating queries (can they contain CRLF), for example: rewrite, return, add_header, proxy_set_header and proxy_pass; <br>  - whether the variables $ uri and $ document_uri are used, and if so, in which directives, since they are guaranteed to contain the url-decoded value; <br>  - pay special attention to variables derived from groups with an exclusive range: (? P [^.] +). <br><br>  Exclusive Range Example: <br><br>  - configuration: <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~ /v1/((?&lt;action&gt;[^.]*)\.json)?$</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Action <span class="hljs-variable"><span class="hljs-variable">$action</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; } }</code> </pre> <br>  - exploitation: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">GET</span></span> /v1/see%20below%<span class="hljs-number"><span class="hljs-number">0d</span></span>%0ax-crlf-header:injected.json HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> Host: localhost HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Content-Length: <span class="hljs-number"><span class="hljs-number">2</span></span> Content-Type: application/octet-stream Date: Fri, <span class="hljs-number"><span class="hljs-number">28</span></span> Apr <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>:<span class="hljs-number"><span class="hljs-number">57</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span> GMT Server: nginx/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> X-Action: see below x-crlf-header: injected OK</code> </pre> <br>  As you can see, we were able to add an x-crlf-header response header: injected.  This happened due to the coincidence of several circumstances: <br><br>  - add_header does not encode / validate the values ‚Äã‚Äãpassed to it, considering that the author is aware of the consequences; <br>  - the value of the path is normalized before processing the location; <br>  - the $ action variable was selected from the regular expression group with the exclusive range: [^.] *; <br>  - thus, the value of the $ action variable became equal to see below \ r \ nx-crlf-header: injected and got into the HTTP response. <br><br>  Fortunately, Gixy successfully copes with this task: <br><br>  - he knows about "dangerous" variables - more precisely, he knows about the allowable set of characters in most embedded variables.  Thus, the difference between $ request_uri and $ uri is obvious to him; <br>  - able to select variables from regular expression groups; <br>  - able to determine whether any character (in our case, \ n) can be matched with a regular expression (or a single group). <br><br>  Another interesting example is rewright with try_files: <br><br>  - configuration: <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span>/ /index.php?q=<span class="hljs-variable"><span class="hljs-variable">$uri</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~ \.php</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1:9000; } }</code> </pre> <br>  - operation (on 127.0.0.1:9000 listens to the debug echo-server): <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">GET</span></span> /request%20HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>%0aInjection: HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> Host: localhost HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> Ok Content-Length: <span class="hljs-number"><span class="hljs-number">244</span></span> Content-Type: text/plain Date: Fri, <span class="hljs-number"><span class="hljs-number">28</span></span> Apr <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>:<span class="hljs-number"><span class="hljs-number">59</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span> GMT Server: nginx/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> GET /index.php?q=/request HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>\n Injection: HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>\r\n X-Real-IP: <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>\r\n X-Forwarded-For: <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>\r\n Host: localhost\r\n Connection: close\r\n User-Agent: HTTPie/<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>\r\n Accept-Encoding: gzip, deflate\r\n Accept: */*\r\n \r\n</code> </pre> <br>  What to do? <br><br>  - Try to use more secure variables, such as $ request_uri instead of $ uri. <br>  - Disallow line breaks in the exclusion range, for example, / some / (? [^ / \ S] +) instead of / some / (? [^ /] +. <br>  - It may be a good idea to add $ uri validation (only if you know what you are doing). <br><br>  <b>Override "parent" response headers with the add_header directive</b> <br><br>  This is a well-known feature of Nginx that many of us have stumbled over and will continue to stumble over.  The point is extremely simple - if you set headings at the same level (for example, in the server section), and a lower level (for example, at the location) sets up some more, the first one will not be applied. <br><br>  The most simple example is as follows: <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> _; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Content-Type-Options nosniff; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Frame-Options DENY; } }</code> </pre> <br>  In this case, the X-Content-Type-Options response header will not be set when processing a locale /. <br><br>  Gixy successfully tells you about it: <br><br><pre> <code class="nginx hljs">$ <span class="hljs-attribute"><span class="hljs-attribute">gixy</span></span> /etc/nginx/nginx.conf ==================== Results =================== Problem: [add_header_redefinition] Nested <span class="hljs-string"><span class="hljs-string">"add_header"</span></span> drops parent headers. Description: <span class="hljs-string"><span class="hljs-string">"add_header"</span></span> replaces ALL parent headers. See documentation: http://nginx.org/en/docs/http/ngx_http_headers_module.html#add_header Additional <span class="hljs-literal"><span class="hljs-literal">info</span></span>: https://github.com/yandex/gixy/blob/master/docs/ru/plugins/addheaderredefinition.md Reason: Parent headers <span class="hljs-string"><span class="hljs-string">"x-content-type-options"</span></span> was dropped in current level Pseudo config: include /etc/nginx/sites/default.conf; <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> _; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Content-Type-Options nosniff; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Frame-Options DENY; } }</code> </pre> <br>  I know several ways to solve this problem: <br><br>  - duplicate important headers; <br>  - set the headers at the same level, for example, in the server section; <br>  - consider the option of using the ngx_headers_more module. <br><br>  Each of them has its advantages and disadvantages.  Which one to choose is up to you. <br><br><h3>  About Gixy </h3><br>  I hope I convinced you that the Nginx configuration requires more attention.  I also believe that static analysis of Nginx configurations can work (this also confirms the experience of <a href="https://www.nginx.com/amplify/">Nginx Amplify</a> ).  Unfortunately, it is not always possible to automatically determine all borderline cases or specific features of the application behind Nginx.  So, for example, I didn‚Äôt include the X-Forwarded- * request header override check in the standard set, since the response to them depends on the application, and in some cases they cannot be touched at all (for example, in case of multiple proxying).  But at home you can do the checks you need based on a deeper understanding of the application.  Yes, now Gixy does not know how to identify the whole range of known problems, but he is learning and, perhaps, with your help, he will start doing it better and more fully. <br><br>  If we talk about usage scenarios, then we have identified several typical cases for ourselves: <br><br>  - run in a test environment where nginx is installed; <br>  - web application for checking a single block.  This is useful when you encounter a suspicious part of the config; <br>  - HTTP API for integration with CI or thin clients. <br><br>  It seems to us that the most interesting option is using the HTTP API for thin clients.  Indeed, in this case, we can centrally manage the checks we need, update them, and so on.  Fortunately, modern versions of nginx have the -T switch to test the configuration and dump it, and Gixy can parse this format. <br><br><div class="spoiler">  <b class="spoiler_title">Judge for yourself how comfortable it is.</b> <div class="spoiler_text"> <code>$ nginx -T | http -v https://gixy/api/check Content-Type:'application/nginx' <br> POST /api/check HTTP/1.1 <br> Accept: application/json, */* <br> Accept-Encoding: gzip, deflate <br> Connection: keep-alive <br> Content-Length: 959 <br> Content-Type: application/nginx <br> Host: gixy <br> User-Agent: HTTPie/0.9.8 <br> <br> # configuration file /etc/nginx/nginx.conf: <br> user http; <br> worker_processes 1; <br> <br> #daemon on; <br> events { <br> worker_connections 1024; <br> } <br> <br> http { <br> include mime.types; <br> default_type application/octet-stream; <br> sendfile on; <br> keepalive_timeout 65; <br> gzip on; <br> access_log /var/log/nginx/access.log combined; <br> error_log /var/log/nginx/error.log debug; <br> <br> include sites/*.conf; <br> } <br> <br> # configuration file /etc/nginx/mime.types: <br> types { <br> text/html html htm shtml; <br> text/css css; <br> text/xml xml; <br> image/gif gif; <br> image/jpeg jpeg jpg; <br> application/javascript js; <br> application/atom+xml atom; <br> application/rss+xml rss; <br> } <br> <br> # configuration file /etc/nginx/sites/default.conf: <br> server { <br> listen 80; <br> return 301 https://some$uri; <br> } <br> <br> HTTP/1.1 200 OK <br> Connection: keep-alive <br> Content-Encoding: gzip <br> Content-Type: application/json <br> Date: Tue, 24 Apr 2017 19:45:57 GMT <br> Keep-Alive: timeout=120 <br> Server: nginx <br> Transfer-Encoding: chunked <br> <br> { <br> "result": [ <br> { <br> "auditor": "http_splitting", <br> "config": "\ninclude /etc/nginx/sites/default.conf;\n\n\tserver {\n\t\treturn 301 https://some$uri;\n\t}", <br> "description": "        (\"\\n\")      nginx.      : rewrite, return  proxy_pass.", <br> "help_url": "https://wiki/product-security/gixy/httpsplitting/", <br> "reason": "At least variable \"$uri\" can contain \"\\n\"", <br> "recommendation": "   ,       (eg \"$request_uri\"  \"$uri\").", <br> "severity": "HIGH", <br> "summary": "   HTTP Splitting" <br> } <br> ], <br> "status": "ok", <br> "warnings": [] <br> }</code> <br> </div></div><br>  Finally, I would like to emphasize the fact that this is the first public alpha version of Gixy, so the API can be changed without maintaining backward compatibility.  In this regard, if you need to implement your own plug-in, it is better to write an Issue or send a Pull Request - then we will come up with something together. <br><br>  I hope our experience was interesting and useful to you, and, perhaps, even made you reconsider our configurations again;) </div><p>Source: <a href="https://habr.com/ru/post/327590/">https://habr.com/ru/post/327590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327580/index.html">Microsoft itself</a></li>
<li><a href="../327582/index.html">How does the testing of the developers KOMPAS-3D</a></li>
<li><a href="../327584/index.html">Development: technical task on the site or concept?</a></li>
<li><a href="../327586/index.html">Cheeky telegram bot</a></li>
<li><a href="../327588/index.html">We are testing a new line of SSD VPS + a little insider from the life of a hoster</a></li>
<li><a href="../327592/index.html">Results of the third round of the Russian Code Cup 2017</a></li>
<li><a href="../327594/index.html">How to use the HTTP API to send emails</a></li>
<li><a href="../327596/index.html">Tale of creating a classic RTS at home from scratch (Part 2: "Resurrection")</a></li>
<li><a href="../327598/index.html">Security Week 17: DoublePulsar broke free, a hundred thousand Linksys found holes, SMSVova expelled from Google Play</a></li>
<li><a href="../327600/index.html">Outstanding portfolio creation guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>