<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Naive Spellchecking, or search for the nearest words from the dictionary by Levenshtein's metric on Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings This article will show the algorithm for finding the closest to a given word from the corpus in terms of the Levenshten metric. The naive sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Naive Spellchecking, or search for the nearest words from the dictionary by Levenshtein's metric on Scala</h1><div class="post__text post__text-html js-mediator-article">  Greetings  This article will show the algorithm for finding the closest to a given word from the corpus in terms of the Levenshten metric.  The naive spellchecking is named because it does not take into account neither the morphology, nor the context, nor the probability of the appearance of the corrected word in the sentence, however, as a first approximation, it will completely do.  Also, the algorithm can be extended to search for the nearest sequences from any other comparable objects, rather than a simple alphabet from Chars, and, after doping, it can be adapted to take into account the probabilities of the appearance of corrected words.  But in this article we will focus on the basic algorithm for words of a certain alphabet, say, English. <br><br>  The code in the article will be on Scala. <br><br>  All interested in asking under the cat. <br><a name="habracut"></a><br><h4>  Intro </h4><br>  Generally speaking, specialized data structures exist for searching in a metric space, such as VP-Tree (Vantage Point Tree).  However, experiments show that for a word space with Levenshtein metric, the VP-tree works extremely poorly.  The reason is simple - this metric space is very dense.  A word of, say, 4 letters, has a huge number of neighbors at a distance of 1. At greater distances, the number of options becomes comparable to the size of the whole set, which makes the search in a VP-tree no more productive than a linear search over a set.  Fortunately, there is a more optimal solution for strings, and now we will analyze it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Description </h4><br>  For compact storage of a set of words with a common prefix, we use a data structure such as boron (trie). <br><br><div class="spoiler">  <b class="spoiler_title">Picture of Wikipedia Boron</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qc/t-/ge/qct-gevxn_hlweumwtuljcmo7iq.png"><br></div></div><br>  In a nutshell, the algorithm is described as a simple search by Dijkstra's algorithm on an implicit graph of options for the prefix match of the search word and the word in bor (trie).  In the fuzzy search, the graph nodes are the above options, and the edge weights are the actual Levenshtein distance of a given string prefix and a boron node. <br><br><h4>  Basic implementation of boron </h4><br>  To begin with, we will describe a boron node, we will write an algorithm for inserting and a clear search for a word in boron.  Fuzzy search leave for a snack. <br><br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Trie</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> val ends: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = false, // whether this node is end of some string private val parent: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Trie</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = null, private val childs : </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TreeMap</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Char</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Trie</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = null, val value : </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Char</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0x0</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  As you can see, nothing supernatural.  A boron node is an object with a link to the parent, a Map of the links to the descendants, the literal value of the node, and a flag indicating whether the node is the end node for any string. <br><br>  Now we describe a clear search in boron: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">/// exact search def contains(s: String) = { @tailrec def impl(t: Trie, pos: Int): Boolean = if (s.size &lt; pos) false else if (s.size == pos) t.ends else if (t.childs == null) false else if (t.childs.contains(s(pos)) == false) false else impl(t.childs(s(pos)), pos + 1) impl(this, 0) }</span></span></code> </pre><br>  Nothing complicated.  We descend through the children of the node until we meet a coincidence (t.ends) or see that there is no place to descend further. <br><br>  Now - insert: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">/// insertion def +(s: String) = { def insert(trie: Trie, pos: Int = 0) : Trie = if (s.size &lt; pos) trie else if (pos == 0 &amp;&amp; trie.contains(s)) trie else if (s.size == pos) if (trie.ends) trie else new Trie(true, trie.parent, trie.childs, trie.value) else { val c = s(pos) val children = Option(trie.childs).getOrElse(TreeMap.empty[Char, Trie]) val child = children.getOrElse( c, new Trie(s.size == pos + 1, trie, null, c)) new Trie( trie.ends, trie.parent, children + (c, insert(child, pos + 1)), trie.value) } insert(this, 0) }</span></span></code> </pre><br>  Our boron is immutable, so the function <i><b>+</b></i> returns us a new boron. <br><br>  Building a boron from a body of words looks something like this: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Trie</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(seq: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) : <span class="hljs-type"><span class="hljs-type">Trie</span></span> = seq.filter(_.nonEmpty).foldLeft(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Trie</span></span>)(_ + _) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(seq: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) : <span class="hljs-type"><span class="hljs-type">Trie</span></span> = apply(seq.iterator) }</code> </pre><br>  Basic construction is ready. <br><br><h4>  Fuzzy search, basic function </h4><br>  We describe the graph node: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val pos: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val node: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Trie</span></span></span></span></span><span class="hljs-class">)(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val penalty: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Pos is the position at which the prefix of the search string ends in the considered variant.  Node - boron prefix in the current version.  Penalty - Levenshtein distance of the string prefix and the boron prefix. <br><br>  The curried case-class means that the compiler will generate the equals / hashCode function only for the first argument list.  Penalty versus Variant are <i>not counted</i> . <br><br>  Looking through the nodes of a graph with non-decreasing penalty is managed by a function with this signature: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixes</span></span></span></span>(toFind: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">Variant</span></span>]</code> </pre><br>  To implement it, we write a small helper that generates a Stream with a generator function: <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">streamGen</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">Ctx</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] (init: <span class="hljs-type"><span class="hljs-type">Ctx</span></span>)(gen: <span class="hljs-type"><span class="hljs-type">Ctx</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">Ctx</span></span>)]): <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> op = gen(init) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op.isEmpty) <span class="hljs-type"><span class="hljs-type">Stream</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> op.get._1 #:: streamGen(op.get._2)(gen) }</code> </pre><br>  Now we implement the immutable context of the search, which we will pass to the function above, and which contains everything that is needed to iterate over the nodes of an implicit graph using the Dijkstra algorithm: a priority queue and many visited nodes: <br><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Context</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> // immutable priority queue, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-class"><span class="hljs-params"> of (penalty-, prefix pos+</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">-&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Variant</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">q</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">TreeMap</span></span>[(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>), <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Variant</span></span>]], <span class="hljs-comment"><span class="hljs-comment">// immutable visited nodes cache val cache: HashSet[Variant]) { // extract from 'q' value with lowest penalty and greatest prefix position def pop: (Option[Variant], Context) = { if (q.isEmpty) (None, this) else { val (key, list) = q.head if (list.tail.nonEmpty) (Some(list.head), new Context(q - key + (key, list.tail), cache)) else (Some(list.head), new Context(q - key, cache)) } } // enqueue nodes def ++(vars: Seq[Variant]) = { val newq = vars.filterNot(cache.contains).foldLeft(q) { (q, v) =&gt; val key = (v.penalty, v.pos) if (q.contains(key)) { val l = q(key); q - key + (key, v :: l) } else q + (key, v :: Nil) } new Context(newq, cache) } // searches node in cache def apply(v: Variant) = cache(v) // adds node to cache; it marks it as visited def addCache(v: Variant) = new Context(q, cache + v) } private object Context { def apply(init: Variant) = { // ordering of prefix queue: min by penalty, max by prefix pos val ordering = new Ordering[(Int, Int)] { def compare(v1: (Int, Int), v2: (Int, Int)) = if (v1._1 == v2._1) v2._2 - v1._2 else v1._1 - v2._1 } new Context( TreeMap(((init.penalty, init.pos), init :: Nil))(ordering), HashSet.empty[Variant]) } }</span></span></code> </pre><br>  The node queue is made from simple immutable treemaps.  Nodes in the queue are sorted in ascending penalty and descending prefix pos. <br><br>  Well, finally the generator itself stream options: <br><br><pre> <code class="scala hljs"> <span class="hljs-comment"><span class="hljs-comment">// impresize search lookup, returns stream of prefix match variants with lowest penalty def prefixes(toFind: String) : Stream[Variant] = { val init = Variant(0, this)(0) // returns first unvisited node @tailrec def whileCached(ctx: Context): (Option[Variant], Context) = { val (v, ctx2) = ctx.pop if (v.isEmpty) (v, ctx2) else if (!ctx2(v.get)) (Some(v.get), ctx2) else whileCached(ctx2) } // generates graph edges from current node def genvars(v: Variant): List[Variant] = { val replacePass: List[Variant] = if (v.node.childs == null) Nil else v.node.childs.toList flatMap { pair =&gt; val (key, child) = pair val pass = Variant(v.pos, child)(v.penalty + 1) :: Nil if (v.pos &lt; toFind.length) Variant(v.pos + 1, child)(v.penalty + {if (toFind(v.pos) == key) 0 else 1}) :: pass else pass } if (v.pos != toFind.length) { Variant(v.pos + 1, v.node)(v.penalty + 1) :: replacePass } else replacePass } streamGen(Context(init)) { ctx =&gt; val (best, ctx2) = whileCached(ctx) best.map { v =&gt; (v, (ctx2 ++ genvars(v)).addCache(v)) } } }</span></span></code> </pre><br>  Of course, <i>genvars</i> deserves the most attention.  For a given node of the graph, it generates edges emanating from it.  For each descendant of the boron node of this search option, we generate a variant with an insert character <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pass = <span class="hljs-type"><span class="hljs-type">Variant</span></span>(v.pos, child)(v.penalty + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  and replacing the character <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Variant</span></span>(v.pos + <span class="hljs-number"><span class="hljs-number">1</span></span>, child)(v.penalty + {<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toFind(v.pos) == key) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  If you have not reached the end of the line, then the generma also has the option of removing the character <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Variant</span></span>(v.pos + <span class="hljs-number"><span class="hljs-number">1</span></span>, v.node)(v.penalty + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><h4>  Fuzzy search, usability </h4><br>  Of course, the <i>prefixes</i> function is not suitable for general use.  Let's write wrappers that allow us to search more or less meaningfully.  To begin with, we will limit the search of variants to some reasonable value of penalty to prevent the algorithm from sticking on any word for which there is no more or less adequate replacement in the dictionary. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">limitedPrefixes</span></span></span></span>(toFind: <span class="hljs-type"><span class="hljs-type">String</span></span>, penaltyLimit: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>): <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">Variant</span></span>] = { prefixes(toFind).takeWhile(_.penalty &lt; penaltyLimit) }</code> </pre><br>  Next, we filter the options with a full, rather than a prefix match, that is, those that have pos equal to the length of the search string, and node points to the end node with the ends == true flag: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span></span>(toFind: <span class="hljs-type"><span class="hljs-type">String</span></span>, penaltyLimit: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>): <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">Variant</span></span>] = { limitedPrefixes(toFind, penaltyLimit).filter { v =&gt; v.node.ends &amp;&amp; v.pos == toFind.size } }</code> </pre><br>  Finally, we will convert the stream of variants into the stream of words. To do this, in the <i>Trie</i> class, we will write a code that returns the found word: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeString</span></span></span></span>() : <span class="hljs-type"><span class="hljs-type">String</span></span> = { <span class="hljs-meta"><span class="hljs-meta">@tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span></span>(t: <span class="hljs-type"><span class="hljs-type">Trie</span></span>, sb: <span class="hljs-type"><span class="hljs-type">StringBuilder</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || t.parent == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) sb.result.reverse <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { helper(t.parent, sb += t.value) } helper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">StringBuilder</span></span>) }</code> </pre><br>  Nothing complicated.  Climb up on parenting, recording the values ‚Äã‚Äãof the nodes, until we meet the boron root. <br><br>  And finally: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchValues</span></span></span></span>(toFind: <span class="hljs-type"><span class="hljs-type">String</span></span>, penaltyLimit: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>): <span class="hljs-type"><span class="hljs-type">Stream</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = { matches(toFind, penaltyLimit).map(_.node.makeString) }</code> </pre><br><h4>  Total </h4><br>  I must say that the function <i>matches is</i> very versatile.  Using it, you can search for K nearest, making <br><br><pre> <code class="scala hljs">matches(toFind).take(k).map(_.node.makeString)</code> </pre> <br>  or search for Delta-closest, that is, lines at a distance not more than D: <br><br><pre> <code class="scala hljs">matches(toFind).takeWhile(_.penalty &lt; d).map(_.node.makeString)</code> </pre> <br>  Another algorithm can be expanded by introducing different weights for inserting / deleting / replacing characters.  You can add specific replace / delete / insert counters to the Variant class.  Trie can be generalized, so that it is possible to store values ‚Äã‚Äãin the end nodes, and not only strings, but also indexed sequences of any comparable types of keys can be used as keys.  You can also mark each boron node with a probability to meet it (for the end node it is the probability to meet the word + the probability to meet all the descendant words, for the intermediate one - only the sum of the probabilities of the descendants) and to take this weight into account when calculating the penalty, but this is already beyond the scope of this article . <br><br>  I hope it was interesting.  Code <a href="https://github.com/iboltaev/scalaspell/blob/master/src/main/scala/Trie.scala">here</a> </div><p>Source: <a href="https://habr.com/ru/post/345002/">https://habr.com/ru/post/345002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344992/index.html">Stack: analyze parameter values</a></li>
<li><a href="../344994/index.html">Netflix selects the best movie covers for each viewer.</a></li>
<li><a href="../344996/index.html">Evaluation of option premiums - analytical formulas vs modeling</a></li>
<li><a href="../344998/index.html">One day at Alpha Lab: Java development</a></li>
<li><a href="../345000/index.html">R and Information Security. How to eliminate the contradiction of interests and run R on Linux in offline mode</a></li>
<li><a href="../345006/index.html">Technology good</a></li>
<li><a href="../345010/index.html">Oh, I have a delay. Part 2</a></li>
<li><a href="../345012/index.html">Task with an asterisk: how we recoded the FIAS in KLADR</a></li>
<li><a href="../345014/index.html">How to manage sections in Oracle DB and not go crazy</a></li>
<li><a href="../345016/index.html">Polymer, fight for performance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>