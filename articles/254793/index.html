<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Two worlds of virtual machines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Virtual Unlike most fashionable computer words, this concept usually corresponds to its dictionary definition when it comes to hardware or software. T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Two worlds of virtual machines</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <i>Virtual</i>  Unlike most fashionable computer words, this concept usually corresponds to its dictionary definition when it comes to hardware or software.  The Dictionary ‚ÄúRandom House College Dictionary‚Äù defines ‚Äúvirtual‚Äù as ‚Äúmanifesting the properties and effects of something, but not being such‚Äù. <br><div class="spoiler">  <b class="spoiler_title">Original</b> <div class="spoiler_text">  <i>Virtual.</i>  It usually refers to hardware or software.  The vocabulary of the vocabulary defines ‚Äúvirtual‚Äù as ‚Äúbeing such a force or effect, although not actually or expressly such.‚Äù [4] <br></div></div></blockquote>  For the last few years, at the beginning of each semester, I give students definitions of the main terms used in my course: <i>simulation</i> , <i>emulation,</i> and <i>virtualization</i> .  And every time I say that my words do not take for one hundred percent truth.  The fact is that in some areas of technical knowledge these terms are often interpreted contrary to what is commonly used in others.  Difficult this thing - to give definitions. <br><br>  Apparently, this problem was noticed not only by me.  In their book, <a href="http://store.elsevier.com/Software-and-System-Development-using-Virtual-Platforms/Daniel-Aarno/isbn-9780128008133/">Software and System Development using Virtual Platforms</a> , published last year, my colleagues Jakob Engblom and Daniel Aarno introduce the concepts of <i>simulation</i> and <i>emulation</i> in the <a href="http://scitechconnect.elsevier.com/software-system-development-using-virtual-platforms-chapter-one/">first chapter</a> and note the ambiguity of their interpretation in the areas of software development and hardware design. <br><br>  I understood for myself the disorder in the interpretation of these two terms and seemed to be reconciled.  There remains one more concept, for more than ten (actually <i>fifty</i> ) years not losing popularity - this is ‚Äúvirtualization‚Äù.  During its existence in the category ¬´buzzword¬ª it began to be combined with many other words.  Recently, I realized that the term ‚Äúvirtual machine‚Äù (VM) is actually used to mean two, though related, but different entities.  In this article I will talk about two classes: <i>language</i> and <i>system</i> virtual machines.  I will show the similarities and differences between them, their purpose, classification, common and particular features in their practical implementation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/bbe/84f/f55/bbe84ff55c1d460796de7b42d603ef3f.png"><br><a name="habracut"></a><br>  Broadly speaking, a virtual machine is a <i>program</i> whose task is to implement the specifications of a specific computing device or class of devices.  This is its main difference from the "just" physical machine that implements the same thing, but in hardware.  Any specification (computer architecture) most often includes the definition of device interfaces and a description of transitions between machine states.  However, the definition of an interface, as is well known, should not impose restrictions on how it is implemented. <br><br>  Many of us probably don‚Äôt notice how often they are confronted daily with both types of machines - virtual and real.  For example, the simplest calculator has two implementations - as a specialized device and as a program: <br><br><img src="https://habrastorage.org/files/879/f1e/f30/879f1ef3000347e58e19b7788fb7a385.png"><br><br>  Both the hardware on the left and the virtual machine on the right provide the same interface ‚Äî the buttons and the screen ‚Äî and implement the same functions ‚Äî arithmetic, logical, and trigonometric operations on the numbers displayed on the screen. <br><br>  A virtual calculator is an example of a virtual machine - a software copy of what originally existed only in the form of hardware, a physical machine, a very specific and tangible <i>system</i> .  We will return to the system VM later. <br><br><h2>  Language VMs </h2><br>  Another case is when a program is created for something ‚Äúunreal‚Äù from the very beginning, for example, for a programming language or runtime environment.  In this case, such a <i>language</i> virtual machine will be a way to implement the specification of a language or environment. <br><div class="spoiler">  <b class="spoiler_title">Is VM always needed?</b> <div class="spoiler_text">  The key phrase in the previous paragraph is the <i>method of implementation</i> .  In addition to VM, there are other ways. <br>  Whenever we take the documentation for a new programming language, we open the description of the "nonexistent" machine.  For example, K &amp; R C is in many places its deliberate unspoken description of the environment for C programs.  Most implementations of C are compilers (I will be grateful if I am prompted by implementations based on VM).  For Java, the description of the environment and its boundaries is clearer (its authors had different goals and objectives than the creators of C), however, neither the use of any particular VM is dictated here (the choice of machines from Sun / Oracle, IBM, Microsoft, Apple, GNU and even Google's Dalvik), nor even the need for VM (GNU GCJ compiler). <br></div></div><br><br>  Language VMs are usually designed to execute one guest application (sometimes multi-threaded) in one copy of the virtual environment.  In other words, they do not assume the functions of access control to resources typical for a multiuser / multitasking operating system.  The task of a language VM is to provide the program with an environment that is not directly dependent on the details (and to some extent restrictions) of the underlying physical system, such as the processors used in the latter, RAM and disk volumes, presence and features of peripheral devices, etc. <br><br>  Of course, and here not to do without holivar about terminology.  I will also refer to what is called a process virtual machine and what is called a managed runtime environment (MRE) as a language VM (language VMs). <br><br><h3>  Two families of language VMs </h3><br>  A language VM is in the middle of a path: from high-level languages ‚Äã‚Äãto the computer codes of the computer on which it is executed.  Therefore, when creating a new language VM architecture, two factors should be taken into account: the convenience of converting selected input languages ‚Äã‚Äãand the speed of execution on specific hardware systems.  From the first will depend on the versatility and extensibility of the created environment, and from the second - the upper limit of the speed of programs for this VM. <br><br>  The basic unit of execution for a VM is a <i>machine instruction</i> .  Each such instruction should determine the operation performed on the data, as well as the location of the data itself.  Naturally, the set of operations is highly dependent on the specific VM and can vary widely.  The ‚Äúiron‚Äù instruction sets are much more limited in this <i>[I'm still waiting for a processor with hardware malloc () and free (), and better with a hardware garbage collector]</i> . <br>  On the other hand, in approaches to the organization of the processed data among VM there is not so much variety.  In fact, there are two well-established concepts - to store data on the stack (s) and use a dedicated set of registers. <br><br><h4>  Stacked VM </h4><br>  Such VMs store all or almost all of the data in one or more stacks.  Addressing them is done by addressing the relative position of the desired cell from the current top of the stack.  If an operation has a result, then it is pushed onto the stack, becoming its new top.  In addition to the data, addresses that are used when returning from called subprocedures to callers can be stored on the stack.  Alternatively, the addresses may be in a separate stack. <br>  About stack machines known and written a lot, and I will not try to describe here everything that I know and what I do not know.  I will highlight only some key facts. <br><br>  I note the advantages of stack language VM: <br><ul><li> Ease of translating expressions from infix notation (expressions with parentheses: <code>a + b * (c / (d - f))</code> ) to the stack representation (reverse Polish notation). </li><li>  Compact encoding instructions.  Most machine instructions do not require explicit arguments, since they work with the top of the stack. </li></ul>  The only important exception in practice is the transfer to the process of calculating literals - constants.  It is easier to transfer them entirely in the flow of instructions than to try to "construct" from the good already stored on the stack.  But if you wish, you can make a VM without it: start the operation ‚Äúput a unit on the stack‚Äù, and then continue to fold it with you until you get the desired number. <br>  It is impossible to say that in the stack VM there can be no allocated registers at all.  You must have at least two cells: one for the pointer of the current command, and another for the pointer to the top of the stack.  However, they are not always available for direct manipulation in the program, i.e.  not every machine makes them architecturally visible. <br><br>  Since we are now talking only about software systems, I will not go into particular hardware stack machines, with their strengths and weaknesses, such as interrupt handling, memory access speed, interaction with various processor nodes, opportunities for parallelization, etc.  I recommend a good <a href="http://en.wikipedia.org/wiki/Stack_machine">Wikipedia article</a> as a starting point. <br><br><h5>  Examples </h5><br>  I do not hide the truth, saying that for all the time all sorts of language virtual machines have been created a lot.  Trying to describe them all is a hopeless undertaking.  Therefore, I further mention only some of them as examples. <br><br><h5>  Historical important examples of stack language VMs </h5><br>  <a href="http://skelet.ludost.net/sec/">SECD</a> is an abstract machine that appeared in the 1960s and influenced the development of functional languages, including LISP. <br><br>  <a href="http://homepages.cwi.nl/~steven/pascal/book/10pcode.html">P-code</a> is the language of the virtual machine into which the first Pascal compiler of the University of California transmitted programs.  Thanks to the p-code portability and the ‚Äúbootstrapping‚Äù approach of the compiler, it was possible to quickly get a working Pascal compiler on new computers, which, when there were no standards for the environment (no POSIX for you in the 70s) and a huge number of incompatible architectures The computer was an important factor in gaining popularity in the language. <br><br>  <a href="http://thinking-forth.sourceforge.net/">Forth</a> - in general, Forth cannot be called <i>just a</i> language VM.  For some, this is a high-level procedural language, for some it is an object-oriented language, for someone it is a functional language, for someone it is machine-language, and for some it is a Thinking Forth system design philosophy.  However, it is the Fort that comes to my mind when someone says the words ‚Äúprogramming‚Äù and ‚Äústack‚Äù in the same sentence. <br><br><h5>  Actual language VM </h5><br>  <b>Java VM</b> - bytecode for the well-known ‚Äúcompile once, run everywhere‚Äù Java language (as well as for Scala, Clojure, etc.) runs on a stack VM.  The stack itself stores the scalar data of the running methods, the arguments of instructions, including references to objects and arrays, which are stored in a separate heap area. <br><br>  Microsoft's <b>Common Intermediate Language</b> is the foundation of the .NET framework.  C #, F #, VB.NET and many other less popular high-level languages ‚Äã‚Äãare translated into it.  Bytecode is executed on a stack VM.  The structure of both the runtime environment and the CIL bytecode differs significantly from the JVM;  in [1], their comparison is given, including their similarities between themselves and differences from conventional hardware instruction sets. <br><br>  Thus, the two most popular runtime environments use stack language VMs.  Perhaps the reader has a question: if the code from bytecode most often ends up being translated into a real machine code of the host system, whose architecture contains registers, and not just the stack (who reads these lines from the display of the machine with stack architecture, raise your hands!) , why do the two most popular language VMs use stack representation?  The following argument is given in [1]: ‚Äú... a stack is amenable to platform independence (ISA)‚Äù - ‚Äúthe stack facilitates platform independence (the host platform can have any number of registers in its recruitment teams) ". <br><br><h4>  Register VMs </h4><br>  An alternative approach to storing the processed data is to use a dedicated set of memory cells with fixed name numbers ‚Äî <i>registers</i> .  The instructions mainly operate on the data on the registers, if necessary, loading the missing values ‚Äã‚Äãfrom the memory or unloading unnecessary values ‚Äã‚Äãinto the memory. <br>  In some register architectures, the stack is also usually available.  However, it does not play a central role in the work of the VM, but is used to support the procedural mechanism (in which case it is not necessarily directly available to programs). <br><br>  The features of register VMs are easiest to see by comparing them with stack ones. <br><ul><li>  Their machine instructions are longer, because they have to encode operands.  In stack VMs, operands are implicitly specified. </li><li>  When the VM is running, fewer memory accesses occur.  Stacked VMs are constantly forced to shift data on the stack, since the lifetime of the latter is short (most often the operation ‚Äúeats‚Äù the input values ‚Äã‚Äãfrom the top of the stack and replaces them with its result).  The value placed in the register lives until its rewriting.  For example, it allows you to get rid of the constant computation or loading from the memory of values ‚Äã‚Äãfor cyclic invariants - they are simply placed in registers. </li><li>  The need to use register allocation algorithms for broadcasting from high-level languages.  For nontrivial programs, there will always be a situation of register shortages (their number is limited) to accommodate all the data used in the calculation.  At the same time, it is necessary to keep track of which register is at each moment of time.  Whereas in the case of stack VMs, the top of the stack is one, and it is always ‚Äúavailable‚Äù.  These circumstances can significantly complicate the logic of the tools for the register VM. </li></ul><br><br>  The most interesting question is whether the VM type ‚Äî stack or register ‚Äî executes programs faster.  There is currently no clear answer;  data from some researchers prove the advantage of the first type, while others argue the opposite.  An interesting experiment is described in [3] - the authors of the article use a register VM for execution, the code for which is obtained using an optimized translation from Java bytecode, and compares the performance. <br><br><h5>  Examples </h5><br>  <a href="http://docs.parrot.org/parrot/latest/html/index.html">Parrot VM</a> is a <s>long</s> - <s>term</s> VM developed for over 10 years and serving as the main execution environment for the Perl 6 language. <br><br>  <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html">Dalvik</a> from Google is a registered VM used to execute applications written in Java.  Interestingly, the stack JVM bytecode (* .class) is converted to register VM bytecode (* .dex).  Currently, Dalvik fades into the background in Android, giving way to ART - the mechanism of direct compilation into the machine code of the host system. <br><br>  <a href="http://llvm.org/docs/BitCodeFormat.html">LLVM bitcode</a> is one of the representations of the source program used when translating programs using LLVM-based tools and partly the VM input language using the three-instruction format of instructions with registers.  Unusual in this VM is that the instructions are expressed in the so-called.  SSA (single static assignment) form, i.e.  they use a potentially unlimited number of virtual registers.  The allocation of VM registers to physical ones occurs later in the process of translation into machine code or interpretation. <br><br>  MIX and <a href="http://www-cs-faculty.stanford.edu/~knuth/mmix.html">MMIX</a> are virtual machines used (or planned for use in future editions) by D. Knut in his series The Art of Programming to illustrate the implementation of algorithms.  MIX is made in the spirit of the 1960s: a dedicated register-battery, 6-bit bytes, a binary-decimal number format, no stack, and a tendency to use self-modifying code.  MMIX is already a sane RISC with a generous number (256) and a width (64 bits) of registers. <br><div class="spoiler">  <b class="spoiler_title">On the illustration of machine code algorithms</b> <div class="spoiler_text">  Personally, it is very difficult for me to understand the ‚Äúalgorithms‚Äù written in MIX, in an already complex book that the author undoubtedly respected me.  For some reason it seems to me that the use of higher level languages ‚Äã‚Äãwould greatly facilitate perception. <br></div></div><br><br><h4>  Exotic VM </h4><br><blockquote>  Beware of the Turing tar pit, in which everything is possible, but none of the interesting is achievable. <br><div class="spoiler">  <b class="spoiler_title">Original</b> <div class="spoiler_text">  It is an easy way to get around.  Alan Perlis, "Epigrams on Programming" </div></div></blockquote><br>  Finally, the third approach to building a VM is to break all the rules and create an architecture that is unlike anything ‚Äústandard‚Äù.  On the one hand, this is very exciting: to invent a new concept where everything seems to be invented.  On the other hand, the benefits of such systems are limited, often because of their (addictive) extreme impracticality. <br><br>  <b>printf () as a virtual machine</b> is not exactly exotic, I just want to show a familiar thing to many things from a new angle.  After all, if you take a closer look, the specification line that comes with the first argument to the standard functions of the C <code>printf</code> family is a program whose instructions are characters, and the data are the remaining arguments of the function.  Most of the instructions of this VM simply output one character that matches the code of the instruction itself;  but the <code>%</code> instruction has much more complex semantics, depending on the characters following it.  Not surprisingly, some vulnerabilities in software are based on passing a specially selected string to interpret it in printf and executing unauthorized code. <br><br>  <b>OISC</b> .  The most fascinating and mysterious (for me) class of languages ‚Äã‚Äãof an exotic type is <a href="http://esolangs.org/wiki/OISC">OISC</a> (one instruction set computer) - systems containing exactly one machine instruction and at the same time not being completely trivial.  Some of them are equivalent to the Turing machine, i.e.  quite complex algorithms can be programmed on them.  The best known of OISC is subleq (subtract and branch unless positive). <br>  It should be noted that OISC is often hidden in a completely familiar set of machine instructions;  for example, MOV in a <a href="http://zlo.rt.mipt.ru/%3Fread%3D8586394">PDP-11</a> or # PF / # DF with Intel ¬Æ <a href="https://github.com/jbangert/trapcc/raw/master/slides/PFLA-shmoocon.pdf">IA-32</a> ;  The last machine can be called <i>zero</i> instruction set computer, because formally the execution of IA-32 instructions during exception handling does not occur. <br><br>  <a href="http://doc.cat-v.org/inferno/4th_edition/dis_VM_specification">Dis</a> - VM for distributed OS Inferno, created at Bell Labs by people who were at the beginnings of Plan 9 OS. This machine has memory-to-memory addressing, which is rather unusual by modern standards (the last time in hardware was in Motorola 68000), and lack of architecturally visible registers.  I cannot think of the advantages of such an approach either over register systems or stack systems;  rather, he collects in himself all their faults. <br><br><h3>  Execution methods </h3><br>  After determining the type of VM and architecture details, it is time to create a program that implements the VM functionality.  After choosing a programming language and other little things, you need to decide how the instructions will be processed.  And there are at least three ways: <br><br><img src="https://habrastorage.org/files/fbe/c8c/fad/fbec8cfada9847068c7cf21e9b384b2c.png"><br><br>  Interpretation is the main and initial technique for both language and system VM.  I described its basic principle in my previous articles.  The question of building the most efficient interpreter is not as simple as it seems, and is of great practical value due to the wide popularity and prevalence of dynamic languages ‚Äã‚Äãthat use interpretation at various stages of their work.  And it's not always enough to write <code>switch (...) {case ... case ... case ...}</code> .  I plan to describe in more detail the problems leading to the low speed of work for such a naive approach, and the existing solutions in one of my subsequent articles. <br><br>  Dynamic translation is a technique that is generally superior to interpretation in terms of both speed and complexity of implementation.  It is based on the fact that the code executed inside the VM forms cycles, and the instructions within them will perform the same actions with each interpretation.  If the blocks of the VM code are translated into equivalent sections of the machine code of the physical system before execution, you can save on decoding and interpretation.  The more iterations will be carried out in a loop, the greater will be the effect of the use of translation.  I described one of the ways to build a simple template translator in a previous <a href="http://habrahabr.ru/company/intel/blog/254027/">article</a> . <br><br>  Static translation - in the case when all the code to be executed is known in advance (that is, in the course of VM operation, loading of new blocks with instructions is not expected), then it is possible to use classical compilation ‚Äî once to convert the machine instructions of the original VM into machine instructions of the physical system, This optionally applying a variety of optimizations. <br><br>  If I am interested in the design and implementation of language VMs, I can advise the book [2], the author of which describes the theory and gives practical examples of the implementation of stackable, register VMs, as well as the ‚Äúexotic‚Äù VM version for an event-oriented system. <br><br><h2>  System VMs </h2><br><br>  System virtual machines, as a rule, are created according to specifications for which ‚Äúiron‚Äù implementations already exist.  This brings its own features to the process of creating such VMs.  The architecture of this equipment is limited more than a purely software, ‚Äúspeculative‚Äù VM: requirements affect performance, power consumption, the physical dimensions of the crystal that can accommodate the implementation, compatibility with external devices, etc. <br><br>  Often, the goal of creating a system VM is to launch unmodified (neglect para-virtualization for simplicity) operating systems inside it that provide multitasking and controlled access to system resources for guest user applications.  Unlike language VMs designed for a single process, the system VM should provide a fairly complete environment from a large number of peripheral models, simulation of working with physical memory cards, correct interrupt and exception processing, monotonous and uniform virtual time, etc. <br><br>  Unlike the creators of language VMs, who often have quite a lot of freedom in choosing machine parts, the programmers implementing system VMs are bound by the need to clearly follow the hardware specifications, which are usually not easy to change.  Significant efforts have to be spent on effective support for idiosyncrasies (or simply crutches) of the chosen machine language.  After a long evolution and numerous extensions, some architectures look like a solid crutch fence ... but I got distracted.  In any case, when creating a system VM, more attention is paid to the issues of creating a correct and fast program than to the hassle of input machine language. <br><br><h3>  Classification of system VMs </h3><br><br><img src="https://habrastorage.org/files/09a/fae/4cb/09afae4cbe794c8b87012fe02bd0befe.png"><br><br>  System VMs are primarily classified according to what type of guest processor is being modeled.  There are many classifications of processors, and they are described in some detail in various sources, so here I only briefly summarize the most common things.  According to the architecture of the CPU command set, there are CISC ‚Äî complex instructions that do many things at once, including loading data from memory, and RISC ‚Äî the simplest instructions in which memory access and operations on data in registers are clearly separated;  VLIW stand somewhat apart, in which several different operations are combined into one machine word.  It is also possible to classify instruction sets based on the variability of the instruction length: systems with variable command lengths and systems with a fixed length.  In truth, the truly constant length of instructions is rare - always or something does not fit into the machine word (for example, 32-bit literals in ARC and 64-bit in IA-64), or the creators try to save money by assigning to frequently used instructions are shorter sequences (16-bit ARCompact or ARM Thumb commands). <br><br>  When creating a system VM, an important classification feature is the presence / absence of a ‚Äúrelationship‚Äù between the host and guest architectures.  According to the degree of relationship, the simulated and modeling systems can be: completely heterogeneous (for example, Zilog Z80 and PowerPC), similar (Intel IA-32 and Intel 64, or Intel 8086 and Intel IA-32) or the same ( <i>X</i> and <i>X</i> , where <i>X</i> - your favorite architecture). <br><br>  In the case when the guest and the host are different, the task of the system VM is to provide the ability to run applications written and compiled for the ‚Äúalien‚Äù architecture on the host system without the need to recompile them or make any other modifications.  Ideally, the VM software layer may be completely invisible to the end user.  It is obliged to work correctly, quickly enough and not require additional configuration. <br><br>  Such an approach can help companies transfer users with their favorite programs from their old architecture to a new one (of course, excellent in everything, but incompatible with the old one), or even lure users of a competitor‚Äôs system to their own.  The system VM should eliminate the loop: a <i>new architecture ‚Äî no applications ‚Äî no users ‚Äî no developers ‚Äî no popularity ‚Äî no applications</i> . <br>  Examples of this application VM weight.  Let me give you some known to me. <br><ul><li>  Digital Company: Digital FX! 32 for launching IA-32 applications on Alpha, VEST - for launching VAX programs on Alpha, mx - Ultrix MIPS on Alpha. </li><li>  IBM: PowerVM Lx86 for running IA-32 on POWER processors. </li><li>  Apple used system VMs twice: when switching from a Motorola 680x0 to a PowerPC in 1996;  Apple Rosetta to translate from PowerPC to IA-32 in 2006. </li><li>             IA-32   ¬´¬ª. </li><li>  Intel   IA-32 Execution Layer   IA-32   Intel Itanium. </li><li>  NTVDM (NT virtual DOS machine)  32-  Microsoft Windows    DOS-,    8086      MS-DOS. </li><li>    Intel:     Android,    ARM,     Intel Atom,     ,   . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this list goes on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In cases of coincidence of architectures of guest and host systems, the system VMs also find application. Running a guest OS inside a VM running the monitor allows you to control its resource consumption, execute simultaneously with other systems, freeze, restore from images, clone, migrate from one place to another and generally perform various tricks that are difficult to turn with an OS running directly on the hardware .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For VM creators, the ‚Äúvirtualizability‚Äù of the instruction set becomes critical. It depends on how easy it is to implement a virtual machine monitor for it, as well as how much slowdown (in relation to working on bare hardware), does it satisfy whether the selected machine instruction architecture satisfies the sufficient conditions of Goldberg-Popek. Intel IA-32 / Intel 64 before the advent of Intel VT-x extensions belonged to the first category of hard-to-virtualizable systems, but at present it is easy to write effective monitors for it (if this word is applicable to the development of core modules for instruction set with almost half a century evolution ).</font></font><br><br><h3>  Execution methods </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the point of view of software implementation, system VMs have much in common with linguistic ones. This is not surprising - the basic unit of execution in both cases is the machine instruction. </font></font><br><br><img src="https://habrastorage.org/files/ca4/452/721/ca4452721aca4a49826a780ab9f12943.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpretation - and again this word! In the case when you need to make the most easily portable system VM without special consideration for speed, the interpreter will be the natural first choice. </font></font><a href="http://bochs.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bochs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is probably the most famous open source project of this type. I emphasize again the lack of order in terminology - on the official page of Bochs is presented as a ‚ÄúPC emulator‚Äù, and not a simulator or a virtual machine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic translation - as described earlier, a group of technologies that promise a higher speed. But static translation, applicable for language VMs, is not very convenient for creating system VMs ‚Äî in full-platform models, it‚Äôs extremely rare for all code to be available and known in advance, before the start of the simulation. The purely dynamic translators include the previously mentioned IA-32 Execution Layer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware support ‚Äî for architectures that support hardware virtualization, this is the most efficient method. </font><font style="vertical-align: inherit;">However, it is also the most ‚Äúcapricious‚Äù, because it only works if the guest and host architectures coincide. </font><font style="vertical-align: inherit;">Often, even relatively small differences between the sets of extensions of the selected systems may make it impractical to attempt to create a VM of this type. </font><font style="vertical-align: inherit;">Most modern commercial hypervisors for IA-32 actively rely on the presence of VT-x in their work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interested in the design and implementation of system VMs I want to advise the book [1]. </font><font style="vertical-align: inherit;">Not interested, too, I would venture to advise her - it explains in an accessible way many important features of computer architecture, it is written in quite understandable language.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What appeared earlier - virtual memory or virtual machine?</font></font></b> <div class="spoiler_text">      .    ,      ,                      ,         .  ,   ¬´¬ª            .  [4],         ,   : <br><blockquote> IBM    VM (Virtual Machine)  1964.    , VM   .     ,       :    ,       ,    . IBM  VM      ,                   .        VM ,       ,       . <br><div class="spoiler">  <b class="spoiler_title">Original</b> <div class="spoiler_text"> IBM developed VM (¬´Virtual Machine¬ª) in 1964. Like any operating system, VM controlled the computer's resources. It also added a feature that had never existed before: the illusion, for each of its users, that they had a whole computer to themselves. (Because IBM developed VM well before the invention of the PC, having even a simulation of your own computer was a Big Deal.) If twenty people use a VM system at once, it gives them the illusion that they are using twenty different computers. </div></div></blockquote><br>  ,      ! </div></div><br><br><h2>  Results </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I tried to describe two classes of software systems, called virtual machines, to show the differences and similarities between them, known variations of the used architectures and their software implementations. The total classification of </font></font><br><br><img src="https://habrastorage.org/files/b55/7a7/fed/b557a7fed2ef41a2a0dd878bb905fe6f.png"><br><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VMs is </font><font style="vertical-align: inherit;">as follows: </font><font style="vertical-align: inherit;">Language virtual machines are primarily distinguished by the organization of data access. System VMs are primarily characterized by the features of the hardware architecture of the implemented guest. Very often the script implemented in practice implies the coincidence of the host and guest architectures. In this case, the most important property from the point of view of the designer of the VM monitor is the satisfaction of the conditions of effective virtualizability. </font></font><br><br> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Whew, as always, I wanted to write a couple of lines, but I got a long post-sheet.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, the scope of questions about the structure, performance and development of virtual machines is immense. </font><font style="vertical-align: inherit;">I was planning to write more about a couple of moments in the work of the creators of VM, but, perhaps, I will postpone them for the next time.</font></font><br>  Thanks for attention! <br><br><h2>  Literature </h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> James E. Smith, Ravi Nair, Virtual Machines: Versatile Platforms For Systems And Processes - Morgan Kaufmann - 2005. ISBN 1-55860-910-5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Craig, Iain D. Virtual Machines - Springer - 2006. ISBN 1-85233-969-1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yunhe Shi, Kevin Casey, M. Anton Ertl, and David Gregg. </font><font style="vertical-align: inherit;">Virtual Machine Showdown: Stack Versus Registers - USENIX - 2008. </font></font><a href="https://www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.usenix.org/events/vee05/full_papers/p153-yunhe.pdf</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bob DuCharme. </font><font style="vertical-align: inherit;">Fake Your Way Through Minis and Mainframes (formerly, ‚ÄúThe Operating System Hand-book‚Äù) - Part 5: VM / CMS - 2001. </font></font><a href="http://www.snee.com/bob/opsys/part5vmcms.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.snee.com/bob/opsys/part5vmcms.pdf</font></font></a> </li></ol><br><br></div><p>Source: <a href="https://habr.com/ru/post/254793/">https://habr.com/ru/post/254793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254781/index.html">Introduction to the capabilities of the Realtek RTL 8332M switch processor</a></li>
<li><a href="../254785/index.html">We need instant messengers. More messengers</a></li>
<li><a href="../254787/index.html">Perl 6: nextsame and its relatives</a></li>
<li><a href="../254789/index.html">Translation of hours in Russia, again ... and php5-intl</a></li>
<li><a href="../254791/index.html">Aspect-oriented programming. The basics</a></li>
<li><a href="../254795/index.html">Worst API ever created</a></li>
<li><a href="../254797/index.html">The taste and color or coloring for Android</a></li>
<li><a href="../254799/index.html">Development of MMO RPG - a practical guide. Episode 1</a></li>
<li><a href="../254801/index.html">Android Volley custom Loader</a></li>
<li><a href="../254803/index.html">About interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>