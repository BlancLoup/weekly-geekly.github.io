<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of your PE packer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will talk about the development of its own packer of executable files under Windows in C ++. 



 A long time ago, when Windows XP was not th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of your PE packer</h1><div class="post__text post__text-html js-mediator-article">  Today we will talk about the development of its own packer of executable files under Windows in C ++. <br><img src="https://habrastorage.org/storage2/a3a/e06/599/a3ae0659911d79794c2aca64c31168d6.gif"><br><a name="habracut"></a><br><br>  A long time ago, when Windows XP was not there yet, in search of information about packers, we climbed into the wilds of the source code of the then young UPX.  But either acetylcholine in our brains was synthesized less than what was needed, or UPX was already very boring at that time - well, in general, we didn‚Äôt extract anything from those samples.  Matt Pitrek, and he helped more.  Now with info much easier.  Almost everything is there.  Even a completely normal bank banking can be downloaded ( <a href="http://bit.ly/v3EiYP">Zeus 2.0.8.9</a> ).  Yes, what is already there, Windows for a long time in public ( <a href="http://bit.ly/rBZlCy">Windows 2000</a> ). <br>  There is information about packers, too, but mostly research, directly related to the development from the wrong side from which we would like.  An excellent example of this is the article <a href="http://bit.ly/vRPCxZ">‚ÄúAbout Packers for the Last Time‚Äù</a> <a href="http://bit.ly/tSUxT7">in two parts</a> , written by well-known gurus Volodya and NEOx. <br>  We, in turn, will try to give the most specific and consistent information about the development of the simplest but easily modified PE packer. <br><br><h4>  Algorithm </h4><br>  Here we have, for example, notepad.exe.  In its usual 32-bit form, it weighs about 60 KB.  We want to significantly reduce it, while retaining all its functionality.  What should be our actions?  Well, for starters, we will read our file from the first to the last baytik in the array.  Now we can do anything with it.  And we like to squeeze it.  We take it and give it to some simple compressor, as a result of which we get an array not in 60 Kb, but, for example, in 20 Kb.  This is cool, but in a compressed form, the image of our ‚ÄúNotepad‚Äù is just a set of bytes with high entropy, it is not an executable, and it cannot be launched by writing to a file and clicking.  For an array with a compressed image, we need a medium (boot loader), a very small executable file to which we attach our array and which will release it and run it.  We write the media, compile, and then append to our end our compressed Notepad.  Accordingly, if the file obtained as a result of all actions (the size of which is slightly larger than that of just a compressed Notepad) is launched, it will find a packed image in itself, unpack it, parse its structure and launch it. <br>  As you can see, we have to automate a not too complicated process.  You just need to write two programs, a loader and, in fact, a packer. <br>  The algorithm of the packer: <ul><li>  read PE file into an array; </li><li>  compress the array with some kind of lossless compression algorithm; </li><li>  in accordance with the PE format, add a compressed array to the template loader. </li></ul>  Loader operation algorithm: <ul><li>  find at the end of an array with a compressed PE file; </li><li>  unclench it; </li><li>  parse the headers of the PE file, arrange all rights, allocate memory and eventually start. </li></ul>  We will start the development from the loader, since it is they who will later be manipulated by the packer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Loader </h4><br>  So, the first thing that our loader has to do is to find in its body the address of the array with the compressed image of the PE file.  The search methods depend on how the packer implanted this array into the loader. <br>  For example, if he simply added a new data section, the search would look like this: <br><br><h6>  Search for a compressed image in the last section </h6><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    PE-    HMODULE hModule = GetModuleHandle(NULL); PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNTHeaders = MakePtr(PIMAGE_NT_HEADERS,hModule,pDosHeader-&gt;e_lfanew); PIMAGE_SECTION_HEADER pSections = IMAGE_FIRST_SECTION(pNTHeaders); // ,      PIMAGE_SECTION_HEADER pLastSection = &amp;pSections[pNTHeaders-&gt;FileHeader.NumberOfSections - 1]; // ,   LPBYTE pbPackedImage = MakePtr(LPBYTE, hModule, pLastSection-&gt;VirtualAddress); //   DWORD dwPackedImageSize = pLastSection-&gt;SizeOfRawData;</span></span></code> </pre> <br>  But, in our opinion, this code in the loader can be sacrificed.  In general, everything that a packer can do, even if it does.  The address of the image in the address space of the loader can be calculated in advance when packing, and then just enter in the right place.  For this, we leave two tags in our program: <br><br><pre> <code class="cpp hljs">LPBYTE pbPackedImage = (LPBYTE) <span class="hljs-number"><span class="hljs-number">0xDEADBEEF</span></span>; DWORD dwPackedImageSize = <span class="hljs-number"><span class="hljs-number">0xBEEFCACE</span></span>;</code> </pre> <br>  When the packer implants the array in a compressed manner into the loader, it will go through a signature search through the loader body and replace 0xDEADBEEF with the array address, and 0xBEEFCACE with its size. <br><br>  Now that we have decided how to search for an address, we can choose a ready-made implementation of the compression algorithm for use in our packer. <br>  A good option is to use <a href="http://www.ibsensoftware.com/">aplib</a> , a small library with a neat and very compact code that implements compression based on the Lempel-Ziv algorithm (LZ).  And we would definitely choose it on any other day, but today we have the mood for an even simpler and more compact solution - the built-in Windows functions! <br><br>  Since XP, our favorite ntdll.dll has started exporting two great features: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlCompressBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __in USHORT CompressionFormatAndEngine, __in PUCHAR UncompressedBuffer, __in ULONG UncompressedBufferSize, __out PUCHAR CompressedBuffer, __in ULONG CompressedBufferSize, __in ULONG UncompressedChunkSize, __out PULONG FinalCompressedSize, __in PVOID WorkSpace )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlDecompressBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __in USHORT CompressionFormat, __out PUCHAR UncompressedBuffer, __in ULONG UncompressedBufferSize, __in PUCHAR CompressedBuffer, __in ULONG CompressedBufferSize, __out PULONG FinalUncompressedSize )</span></span></span></span>;</code> </pre> <br>  Their names speak for themselves - one function for compression, the other for decompression.  Of course, if we were developing a really serious product, we would not touch these functions, as there were still computers with Windows 2000, and even with NT 4.0,;) but for our modest goals, RtlCompressBuffer \ RtlDecompressBuffer is fine. <br>  There are no these functions in the Platform SDK headers, we cannot statically link them, so we have to use GetProcAddress: <br><br><h6>  Determining the address of the function to unpack </h6><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   RtlDecompressBuffer      DWORD (__stdcall *RtlDecompressBuffer)(ULONG,PVOID,ULONG,PVOID,ULONG,PULONG); //    RtlDecompressBuffer  ntdll.dll (FARPROC&amp;)RtlDecompressBuffer = GetProcAddress(LoadLibrary("ntdll.dll"), "RtlDecompressBuffer" );</span></span></code> </pre> <br>  When you have something to unpack and have something to unpack, you can finally do it.  To do this, we will allocate memory with a margin (since we do not know the volume of the unpacked file) and run the function defined above: <br><br><pre> <code class="cpp hljs">DWORD dwImageSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; DWORD dwImageTempSize = dwPackedImageSize * <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      LPVOID pbImage = VirtualAlloc( NULL, dwImageTempSize, MEM_COMMIT, PAGE_READWRITE ); //  RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, pbImage, dwImageTempSize, pbPackedImage, dwPackedImageSize, &amp;dwImageSize);</span></span></code> </pre> <br>  The parameter COMPRESSION_FORMAT_LZNT1 means that we want to use classic LZ compression.  The function is able to compress with <a href="http://bit.ly/sV9SVu">other algorithms</a> , but this is enough for us. <br>  Now we have in memory (pbImage) a raw image of a PE file.  To run it, you need to carry out a series of manipulations, which are usually done by native Windows PE-loader.  We will reduce the list to the most-needed: <ol><li>  Place the beginning of the image (heders) to the address specified in the Image Base field of the optional header (OPTIONAL_HEADER). </li><li>  Place the sections of the PE file to the addresses specified in the table of sections. </li><li>  Parse the import table, find all the addresses of the functions and enter them in the corresponding cells. </li></ol>  Naturally, the standard PE loader performs a whole bunch of other actions, and by the fact that we brush them off, we limit the compatibility of our packer with some PE files.  But for the absolute majority, these actions will be enough - it is possible not to fix relocs, fixes, and other rare and nasty garbage. <br>  If suddenly you want serious compatibility, you either write a cool PE loader yourself, or find the most complete implementation on the Web - we were too lazy to write our own, and we took advantage of the <a href="http://bit.ly/tc65cB">gr8 works</a> from hellknights, throwing out everything that we didn't understand.  ;) Even in a reduced form, the function of the PE-loader is a hundred lines, no less, so here we will only give its prototype (the full code is on the disk): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HMODULE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadExecutable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPBYTE image, DWORD* AddressOfEntryPoint)</span></span></span></span></code> </pre> <br>  It takes a pointer to our unpacked image and returns the handle of the loaded module (equivalent to the address to which the PE file is loaded) and the address of the entry point (according to the pointer AddressOfEntryPoint).  This function does everything to correctly place the image in memory, but not everything, so that you can finally transfer control to it. <br>  The fact is that the system still does not know anything about the module loaded by us.  If we call the entry point right now, from which the compressed program starts execution, there may be a number of problems.  The program will work, but crooked. <br>  For example, GetModuleHandle (NULL) will return the Image Base of the loader module, rather than the unpacked program.  The FindResource and LoadResource functions will rummage through our bootloader, in which there are no resources at all.  There may be more specific glitches.  To prevent this from happening, you need to update the information in the system structures of the process whenever possible, replacing the addresses of the loader module with the addresses of the loaded module. <br>  First of all, you need to fix the PEB (Process Enviroment Block), in which the old Image Base is specified.  The PEB address is very easy to get; in the user interface, it is always at the offset 0x30 in the FS segment. <br><br><pre> <code class="cpp hljs">PPEB Peb; __asm { push eax mov eax, FS:[<span class="hljs-number"><span class="hljs-number">0x30</span></span>]; mov Peb, eax pop eax } <span class="hljs-comment"><span class="hljs-comment">// hModule ‚Äî      PE- Peb-&gt;ImageBaseAddress = hModule;</span></span></code> </pre> <br>  It also does not hurt to fix the module lists in the LDR_DATA structure referenced by PEB.  In total there are three lists: <ul><li>  InLoadOrderModuleList - a list of modules in boot order; </li><li>  InMemoryOrderModuleList - a list of modules in order of their location in memory; </li><li>  InInitializationOrderModuleList - a list of modules in order of initialization. </li></ul>  We need to find in each list the address of our bootloader and replace it with the address of the loaded module.  Somehow: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,   //       PLDR_DATA_TABLE_ENTRY pLdrEntry = (PLDR_DATA_TABLE_ENTRY)(Peb-&gt;Ldr-&gt;ModuleListLoadOrder.Flink); pLdrEntry-&gt;DllBase = hModule; ...</span></span></code> </pre> <br>  Now you can safely call the entry point of the loaded module.  It will function as if it were called in the most usual way. <br><br><pre> <code class="cpp hljs">LPVOID entry = (LPVOID)( (DWORD)hModule + AddressOfEntryPoint ); __asm call entry;</code> </pre> <br>  AddressOfEntryPoint is a relative virtual address (RVA, Relative Virtual Address) of the entry point taken from the optional header in the LoadExecutable function.  To get the absolute address, we simply added the address of the base (that is, the newly loaded module) to the RVA. <br><br><h4>  Reducing the size of the bootloader </h4><br>  If our bootloader is compiled and compiled in VS 2010 with default flags, then we will get not a two-kilobyte utility program, but a monster of more than 10 Kb in size.  The studio will build there a whole bunch of superfluous, but we need to get it all out. <br>  Therefore, in the compilation properties of the project loader (tab C / C ++) we do the following: <ul><li>  In the "Optimization" section, select "Minimum Size (/ O1)" so that the compiler tries to make all functions more compact. </li><li>  In the same place, we indicate the priority of size over speed (flag / Os). </li><li>  In the "Code Generation" section we turn off C ++ exceptions, we do not use them. </li><li>  We also do not need to check the buffer overflow (/ GS-).  This is a good thing, but not in our case. </li></ul>  In the properties of the linker (linker): <ul><li>  Turning off to hell "Manifest."  It is big, and because of it, a .rsrc section is created in the loader, which we absolutely do not need.  In general, each extra section in a PE file is at least 512 completely unnecessary bytes, thanks to the alignment. </li><li>  Disable the creation of debug information. </li><li>  We climb in the tab "Advanced".  Turn off the "Inclusion of randomness in the base address" (/ DYNAMICBASE: NO), otherwise the linker will create a relocation section (.reloc). </li><li>  Specify the base address.  Choose some non-standard higher, for example 0x02000000.  This value will be returned by GetModuleHandle (NULL) in the loader.  You can even zakardkodit. </li><li>  We specify our entry point, but not the CRT shny: / ENTRY: WinMain.  In general, we are accustomed to do this with the pragma directive directly from the code, but since we‚Äôve gotten into properties, it‚Äôs possible here. </li></ul>  The remaining settings for the linker are set directly from the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(linker,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/MERGE:.rdata=.text"</span></span></span><span class="hljs-meta">)</span></span></code> </pre> <br>  Here we have combined the .rdata section, which contains read-only data (rows, import table, etc.) with the .text code section.  If we used global variables, we would also need to combine the .data section with the code. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(linker,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/MERGE:.data=.text"</span></span></span><span class="hljs-meta">) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    .data    , //        #pragma comment(linker,"/SECTION:.text,EWR")</span></span></span></span></code> </pre> <br>  All of the above is enough to get a loader size of 1.5 KB. <br><br><h4>  Packer </h4><br>  It remains for us to develop a console utility that will compress the files given to it and attach it to the loader.  The first thing that it should do according to the algorithm described at the beginning of the article is to read the file into an array.  The task with which the student will cope: <br><br><pre> <code class="cpp hljs">HANDLE hFile = CreateFile(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], GENERIC_READ,FILE_SHARE_READ, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); DWORD dwImageSize = GetFileSize(hFile, <span class="hljs-number"><span class="hljs-number">0</span></span>); LPBYTE lpImage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE[dwImageSize], lpCompressedImage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE[dwImageSize]; DWORD dwReaded; ReadFile(hFile, lpImage, dwImageSize, &amp;dwReaded, <span class="hljs-number"><span class="hljs-number">0</span></span>); CloseHandle(hFile);</code> </pre> <br>  Next, our packer must compress the resulting file.  We will not check if this is really a PE file, if its headers are correct, and so on. We leave everything on the user's conscience, immediately compress it.  To do this, we use the RtlCompressBuffer and RtlGetCompressionWorkSpaceSize functions.  We have already described the first one ‚Äî it compresses the buffer, while the second is needed to calculate the amount of memory needed for the compressing engine to work.  We assume that we have already dynamically connected both functions (as in the bootloader), all that remains is to run them: <br><br><pre> <code class="cpp hljs">DWORD format = COMPRESSION_FORMAT_LZNT1|COMPRESSION_ENGINE_STANDARD; DWORD dwCompressedSize, dwBufferWsSize, dwFragmentWsSize; RtlGetCompressionWorkSpaceSize(format, &amp;dwBufferWsSize, &amp;dwFragmentWsSize); LPBYTE workspace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BYTE [dwBufferWsSize]; RtlCompressBuffer(format , <span class="hljs-comment"><span class="hljs-comment">//     lpImage, //    dwImageSize, //   lpCompressedImage, //    dwImageSize, //   4096, //  ,   &amp;dwCompressedSize, //       workspace); //   </span></span></code> </pre> <br>  As a result, we have a compressed buffer and its size, you can screw them to the loader.  To do this, you first need to embed the compiled code of our loader into the packer.  The most convenient way to put it into a program is to use the <a href="http://www.deadnode.org/sw/bin2h/">bin2h</a> utility.  It will envelope any binary into a convenient shared header, all the data in it will look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loader_size=<span class="hljs-number"><span class="hljs-number">1536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> loader[] = { <span class="hljs-number"><span class="hljs-number">0x4d</span></span>,<span class="hljs-number"><span class="hljs-number">0x5a</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x01</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>,<span class="hljs-number"><span class="hljs-number">0x00</span></span>, ...</code> </pre> <br><img src="https://habrastorage.org/storage2/42e/505/c8e/42e505c8ea6a3d9e8783f634661129c7.png"><br><h6>  Creating a header with bin2h can be automated </h6><br>  We feed her a file with our loader and get everything you need for further distortions.  Now, if we follow the algorithm described at the beginning of the article, we must attach a compressed image to the loader.  Here we will have to remember the 90s and our vir-maker past;).  The fact is that embedding data or code into a third-party PE file is a purely viral topic.  The introduction is organized in a large number of different ways, but the most trivial and popular is the expansion of the last section or the addition of its own.  Adding, in our opinion, is fraught with losses during alignment, therefore, in order to embed a compressed image into our bootloader, we will expand to it (the bootloader) the last section.  Rather, the only section - we got rid of all the excess.  ;) <br>  The action algorithm will be as follows: <ul><li>  We find the only section (.text) in the loader. </li><li>  Change its physical size, that is, the size of the disk (SizeOfRawData).  It should be equal to the sum of the old size and the size of the compressed image and at the same time it is aligned in accordance with the file alignment (FileAlignment). </li><li>  We change the virtual size of the memory (Misc.VirtualSize) by adding to it the size of the compressed image. </li><li>  We change the size of the entire boot image (OptionalHeader.SizeOfImage) using the ancient formula [virtual size of the last section] + [virtual address of the last section], not forgetting to align the value using FileAlignment. </li><li>  Copy the compressed image to the end of the section. </li></ul>  There is a little trick.  The fact is that our studio makes the virtual size (Misc.VirtualSize) of the section with the code (.text) equal to the real unaligned size of the code, that is, it indicates the size is smaller than the physical one.  So, there is a chance to save up to 511 bytes. <br>  That is, so we would write the data after the heap of alignment zeros, and knowing the chip, you can write over these zeros. <br>  Here is how all our thoughts will look like in code: <br><br><h6>  Extension code section </h6><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          PBYTE pbLoaderCopy = new BYTE[simple_packer_size + dwCompressedSize + 0x1000]; memcpy(pbLoaderCopy, (LPBYTE)&amp;simple_packer, simple_packer_size); //    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)pbLoaderCopy; PIMAGE_NT_HEADERS nt = MakePtr(PIMAGE_NT_HEADERS, pbLoaderCopy, dos-&gt;e_lfanew); //   PIMAGE_SECTION_HEADER text = IMAGE_FIRST_SECTION(nt); //         memcpy(&amp;pbLoaderCopy[text-&gt;PointerToRawData + text-&gt;Misc.VirtualSize], lpCompressedImage, dwCompressedSize); //   ,    Misc.VirtualSize text-&gt;SizeOfRawData = ALIGN(text-&gt;Misc.VirtualSize + dwCompressedSize, nt-&gt;OptionalHeader.FileAlignment); //   (    )  text-&gt;Misc.VirtualSize += dwCompressedSize; //    nt-&gt;OptionalHeader.SizeOfImage = ALIGN(test-&gt;Misc.VirtualSize + test-&gt;VirtualAddress, nt-&gt;OptionalHeader.FileAlignment); //     DWORD dwNewFileSize = pSections-&gt;SizeOfRawData + test-&gt;PointerToRawData;</span></span></code> </pre> <br>  Oh, we almost forgot to replace the tags 0xDEADBEEF and 0xBEEFCACE left in the loader with real values!  0xBEEFCACE is changed to the size of the compressed image, and 0xDEADBEEF to its absolute address.  The image address is calculated by the formula [image address] + [virtual section address] + [image offset relative to the section start].  It should be noted that the replacement must be made before updating the value of Misc.VirtualSize, otherwise the resulting file will not work. <br>  Search and replace tags using a very simple loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; simple_packer_size; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(DWORD*)(&amp;pbLoaderCopy[i]) == <span class="hljs-number"><span class="hljs-number">0xBEEFCACE</span></span>) *(DWORD*)(&amp;pbLoaderCopy[i]) = dwCompressedSize; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(DWORD*)(&amp;pbLoaderCopy[i]) == <span class="hljs-number"><span class="hljs-number">0xDEADBEEF</span></span>) *(DWORD*)(&amp;pbLoaderCopy[i]) = nt-&gt;OptionalHeader.ImageBase + text-&gt;VirtualAddress + text-&gt;Misc.VirtualSize;</code> </pre> <br>  That's all.  Now we have a packed and ready-to-use file in memory, just save it to disk using the CreateFile / WriteFile functions. <br><br><img src="https://habrastorage.org/storage2/f07/790/911/f077909114b57adef236f409770decd9.png"><h6>  The process of debugging a huge file in OllyDbg </h6><br><h4>  findings </h4><br>  If we compare the compression efficiency of our packer with UPX using notepad.exe as an example - we win about 1 Kb: 46,592 bytes with us against 48,128 for UPX.  However, our packer is far from perfect.  And it is very noticeable. <br>  The fact is that we deliberately ignored such an important thing as the transfer of resources.  The resulting file will lose the icon!  You have to implement the missing function yourself.  Thanks to the knowledge obtained from this material, you will not have any difficulties with this business. <br><br>  <a href="http://www.sendspace.com/file/6cnesv">Source for the article</a> . <br><br><img src="https://habrastorage.org/storage2/5cb/393/28d/5cb39328d4a6a290c7bcd4585a3336c6.png"><h6>  Our packager squeezed notepad.exe stronger than UPX! </h6><br><hr><br><h4>  Remake cryptor </h4><br>  Actually, our package differs very little from cryptor: the lack of an encryption function and anti-emulation techniques.  The simplest thing you can do on the fly is to add the xor of the entire image immediately after unpacking in the bootloader.  But for antivirus emulators to choke, that's not enough.  It is necessary to somehow complicate the task.  For example, do not prescribe the xor key in the body of the loader.  That is, the loader will not know what key he needs to decrypt the code, he will go through it in the framework defined by us.  This may take some time that the user has, in contrast to the antivirus. <br>  Also, the key can be made dependent on some non-emulated function or structure.  Only they still need to be found. <br>  So that the bootloader code does not burn signature, you can attach any advanced virus engines to the packer to generate garbage and to modify the code in every way, the benefit of which is in bulk in the Web. <br><br><hr><br>  After executing the LoadExecutable function in the loader, it would be nice to free the memory allocated for unpacking - it will not be useful to us anymore. <br><br><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/b3b/6d8/10b/b3b6d810b4bae016876c6e0133b2b878.jpg" alt="image"><br>  <i>Journal Hacker, <a href="http://www.xakep.ru/articles/magazine/default.asp">February (02) 157</a></i> <i><br></i>  <i>Peter and the Wolf</i> . <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">1 999 .</a>  <a href="http://bit.ly/habr_subscribe_paper">for 12 numbers of paper version</a> </li><li>  <a href="http://bit.ly/digital_xakep">1249r.</a>  <a href="http://bit.ly/digital_xakep">for an annual subscription to iOS / iPad (Android'a release soon!)</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul><br><br> <a href="http://bit.ly/xakep_on_ipad"><img src="https://habrastorage.org/storage2/a86/fc6/a22/a86fc6a22179b180d53a36f9cb5a7d3f.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/139138/">https://habr.com/ru/post/139138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139118/index.html">How to protect yourself when buying expensive goods on Ebay</a></li>
<li><a href="../139129/index.html">Introduction to the theory of interacting sequential processes (CSP), part 2</a></li>
<li><a href="../139132/index.html">Python-interface between the computer and the physical world</a></li>
<li><a href="../139133/index.html">The main shock of the exhibition MWC 2012: 41 megapixel smartphone Nokia 808 on Symbian</a></li>
<li><a href="../139136/index.html">Where in Russia from bachelor to quality pump to the IT-master?</a></li>
<li><a href="../139141/index.html">Adobe AIR 3.2 with mobile platform support for Stage3d</a></li>
<li><a href="../139142/index.html">MegaFon data center tour</a></li>
<li><a href="../139143/index.html">Game Survivor (Commodore 64) on html, css and javascript</a></li>
<li><a href="../139146/index.html">We develop iOS application on flash</a></li>
<li><a href="../139150/index.html">Three devices in one - look at Asus PadFone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>