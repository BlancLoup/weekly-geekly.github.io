<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Setting up a server to deploy a Rails application using Ansible</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago I had to write several ansible playbooks to prepare the server for the deployment of rails application. And, surprisingly, I did not f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Setting up a server to deploy a Rails application using Ansible</h1><div class="post__text post__text-html js-mediator-article"><p>  Not so long ago I had to write several ansible playbooks to prepare the server for the deployment of rails application.  And, surprisingly, I did not find a simple step by step manual.  I didn‚Äôt want to copy someone else‚Äôs playbook without understanding what was happening, and eventually I had to read the documentation, collecting everything myself.  Perhaps someone I can help speed up this process with the help of this article. </p><br><p>  The first step is to understand that ansible provides you with a convenient interface for performing a predefined list of actions on a remote server (s) via SSH.  There is no magic here, you can‚Äôt install a plugin and get your application with docker, monitoring and other stuff out of the box.  In order to write a playbook you need to know what exactly you want to do and how to do it.  Therefore, I am not satisfied with ready-made playbooks from a github, or articles like: ‚ÄúCopy and run, will work‚Äù. </p><a name="habracut"></a><br><h2 id="chto-nam-nuzhno">  What do we need? </h2><br><p>  As I said, in order to write a playbook you need to know what you want to do and how to do it.  Let's define what we need.  For Rails applications, we will need several system packages: nginx, postgresql (redis, etc).  In addition, we need a certain version of ruby.  It is best to install it via rbenv (rvm, asdf ...).  Running it all as a root user is always a bad idea, so you need to create a separate user and set up permissions for it.  After this, you need to upload our code to the server, copy the configs for nginx, postgres, etc and run all these services. </p><br><p>  <strong>As a result, the sequence of actions is as follows:</strong> </p><br><ol><li>  Login as root </li><li>  install system packages </li><li>  create a new user, set up permissions, ssh key </li><li>  configure system packages (nginx etc) and run them </li><li>  Create a user in the database (you can immediately create a database) </li><li>  Login as a new user </li><li>  Install rbenv and ruby </li><li>  Installing a Bandler </li><li>  Fill the application code </li><li>  We start Puma server </li></ol><br><p>  Moreover, the last stages can be done with the help of capistrano, at least she is able to copy the code into the release directories from the box, switch the release with a symlink if successful, copy configs from the shared directory, restart puma, etc.  All this can be done with Ansible, but why? </p><br><h2 id="faylovaya-struktura">  File structure </h2><br><p>  Ansible has a strict <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html">file structure</a> for all its files, so it‚Äôs best to keep it all in a separate directory.  And it is not so important whether it will be in the rails application itself, or separately.  You can store files in a separate git repository.  Personally, it was most convenient for me to create the ansible directory in the / config directory of the rails application and store everything in one repository. </p><br><h3 id="simple-playbook">  Simple playbook </h3><br><p>  A playbook is a yml file in which, using a special syntax, it is described what should be done by ansible.  Let's create the first playbook that does nothing: </p><br><pre><code class="plaintext hljs">--- - name: Simple playbook hosts: all</code> </pre> <br><p>  Here we simply say that our playbook is called <code>Simple Playbook</code> and that its content must be performed for all hosts.  We can save it in the / ansible directory with the name <code>playbook.yml</code> and try to run: </p><br><pre> <code class="plaintext hljs">ansible-playbook ./playbook.yml PLAY [Simple Playbook] ************************************************************************************************************************************ skipping: no hosts matched</code> </pre> <br><p>  Ansible says that it does not know the hosts that would match the all list.  They must be listed in a special <a href="https://docs.ansible.com/ansible/2.3/intro_inventory.html">inventory file</a> . </p><br><p>  Let's create it in the same ansible directory: </p><br><pre> <code class="plaintext hljs">123.123.123.123</code> </pre> <br><p>  So just specify the host (ideally, the host of your VPS for tests, or you can register localhost) and save it under the name of <code>inventory</code> . <br>  You can try to run ansible with the invetory file: </p><br><pre> <code class="plaintext hljs">ansible-playbook ./playbook.yml -i inventory PLAY [Simple Playbook] ************************************************************************************************************************************ TASK [Gathering Facts] ************************************************************************************************************************************ PLAY RECAP ************************************************************************************************************************************</code> </pre> <br><p>  If you have ssh access to the specified host, then ansible will connect and collect information about the remote system.  (default TASK [Gathering Facts]) then gives a brief report on the implementation (PLAY RECAP). </p><br><p>  By default, the connection uses the username under which you are logged in to the system.  On the host it probably will not.  In the playbook file, you can specify which user to connect to using the remote_user directive.  Also, information about a remote system can often be unnecessary and you should not waste time collecting it.  This task can also be turned off: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root become: true gather_facts: no</code> </pre> <br><p>  Try running the playbook again and make sure the connection is working.  (If you specified the root user, then you also need to specify the become: true directive to get elevated rights. As written in the documentation: <code>become set to 'true'/'yes' to activate privilege escalation.</code> although it is not entirely clear why) . </p><br><p>  Perhaps you will get an error caused by the fact that the ansible cannot determine the python interpreter, then you can specify it manually: </p><br><pre> <code class="plaintext hljs">ansible_python_interpreter: /usr/bin/python3</code> </pre> <br><p>  where you have python can be found with the <code>whereis python</code> command. </p><br><h3 id="ustanovka-sistemnyh-paketov">  Installing system packages </h3><br><p>  The standard Ansible package includes many modules for working with various system packages, so we don‚Äôt have to write bash scripts for any reason.  Now we need one of these modules to upgrade the system and install system packages.  I have Ubuntu Linux on my VPS, respectively, to install packages, I use <code>apt-get</code> and a <a href="https://docs.ansible.com/ansible/latest/modules/apt_module.html">module for it</a> .  If you use another operating system, you may need another module (remember, I said at the beginning that you need to know in advance what we will do and how).  However, the syntax is likely to be similar. </p><br><p>  Let's complete our playbook with the first tasks: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root become: true gather_facts: no tasks: - name: Update system apt: update_cache=yes - name: Install system dependencies apt: name: git,nginx,redis,postgresql,postgresql-contrib state: present</code> </pre> <br><p>  Task - this is just the task that ansible will perform on remote servers.  We give the task a name to track its execution in the log.  And we describe, using the syntax of a specific module, what it needs to do.  In this case, <code>apt: update_cache=yes</code> - says update system packages using the apt module.  The second team is somewhat more complicated.  We pass a list of packages to the apt module, and say that their <code>state</code> should become <code>present</code> , that is, we say to install these packages.  Similarly, we can tell them to remove, or update, simply by changing the <code>state</code> .  Please note that in order for rails to work with postgresql, we need the postgresql-contrib package, which we are installing now.  On this again, one must know and do, ansible in itself will not do this. </p><br><p>  Try running the playbook again and check that the packages are installed. </p><br><h3 id="sozdanie-novyh-polzovateley">  Create new users. </h3><br><p>  Ansible also has a user module for working with users.  Add one more task (I hid the already known parts of the playbook for comments, so as not to copy it entirely each time): </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Add a new user user: name: my_user shell: /bin/bash password: "{{ 123qweasd | password_hash('sha512') }}"</code> </pre> <br><p>  We create a new user, set a schell and password for it.  And then we face several problems.  What if user names have to be different for different hosts?  Yes, and store the password in clear form in the playbook is a very bad idea.  To begin with, we will put the username and password into variables, and towards the end of the article I will show how to encrypt the password. </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}"</code> </pre> <br><p>  using double curly braces in playbooks variables are set. </p><br><p>  The values ‚Äã‚Äãof the variables we specify in the inventory file: </p><br><pre> <code class="plaintext hljs">123.123.123.123 [all:vars] user=my_user user_password=123qweasd</code> </pre> <br><p>  Pay attention to the directive <code>[all:vars]</code> - it says that the next block of text is variables (vars) and they apply to all hosts (all). </p><br><p>  Also interesting is the construction <code>"{{ user_password | password_hash('sha512') }}"</code> .  The fact is that ansible does not establish the user through <code>user_add</code> as you would do it manually.  And it saves all the data directly, which is why we must also convert the password into a hash in advance, which is what this command does. </p><br><p>  Let's add our user to the sudo group.  However, before this you need to make sure that such a group exists because nobody will do this for us: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo"</code> </pre> <br><p>  Everything is quite simple, we also have a group module for creating groups, with a syntax very similar to apt.  After that, it is enough to register this group to the user ( <code>groups: "sudo"</code> ). <br>  It is also useful to add this ssh user a key so that we can log in under it without a password: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo" - name: Deploy SSH Key authorized_key: user: "{{ user }}" key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}" state: present</code> </pre> <br><p>  In this case, the interesting construction is <code>"{{ lookup('file', '~/.ssh/id_rsa.pub') }}"</code> - it copies the contents of the file id_rsa.pub (you may have a different name), that is, the public part of the ssh key and loads it into the list of authorized keys for the user on the server. </p><br><h3 id="roli">  Roles </h3><br><p>  All three tasks for creation can be easily attributed to one group of tasks, and it would be nice to keep this group separate from the main playbook so that it would not grow too much.  For this, there are <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html">roles</a> in ansible. <br>  According to the file structure specified at the very beginning, the role must be put in a separate roles directory, for each role - a separate directory with the same name, inside the tasks, files, templates, etc directory <br>  Create the file structure: <code>./ansible/roles/user/tasks/main.yml</code> (main is the main file that will be loaded and executed when the role is connected to the playbook, it is possible to include other role files in it).  Now you can transfer to this file all tasks related to the user: </p><br><pre> <code class="plaintext hljs"># Create user and add him to groups - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo" - name: Deploy SSH Key authorized_key: user: "{{ user }}" key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}" state: present</code> </pre> <br><p>  Basically, the playbook needs to specify the use of the user role: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root gather_facts: no tasks: - name: Update system apt: update_cache=yes - name: Install system dependencies apt: name: git,nginx,redis,postgresql,postgresql-contrib state: present roles: - user</code> </pre> <br><p>  It also probably makes sense to perform a system update before all other tasks, for this you can rename the <code>tasks</code> block in which they are defined in <code>pre_tasks</code> . </p><br><h3 id="nastroyka-nginx">  Nginx configuration </h3><br><p>  Nginx should be already installed, you need to configure and run it.  Let's do it right away in the role.  Create a file structure: </p><br><pre> <code class="plaintext hljs">- ansible - roles - nginx - files - tasks - main.yml - templates</code> </pre> <br><p>  Now we need files and templates.  The difference between them is that the files are ansible to copy directly as is.  And the templates must have the extension j2 and in them you can use the values ‚Äã‚Äãof variables using the same double curly braces. </p><br><p>  Let's include nginx in the <code>main.yml</code> file.  To do this, we have a systemd module: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes</code> </pre> <br><p>  Here we not only say that nginx should be started (ie, run it), but we immediately say that it should be enabled. <br>  Now copy the configuration files: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes - name: Copy the nginx.conf copy: src: nginx.conf dest: /etc/nginx/nginx.conf owner: root group: root mode: '0644' backup: yes - name: Copy template my_app.conf template: src: my_app_conf.j2 dest: /etc/nginx/sites-available/my_app.conf owner: root group: root mode: '0644'</code> </pre> <br><p>  We create the main nginx configuration file (you can take it directly from the server, or write it yourself).  And also the configuration file for our application in the sites_available directory (this is not necessarily but useful).  In the first case, we use the copy module to copy files (the file must be in <code>/ansible/roles/nginx/files/nginx.conf</code> ).  In the second, we copy the template, substituting the values ‚Äã‚Äãof the variables.  The template should be in <code>/ansible/roles/nginx/templates/my_app.j2</code> ).  And it can look something like this: </p><br><pre> <code class="plaintext hljs">upstream {{ app_name }} { server unix:{{ app_path }}/shared/tmp/sockets/puma.sock; } server { listen 80; server_name {{ server_name }} {{ inventory_hostname }}; root {{ app_path }}/current/public; try_files $uri/index.html $uri.html $uri @{{ app_name }}; .... }</code> </pre> <br><p>  Pay attention to the inserts <code>{{ app_name }}</code> , <code>{{ app_path }}</code> , <code>{{ server_name }}</code> , <code>{{ inventory_hostname }}</code> - these are all variables, the values ‚Äã‚Äãof which ansible will insert into the template before copying.  This is useful if you use a playbook for different groups of hosts.  For example, we can supplement our inventory file: </p><br><pre> <code class="plaintext hljs">[production] 123.123.123.123 [staging] 231.231.231.231 [all:vars] user=my_user user_password=123qweasd [production:vars] server_name=production app_path=/home/www/my_app app_name=my_app [staging:vars] server_name=staging app_path=/home/www/my_stage app_name=my_stage_app</code> </pre> <br><p>  If we start our playbook now, it will perform the specified tasks for both hosts.  But at the same time for staging the host variables will be different from production, and not only in roles and playbooks, but also in the nginx configs.  <code>{{ inventory_hostname }}</code> not necessary to specify in the inventory file - this is a <a href="https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html">special variable ansible</a> and the host for which the playbook is currently running is stored there. <br>  If you want to have an inventory file for several hosts, and run only for one group, you can do this with the following command: </p><br><pre> <code class="plaintext hljs">ansible-playbook -i inventory ./playbook.yml -l "staging"</code> </pre> <br><p>  Another option is to have separate inventory files for different groups.  Or you can combine the two approaches, if you have many different hosts. </p><br><p>  Let's return to the nginx setup.  After copying the configuration files, we need to create a symlink in sitest_enabled on my_app.conf from sites_available.  And restart nginx. </p><br><pre> <code class="plaintext hljs">... # old code in mail.yml - name: Create symlink to sites-enabled file: src: /etc/nginx/sites-available/my_app.conf dest: /etc/nginx/sites-enabled/my_app.conf state: link - name: restart nginx service: name: nginx state: restarted</code> </pre> <br><p>  Everything is simple - again, modules are ansible with a fairly standard syntax.  But there is one moment.  Restarting nginx every time does not make sense.  You noticed that we do not write commands like: ‚Äúto do this like this‚Äù, the syntax looks more like ‚Äúthis should have this state‚Äù.  And most often this is exactly what ansible works.  If the group already exists, or the system package is already installed, then ansible will check it and skip the task.  The same files will not be copied if they completely coincide with what is already on the server.  We can take advantage of this and restart nginx only if the configuration files have been changed.  There is a register directive for this: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes - name: Copy the nginx.conf copy: src: nginx.conf dest: /etc/nginx/nginx.conf owner: root group: root mode: '0644' backup: yes register: restart_nginx - name: Copy template my_app.conf template: src: my_app_conf.j2 dest: /etc/nginx/sites-available/my_app.conf owner: root group: root mode: '0644' register: restart_nginx - name: Create symlink to sites-enabled file: src: /etc/nginx/sites-available/my_app.conf dest: /etc/nginx/sites-enabled/my_app.conf state: link - name: restart nginx service: name: nginx state: restarted when: restart_nginx.changed</code> </pre> <br><p>  If one of the configuration files changes, then the <code>restart_nginx</code> variable will be copied and registered.  And only if this variable has been registered, will the service restart. </p><br><p>  And, of course, you need to add the nginx role to the main playbook. </p><br><h3 id="nastroyka-postgresql">  Configure postgresql </h3><br><p>  We need to enable postgresql with systemd, just like we did with nginx, and also create a user that we will use to access the database and the database itself. <br>  Create the role <code>/ansible/roles/postgresql/tasks/main.yml</code> : </p><br><pre> <code class="plaintext hljs"># Create user in postgresql - name: enable postgresql and start systemd: name: postgresql state: started enabled: yes - name: Create database user become_user: postgres postgresql_user: name: "{{ db_user }}" password: "{{ db_password }}" role_attr_flags: SUPERUSER - name: Create database become_user: postgres postgresql_db: name: "{{ db_name }}" encoding: UTF-8 owner: "{{ db_user }}"</code> </pre> <br><p>  I will not describe how to add variables to inventory, this has already been done many times, as well as the syntax of the postgresql_db and postgresql_user modules.  More data can be found in the documentation.  Here the <code>become_user: postgres</code> directive is most interesting.  The fact is that by default only postgres user has access to the postgresql database and only locally.  This directive allows us to execute commands on behalf of this user (unless of course we have access). <br>  Also, you may have to add a line in pg_hba.conf to allow the new user access to the database.  This can be done just as we changed the nginx config. </p><br><p>  And of course, you need to add the postgresql role to the main playbook. </p><br><h3 id="ustanovka-ruby-cherez-rbenv">  Installing ruby ‚Äã‚Äãvia rbenv </h3><br><p>  In ansible there are no modules for working with rbenv, and it is installed by cloning the git repository.  Therefore, this task becomes the most non-standard.  Let's create for it the role <code>/ansible/roles/ruby_rbenv/main.yml</code> and begin to fill it: </p><br><pre> <code class="plaintext hljs"># Install rbenv and ruby - name: Install rbenv become_user: "{{ user }}" git: repo=https://github.com/rbenv/rbenv.git dest=~/.rbenv</code> </pre> <br><p>  We again use the become_user directive to work from under the user we created for these purposes.  Since rbenv is installed in its home directory, not globally.  And we also use the git module to clone the repository, specifying repo and dest. </p><br><p>  Next, we need to register rbenv init in bashrc and add rbenv to PATH in the same place.  For this we have a lineinfile module: </p><br><pre> <code class="plaintext hljs">- name: Add rbenv to PATH become_user: "{{ user }}" lineinfile: path: ~/.bashrc state: present line: 'export PATH="${HOME}/.rbenv/bin:${PATH}"' - name: Add rbenv init to bashrc become_user: "{{ user }}" lineinfile: path: ~/.bashrc state: present line: 'eval "$(rbenv init -)"'</code> </pre> <br><p>  After that, you need to install ruby_build: </p><br><pre> <code class="plaintext hljs">- name: Install ruby-build become_user: "{{ user }}" git: repo=https://github.com/rbenv/ruby-build.git dest=~/.rbenv/plugins/ruby-build</code> </pre> <br><p>  And finally, install ruby.  This is done via rbenv, simply by bash with the command: </p><br><pre> <code class="plaintext hljs">- name: Install ruby become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" rbenv install {{ ruby_version }} args: executable: /bin/bash</code> </pre> <br><p>  We say what command to execute and what.  However, here we will come across the fact that ansible does not run the code contained in bashrc before running the commands.  So, rbenv will have to be defined directly in the same script. </p><br><p>  The next problem is that the shell command has no state in terms of ansible.  Ie, an automatic check whether this version of ruby ‚Äã‚Äãis installed or not will not.  We can do it on our own: </p><br><pre> <code class="plaintext hljs">- name: Install ruby become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" if ! rbenv versions | grep -q {{ ruby_version }} then rbenv install {{ ruby_version }} &amp;&amp; rbenv global {{ ruby_version }} fi args: executable: /bin/bash</code> </pre> <br><p>  And it remains to install the bundler: </p><br><pre> <code class="plaintext hljs">- name: Install bundler become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" gem install bundler</code> </pre> <br><p>  And again, add our role of ruby_rbenv to the main playbook. </p><br><h3 id="shared-files">  Shared files. </h3><br><p>  In general, this setting could be completed.  Then it remains to run capistrano and it will copy the code itself, create the necessary directories and start the application (if everything is configured correctly).  However, often capistrano requires additional configuration files, such as <code>database.yml</code> or <code>.env</code> They can be copied just like files and templates for nginx.  There is only one subtlety.  Before copying files, you need to create a directory structure for them, something like this: </p><br><pre> <code class="plaintext hljs"># Copy shared files for deploy - name: Ensure shared dir become_user: "{{ user }}" file: path: "{{ app_path }}/shared/config" state: directory</code> </pre> <br><p>  we specify only one directory and ansible will automatically create the parent if necessary. </p><br><h2 id="ansible-vault">  Ansible vault </h2><br><p>  We have already stumbled upon the fact that the variables may be confidential data such as user password.  If you created an <code>.env</code> file for an application, and <code>database.yml</code> then there should be even more such critical data.  They would be good to hide from prying eyes.  For this is used <a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html">ansible vault</a> . </p><br><p>  Create a file for variable <code>/ansible/vars/all.yml</code> (here you can create different files for different groups of hosts, just like in the inventory file: production.yml, staging.yml, etc). <br>  In this file you need to transfer all the variables that should be encrypted using the standard yml syntax: </p><br><pre> <code class="plaintext hljs"># System vars user_password: 123qweasd db_password: 123qweasd # ENV vars aws_access_key_id: xxxxx aws_secret_access_key: xxxxxx aws_bucket: bucket_name rails_secret_key_base: very_secret_key_base</code> </pre> <br><p>  Then this file can be encrypted with the command: </p><br><pre> <code class="plaintext hljs">ansible-vault encrypt ./vars/all.yml</code> </pre> <br><p>  Naturally, when encrypting it will be necessary to set a password for decryption.  You can see what is inside the file after calling this command. </p><br><p>  Using <code>ansible-vault decrypt</code> file can be decrypted, modified and then encrypted again. </p><br><p>  To work to decrypt the file is not necessary.  You store it in encrypted form and launch the playbook with the argument <code>--ask-vault-pass</code> .  Ansible asks for a password, retrieves variables and performs tasks.  All data will remain encrypted. </p><br><p>  The complete command for several groups of hosts and the ansible vault will look something like this: </p><br><pre> <code class="plaintext hljs">ansible-playbook -i inventory ./playbook.yml -l "staging" --ask-vault-pass</code> </pre> <br><p>  And I will not give you the full text of playbooks and roles, write yourself.  Because the ansible thing is this - if you do not understand what needs to be done, then he will not do it for you. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460769/">https://habr.com/ru/post/460769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460741/index.html">ES6 Simple language</a></li>
<li><a href="../460745/index.html">Experience of using GSM module in home automation</a></li>
<li><a href="../460747/index.html">Find profit or crackdown: Spotify stopped working directly with the authors - what does it mean</a></li>
<li><a href="../460751/index.html">How we launched robots in small Chernobyl</a></li>
<li><a href="../460755/index.html">The robot that will go for your smile. We make a cheap cart for studying ROS. Part 1, iron</a></li>
<li><a href="../460773/index.html">Implementing Pattern Matching in Java</a></li>
<li><a href="../460777/index.html">This is a twist: why Apple changed the requirements for application developers</a></li>
<li><a href="../460779/index.html">Advanced Debug</a></li>
<li><a href="../46078/index.html">Erotic social networks Ning left month</a></li>
<li><a href="../460783/index.html">Consensus on the reputation of the node. Do I need?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>