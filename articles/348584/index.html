<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to avoid performance problems when creating React-applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Performance react 


 React is not for nothing considered to be very productive framework. It allows you to create fast dynamic pages with a large num...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to avoid performance problems when creating React-applications</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/1m/ho/_3/1mho_3_d9il4csflo1v0gtcu9p4.png"></p><br><h2 id="o-proizvoditelnosti-react">  Performance react </h2><br><p>  React is not for nothing considered to be very productive framework.  It allows you to create fast dynamic pages with a large number of elements. </p><br><p>  But there are situations when there are a lot of elements on the page and react lacks the built-in performance.  Then you have to apply various techniques for optimization. </p><a name="habracut"></a><br><p>  A page written on react consists of individual components.  Each of them is responsible for the appearance of a particular part of the page.  This appearance depends on the parameters (properties) that were passed to the component.  At occurrence of any events (for example, at any actions of the user or data acquisition on a network) properties can change.  If the properties of a component have changed, it must be redrawn so that these changes are displayed on the user's screen. </p><br><p>  If any events occur, parts of the page can be redrawn, even if the properties of the components that are responsible for them have not been changed.  If there are many such parts, then for any user action, the drawing can take a considerable amount of time, and there can be noticeable delays when interacting with the page interface.  The main way to deal with such performance problems is to cancel component redrawing, if their properties have not been changed.  That is, upon the occurrence of any events, only those elements on the page should be redrawn, the properties and appearance of which this event affected.  To do this, when creating react-components, you must define the method shouldComponentUpdate or use React.PureComponent as the parent class instead of React.Component. </p><br><p>  The shouldComponentUpdate method should return false when no redraw is needed.  And in the React.PureComponent class, this method is already implemented.  It checks all incoming properties, and the component will not be redrawn if none of its properties have changed. </p><br><p>  Example shouldComponentUpdate: </p><br><pre><code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * as <span class="hljs-type"><span class="hljs-type">React</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'reac</span></span>t'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ shouldComponentUpdate(nextProps) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.value !== nextProps.value } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;...&lt;/div&gt;; } }</code> </pre> <br><p>  Example React.PureComponent: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * as <span class="hljs-type"><span class="hljs-type">React</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'reac</span></span>t'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt;...&lt;/div&gt;; } }</code> </pre> <br><h2 id="kogda-optimizaciya-ne-rabotaet">  When optimization doesn't work </h2><br><p>  The working principle of shouldCompenentUpdate and React.PureComponent is based on a comparison of old properties with new ones.  If the properties have not changed, the appearance of the component is not updated. </p><br><p>  Therefore, it is necessary to ensure that the properties are changed only when necessary. <br>  But there are situations in which a component unintentionally gets new properties when it is not required. </p><br><p>  This can occur when using the bind method, arrow functions, literal objects, or other constructs that create new objects with each call, in the render method. </p><br><p>  When optimization doesn't work: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick() { doSomehing(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; &lt;<span class="hljs-type"><span class="hljs-type">Child1</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)}/&gt; &lt;<span class="hljs-type"><span class="hljs-type">Child2</span></span> onClick={() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick()}/&gt; &lt;<span class="hljs-type"><span class="hljs-type">Child3</span></span> data={{id: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.id, value: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.value}}/&gt; &lt;<span class="hljs-type"><span class="hljs-type">Child4</span></span> items={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item) =&gt; {.....})}/&gt; &lt;/div&gt; ); } }</code> </pre> <br><p>  The bind and arrow functions each time a new function is returned. </p><br><p>  Comparing bind results: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick() === <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  Therefore, here the first two components will each time receive a new onClick property. <br>  Child3 will receive the new object in the data property, and the fourth will receive the new array in items. </p><br><p>  Such constructions should be avoided.  When using them, performance optimizations made with shouldComponentUpdate or React.PureComponent will not work due to getting new properties. </p><br><p>  In principle, you can write such an implementation of shouldComponentUpdate, in which changes of some properties will be ignored and the update will not occur.  But this method can not be used in all situations.  First, if there are many properties, such an implementation may contain a fairly large number of checks, and this may be the cause of errors and bugs.  Also, this code is more difficult to maintain, as when adding new properties you will need to modify the method shouldComponentUpdate.  Secondly, with this approach, the component in which shouldComponentUpdate is implemented must know exactly where and under what circumstances it will be used to determine exactly which changes of which particular properties can be ignored.  And in the place where it will be used, you need to know its internal implementation, so as not to transfer once again new values ‚Äã‚Äãto those properties, the change of which will lead to unnecessary redrawing.  This greatly impairs the encapsulation of components, which is often undesirable. </p><br><h2 id="rezultaty-testirovaniya-proizvoditelnosti">  Performance Test Results </h2><br><p>  Often during the writing of code and during the code review there are doubts whether it is necessary to waste your time and pay attention to such problems.  To determine the impact that the transfer of new properties to components has on performance, a small test page was written.  It is located at <a href="https://megazazik.github.io/react-perf-test/">https://megazazik.github.io/react-perf-test/</a> </p><br><p>  The project allows to measure the update time of a large number of small components in situations where they receive new properties each time, as well as when the properties remain unchanged.  For testing used different components: </p><br><ul><li>  stateful - inherited from React.Component </li><li>  stateful - inherited from React.PureComponent </li><li>  stateless - simple functions </li><li>  html elements (div) </li></ul><br><p>  When you open the project page, a list of thousands of items is displayed.  When you click on any element or when you hover the mouse, the selected element becomes active, and the list is redrawn again.  At the same time, depending on the selected parameters, elements whose state has not changed receive either the same properties or new ones, due to the use of switch functions. </p><br><p>  1000 items update time: </p><br><table><thead><tr><th>  Device, Browser </th><th>  Optimization </th><th>  Pure, mc </th><th>  Stateful, mc </th><th>  Stateless, mc </th><th>  html, mc </th></tr></thead><tbody><tr><td>  Desktop, Chrome </td><td>  not </td><td>  6.5 </td><td>  6.3 </td><td>  5.8 </td><td>  3.5 </td></tr><tr><td>  Desktop, Chrome </td><td>  Yes </td><td>  3.3 </td><td>  4.9 </td><td>  4.3 </td><td>  2.5 </td></tr><tr><td>  Desktop, Firefox </td><td>  not </td><td>  13.7 </td><td>  11.9 </td><td>  11.5 </td><td>  7.3 </td></tr><tr><td>  Desktop, Firefox </td><td>  Yes </td><td>  5.4 </td><td>  8.5 </td><td>  7,6 </td><td>  4.4 </td></tr><tr><td>  Desktop, Edge </td><td>  not </td><td>  19.6 </td><td>  16.2 </td><td>  13.5 </td><td>  8.6 </td></tr><tr><td>  Desktop, Edge </td><td>  Yes </td><td>  8.1 </td><td>  11.5 </td><td>  8.7 </td><td>  4.7 </td></tr><tr><td>  Mobile, Chrome </td><td>  not </td><td>  31.1 </td><td>  30.2 </td><td>  29.6 </td><td>  19.3 </td></tr><tr><td>  Mobile, Chrome </td><td>  Yes </td><td>  16.7 </td><td>  25.8 </td><td>  21.5 </td><td>  14.8 </td></tr></tbody></table><br><p>  Specific numbers can be highly dependent on the device and the browser on which the page is opened, as well as on the memory status and CPU usage.  But the relative difference in rendering performance, with and without optimization, should always remain at about the same level. </p><br><p>  You can compare the results with those that will be relevant for your device. </p><br><p>  The optimal rendering time can be considered such a time at which the browser will not skip frames when updating the screen of the device.  Most modern screens support a refresh rate of at least 60 frames per second.  It turns out, the screen is updated at least every 16.6 milliseconds.  Therefore, taking into account the possible additional load, it is desirable that the update of all components of the page takes place no more than 10 milliseconds. </p><br><p>  According to the test results, it can be seen that the rendering time of components inherited from PureComponent and html elements is significantly reduced when the properties do not change. <br>  Moreover, in tests, the immutability of properties also affects the performance of other types of components.  But it is significantly less and is not connected with the abolition of redrawing, but with the fact that the properties they received are eventually transferred to the same div-elements in the markup, which are already in turn optimized. </p><br><p>  When testing used the smallest components.  As their size increases, the performance gain should only increase.  This effect can be roughly estimated if the ‚ÄúSplit List‚Äù option is enabled in the test project.  In this mode, the entire list is divided into groups of 10 elements each.  Then every 10 groups turn into groups of the top level.  As a result, the page consists of 10 groups, which contain 10 subgroups, each of which has 10 elements. </p><br><p>  Such a partition is more like what real pages consist of.  Typically, a page contains several large components that contain smaller nested components. </p><br><p>  In this mode, you can estimate the difference in performance between the worst situation, when in any event every element of the page is redrawn, and the situation.  when only those elements are updated, the properties that have changed. </p><br><table><thead><tr><th>  Device, Browser </th><th>  Optimization </th><th>  Pure, mc </th><th>  Stateful, mc </th><th>  Stateless, mc </th><th>  html, mc </th></tr></thead><tbody><tr><td>  Desktop, Chrome </td><td>  not </td><td>  8.7 </td><td>  8.3 </td><td>  8.0 </td><td>  6.1 </td></tr><tr><td>  Desktop, Chrome </td><td>  Yes </td><td>  0.9 </td><td>  0.9 </td><td>  0.9 </td><td>  0.8 </td></tr><tr><td>  Desktop, Firefox </td><td>  not </td><td>  19.1 </td><td>  16.3 </td><td>  15.4 </td><td>  12.6 </td></tr><tr><td>  Desktop, Firefox </td><td>  Yes </td><td>  1.5 </td><td>  1.5 </td><td>  1.5 </td><td>  1,3 </td></tr><tr><td>  Desktop, Edge </td><td>  not </td><td>  23.1 </td><td>  20.6 </td><td>  18.1 </td><td>  13.0 </td></tr><tr><td>  Desktop, Edge </td><td>  Yes </td><td>  2.9 </td><td>  2.9 </td><td>  2.9 </td><td>  2.8 </td></tr><tr><td>  Mobile, Chrome </td><td>  not </td><td>  37.1 </td><td>  35.0 </td><td>  34.5 </td><td>  24.9 </td></tr><tr><td>  Mobile, Chrome </td><td>  Yes </td><td>  5.2 </td><td>  5.6 </td><td>  5.3 </td><td>  4.7 </td></tr></tbody></table><br><p>  In this case, the type of the component under test is of little importance, since the groups to which the list is divided implement the own method shouldComponentUpdate. </p><br><h2 id="kak-izbezhat-sozdaniya-novyh-funkciy-v-render">  How to avoid creating new features in render </h2><br><p>  In practice, most often unnecessary generation of new component properties occurs due to the use of switch functions or the bind function.  Consider how you can solve this problem.  Most often, it is quite simple.  But sometimes you need to spend some time. </p><br><p>  The easiest way to not create new functions with each update is to create them once at the moment of initialization of the component instance. </p><br><p>  To do this, you can call the bind function not in the render method, but in the class constructor, and save the result in an object property for later reference in the render method. </p><br><p>  Example bind in constructor: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ constructor(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } _onClick() { doSomehing(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick}/&gt;; } }</code> </pre> <br><p>  Or you can use the arrow function and also save the result in the property of the object. </p><br><p>  Example with arrow function: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick = () =&gt; { doSomehing(); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick}/&gt;; } }</code> </pre> <br><p>  The previous method is simple and fast to implement.  It should be used in most cases. </p><br><p>  But there are situations when the callback function is transferred to the list of child components, for example, in a loop, and when it is executed, it must be known in which of the elements the call occurred.  Such a function can take as an argument, for example, the index of an element of an array. </p><br><p>  Example with a list: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick = (index) =&gt; { doSomehing(index); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick(index)} item={item} /&gt; ))} &lt;/div&gt; ); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onClick}&gt;...&lt;/div&gt;; } }</code> </pre> <br><p>  Here each child component from the list should get its unique function, in which the element index is stored through the closure. </p><br><p>  In this case, getting rid of creating new functions with each drawing is more difficult.  There are several ways to do this. </p><br><h3 id="izmenenie-interfeysa-dochernego-komponenta">  Changing the interface of the child component </h3><br><p>  To use the first approach, you need to create only one callback function and pass it to all child components.  At the same time, the responsibility for passing the necessary arguments to the function will rest on the child components. </p><br><p>  An example with id transfer: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick = (id) =&gt; { doSomehing(id); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick} item={item} /&gt; ))} &lt;/div&gt; ); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ _onClick = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onClick(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.item.id) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick}&gt;...&lt;/div&gt;; } }</code> </pre> <br><p>  If there is no data required for the callback function inside the child component, then it will need to be passed to it through the properties. </p><br><p>  An example with adding index to properties: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick = (index) =&gt; { doSomehing(index); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick} item={item} index={index} /&gt; ))} &lt;/div&gt; ); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ _onClick = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onClick(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.index) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick}&gt;...&lt;/div&gt;; } }</code> </pre> <br><p>  This method is not always possible to use.  First, we may not have access to the source code of the child component.  Secondly, adding new properties may be undesirable due to the fact that this may adversely affect the clarity and integrity of its interface. </p><br><h3 id="vydelenie-komponenta">  Component selection </h3><br><p>  If you cannot use the previous method or if this is undesirable, you can create a separate component that will be responsible for passing an additional parameter to the callback function. </p><br><p>  Example selection component: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick = (index) =&gt; { doSomehing(index); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildWrapperComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick} item={item} index={index} /&gt; ))} &lt;/div&gt; ); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildWrapperComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ _onClick = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.onClick(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.index) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick} item={item} /&gt; ); } }</code> </pre> <br><p>  This method can be used in almost any situation.  Perhaps his only drawback is that it is relatively laborious.  You have to write a separate class only to get rid of creating functions when you call render. </p><br><h3 id="peredacha-znacheniy-v-kachestve-svoystv-nativnym-elementam">  Passing Values ‚Äã‚Äãas Properties to Native Elements </h3><br><p>  A method can also be used in which the array index (or other key) is passed to child html elements (such as, for example, button and input), and when an event occurs in the callback function, this data is extracted from the html element. </p><br><p>  Example with html elements: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick = (e) =&gt; { doSomehing(e.target.value); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"button"</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onClick} value={index} &gt; {item.title} &lt;/button&gt; ))} &lt;/div&gt; ); } }</code> </pre> <br><p>  We cannot implement shouldComponentUpdate for html elements, but, as tests have shown, they have a built-in optimization mechanism and the immutability of their properties can also significantly reduce the update time of such elements. </p><br><h3 id="keshirovanie-funkciy-obratnogo-vyzova">  Caching Callbacks </h3><br><p>  To use this method, you need to create a list of callback functions once for all child components, and use the previously created functions for subsequent rendering.  One of the options for such an implementation: </p><br><p>  Caching Kolbeks: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _callbacks = {}; _getOnClick = (index) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._callbacks[index]) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._callbacks[index] = () =&gt; doSomehing(index); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._callbacks[index]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getOnClick(index)} item={item} /&gt; ))} &lt;/div&gt; ); } }</code> </pre> <br><p>  This method is relatively time consuming.  If, in addition to the index, you need to transfer some more data to the callback function, then for its proper operation you will need to implement more complex logic and write more code.  In addition, this function will need to be copied to each component where it is needed, and, possibly, to paste this code several times into the same class.  Therefore, to avoid duplication of code in each class, you can create a module that would perform the necessary actions. </p><br><p>  For an example of such modules, there are two packages: </p><br><ul><li>  cached-bind </li><li>  react-cached-callback </li></ul><br><p>  Both packages have the same features, but they have a different interface. <br>  They allow you to create a callback function once for each child component from the list and use it with each subsequent drawing. </p><br><p>  An example of using cached-bind: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bind from <span class="hljs-symbol"><span class="hljs-symbol">'cached</span></span>-bind'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ _onClick(index) { doSomehing(index); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'_onClic</span></span>k', index)} item={item} /&gt; ))} &lt;/div&gt; ); } }</code> </pre> <br><p>  An example of using react-cached-callback: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cached from <span class="hljs-symbol"><span class="hljs-symbol">'react</span></span>-cached-callback'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@cached</span></span> _getOnClick(index) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; doSomehing(index); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div&gt; {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.items.map((item, index) =&gt; ( &lt;<span class="hljs-type"><span class="hljs-type">ChildComponent</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getOnClick(index)} item={item} /&gt; ))} &lt;/div&gt; ); } }</code> </pre> <br><p>  To understand what kind of stored function must be returned, both packages must determine the ID of the child component when they are called.  As an identifier, you can use, for example, the index of an element in an array. </p><br><p>  cached-bind should get this identifier as the third argument when calling the bind function. <br>  And react-cached-callback by default considers the first argument passed to the original function to be the identifier.  You can find out the details of the interfaces in the package description. </p><br><h2 id="v-zaklyuchenie">  Finally </h2><br><p>  React is a fast framework, and much of the applications will work with sufficient performance without additional effort.  But, when increasing the size of the application, the developer may need to apply various optimization techniques and make sure that the properties of the components are not changed unnecessarily. </p><br><p>  Many libraries for state management (for example, redux or MobX) currently have their own methods for optimizing react-components.  But even with their use, the optional generation of new objects and functions when drawing components can lead to significant delays when updating the user interface. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348584/">https://habr.com/ru/post/348584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348570/index.html">7 Free Data Science Courses for Beginners</a></li>
<li><a href="../348572/index.html">Security week 3: a thief from a bitcoin thief stole, your trojan could be here, ten days without computers</a></li>
<li><a href="../348574/index.html">From regular office to fully distant work: how we built an effective corporate culture</a></li>
<li><a href="../348578/index.html">Serverless application with AWS and Bitbucket Pipelines CI / CD implementation</a></li>
<li><a href="../348582/index.html">Some interesting data drawn from the ‚ÄúMy Circle‚Äù autocompletion</a></li>
<li><a href="../348586/index.html">Experiment with binary code in Glimmer</a></li>
<li><a href="../348588/index.html">Black Friday 2017 through the eyes of IT and developers. As we stood black Friday with a 10 times increase in traffic</a></li>
<li><a href="../348590/index.html">What is not written in the documentation, or the subtleties of refactoring on .Net Core</a></li>
<li><a href="../348592/index.html">Fintech Digest: eBay vs. PayPal, the international payment system on the blockchain</a></li>
<li><a href="../348594/index.html">Internet people and non-people</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>