<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Construction of the suffix tree: Ukkonen algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the request of the workers lay out the description and proof of the algorithm Ukkonen. 

 Task Description 
 It is required to build a suffix tree ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Construction of the suffix tree: Ukkonen algorithm</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/algorithm/111449/">At the request of the workers</a> lay out the description and proof of the algorithm Ukkonen. <br><br><h4>  Task Description </h4><br>  It is required to build a suffix tree for a given string in a reasonable time.  A suffix tree is a boron consisting of all the suffixes of a given string.  If in short, boron is a hanging tree with symbols on edges, an implementation of a data structure for storing strings.  Strings are obtained by passing from the root along the edges, writing down the corresponding characters, to the terminal vertex. <br><br>  A boron for an arbitrary row of lines is constructed in O (the sum of the lengths of these lines).  Obviously, the sum of the lengths of all suffixes of a string is proportional to the square of the length of the string itself.  Thus, building a suffix tree with a trivial algorithm works in O (N <sup>2</sup> ).  And here a reasonable question arises, is it possible to build a suffix tree faster? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Actually you can. <br><a name="habracut"></a><br>  And so, let's start from the beginning.  Let the length of the string S = s <sub>1</sub> ... s <sub>n</sub> , for which we build a suffix tree, be N. Suppose that the tree grows down, i.e.  the root is the upper vertex, and the ribs go from above, from the ancestor, down to the descendant.  In the future, I will sometimes call vertices suffixes, and vice versa, implying the corresponding suffixes, if they are vertices for suffixes, or the corresponding substrings. <br><br>  First, we abandon the idea of ‚Äã‚Äãadding suffixes one by one, and we will build a tree for all suffixes at the same time, i.e.  successively adding characters to the string.  Secondly, we compress the edges.  What does it mean: if we have several edges in a row, between which there are vertices with only one descendant, then we will merge these edges into one and write on it a sequence of characters written on the combined edges.  You can not explicitly store this sequence, but for each edge, store only the indices of the beginning and end of this substring in S. To remote vertices, compare the positions within the long edge and call these positions ‚Äúimaginary vertices‚Äù.  Thus, to store a vertex you need: the number of the vertex from which the edge goes, the first character of this edge, the offset along the edge.  As ancestors, we will consider only the silent vertices. <br><br>  First we show that the total number of existing vertices in a compressed tree is O (N). <br><br><h5>  Lemma: The number of vertices in a compressed suffix tree O (N) </h5><br>  Let's see what kind there are vertices.  First, it leaves.  Secondly, this is a "fork" - the top with more than one child.  The root is also the top. <br>  The root is only one. <br>  Each sheet can only match the suffix.  Let the top of the sheet correspond to T = s <sub>l</sub> ... s <sub>r</sub> - a substring in S that is not a suffix.  Then in S there is a string Ts <sub>r + 1</sub> , which means that there must be an edge from our sheet.  Thus, the number of sheets is no more than N. <br>  At first glance, it is not clear how much a fork can be.  To do this, consider the places where a compressed tree is built when they are created.  When adding one suffix, we first go on a tree, and then maybe 3 cases: <br>  1) we have finished adding the suffix, never trying to get out of an already constructed tree.  Then the fork was not created <br>  2) we wanted to get out of the tree in the dumb vertex.  Then an edge is created to the end of the suffix from this vertex.  New fork is also not created. <br>  3) we wanted to get out of the tree at the imaginary top.  That's when we have to split this edge into two, create a fork in this place, and one edge will correspond to the rest of the edge on which we stopped, and the other will <br>  match the ending suffix.  In this case, we created only one fork. <br>  We get that the fork is not more than N. <br>  As a result, the number of vertices in a compressed tree is O (N). <br><br>  The considered algorithm will work online, i.e.  after the k-th step of the algorithm, we want to get a suffix tree for the prefix string of length k.  In this case, we can subsequently increase the length of the string as needed in a short time.  Because  suffixes we have N, add characters required O (N), we get the running time O (N <sup>2</sup> ).  To speed up the work, we will add suffix links to the tree and make 3 optimizations. <br>  A suffix link is a pointer (or number) of a vertex (including an imaginary one), which corresponds to the largest proper (not equal to the line itself) suffix of the line corresponding to the current vertex.  Since we store all suffixes, and hence all the substrings, of one string, then the suffix link from the string T = s <sub>l</sub> ... s <sub>r</sub> points to the string T '= s <sub>l + 1</sub> ... <sub>r</sub> , i.e.  shortens the string length by one.  We will store suffix links only for fork and root.  In order not to consider cases, we add a ‚Äúempty‚Äù vertex blank, from which edges with all symbols of the alphabet lead to the root, and a suffix link from the root leads to it.  The fact that the suffix link from the fork leads to the dumb vertex, I will leave without proof, because  I consider it obvious.  For sheets, a similar statement is not true.  Suffix links from a sheet can also point to an imaginary vertex, so we will not store them for sheets.  So, suffix links lead to silent vertices and their number O (N). <br><br><h4>  Now about optimization </h4><br><br><h5>  Optimization number 1: was a sheet, sheet and stay </h5><br>  Note that when adding a symbol to a sheet, we get a new sheet.  Therefore, we say that we create a sheet not only for the considered part of the line, but for the whole of all the lines to the end.  For this, the right border of the substring corresponding to an edge to a leaf is infinity.  Thus, it is no longer necessary to extend the sheets each time.  As a result, if we have created a sheet for some suffix, we will not consider this suffix anymore.  It is clear that this does not affect the asymptotics, but it saves us from unnecessary actions. <br><br><h5>  Optimization number 2: if you just went along the edge, then in smaller suffixes we will also go along the edge </h5><br>  What does this mean?  Consider the first (longest) suffix, from the top of which we were able to walk along the edge of the current character.  Then it is stated that for all smaller suffixes from their vertex we will go over the corresponding edge, and we will not create sheets or forks.  Thus, we reduce the number of vertices at each step.  For obvious reasons, this also does not affect the asymptotics, but will be needed for the last optimization. <br><br>  So, ahead of us is waiting for the last major and most difficult optimization, which reduces the asymptotics to the required value.  But for starters, we get rid of the list of Konnyh vertices of suffixes, and to view them all we will walk from the longest, first suffix on the suffix links.  Because  we know that suffix links are not for every vertex, but only for forks (and the root, but from this point on, we will also consider it a fork), then passing through the suffix link from a leaf or imaginary vertex will occur like this: <br>  1) go to the nearest ancestor-fork along the edge and remember the substring, which we climbed up; <br>  2) go to the suffix link from the fork; <br>  3) go down until we pass through this memorized substring.  We may have to go through several forks, then we just need to go along the right edge; <br>  4) a vertex, possibly imaginary, in which we will stop, and will be a ‚Äúsuffix reference‚Äù for the original one. <br>  The fact that during the descent down we will not try to get out of the tree, I leave it without proof as obvious. <br><br>  And so, we have 3 actions with vertices when adding a symbol: <br>  1) Sheet renewal (performed for the sheet) <br>  2) Creating a fork (performed for an imaginary vertex or fork, of which there is no edge with this symbol) <br>  3) Just pass along the edge (performed for an imaginary vertex or fork, of which there is such an edge) <br>  It is argued that if we consider the suffixes by reducing the length, then actions with them will be performed in this order 11 ... 12 ... 23..33.  (This follows from the fact that from the vertex of the suffix of a given vertex there are at least all edges similar to the edges from a given vertex, but there may still be other edges).  Moreover, the positions of the change of action 1 by 2 and 2 by 3 move only to the left (do not forget that after each phase we have the length of this sequence drop by 1, because a new suffix is ‚Äã‚Äãadded). <br><br>  Let's call the first vertex, which is not a leaf, as a start-point (SP).  This vertex corresponds to the first occurrence of 2 in this sequence.  True, there can be no type 2 actions, then SP is the first occurrence 3. And the vertex corresponding to the first occurrence 3 is called the active-point (AP).  What did we get after the first two optimizations?  The fact that the sequence in this phase can be considered starting with SP, and finish when we arrive at the AP.  Now there is a reasonable question, how to quickly find the SP for the next phase?  There is a third optimization for this. <br><br><h5>  Optimization # 3: SP for the next phase is a descendant of the current phase AP </h5><br>  To begin with, SP is a descendant of one of the vertices of suffixes before this phase.  During the execution of the phase, some action was performed, and then a descent along the edge with the current symbol.  Therefore, I will not operate with descendants, but with the tops of the previous phase. <br>  Obvious fact: the next SP cannot be the suffix with which the action of the first type was performed at the current step.  Further, SP cannot be a suffix for which an action of the second type was performed, since  at the same time we created a fork and, passing along the edge leading to the leaf, we hit the leaf.  Why is the suffix corresponding to the previous AP appropriate?  From the AP, we only want to have at least some edge from it.  Consider the suffix T corresponding to SP.  Since there is at least an edge with this symbol, then T appears as a substring with no suffix in S. Hence, there is a substring Ts <sub>k</sub> in S (recall that at this phase we added the symbol s <sub>k</sub> ).  Then in the new line, with the added symbol s <sub>k</sub> , there will be a substring of Ts <sub>k</sub> c, where c is a certain character.  So, at the vertex Ts <sub>k</sub> (descendant of SP) the condition for the AP is fulfilled, and the vertex we just considered is the earliest possible one, which means it will be the next AP. <br>  As a result, we obtain that it is enough for us to store only the AP and move it.  Processing the vertices when moving the AP (creating cross-overs or adding one edge to an existing one) will be enough to build a tree. <br><br>  Congratulations!  If you have read this far and almost understood everything, then you can already write a working implementation of the Ukkonen algorithm.  For a better understanding of the spread pseudocode of this algorithm: <br><pre><code class="cpp hljs">....   .....  root  blank     ; SP &lt;- root; k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (c =  k-  ) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( SP     c) {   SP    [k,oo]; SP &lt;-     SP; } SP &lt;-      C  <span class="hljs-number"><span class="hljs-number">1</span></span> ; k++;<span class="hljs-comment"><span class="hljs-comment">//   ; } ....      V .... U &lt;-  V; S &lt;-    U  V; U &lt;- suff(U); //      while (S  ) { C &lt;-   S; if ( ,   C ==  S) {      ; } else if ( ,   C &gt;  S){      ;   ; } else { // ,   C &lt;  S     ;   S  ,    ; } }</span></span></code> </pre> <br><br>  But the last question remains.  Why the asymptotics of this algorithm is O (N)?  Despite the fact that these optimizations allow you to work with all suffixes no more than 2N times (we either process each suffix and go further, or stay on this suffix and look at the next character; each of these cases is not more than N), we still have transitions by suffix links, for which it is not at all obvious that the total transitions on them will be O (N). <br><br><h4>  Asymptotic proof </h4><br>  Because  the transition by direct link works beyond O (1), and there are no more than N of them, then it suffices to consider the transition down the edges.  To do this, consider the length of the displacement along the edge along which we ascended to the ancestor.  Let it be equal to L. Then, with each passing down in the ribs, this length decreases by at least 1. And it increases only in the basic procedure when you walk along the edge of the symbol C, and not more than 1 at a time.  And there are N. such passages. The final offset value lies in the range [0, N], the number of elongations N, and the total number of cuts can be no more than 2N.  This means that the total number of advances down when clicking on the suffix link O (N).  As a result, the number of each type of action O (N), and hence the total number of all actions O (N).  Asymptotics is proved. <br><br><h4>  Using Suffix Trees </h4><br><br>  The first, and perhaps the most common, practical task associated with suffix trees is to find the inclusion of a single line in the text.  There are other algorithms for this task, but if we modify it a little, for example, we need to search for it many times, but we cannot process all requests in advance, as in the Aho-Korsika algorithm, then simply walking the tree through the characters from the search query , we will either try to exit the tree, then the answer is negative, or, if the request has ended, the answer is positive.  If, in addition to the tree, to store, how many leaves can be reached from this vertex, and a unique symbol can be assigned to the text at the end, so that each suffix corresponds to a leaf, then the number of queries in the text can also be said. <br><br>  The largest common substring of two or more strings. <br>  The condition of the problem is simple: a set of strings is given (we consider the case when there are two of them), and it is required to find their greatest common substring in linear time.  For this you need to build a generalized suffix tree of these substrings.  Each leaf of this tree is a suffix of some string data set.  Then, if for each fork we indicate the suffixes of which set of lines begin with the line of this vertex, then to find the greatest substring it is enough to go through all the vertices and, if the vertex contains a set of all lines, then compare its length and the length of the answer already found. <br><br>  The calculation of the sum of leaves in the first task and the sets of strings in the second relates to dynamic programming and does not understand this topic.  I can only say briefly that for this you need to walk on the tree from the bottom up and do the counting, based on the already known results. <br><br>  Ps.  If you are willing, I can write an article using the Aho-Korasik algorithm. <br>  Pss.  If suddenly there are some unobvious moments, write, I will explain more clearly. </div><p>Source: <a href="https://habr.com/ru/post/111675/">https://habr.com/ru/post/111675/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111670/index.html">Choosing from a long list, speeding up the process correctly</a></li>
<li><a href="../111671/index.html">We create an original gift with the help of chemistry, physics and electronics: part 3</a></li>
<li><a href="../111672/index.html">We write our intermediate driver. Part 1</a></li>
<li><a href="../111673/index.html">Duokan. Or how to read DJVU on Kindle</a></li>
<li><a href="../111674/index.html">Software life cycle models</a></li>
<li><a href="../111676/index.html">loop_dance - quick deployment background scheduler</a></li>
<li><a href="../111678/index.html">System automatically generate settings for the DNS server Bind</a></li>
<li><a href="../111679/index.html">Development of a touch keyboard for their devices</a></li>
<li><a href="../111680/index.html">Wrapper for calling functions at their address</a></li>
<li><a href="../111681/index.html">Implementing XMPP Publish / Subscribe via Twisted</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>