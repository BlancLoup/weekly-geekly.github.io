<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Error Handling in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, habrovchane! Already today, the ‚ÄúGolang Developer‚Äù course starts at OTUS and we consider this to be an excellent occasion to share another useful ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Error Handling in Go</h1><div class="post__text post__text-html js-mediator-article">  Hi, habrovchane!  Already today, the <a href="https://otus.pw/Hjyy/">‚ÄúGolang Developer‚Äù</a> course starts at OTUS and we consider this to be an excellent occasion to share another useful publication on the topic.  Today we will talk about the Go approach to errors.  Let's start! <br><br><img src="https://habrastorage.org/webt/mr/8i/ch/mr8ichd887jvkbuzbf3dh_h5oc0.png"><br><br><h3>  Mastering Pragmatic Error Handling in Your Go Code </h3><br><img src="https://habrastorage.org/webt/gp/i3/ff/gpi3ffckknhyvkcqyfyk1dnbltc.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>This post is part of the <a href="https://medium.com/gett-engineering/before-you-go-go-bf4f861cdec7">‚ÄúBefore Starting Go‚Äù series</a> , where we explore the world of Golang, share tips and ideas you need to know when writing code on Go, so you don‚Äôt have to stuff your own bumps.</i> <br><br>  I assume that you already have at least a basic experience with Go, but if you feel that at some point you are faced with an unfamiliar material in question, do not hesitate to pause, explore the topic and come back. <br><br>  Now that we have cleared our way, let's go! <a name="habracut"></a><br><br>  Go's approach to error handling is one of the most controversial and misused features.  In this article you will learn the Go approach to errors, and understand how they work ‚Äúunder the hood‚Äù.  You will explore several different approaches, review the Go source code and the standard library to learn how errors are handled and how to work with them.  You will learn why Type Assertions play an important role in processing them, and you will see upcoming changes in error handling that you plan to introduce in Go 2. <br><br><img src="https://habrastorage.org/webt/e3/0t/gk/e30tgk9zbbofawpffxugwstrhow.png"><br><br><h2>  Introduction </h2><br>  First things first: errors in Go are not exceptions.  <a href="https://medium.com/%40davecheney">Dave Cheney</a> wrote an <a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right">epic blog post</a> about this, so I refer you to him and summarize: in other languages ‚Äã‚Äãyou cannot be sure whether the function can cause an exception or not.  Instead of generating exceptions, Go supports <b>multiple return values</b> , and by convention, this feature is usually used to return the result of a function along with an error variable. <br><br><img src="https://habrastorage.org/webt/p5/nl/dw/p5nldwpihop5qjmlgz4f0h0v_yi.png"><br><br>  If for some reason your function may fail, you should probably return a previously declared <code>error</code> type from it.  By convention, returning an error signals the problem to the caller, and returning nil is not considered an error.  Thus, you will give the caller to understand that a problem has occurred, and he needs to deal with it: whoever calls your function, he knows that he should not rely on the result before checking for an error.  If the error is not nil, he is obliged to check it and process it (log, return, maintain, invoke any retry / cleanup mechanism, etc.). <br><br><img src="https://habrastorage.org/webt/l2/u-/05/l2u-05npjr4ptcwn7woqyb20usg.png"><br>  <i>(3 // error handling</i> <i><br></i>  <i>5 // continued)</i> <br><br>  These snippets are very common in Go, and some view them as template code.  The compiler treats unused variables as compilation errors, so if you are not going to check for errors, you must assign them to <a href="https://golang.org/ref/spec">an empty identifier</a> .  But no matter how convenient it is, mistakes should not be ignored. <br><br><img src="https://habrastorage.org/webt/fm/pq/rv/fmpqrvcl6_eh4tvwhq0ebxmd4qo.png"><br>  <i>(4 // ignoring errors is not safe, and you should not rely on the result before checking for errors)</i> <br>  <i><b>the result cannot be trusted until checking for errors</b></i> <br><br>  Returning an error along with the results, along with a strict Go type system, makes it much harder to write buggy code.  You must always assume that the value of the function is corrupted, unless you have checked the error it returned, and, by assigning an error to an empty identifier, you explicitly ignore that the value of your function may be damaged. <br><br><img src="https://habrastorage.org/webt/lm/xj/uh/lmxjuhxt8v8sdvillwvsbbuct5o.png"><br>  <b><i>An empty identifier is dark and full of horror.</i></b> <br><br>  Go does have <code>panic</code> and <code>recover</code> mechanisms, which are also described in <a href="https://blog.golang.org/defer-panic-and-recover">another detailed blog post Go</a> .  But they are not intended to mimic exceptions.  According to Dave, <i>"When you panic on Go, you really panic: this is not someone else‚Äôs problem, this is already a gamemover."</i>  They are fatal and cause your program to crash.  Rob Pike came up with the proverb Do not panic, which speaks for itself: you should probably avoid these mechanisms and return errors instead. <br><br><blockquote>  "Errors - values." <br>  ‚ÄúDo not just check for errors, but treat them elegantly.‚Äù <br>  "Do not panic" <br>  <a href="https://go-proverbs.github.io/">all sayings of rob pike</a> <br></blockquote><br><h2>  Under the hood </h2><br>  <b>Interface error</b> <br><br>  Under the hood, the error type is a <a href="https://golang.org/ref/spec">simple interface with one method</a> , and if you are not familiar with it, I highly recommend viewing <a href="https://blog.golang.org/error-handling-and-go">this post</a> on the official Go blog. <br><br><img src="https://habrastorage.org/webt/n_/c3/ip/n_c3iptfnwohofkgwwhhxc-cwda.png"><br>  <b><i>interface error from source code</i></b> <br><br>  Your own mistakes are not difficult to implement.  There are various approaches to user structures that implement the <code>Error()</code> <code>string</code> method.  Any structure that implements this single method is considered a valid error value and can be returned as such. <br><br>  Let's look at a few of these approaches. <br><br><h3>  Built-in errorString structure </h3><br>  The most commonly used and widely accepted implementation of the error interface is the built-in structure of <code>errorString</code> .  This is the simplest implementation you can think of. <br><br><img src="https://habrastorage.org/webt/uv/hj/by/uvhjbyzjh8cmovqpjdkda0ww5_c.png"><br>  Source: <a href="">Go source</a> <br><br>  You can see its simplified implementation <a href="">here</a> .  All it does is contain a <code>string</code> , and this string is returned by the <code>Error</code> method.  This string error can be formatted by us on the basis of some data, say, using <code>fmt.Sprintf</code> .  But besides this, it does not contain any other features.  If you applied <a href="">errors.New</a> or <a href="">fmt.Errorf</a> , then you have already <a href="https://play.golang.org/p/olRXqq3jNyR">used it</a> . <br><br><img src="https://habrastorage.org/webt/br/6h/g5/br6hg5p3lozppuf98ry0g2ptsw4.png"><br>  <i>(13 // conclusion :)</i> <br><br>  <a href="https://play.golang.org/p/oWy5BNY1Hzq">try</a> <br><br><h3>  github.com/pkg/errors </h3><br>  Another simple example is the <a href="">pkg / errors</a> package.  Not to be confused with the built-in <code>errors</code> package, which you learned about earlier, this package provides additional important features, such as error wrapper, scan, formatting, and stack-trace writing.  You can install the package by running <code>go get github.com/pkg/errors</code> . <br><br><img src="https://habrastorage.org/webt/bo/vs/f7/bovsf7dn4l2gvaesqbepogmjxrw.png"><br><br>  When you need to attach a stack trace or the necessary debugging information to your errors, using the <code>New</code> or <code>Errorf</code> this package provides errors that are already written to your stack trace, and you can also attach simple metadata using it formatting options.  <code>Errorf</code> implements the <a href="https://golang.org/pkg/fmt/">fmt.Formatter</a> interface, that is, you can format it using the runes of the <code>fmt</code> package ( <code>%s</code> , <code>%v</code> , <code>%+v</code> , etc.). <br><br><img src="https://habrastorage.org/webt/tz/r6/if/tzr6if2llu8ayda0lrnl1zblkju.png"><br>  <i>(// 6 or alternative)</i> <br><br>  This package also represents the <code>errors.Wrap</code> and <code>errors.Wrapf</code> .  These functions add context to the error using the message and stack trace at the place where they were called.  Thus, instead of simply returning an error, you can wrap it with context and important debugging data. <br><br><img src="https://habrastorage.org/webt/pa/pz/3t/papz3tu-dlhtdcb4r8lmldfxazu.png"><br><br>  Error wrappers with other errors support the <code>Cause() error</code> method, which returns their internal error.  In addition, they can be used by the <code>errors.Cause(err error) error</code> function, which extracts the underlying internal error in the wrapping error. <br><br><h2>  Work with errors </h2><br><h3>  Type approval </h3><br>  <a href="https://golang.org/ref/spec">Type</a> assertions play an important role when dealing with errors.  You will use them to extract information from the interface value, and since error handling is associated with custom implementations of the <code>error</code> interface, implementing statements on errors is a very convenient tool. <br><br>  Its syntax is the same for all its purposes ‚Äî <code>x.(T)</code> , if <code>x</code> has an interface type.  <code>x.(T)</code> states that <code>x</code> not equal to <code>nil</code> and that the value stored in <code>x</code> is of type <code>T</code>  In the next few sections, we will look at two ways to use type assertions ‚Äî with a specific type <code>T</code> and with an interface like <code>T</code> <br><br><img src="https://habrastorage.org/webt/tb/fd/e2/tbfde2ne-8parkmkbsthfamc_ym.png"><br>  <i>(2 // abbreviated syntax skipping logical variable ok</i> <i><br></i>  <i>3 // panic: interface mapping: interface {} is nil, not string</i> <i><br></i>  <i>6 // extended syntax with logical variable ok</i> <i><br></i>  <i>8 // doesn't panic, instead sets ok false when an assertion is false</i> <i><br></i>  <i>9 // now we can safely use s as string)</i> <br><br>  <b><i>sandbox: <a href="https://play.golang.org/p/bl-O3lJrixF">panic with shortened syntax</a> , <a href="https://play.golang.org/p/CLLyXQWyrgF">secure extended syntax</a></i></b> <br><br><blockquote>  <i>Additional syntax note: Type assertion can be used with either a short syntax (which panics if an assertion fails) or an extended syntax (which uses the logical value OK to indicate success or failure).</i>  <i>I always recommend taking the extended one instead of the shortened one, since I prefer to check the variable OK, rather than deal with panic.</i> </blockquote><br><br><h3>  Type T Approval </h3><br>  The execution of a type <code>x.(T)</code> statement with an interface of type <code>T</code> confirms that <code>x</code> implements the interface <code>T</code>  Thus, you can ensure that the interface value implements the interface, and only if it is, can you use its methods. <br><br><img src="https://habrastorage.org/webt/jl/ps/k7/jlpsk7f8m1bj-7jhwbgmzigsqea.png"><br>  <i>(5 ... // assert that x implements the resolver interface</i> <i><br></i>  <i>6 ... // here we can safely use this method)</i> <br><br>  To understand how this can be used, let's look at <code>pkg/errors</code> again.  You already know this error batch, so let's delve into the <code>errors.Cause(err error) error</code> function. <br><br>  This function receives an error and extracts the innermost error that it carries (one that no longer serves as a wrapper for another error).  This may seem primitive, but there are many great things you can learn from this implementation: <br><br><img src="https://habrastorage.org/webt/kj/uy/rm/kjuyrm3rxxgtqt-8a6_cd1bvsqg.png"><br>  source: <a href="">pkg / errors</a> <br><br>  The function receives the value of the error, and it cannot assume that the argument it receives <code>err</code> is a wrapper error (supported by the <code>Cause</code> method).  Therefore, before calling the <code>Cause</code> method, you must make sure that you are dealing with an error that implements this method.  By performing a type statement in each iteration of the for loop, you can verify that the <code>cause</code> variable supports the <code>Cause</code> method, and can continue to extract internal errors from it until you find an error that does not have <code>Cause</code> . <br><br>  By creating a simple local interface that contains only the methods you need, and applying a statement to it, your code is separate from other dependencies.  The argument you receive does not have to be a known structure, it just has to be a mistake.  Any type that implements the <code>Error</code> and <code>Cause</code> methods will do.  Thus, if you implement the <code>Cause</code> method in your type of error, you can use this function with it without slowing down. <br><br>  However, there is one minor flaw to keep in mind: the interfaces are subject to change, so you should carefully maintain the code so that your statements are not violated.  Remember to define your interfaces where you use them, keep them slim and neat, and you will be fine. <br><br>  Finally, if you only need one method, it is sometimes more convenient to make a statement on an anonymous interface that contains only the method you rely on, that is, <code>v, ok := x.(interface{ F() (int, error) })</code> .  Using anonymous interfaces can help separate your code from possible dependencies and protect it from possible changes in interfaces. <br><br><h3>  Approval with a specific type T and Type Switch </h3><br><br>  I anticipate this section by introducing two similar error handling patterns that suffer from several flaws and pitfalls.  This does not mean that they are not common.  Both can be handy tools in small projects, but they do not scale well. <br><br>  The first one is the second version of the type statement: the type <code>x.(T)</code> statement is fulfilled <code>x.(T)</code> with a specific type <code>T</code>  He claims that the value of <code>x</code> is of type <code>T</code> , or it can be converted to type <code>T</code> <br><br><img src="https://habrastorage.org/webt/mh/c5/qy/mhc5qyqfrrnhpct7wyfzhhpflju.png"><br>  <i>(2 // we can use v as mypkg.SomeErrorType)</i> <br><br>  The other is the <a href="https://golang.org/doc/effective_go.html">Type Switch</a> pattern.  The Type Switch combines a switch statement with a type statement using the reserved <code>type</code> keyword.  They are especially common in error handling, where knowledge of the basic type of error variable can be very useful. <br><br><img src="https://habrastorage.org/webt/on/iz/ji/onizji38uqjzltxqord4icmmvoq.png"><br>  <i>(3 // processing ...</i> <i><br></i>  <i>5 // processing ...)</i> <br><br>  The big drawback of both approaches is that they both lead to the binding of code with their dependencies.  Both examples should be familiar with the <code>SomeErrorType</code> structure (which obviously should be exported) and should import the <code>mypkg</code> package. <br>  In both approaches, when handling your errors, you should be familiar with the type and import its package.  The situation is exacerbated when you are dealing with errors in the wrappers, where the cause of the error may be an error arising from an internal dependency that you do not know about and should not know about. <br><br><img src="https://habrastorage.org/webt/vz/xz/zq/vzxzzqe6qajcsroflsuy0mjt5jk.png"><br>  <i>(7 // processing ...</i> <i><br></i>  <i>9 // processing ...)</i> <br><br>  Type Switch distinguish between <code>*MyStruct</code> and <code>MyStruct</code> .  Therefore, if you are not sure whether you are dealing with a pointer or an actual instance of the structure, you will have to provide both options.  Moreover, as with conventional switches, the cases in the Type Switch do not fail, but unlike the usual Type Switch, the use of <code>fallthrough</code> forbidden in the Type Switch, so you have to use a comma and provide both options, which is easy to forget. <br><br><img src="https://habrastorage.org/webt/pe/1y/g7/pe1yg7one8orth5kvcdguqtpteo.png"><br><br><h2>  Summarize </h2><br>  That's all!  You are now familiar with the bugs and must be prepared to eliminate any bugs that your Go application may throw (or actually return) on your way! <br>  Both <code>errors</code> packages represent simple but important approaches to errors in Go, and if they suit your needs, they are an excellent choice.  You can easily implement your own error structures and take advantage of Go error handling by combining them with <code>pkg/errors</code> . <br><br>  When you scale simple errors, the proper use of type assertions can be a great tool for handling various errors.  Either by using Type Switch, or by stating the behavior of the error and checking the interfaces that it implements. <br><br><h2>  What's next? </h2><br>  Error handling in Go is now very relevant.  Now that you have the basics, you may be wondering what will happen to us in the future to handle Go errors! <br><br>  The next version of Go 2 pays a lot of attention to this, and you can already have a look at the <a href="">draft</a> .  In addition, during <a href="https://www.dotgo.eu/">dotGo 2019,</a> Marcel van Lohuizen had a great conversation on a topic that I just cannot recommend - <a href="https://www.youtube.com/watch%3Fv%3DSeVxmQl9Wmk">‚ÄúThe values ‚Äã‚Äãof GO 2 errors today</a> . <a href="https://www.youtube.com/watch%3Fv%3DSeVxmQl9Wmk">‚Äù</a> <br><br>  Obviously, there are many more approaches, tips and tricks, and I cannot include them all in one post!  Despite this, I hope you like it, and I will see you in the next issue of the <i><a href="https://medium.com/gett-engineering/before-you-go-go-bf4f861cdec7">‚ÄúBefore I Go Go‚Äù series</a></i> ! <br><br>  And now, traditionally, we are waiting for your comments. </div><p>Source: <a href="https://habr.com/ru/post/453806/">https://habr.com/ru/post/453806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453796/index.html">Do people need mathematics?</a></li>
<li><a href="../4538/index.html">Virtual worlds attract the attention of the tax inspectorate</a></li>
<li><a href="../45380/index.html">Bypassing J2EE or a review of Tapestry 5 framework for example blog</a></li>
<li><a href="../453800/index.html">How to solve ‚ÄúMinesweeper‚Äù (and make it better)</a></li>
<li><a href="../453804/index.html">The book "Competitiveness and concurrency on the platform .NET. Patterns of effective design "</a></li>
<li><a href="../453808/index.html">We understand the business model of the Vikings</a></li>
<li><a href="../453810/index.html">Biometric feedback</a></li>
<li><a href="../453812/index.html">Themes, styles and other</a></li>
<li><a href="../453818/index.html">GitLab 11.11: Several Responsible for Merge Requests and Improvements for Containers</a></li>
<li><a href="../45382/index.html">Genius Table - brainstorming table</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>