<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in C # 7 and already supported in Visual Studio ‚Äú15‚Äù Preview 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the release of Visual Studio ‚Äú15‚Äù Preview 4, many new C # 7 features can be tried by yourself. The main innovations of C # 7 are designed to faci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in C # 7 and already supported in Visual Studio ‚Äú15‚Äù Preview 4</h1><div class="post__text post__text-html js-mediator-article">  With the release of <a href="https://blogs.msdn.microsoft.com/visualstudio/2016/08/22/visual-studio-15-preview-4/">Visual Studio ‚Äú15‚Äù Preview 4,</a> many new C # 7 features can be tried by yourself.  The main innovations of C # 7 are designed to facilitate the work with data, simplify the code and improve performance.  From myself I‚Äôll say that C # is moving towards a functional language, adding things like tuples and pattern matching.  Not all of the new functionality works as planned, in Preview 4, in these cases it will be indicated what you can still use and how it will work in the future.  Well, let's get started. <br><a name="habracut"></a><br><h2>  Out variables </h2><br>  Now using out variables is not as easy as we would like.  Before calling a method with out arguments, you must declare the variables that will be passed to this method.  Since the values ‚Äã‚Äãare usually not assigned to these variables during the declaration (which is logical - they will still be overwritten by the method), the <i>var</i> keyword cannot be used.  You need to declare variables with their type: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintCoordinates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-comment"><span class="hljs-comment">//    p.GetCoordinates(out x, out y); WriteLine($"({x}, {y})"); }</span></span></code> </pre> <br>  In C # 7, added <i>out variables</i> that allow you to declare variables immediately in a method call: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintCoordinates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Point p</span></span></span><span class="hljs-function">)</span></span> { p.GetCoordinates(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y); WriteLine(<span class="hljs-string"><span class="hljs-string">$"(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string">, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{y}</span></span></span><span class="hljs-string">)"</span></span>); }</code> </pre><br>  The scope for such variables is an external block, which is why you can use them in the expression following the method call. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Attention:</b> In Preview 4, there are more stringent constraints on scope: out variables can only be used inside the expression where they were defined.  Therefore, in order for the above example to work, you have to wait for the next release. <br><br>  Since the out declaration of variables occurs in the same expression as passing them as method arguments, the compiler can infer their type (if there are no conflicting overloads for this method), so you can use the <i>var</i> keyword instead of type: <br><br><pre> <code class="cs hljs">p.GetCoordinates(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y);</code> </pre><br>  Out arguments are widely used in the <i>Try ...</i> family of methods, where the returned boolean value indicates the success of the operation and out arguments contain the resulting value: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintStars</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(s, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i)) { WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-string"><span class="hljs-string">'*'</span></span>, i)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { WriteLine(<span class="hljs-string"><span class="hljs-string">" -  !"</span></span>); } }</code> </pre><br>  <b>Warning:</b> In this example, <i>i is</i> used only inside the if block in which it is defined, so this example also works in Preview 4. <br><br>  One possible improvement (which does not necessarily fall into C # 7) may be the use of wildcard characters (*) instead of those out parameters that will not be used further.  For example: <br><br><pre> <code class="cs hljs">p.GetCoordinates(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> *); <span class="hljs-comment"><span class="hljs-comment">//    x</span></span></code> </pre><br><h2>  Pattern matching </h2><br>  In the seventh version of C #, the concept of a <i>pattern (pattern)</i> appears, which in general is a syntactic construct that allows you to check the correspondence of a variable to a specific pattern and extract information from it, if there is such a correspondence. <br><br>  C # 7 has the following patterns: <br><br><ul><li>  <i>Constant patterns</i> : <b>c</b> (where c is a constant C # expression);  check whether a variable is equal to this constant or not. </li><li>  <i>Templates of type</i> : <b>T x</b> (where T is a type and x is a variable);  check if the variable is of type T, and if it is, then retrieves its value into a new variable x of type T. </li><li>  <i>Var templates</i> : <b>var x</b> (where x is a variable);  this template is always calculated in true, used to create a new variable of the same type and with the same value. </li></ul><br>  This is just the beginning, and in the future we will definitely add new templates in C #.  To support the templates 2 existing language constructs were changed: <br><br><ul><li>  <b>is</b> now can be used not only with the type, but also with the template (as the right argument). </li><li>  <b>The case</b> in the <i>switch statement</i> can now use patterns, not just constants. </li></ul><br>  In the future, we will add more options for using templates. <br><br><h2>  Templates with is </h2><br>  Consider a simple example that uses both a constant pattern and a type pattern. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintStars</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "null" if (!(o is int i)) return; //   "int i" WriteLine(new string('*', i)); }</span></span></code> </pre><br>  As you can see from the example, template variables (which were declared in the template) have the same scope as out variables, so they can be used inside the external visibility unit. <br><br>  <b>Note:</b> In Preview 4, for template variables the same as for out variables, more stringent visibility rules apply, so the example will work only in future releases. <br><br>  Templates and Try methods can be used together: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i || (o <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(s, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> i)) { <span class="hljs-comment"><span class="hljs-comment">/*   i  int */</span></span> }</code> </pre><br><h2>  Switch templates and expression </h2><br>  The use of <i>switch</i> options has been expanded, now you can: <br><br><ul><li>  Use any types (not only primitive). </li><li>  Use patterns in case expressions. </li><li>  Add additional conditions to case expressions (using the <i>when</i> keyword). </li></ul><br>  Now consider an example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(shape) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Circle c: WriteLine(<span class="hljs-string"><span class="hljs-string">$"   </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{c.Radius}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">case</span></span></span><span class="hljs-function"> Rectangle s </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s.Length == s.Height</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">$"</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">{s.Length}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"> x </span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">{s.Height}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"> "</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Rectangle r: WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{r.Length}</span></span></span><span class="hljs-string"> x </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{r.Height}</span></span></span><span class="hljs-string"> "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: WriteLine(<span class="hljs-string"><span class="hljs-string">"&lt; &gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(shape)); }</code> </pre><br>  Note the following features of the new extended <i>switch</i> : <br><br><ul><li>  <i>The order of case expressions now matters.</i>  Now the matching logic is the same as for <i>catch</i> expressions: the first order of the expression that satisfies the condition will be selected.  Therefore, in this example, it is important that a more specific condition for a square comes before a more general condition for a rectangle; if you swap them, the condition for a square will never work.  In such cases, the compiler comes to the rescue, which will mark the explicit unreachable conditions (as well as for the <i>catch</i> ).  This change is not a change to an existing behavior: until C # 7, the order in which <i>case</i> expressions were executed was not defined. <br><br></li><li>  <i>The default condition is always last calculated.</i>  Even though the <i>null</i> condition is after it, the default condition will be checked after it.  This was done to support existing logic, but it is good practice to make the default condition last. <br><br></li><li>  <i>A null condition at the end is achievable.</i>  This is because the type template follows the current logic of the <i>is</i> operator and does not work for <i>null</i> .  Due to this behavior, <i>null</i> will not be mapped to the first type pattern;  you must explicitly specify a pattern for it or leave the logic for the silence condition. </li></ul><br>  The scope for pattern variables declared in a <i>case</i> is the <i>switch</i> expression. <br><br><h2>  Tuples </h2><br>  Sometimes you want to return several values ‚Äã‚Äãfrom a method.  None of the currently available methods looks optimal: <br><br><ul><li>  Out parameters: the syntax looks overloaded (even if you use the innovations discussed above), not applicable to asynchronous methods. <br><br></li><li>  System.Tuple &lt;...&gt;: again it looks verbose and requires the creation of an additional object. <br><br></li><li>  A separate class for each such case: too much code for a type, the only purpose of which is a temporary grouping of several values. <br><br></li><li>  The dynamic object: performance loss and no type checking at compile time. </li></ul><br>  To simplify this task, tuples and tuple literals have been added to C # 7: <br><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) LookupName(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> id) <span class="hljs-comment"><span class="hljs-comment">//   -  { ... //   return (first, middle, last); //   }</span></span></code> </pre><br>  The method now returns 3 strings combined into a tuple.  The calling code can use them as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = LookupName(id); WriteLine(<span class="hljs-string"><span class="hljs-string">$" </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{names.Item1}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{names.Item3}</span></span></span><span class="hljs-string">."</span></span>);</code> </pre><br>  The names of the fields <i>Item1, Item2, ...</i> are the default names for each tuple, however, it is possible to give the data combined into a tuple better names: <br><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> first, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> middle, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> last) LookupName(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> id) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Now the elements of the tuple can be accessed as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = LookupName(id); WriteLine(<span class="hljs-string"><span class="hljs-string">$" </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{names.first}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{names.last}</span></span></span><span class="hljs-string">."</span></span>);</code> </pre><br>  You can also specify element names in the literal tuple immediately: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (first: first, middle: middle, last: last); <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Tuples can be assigned to each other if the names of their elements do not match: the main thing is that the elements themselves can be assigned to each other.  Restrictions will be added in the future, mainly for tuple literals that will signal errors such as randomly reversed element names, etc.  In Preview 4, there are no such restrictions yet. <br><br>  Tuples are a significant type, and their elements are mutable open fields.  Tuples can be compared for equality: two tuples are equal (and have the same hash code) if all constituent elements are equal to each other in pairs (and have the same hash code).  This behavior makes tuples useful not only for returning multiple values ‚Äã‚Äãfrom a method.  For example, if you need a dictionary with a composite key, use a tuple as a key.  If you need a list where there should be several values ‚Äã‚Äãat each position, it also uses a list of tuples.  (From the translator: do not take this as a guide to using tuples in 100% situations, sometimes a simple class with a couple of properties will better express your intentions and will be easier to support in the future). <br><br>  <b>Note:</b> Tuples in their work rely on types that are not already in Preview 4, but you can add them to your project using NuGet (do not forget to select ‚ÄúInclude prerelease‚Äù and specify ‚Äúnuget.org‚Äù as ‚ÄúPackage source‚Äù), package called <i>System.ValueTuple</i> . <br><br><h2>  Unpacking Tuples </h2><br>  Another way to work with a tuple is to unpack it, which is to assign its elements to new variables: <br><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> first, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> middle, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> last) = LookupName(id1); <span class="hljs-comment"><span class="hljs-comment">// deconstructing declaration WriteLine($" {first} {last}.");</span></span></code> </pre><br>  You can also use the <i>var</i> keyword instead of the type for each variable: <br><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> middle, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> last) = LookupName(id1); <span class="hljs-comment"><span class="hljs-comment">// var </span></span></code> </pre><br>  Or even place a <i>var</i> in front of the brackets: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> (first, middle, last) = LookupName(id1); <span class="hljs-comment"><span class="hljs-comment">// var </span></span></code> </pre><br>  You can also unpack a tuple into already declared variables: <br><br><pre> <code class="cs hljs">(first, middle, last) = LookupName(id2); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  You can not only unpack a tuple, any type can be unpacked.  To do this, it must have a method of the following form: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T1 x1, ..., </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tn xn</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre><br>  Out parameters correspond to the values ‚Äã‚Äãthat will be assigned as a result of unpacking.  Why are out parameters and not tuples used?  So that you can have several method overloads with a different number of parameters. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Point</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { X = x; Y = y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deconstruct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { x = X; y = Y; } } (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myX, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myY) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">//  Deconstruct(out myX, out myY);</span></span></code> </pre><br>  This approach will allow you to create a "symmetric" constructor and unpacking method. <br>  As for the out variables, we plan to add wildcard characters to ignore some return parameters. <br><br><pre> <code class="cs hljs">(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myX, *) = GetPoint(); <span class="hljs-comment"><span class="hljs-comment">//    myX</span></span></code> </pre><br>  <b>Warning:</b> It is still unknown whether wildcards will be added in C # 7. <br><br><h2>  Local functions </h2><br>  Sometimes an auxiliary function only makes sense within the single method in which it is called.  Now this function can be declared inside the method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fibonacci</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(x)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Fib(x).current; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previous) Fib(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> (p, pp) = Fib(i - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (p + pp, p); } }</code> </pre><br>  The arguments of the external method and its local variables are available for the local function, as well as for lambda expressions. <br><br>  As another example, consider the method implemented as an iterator.  In this case, such a method usually requires a non-eager wrapper method to validate the arguments (because the iterator itself is not called until the MoveNext method is called). <br><br>  With the help of local functions, this problem is solved more elegantly than usual: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;T&gt; Filter&lt;T&gt;(IEnumerable&lt;T&gt; source, Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; filter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(source)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filter == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(filter)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Iterator(); <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> source) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filter(element)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element; } } } }</code> </pre><br>  If the <i>Iterator</i> method were an ordinary private method, then it could have been called accidentally, without checking the arguments.  In addition, it would need to pass the same arguments to the Filter method. <br><br>  <b>Caution:</b> In Preview 4, local functions must be declared before the call.  In the future, this restriction will be relaxed: local functions can be called after all local variables used by them are assigned values. <br><br><h2>  Literal improvements </h2><br>  C # 7 now has the ability to add <b>_</b> as a delimiter to numeric literals: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-number"><span class="hljs-number">123</span></span>_456; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0xAB</span></span>_CD_EF;</code> </pre> <br>  Separator can be added anywhere between the numbers, it does not affect the value. <br>  Also in C # 7, binary literals appeared: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">0b1010</span></span>_1011_1100_1101_1110_1111;</code> </pre><br><h2>  Local variables and return values ‚Äã‚Äãby reference. </h2><br>  Now you can not only pass the parameters to the method by reference (using the <i>ref</i> keyword), but also return the data from the method by reference, and also save it to the local variable by reference. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] numbers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numbers.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numbers[i] == number) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> numbers[i]; <span class="hljs-comment"><span class="hljs-comment">//     ,      } } throw new IndexOutOfRangeException($"{nameof(number)}  "); } int[] array = { 1, 15, -39, 0, 7, 14, -12 }; ref int place = ref Find(7, array); //   ,   7   place = 9; //  7  9 WriteLine(array[4]); //  9</span></span></code> </pre><br>  Now it will be convenient to transfer references to specific places in large data structures.  For example, in a game, information is contained in a large pre-allocated array of structures (to avoid pauses for garbage collection).  Now methods can return a reference to one of such structures, with the help of which the calling code can read and modify this structure. <br><br>  In order to work with links safely, the following restrictions were introduced: <br><br><ul><li>  You can only return links that are safe to return: references to the objects passed to the method and references to the fields of the objects. </li><li>  Variables are initialized with a specific reference and do not change in the future. </li></ul><br><h2>  Expansion of the list of types returned by asynchronous methods </h2><br>  Until today, <i>async</i> methods could return only <i>void</i> , <i>Task</i> or <i>Task &lt;T&gt;</i> .  C # 7 now has the ability to create types that can also be returned by the asynchronous method.  For example, you can create a <i>ValueTask &lt;T&gt;</i> structure that will help you avoid creating a <i>Task &lt;T&gt;</i> object when the result of an asynchronous operation is already available.  For many asynchronous scenarios, for example, where buffering is used, this approach can significantly reduce the number of memory allocations and thus improve performance. <br><br>  Of course, you can come up with other situations in which Task-like objects will be useful.  Proper creation of these types will not be an easy task, so we do not expect a large number of developers to create them, but we think that in various frameworks they will be useful and the calling code can simply use <i>await</i> , as it is now for Task. <br><br>  <b>Warning:</b> In Preview 4, these types are not yet available. <br><br><h2>  More class members in the form of expressions </h2><br>  Methods and properties in the form of expressions (expression bodied members), which appeared in C # 6, were often used, but not all types of members of a class could be so declared.  Now support for setters, getters, constructors and destructors has been added to C # 7: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConcurrentDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = GetId(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> =&gt; names.TryAdd(id, name); <span class="hljs-comment"><span class="hljs-comment">//  ~Person() =&gt; names.TryRemove(id, out *); //  public string Name { get =&gt; names[id]; //  set =&gt; names[id] = value; //  } }</span></span></code> </pre><br>  This is an example of a new functionality added by the community, not by the compiler development team!  Hurray, open source! <br><br>  <b>Warning:</b> In Preview 4, support for these class members is not available. <br><br><h2>  Throw expressions </h2><br>  Throwing an exception in the middle of an expression is not so difficult: just call the method that does it.  But in C # 7, you can now use <i>throw</i> as part of the expression: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> =&gt; Name = name ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(name); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parts = Name.Split(<span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parts.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? parts[<span class="hljs-number"><span class="hljs-number">0</span></span>] : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"No name!"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLastName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); }</code> </pre><br>  <b>Warning:</b> In Preview 4, such expressions are not yet available. <br><br><h2>  Conclusion </h2><br>  Although it‚Äôs still far from the release of C # 7, you can already play with most of the new features and understand where C # and .Net generally move (as for me, C # takes some of the features from functional languages, and this often makes the code more readable and less verbose. But everywhere you need to know when to stop, of course). </div><p>Source: <a href="https://habr.com/ru/post/311112/">https://habr.com/ru/post/311112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311102/index.html">Intelligence services and not only: how to protect your application from backdoors</a></li>
<li><a href="../311104/index.html">YT: why does Yandex need its own MapReduce-system and how it works</a></li>
<li><a href="../311106/index.html">How to choose a cloud provider?</a></li>
<li><a href="../311108/index.html">How to connect a library to a project using maven</a></li>
<li><a href="../311110/index.html">YouTrack 7.0 Release: New Agile Concept, Gantt Chart, and More</a></li>
<li><a href="../311114/index.html">The book Spark for Professionals: Modern Patterns of Big Data Processing</a></li>
<li><a href="../311116/index.html">Seminar "Operation of the data center: working with contractors"</a></li>
<li><a href="../311118/index.html">GoTo school projects: recommendation system for a news portal</a></li>
<li><a href="../311120/index.html">Virtual Private Cloud: Image Preparation</a></li>
<li><a href="../311122/index.html">How it works: MegaFon card</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>