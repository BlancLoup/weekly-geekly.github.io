<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Attack on the black box. Reverse engineering of virtualized and mutated code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Protecting your own software from reverse engineering is a rather old problem, which once tormented the hearts of many shareware developers and not on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Attack on the black box. Reverse engineering of virtualized and mutated code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/54d/014/e99/54d014e992834814448fd8ba4e3e2ee4.png"><br><br>  Protecting your own software from reverse engineering is a rather old problem, which once tormented the hearts of many shareware developers and not only.  Usually, a protector is used for such purposes, but no matter how tough the protector is, there will always be people who will cut it and crack it.  However, recently, protectors have begun to apply code modification technologies (mutation and virtualization), which allow us to make a mess out of the original algorithm that looks like a black box.  And indeed there are people who are confident that the virtualization and mutation of the executable code by modern commercial protectors is a kind of panacea.  It‚Äôs clear that any security person will rather grin and disagree with this statement, because people who know the bitter price of security will most likely perceive any hints of perfect protection as a myth and a marketing fairy tale.  In this article I will talk about my own experience and vision of the study of the black box of commercial protectors and possible attacks on it.  I hope an understanding of the shortcomings of such technologies will help you to put them into practice more rationally and efficiently or not at all. <a name="habracut"></a><br><br><h5>  0x00.  Parsing code protection mechanisms </h5><br>  First, let's define the technologies that we will explore: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Mutation is an obfuscation method of code, in which the initial control flow graph is broken by additional vertices, branches, supplemented with garbage instructions, cycles, without violating the original algorithm of the program.  Often, original instructions are mutated into a subset of other instructions that perform the same work. <br><br>  2. Virtualization is a code obfuscation method, in which the initial instructions of the algorithm are translated into instructions of the virtual machine generated by the protector.  A code is embedded in the place of the original algorithm, which at run time passes intermediate instructions to the input to the virtual machine interpreting them. <br><br>  Both methods complicate both static and dynamic analysis of executable code, and often protectors allow for a combination of methods. <br><br>  Further in the article I will consider free demo versions of two protectors: <a href="http://vmpsoft.com/">VMProtect</a> , <a href="http://www.safengine.com/en-us">Safengine</a> , they allow you to mutate, virtualize and combine both obfuscation methods. <br><br>  For the imposition of technology mutations and code virtualization protectors provide the following methods: <br><br>  1. At the development stage, through special markers (SDK) <br>  The developer of the software marks in the source code a fragment of the protected code with special functions from the SDK of the protector, then after compilation, during the installation of the protector, these areas will be detected, cut and obfuscated. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ VMProtectMutate(<span class="hljs-string"><span class="hljs-string">"Critical_code_mut"</span></span>); ... <span class="hljs-comment"><span class="hljs-comment">// critical code here VMProtectEnd(); return 0; }</span></span></code> </pre>  <i>Example of marking source code with VMProtect markers</i> <br><br>  2. At the protection stage, via debug files <br>  Directly during the installation of the protector, debug files (pdb, map) are read and based on them the map of the application objects is determined.  Next, the developer chooses which functions need to be protected and how, after which they are completely cut from the code and processed. <br><br>  Why is the protected code cut?  The fact is that when a code is diluted, its size increases significantly, and therefore it is impossible to fit new instructions in the original segment, therefore, cutting the code into its own memory section is applied. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43f/502/a86/43f502a8681b091013fef72406420a29.png"><br>  <i>A simplified mutation scheme for the executable code of the function void Test () {printf ("Hello");</i>  <i>}</i> <br><br><h5>  0x01.  Advantages and disadvantages of protectors </h5><br>  The obvious advantage of the mutation is of course the impossibility of a visual study of the algorithm.  At first glance, before a researcher, there is just a plate with a mountain of spaghetti, which is extremely difficult to disassemble into a manual one, which is what modern protectors place on bets. <br><br>  Equally important is the combination of various techniques of anti-debugging, anti-patching, anti-cheating, mutation, etc.  In the aggregate, all this leads to a complication of the analysis processes, but does not stop them. <br><br>  The disadvantages of such technologies are also missing.  The first of which is the loss of performance, because the mutable code is increased hundreds or even thousands of times.  Not less it concerns also virtualization, usually the virtual computer is much heavier than the mutated code.  And if you combine both approaches, you get manic bloated code.  Moreover, overhead costs do not always justify such obfuscation, the use of mutating technologies is one-sidedly aimed at complicating the restoration of the original graph of program execution. <br><br>  Here is an example of tracing a primitive function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"This is protected message #1\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"This is protected message #2\n"</span></span>); }</code> </pre><br>  Before mutation: <br><div class="spoiler">  <b class="spoiler_title">Trace log</b> <div class="spoiler_text"><pre>  main 00405A2A CALL 004059F0 ESP = 0018FEE0
 main 004059F0 PUSH EBP ESP = 0018FEDC
 main 004059F1 MOV EBP, ESP EBP = 0018FEDC
 main 004059F3 SUB ESP, 40 ESP = 0018FE9C
 main 004059F6 PUSH EBX ESP = 0018FE98
 main 004059F7 PUSH ESI ESP = 0018FE94
 main 004059F8 PUSH EDI ESP = 0018FE90
 main 004059F9 PUSH OFFSET 0040ED10 ESP = 0018FE8C
 main 004059FE CALL DWORD PTR DS: [&lt;&amp; MSVCR100D.printf&gt;] EAX = 00000012, ECX = 84CB6CA9, EDX = 7418F4B8
 main 00405A04 ADD ESP, 4 ESP = 0018FE90
 main 00405A07 PUSH OFFSET 0040ECF8 ESP = 0018FE8C
 main 00405A0C CALL DWORD PTR DS: [&lt;&amp; MSVCR100D.printf&gt;] EAX = 00000014
 main 00405A12 ADD ESP, 4 ESP = 0018FE90
 main 00405A15 POP EDI ESP = 0018FE94
 main 00405A16 POP ESI ESP = 0018FE98
 main 00405A17 POP EBX ESP = 0018FE9C
 main 00405A18 MOV ESP, EBP ESP = 0018FEDC
 main 00405A1A POP EBP ESP = 0018FEE0, EBP = 0018FF30
 main 00405A1B RETN ESP = 0018FEE4 </pre></div></div><br>  After mutation by Safengine protector: <br><div class="spoiler">  <b class="spoiler_title">Trace log</b> <div class="spoiler_text"><pre>  main 00405A2A CALL 004059F0 ESP = 0018FEE0
 main 004059F0 JMP 004C9C6A
 main 004C9C6A JMP 004C8391
 main 004C8391 CALL 004C82D6 ESP = 0018FEDC
 main 004C82D6 LEA ESP, [ESP + 2] ESP = 0018FEDE
 main 004C82DA LEA ESP, [ESP + 2] ESP = 0018FEE0
 main 004C82DE PUSH EBP ESP = 0018FEDC
 main 004C82DF NEG BP EBP = 001800D0
 main 004C82E2 JMP 004C812E
 main 004C812E MOV EBP, ESP EBP = 0018FEDC
 main 004C8130 STC
 main 004C8131 SUB ESP, 40 ESP = 0018FE9C
 main 004C8134 CALL 004C8006 ESP = 0018FE98
 main 004C8006 JMP SHORT 004C7F96
 main 004C7F96 LEA ESP, [ESP + 4] ESP = 0018FE9C
 main 004C7F9A PUSH EBX ESP = 0018FE98
 main 004C7F9B CALL 004C7F80 ESP = 0018FE94
 main 004C7F80 LEA ESP, [ESP + 4] ESP = 0018FE98
 main 004C7F84 PUSH ESI ESP = 0018FE94
 main 004C7F85 JMP SHORT 004C7FB6
 main 004C7FB6 PUSH EDI ESP = 0018FE90
 main 004C7FB7 PUSH 0040ED10 ESP = 0018FE8C
 main 004C7FBC CALL DWORD PTR DS: [40E19C] EAX = 00000012, ECX = 93D2AD8F, EDX = 7418F4B8
 main 004C7FC2 JMP SHORT 004C7FA0
 main 004C7FA0 STC
 main 004C7FA1 JMP SHORT 004C7FDA
 main 004C7FDA ADD ESP, 4 ESP = 0018FE90
 main 004C7FDD CALL 004C7FC4 ESP = 0018FE8C
 main 004C7FC4 LEA ESP, [ESP + 4] ESP = 0018FE90
 main 004C7FC8 PUSH 0040ECF8 ESP = 0018FE8C
 main 004C7FCD CALL 004C7FE2 ESP = 0018FE88
 main 004C7FE2 MOV BYTE PTR SS: [ESP], CH
 main 004C7FE5 JMP SHORT 004C7FEB
 main 004C7FEB LEA ESP, [ESP + 4] ESP = 0018FE8C
 main 004C7FEF CALL DWORD PTR DS: [40E19C] EAX = 00000014
 main 004C7FF5 SETPE BH EBX = 7EFD0100
 main 004C7FF8 XCHG BL, BH EBX = 7EFD0001
 main 004C7FFA INC EBX EBX = 7EFD0002
 main 004C7FFB JMP SHORT 004C805A
 main 004C805A ADD ESP, 4 ESP = 0018FE90
 main 004C805D POP EDI ESP = 0018FE94
 main 004C805E MOV ESI, 4B536EDD ESI = 4B536EDD
 main 004C8063 MOV SI, WORD PTR SS: [ESP] ESI = 4B530000
 main 004C8067 JMP SHORT 004C801E
 main 004C801E LEA EBX, [CDDFCA2F] EBX = CDDFCA2F
 main 004C8024 POP ESI ESP = 0018FE98, ESI = 00000000
 main 004C8025 CALL 004C8008 ESP = 0018FE94
 main 004C8008 POP WORD PTR SS: [ESP] ESP = 0018FE96
 main 004C800C MOV BX, WORD PTR SS: [ESP + 1] EBX = CDDF0000
 main 004C8011 XCHG BYTE PTR SS: [ESP], BL EBX = CDDF004C
 main 004C8014 JMP SHORT 004C8040
 main 004C8040 LEA ESP, [ESP + 2] ESP = 0018FE98
 main 004C8044 POP EBX EBX = 7EFDE000, ESP = 0018FE9C
 main 004C8045 JMP SHORT 004C802A
 main 004C802A MOV ESP, EBP ESP = 0018FEDC
 main 004C802C LEA EBP, [EDI + EAX] EBP = 00000014
 main 004C802F MOV BP, 3200 EBP = 00003200
 main 004C8033 MOV EBP, CEF73787 EBP = CEF73787
 main 004C8038 JMP 004C80ED
 main 004C80ED POP EBP ESP = 0018FEE0, EBP = 0018FF30
 main 004C80EE RETN ESP = 0018FEE4
 -------- Logging stopped </pre><br></div></div><br>  In the given example, the code mutation is performed at the lowest level of complexity.  Safengine allows you to increase this complexity up to 254 times, which ultimately can inflate your code of 10 instructions into a garbage collection that is a couple of times longer than the original program size, which is quite redundant. <br><br>  Also to the disadvantage can be attributed cases of damage to the program, which unfortunately in my memory were.  It is one thing if such failures occur in a normal program, which will lead to a fall, and completely different if a fall occurs in the driver, which is completely unacceptable.  As it is known, protectors can process various executable files (exe, dll, ocx, sys). <br><br>  Marketing policy also sometimes leaves much to be desired.  Technical garbage in the ears of customers creating the illusion of security is not good.  After all, the developers of protectors do not write in the descriptions of their products that this technology is good, but there is such and such a flaw in it. <br><br><h5>  0x02.  The problem of incomplete code protection </h5><br>  Finally, we turn to the question, what prevents the protector developers from writing an even more complex and durable protection?  The answer is quite simple - incomplete information.  Receiving a binary file as input, even with debug information, there are a number of restrictions, the violation of which will lead to non-universality of the protector or damage to the protected application.  For an example of such restrictions, take a look at the structure of a regular PE application: <br><br><pre>  Raw virtual name
 ------------------------------------
 00000000 00400000 PE header
 00000200 00401000 Code sector
 00000400 00402000 Data sector
 00000600 00403000 Resources Sector
</pre><br>  The code and data in the application are placed in different sections, but there are clear links between them.  Thus, several different functions can refer to the same data block, and data can refer to other data and functions.  Moreover, this connection is not always obvious.  On this basis, protectors cannot freely manipulate the structure of the executable file: move data, expand, move functions in the source segment, etc.  Although once I tried to <a href="http://k0rnev.blogspot.com/2013/12/pe.html">expand sections of the</a> executable file, but this is a special case that is not universal.  Therefore, the protectors stack their data as follows: <br><br><pre>  Raw virtual name
 ------------------------------------
 00000000 00400000 PE header
 00000200 00401000 Code sector
 00000400 00402000 Data sector
 00000600 00403000 Protector sector
 00000800 00404000 Resources Sector
</pre><br>  The original location of the code and data does not change, although the movement of some other sectors is possible (resources, relocation, ...).  The protected code is cut out and trash instructions are placed in its place, most often these instructions are part of the mutated execution graph.  The mutated graph and the virtual machine are placed in the tread sector. <br><br>  Also, due to an increase in computational load, protectors cannot mutate all application code.  Therefore, the choice of protected areas of the code falls on the shoulders of the programmer.  But the programmer cannot always apply this overlay wisely.  For example, having covered some encryption algorithm with a mutation, the programmer will forget to mutate all the calls of this cipher, finding that the researcher will be able to get the input data of this algorithm and based on them build assumptions on the cipher device and maybe even classify or reproduce it. <br><br>  All this leads to the leakage of information from the mutated \ virtualized code and allows you to perform attacks on it.  Knowing the approximate location of data or some functions, we can track the access to them from the black box, thus, instead of unraveling the coil, we make up a phantom model of the algorithm.  Of course, this approach is far from claiming to give us a complete picture of the algorithm of the program, but in some cases this is quite enough. <br><br><h5>  0x03.  Fishing in a black box </h5><br>  A typical black box research tool is a tracer.  However, the obfuscated code track consists of 80-99% of garbage, so we need to get only useful information from this garbage.  This process is a bit like fishing.  Imagine that the trail is a lake, a tracer rod, and the tracing conditions are this bait.  Using the above disadvantages of treads, we can find the right bait and catch the right information.  Let's see how it looks in practice. <br><br>  Suppose we have the following program: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_fill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buf[i] ^= buf[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">10</span></span>]; array_fill(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Let the mutation and virtualization be superimposed on the array_fill () function.  Let's trace the call to the array_fill () function: <br><br>  Original steps: <b>230</b> <br>  Number of steps after obfuscation VMProtect: <b>83924</b> <br>  Number of steps after obfuscation Safengine: <b>250382</b> <br><br>  As you can see from the figures, it‚Äôs simply unrealistic to disassemble the route manually.  Therefore, we use the method of fishing. <br><br>  Imagine that we know nothing about the array_fill () function.  By examining main () we can say for sure that its sub-call accepts the address of the buffer and its size at the input, after which, according to some algorithm, the buffer is filled with information.  Therefore, we will give our tracer a rule according to which we will log only read / write access to the buffer transferred to the function.  The result for all three variants of applications will be the same: <br><div class="spoiler">  <b class="spoiler_title">Trace log</b> <div class="spoiler_text"><pre>  main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7700, ECX = 0018FF34
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7701, ECX = 0018FF35
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF34
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF35
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7701, ECX = 0018FF35
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7702, ECX = 0018FF36
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF35
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF36
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7703, ECX = 0018FF36
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7703, ECX = 0018FF37
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF36
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF37
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7700, ECX = 0018FF37
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7704, ECX = 0018FF38
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF37
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF38
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7704, ECX = 0018FF38
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7705, ECX = 0018FF39
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF38
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF39
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7701, ECX = 0018FF39
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7706, ECX = 0018FF3A
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF39
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3A
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7707, ECX = 0018FF3A
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7707, ECX = 0018FF3B
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3A
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3B
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7700, ECX = 0018FF3B
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7708, ECX = 0018FF3C
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3B
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3C
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7708, ECX = 0018FF3C
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7709, ECX = 0018FF3D
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3C
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF3D </pre></div></div><br>  As can be seen, regardless of the degree of code mutation and the amount of garbage, we were able to get a clean route describing all calls to the buffer.  But can we restore the original algorithm from it?  Let's try. <br><br>  And so, if you peer into the track, a cycle becomes visible (this can be seen from the repeated calls to the code at 004B7898): <br><br><pre>  ;  1 step
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7700, ECX = 0018FF34
 ;  2 step
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7701, ECX = 0018FF35
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF34
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF35
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7701, ECX = 0018FF35
 ;  3 step
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7702, ECX = 0018FF36
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF35
 main 004B7A8E MOV AL, BYTE PTR DS: [ECX] EAX = 004B7A89, ECX = 0018FF36
 main 004B7898 MOV BYTE PTR DS: [ECX], AL EAX = 004B7703, ECX = 0018FF36
 ... </pre><br>  and there are only 10 such steps, which corresponds to the size of our buffer.  Then everything is quite simple, knowing what values ‚Äã‚Äãare taken and what are put back, our algorithm of work lies with us almost in the palm of your hand.  The only thing you need to guess here is the application of the XOR operation, but in this case it is absolutely not difficult. <br><br>  Of course, this example is artificial, but in practice we have to deal with more complex algorithms with nested calls and implicit logic, obtaining information about which can be ten times more complicated.  In such situations, more complex tracers, deobfuscators, DBI, etc. are used.  Nevertheless, it all comes down to extracting information from traders and analyzing it.  Knowing the addresses that the algorithm can access, we collect enough useful information about it. <br><br><h5>  0x04.  Analysis of nested calls </h5><br>  Equally important information that can be pulled out of the black box is information about nested calls.  These can be WinAPI calls, library functions, functions of the application itself.  Such information would help us to study in more detail the internal structure and dependencies of the protected algorithm. <br><br>  In the simplest case, to analyze nested calls, we can use known information about the structure of the executable file.  That is, knowing in which segment the mutated code is located, it is possible to track all exits from this segment that will correspond to the calls of external functions.  And this will actually work for library functions, but problems may arise for calling the program's own functions.  As I said somewhere above, cutting out the protected code, in its place the protector can put a part of its own code (a mutated graph, a piece of a virtual machine).  Thus, if the execution of the code goes from the protector section to the application code section, there is no guarantee that this is a call to the nested function, and not the execution of a part of the mutated graph. <br><br>  The solution to this problem is again quite probabilistic.  First, we need a flexible tracer, for example, you can use the <a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool">Intel Pin</a> framework, the last time I used the tracer built into OllyDbg.  Secondly, we need to create competent tracing rules that will allow us to log only nested calls, excluding garbage located in the code section.  If we want to define a call to a library function, we just need to create a rule that will fix the transfer of control beyond the memory to the module under study.  In most cases, this will be the transfer of control to some library, although in some non-standard situations the transfer of control can be performed with some base-independent protector code.  But we will not consider such special cases.  However, what to do with nested calls in the program itself? <br><br>  Alternatively, nested functions can be defined by the prolog signature.  Compilers usually give functions a fairly patterned look, which you can hook on. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22d/9a1/02f/22d9a102f2f709e84a0e1ce51873e96a.png"><br>  <i>Template function prologue</i> <br><br>  That is, when returning control from the obfuscated code (tread section), we can check the presence of Int3 and Retn instructions located before the intended prologue in the application code section and also verify the prolog with pre-prepared signatures.  This will not always help, since the compiler can stuff anything into the code, especially after optimization, but this is more than nothing. <br><br>  I also noticed one small flaw in obfuscation with Safengine protector, which may be present in other protectors, but not in VMProtect.  The disadvantage is that if the protector mutates some function and there is a call to another mutated function, the nested function is not called in the mutated code, but through an adapter (jmp instruction) which is located at its original address.  This is also a leakage of information from the mutated code and can be used to create a tracer rule.  Although in VMProtect, for example, the nested mutable function will be called immediately in the tread segment, not allowing us to define the nested call in this way.  Perhaps this flaw exists only in the demo version of Safengine. <br><br>  I did not begin to clog the article with the source code of the tracer on Intel Pin, but if you like the article, you can write a separate article about the tracer. <br><br><h5>  0x05.  Recovery graph execution </h5><br>  We were all around and around, trying to avoid a complete analysis of the mutated code, but deobfuscation and devirtualization are far from a myth.  Just in fact, such technologies are quite complex and are not written on the knee.  I think experts from universities and anti-virus laboratories with might and main have already mastered this area and have a rich set of tools for their implementation.  Unfortunately, I‚Äôm not very familiar with the practice of applying such technologies and I don‚Äôt have much to say about them, except that they exist and that it‚Äôs cool :) <br><br>  If you have any knowledge and experience in this matter I would be grateful if you throw a couple of references in the comments. <br><br><h5>  0x06.  Conclusion </h5><br>  As you can see, the black box actually turns out to be not so black.  By collecting bits of information, we can partially restore the logic of the protected algorithm and sometimes in sufficient volume. <br><br>  In general, I think it is best to unlock the potential of using virtualization technologies and mutations can only specialized compilers.  After all, the compiler, unlike the protector, has almost complete information about the protected code and can easily manipulate the location and appearance of the protected code.  If you implement a set of hints for the compiler, you can help the programmer to choose the degree of obfuscation complexity for certain functions and methods, which will ensure a more efficient distribution of protection and therefore the load. <br><br>  Finally, if you want to test your skills in reverse obfuscated code, I suggest solving <a href="http://forum.reverse4you.org/showthread.php%3Ft%3D1731%26p%3D7113">this crackme</a> . <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/225963/">https://habr.com/ru/post/225963/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225935/index.html">In-Memory OLTP in SQL Server 2014. Part II</a></li>
<li><a href="../225945/index.html">We kill the "bell" from Google Chrome in the tray</a></li>
<li><a href="../225947/index.html">SwiftKey for Android. Now free</a></li>
<li><a href="../225951/index.html">Google bought Skybox microsatellite company for 500 million</a></li>
<li><a href="../225961/index.html">Managing Mozilla Firefox via GPO</a></li>
<li><a href="../225965/index.html">Setting up server operation on CentOS with 2 gateways and balancing between them</a></li>
<li><a href="../225969/index.html">Understanding NSURL / NSURLComponents</a></li>
<li><a href="../225971/index.html">From linux admin to python programmer or how and why I changed my profession</a></li>
<li><a href="../225973/index.html">Nintendo announced the designer "make your game Super Mario"</a></li>
<li><a href="../225975/index.html">Revealing the secret. Secret Architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>