<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We work with Compound File</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have been working with compound files for a long time, for more than 15 years. For all the time I had enough information about the pros and cons of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We work with Compound File</h1><div class="post__text post__text-html js-mediator-article">  I have been working with compound files for a long time, for more than 15 years.  For all the time I had enough information about the pros and cons of compound files. <br>  On the one hand, they are really a very convenient storage of information that allows data to be changed on the fly, on the other hand, this convenience is partially leveled by the speed of access to data. <br><br>  In general, what are commonly used compound files for? <br>  For everything that needs to be stored in a certain container (NoSQL subset). <br>  For example, files of old versions of Microsoft Office from 97 to 2003 inclusively (consisting actually of several dozen files) were stored just in a composite file.  Now they are also stored, only ZIP is used as a container. <br><br>  MSI installation packages are also composite files, and even the folder thumbnail cache file uses this format. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      True for the same Word, there is a whole complex of utilities (Recovery for Word, Word Recovery Toolbox, Munsoft Easy Word Recovery) that restore, or at least attempt to repair, damaged documents.  Conclusions can do yourself. <br>  Although, with proper work with compound files, the problem of their damage can be solved (and I will show how). <br><br>  And, of course, the undoubted advantage of this format is that inside the vault a full-fledged file system is emulated with its files and folders. <br><br>  By the way, nuance.  Before starting the article, I conducted a survey on several forums, and it turned out that the vast majority of developers do not work with compound files, and for a simple reason, they did not hear what it is. <br>  Now we close this gap. <br><a name="habracut"></a><br><h4>  1. General information about compound files and their creation </h4><br>  I will not tell you about the structure and internal format of the compound file, this is unnecessary. <br>  First you need to "touch" him - what he is all about. <br><br>  Therefore, let's start by creating a new compound file by calling the StgCreateDocfile. <br>  In uses, we include this pair of ActiveX and AxCtrls (useful). <br>  And now we write: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Code: HRESULT)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Succeeded(Code) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> RaiseLastOSError; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TestFilePath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; WideBuff: WideString; Root: IStorage; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TestFilePath := ExtractFilePath(ParamStr(<span class="hljs-number"><span class="hljs-number">0</span></span>)) + <span class="hljs-string"><span class="hljs-string">'..\data\simple.bin'</span></span>; ForceDirectories(ExtractFilePath(TestFilePath)); WideBuff := TestFilePath; CheckHResult(StgCreateDocfile(@WideBuff[<span class="hljs-number"><span class="hljs-number">1</span></span>], STGM_CREATE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> STGM_WRITE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> STGM_SHARE_EXCLUSIVE, <span class="hljs-number"><span class="hljs-number">0</span></span>, Root));</code> </pre> <br>  First of all, I will pay attention to the flags. <br>  STGM_CREATE and STGM_WRITE - these two flags are used to create a new compound file, and the presence of the STGM_WRITE flag in this case is mandatory (otherwise no focus will work). <br><br>  <b>IMPORTANT:</b> <br>  But with the third flag STGM_SHARE_EXCLUSIVE everything is much more cunning.  Its presence is required always and everywhere, except for opening a file in ‚Äúread only‚Äù mode, as discussed in the second chapter. <br>  You can check it yourself in <a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">IDA Pro Freeware</a> . <br>  The StgCreateDocfile calls the DfOpenDocfile function, from which VerifyPerms is called, which will have this check: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b1e/d55/932/b1ed559321ed4001b463d273a3e814f0.png"></div><br>  At the address 72554E62 there is a check for the presence of this flag, and if it is suddenly not detected, the opening error will return.  Thus, the simultaneous opening of a compound file for writing more than once is prohibited. <br><br>  It was somewhat surprising for me to see such a check in the third ring, and I even (for the sake of experiment) scored it, after which I was able to open the file for recording two times at a time.  But - correctly written to both files, of course, did not work.  :) <br><br>  In fact, this is quite a competent decision, due to the very format of data storage, but I will focus on it a little later, towards the end of the article. <br><br>  If all checks were successful and the return code StgCreateDocfile is S_OK, then in the fourth parameter of this function, the IStorage interface will return to us, indicating the root element of the compound file, with which all further work will occur. <br>  What can we do next? <br><br>  For example, create a new file in the root (we still have a file system) and write some block of data into it. <br>  We write the following function: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Storage: IStorage; AName: WideString; Data: AnsiString)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Stream: IStream; OS: TOleStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckHResult(Storage.CreateStream(@AName[<span class="hljs-number"><span class="hljs-number">1</span></span>], STGM_WRITE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> STGM_SHARE_EXCLUSIVE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Stream)); OS := TOleStream.Create(Stream); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> OS.WriteBuffer(Data[<span class="hljs-number"><span class="hljs-number">1</span></span>], Length(Data)); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> OS.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In it, first of all we create a new ‚Äúfile‚Äù by calling the function Storage.CreateStream.  It is almost identical to the previously discussed StgCreateDocfile, only as a result, returns the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380034(v%3Dvs.85).aspx">IStream</a> interface, through which the contents of the file will be <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380034(v%3Dvs.85).aspx">handled</a> . <br><br>  Pay attention to the flags: STGM_SHARE_EXCLUSIVE must be specified, and the second must go (if created) either STGM_WRITE or STGM_READWRITE, but since  the composite file was created using the STGM_WRITE flag ‚Äî it is used. <br><br>  For convenience, working with IStream is carried out through the TOleStream interlayer class, which records data. <br><br>  This, of course, is not a crucial point, and you could use the call to the function Write of the ISequentialStream interface, which is inherited from IStream, but it is easier to work with the TOleStream class. <br>  Call the previously implemented function: <br><br><pre> <code class="delphi hljs">WriteFile(Root, <span class="hljs-string"><span class="hljs-string">'RootFile'</span></span>, <span class="hljs-string"><span class="hljs-string">'First file data'</span></span>);</code> </pre><br>  As a result, a file with the name RootFile and the contents of ‚ÄúFirst file data‚Äù will appear in the root. <br><br>  <b>IMPORTANT:</b> <br>  There is one nuance here. The names of files and folders inside a compound file cannot exceed the length of 31 Unicode characters (in fact, not more than 32, but we should not forget about the terminating zero). <br><br>  Yes, exactly, a folder or file can be called ‚Äú123‚Äù, but it is impossible: ‚ÄúMy long file name and many more digits‚Äù.  Moreover, the specification is a set of characters that can not be used in the name (from 0 to 0x1F). <br><br>  Probably, you will say - why such restrictions, and suddenly I want to deploy a huge branched file system with a huge depth of nesting? <br>  So it is not a question, in contrast to the standard file restrictions, the MAX_PATH constant does not affect you. <br>  500 subfolders named ‚Äúmy big name‚Äù? <br>  It's easy, we still work with the virtual file system - create what you want.  :) <br><br>  Let's return to our sheep: we will create a folder in the root. <br><br><pre> <code class="delphi hljs">CheckHResult(Root.CreateStorage(<span class="hljs-string"><span class="hljs-string">'SubFolder'</span></span>, STGM_WRITE <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> STGM_SHARE_EXCLUSIVE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Folder));</code> </pre><br>  The code is almost the same as calling Storage.CreateStream, only this time we will get another IStorage interface pointing to the folder we just created. <br><br>  We can create a new file in it right now: <br><br><pre> <code class="delphi hljs">WriteFile(Folder, <span class="hljs-string"><span class="hljs-string">'SubFolderFile'</span></span>, <span class="hljs-string"><span class="hljs-string">'Second file data'</span></span>);</code> </pre><br>  For this, we‚Äôll specify the first parameters not Root, which refers to the root, but the newly created Forder. <br><br>  <b>IMPORTANT:</b> <br>  And now the nuance, if we close the application right now - the data may not be saved. <br>  Here, in fact, not everything is so simple, for example, on my home machine, this behavior is reproduced guaranteed, and on the working machine, exactly the opposite. <br><br>  To ensure that the data is saved, the following code must be executed: <br><br><pre> <code class="delphi hljs">CheckHResult(Root.Commit(STGC_DEFAULT));</code> </pre><br>  After executing this code, all data will be guaranteed to be saved to a file on disk.  Well, if you suddenly "suddenly" changed your mind, you can undo all the changes that occurred from the previous commit by calling the following code: <br><br><pre> <code class="delphi hljs">CheckHResult(Root.Revert);</code> </pre><br>  By the way, about closing the file. <br>  This is done by banal nibbling of the root, after which, when calling @IntfClear for an interface in the Root variable, all other interfaces will be destroyed in a hierarchical order. <br>  What we have left? <br><br>  Aha, more methods CopyTo / MoveElementTo / EnumElements and more ... <br>  We will deal with them a little later, but for now you can open the archive attached to the article and look at the implementation of the code described above <a href="">in the file ".. \ simple \ StorageCreateDemo.dpr"</a> <br><br>  Now we try to read all this trouble. <br><br><h4>  2. Reading the compound file </h4><br>  Let's create a new project, connect ActiveX and AxCtrls again and write the opening code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> TestFilePath: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; WideBuff: WideString; Root: IStorage; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TestFilePath := ExtractFilePath(ParamStr(<span class="hljs-number"><span class="hljs-number">0</span></span>)) + <span class="hljs-string"><span class="hljs-string">'..\data\simple.bin'</span></span>; WideBuff := TestFilePath; CheckHResult(StgOpenStorage(@WideBuff[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, STGM_READ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> STGM_SHARE_DENY_WRITE, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Root));</code> </pre><br>  Since we do not need access to the record, we use the STGM_READ flag and here we have the choice to use STGM_SHARE_DENY_WRITE or still leave STGM_SHARE_EXCLUSIVE (one of the two flags must be). <br><br>  The result of executing the code is the variable Root, of the IStorage class, indicating the root. <br><br>  How would you search for files in the specified folder on the disk? <br>  Naturally, a recursive directory traversal using FindFirstFile. <br>  In this case, we have something similar: this is the EnumElements method of the IStorage interface, whose call looks something like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Enum: IEnumStatStg; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckHResult(Storage.EnumElements(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Enum));</code> </pre><br>  Roughly speaking, this is an analogue of the FindFirstFile call, but here we get not the handle with which we can work further, but the IEnumStatStg interface. <br><br>  There is one interesting point on which is to draw your attention. <br>  This interface (when used) will return the TStatStg structure, one of the fields of which will be the parameter pwcsName, the type of which is <b>POleStr</b> . <br><br>  Zimus this situation understood? <br><br>  Of course, this is a potential memo, because OLE never knows about the existence of our native memory manager and allocates a block for storing this string with its own means, through the IMalloc interface. <br><br>  If we do not handle this situation, the application's memory will flow like a Victoria Falls, but it will be fun to look at the memory consumption counters.  :) <br><br>  Therefore, the first step is to get a link to an instance of this interface: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CoGetMalloc(<span class="hljs-number"><span class="hljs-number">1</span></span>, ShellMalloc) &lt;&gt; S_OK) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (ShellMalloc = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception.Create(<span class="hljs-string"><span class="hljs-string">'CoGetMalloc failed.'</span></span>);</code> </pre><br>  We will need it to free the memory allocated by us. <br>  Like this: <br><br><pre> <code class="delphi hljs">ShellMalloc.Free(TmpElement.pwcsName);</code> </pre><br>  Further one more nuance: <br>  The data type in the returned TStatStg can be the following: <br><br><ul><li>  STGTY_STORAGE is a folder </li><li>  STGTY_STREAM is a file </li></ul><br>  All other options are purely service and we are not interested. <br><br>  We look how it happens: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enumerate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Root: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Storage: IStorage)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Enum: IEnumStatStg; TmpElement: TStatStg; ShellMalloc: IMalloc; Fetched: Int64; Folder: IStorage; AFile: IStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// ..   OLE,     IMalloc if (CoGetMalloc(1, ShellMalloc) &lt;&gt; S_OK) or (ShellMalloc = nil) then raise Exception.Create('CoGetMalloc failed.'); //        CheckHResult(Storage.EnumElements(0, nil, 0, Enum)); //       Fetched := 1; while Fetched &gt; 0 do if Enum.Next(1, TmpElement, @Fetched) = S_OK then //  ( ) if ShellMalloc.DidAlloc(TmpElement.pwcsName) = 1 then begin //    Write('Found: ', Root, '\', AnsiString(TmpElement.pwcsName)); //    case TmpElement.dwType of //   -       STGTY_STREAM: begin Writeln(' - file: ', sLineBreak); CheckHResult(Storage.OpenStream(TmpElement.pwcsName, nil, STGM_READ or STGM_SHARE_EXCLUSIVE, 0, AFile)); ShowFileData(AFile); Writeln; end; //   -           STGTY_STORAGE: begin Writeln(' - folder'); CheckHResult(Storage.OpenStorage(TmpElement.pwcsName, nil, STGM_READ or STGM_SHARE_EXCLUSIVE, nil, 0, Folder)); Enumerate(Root + '\' + string(TmpElement.pwcsName), Folder); end; else Writeln('Unsupported type: ', TmpElement.dwType); end; // ,      -    ShellMalloc.Free(TmpElement.pwcsName); end; end;</span></span></code> </pre><br>  And now let's see what happens when reading the file created in the first chapter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/74d/206/9e6/74d2069e63cf4ed3883fc7bfe180d0ec.png"></div><br>  Actually, this is exactly the data that we recorded in the first chapter. <br><br>  The code for this example is in the archive for the article, <a href="">following the path ".. \ simple \ StorageReadDemo.dpr"</a> <br><br>  Now let's see how to work with it a little more convenient. <br><br><h4>  3. Wrap class </h4><br>  At one time, I developed a small module (a thousand lines with comments), which implemented several classes that take into account all the nuances of working with composite files and provide a more convenient mechanism for working. <br>  You can find it in the archive, <a href="">in the folder ".. \ StorageReader \ FWStorage.pas"</a> . <br><br>  It has several shortcomings.  The fact is that I abandoned its development a very long time ago, so on Unicode Delphi versions it will issue vornings related to working with strings. <br><blockquote>  [dcc32 Warning] FWStorage.pas (860): W1057 Implicit string cast from 'AnsiString' to 'string' <br>  [dcc32 Warning] uStgReader.pas (102): W1057 Implicit string cast from 'ShortString' to 'string' </blockquote><br>  But at the same time it is quite functional and these vornings will not affect its performance in any way.  (To be honest - too lazy to comb them too). <br><br>  You can use this module at your discretion with the following reservations. <br><br>  If you suddenly change the code of the classes (add ryushechki, correct errors if you find one), and then upload it to the Internet, the name of the author of the module should be saved in the header. <br>  I‚Äôm not accompanying this module anymore (it‚Äôs outdated for me), so I‚Äôll reject requests for improvement. <br>  So, from this module, we are interested in the TFWStorage class, which is used to work with a compound file, and the TFWStorageCursor class, which is a wrapper on IStorage. <br>  To begin with, I will list the methods of these classes, and then I will give an example of working with them. <br>  So, the TFWStorage class, it is intended only for working with a file and provides several utilitarian methods: <br><br><ul><li>  OpenFile, OpenFileReadOnly - well, everything is clear here, just open the compound file.  Both methods create and return a TFWStorageCursor class pointing to the root directory of the file. </li><li>  CloseFile - respectively, close the previously opened file. </li><li>  ReConnect - reopen the previously opened file.  Also returns TFWStorageCursor. </li><li>  Compress - compresses the specified file, removing fragmented blocks.  The compressible file should not be open. </li><li>  IsStgValidBinaryFmt - checks if everything is in order with the specified file and if its structure is not destroyed.  The specified file should not be open. </li><li>  ForceStorage - creates or opens a folder inside a compound file at the specified path.  The path must be specified from the root, "\" is used as a separator.  Example: "file path \ Subfolder1 \ subfolder2 \ subsubfolder".  Returns TFWStorageCursor. </li></ul><br>  Those.  in principle, its main task is to give us an instance of the TFWStorageCursor class, with the help of which the main work with the composite file will occur. <br><br>  His methods are as follows: <br><br><ul><li>  CreateStorage creates a new folder inside the current one and returns a TFWStorageCursor pointing to the newly created folder. </li><li>  OpenStorage - opens a folder inside the current one.  Returns a TFWStorageCursor pointing to an open folder. </li><li>  DeleteStorage - deletes the specified folder inside the current one. </li><li>  Copy - copies the specified file or folder from the current folder to another.  The folder to which the copy is made is transmitted as a class TFWStorageCursor. </li><li>  MoveTo is similar to the Copy method, only the copied item is deleted from the current folder. </li><li>  CreateStream - creates an empty file in the current folder. </li><li>  ReadStream - reads the contents of the specified file. </li><li>  WriteStream - writes new data to the file.  If the file with the same name does not exist - creates it. </li><li>  DeleteStream - deletes a file in the current folder. </li><li>  FlushBuffer - saves changes. </li><li>  Rename - renames the specified file or folder in the current folder. </li><li>  Enumerate - lists the contents of the current folder and returns the result as an array of TFWStorageEnum. </li><li>  Backward - returns a link to the parent folder, and itself is destroyed (unless Root). </li><li>  Release - destroys the current class. </li><li>  IsRoot ‚Äî Indicates whether the current class points to the root folder of a compound file. </li><li>  GetName - returns the name of the current folder. </li><li>  Path - returns the path to the current folder. </li><li>  Storages - a list of all child subfolders. </li></ul><br>  As you can see, there are no wrappers for IStream, work with this interface is assigned to the methods CreateStream, ReadStream, WriteStream. <br><br>  In the TFWStorageEnum array, which is returned by the Enumerate method, you do not need to free the memory allocated for pacsName, this has already been done, and you are working with a copy of the data stored in the memory allocated by the native memory manager. <br>  The only question can cause the method Backward, as so - why he destroys himself? <br><br>  And now I will show, it is really convenient. <br>  Here, for example, if we needed to open such a path: ‚Äúthe path to the file \ Subfolder1 \ subfolder2 \ subsubfolder‚Äù, which had to be done using the usual interfaces from the second chapter: <br>  Open the file itself and get the IStorage interface pointing to the root, then get IStorage for the first folder, then for the second and third, which is also needed for the ‚Äúsubsubfolder‚Äù. <br>  These are as many as 4 items that need to be stored somewhere. <br><br>  When using TFWStorage, everything becomes much simpler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Path: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; Storage: TFWStorage; Root, Folder: TFWStorageCursor; Data: TStringStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Storage := TFWStorage.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//     Path := ExpandFileName(ExtractFilePath(ParamStr(0)) + '..\data\test.bin'); //    Storage.OpenFile(Path, True, Root); //          Storage.ForceStorage(Path + '\Subfolder1\subloder2\subsubfolder', Folder); Data := TStringStream.Create; try //      Data.WriteString('new file data.'); //             while Folder &lt;&gt; Root do begin Folder.WriteStream(Folder.GetName + '_new_file.txt', Data); //       Folder.Backward(Folder); end; //   Root.FlushBuffer; finally Data.Free; end; finally Storage.Free; end; end;</span></span></code> </pre><br>  That's all, in terms of programming it turned out very convenient. <br><br>  Well, now write something more serious, namely the editor of the contents of the compound file. <br><br>  Open a new project and create something like this in it: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/069/bb5/fb6/069bb5fb6ec04644bc089c18ad13fa08.png"></div><br><div class="spoiler">  <b class="spoiler_title">In private, add three variables:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FCurrentFileName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; FStorage: TFWStorage; FRoot: TFWStorageCursor;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">In the form constructor we write the following code:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     FCurrentFileName := ExpandFileName(ExtractFilePath(ParamStr(0)) + '..\data\simple.bin'); //   FStorage := TFWStorage.Create; //   OpenFile(False); end;</span></span></code> </pre><br></div></div><br>  Now we write the file opening procedure itself, it is simple: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CreateNew: Boolean)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  ,      FStorage.CloseFile; //    FStorage.OpenFile(FCurrentFileName, CreateNew or not FileExists(FCurrentFileName), FRoot); Caption := FCurrentFileName; //       ShowStorageData(FRoot); end;</span></span></code> </pre><br>  So far, so simple, yes?  In principle, the rest of the code will be unpretentious. <br><br>  Now we write the procedure for displaying the contents of the folder on the screen: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowStorageData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AStorage: TFWStorageCursor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ACaption: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; AIndex: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ListView1.Items.Add <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Caption := ACaption; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AIndex <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>: ImageIndex := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ImageIndex := <span class="hljs-number"><span class="hljs-number">0</span></span>; SubItems.Add(<span class="hljs-string"><span class="hljs-string">'Folder'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ImageIndex := <span class="hljs-number"><span class="hljs-number">1</span></span>; SubItems.Add(<span class="hljs-string"><span class="hljs-string">'File'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Data, : // -1 -     // 0 -  // 1 -  //       Data := Pointer(AIndex); end; end; var AData: TFWStorageEnum; I: Integer; begin ListView1.Items.BeginUpdate; try ListView1.Items.Clear; //  ,         // (   - ) if not AStorage.IsRoot then AddItem('..', -1); //     AStorage.Enumerate(AData); //     ListView for I := 0 to AData.Count - 1 do AddItem( string(AData.ElementEnum[I].pacsName), Byte(AData.ElementEnum[I].dwType = STGTY_STORAGE)); finally ListView1.Items.EndUpdate; end; end;</span></span></code> </pre><br>  If everything is done correctly, then run the project, this will open the file ".. \ data \ simple.bin" that we created in the first chapter and everything should look something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8ce/182/3e5/8ce1823e522c450ab1bfff463d77aa91.png"></div><br>  Now let's navigate through our repository. <br>  Its logic will be simple: <br><br><ul><li>  Double click on the folder - open the folder and show its contents. </li><li>  double click on the file - open the file content editor. </li><li>  Double click on the element ".." - go to the next level. </li></ul><br>  To do this, in the OnDblClick event handler of the ListView, we write the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListView1DblClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//     -  if ListView1.Selected = nil then Exit; //    Data   case Integer(ListView1.Selected.Data) of -1: //     begin //       FRoot.Backward(FRoot); //    ShowStorageData(FRoot); end; 0: //   EditFile; 1: //   begin //      FRoot.OpenStorage(AnsiString(ListView1.Selected.Caption), FRoot); //    ShowStorageData(FRoot); end; end; end;</span></span></code> </pre><br>  Now you can walk around our store with double clicks.  :) <br><br>  Editing the file will do as follows.  We will connect a new form to the project, add a save button and a cancel button to it, and also TMemo in which the contents of the file will be displayed, after which we will write the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditFile</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Buff: TMemoryStream; Data: AnsiString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Buff := TMemoryStream.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//    FRoot.ReadStream(AnsiString(ListView1.Selected.Caption), Buff); //     if Buff.Size &gt; 0 then begin SetLength(Data, Buff.Size); Buff.Read(Data[1], Buff.Size); end; //    frmEdit := TfrmEdit.Create(Self); try //   Memo   frmEdit.Memo1.Text := string(Data); //   if frmEdit.ShowModal &lt;&gt; mrOk then Exit; //    Memo Buff.Clear; Data := AnsiString(frmEdit.Memo1.Text); if Length(Data) &gt; 0 then Buff.Write(Data[1], Length(Data)); //    FRoot.WriteStream(AnsiString(ListView1.Selected.Caption), Buff); //    FRoot.FlushBuffer; finally frmEdit.Release; end; finally Buff.Free; end; end;</span></span></code> </pre><br>  Well, here we have almost a full-fledged editor, it remains to add functionality for the buttons on top of the form. <br><br><div class="spoiler">  <b class="spoiler_title">Handlers for creating a new compound file and opening an existing one look like this:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnCreateDFaseClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SaveDialog1.Execute <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCurrentFileName := SaveDialog1.FileName; OpenFile(True); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnOpenDBaseClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> OpenDialog1.Execute <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCurrentFileName := OpenDialog1.FileName; OpenFile(False); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">This will be the code for creating a new folder and deleting an existing one:</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnAddFolderClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NewFolderName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; Tmp: TFWStorageCursor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> InputQuery(<span class="hljs-string"><span class="hljs-string">'New folder'</span></span>, <span class="hljs-string"><span class="hljs-string">'Enter folder name'</span></span>, NewFolderName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRoot.CreateStorage(AnsiString(NewFolderName), Tmp); FRoot.FlushBuffer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ShowStorageData(FRoot); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnDelFolderClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Application.MessageBox( PChar(Format(<span class="hljs-string"><span class="hljs-string">'Delete folder: "%s"?'</span></span>, [ListView1.Selected.Caption])), <span class="hljs-string"><span class="hljs-string">'Delete folder'</span></span>, MB_ICONQUESTION <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> MB_YESNO) = ID_YES <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRoot.DeleteStorage(AnsiString(ListView1.Selected.Caption)); FRoot.FlushBuffer; ShowStorageData(FRoot); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">And the same, only for the buttons for opening and deleting a file</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnAddFileClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> NewFileName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> InputQuery(<span class="hljs-string"><span class="hljs-string">'New file'</span></span>, <span class="hljs-string"><span class="hljs-string">'Enter file name'</span></span>, NewFileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRoot.CreateStream(AnsiString(NewFileName)); FRoot.FlushBuffer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; ShowStorageData(FRoot); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btnDelFileClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Application.MessageBox( PChar(Format(<span class="hljs-string"><span class="hljs-string">'Delete file: "%s"?'</span></span>, [ListView1.Selected.Caption])), <span class="hljs-string"><span class="hljs-string">'Delete file'</span></span>, MB_ICONQUESTION <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> MB_YESNO) = ID_YES <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRoot.DeleteStream(AnsiString(ListView1.Selected.Caption)); FRoot.FlushBuffer; ShowStorageData(FRoot); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br>    ,      :) <br><br>   ,  -   DOC ?  :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f20/178/93d/f2017893d61342e5961c464bae5b7c16.png"></div><br>  , ,       ,      ,          , <a href="">  : "..\StorageReader\"</a> <br><br><h4> 4.  Compound File </h4><br>   ,     ,       ,       . <br><br>    ‚Äî        . <br><br>             . <br>        ‚Äî  . <br>     ,       .  :)) <br>      ,       ,         . <br><br>   ,    ,  : <br><br><ul><li>  ‚Üí  ‚Üí  </li><li>  ‚Üí  ‚Üí  ‚Üí  </li><li>   ‚Üí  ‚Üí  ‚Üí  ‚Üí  </li></ul><br>         ( )       ‚Äî   ,         ,   . <br><br>            ,    (      ¬´//¬ª) ,  ,  INI     (- thumbs.db),      ,     ,         ? <br><br>                 ,          . <br>    ,               . <br><br>   :      ,            ,   . <br>  : ¬´     .  -, 1, 142 1 ‚Äî 163 10,  22, 0¬ª. <br><br>  ‚Äî         31 ,     : ¬´    ¬ª. <br> ,  : ¬´ ¬ª. <br><br>     ,         ,   -   . <br><br>       : <br>   ,    ( ‚Äî   ),              .      ¬´Properties¬ª,          (  , ,       )       (        1024  ‚Äî  ,        ,       ). <br>        ‚Äî        ‚Äî ¬´Data¬ª,      . <br><br>        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a60/a09/4e2/a60a094e282c44ae85fed09a534547eb.png"></div><br> ,           ? <br>    GUID      ¬´¬ª        31   .  :) <br><br>       31  ,  -           . <br><br>  ,           5 ? <br> -,   ,  5 ,   .    ,  ,       ‚Äî     .  :) <br><br>     ,  ¬´ ¬ª ‚Äî           .         ¬´¬ª    ‚Äî  . <br><br>         : ¬´,       ,      ?¬ª. <br><br>         ,      (  ),       ‚Äî      ?!!! <br><br>   ,        . <br>  ,      <b> 2  </b>   200     ( ).      , ‚Ä¶ <br>   ‚Äî   ,    ,        (    ). <br><br>   ,     :             50 ,       /   . <br><br> , , ,    - . <br>       ,   ,       ,   . ,      Firebird/Interbase,     ‚Äî MS SQL/Olracle,     ADO.     ,        . <br><br>  ‚Äî ,   ,   . <br><br>             . <br>  - ,      OpenStorage,    ,          ‚Äî     . <br><br>       TFWStorage     : ReConnect ‚Äî         ForceStorage,       ,    . <br><br> :                  .       ()         ( ‚Äî   MSDN). <br><br>    ,     ,      : ¬´  ,      ¬ª. <br><br>  . <br>  , ,                   StgOpenStorage. <br> ‚Ä¶ <br><br>   ‚Äî -   4 ,      . <br>     ,          .      . <br><br> ,        ‚Äî       ,  (   ) ‚Äî    MSDN         ,     .     ,           . <br><br> ,      : <br>     -   ()    ‚Äî    ,  EnumElements.  IEnumStatStg,       .      CreateStream    ,    . <br><br>        .   DestroyElement         CreateStream,      : ¬´-      ¬ª. <br><br>       ,        ,    . <br><br><h4> 5.    RAW  </h4><br>  ,      : ,  ,       ?       ? <br><br>    .           ,        ,   . <br><br>  ,              NTFS        ,      API ‚Äî         ?  :) <br><br>     ,       . <br><br>    , MS <a href="https://msdn.microsoft.com/en-us/library/dd942138.aspx">      </a> ,              <a href="http://poi.apache.org/poifs/fileformat.html">   POIFS</a> ,  <a href="http://en.wikipedia.org/wiki/Compound_File_Binary_Format">  Wiki</a>           POIFS (   ),         (  ). <br><br>       ,     ?  :) <br>     . <br><br> ,      ,    : <br><br><pre> <code class="delphi hljs">TPoifsFileHeader = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-comment"><span class="hljs-comment">// .   (0 x E011CFD0, 0 x E11AB1A1) _abSig: array [0..7] of Byte; // Class ID.  WriteClassStg,  GetClassFile/ReadClassStg. //  Excel   = 0 _clid: TGUID; //    . _uMinorVersion: USHORT; //    Dll/ _uDllVersion: USHORT; // 0 x FFFE ,   Intel  _uByteOrder: USHORT; //  .   9,     512  (2 ^ 9) _uSectorShift: USHORT; //  -.   6,     64  (2 ^ 6) _uMiniSectorShift: USHORT; // ,    0 _usReserved: USHORT; // ,    0 _ulReserved1: ULONG; // ,    0 _ulReserved2: ULONG; //  ,    FAT. //    7,   1,  ,   1   DIF . _csectFat: ULONG; //   ,    Property Set Storage // (  FAT Directory  Root Directory Entry) _sectDirStart: ULONG; //   . _signature: ULONG; //   -.  4096 _ulMiniSectorCutoff: ULONG; //   -FAT. //  (-2),  - . _sectMiniFatStart: ULONG; //     -FAT. 0,  -  _csectMiniFat: ULONG; //    DIF . //    7,  DIF      (-2) _sectDifStart: ULONG; //    DIF .0,   &lt; 7 _csectDif: ULONG; //   109 ,    FAT. //    7,   ,    (-1). _sectFat: array [0..108] of ULONG; end;</span></span></code> </pre><br> ,    ,    ‚Äî        . <br><br>  ,   _uSectorShift  _uMiniSectorShift   , ,      . <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitHeader</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FStream.ReadBuffer(FHeader, SizeOf(TPoifsFileHeader)); FHeader._uSectorShift := Round(IntPower(<span class="hljs-number"><span class="hljs-number">2</span></span>, FHeader._uSectorShift)); FHeader._uMiniSectorShift := Round(IntPower(<span class="hljs-number"><span class="hljs-number">2</span></span>, FHeader._uMiniSectorShift)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><div class="spoiler"> <b class="spoiler_title">   FAT,    ,        _ulMiniSectorCutoff  .</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComposeFAT</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, J, X, FatLength: Integer; FatBlock: TPoifsFatBlock; CurrentFat, Offset: Integer; XFat: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  -  FAT (   128 ) //   DIF ,  _csectFat   FatLength := FHeader._csectFat * 128; //      FAT SetLength(FFat, FatLength); //        SetLength(FFatOffset, FatLength); //   DIF ,  FAT     109  //     DIF  for I := 0 to IfThen(FHeader._csectDif &gt; 0, 108, FHeader._csectFat - 1) do begin //  FAT    128  FatBlock := TPoifsFatBlock(GetBlock(FHeader._sectFat[I])); for J := 0 to 127 do begin FFat[I * 128 + J] := FatBlock[J]; //        ,  FFatOffset[I * 128 + J] := FStream.Position - SizeOf(TPoifsBlock); end; end; // ,   DIF  if FHeader._sectDifStart = 0 then Exit; //  ,      FAT   Offset := FHeader._sectDifStart; //   XFAT     FAT  SetLength(XFat, 128); //     FAT  CurrentFat := 13951; //109 * 128 - 1 BAT for X := 0 to FHeader._csectDif - 1 do begin //     ( _uSectorShift  ) //     FStream.Position := GetBlockOffset(Offset); //    FAT  FStream.ReadBuffer(XFat[0], 128 * SizeOf(DWORD)); //      //        //        for I := 0 to 126 do begin //     ,   , //  FAT   if XFat[I] &lt; 0 then Exit; //  FAT    128  FatBlock := TPoifsFatBlock(GetBlock(XFat[I])); for J := 0 to 127 do begin Inc(CurrentFat); FFat[CurrentFat] := FatBlock[J]; FFatOffset[CurrentFat] := FStream.Position - SizeOf(TPoifsBlock); end; end; //       Offset := XFat[127]; end; end;</span></span></code> </pre><br></div></div><br>    TPoifsFatBlock,     128 Integer. <br>     GetBlockOffset  GetBlock. <br><br><div class="spoiler"> <b class="spoiler_title">    .</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBlockOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockIndex: Integer)</span></span></span><span class="hljs-function">:</span></span> Int64; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := HEADER_SIZE + FHeader._uSectorShift * BlockIndex; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Adress: Integer)</span></span></span><span class="hljs-function">:</span></span> TPoifsBlock; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FStream.Position := GetBlockOffset(Adress); FStream.ReadBuffer(Result, SizeOf(TPoifsBlock)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br>     ,    ,      _ulMiniSectorCutoff. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComposeMiniFat</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, CurrChain: Integer; TmpPosition: int64; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//        CurrChain := FHeader._sectMiniFatStart; //     (-    128 ) SetLength(FMiniFat, FHeader._csectMiniFat * 128); I := 0; while Integer(CurrChain) &gt;= 0 do begin //    TmpPosition := GetBlockOffset(CurrChain); //  ,    if TmpPosition &lt; 0 then Exit; //if TmpPosition &gt; FStream.Size then Exit; FStream.Position := TmpPosition; //   FStream.ReadBuffer(FMiniFat[I], 512 {128 * SizeOf(DWORD)}); Inc(I, 128); //      FAT CurrChain := FFat[CurrChain]; end; end;</span></span></code> </pre><br>         . <br><br>        : <br><br><pre> <code class="delphi hljs">TPoifsProperty = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-comment"><span class="hljs-comment">// 128 length //  / Caption: array[0..31] of WChar; //   CaptionSize: Word; //   STGTY_ PropertyType: Byte; //   ( TPoifsProperty    Red-Black-Tree) NodeColor: Byte; // 0 (red) or 1 (black) //      PreviousProp: Integer; //      NextProp: Integer; //      ChildProp: Integer; Reserved1: TGUID; UserFlags: DWORD; //  ATime: array [0..1] of Int64; //   FAT        StartBlock: Integer; //   Size: Integer; Reserved2: DWORD; end; TPoifsPropsBlock = array[0..3] of TPoifsProperty;</span></span></code> </pre><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadPropsArray</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, J, Len: Integer; PropsBlock: TPoifsPropsBlock; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := True; <span class="hljs-comment"><span class="hljs-comment">//     Len := 0; //    ,    Property Set Storage J := FHeader._sectDirStart; repeat //     4  Inc(Len, 4); SetLength(FPropsArray, Len); PropsBlock := TPoifsPropsBlock(GetBlock(J)); for I := 0 to 3 do FPropsArray[Len - 4 + I] := PropsBlock[I]; //      FAT J := FFat[J]; until J = ENDOFCHAIN; end;</span></span></code> </pre><br></div></div><br>       : <br><ol><li>   FAT,          . </li><li>       </li><li>   MiniFAT </li><li>     </li></ol><br>   FAT  MiniFAT? <br>             FHeader._uSectorShift,     . <br> FAT          (  ,        ). <br>  ,      1 ,     2048 ,       512  ( ). <br> -          ,    ,   10       ,   ‚Äî  . <br>  ,     ( )    FAT   StartBlock   TPoifsProperty,     ,      ,     (    FAT). <br>       ,      ,     . <br><br> ,   . <br>      .  ,    TPoifsProperty,       PreviousProp, NextProp  ChildProp,   NodeColor.  Red-Black-Tree. <br>       ,     . <br><br>      ,            . <br><br>   ,   : <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/551/c12/d6c/551c12d6c81e4f8095d870e571578913.png"></div><br>      :            (   TreeView),                   . <br><br>     ,       Extract: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FileStream := TFileStream.Create(edSrc.Text, fmOpenReadWrite); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> AFile := TPoifsFile.Create(FileStream); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-comment"><span class="hljs-comment">//      AFile.LoadFromStream; ATree := TStorageTree.Create; try //   for I := 0 to AFile.PropertiesCount - 1 do ATree.AddNode(I).Data := AFile[I]; //    FillAllChilds(0, ATree.GetNode(0).Data.ChildProp); //    TreeView1.Items.Clear; FillTree(nil, 0); //    DebugLog := TStringList.Create; try Extract(IncludeTrailingPathDelimiter(edDst.Text), 0); if DebugLog.Count &gt; 0 then DebugLog.SaveToFile(IncludeTrailingPathDelimiter(edDst.Text) + 'cannotread.log'); finally DebugLog.Free; end; finally ATree.Free; end; finally AFile.Free; end; finally FileStream.Free; end; end;</span></span></code> </pre><br>   (   )    . <br>     . <br><br>               . <br><br>  ,   N   ,           TPoifsProperty (    ,  ¬´ ¬ª). <br>         ,     . <br><br>      ,     : <br><br><ul><li> TPoifsProperty.ChildProp ‚Äî         (   ) </li><li> TPoifsProperty.PreviousProp ‚Äî        . </li><li> TPoifsProperty.NextProp ‚Äî        . </li></ul><br>      : <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/d5b/756/172/d5b756172453470992785724e4a1d49e.png"></div><br>  ,  ChildProp,  ‚Äî NextProp,  ‚Äî PreviousProp. <br>     ,           ,      . <br><br><div class="spoiler"> <b class="spoiler_title">,  ,     ,       .</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ATree: TStorageTree; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillAllChilds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RootIndex, CurrentIndex: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> SubChildIndex: Integer; RootNode, CurrNode, ChildNode: TStorageElement; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurrentIndex &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      RootNode := ATree.GetNode(RootIndex); //        CurrNode := ATree.GetNode(CurrentIndex); if CurrNode = nil then Exit; //     -  if CurrNode.Added then Exit; CurrNode.Added := True; //       ATree.AddVector(RootNode, CurrNode); //         FillAllChilds(CurrNode.ID, CurrNode.Data.ChildProp); //          SubChildIndex := CurrNode.Data.PreviousProp; while SubChildIndex &gt;= 0 do begin //  ,     FillAllChilds(RootIndex, SubChildIndex); ChildNode := ATree.GetNode(SubChildIndex); if ChildNode &lt;&gt; nil then SubChildIndex := ChildNode.Data.PreviousProp else SubChildIndex := -1; end; //       ,      SubChildIndex := CurrNode.Data.NextProp; while SubChildIndex &gt;= 0 do begin FillAllChilds(RootIndex, SubChildIndex); ChildNode := ATree.GetNode(SubChildIndex); if ChildNode &lt;&gt; nil then SubChildIndex := ChildNode.Data.NextProp else SubChildIndex := -1; end; end;</span></span></code> </pre><br></div></div><br>   ,   TStorageTree    ,        ,    <a href="">   </a> . <br>   ,      GetNode,       (       TPoifsProperty,     Data)   AddVector,      . <br><br><div class="spoiler"> <b class="spoiler_title">   ‚Äî        .</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node: TTreeNode; RootNodeIndex: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> W: WideString; TreeNode: TTreeNode; I: Integer; RootStorageNode, ChildStorageNode: TStorageElement; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    RootStorageNode := ATree.GetNode(RootNodeIndex); //     (   ) W := RootStorageNode.Data.Caption; TreeNode := TreeView1.Items.AddChildFirst(Node, W); case RootStorageNode.Data.PropertyType of STGTY_STORAGE: TreeNode.ImageIndex := 0; STGTY_STREAM: TreeNode.ImageIndex := 1; end; //      for I := 0 to RootStorageNode.VectorCount - 1 do begin // ,       (   ?) ChildStorageNode := TStorageElement(RootStorageNode.GetVector(I).SlaveNode); if ChildStorageNode = nil then Continue; //   ,      ,    if ChildStorageNode.ID &lt;&gt; RootNodeIndex then FillTree(TreeNode, ChildStorageNode.ID); end; end;</span></span></code> </pre><br></div></div><br>  . <br>     ,   ,      (    GetVector(I).SlaveNode)  ,     . <br><br> ,        ¬´Red-Black-Tree¬ª    NodeColor? <br>    .             : ¬´ ‚Äî    ¬ª.  :) <br><br>         ‚Äî     . <br>        ‚Äî       ,   . <br><br>       FAT ‚Äî          ,    ,   FAT. <br><br> ,     ¬´ ¬ª (     ,    _ulMiniSectorCutoff ): <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataFromStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChainStart: ULONG; NeedLength: DWORD; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Stream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Stream.Size := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Integer(ChainStart) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Stream.Size &lt; NeedLength) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//      FStream.Position := GetBlockOffset(ChainStart); //      ChainStart := FFat[ChainStart]; //    Stream.CopyFrom(FStream, FHeader._uSectorShift); end; //   if Stream.Size &gt; NeedLength then Stream.Size := NeedLength; end;</span></span></code> </pre><br>    -       ,         . <br> ,   ,    ,  ‚Äî   ?  :) <br><br> ,  ,    ChainStart,     .    StartBlock   TPoifsProperty. <br><br>         ,  _ulMiniSectorCutoff. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDataFromMiniStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChainStart: ULONG; NeedLength: DWORD; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Stream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MiniStreamOffset: DWORD; RealMiniStreamSector, TmpChain: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Stream.Size := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Integer(ChainStart) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Stream.Size &lt; NeedLength) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//        Ministream TmpChain := ChainStart; RealMiniStreamSector := Properties[0].StartBlock; while TmpChain &gt;= 8 do begin Dec(TmpChain, 8); RealMiniStreamSector := FFat[RealMiniStreamSector]; end; //    MiniStreamOffset := GetBlockOffset(RealMiniStreamSector); //      FStream.Position := MiniStreamOffset + (ChainStart mod 8) * FHeader._uMiniSectorShift; //       ChainStart := FMiniFat[ChainStart]; //    Stream.CopyFrom(FStream, FHeader._uMiniSectorShift); end; //   if Stream.Size &gt; NeedLength then Stream.Size := NeedLength; end;</span></span></code> </pre><br>  , ? <br> ,  ,        TmpChain    FAT.       ()     FAT   ,  TmpChain     ,        . <br><br><div class="spoiler"> <b class="spoiler_title">        ,   :</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStorageData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ANode: TStorageElement; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Stream: TStream)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ANode.Data.Size &lt; Integer(AFile.Header._ulMiniSectorCutoff) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> AFile.GetDataFromMiniStream(ANode.Data.StartBlock, ANode.Data.Size, Stream) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> AFile.GetDataFromStream(ANode.Data.StartBlock, ANode.Data.Size, Stream); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br>        ,       ,     ,      . <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems to be almost everything, the last fifth stage remains - unpacking the entire contents of the compound file into a folder.</font></font></b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; RootNodeIndex: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> W: WideString; I: Integer; RootStorageNode, ChildStorageNode: TStorageElement; F: TFileStream; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RootStorageNode := ATree.GetNode(RootNodeIndex); W := RootStorageNode.Data.Caption; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RootStorageNode.Data.PropertyType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> STGTY_STORAGE: Path := Path + W + <span class="hljs-string"><span class="hljs-string">'\'</span></span>; STGTY_STREAM: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> ForceDirectories(Path); F := TFileStream.Create(Path + W, fmCreate); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> GetStorageData(RootStorageNode, F); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> F.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> DebugLog.Add(Path + W); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> RootStorageNode.VectorCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ChildStorageNode := TStorageElement(RootStorageNode.GetVector(I).SlaveNode); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ChildStorageNode = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ChildStorageNode.ID &lt;&gt; RootNodeIndex <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Extract(Path, ChildStorageNode.ID); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, there are already no comments. </font><font style="vertical-align: inherit;">We all saw earlier - the usual algorithm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you run a project created by us and set it on some Word document, it will look like this:</font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/e39/d39/7f5/e39d397f57094649a9eb139d5b5c2c50.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And in the daddy, where we got all this, will be this: </font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/fe4/4c3/fe1/fe44c3fe169c4337bfca0820aeb3a009.png"></div><br>   , ? <br> ,   ,      ,   -    "|"        ¬´CompObj¬ª. <br><br>       OLE ,         ( 0  0x1F).          ,   ,       : ¬´cannotread.log¬ª. <br><br> ,    ,      . <br><br>      <a href="">  "..\RawStorageReader\".</a> <br><br> ,     ? <br>      ,          : "..\corrupted\corrupted_storage.bin" <br><br>  - : <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/160/68b/d9a/16068bd9ad934cbfad5aa1d5b9994fa4.png"></div><br>  ,      ,   API: <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/b2a/106/95a/b2a10695a2ce4358bad762606321af62.png"></div><br><br> ,     ,       RAW : <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/4cd/70e/ca8/4cd70eca8fe94d79a951d4a24e62460e.png"></div><br> ,  ,  : <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/e71/7ab/4c1/e717ab4c1bd64107a6887af553901001.png"></div><br>      ,    ReadBuffer   GetBlock. <br>  We will decide. <br><br><h4> 6.          . </h4><br>            ¬´¬ª   Word.    -  .  :) <br><br>       . <br><br><ul><li>      . </li><li>     ,  Word    . </li></ul><br> , ,      ,      ,    ,    ,    .  :) <br><br>           : <br><br><ul><li>   ( ,  ) </li><li>  FAT </li><li>    TPoifsProperty </li><li>      </li></ul><br>  ‚Äî  . ,               FAT,     . <br><br>  ‚Äî   . <br> ,  FAT   ,       :      ENDOFCHAIN (-2)     FAT . <br>         ENDOFCHAIN, ,  ,        ,         (   ). <br><br>   . <br> ,    FAT,     ,     ENDOFCHAIN.  , ,    ( 99   ),    ,    . <br><br>    ,        ,    ,      (  ‚Äî  ). <br><br>  : <br>         ,   ‚Äî    FAT    . <br>       RAW ,      . <br><br>       : <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Adress: Integer)</span></span></span><span class="hljs-function">:</span></span> TPoifsBlock; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BlockOffset: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> BlockOffset := GetBlockOffset(Adress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> BlockOffset &lt; FStream.Size <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FStream.Position := BlockOffset; FStream.ReadBuffer(Result, SizeOf(TPoifsBlock)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception.Create(<span class="hljs-string"><span class="hljs-string">'Wrong block offset at addres: '</span></span> + IntToStr(Adress)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose now that she checks the offsets and raise an exception, if suddenly something has not grown together. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will make the second change in the ReadPropsArray procedure, where we will more strictly control the state of the FAT array:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadPropsArray</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, J, Len, LastGood: Integer; PropsBlock: TPoifsPropsBlock; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := True; <span class="hljs-comment"><span class="hljs-comment">//     Len := 0; //    ,    Property Set Storage J := FHeader._sectDirStart; LastGood := J; repeat if J = FREESECT then begin FixFatEntry(LastGood, ENDOFCHAIN); Break; end; //     4  Inc(Len, 4); SetLength(FPropsArray, Len); //     try PropsBlock := TPoifsPropsBlock(GetBlock(J)); except FixFatEntry(LastGood, ENDOFCHAIN); Break; end; for I := 0 to 3 do FPropsArray[Len - 4 + I] := PropsBlock[I]; LastGood := J; //      FAT J := FFat[J]; if J &lt; ENDOFCHAIN then begin FixFatEntry(LastGood, ENDOFCHAIN); Break; end; until J = ENDOFCHAIN; end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Well, it remains to write the procedure FixFatEntry: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPoifsFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixFatEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FatIndex, NewValue: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> J, Offset: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    FAT  J := FatIndex mod 128; Offset := FFatOffset[FatIndex] + J * 4; //       FStream.Position := Offset; FStream.WriteBuffer(NewValue, SizeOf(Integer)); end;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is with the help of it that we will make changes to the FAT chain in the original file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's see what happened:</font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/775/5a5/3b2/7755a53b2382447fa434b04d46b76f32.png"></div><br> ‚Ä¶      :) <br> , ,  ,     . <br><br> ,    ,       FixFatEntry        FStream.WriteBuffer. <br><br>   ,     ,     ,   ,    ,     ,   . <br><br>             :) <br><br>          <a href="">  : "..\RawStorageReader\PoifsWithRepair.pas"</a> . <br><br> ,  . <br><br><h4> 7.    </h4><br>   ‚Äî    ,          . <br><br>    ,     ,    ‚Äî  ,     ,   ,   <b></b> ( , )   . <br><br>      ‚Äî       ,    . <br>  ,    ,    ? <br>    , ,       ‚Äî ,      ,     :) <br><br> , ,     : <br>  ,     , , ,  . <br>      () . <br><br> ,        ,          ,  . <br><br>   : <br>   8    (,         RAW )       473   ,     . <br>         ,   ‚Äî   150  ,      . <br>   24  ,     12   . <br> : 150000   * 24  * 12  * 8  = 345     (). <br><br>  ,      473 ¬´¬ª  (  1-2  ,   ).   (   ),      FAT (     ‚Äî  ,  ). <br>  ,        FAT-  ‚Äî     ,      UnErase  :      ? <br>       ‚Äî   ,    . <br><br> ,   ,  :     ? <br>    1   ‚Äî CD       ,    :) <br><br>  Do not believe? <br>             ( ,   )     ? <br><br>      ? <br>  ‚Äî  :       . <br>           ¬´¬ª      ‚Äî    :) <br><br>    ,      ,   ‚Äî        ,       (    ,    ). <br><br>     ,     : <br><br><ul><li>       ,        ‚Äî     ,           . </li><li>     AddVectoredExceptionHandler.        ‚Äî          SEH.     ,   ,    ‚Äî     . (     ,    False Alarm :) </li></ul><br>      ,      <a href="">  </a> . <br><br>  ,     " <a href="http://www.delphimaster.ru/"> </a> "       . <br><br> : ,       (  1024 ). ,            ,      NTFS?  :) <br><br>  Good luck :) <br><br> ‚Äî  (Rouse_)  <br><br> , 2015 </div><p>Source: <a href="https://habr.com/ru/post/254541/">https://habr.com/ru/post/254541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254527/index.html">Android - Custom View or ToggleButton 4x4</a></li>
<li><a href="../254529/index.html">Comparison of online consultants for the site: flour choice</a></li>
<li><a href="../254531/index.html">Programming Philosophy 6 - Product and Project</a></li>
<li><a href="../254533/index.html">Tarantool 1.6 - let's get started</a></li>
<li><a href="../254537/index.html">Document generator docx and xlsx</a></li>
<li><a href="../254543/index.html">Research on IT leadership factors</a></li>
<li><a href="../254545/index.html">Damage to the stack in one of the NSString methods</a></li>
<li><a href="../254549/index.html">Coub goes to strike</a></li>
<li><a href="../254551/index.html">4th generation SCADA system: AggreGate SCADA / HMI</a></li>
<li><a href="../254555/index.html">CLRium # 2 accepts DevExpress CodeRush and runs the kernel on Ubuntu Linux. And it's not a joke</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>