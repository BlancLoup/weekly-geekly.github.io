<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúWhat's new in Swift 2?‚Äù With examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift 2 focused on improving the language itself, interacting with Objective-C, and improving the performance of compiled applications. New features o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúWhat's new in Swift 2?‚Äù With examples</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fe1/e7f/4fe/fe1e7f4fe9bb42efa4fa80fd77a4895f.png"><br><br>  <b>Swift 2</b> focused on improving the language itself, interacting with Objective-C, and improving the performance of compiled applications.  New features of <b>Swift 2 are</b> presented in 6 different areas: <br><br><ul><li>  fundamental constructs of the language, such as <font color="#0000FF">enum</font> , scoping (scope), argument syntax, etc. </li><li>  <b>pattern matching</b> </li><li>  availability check </li><li>  protocol <b>extensions</b> </li><li>  <b>error handling</b> </li><li>  interaction with objective-c </li></ul><br>  I will consider the new features of Swift 2, accompanying them with examples whose code is on <a href="https://github.com/BestKora/WhatsNewInSwift2">Github</a> . <br><a name="habracut"></a><br><h2>  1. Fundamental language constructions </h2><br><h3>  No more <font color="#0000FF">println ()</font> </h3><br>  Usually we used the <font color="#0000FF">println ()</font> function to print a message on the console.  In the Swift 2 version, we will use only <font color="#0000FF">print ()</font> .  Apple combined the <font color="#0000FF">println ()</font> and <font color="#0000FF">print ()</font> functions into one.  The <font color="#0000FF">print ()</font> function, by default, prints your message with a newline character "\ n".  If you want, you can output a line without a newline: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/d2e/18f/e59/d2e18fe59894436e820fbff8ae4d81ea.png" height="117" width="500"><br><br><h3>  <font color="#0000FF">map</font> , <font color="#0000FF">filter</font> and company </h3><br>  The definition of these convenient functions and methods through the collections in Swift 1.2 was not completely consistent.  In Swift 1.2, there was no default implementation of the <font color="#0000FF">map</font> method for the <font color="#0000FF">CollectionType</font> protocol, since the default implementation of the protocol was not possible and extensions were made only for classes.  Partly for this reason, <font color="#0000FF">map</font> was defined as a method in the <font color="#0000FF">Array</font> class (which implements the <font color="#0000FF">CollectionType</font> protocol), and not defined in the <font color="#0000FF">Set</font> class (which also implements the <font color="#0000FF">CollectionType</font> protocol).  In addition to this, the global <font color="#0000FF">map</font> function was disclaimed, which took an instance of <font color="#0000FF">CollectionType</font> as the first parameter.  This created complete confusion. <br><br><pre><code class="hljs pgsql">// Swift <span class="hljs-number"><span class="hljs-number">1.2</span></span> let a: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] //    map   <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> let b = a.map{ <span class="hljs-meta"><span class="hljs-meta">$0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } //      map  map([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]) { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]) //  ,    map   <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.map{ <span class="hljs-meta"><span class="hljs-meta">$0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } //   map   <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> map(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) { <span class="hljs-meta"><span class="hljs-meta">$0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  It turned out that, depending on the type of collection, either the global <font color="#0000FF">map</font> function is used, or the <font color="#0000FF">map</font> method of this collection.  It looks inconsistent and poorly readable if a chain of transformations is used using the methods and functions of <font color="#0000FF">map</font> , <font color="#0000FF">filter</font> and <font color="#0000FF">reduce</font> . <br><br>  Now, in Swift 2, protocol extensions are allowed, therefore <font color="#0000FF">map</font> , <font color="#0000FF">filter</font> &amp; co are implemented at the protocol level for <font color="#0000FF">CollectionType</font> , as protocol extensions.  Therefore, the same methods will operate on <font color="#0000FF">Array</font> , <font color="#0000FF">Set,</font> or any other collection implementing the <font color="#0000FF">CollectionType</font> protocol. <br><br><pre> <code class="hljs bash">// Swift 2 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> a: [Int] = [1,2,3] <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> b = a.map{ <span class="hljs-variable"><span class="hljs-variable">$0</span></span> + 1 } <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> = Set([1,2,3]) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> anotherSet = set.map{ <span class="hljs-variable"><span class="hljs-variable">$0</span></span> + 1 } <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> sum = (1...100) .filter { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> % 2 != 0 } .map { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> * 2 } .reduce(0) { <span class="hljs-variable"><span class="hljs-variable">$0</span></span> + <span class="hljs-variable"><span class="hljs-variable">$1</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(sum) // prints out 5000</code> </pre><br>  We see in the example above that <font color="#0000FF">filter</font> now works on <font color="#0000FF">Range</font> .  This did not work in the previous version, because, although <font color="#0000FF">Range</font> confirmed the <font color="#0000FF">CollectionType</font> protocol, the <font color="#0000FF">filter</font> method was not implemented.  Now everywhere we have a much more understandable syntax of these methods for any collection. <br><br><h3>  Enum <font color="#0000FF">enums</font> </h3><br>  In Swift 2, <font color="#0000FF">enum</font> has sufficient <font color="#0000FF">reflection</font> information to enable their printing. <br><br><img src="https://habrastorage.org/files/b75/443/b79/b75443b79a0440b08b33fbfaa043439c.png" height="161" width="500"><br><br>  The <font color="#0000FF">print (an)</font> clause will now print <font color="#0000FF">Dragon</font> correctly, although in the previous version of Swift, the output was completely non-informative <font color="#0000FF">(Enum Value)</font> . <br><br>  Another improvement regarding <font color="#0000FF">enum</font> is that Swift now allows you to represent the associated values ‚Äã‚Äãof various types in <font color="#0000FF">enum</font> .  As an example, you can now legally present the <font color="#0000FF">Either</font> type: <br><br><img src="https://habrastorage.org/files/21c/c08/391/21cc08391030424993d2edcaf4d486ad.png" height="115" width="500"><br><br>  Now <font color="#0000FF">enum</font> can be recursive, that is, we can build a tree using <font color="#0000FF">enum</font> .  Let's look at this example: <br><br><img src="https://habrastorage.org/files/ec4/aec/156/ec4aec15656749f09af3bfd8ff300e40.png" height="63" width="380"><br><br>  We must use the <font color="#0000FF">indirect</font> keyword in front of <font color="#0000FF">case Node</font> .  And it allowed us to create a tree: <br><br><img src="https://habrastorage.org/files/cca/c07/e2f/ccac07e2ff1b479fb2d5f0d2b71ee45e.png" height="93" width="560"><br><br>  Here's what it looks like: <br><br><img src="https://habrastorage.org/files/076/0cd/dea/0760cddea2864ebe87267f0efb085ddd.png" height="142" width="340"><br><br>  Now we can create a function that recursively traverses the entire tree and adds the numbers: <br><br><img src="https://habrastorage.org/files/31f/057/1be/31f0571be45e4829be5e087b52c64987.png" height="158" width="560"><br><br>  A result of 21 must be printed. <br><br><h3>  Diagnostics. </h3><br>  In addition to this, Swift 2 brought a huge number of improvements in diagnosing errors and assumptions to correct them, such as correctly defining a developer‚Äôs attempt to modify <font color="#0000FF">var</font> using an immutable <font color="#0000FF">struct</font> method, or when the <font color="#0000FF">var</font> property never changes after initialization or when the result of a function call and etc. <br><br>  One of the simplest changes makes the code more readable.  As you know, Swift developers prefer to declare many things as constants, using <font color="#0000FF">let</font> , rather than variables, using <font color="#0000FF">var</font> .  But what if you accidentally used the keyword <font color="#0000FF">var?</font>  Or did you think that you need to change it, but did not do it?  Both Xcode 7 and Swift 2 will give you a warning that you don‚Äôt change this variable anywhere in your code - Xcode literally explores all uses of the variable and knows for sure whether you changed it or not. <br><br><h3>  Many options (Option Sets) </h3><br>  The set of options is a way of representing a set of Boolean values, and in Swift 1.x it looked like this: <br><br><pre> <code class="hljs ruby">viewAnimationOptions = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> viewAnimationOptions = .Repeat <span class="hljs-params"><span class="hljs-params">| .CurveEaseIn |</span></span> .TransitionCurlUp <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> viewAnimationOptions &amp; .TransitionCurlUp != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { ...</code> </pre><br>  This type of syntax was widely used in Cocoa, but in reality, it is only a ‚Äúrelic‚Äù of the C language. So, in Swift 2, it is removed and its own type is presented for many options, it is the <font color="#0000FF">OptionSetType</font> protocol: <br><br><img src="https://habrastorage.org/files/bb0/0ce/82d/bb00ce82d31b4edb88bb1ec14cf18339.png" height="99" width="370"><br><br>  So now the set of options can be any type of <font color="#0000FF">Set</font> or <font color="#0000FF">struct</font> , confirming the <font color="#0000FF">OptionSetType</font> protocol.  This leads to a clearer syntax when using multiple options: <br><br><img src="https://habrastorage.org/files/25c/e9f/08d/25ce9f08d771421bbf37d16aaebe3be1.png" height="180" width="360"><br><br>  The syntax does not rely on ‚Äúbit‚Äù operations, as in previous versions, and does not use <font color="#0000FF">nil</font> to represent an empty set of options. <br><br>  It should be noted that the many <font color="#0000FF">OptionSetType</font> options now rely on another feature in Swift 2, called the ‚Äúdefault‚Äù implementation implementations for protocol extensions, so simply confirming the <font color="#0000FF">OptionSetType</font> protocol, you get a default implementation, for example, for the method <font color="#0000FF">contains</font> , <font color="#0000FF">subtractInPlace</font> , <font color="#0000FF">unionInPlace</font> and other set operations.  We will look at protocol extensions later. <br><br><h3>  Functions and methods </h3><br>  The Swift 1.x syntax for declaring functions and methods was inherited from two different conventions originating from C, where the function arguments have no labels, and Objective-C, which labels the methods arguments.  So you had such declarations: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: String, encrypt: Bool)</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: String, encrypt: Bool)</span></span></span></span> { ... } save(<span class="hljs-string"><span class="hljs-string">"thing"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) widget.save(<span class="hljs-string"><span class="hljs-string">"thing"</span></span>, encrypt: <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  In Swift 2, the above code would look like this: <br><br><img src="https://habrastorage.org/files/a4c/460/b74/a4c460b74bc94d238887759efaa04d33.png" height="167" width="500"><br><br>  So the functions get the same convention as the methods: <br><br><ul><li>  implies that the name of the first argument is contained in the function name; </li><li>  subsequent arguments have labels. </li></ul><br>  However, these changes do not apply to functions imported from the C and Objective-C APIs. <br><br>  Additionally, the parameter label declaring model has become more convenient since the <font color="#0000FF">#option</font> option, which was used in Swift 1.x to denote a parameter with the same internal ( <font color="#0000FF">internal</font> ) and external ( <font color="#0000FF">external</font> ) name, has been removed. <br><br><h3>  Scoping Operators </h3><br>  The new <font color="#0000FF">do</font> clause allows developers to explicitly define the explicit scope of variables and constants.  This can be useful for re-using already declared names or for early release of some resources.  The <font color="#0000FF">do</font> clause looks like this: <br><br><img src="https://habrastorage.org/files/712/cda/e77/712cdae777b844fea155deecfa66b117.png" height="100" width="520"><br><br>  In order to avoid ambiguity with the <font color="#0000FF">do ... while</font> clause, which is presented in earlier versions of Swift 1.x, the latter was renamed to <font color="#0000FF">repeat ... while</font> in Swift 2. <br><br><h3>  UNIT testing </h3><br>  The problem with unit-testing Swift 1.x code is that Swift 1.x made you mark the <font color="#0000FF">public</font> word with all that you want unit-testing to see.  As a result, there are <font color="#0000FF">public</font> notes where they should not be.  All this is due to the fact that <b>Test Target</b> is different from <b>Application Target</b> , and files from your application that are <font color="#0000FF">internal</font> are not available for <b>Test Target</b> . <br><br>  In Swift 2, substantial unit relief has been achieved.  Xcode 7 automatically compiles Swift 2 code in a special "test" mode <br><br><img src="https://habrastorage.org/files/5e8/4f4/cb9/5e84f4cb996943998ed2b977275aaa61.png" height="192" width="570"><br><br>  to access all <font color="#0000FF">internal</font> definitions as if they are defined as <font color="#0000FF">public</font> .  This is done using the <font color="#0000FF">@testable</font> attribute when importing our module. <br><br><img src="https://habrastorage.org/files/fd7/5d4/b7f/fd75d4b7fa004c888a608b4fe15476a4.png" height="255" width="450"><br><br>  That's all it takes, and you don't need to mark anything with the word <font color="#0000FF">public</font> . <br><br>  Moreover, these changes do not affect the main release of your application, maintaining the correct behavior both in terms of performance and in terms of access control. <br><br><h2>  2. Control the order of calculations </h2><br>  Swift 2 introduced new concepts for managing the order of computation, and improved existing structures. <br><br><h3>  Offer <font color="#0000FF">guard</font> </h3><br>  The <font color="#0000FF">guard</font> clause, as well as the <font color="#0000FF">if</font> clause, executes the code depending on the Boolean value of the conditional expression.  You use the <font color="#0000FF">guard</font> clause to, if the Boolean value is <font color="#0000FF">true</font> , continue the code following the <font color="#0000FF">guard</font> clause. <br><br>  A <font color="#0000FF">guard</font> clause is essentially the inverse of an <font color="#0000FF">if</font> clause.  For <font color="#0000FF">if,</font> we write: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>  }</code> </pre><br>  For <font color="#0000FF">guard</font> , <b>true the</b> branch rises to a higher level compared to the <b>false</b> branch: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> condition <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// false  } // true </span></span></code> </pre><br>  Notice that the <b>false</b> branch should end execution in a closed context (scope), returning a value or ‚Äúthrowing‚Äù (throw) an error.  You guarantee that the code in the <b>true</b> branch will be executed only if the condition is met. <br><br>  This makes <font color="#0000FF">guard a</font> natural way to check non-fatal preconditions without using the ‚ÄúSmetri pyramid‚Äù formed by nested <font color="#0000FF">if statements</font> and without inversion of conditions. <br><br>  Let's see what a typical code path looks like when using the traditional <font color="#0000FF">if statement</font> . <br><br><img src="https://habrastorage.org/files/544/004/3e8/5440043e8702456b8db63eee5790942e.png" height="213" width="500"><br><br>  The <font color="#0000FF">jsonDict</font> dictionary is input to the <font color="#0000FF">createPersonFromJSON</font> function, and a valid instance of the <font color="#0000FF">Person</font> structure is created at the output if the corresponding information is presented in the dictionary, otherwise <font color="#0000FF">nil is</font> returned.  The function is written as it would appear in Swift 1.2 - using the <font color="#0000FF">if let</font> construct.  There are a couple of ‚Äúpain points‚Äù in this code.  First, the ‚Äúturning off‚Äù of the direction of correct calculations from the main code, that is, the ‚Äúsuccessful‚Äù (in terms of condition) direction of calculations turned out to be ‚Äúnested‚Äù in the <font color="#0000FF">if let</font> clause.  Secondly, the <font color="#0000FF">createPersonFromJSON</font> function <font color="#0000FF">does</font> not always return an instance of <font color="#0000FF">Person</font> when we need it.  The <font color="#0000FF">Person</font> structure contains 3 properties, one of which is <b>Optional</b> , but the function returns the correct instance of <font color="#0000FF">Person</font> only if we get values ‚Äã‚Äãfrom the dictionary that are different from <font color="#0000FF">nil</font> for all 3 keys.  Let's rewrite this function as follows: so that we can return an instance of <font color="#0000FF">Person</font> if the address is missing, that is, if the <font color="#0000FF">address</font> key returns <font color="#0000FF">nil</font> . <br><br><img src="https://habrastorage.org/files/ee6/c36/8b2/ee6c368b25b84d12a8a193b48f2cee4c.png" height="169" width="480"><br><br>  We made a slight improvement in functionality.  This version of the <font color="#0000FF">createPersonFromJSON2</font> function can now instantiate <font color="#0000FF">Person</font> even if the address is <font color="#0000FF">nil</font> .  This reflects the <font color="#0000FF">Person</font> structure better, but now we have a lot of <font color="#0000FF">if statements</font> , as well as the need to expand the final values ‚Äã‚Äãassigned to <font color="#0000FF">name</font> and <font color="#0000FF">age</font> .  Let's see how this can be improved with the new <font color="#0000FF">guard</font> clause. <br><br><img src="https://habrastorage.org/files/dfe/df8/f9f/dfedf8f9f75449e5ba9291241e15e581.png" height="128" width="500"><br><br>  In the case of <font color="#0000FF">guard</font> clauses, as well as with the <font color="#0000FF">if let</font> clause, we can check for the presence of values, ‚Äúexpand‚Äù them and assign them to constants.  However, with the <font color="#0000FF">guard let</font> construct, code execution continues after curly braces <font color="#0000FF">{}</font> , if the conditional expression is evaluated as <b>true</b> .  This means that we can instantiate <font color="#0000FF">Person</font> within the normal scope of the function without using additional code branching to expand the values.  If any of the <font color="#0000FF">name</font> or <font color="#0000FF">age</font> values ‚Äã‚Äãis <font color="#0000FF">nil</font> , then the code "jumps" to the <font color="#0000FF">else</font> clause and an early return <font color="#0000FF">nil is</font> performed. <br><br>  Let's take a quick look at <font color="#0000FF">guard</font> . <br><br><ul><li>  If the condition of the <font color="#0000FF">guard</font> clause is satisfied, execution of the code continues after the curly braces of the <font color="#0000FF">guard</font> sentence are closed; </li><li>  If this condition is not met, then the code in the <font color="#0000FF">else</font> ‚Äúbranch‚Äù is executed;  unlike <font color="#0000FF">if</font> , <font color="#0000FF">guard</font> always has an <font color="#0000FF">&gt; else</font> block; </li><li>  The <font color="#0000FF">else</font> clause must transfer control beyond the normal scope of the function using <font color="#0000FF">return</font> , <font color="#0000FF">break</font> , <font color="#0000FF">continue</font> &gt; or by calling another function or method. </li></ul>  . <br><h3>  Offer <font color="#0000FF">defer</font> </h3><br><br>  The <font color="#0000FF">defer clause</font> resembles <font color="#0000FF">finally</font> in other programming languages, except that it is not tied to a <font color="#0000FF">try</font> clause, and you can use it anywhere.  You write <font color="#0000FF">defer {...}</font> and somewhere in the code and this block will be executed when the calculation control leaves this code scope (enclosing scope), and it does not matter whether the code gets to the end or receives the return clause or ‚Äúthrows An error.  The operator defer is perfectly combined with <font color="#0000FF">guard</font> and error handling (discussed later). <br><br><pre> <code class="hljs ruby">guard let file1 = Open(...) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   file1 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } defer { file1.close() } guard let file2 = Open(...) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   file2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } defer { file2.close() } /<span class="hljs-regexp"><span class="hljs-regexp">/  file1  file2 . . . . . . . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ,   </span></span></code> </pre><br>  Note that <font color="#0000FF">defer</font> works for <font color="#0000FF">file1</font> both in the normal course of the computational process and in the case of an error with the file <font color="#0000FF">file2</font> .  This removes numerous repetitions from the code and helps you not to forget to ‚Äúclear‚Äù something in any branch of the calculations.  When handling errors, there is the same problem and the <font color="#0000FF">defer</font> clause is <font color="#0000FF">best</font> suited for this purpose. <br><br><h3>  <font color="#0000FF">Repeat - while</font> </h3><br>  Swift 2.0 introduced syntactic changes to the <font color="#0000FF">do-while</font> clause that was used before.  Instead of a <font color="#0000FF">do-while</font> , we now get a <font color="#0000FF">repeat-while</font> . <br><br><img src="https://habrastorage.org/files/e55/b81/974/e55b8197408d4973a97365c164b33141.png" height="100" width="360"><br><br>  There are two reasons for such changes: <br><br>  When you use the <font color="#0000FF">do - while</font> loop, it is immediately unclear that this is a construct to be repeated.  This is especially true if the block of code inside the <font color="#0000FF">do</font> clauses is large, and the <font color="#0000FF">while</font> condition is outside the screen.  To mitigate this circumstance, the <font color="#0000FF">do</font> keyword has been replaced by <font color="#0000FF">repeat</font> , which makes it clear to the user that this is a duplicate block of code. <br><br>  The keyword <font color="#0000FF">do</font> has a new assignment in Swift 2 in the new error handling model, which we will explore later. <br><br><h3>  Pattern matching </h3><br>  Swift has always had the power of <b>pattern matching</b> , but only in the <font color="#0000FF">switch</font> construction.  The <font color="#0000FF">switch</font> construct considered the value <font color="#0000FF">value</font> and compared it with several possible patterns.  One of the drawbacks of the <font color="#0000FF">switch</font> clause is that we have to present all possible options for the <font color="#0000FF">value</font> , that is, the <font color="#0000FF">switch statement</font> must be exhaustive and this causes inconvenience of use.  Therefore, Swift 2 ported <b>pattern matching</b> capabilities, which previously were only for <font color="#0000FF">switch / case</font> , to other sentences that control the flow of computations.  <font color="#0000FF">if case</font> is one of them, and it allows you to rewrite the code with the <font color="#0000FF">switch</font> more briefly.  Other sentences are <font color="#0000FF">for case</font> and <font color="#0000FF">while case</font> . <br><br><h3>  Pattern matching <font color="#0000FF">if case</font> </h3><br>  New in Swift 2 is support for <b>pattern matching</b> inside <font color="#0000FF">if</font> (and <font color="#0000FF">guard</font> ) clauses.  Let's first define the simplest enumeration <font color="#0000FF">Number</font> , and then show how to use it. <br><br><img src="https://habrastorage.org/files/c84/2fc/526/c842fc5268914abaa9b1474b3b41b9ba.png" height="87" width="500"><br><br><h4>  1. Check a specific option (case) </h4><br>  Use <font color="#0000FF">case</font> : we want to check if the value matches a specific <font color="#0000FF">case</font> .  This works regardless of whether this <font color="#0000FF">case has an</font> associated value or not, but the value is not restored (if it exists). <br><br><img src="https://habrastorage.org/files/c26/f78/2ad/c26f782ad4fc4747b7620e2bb3acaf43.png" height="74" width="500"><br><br>  The pattern starts with <font color="#0000FF">case .IntegerValue</font> , and the value that must match this pattern, the <font color="#0000FF">myNumber</font> variable, comes after the <font color="#0000FF">=</font> equality sign.  This may seem illogical, but we see the same thing when the <b>Optional is</b> expanded by the <font color="#0000FF">a1</font> value in the <font color="#0000FF">if let a = a1</font> construction: the <font color="#0000FF">a1</font> value that is being checked comes after the equal sign. <br><br>  Here is the equivalent version of Swift 1.2 using <font color="#0000FF">switch</font> : <br><br><img src="https://habrastorage.org/files/d76/e2f/9f8/d76e2f9f8d58455fba02d5490b10d109.png" height="65" width="500"><br><br><h4>  2. Getting the associated value </h4><br>  We use <font color="#0000FF">case</font> : we want to check whether the value corresponds to a specific <font color="#0000FF">case</font> , and also to extract the associated value (or values). <br><br><img src="https://habrastorage.org/files/1f6/962/c8c/1f6962c8caea44b9b459b1013b8b3109.png" height="56" width="500"><br><br>  The ‚Äúpattern‚Äù has now become <font color="#0000FF">case let .IntegerValue (theInt)</font> .  The value that must match the ‚Äúsample‚Äù is the same as in the previous example. <br><br>  Below is an example reflecting the same concept, but applied to <font color="#0000FF">guard</font> .  The predicate semantics for <font color="#0000FF">guard</font> and <font color="#0000FF">if are</font> identical, so <b>pattern matching</b> works just as well. <br><br><img src="https://habrastorage.org/files/3c7/7d5/2e1/3c77d52e17db4f9a80fb7eca4edd96fa.png" height="161" width="500"><br><br><h4>  3. Selection using the <font color="#0000FF">where</font> clause </h4><br>  An optional <font color="#0000FF">where</font> clause may be added to any <font color="#0000FF">case</font> in the <font color="#0000FF">guard</font> clause to provide additional restrictions.  Let's modify the <font color="#0000FF">getObjectInArray: atIndex:</font> function from the previous example: <br><br><img src="https://habrastorage.org/files/4ca/08f/e21/4ca08fe21e0c466aa446028acfbbe607.png" height="162" width="600"><br><br><h4>  4. Matching <font color="#0000FF">range</font> </h4><br><img src="https://habrastorage.org/files/3a1/e91/2ac/3a1e912ac038460184dbf2909f74e411.png" height="200" width="450"><br><br><h4>  5. Use the tuple <font color="#0000FF">tuple</font> </h4><br><img src="https://habrastorage.org/files/739/3a9/f08/7393a9f088b9459a9a1141474a1d798c.png" height="120" width="500"><br><br><h4>  6. Complex <font color="#0000FF">if</font> predicates </h4><br>  The if sentence in Swift 2 was surprisingly capable.  It can have multiple predicates separated by a comma.  Predicates fall into one of three categories: <br><br><ul><li>  The simplest logical tests (for example, <font color="#0000FF">foo == 10 || bar&gt; baz</font> ).  There can be only one such predicate and it should be placed in the first place. </li><li>  Expanding <b>Optional</b> (for example, <font color="#0000FF">let foo = maybeFoo where foo&gt; 10</font> ).  If another <b>option's</b> immediate predicate is immediately followed by the <b>optional</b> deployment predicate, then you can skip the let.  It can be added with the <font color="#0000FF">where</font> qualifier. </li><li>  Pattern matching (for example, <font color="#0000FF">case let. Bar (something) = theValue</font> ), is what we looked at above.  It can be added with the <font color="#0000FF">where</font> qualifier. </li></ul><br>  Predicates are evaluated in the order of their definition and after not completing a predicate, the rest are not evaluated. <br><br><h3>  Pattern matching <font color="#0000FF">for case</font> </h3><br>  <b>Pattern</b> <b>matching</b> can be used in conjunction with the <font color="#0000FF">for -in</font> loop.  In this case, our intention is to go through the elements of the sequence, but only on those that correspond to a given ‚Äúpattern‚Äù.  Here is an example: <br><br><img src="https://habrastorage.org/files/519/a0e/5cf/519a0e5cfb9548049df92a7262f320a6.png" height="349" width="500"><br><br>  Note that just like the ‚Äúpatterns‚Äù in the <font color="#0000FF">switch</font> clause, you can retrieve a set of associated values ‚Äã‚Äãand use <font color="#0000FF">_</font> if you are not interested in this associated value.  If necessary, you can also add additional constraints using the <font color="#0000FF">where</font> clause. <br><br><h3>  Pattern matching <font color="#0000FF">while</font> </h3><br>  <b>Pattern</b> <b>matching</b> can also be used with a <font color="#0000FF">while</font> loop.  In this case, we will repeat the body of the loop until a certain value in the predicate matches the ‚Äúpattern‚Äù.  Here is an example: <br><br><img src="https://habrastorage.org/files/e07/b46/b35/e07b46b3524442beac773b72beec11a7.png" height="380" width="400"><br><br>  Note that the complex predicates described in section ‚Äú6.  Complex if ‚Äùpredicates are also supported by a <font color="#0000FF">while loop</font> , including the use of <font color="#0000FF">where</font> . <br><br><h3>  Pattern for "unwrapping" numerous <b>optional</b> </h3><br>  In Swift 1.2, we had a nice compact syntax for ‚Äúdeploying‚Äù the <b>Optionals</b> set in one simple <font color="#0000FF">if let</font> clause: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> optional1: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> optional2: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional1 = optional1, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional2 = optional2 { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Success"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failure"</span></span>) }</code> </pre><br>  Great! <br><br>  However, you still encounter a situation where you really need to manage various combinations of existing / missing <b>Optional</b> values.  One such example is the form to fill in the <font color="#0000FF">username</font> and <font color="#0000FF">password</font> fields, and the user did not fill in one of them, and clicked the "Submit" button.  In this case, you will want to show a special error in order to notify the user what exactly is missing.  To do this, we can use the <b>pattern makching</b> in Swift 1.x! <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> username: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> password: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (username, password) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (.<span class="hljs-type"><span class="hljs-type">Some</span></span>(username), .<span class="hljs-type"><span class="hljs-type">Some</span></span>(password)): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Success!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (.<span class="hljs-type"><span class="hljs-type">Some</span></span>(username), .<span class="hljs-type"><span class="hljs-type">None</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Password is missing"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (.<span class="hljs-type"><span class="hljs-type">None</span></span>, .<span class="hljs-type"><span class="hljs-type">Some</span></span>(password)): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Username is missing"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (.<span class="hljs-type"><span class="hljs-type">None</span></span>, .<span class="hljs-type"><span class="hljs-type">None</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Both username and password are missing"</span></span>) }</code> </pre><br>  It's a little awkward, but we enjoyed it right from the start. <br><br>  In Swift 2, the syntax looks clearer: <br><br><img src="https://habrastorage.org/files/cd1/ee6/932/cd1ee693244247eaaff48aa0595cc048.png" height="209" width="570"><br><br>  At first glance, confused by the use of a question mark <font color="#0000FF">?</font>  to show that the value is present (especially if it is associated with the idea of <b>Optionals</b> , when the value may or may not exist), but it must be recognized that this example becomes very understandable in contrast to the awkward syntax <font color="#0000FF">.Some (username)</font> . <br><br><h3>  Error processing </h3><br>  In order to understand the new features of Swift related to error handling, it will be useful to remember that there are 3 ways where a function can end abnormally (hereafter, for brevity, let's switch to jargon and say ‚Äúfall‚Äù): <br><br><ul><li>  Many functions can ‚Äúfall‚Äù for one reasonably simple ‚Äúinherent‚Äù reason, for example, when you are trying to convert a String to an Int;  such cases are handled fairly well by returning Optional values; </li><li>  At the other end of the spectrum there are logical programming errors that cause the array index to go out of bounds, inadmissible conditions, etc., it‚Äôs very difficult to deal with them and we don‚Äôt know how to manage them. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The third case is a detail error, a fixable error, for example, such as a file is not found, or a network error or the user has destroyed the operation (situational errors). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handling errors of the third type related to the situation is what Swift 2 is trying to improve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we consider a typical control scheme for such errors in Swift 1.x and Objective-C, then we find a scheme when the function takes the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inout</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argument </font><font color="#0000FF"><font style="vertical-align: inherit;">NSError? </font></font><font style="vertical-align: inherit;">and returns </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bool</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to represent the success or failure of the operation:</font></font><br><br><pre> <code class="hljs lua">//  <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>  ,    var <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: NSError? // success  Bool: let success = someString.writeToURL(someURL, atomically: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, encoding: NSUTF8StringEncoding, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: &amp;<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !success { //     <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>: println(<span class="hljs-string"><span class="hljs-string">"Error writing to URL: \(error!)"</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach has many ‚Äúdark‚Äù sides that make it less understandable, and what the method itself does, but more importantly, manual implementation of agreements regarding what is behind the returned </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bool</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is required </font><font style="vertical-align: inherit;">. If the method returns an object and received an error, then it returns </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nil</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; if it is a boolean value, then </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false is</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returned, </font><font style="vertical-align: inherit;">and so on. You need to know which method you are dealing with, what to check if the result is </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nil</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or something else when the method contains an </font><font color="#0000FF"><font style="vertical-align: inherit;">NSError</font></font><font style="vertical-align: inherit;"> error object </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></font>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Very confusing syntax. All these difficulties are related to the fact that Objective-C could not return a set of values ‚Äã‚Äãfrom a function or method, and if we need to notify the user about an error, such an ingrained way of handling it was suggested. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift 2 got new error management. It uses the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-try-catch</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> syntax </font><font style="vertical-align: inherit;">that replaces </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSError</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Let's see how you can use this new syntax. I will consider a very simple example of handling such errors, which the </font><b><font style="vertical-align: inherit;">optional</font></b><font style="vertical-align: inherit;"> returns perfectly cope with.</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">values, and for which the new syntax is not intended. But the simplicity of this example will allow me to focus your attention on the mechanism of ‚Äúthrowing out‚Äù and ‚Äúcatching‚Äù errors, and not on the complexity of their semantic content. In the end I will give a real example of processing data coming from the network. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before an error can be thrown (throw) or caught (catch), it must be defined. You can define it in Swift 2 with the help of </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enum</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which implements the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ErrorType</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol </font><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/files/342/f10/279/342f1027966b49caa5e57fa45615835a.png" height="68" width="250"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for a function </font></font><br><br><img src="https://habrastorage.org/files/c2a/226/1a9/c2a2261a9aa14098b9aff9c5c622042f.png" height="80" width="302"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to ‚Äúthrow out‚Äù (throw) an error, you need to announce the keyword </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throws</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the function header </font><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/files/36f/8db/c89/36f8dbc89f23403293dd53d0fec4b91e.png" height="80" width="341"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now this function can throw an error using the keyword </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throw</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a link to a specific type of error: </font></font><br><img src="https://habrastorage.org/files/a0c/959/264/a0c9592648d04d82b8dcc06642bc1566.png" height="85" width="340"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you try to call this function, the compiler will generate an error: ‚ÄúThe function being called throws errors, and the reference to it is not marked with the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keyword </font><font style="vertical-align: inherit;">and there is no error handling.‚Äù </font></font><br><br><img src="https://habrastorage.org/files/91a/bb9/5e2/91abb95e28264cc39419de1497c10dbb.png" height="53" width="540"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because the function declared that it is capable of throwing errors , and you have to ‚Äúcatch‚Äù potential mistakes. Let's try to use the keyword </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the try</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/files/43e/342/bb6/43e342bb67af4331aa78be80e2e1f5ad.png" height="36" width="540"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it was not enough, the compiler tells us that the required error handling, which is produced by using syntax </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-try-catch</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/files/174/d33/ef0/174d33ef05064eefa9a48685f604a342.png" height="190" width="540"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Furthermore, in the block </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-try-catch</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you have the opportunity to "catch" a few errors:</font></font><br><br><img src="https://habrastorage.org/files/6fb/2a1/d24/6fb2a1d2492842be855d9e577a7a7841.png" height="122" width="540"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the semantic part of errors does not interest you, then instead of using </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-try-catch</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constructions </font><font style="vertical-align: inherit;">, you can treat the values ‚Äã‚Äãyou are interested in as with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optional</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/files/394/60b/be8/39460bbe89ce4947b7777a48bd082545.png" height="75" width="540"><br><br> <font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aTry</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aTrySuccess</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optional</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so don't forget to ‚Äúdeploy‚Äù them before use! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes there is a method that can ‚Äúfall‚Äù only in certain circumstances, and you know for sure that it will not ‚Äúfall‚Äù in your mode of use. Then you can use </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try!</font></font></font>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the function throws an error, it returns immediately. But sometimes you need to do some actions, such as freeing up resources or closing files, before the function returns. In this situation, the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defer</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keyword already familiar to us works </font><font color="#0000FF"><font style="vertical-align: inherit;">just fine</font></font><font style="vertical-align: inherit;"> . With the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defer keyword,</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can define a block of code that is always executed if the function returns, and it does not matter whether it returns normally or due to errors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can define a </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defer</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block anywhere in our function. Moreover, it is possible to define more than one </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defer</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> block. In this case, they will be performed in the reverse order. Let's look at an example:</font></font><br><br><img src="https://habrastorage.org/files/4d0/c7f/5ad/4d0c7f5ad0e24789b67287b7bb7775f5.png" height="225" width="480"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us consider the real example presented in the </font><a href="http://natashatherobot.com/swift-2-0-try/"><font style="vertical-align: inherit;">Natasha Murashev</font></a><font style="vertical-align: inherit;"> article </font></font><a href="http://natashatherobot.com/swift-2-0-try/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Swift 2.0: Let's try?</font></font></a>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the data that comes from an API (after deserialization): </font></font><br><br><img src="https://habrastorage.org/files/1b7/a6c/e74/1b7a6ce744d6490c93898cb65d6d968e.png" height="125" width="500"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This data needs to be converted to a Model for later use in an application: </font></font><br><br><img src="https://habrastorage.org/files/c4d/a10/5b0/c4da105b08b7428cba8e5750a2390d21.png" height="130" width="600"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TodoItemParser</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parser </font><font style="vertical-align: inherit;">deals with mixed data coming from an API, converts it into an understandable Model for later use in an application and ‚ÄúThrows‚Äù errors if it detects them: </font></font><br><br><img src="https://habrastorage.org/files/859/dbb/e2e/859dbbe2ea4941eea267807223755c87.png" height="370" width="650"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will perform the parsing of ‚Äúgood‚Äù data in the Model using the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-try-catch</font></font></font> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> construction </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will perform the </font></font><br><br><img src="https://habrastorage.org/files/fc8/5c0/4cf/fc85c04cf8b14e58967e8e9d90f66412.png" height="340" width="620"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parsing of ‚Äúbad‚Äù data. </font></font><br><br><img src="https://habrastorage.org/files/6c3/8f5/416/6c38f54163804b74a291d3642fea91b2.png" height="218" width="620"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of using the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do-try-catch</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> construct </font><font style="vertical-align: inherit;">, you can treat the values ‚Äã‚Äãthat interest us as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optional</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the </font></font><font color="#0000FF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try?</font></font></font>  : <br><br><img src="https://habrastorage.org/files/c7b/d0a/511/c7bd0a5115054c389f842defa8efa404.png" height="170" width="640"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first part, we considered only a part of the new features of Swift 2: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the fundamental constructs of the language, such as </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>scoping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(scope), the syntax of the arguments, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pattern matching</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">pattern matching</font></b><font style="vertical-align: inherit;"> ) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error handling</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">error handling</font></b><font style="vertical-align: inherit;"> )</font></font><br><br>  In the second part, we will look at the rest: <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- availability check ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">availability Available checking</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- extension ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the extensions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) protocol </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- interaction with Objective-C </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References used article: </font></font><br><br> <a href="https://www.hackingwithswift.com/new-features-swift-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the New features in Swift 2 </font></font></a> <br> <a href="http://blog.zuehlke.com/en/what-i-like-in-swift-2-the-return-part-1-of-3/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What I Like in Swift 2 </font></font></a> <br> <a href="http://www.appcoda.com/swift2/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Beginner's guide to Swift 2 </font></font></a> <br> <a href="http://www.thomashanning.com/error-handling-in-swift-2-0/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Error Handling in Swift 2.0 We do </font></font></a> <br> <a href="http://natashatherobot.com/swift-2-0-try/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift 2.0 We do: for Let's try? </font></font></a> <br> <a href="http://www.raywenderlich.com/109655/video-tutorial-whats-new-in-swift-2-part-4-pattern-matching"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video Tutorial: What's New in Swift 2 Part 4: Pattern A Matching </font></font></a> <br> <a href="http://robnapier.net/throw-what-dont-throw"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Throw for What the Do not the Throw </font></font></a> <br> <a href="https://www.mikeash.com/pyblog/friday-qa-2015-06-19-the-best-of-whats-new-in-swift.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of The of the Best for What's in the New Swift</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/269171/">https://habr.com/ru/post/269171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269161/index.html">AVG antivirus company can now sell data of its customers</a></li>
<li><a href="../269163/index.html">Service for the system administrator. Part 1</a></li>
<li><a href="../269165/index.html">What protect sites, or why do we need WAF?</a></li>
<li><a href="../269167/index.html">Combined ABC and XYZ analysis in Retail</a></li>
<li><a href="../269169/index.html">Amazon's legendary books. Continuing the theme of "Elements of Programming Interviews: The Insiders' Guide"</a></li>
<li><a href="../269173/index.html">Oracle, typical SQL tasks. The multiplication of the rows of the table depending on the value of the number in the column</a></li>
<li><a href="../269175/index.html">Course on machine learning on Coursera from Yandex and HSE</a></li>
<li><a href="../269177/index.html">1Password changes the default file format to increase security</a></li>
<li><a href="../269181/index.html">How to organize a paid support for a complex product: the experience of "Hydra"</a></li>
<li><a href="../269183/index.html">Part 2. Publishing apps in the Office Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>