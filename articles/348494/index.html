<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Remove what is hidden: optimization of 3D scenes in the mobile game. Tips employees Plarium Krasnodar</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Already at the initial stage of the creation of mobile games, it should be borne in mind that the detailed models heavily load a portable device, and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Remove what is hidden: optimization of 3D scenes in the mobile game. Tips employees Plarium Krasnodar</h1><div class="post__text post__text-html js-mediator-article">  Already at the initial stage of the creation of mobile games, it should be borne in mind that the detailed models heavily load a portable device, and this leads to a drop in the frame rate, especially on weak devices.  How to economically use the resources of three-dimensional models without losing visual quality?  Under the cut - a solution found by the specialists of the Krasnodar studio Plarium. <br><br><img src="https://habrastorage.org/webt/1t/ei/06/1tei06nzahdeqcwuoguolypfgro.jpeg" alt="image"><br><a name="habracut"></a><br>  <font color="‚Äú#F0E68C‚Äù">The method described here requires large calculations and is suitable only for the preliminary preparation of scenes</font> . <br><br>  The game Terminator Genisys: Future War has three-dimensional miniatures of units (people, robots, cars) that can be viewed from different sides with the help of the camera.  However, its review is limited by software, and certain parts of the models always remain hidden from the eyes of users.  So, it is necessary to find and delete such sites. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Invisible parts fall into two categories: <br><br><ol><li>  Located behind the model. </li><li>  Overlapped by other parts. </li></ol><br>  Parts of the first category are fairly easy to process using the standard method of removing invisible triangles.  With the second category, things are not so obvious. <br><br>  First you need to determine at what stage to remove hidden triangles.  We created models of units and environment objects in 3D editors, and final assembly of the scene, camera and lighting settings were carried out in Unity.  Since the optimization of model geometry in the 3D editor requires the development of additional tools for each 3D package, we decided to perform optimization in Unity. <br><br>  To define invisible triangles, we developed a simple algorithm: <br><br><ol><li>  Turn off the effects that do not affect the visibility of objects in the scene. </li><li>  We set the positions and camera angles with which to check.  A large number of specified positions will make the result more accurate, but will slow down the optimization process.  We used several dozen positions. </li><li>  All objects in the scene are assigned a shader, which displays the color of the vertices of the object meshes.  By default, the vertices are painted black, so the scene in this form will be similar to the famous picture of Malevich. </li><li>  We pass through all the triangles of the mesh of one of the objects being optimized. </li></ol><br>  4.1.  At each step, we cut the current triangle out of the mesh, save it into a separate temporary mesh and, accordingly, obtain a separate object on the stage.  At the same time, paint its vertices red.  As a result, we have a black scene with a small red triangle. <br><br>  4.2.  We pass through all the initially recorded positions and camera angles. <br><br>  4.2.1.  In the current position of the camera take a picture of the scene.  Good image resolution will make the result more accurate, but will slow down the optimization process.  We used 4K resolution. <br><br>  4.2.2.  On the resulting picture we are looking for red.  We calculate the region of the image in which the checked triangle is located so as not to pass through all the pixels of the image.  To do this, we translate the coordinates of the triangle vertices from the scene space to the screen coordinates, taking into account the current position and camera angle.  If we find a red pixel in the checked region, then we can immediately proceed to the next step. <br><br>  4.2.3.  If we find a red pixel, then further checking for other angles and camera positions can be omitted.  Check the next triangle, returning to step 4.1. <br><br>  4.2.4.  Moving on to the next camera position and to step 4.2.1. <br><br>  4.3.  If we went through all the steps and were here, then we did not find the red color on any of the pictures taken.  The triangle can be deleted and go to step 4.1. <br><br>  5. Profit!  We optimized one of the objects.  You can proceed to step 4 for other objects. <br><br>  6. The scene is optimized. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MeshData</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera Camera; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Polygons; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MeshFilter Filter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MeshFilter PolygonFilter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ScreenWidth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ScreenHeight; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RenderTexture RenderTexture; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D ScreenShot; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RenderTextureMeshCutter</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ..................... //   //     ,        public static void SaveVisiblePolygons(MeshData data) { var polygonsCount = data.Polygons.Count; for (int i = polygonsCount - 1; i &gt;= 0; i--) { var polygonId = data.Polygons[i]; var worldVertices = GetPolygonWorldPositions(polygonId, data.PolygonFilter); var screenVertices = GetScreenVertices(worldVertices, data.Camera); screenVertices = ClampScreenCordinatesInViewPort(screenVertices, data.ScreenWidth, data.ScreenHeight); var gui0 = ConvertScreenToGui(screenVertices[0], data.ScreenHeight); var gui1 = ConvertScreenToGui(screenVertices[1], data.ScreenHeight); var gui2 = ConvertScreenToGui(screenVertices[2], data.ScreenHeight); var guiVertices = new[] { gui0, gui1, gui2 }; var renderTextureRect = GetPolygonRect(guiVertices); if (renderTextureRect.width == 0 || renderTextureRect.height == 0) continue; var oldTriangles = data.Filter.sharedMesh.triangles; RemoveTrianglesOfPolygon(polygonId, data.Filter); var tex = GetTexture2DFromRenderTexture(renderTextureRect, data); //    (  ),      ,    if (ThereIsPixelOfAColor(tex, renderTextureRect)) { data.Polygons.RemoveAt(i); } //       data.Filter.sharedMesh.triangles = oldTriangles; } } //  ,        private static Vector3[] ClampScreenCordinatesInViewPort(Vector3[] screenPositions, float screenWidth, float screenHeight) { var len = screenPositions.Length; for (int i = 0; i &lt; len; i++) { if (screenPositions[i].x &lt; 0) { screenPositions[i].x = 0; } else if (screenPositions[i].x &gt;= screenWidth) { screenPositions[i].x = screenWidth - 1; } if (screenPositions[i].y &lt; 0) { screenPositions[i].y = 0; } else if (screenPositions[i].y &gt;= screenHeight) { screenPositions[i].y = screenHeight - 1; } } return screenPositions; } //    private static Vector3[] GetPolygonWorldPositions(MeshFilter filter, int polygonId, MeshFilter polygonFilter) { var sharedMesh = filter.sharedMesh; var meshTransform = filter.transform; polygonFilter.transform.position = meshTransform.position; var triangles = sharedMesh.triangles; var vertices = sharedMesh.vertices; var index = polygonId * 3; var localV0Pos = vertices[triangles[index]]; var localV1Pos = vertices[triangles[index + 1]]; var localV2Pos = vertices[triangles[index + 2]]; var vertex0 = meshTransform.TransformPoint(localV0Pos); var vertex1 = meshTransform.TransformPoint(localV1Pos); var vertex2 = meshTransform.TransformPoint(localV2Pos); return new[] { vertex0, vertex1, vertex2 }; } //    private static bool ThereIsPixelOfAColor(Texture2D tex, Rect rect) { var width = (int)rect.width; var height = (int)rect.height; //       var pixels = tex.GetPixels(0, 0, width, height, 0); var len = pixels.Length; for (int i = 0; i &lt; len; i += 1) { var pixel = pixels[i]; if (pixel.r &gt; 0f &amp;&amp; pixel.g == 0 &amp;&amp; pixel.b == 0 &amp;&amp; pixel.a == 1) return true; } return false; } //       private static Texture2D GetTexture2DFromRenderTexture(Rect renderTextureRect, MeshData data) { data.Camera.targetTexture = data.RenderTexture; data.Camera.Render(); RenderTexture.active = data.Camera.targetTexture; data.ScreenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; data.Camera.targetTexture = null; return data.ScreenShot; } //     polygonId   triangles private static void RemoveTrianglesOfPolygon(int polygonId, MeshFilter filter) { var newTriangles = new int[triangles.Length - 3]; var len = triangles.Length; var k = 0; for (int i = 0; i &lt; len; i++) { var curPolygonId = i / 3; if (curPolygonId == polygonId) continue; newTriangles[k] = triangles[i]; k++; } filter.sharedMesh.triangles = newTriangles; } //      private static Vector3[] GetScreenVertices(Vector3[] worldVertices, Camera cam) { var scr0 = cam.WorldToScreenPoint(worldVertices[0]); var scr1 = cam.WorldToScreenPoint(worldVertices[1]); var scr2 = cam.WorldToScreenPoint(worldVertices[2]); return new[] { scr0, scr1, scr2 }; } //    Gui  private static Vector2 ConvertScreenToGui(Vector3 pos, float screenHeight) { return new Vector2(pos.x, screenHeight - pos.y); } //    Gui  private static Rect GetPolygonRect(Vector2[] guiVertices) { var minX = guiVertices.Min(v =&gt; vx); var maxX = guiVertices.Max(v =&gt; vx); var minY = guiVertices.Min(v =&gt; vy); var maxY = guiVertices.Max(v =&gt; vy); var width = Mathf.CeilToInt(maxX - minX); var height = Mathf.CeilToInt(maxY - minY); return new Rect(minX, minY, width, height); } }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/uq/iq/5d/uqiq5dk12ai-9eqttv6llt7tahc.gif" alt="image"><br><br>  We decided not to dwell on trimming the geometry and tried to save free texture space.  To do this, we returned the optimized model models to the modellers, and they recreated the texture sweeps in the 3D package.  Then we added models with new textures to the project.  It remains only to re-calculate the lighting in the scene. <br><br><img src="https://habrastorage.org/webt/_2/lu/9z/_2lu9zjn0nlp1ptw9hhnzz3xdik.gif" alt="image"><br><br>  With the help of the created algorithm we managed: <br><br><ul><li>  Reduce the number of vertices and triangles of the model without loss of quality ‚Üí The load on the video adapter has decreased.  Also, shaders will be executed fewer times. </li><li>  Reduce the area of ‚Äã‚Äãthe object in the lighting map and save texture for some models due to the resulting empty area ‚Üí The size of the application has decreased and the video memory consumption has decreased. </li><li>  Use a higher density of pixels on the model (in some cases) ‚Üí Improved detail. </li></ul><br>  As a result, in the models we managed to remove up to 50% of polygons and reduce textures by 10‚Äì20%.  It took three to five minutes to optimize each scene consisting of several objects. <br><br>  We hope that these findings will make your further work more convenient and more pleasant. </div><p>Source: <a href="https://habr.com/ru/post/348494/">https://habr.com/ru/post/348494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348478/index.html">Runtime Permissions</a></li>
<li><a href="../348486/index.html">The release of Kali Linux 2018.1</a></li>
<li><a href="../348488/index.html">Reinventing the PoA Consensus Algorithm - PoG Algorithm</a></li>
<li><a href="../348490/index.html">Mono-vendor data centers. Debunking myths</a></li>
<li><a href="../348492/index.html">Clothing stores in section: why are we so painful to go there</a></li>
<li><a href="../348496/index.html">Social engineering as an attack method</a></li>
<li><a href="../348498/index.html">Neurogress: a platform of neural control systems from Blue Brain project participants</a></li>
<li><a href="../348500/index.html">Modern CSS for dinosaurs</a></li>
<li><a href="../348502/index.html">We are looking for hover support on css</a></li>
<li><a href="../348506/index.html">Kickstarter and games in 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>