<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributed systems. Design patterns. Book Review</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues. Today we publish the translation of the next review from the site of Ben Neidel - this site will certainly interest you in the origi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distributed systems. Design patterns. Book Review</h1><div class="post__text post__text-html js-mediator-article">  Hello colleagues.  Today we publish the translation of the next review from the site of Ben Neidel - this site will certainly interest you in the original.  This time we will talk about the book " <a href="https://www.piter.com/collection/new/product/raspredelennye-sistemy-patterny-proektirovaniya">Distributed Systems. Design Patterns</a> ", which complements the book " <a href="https://www.piter.com/collection/all/product/osvaivaem-kubernetes-orkestratsiya-konteynernyh-arhitektur">We Master Kubernetes</a> ", which we published earlier this year and, in essence, is analogous to GoF for the design of distributed systems. <br><br><img src="https://habrastorage.org/webt/kv/we/4c/kvwe4cf94jbziiik3j87ywbjgyi.png"><br><br>  Enjoy reading. <br><a name="habracut"></a><br>  In total over the weekend I read the book ‚ÄúDistributed Systems.  Design Patterns ‚Äù, written by <a href="https://twitter.com/brendandburns">Brendan Burns</a> .  I really liked the book, although I have to admit that I expected to find some other material in it.  So, in the description of the book containers are mentioned only in passing.  At the same time, although the patterns described in the book are applicable not only for containerization, almost all the templates described here are given exactly in the container context, and then are considered in the Kubernetes deployment pipeline.  It turned out to be the way.  I'm just starting to get acquainted with container-oriented development and deployment, and the discussion of architectural patterns from just such a ‚Äúcontainer‚Äù point of view was a revelation to me.  This approach helped me to get a good idea of ‚Äã‚Äãhow small services are correctly distinguished in the microservice landscape, each of which implements a specific feature. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The author of the book Brendan Burns is the co-founder of the open-source project Kubernetes.  Therefore, it is not surprising that all its application examples are built around the deployment of containers based on the Kubernetes configuration files.  At the time of reading the book, I was slightly versed in Docker and did not know anything about Kubernetes.  Thus, I tried to understand the ‚Äúpurpose‚Äù of the Kubernetes configuration files by simply reading them.  However, I believe that the book will be more useful if the reader has at least some experience with Kubernetes. <br><br>  Reading the book, I could not get rid of the associations with the work of " <a href="https://www.bennadel.com/blog/3423-enterprise-integration-patterns-designing-building-and-deploying-messaging-solutions-by-gregor-hohpe-and-bobby-woolf.htm">Patterns of integration of enterprise applications</a> " by Gregor Hop and Bobby Wolfe.  Many of the patterns considered by Burns are very reminiscent of message queuing patterns discussed by Hop and Wolfe.  In fact, I should note that many of the patterns are even named the same in both books (for example, Scatter / Gather).  This is logical, since the theme of both books is the division of complex monolithic systems into sets of small, tightly fitted reusable services.  I think it can even be argued that Burns sets out specific approaches that will be useful when implementing Service-Producers and Service-Consumers participating in the workflow based on messages, the very ones described in the book "Enterprise Application Integration Patterns". <br><br>  Again, I believe that the parallels traced between these two books testify to the strength of the design patterns.  Both in how well they lead us to proven solutions, and in that design patterns facilitate technical communication, because they allow us to reason in a common language. <br><br>  At the same time, one of the approaches I liked most is that described in the book Distributed Systems.  Design Patterns ‚Äùjust associated with the consumption of a message queue.  Burns advises not to force the working container to pull out messages directly from the system (just as it does in the Simple Queue Service (SQS) system from Amazon), but to create an ‚Äúambassador‚Äù (Ambassador pattern).  Such an ‚Äúambassador‚Äù container will be deployed with the working container and provide a generic API for manipulating the queues.  The Ambassador container allows you to abstract the implementation details associated with the permanent storage of items in the message queue, so that the working container is completely independent of any specific technological solutions. <br><br>  ‚ÄúAmbassador of the working queue source container‚Äù is just one example of a cross-cutting theme running through the entire book with a red thread: use sets of small containers so that each individual container can concentrate on a specific task and make it as reusable as possible.  Burns explores this concept at the level of individual containers, talking about parameterizing containers using command line arguments and environment variables.  Then he rises to a higher level, talks about the multi-container side-car and ambassador patterns in a single-node context.  Finally, it shows how to create powerful microservice architecture using multi-container patterns. <br><br>  I think that Burns managed to perfectly articulate the ‚Äúdream‚Äù of the entire microservice landscape: <br><br><blockquote>  The microservice approach has many advantages, many of which are related to reliability and flexibility.  Microservices divide the application into small parts, each of which is responsible for providing a specific service.  By narrowing the scope of services, each service is able to develop and maintain a team that can be fed with two pizzas. <br><br>  Reducing the size of the team also reduces the cost of maintaining its activities. <br><br>  In addition, the emergence of a formal interface between microservices weakens the interdependence of commands and establishes a reliable contract between services.  Such a formal contract reduces the need for close synchronization of commands, because the team providing the API understands the extent to which it is necessary to ensure compatibility, and the team consuming the API can rely on stable service without worrying about the implementation details of the consumed service.  This decomposition allows teams to independently control the pace of development and the release schedule of new versions, which enables them to perform iterations, thereby improving the service code. <br><br>  Finally, the division into microservices improves scalability.  Since each component is allocated to a separate service, it can be scaled independently of the rest </blockquote><br>  (p. 79-80 in Russian translation) <br><br>  I‚Äôm talking about a ‚Äúdream‚Äù because, as Burns himself admits, it‚Äôs difficult to design a microservice system and design its architecture.  And monitoring and debugging such a system is much more difficult than monitoring and debugging a monolithic counterpart.  Just so I can easily agree.  From my own limited experience with microservices, I confirm that shared services quickly become strongly connected, and ‚Äúreliable contracts‚Äù between services quickly turn into a moving target, undergoing new and new changes. <br><br>  In conclusion, I would like to touch upon the concept of FaaS - ‚Äúfunctions as services‚Äù.  Systems like Amazon's Lambda Service give me mixed feelings.  In an extremely abstract sense, I like such systems, but I have no idea how they manifest themselves in a particular application.  Burns touches on FaaS in Part II on "Design patterns for service systems," but unfortunately, it does not fully clarify the Faas problem for me. <br><br>  I really liked the fact that Burns recommends using FaaS to solve only a certain subset of known problems: <br><br><blockquote>  As is the case with other tools for developing distributed systems, there may be a desire to use a particular solution (for example, event-oriented processing) as a universal tool.  The truth is that a particular solution usually solves particular problems.  In a certain context, it will be a powerful tool, but pulling it by the ears to solve common problems generates complex, fragile architectures. </blockquote><br>  (p. 135 in Russian translation) <br><br>  Moreover, many thanks to him for mentioning the difficulties encountered when using FaaS: <br><br><blockquote>  As mentioned in the previous section, developing systems using the FaaS approach forces the system components to be loosely coupled.  Each function is independent by definition.  All interaction is carried out over the network.  Instances of functions do not have their own memory, therefore, they require a shared storage to store the state.  Forcing a weakening of the connectivity of system elements can increase the flexibility and speed of service development, but at the same time can significantly complicate its support. <br>  In particular, it is rather difficult to see the comprehensive structure of the service, to determine how the functions integrate with each other, to understand what went wrong and why in the event of a failure.  In addition, the query-oriented and serverless nature of the functions means that some problems will be difficult to detect. </blockquote><br>  (p. 136-137 in Russian translation) <br><br>  Again, I was surprised by the fact that most FaaS systems are not too good for solving problems that require active processing: <br><br><blockquote>  ... besides, due to serverless implementation of services, the execution time of the function instance is usually limited.  This means that the FaaS approach is usually not suitable for applications requiring long background processing.  (P. 138 in Russian translation) <br>  Finally, I was pleased with the remark that FaaS is becoming economically inexpedient if it is impossible to ensure long uninterrupted operation of the processor: <br>  But if you have so many requests that the function is constantly active, you are probably overpaying for the number of requests being processed. <br><br>  ... as the service grows, the number of requests processed grows to such a level that the processor is busy processing them all the time.  At this point, the charge for the number of requests begins to become unprofitable.  The cost per unit of processor time of cloud virtual machines decreases as kernels are added, as well as due to the reservation of resources and discounts for long-term use.  The cost of paying the number of requests usually increases with the number of requests. </blockquote><br>  (p. 139-140 in Russian translation) <br><br>  As a result, I did not understand: when is it better to use "functions as services"?  I note that further Burns briefly describes work with event-oriented short-term tasks that do not heavily load the processor, such as two-factor authentication (2FA).  However, given that we are talking about small short-term tasks with low costs, the question arises: why should they be scaled independently?  Why not just include these features in another container service, closely related to the first? <br><br>  I hope to better deal with these issues when I move to using FaaS-technologies in practice. <br><br>  Apart from some confusion with FaaS, I really liked the book.  Reads quickly, easily perceived.  It reminds once again how great potential there is in weakening the connection between components at all levels of application development.  Finally, now it will be much easier for me to maintain a conversation with colleagues on topics such as ‚ÄúSidecar-containers.‚Äù </div><p>Source: <a href="https://habr.com/ru/post/442514/">https://habr.com/ru/post/442514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442498/index.html">Top 10 reports of the C ++ Russia 2018 conference: full videos, slides, comments</a></li>
<li><a href="../442500/index.html">Detekt Static Analyzer for Kotlin</a></li>
<li><a href="../442502/index.html">We transform the workplace in the recumbent for $ 200</a></li>
<li><a href="../442506/index.html">Is Russia being punished for illegal trade in personal data?</a></li>
<li><a href="../442508/index.html">How do udalenka accelerates innovation on gitlab</a></li>
<li><a href="../442516/index.html">A guide to using pandas for analyzing large data sets.</a></li>
<li><a href="../442520/index.html">Case Saving 300,000 p. per month on contextual advertising</a></li>
<li><a href="../442522/index.html">Intuitive RL (Reinforcement Learning): An Introduction to Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../442524/index.html">How to increase security in personal identification and access control systems</a></li>
<li><a href="../442526/index.html">The history of Soviet cassette players (part two): Walkman boom, gadget for the KGB and tape recorders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>