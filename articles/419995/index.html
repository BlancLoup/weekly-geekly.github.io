<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ivy Research - New Angular Compiler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Äú I think compilers are very interesting ,‚Äù says Uri Sheked, the author of the material, the translation of which we are publishing today. Last year, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ivy Research - New Angular Compiler</h1><div class="post__text post__text-html js-mediator-article">  ‚Äú <i>I think compilers are very interesting</i> ,‚Äù says Uri Sheked, the author of the material, the translation of which we are publishing today.  Last year, he wrote <a href="https://blog.angularindepth.com/a-deep-deep-deep-deep-deep-dive-into-the-angular-compiler-5379171ffb7a">an article</a> in which he talked about the reverse engineering of the Angular compiler and about the imitation of certain stages of the compilation process, which helps to understand the features of the internal structure of this mechanism.  It should be noted that usually what the author of this material refers to as a ‚Äúcompiler‚Äù is called a ‚Äúrendering engine‚Äù. <br><br>  When Uri heard that a new version of the Angular compiler, called Ivy, was released, he immediately wanted to take a closer look at it and find out what changed in it compared to the old version.  Here, just as before, templates and components created by Angular, which are converted into plain HTML and JavaScript code, understandable by Chrome and other browsers, come to the input of the compiler. <br><br> <a href="https://habr.com/company/ruvds/blog/419995/"><img src="https://habrastorage.org/webt/6o/ha/fa/6ohafariunj4046cd6nokfypam0.jpeg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we compare the new version of the compiler with the previous one, it turns out that Ivy uses the tree-shaking algorithm.  This means that the compiler automatically removes unused code fragments (this also applies to Angular code), reducing the size of project bundles.  Another improvement concerns the fact that now each file is compiled independently, which reduces the recompile time.  If in a nutshell, thanks to a new <a href="https://www.telerik.com/blogs/first-look-angular-ivy">compiler,</a> we get smaller builds, faster re-compilation of projects, more simple ready-made code. <br><br>  Understanding how the compiler works is interesting in itself (at least, the author of the material hopes for it), but it also helps to better understand the internal mechanisms of Angular.  This leads to the improvement of the skills of ‚ÄúAngular-thinking‚Äù, which, in turn, makes it possible to more effectively use this framework for web development. <br><br>  By the way, do you know why the new compiler was called Ivy?  The fact is that this word sounds like a combination of the letters "IV", read aloud, which represents the number 4, written in Roman numerals.  "4" is the fourth generation of Angular compilers. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ivy application</font> </h2><br>  Ivy is still in the process of intensive development, you can watch this process <a href="https://is-angular-ivy-ready.firebaseapp.com/">here</a> .  Although the compiler itself is not yet suitable for use in combat conditions, the RendererV3 abstraction, which it will use, is already quite functional and comes with Angular 6.x. <br><br>  Although Ivy is not quite ready yet, we can still look at the results of his work.  How to do it?  Creating a new Angular project: <br><br><pre><code class="hljs cs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ivy-internals</code> </pre> <br>  After that, you need to enable Ivy by adding the following lines to the <code>tsconfig.json</code> file located in the new project folder: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  And finally, we run the compiler by executing the <code>ngc</code> command in the newly created project folder: <br><br><pre> <code class="hljs">node_modules/.bin/ngc</code> </pre> <br>  That's all.  Now you can explore the generated code, located in the folder <code>dist/out-tsc</code> .  For example, take a look at the following fragment of the <code>AppComponent</code> template: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"‚Ä¶"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Here are some links to help you start:</font> </h2><br>  The code generated for this template can be found by looking into the file <code>dist/out-tsc/src/app/app.component.js</code> : <br><br><pre> <code class="hljs smalltalk">i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">"div"</span></span>, _c0); i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h1"</span></span>); i0.…µ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); i0.…µe(); i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-comment"><span class="hljs-comment">"img"</span></span>, _c1); i0.…µe(); i0.…µe(); i0.…µ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h2"</span></span>); i0.…µ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Here are some links to help you start: "</span></span>); i0.…µe();</code> </pre> <br>  It is in this JavaScript code that Ivy transforms the component template.  Here's how the same thing was done in the previous version of the compiler: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/d3a/278/1f4d3a278708237e5558f313b316e780.png"></div><br>  <i><font color="#999999">The code that produces the previous version of the Angular compiler</font></i> <br><br>  There is a feeling that the code that generates the Ivy is much easier.  You can experiment with the component template (it is in <code>src/app/app.component.html</code> ), compile it again and see how the changes made to it affect the generated code. <br><br><h2>  <font color="#3AC1EF">Parsing the generated code</font> </h2><br>  Let's try to parse the generated code and see what actions it performs.  For example, let's look for an answer to the question about the meaning of calls like <code>i0.…µE</code> and <code>i0.…µT</code> <br><br>  If you look at the beginning of the generated file, there we will find the following expression: <br><br><pre> <code class="hljs perl">var i<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>);</code> </pre> <br>  Thus, <code>i0</code> is just an Angular kernel module, and all of these are functions exported by Angular.  The letter <code>…µ</code> used by the Angular development team to indicate that some methods are intended solely to support the <a href="https://github.com/angular/angular/pull/14467/commits/f39a46bf39d27415b45193da645fb7697957a0e8">internal mechanisms of the</a> framework, that is, users should not call them directly, since the API‚Äôs invariance of these methods is not guaranteed when new versions of Angular are released (in fact, I would say that their API is almost guaranteed to change). <br><br>  So all these methods are private APIs exported by Angular.  It‚Äôs easy to understand their functionality by opening a project in VS Code and analyzing the tooltips: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3df/800/ffb/3df800ffb5948fa113362e73f7d7b54c.png"></div><br>  <i><font color="#999999">Code Analysis in VS Code</font></i> <br><br>  Even though a JavaScript file is analyzed here, VS Code uses type information from TypeScript to identify the call signature and find the documentation for a particular method.  If, selecting the method name, use the Ctrl + click combination (Cmd + click on Mac), we find out that the real name of this method is <code>elementStart</code> . <br><br>  This technique made it possible to find out that the name of the method <code>…µT</code> is <code>text</code> , the name of the method <code>…µe</code> is <code>elementEnd</code> .  Armed with this knowledge, we can "translate" the generated code, turning it into something that will be easier to read.  Here is a small piece of this "translation": <br><br><pre> <code class="hljs ruby">var core = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"angular/core"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... core.elementStart(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>, _c<span class="hljs-number"><span class="hljs-number">0</span></span>); core.elementStart(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"h1"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">2</span></span>); core. (); core.elementStart(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"img"</span></span>, _c1); core.elementEnd(); core.elementEnd(); core.elementStart(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"h2"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"Here are some links to help you start: "</span></span>); core.elementEnd();</code> </pre> <br>  And, as already mentioned, this code corresponds to the following text from the HTML template: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"‚Ä¶"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Here are some links to help you start:</font> </h2><br>  After analyzing this all, it is easy to notice the following: <br><br><ul><li>  Each opening HTML tag corresponds to a call to <code>core.elementStart()</code> . </li><li>  The closing tags correspond to the <code>core.elementEnd()</code> calls. </li><li>  Text nodes correspond to <code>core.text()</code> calls. </li></ul><br>  The first argument to the <code>elementStart</code> and <code>text</code> methods is a number, the value of which increases with each call.  It is probably an index in some kind of array in which Angular stores references to the created elements. <br><br>  The third argument is also passed to the <code>elementStart</code> method.  After studying the above materials, we can conclude that the argument is optional and contains a list of attributes for the DOM node.  You can check this by looking at the <code>_c0</code> value and finding out that it contains a list of attributes and their values ‚Äã‚Äãfor the <code>div</code> element: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _c0 = [<span class="hljs-string"><span class="hljs-string">"style"</span></span>, <span class="hljs-string"><span class="hljs-string">"text-align:center"</span></span>];</code> </pre> <br><h2>  <font color="#3AC1EF">NgComponentDef note</font> </h2><br>  So far, we have analyzed the part of the generated code that is responsible for rendering the template for the component.  This code is actually in a larger code snippet, which is assigned by <code>AppComponent.ngComponentDef</code> , a static property that contains all the metadata about the component, such as CSS selectors, its change detection strategy (if specified), and the template.  If you feel adventurous, you can now figure out how it works, although we'll talk about it below. <br><br><h2>  <font color="#3AC1EF">Homemade ivy</font> </h2><br>  Now that we, in general terms, understand what the generated code looks like, we can try to create, from scratch, our own component using the same RendererV3 API that Ivy uses. <br><br>  The code that we are going to create will be similar to the code that the compiler produces, but we will make it so that it is easier to read. <br><br>  Let's start by writing a simple component, and then manually translate it into code, similar to the one that comes out of the Ivy output: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>, template: <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;&lt;font color="#3AC1EF"&gt;Hello, Component&lt;/font&gt;&lt;/h2&gt;'</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br>  The compiler takes as input information for the <code>@component</code> decorator, creates instructions, and then draws it all in the form of a static property of the component class.  Therefore, in order to imitate the activity of Ivy, we remove the <code>@component</code> decorator and replace it with the <code>ngComponent</code> static property: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.…µdefineComponent({   <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ManualComponent,   <span class="hljs-attr"><span class="hljs-attr">selectors</span></span>: [[<span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>]],   <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualComponent(),   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rf: core.…µRenderFlags, ctx: ManualComponent</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-comment"><span class="hljs-comment">//       }, }); }</span></span></code> </pre> <br>  We define the metadata for the compiled component by calling <code>…µdefineComponent</code> .  Metadata includes the type of component (used earlier for dependency injection), the CSS selector (or selectors) that will call this component (in our case, <code>manual-component</code> is the name of the component in the HTML template), a factory that returns a new instance component, and then the function that defines the pattern for the component.  This template displays a visual representation of the component and updates it when the component properties change.  In order to create this template, we will use the methods that we found above: <code>…µE</code> , <code>…µe</code> and <code>…µT</code> . <br><br><pre> <code class="hljs ruby">    <span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.…µRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; {     core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);                 <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2     core.…µT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, Component'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       core.…µe();                        <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2   },</code> </pre> <br>  At this stage, we do not use the <code>rf</code> or <code>ctf</code> parameters provided by our template function.  We will come back to them.  But first, let's look at how to bring our first homemade component to the screen. <br><br><h2>  <font color="#3AC1EF">First application</font> </h2><br>  In order to display components on the screen, Angular exports a method called <code>…µrenderComponent</code> .  All that needs to be done is to check that the <code>index.html</code> file has an HTML tag that corresponds to the element selector, <code>&lt;manual-component&gt;</code> , and then add the following to the end of the file: <br><br><pre> <code class="hljs">core.…µrenderComponent(ManualComponent);</code> </pre> <br>  That's all.  Now we have a minimal self-made Angular application consisting of only 16 lines of code.  You can experiment with the finished application on <a href="https://stackblitz.com/edit/angular-ivy-basic">StackBlitz</a> . <br><br><h2>  <font color="#3AC1EF">Change detection mechanism</font> </h2><br>  So, we have a working example.  Can you add interactivity to it?  Say, how about something interesting, like using the Angular change detection system here? <br><br>  Modify the component so that the user can customize the greeting text.  That is, instead of the component always displaying the text <code>Hello, Component</code> , we are going to allow the user to change the part of the text that comes after <code>Hello</code> . <br><br>  We start by adding the <code>name</code> property and the method to update the value of this property to the component class: <br><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualComponent</span></span> { name = <span class="hljs-string"><span class="hljs-string">'Component'</span></span>; updateName(newName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  So far all this does not look particularly impressive, but the most interesting is ahead. <br><br>  Next, we edit the template function so that, instead of the unchanged text, it displays the contents of the <code>name</code> property: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.…µRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :        core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;--   name   core.…µe(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :       core.…µt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ctx -     } },</code> </pre> <br>  You may have noticed that we wrapped the template instructions in <code>if</code> expressions that check the <code>rf</code> values.  This parameter is used by Angular to indicate whether the component is being created for the first time (the least significant bit will be <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">set</a> ), or we just need to update the dynamic content during the change detection process (this is the second <code>if</code> expression that is directed). <br><br>  So, when the component is displayed for the first time, we create all the elements, and then, when changes are detected, we only update what could have changed.  The internal method <code>…µt</code> responsible for this (note the lower-case letter <code>t</code> ), which corresponds to the <code>textBinding</code> function exported by Angular: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/347/c31/e48347c31b7532a1268509cf0825a031.png"></div><br>  <i><font color="#999999">TextBinding function</font></i> <br><br>  So, the first parameter is the index of the item to be updated, the second is the value.  In this case, we create an empty text element with index 2 <code>core.…µT(2);</code> command <code>core.…µT(2);</code>  .  It plays the role of placeholder for <code>name</code> .  We update it with the <code>core.…µt(2, ctx.name);</code> command <code>core.…µt(2, ctx.name);</code>  when a change in the corresponding variable is detected <br><br>  At the moment, when this component is displayed, the text <code>Hello, Component</code> will still appear, although we can change the value of the <code>name</code> property, which will change the text on the screen. <br><br>  To make the application truly interactive, we will add a data entry field with an event listener, which calls the <code>updateName()</code> component method: <br><br><pre> <code class="hljs php">template: (rf: core.…µRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.…µT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   core.…µe();   core.…µT(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'Your name: '</span></span>);   core.…µE(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'input'</span></span>);   core.…µL(<span class="hljs-string"><span class="hljs-string">'input'</span></span>, $event =&gt; ctx.updateName($event.target.value));   core.…µe(); } <span class="hljs-comment"><span class="hljs-comment">// ... },</span></span></code> </pre> <br>  Event binding is performed in the <code>core.…µL('input', $event =&gt; ctx.updateName($event.target.value));</code> line <code>core.…µL('input', $event =&gt; ctx.updateName($event.target.value));</code>  .  Namely, the <code>…µL</code> method <code>…µL</code> responsible for setting the event listener for the most recent of the declared elements.  The first argument is the name of the event (in this case, <code>input</code> is the event that is called when the content of the <code>&lt;input&gt;</code> element changes), the second argument is the callback.  This callback accepts event data as an argument.  Then we retrieve the current value from the target element of the event, that is, from the <code>&lt;input&gt;</code> element, and pass it to the function in the component. <br><br>  The above code is equivalent to writing the following HTML code in a template: <br><br><pre> <code class="hljs pgsql">Your <span class="hljs-type"><span class="hljs-type">name</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>)="updateName($event.target.value)" /&gt;</code> </pre> <br>  Now you can edit the contents of the <code>&lt;input&gt;</code> element and observe how the text in the component changes.  However, the input field is not filled when the component is loaded.  In order for everything to work that way, you need to add another instruction to the template function code that is executed when a change is detected: <br><br><pre> <code class="hljs coffeescript">template: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.…µRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   core.…µt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);   core.…µp(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, ctx.name); } }</code> </pre> <br>  Here we use another built-in rendering system method, <code>…µp</code> , which updates the property of an element with a given index.  In this case, the method is passed an index of 4, which is the index assigned to the <code>input</code> element, and instructs the method that it should put the value of <code>ctx.name</code> in the <code>value</code> property of this element. <br><br>  Now our example is finally ready.  We implemented, from scratch, two-way data binding using the Ivy rendering system API.  This is just great. <br>  <a href="https://stackblitz.com/edit/angular-ivy-hello">Here</a> you can experiment with ready-made code. <br><br>  Now we are familiar with most of the basic building blocks of the new Ivy compiler.  We know how to create elements and text nodes, how to bind properties and configure event listeners, how to use the change detection system. <br><br><h2>  <font color="#3AC1EF">About * ngIf and * ngFor blocks</font> </h2><br>  Before we finish the Ivy study, consider another interesting topic.  Namely, let's talk about how the compiler works with subpatterns.  These are the templates that are used for <code>*ngIf</code> or <code>*ngFor</code> .  They are processed in a special way.  Let's look at how to use <code>*ngIf</code> in the code of our self-made template. <br><br>  First you need to install the <code>@angular/common</code> npm-package - it is here that <code>*ngIf</code> .  Next, you need to import the directive from this package: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">import</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">NgIf</span></span> } from <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@angular</span></span></span><span class="hljs-string">/common'</span></span>;</code> </pre> <br>  Now, in order to be able to use <code>NgIf</code> in a template, you need to provide it with some metadata, since the <code>@angular/common</code> module was not compiled using Ivy (at least during the writing of the material, and in the future this will probably change from introduction <a href="">ngcc</a> ). <br><br>  We are going to use the <code>…µdefineDirective</code> method, which is related to the already familiar <code>…µdefineComponent</code> method.  It defines metadata for directives: <br><br><pre> <code class="hljs coffeescript">(NgIf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ngDirectiveDef = core.…µdefineDirective({ type: NgIf, selectors: [[<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]], factory: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NgIf(core.…µinjectViewContainerRef(), core.…µinjectTemplateRef()), inputs: {ngIf: <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, ngIfThen: <span class="hljs-string"><span class="hljs-string">'ngIfThen'</span></span>, ngIfElse: <span class="hljs-string"><span class="hljs-string">'ngIfElse'</span></span>} });</code> </pre> <br>  I found this definition in <a href="">the Angular source code</a> , along with the <code>ngFor</code> .  Now that we have prepared <code>NgIf</code> for use in Ivy, we can add the following to the list of directives for the component: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.…µdefineComponent({ directives: [NgIf], <span class="hljs-comment"><span class="hljs-comment">// ... });</span></span></code> </pre> <br>  Next, we define a subpattern only for the partition bounded by <code>*ngIf</code> . <br><br>  Suppose you need to display an image here.  Let us define a new function for this template inside the template function: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.…µRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.…µE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'div'</span></span>);   core.…µE(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'img'</span></span>, [<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://pbs.twimg.com/tweet_video_thumb/C80o289UQAAKIqp.jpg'</span></span>]);   core.…µe(); } }</code> </pre> <br>  This feature of the template is no different from the one we have already written.  It uses the same constructs to create an <code>img</code> element inside the <code>div</code> element. <br><br>  And finally, we can put all this together by adding the <code>ngIf</code> directive to the component template: <br><br><pre> <code class="hljs coffeescript">template: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.…µRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...   core.…µC(<span class="hljs-number"><span class="hljs-number">5</span></span>, ifTemplate, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...   core.…µp(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, (ctx.name === <span class="hljs-string"><span class="hljs-string">'Igor'</span></span>)); } function ifTemplate(rf: core.…µRenderFlags, ctx: ManualComponent) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } },</code> </pre> <br>  Note the call to the new method at the beginning of the code ( <code>core.…µC(5, ifTemplate, null, ['ngIf']);</code> ).  It declares a new container element, that is, an element that has a template.  The first argument is the element index; we have already seen such indexes.  The second argument is the sub-template function that we have just defined.  It will be used as a template for the container element.  The third parameter is the tag name for the element, which does not make sense here, and finally there is a list of directives and attributes associated with this element.  This is where <code>ngIf</code> comes into <code>ngIf</code> . <br><br>  In the line <code>core.…µp(5, 'ngIf', (ctx.name === 'Igor'));</code>  the element state is updated by binding the <code>ngIf</code> attribute to the value of the logical expression <code>ctx.name === 'Igor'</code> .  Here we check whether the <code>name</code> property of the component is equal to the string <code>Igor</code> . <br><br>  The above code is equivalent to the following HTML code: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name === 'Igor'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Here it can be noted that the new compiler produces not the most compact code, but it is not so bad in comparison with what is now. <br><br>  You can experiment with a new example <a href="https://stackblitz.com/edit/angular-ivy-ngif">here</a> .  In order to see the <code>NgIf</code> section in action, enter the name <code>Igor</code> in the field <code>Your name</code> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  We pretty much traveled on the features of the Ivy compiler.  Hope this trip has sparked your interest in further Angular research.  If this is so, then now you have everything you need to experiment with Ivy.  Now you know how to "translate" templates in JavaScript, how to access the same Angular mechanisms that Ivy uses, without using this compiler itself.  I think all this will give you the opportunity to explore the new mechanisms of Angular as deeply as you like. <br><br>  <a href="https://blog.angularindepth.com/ivy-engine-in-angular-first-in-depth-look-at-compilation-runtime-and-change-detection-876751edd9fd">Here</a> , <a href="https://blog.angularindepth.com/angular-ivy-change-detection-execution-are-you-prepared-ab68d4231f2c">here</a> and <a href="">here</a> - three materials in which you can find useful information about the Ivy.  And <a href="">here</a> is the source code for Render3. <br><br>  <b>Dear readers!</b>  How do you feel about the new features Ivy? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/419995/">https://habr.com/ru/post/419995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419985/index.html">Klats, klats: the story of Cherry, famous for the switches for keyboards</a></li>
<li><a href="../419987/index.html">What do the drops of blood tell: trigonometry of crimes</a></li>
<li><a href="../419989/index.html">New Zealand bans plastic bags</a></li>
<li><a href="../419991/index.html">Autonomous drones will drive away flocks of birds from airports</a></li>
<li><a href="../419993/index.html">TypeScript Interview: 20 questions and answers</a></li>
<li><a href="../419999/index.html">Sharing Authentication yii1 / yii2</a></li>
<li><a href="../420001/index.html">Introducing 3CX v15.5 Update 6 BETA and WebRTC browser softphone</a></li>
<li><a href="../420003/index.html">Window with JavaFX buttons:</a></li>
<li><a href="../420007/index.html">FidgetPen, strange lamp and splitter cubes: getting to know Allocacoc</a></li>
<li><a href="../420009/index.html">Subtleties of product design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>