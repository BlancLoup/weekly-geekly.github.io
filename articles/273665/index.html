<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of programming languages ‚Äã‚Äãand compilers in the USSR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The ideal programming language is the same unattainable dream as the ideal life. But the pursuit of excellence leads to the emergence of things that m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of programming languages ‚Äã‚Äãand compilers in the USSR</h1><div class="post__text post__text-html js-mediator-article">  <i>The ideal programming language is the same unattainable dream as the ideal life.</i>  <i>But the pursuit of excellence leads to the emergence of things that make our lives better.</i>  <i>Skeptics can see in this invention the next bike.</i>  <i>But this is not in vain: if the next bike does not become better than the former, the process itself improves the inventors.</i>  <i>The bike can be forgotten and thrown out, but the inventors will gain engineering experience.</i> <br><br><img src="https://habrastorage.org/files/e1e/e5e/b1a/e1ee5eb1a8974f98b40b319b63d9bebf.jpg"><br><br><h3>  Programmer - first compiler </h3><br>  The founder of computer science in the USSR, in particular the programming automation section, is Alexei Andreevich Lyapunov, who first proposed to consider the program as a sequence of alternating stages in which some kind of data processing is performed.  Stage Lyapunov proposed to call the operator, and the scheme of the account - a set of operators and logical conditions.  The scheme and set of specifications for each operator is a program. <a name="habracut"></a>  A look at the program in this way became revolutionary and immediately formed the basis of the first translators (compilers) or programming programs, as they were then called. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/7d7/5e6/bc0/7d75e6bc0fb640d68f8721f2240e82f1.png"><br>  <i>M. R. Shura-Bura, A. A. Lyapunov, S. S. Kamynin</i> <br><br>  The world's first translator of high-level language is PP (Programming Program), aka PP-1, successfully tested in 1954.  The translator PP-2 (1955, 4 in the world translator) was already optimizing and contained its own loader and debugger, a library of standard procedures. <br><br>  The first programs belonging to the system software were translators - assemblers and auto codes in the West; we have programming programs. <br><br>  The programming department investigated the feasibility of operator schemes and identified the main types of operators that correspond to the tasks to be solved: Ai - arithmetic operators, Pi - logical operators that control the account, Fi - redirection operators, which allow you to move to the next index value. <br><br>  The first domestic translators carried the mnemonic name of programming programs.  At the heart of the input language of each of the programming programs lay a common conceptual basis, fixing the types of operators and the general idea of ‚Äã‚Äãtheir specification.  The unification of languages ‚Äã‚Äãwas not posed as a practical task. <br><br>  The types of operators corresponded to the overwhelming majority of the problems solved at that time, namely, to computational problems.  Arithmetic operators i were distinguished, leading the calculation by formulas, logical operators Pi, carrying out account management, forwarding operators Fi, allowing to move to the next index value (and their inverse recovery operators), yet non-arithmetic calculations were combined into so-called non-standard operators Hi, for which the specification was their machine code.  There was no special sublanguage for describing data, the beginnings of which appeared in later FORTRAN and Algol. <br><br>  The programming program PP-1 was one of the first translators in world practice and, apparently, had the highest level of the input language. <br><br>  The programming program PP-2 was created under the direction of M.R.Shura-Bura in 1955 for the Strela-1 machine, based on PP-1 as a prototype.  In PP-2, translation algorithms were improved and considerable attention was paid to optimizing programs ‚Äî saving expressions, optimally combining redirection and recovery (in other words, the best implementation of calculating index expressions), and optimal memory allocation for so-called work cells.  This was, apparently, the first optimizing translator. <br><br><img src="https://habrastorage.org/files/c2d/77d/8db/c2d77d8db42a4d53bb42315cc0fd7d1e.png"><br>  <i>Arrow-1.</i>  <i>The principle of interaction of computer nodes</i> <br><br>  Software for BESM developed an input programming language.  It combined the scheme and specification of operators in one text, the first structured operator was introduced - the cycle operator (corresponding to modern cycles with a parameter). <br><br>  PP-2 served as the ideological basis of two projects - PP for Arrow 4 and PP for Arrow 7. The first of these was the germ of this programming system: besides the translator itself, it contained a module assembly system and some debugging tools.  The translator received such fragments of the object program, which would then be called modules, and the build system created the program from the translated modules and library programs. <br><br>  In software for Arrow 3, a number of ideas were implemented - a tabular approach to syntactic analysis, optimal (in terms of the number of working variables) programming of arithmetic expressions.  A hashing method was invented and applied to the economy of arithmetic expressions. <br><br>  Since the broadcast began not only system, but also theoretical programming.  It was the work on input languages ‚Äã‚Äã(operator schemes) and translators (programming programs) that triggered the creation of the first mathematical model of programs - the Janov schemes. <br><br>  In the late fifties of the last century, the approach to programming automation using standard program libraries also developed.  A standard component program, the SSP (performed static loading and linking of standard programs from a fairly extensive library), an interpretive system (IS), the IS-2 already implemented some functions of future operating systems, performing dynamic linking, swapping and changing of the used subroutines, All this was done with little overhead and very modest memory requests.  The high efficiency of the IS-2 and the well-thought-out interface with the main program made it (as it should be for the operating system) an integral part of the computer delivery set. <br><br>  Despite all its advantages, programming programs did not have wide practical use: <blockquote>  even with their presence in almost all of the many architectures that existed in the country, the proportion of programming directly in machine language was predominant.  The transition to modern programming style in high-level programming languages ‚Äã‚Äãwas made possible thanks to the creation of the first Algol translators.  It happened so that the first three of the domestic Algol translators, created for the most massive then M-20 computer, differed in their consumer possibilities so that with their totality they satisfied almost all categories of users. <br></blockquote><br>  The emergence of system programming has set the task of creating adequate programming languages.  All the languages ‚Äã‚Äãthat appeared at the beginning of the 60s ‚Äî Fortran, Kobol, Algol-60, and others ‚Äî did not take this area of ‚Äã‚Äãprogrammer activity into account, and Algol systems, being fairly large software systems, were written in machine codes manually.  Adequate languages ‚Äã‚Äãwere needed not only for translators, but also for the whole emerging area of ‚Äã‚Äãsystem programming: other language processors began to appear, and the first operating systems and information systems ‚Äî everything that would later be called basic software. <br><br><h3>  ALGOL </h3><br><img src="https://habrastorage.org/files/c3b/856/54e/c3b85654ecee48dfb99054d001709a16.jpeg"><br><br>  <i>A. A. Bers, A. F. Rahr ‚ÄúFormation of the Novosibirsk School of Programming.</i>  <i>Mosaic of memories ":</i> <br><blockquote>  What impressed me in Algol 68?  First, it was the first language in which there was a very rich list of means for describing types, and you can very clearly and formally describe structures with variants and combine them with arrays, etc., etc., and all that about doing it.  Secondly, there was a wonderful mechanism of ghosts, which allowed to use the described types deeply enough to transfer values ‚Äã‚Äãto them.  And of course, the two-story grammar itself.  And here I already had the desire to use this in order to make a good Russian translation. <br><br>  In general, in Algol 68, the structure of the language was superbly accomplished: verbal equivalents of symbols, closing brackets for conditional constructions (for example: while the kl all flourish in the Central Committee in Kiev), choosing sentences, parallel phrases, well-conducted struggle with adverse effects they were not prohibited. <br><br>  As van Vayngaarden liked to say: ‚Äúdon't write such programs‚Äù and ‚Äúif you have a language, then you need to be able to express yourself on it‚Äù. <br><br>  Yes, another great thing that was there was the output of the value of almost any design, which allowed wide use of superposition in the construction of expressions.  It is important to realize the fact that the value that the expression gives is once unique and unique and that it can only be used in two different ways.  Either you pick it up with a superposition, or you must hide it as the state of an object.  In the first case, this value should not be given a designation, then its use is hidden from you, as it were.  Because this value itself cannot be seen, and it is not named by anything.  On the other hand, if you don't pick it up, it will disappear. <br><br>  Now everything is very good in object languages: you have to bring an object to a certain state using this value.  Citing, you can read this value from this state as many times as you need, and get what it means.  That is, this composite program very beautifully allowed to write syntactic expressions of a very coherent nature.  And since programming languages ‚Äã‚Äãalways carried English jargon, and not language, but jargon ... One more thing was, in my opinion, essential - this is work on the creation of Russian national versions of Algol 68. Ershov and I, we tried to so that everything can be written without Latin letters, so that programs can be practically read out loud - a thing inaccessible to previous languages.  And the syntax was generally translated as a mathematical verse - all the rules are preserved, and the mnemonic meaning, and the exact form. <br><br>  And, in general, the language was pretty slim.  But the complexity of it added, in my opinion, the standard entry.  It was even more minimized written program text with additional macro add-ons. </blockquote><br>  The only domestic programming language that has received worldwide fame is <b>Refal</b> .  However, the prevalence of this language is small.  The first version of Refal was created in 1966 by Valentin Turchin as a metalanguage for describing the semantics of other languages.  Subsequently, as a result of the emergence of sufficiently effective implementations on a computer, he began to find practical use as a programming language.  Currently, the main dialects of the language are Refal-2 (1970s), Refal-5 (1985) and Refal + (1990), differing from each other in details of the syntax and a set of additional tools that extend the original version. <br><br><h3>  Refal programming language </h3><br>  Refal is a language for manipulating symbolic objects such as texts, formulas, programs, etc.  The Refal program consists of functions that can be defined through each other - recursively.  Hence the name: algorithmic language of recursive functions.  In addition to describing the semantics of algorithmic languages, he found other equally important applications.  First of all, it is the machine execution of cumbersome analytical calculations in theoretical physics and applied mathematics, the interpretation and compilation of programming languages, the machine proof of theorems, the simulation of purposeful behavior, etc. <blockquote> Common to all these applications is that we force the machine to perform complex transformations on objects defined in some formalized languages ‚Äã‚Äã(algorithmic languages, the language of algebra, the language of the predicate calculus, etc.). </blockquote><br><br>  Refal is a typeless language.  It is based on the concept of an object expression as a universal data type.  All arguments and results of all functions are object expressions. <br><br>  An object expression is defined in such a way that the concatenation operation is made implicit, hidden.  More precisely, concatenation at the level of values ‚Äã‚Äãis expressed by concatenation at the level of names.  This property derives from the main goal of Refal as a metalanguage for describing various language objects.  It gives a special expressive power to the other means of the language, such as samples and result expressions. <br><br>  Samples - a powerful visual tool.  In a concise and visual form, they provide both the recording of conditions on the type of argument, and the division of the argument into its component parts.  Refal‚Äôs language is devoid of any ‚Äúsimplifying‚Äù limitations inherent in other languages, which makes it very easy to learn and use. <br><br>  The Refal function definition language based on the concepts of the pattern and the resulting expression is extremely simple and compact.  Its minimal version is called the Base Refal.  The Basic Refal dialect called Refal-2 was implemented on many types of domestic computers and for a long time played the role of the de facto standard of the Refal language. <br><br>  Refal-5 contains the Base Refal as a subset.  Refal-5 language extensions qualitatively change the programming style. <br><br>  Currently, there are two implementations of the Refal-5 language: one done by D. Turchin, the other by N. Kondratiev and Ark.  Klimov.  Both have almost the same input language, but differ in a number of implementation features.  The second is also known as Refal-6, but remember that this name is not a language, but its implementation. <br><br>  The Refal Plus language was also developed, in contrast to Refal-5, which was brought up to conceptual completeness (extension of the refal by means of processing failures). <br><br>  1997  Refal firmly occupies its niche, without fear of any competitors.  For example, it is successfully used by Obninsk physicists, many mathematical centers in Russia.  One of the main applications of Refal is the development of translators from programming languages, when Refal itself is used as a metalanguage.  At IPM, the highly efficient Cern Fortran translator was written very quickly. <br><br>  Refal did not ignore the military.  Modern military equipment often requires modification of development tools, making them adequate to the growing capabilities of electronics, and Refal supports the creation of rapidly improving highly specialized programming languages.  One of the interesting areas in which Refal is applied is artificial intelligence (AI).  In AI, Refal is used both as a final developer‚Äôs tool and as a tool for creating knowledge languages ‚Äã‚Äãthat are targeted for specific applications in AI.  One of the fundamental directions for effectively using the power of Refal is the analysis of natural languages.  With the help Refal created linguistic processors, expert systems. <br><br><h3>  Almo programming language </h3><br>  A system programming language (machine-oriented language), conceived as an intermediary language for broadcasting from various languages.  For each hardware platform, it was enough to write the Almo translator - and there was an opportunity to work with a variety of programming languages ‚Äã‚Äãthat had a broadcast in Alma.  Language implementations for the main domestic machines of the time (M-20, BESM-6, Minsk 2, Ural 11) and translators from Algol-60 and FORTRAN in Almo were created, and all the translators were also written in Almo and promoted these machines.  The language of Almo was based on some abstract machine, reflecting a feature of the then existing class of machines, and in this regard, the Almo approach anticipated the P-code, M-code, and other similar approaches that appeared later.  Machine orientation was clearly traceable in the language ‚Äî register objects, postfix writing of expressions, operating with machine word bits, etc. <br><br><h3>  Sigma programming system </h3><br>  <i>G. G. Stepanov:</i> <br><blockquote>  ... the name of the language - Sigma - unexpectedly very successfully began to correspond to the essence of the developed language, which can be described as "Symbol Generator and Macroassembler". <br>  In total, in the history of the Sigma language there were three of its implementations: on the M-20, on the BESM-b, and on the Sigma language itself.  The first, of course, the most memorable, because  This was the first work in the field of system programming (and indeed the first work).  The second one was performed on the best, in my opinion, BESM-6 domestic car.  The third relied on the second, was promoted through itself and could generate programs for both BESM-6 and SM-4 and EC computers. </blockquote><br><img src="https://habrastorage.org/files/c62/755/e2b/c62755e2bbd84585a136e8c67ee64c19.png"><br><br>  Sigma - Symbol Generator and Macroassembler - had two important and at the time new features.  Syntactically limited by macros, he allowed the general line of program creation - the substitution of the described macros.  The language contained the means of formal description of a specific architecture: a system of parameters was developed, in terms of which the representation of the language for a specific computer was fixed.  Thus, the general Sigma program, along with a description of the computer architecture, was broadcast on this computer.  The architecture parameters were the word length, the representation of the values ‚Äã‚Äãof types in the machine word, etc., as well as the rules for filling in machine instruction patterns. <br><br><h3>  Universal Machine-Oriented Programming Language Epsilon </h3><br>  Elementary Converter SIMVOLNOY information - was considered extremely simple language.  The variables in it had no type and were not described, the variable identifier simply denoted the contents of the cell reserved for this variable.  Constants in the language could be either natural numbers, or octal numbers, or - sets of binary digits.  The expressions were only two-place;  arithmetic expressions are treated with the values ‚Äã‚Äãof the operands, as with representations of natural numbers;  there were also bitwise operations, shearing operations, and the operation of retrieving the address of a given object (allowing the programmer to manage to some extent the memory allocation).  The objects of the language were the so-called lists (packed arrays) and words (sequences of elements of different lengths that fit in one machine word).  A programmer could specify a binary encoding for a character or a set of binary encodings for a character class.  There were transitions to the conditional conditional and unconditional as well as procedures, closed and open. <br><br>  The legal operator of the language was the machine command presented in octal form.  It is in this form that I / O operations should have been performed.  The tables used by the program were stored as tagged sequences of machine instructions;  after combining such a sequence in memory with some described list, the programmer could use the mechanism of selecting a list element to select a table element. <br><br>  <i>A. F. Rahr:</i> <br><blockquote>  The stated goal of language developers was to provide a convenient working tool for system programmers ... <br>  We sought to achieve a reasonable compromise between such requirements as simplicity and convenience of language means, ease of translation and the possibility of obtaining an effective program ... <br>  This debugging consisted in the classical bootstrapping: I passed the Epsilon-text of the translator through the manually-written Epsilon-translator, and I tested the resulting new translator with normal Epsilon-programs.  This promotion gave an answer to ... the question: "[how much] programs obtained by Epsilon-broadcasting lose compared to programs written by hand?" It turned out ... only 1.35 times. </blockquote><br><br><h3>  Beta Programming System </h3><br>  The Beta project was based on the assumption of the convergence of the main algorithmic languages, as well as methods of translation and optimization.  Initially, Algol 68 and PL / 1 were considered the main input languages.  The Pascal language was born simultaneously with the beginning of work on the Beta project and was soon included in the list of its input languages ‚Äã‚Äãas the main input language of the "test implementation" of the BETA system. <br><br>  The central link of the Beta project was the Inner Language, which was to become the single intermediary language in the BETA system ‚Äúthe greatest common divisor‚Äù of the input languages ‚Äã‚Äãand the ‚Äúleast common multiple‚Äù of the output machines.  In addition to this role of an intermediate language, which allows to reduce the number of paths in the m-language n-machine translation scheme from m * n to m + n, the internal language should also be an environment of optimizing transformations, i.e.  it still had to be rich enough for it to be able to present optimization results;  for example, saving of coinciding subexpressions in the operator a [i, j, k]: = b [i, j, k] + c [i, j, k]. <br><br>  At the same time, it was supposed to try too many innovations: multilingualism at the entrance, multi-machine operation at the exit;  New languages ‚Äã‚Äã(for example, at the beginning of work there were only incomplete experimental translators with Algol 68) and new optimization methods for new applied areas ‚Äî all within the framework of a research institute, semi-productive work by employees, focused on obtaining scientific results. <br><br><h3>  Avtokod MVK Elbrus - El-76 </h3><br><img src="https://habrastorage.org/files/6ca/62e/c32/6ca62ec32ee5400c98c47a20e405ed92.png"><br><br>  <i>From the book of V.M.</i>  <i>Pentkovsky about the Elbrus auto code.</i> <i><br></i>  <i>In Soviet times, did not hesitate to program in Russian</i> <br><br>  Initially, this language was called the Elbrus auto code, then it was renamed El 76.  Despite the fact that El-76 is a language of a fairly high level, there is reason to call it "auto code".  Elbrus simply did not have a lower level language, i.e.  "Assembler".  Those.  the minimum level language Elbrus is El-76, the other languages ‚Äã‚Äãhave already been built on it.  This is a wonderful illustration of the high scientific and engineering level of domestic IT at the time. <br><blockquote>  El-76 is a programming language using Russian vocabulary.  Developed in the mid-70s in the USSR.  El-76 is designed for multi-machine computing complexes of the Elbrus type.  It combines the features of the machine language, which directly controls the operation of computer devices, and graphic means of a high-level language (in many respects similar to Algolu-68).  El-76 supports the structured programming methodology, i.e.  program composition from procedures, linear sequences of operators, cycles, alternative joints with a choice of alternatives by condition or alternative number and branches executed in parallel.  The language has special means of describing the behavior of the program in special cases - the so-called.  situations and structural transitions.  The main feature of the El-76 is the ability to store in the computer memory information about the type of a variable value along with its value and its changes during the execution of the program. </blockquote><br><h3>  Rapier </h3><br><img src="https://habrastorage.org/files/8e4/9a9/7e3/8e49a97e331143d7a092574c5a2cc333.png"><br><br>  The programming language Rapier is one of the two input languages ‚Äã‚Äãof the educational programming system that is part of the ‚ÄúSchoolgirl‚Äù integrated software environment.  Rapier is a concentric family of languages ‚Äã‚Äãwith a consistently expandable set of features.  Each concentr can be considered as a closed language-shell. <br><br>  If interested (and if there is time): <br><div class="spoiler">  <b class="spoiler_title">A complete description of the syntax of the language and brief information about the semantics of its main constructions is given.</b>  <b class="spoiler_title">According to document 3533847.00042-01 35 01 from the archive of academician A.P. Ershov: Language description</b> <div class="spoiler_text">  <b>1. General information</b> <br><br>  1.1.  Rapier is a high-level interactive language intended for teaching programming and solving small applied problems on a computer.  The language is primarily aimed at middle-aged and older schoolchildren (11-17 years old), but can be used by other categories of users. <br><br>  1.2.  Rapier, along with Robik, is the input language of the Schoolgirl programming system.  As with the Robik language, nadprogrammed operations in Rapier are performed by non-language system tools. <br><br>  1.3.  The first version of the Rapier was developed in 1978-1979 and was used in school work with schoolchildren and students.  During the development of the "Schoolgirl" system, the language was completely redesigned. <br><br>  1.4.  Rapier is a concentric family of languages ‚Äã‚Äãwith a consistently expandable set of features.  Each concentr can be considered as a closed language-shell. <br><br>  This document provides a brief description of the main features of the external concentration of the canonical (school) version of the Rapier. <br><br>  1.5.  Russian is chosen as the base ethnic language for the Rapier.  In the process of implementing the language on the instrumental computer, an English version was also developed.  Work is underway on the Estonian and Georgian versions.  It is possible to create versions based on other languages. <br><br>  <b>2. Vocabulary and general program structure</b> <br><br>  2.1.  The lexical structure of the Rapier is almost the same as Robik‚Äôs vocabulary, described in document 3533847.00058-01¬§35-02.  In Rapier, the same lexical units are distinguished: whole and fractional numbers, texts, words, special characters.  The form of these tokens is traditional.  The main differences between the Rapier and Robik are as follows: <br><br>  1. It is allowed to write fractional numbers in an exponential form, for example, 156.65E12 means 156.65x1012. <br><br>  2. Unary + and - are not considered as components of the lexeme, but as operations. <br><br>  3. In Rapier, there are several times more special characters, including compound ones, than in Robik. <br><br>  2.2.  The general structure of the program and the order of execution of individual regulations on Robik and Rapier have much in common.  A Rapier Program is a sequence of directives, procedural blocks, and name descriptions.  The procedure for working with directives and procedural blocks is the same as in Robik. <br><br>  2.3.  Unlike Robik, arbitrary arrangement of prescriptions by lines is allowed (you can write several prescriptions on one line and distribute one prescription on several lines).  Spaces and line breaks can be used anywhere in the program, but not inside lexemes (syntactically significant spaces can be used inside texts).  Between two tokens that are not context sensitive, at least one space or newline is required. <br><br>  The comment in Rapier is in special brackets.  The comment is syntactically equivalent to a space and can be inserted between any two lexemes. <br><br>  <b>3. Names and expressions</b> <br><br>  3.1.  Rapier is a partly typed language.  Each name used in a program or procedure block can be described with an indication of the type.  A name type defines the kinds of values ‚Äã‚Äãthat can be assigned to that name.  If the name is not described or described without specifying a type, it defaults to a universal type.  Such a name can be assigned values ‚Äã‚Äãof any kind. <br><br>  In the online version of the Rapier, the description of the names is used as a debugging tool.  It is assumed that in the batch version the descriptions should be mandatory. <br><br>  The scope of the descriptions covers the main program, the procedural block in which the name is described, and all the procedures and functions called from it that do not describe the local names and formal parameters that coincide with it in writing.  Thus, the descriptions simultaneously determine the localization of names. <br><br>  Name descriptions and type indications in Rapier are not required, therefore, for the quick solution of small tasks, it can be used as a typeless language. <br><br>  3.2.  In Rapier, the following types of name values ‚Äã‚Äãare distinguished: <br><br><ol><li>  whole numbers </li><li>  fractional numbers </li><li>  texts </li><li>  sets </li><li>  tuples </li><li>  procedures </li><li>  functions </li><li>  files </li><li>  modules </li><li>  drawings </li><li>  frames </li><li>  tables </li><li>  empty value </li></ol><br>  3.3.  All names other than standard, which have not been assigned values ‚Äã‚Äãin this program, have an empty value.  The system provides a protected standard name NULL, which is always null. <br><br>  3.4.  Over any pairs of names in Rapier, a TYPE comparison operation is defined, the result of which is TRUE if the declared types of names are the same and FALSE otherwise. <br><br>  Over any pairs of values ‚Äã‚Äã(expressions), the operation of comparing the TYPE is defined, the result of which is TRUE, if the types of values ‚Äã‚Äãof these expressions are the same. <br><br>  3.5.  The following operations are defined above the numbers in Rapier: <br><br>  unary arithmetic: + and -; <br>  binary arithmetic: +, -, *, /, // (division completely), ** (exponentiation); <br>  comparison operations: =, / =, &lt;=,&gt; =, &lt;,&gt; <br>  All operations have the usual mathematical meaning;  it is allowed to compare integers and fractional numbers for equality: the condition 35 = 35.0 is considered true. <br><br>  3.6.  The following operations are defined above the texts: <br><br>  + - concatenation (merging of texts), for example, <br>  <i>"Led" + "ipon" = "bicycle"</i> ; <br><br>  FROM - check whether the character belongs to the text, for example, <br>  <i>"M" OF "microscope" is true</i> ; <br><br>  [] - sampling (taking a character from the text by index), for example, <br>  <i>‚ÄúBicycle‚Äù [5] = ‚Äús‚Äù</i> ; <br><br>  [:] - clipping (selection of text on the initial and final indices), for example, <br>  <i>‚ÄúCrocodile‚Äù [2: 4] = ‚Äúrock‚Äù</i> ; <br><br>  # - power (unary operation that determines the number of characters in the text), for example, <br>  <i># "Airplane" = 7</i> . <br><br>  =, / = - text comparison. <br><br>  In the operations of cutting and sampling, any expressions can be used as indices, the values ‚Äã‚Äãof which are natural numbers not exceeding the power of the corresponding text.  The left index in the clipping should not exceed the right. <br><br>  These two operations can occur both on the left and on the right of the assignment mark, allowing in the latter case text editing.  The length of the text when editing cannot be changed: the substituted text must have the same length as the replaced area.  For example, after assignments: <br><br>  <i>"Crocodile" -&gt; Beast;</i>  <i>‚ÄúOsh‚Äù -&gt; Beast [2: 3];</i> <br><br>  the name Beast will receive the value "cat".  Assignments <br><br>  <i>‚ÄúKosh‚Äù -&gt; Beast [2: 3];</i>  <i>‚ÄúA‚Äù -&gt; Beast [2: 3];</i> <br><br>  are unacceptable because of the discrepancy between the lengths of the replacement and the replaced parts of the text. <br><br>  3.7.  Composite data structures in the interactive version of the Rapier are represented by sets, records and tuples.  Each of these structures can contain an arbitrary number of elements.  The structure element can be any language object, regardless of its type. <br><br>  In the batch version, typed versions of these constructions are allowed: all elements of sets and tuples must be of the same type, and in the records each element must be of a certain type. <br><br>  A set is considered as an unordered collection of pairwise different elements.  Access to a single element of the set is not possible.  Only the verification of the belonging of an element to a set, operations on the whole set and the sequential search of its elements using a special form of the cycle are allowed. <br><br>  A record is treated as an unordered collection of named fields.  Access to the entry element is possible only through the field name. <br><br>  A tuple is considered as an ordered collection of arbitrary elements.  Access to a tuple item is possible by index. <br><br>  This operation allows you to build a new structure from an arbitrary number of elements represented by the values ‚Äã‚Äãof expressions.  For the formation of the desired structure, it is necessary to list all expressions separated by commas, the values ‚Äã‚Äãof which should become elements of the structure, and enclose them in special brackets, the shape of which is determined by the type of structure.  Simple angle brackets &lt;&gt; define the formation of a tuple, curly brackets {} or (* *) - the formation of a set, special brackets &lt;$ $&gt; - the formation of a record.  In addition, when creating a record, before each element the field name must be indicated, separated from the elements by a colon. <br><br>  For example, the expression &lt;2, ‚Äúsearch‚Äù, 5.3, A&gt; defines the formation of a tuple of four elements: the number 2, the text ‚Äúsearch‚Äù, the number 5.3 and the meaning of the name A. The expression {2, ‚Äúword‚Äù, 2, 2} defines the formation sets of two elements: the number 2 and the text "word".  The expression &lt;$ First Name: ‚ÄúSergey‚Äù, Last Name: ‚ÄúIvanov‚Äù, Year of Birth: 1950 $&gt; defines the formation of a record of three fields: Name, Last Name and Year of birth. <br><br>  3.9.  For all structures, the following operations are defined: <br><br>  FROM - check accessory; <br><br>  # - determination of power (number of elements); <br><br>  = and / = - comparison for equality and inequality. <br><br>  It should be noted that two entries with different field structures are considered to belong to different types. <br><br>  Two sets are considered equal if they consist of the same elements, regardless of the order in which they are written, for example, <br><br>  (* 1, 5, 5, &lt;1, 2&gt;, 1, *) = (* 5, &lt;1, 2&gt;, 1, *) <br><br>  Two tuples are considered equal if they consist of the same elements arranged in the same order, for example: <br><br>  &lt;1, 5, &lt;1, 2 "= &lt;1, 2 + 3, &lt;1, 1 + 1" <br><br>  &lt;1,2,3&gt; / = &lt;3,2,1&gt; <br><br>  Two records with the same field structure are considered equal if the fields of the same name have the same values, for example: <br><br>  &lt;$ First Name: ‚ÄúSergey‚Äù, Last Name: ‚ÄúIvanov‚Äù $&gt; = <br>  &lt;$ Last name: "Ivanov", First Name: "Sergey" $&gt; <br><br>  &lt;$ Number: 5, Speed: $ 10&gt; / = &lt;$ Type: 5, Height: $ 10&gt; <br><br>  3.10.  In addition to the operations listed in paragraphs 3.4, 3.6 and 3.9, over the sets are defined the operations of union (+), intersection (*) and difference (-), having the usual mathematical meaning. <br><br>  Similarly, the same operations are defined on tuples as on texts, and multiple indexing is allowed for nested tuples;  the expressions A [2] [3] and A [2, 3] are semantically equivalent and define the third element of the tuple, which is the second element of the tuple A. <br><br>  Above the records, except for general operations, only the selection of the element by the field name is defined.  For example, the expression X. Address defines the values ‚Äã‚Äãof the Address field in an entry that is the value of the name X. <br><br>  As with tuples, sampling can be used on both sides of the assignment mark.  For nested records, multiple sampling is defined, for example: X. Address. Apartment. <br><br>  3.11.  Above the procedures and functions, as for the values ‚Äã‚Äãof the names, in addition to the general operations listed in section 5.3.4, the call operation is defined, the syntax of which is described by diagram 5. <br><br>  3.12.  For other types of operation values ‚Äã‚Äãin Rapier are not defined.  Actions on such values ‚Äã‚Äãare carried out using special instructions or procedures. <br><br>  Information on working with files and modules in Rapier is given in section 7. Working with drawings and frames is carried out using the ‚ÄúSword‚Äù graphic system, which is part of the ‚ÄúSchoolgirl‚Äù system.  Tables as a kind of values ‚Äã‚Äãare provided only for the extraversion version of Rapier and will not be considered here.  The semantics of the empty value is the same as in the Robik language. <br><br>  3.13.  In Rapier, as in Robike, the protection of names is provided.  Partial or full protection can be set and removed by the user using the appropriate types of ENABLE and DISABLE prescriptions, the syntax of which is described in diagram 6. Some names, for example, the names of procedures and functions during their execution and the name of the loop variable within the body of this loop, have absolute protection which cannot be charged by means accessible to the user. <br><br>  3.14.  The syntax of an expression in Rapier is described by diagram 7. As follows from the diagram, an expression is a sequence of binary operations of constants, formers, simple names and expressions in brackets connected by signs, each of which can have one or several unary operations, and then an arbitrary sequence operations of sampling, cutting and calling. <br><br>  Thus, the structure of the expression as a whole is traditional for high-level languages. <br><br>  3.15.  The following operational priorities have been adopted in Rapier: <br><br>  1. Expressions in brackets and component expressions in formers; <br><br>  2. Formation of structures; <br><br>  3. Calculation of the actual parameters of functions and index expressions; <br><br>  4. Samples, clippings, function calls; <br><br>  5. Unary operations; <br><br>  6. Exponentiation; <br><br>  7. Operations *, /, // (multiplication, intersection, division, division completely); <br><br>  8. Binary + and - (addition, concatenation, union, set difference). <br><br>  The described procedure is generally consistent with that adopted in mathematics, with the exception that intersection of sets (*) received a higher priority in Rapier than union (+). <br><br>  3.16.  The syntax of a condition in Rapier is described in diagram 8. The term ‚Äúcondition‚Äù corresponds to the term ‚Äúlogical expression‚Äù used in other languages.  In Rapier, logical values ‚Äã‚Äãcannot be assigned to names; therefore, logical expressions are allowed only in certain contexts, for example, in the BYE cycle and in branch instructions. <br><br>  This selection of logical expressions is introduced into the language from methodological considerations in order to emphasize their semantic differences from expressions of other types. <br><br>  Comparison operations and logical connectives used in conditions have traditional semantics. <br><br>  Priorities of operations in the following conditions: <br><br>  1. Conditions in brackets and expressions included in the terms; <br><br>  2. Comparison operations and ownership checks; <br><br>  3. NOT; <br><br>  4. And; <br><br>  5. OR. <br><br>  <b>4. Assignment, input and output</b> <br><br>  4.1.  The syntax of the assignment, input and output prescriptions in the Rapier language is described in diagrams 9-11.  The semantics of these prescriptions hardly differs from the semantics of similar prescriptions in the Robik language.  Therefore, only the main differences between the specified prescriptions in these languages ‚Äã‚Äãare listed here. <br><br>  4.2.  When comparing the syntax of prescriptions, it is necessary to take into account that, despite the external similarity, the structure of expressions in Rapier is much richer than in Robik, therefore prescriptions for assignment and output in Rapier allow performing various operations on data of various kinds, which in Robik can only be done using specialized performers . <br><br>  4.3.  Prescription of the output in Rapier allows you to display not only simple (numbers, texts), but also composite values ‚Äã‚Äã(sets, tuples, records).  The output form is the same as the type of the corresponding formers in the language.  Similarly, in the data entry mode, composite values ‚Äã‚Äãcan be entered. <br><br>  When outputting texts and entering them in TEXT INPUT mode, bordering quotes are not indicated.  Texts entered as part of the structure and entered in the DATA ENTRY mode are surrounded by quotes. <br><br>  If the input mode is not specified, the default is TEXT INPUT. <br><br>  4.4.  The output of any values ‚Äã‚Äãcan be made with an indication of the format: after the output expression, the number of positions taken after the colon is indicated.  For fractional numbers, it is possible to specify a double format: the number of characters in the fractional part of the number is also indicated.  If the value does not fit in the allotted number of positions, then it is displayed in free format. <br><br>  4.5.  In accordance with the concentric structure of the Rapier, input and output switching to other devices can be performed in various ways.  Along with a one-time switch, performed in the same way as in Robik, by specifying the desired mode in the prescription header (for example: PICTURE OUT: A, B;), in Rapier it is possible to switch all output or input information to one or more devices or files .  To do this, apply the appropriate form of regulations ON and OFF. <br>  For example: Turn ON PAPER OUTPUT; <br><br>  <b>5. Control structures Rapier</b> <br><br>  5.1.  The control structures of the Rapier include three types of branching: IF, SELECT-FROM, four types of cycle: BYE, REPEAT, FOR-FROM and FOR-FROM, means for describing and calling functions and procedures, and the EXIT clause for exiting the procedures. <br><br>  This section discusses the requirements of branching and looping, and work with procedures and functions is discussed in the next paragraph. <br><br>  The syntax of the listed constructions is described in diagrams 5, 12-15.  As can be seen in the diagrams, all these prescriptions have a frame structure, which makes it possible to indicate in the loop body and branch alternatives an arbitrary number of prescriptions without using artificial means for their combination. <br><br>  5.2.  The semantics of simple branching (conditional prescription) IF-TO-OTHER is quite traditional. <br><br>  Example: <br><br>  IF A TO <br>  5 -&gt; A;  CONCLUSION: In; <br>  ANYWAY <br>  5 -&gt; B;  CONCLUSION: A; <br>  EVERYTHING; <br><br>  5.3.  As can be seen in Diagram 12, the multi-branch prescription (SEL-FR) consists of an arbitrary number of alternatives, each of which is represented by a condition followed by one or more prescriptions, separated by a semicolon.  The condition is separated from the prescriptions by a colon, alternatives are separated by the | character.  In the end there may be a design ANY. <br><br>  The prescription is executed as follows.  Sequentially, in the order of recording alternatives, the conditions specified in them are checked.  If one of them turned out to be true, the prescriptions from the corresponding colon to the nearest alternative separator (|), the words AKHA or ALL, are executed.  After that, the execution of the prescription ends.  If none of the conditions were true, the prescriptions between AKA and ALL (if the word AKIA is used) are fulfilled.  Thus, in any case, no more than one of the provided alternatives is performed. <br><br>  Example: <br><br>  SELECT FROM <br>  Wind &lt;= 3: CONCLUSION: ‚Äúweak‚Äù | <br>  Wind &lt;= 7: CONCLUSION: "moderate" | <br>  Wind &lt;= 70: CONCLUSION: ‚ÄúAlarm!‚Äù <br>  NECESSARY CONCLUSION: ‚ÄúThe speed is incorrectly set‚Äù <br>  EVERYTHING; <br><br>  5.4.  The second type of prescription SELECT is executed in the same order, but the condition being checked is of the form: b0 = ba, where <br><br>  b0 - the value of the switching expression written between the words SELECT and FROM, <br><br>  ba is an expression written in the alternative (before the colon).  There may be several such expressions (separated by commas). <br><br>  The value of the switching expression is calculated once at the beginning of the execution of the prescription.  Otherwise, the semantics of this prescription corresponds to clause 5.3. <br><br>  Example: <br><br>  SELECTION FROM FROM <br>  5: CONCLUSION: ‚ÄúExcellent‚Äù | <br>  4: CONCLUSION: ‚Äúgood‚Äù | <br>  3: CONCLUSION: ‚Äúmedium‚Äù | <br>  1.2: CONCLUSION: ‚Äúbad‚Äù | <br>  ELSE CONCLUSION: ‚ÄúError‚Äù <br>  EVERYTHING; <br><br>  5.5.  The BYE cycle (diagram 13) has the traditional semantics: first, the condition specified in the cycle header is checked.  If it is true, all the prescriptions from the sign :: (read ‚Äúrepeat‚Äù) to the word ALL (the body of the cycle) are executed.  Then the condition is checked again, etc.  If at the next check the condition turned out to be false, the execution of the instruction ends.  If it was false at the first check, then the loop body is never executed. <br><br>  Example: <br><br>  1 -&gt; X; <br>  UNTIL X &lt;10 :: CONCLUSION: 2 ** X;  X + 1-&gt; X ALL; <br><br>  5.6.  The REPEAT loop allows you to perform a certain set of prescriptions a specified number of times.  It is performed as follows.  First, the value of the expression specified in the loop header is calculated.  It must be a non-negative integer, otherwise an error message is displayed.  Then the loop body is executed the specified number of times. <br><br>  Example: <br><br>  1 -&gt; X; <br>  REPEAT 10 TIMES :: CONCLUSION: 2 ** X;  X + 1-&gt; X ALL; <br><br>  5.7.  The FOR-FR cycle corresponds to the traditional progression-type cycle for most languages.  The name specified after the word FOR is a cycle variable, the expression after the word OT defines the initial value, the expression after the word TO is the final value, after the word STEP the increment step is indicated.  If a step is not specified, it is taken as equal to one.  The values ‚Äã‚Äãof all three expressions must be numbers (integer or fractional).  Cycle semantics is traditional.  The loop variable in the loop body has absolute protection.  After the end of the cycle, it has an empty value. <br><br>  Example: <br><br>  FOR X FROM 1 TO 10 :: CONCLUSION: 2 ** X ALL; <br><br>  5.8.  The FOR-FR loop is designed for processing texts and compound structures, as well as files of the corresponding types.  When executing this prescription, the loop variable alternately takes the values ‚Äã‚Äãof each element of the corresponding structure or file (or each character of the text), after which the loop body is executed.  As in the FOR-FR loop, the loop variable in the body of this loop has absolute protection, and after its completion it gets an empty value.  The expression specified in the cycle header after the word IZ is calculated once before the cycle begins. <br><br>  Example - counting the number of letters "A" in the text with the name Book: <br><br>  0 -&gt; Mid; <br>  FOR A Letter FROM A Book :: IF A Letter = ‚ÄúA‚Äù THAT MF + 1-&gt; MF ALL ALL; <br>  CONCLUSION: "In the text of the Book", MF, "letters &lt;A&gt;"; <br><br>  <b>6. Procedures and functions</b> <br><br>  6.1.  The syntactic structure, as well as the order of description and calling of functions and procedures in Rapier and Robik are very close.  Therefore, in this paragraph, only the differences between the procedural apparatus Rapiers and the analogous apparatus of Robik are listed. <br><br>  6.2.  As in Robik, the procedural block in Rapier is the basic unit for localizing names and storing program text.  In addition to this, it acquires the properties of the main unit of the description area.  As can be seen in diagrams 14-15, when describing formal parameters and local names in Rapier, unlike Robik, one can indicate the type. <br><br>  6.3.  In procedure headers, you can specify the method of passing each of the parameters.  In the Rapier, there are three types of parameters that differ in the mode of transmission: input, output and return.  These methods are denoted by the symbols =&gt;, &lt;= and &lt;=&gt;, respectively.  If the formal parameter is described as input, then the corresponding actual parameter can be any expression.  The actual parameters, corresponding to the two other types of formal, can only be names. <br><br>  Input parameters are passed by value: at the moment of calling the procedure, the value of the actual parameter is calculated and assigned to the corresponding formal, which is then completely protected.  For functions in Rapier, as well as for all types of procedural blocks in Robik, this method is the only one possible. <br><br>  Output parameters are processed as follows.         .          . <br><br>       :       ,      ‚Äî . <br><br>  6.4.               (     )      . <br><br>          ,       ,      .                 ,    . <br><br>  6.5.            .             . ,  <br><br> &lt;A, B, C&gt;[X](2, 3); <br><br>       A, B  C,      X,       1  3.          . <br><br>  6.6.   ,    ,      .                . <br><br> <b>7.   </b> <br><br>  7.1.   ¬´¬ª    ,      ,        . <br><br>    ,  ‚Äî   ,            .   ,   ,        .  ,     ,      ¬´¬ª  :          ¬´¬ª,      . <br><br>  7.2.       ,        ,       . <br><br> 1.   ,  ,                      ( 10-11). <br><br> 2.                         ( 6).                  ( 10-11). <br><br> 3.    ,     ,       -  ( 13).              . <br><br> 4.       (  ,   ,     ..)       -. <br><br> 5.             ¬´¬ª, ,  ,        .           . <br><br> 6.         ,     . <br><br>  7.3.   ¬´¬ª   .  ‚Äî     ,    ‚Äî    ,      . <br><br>     ,     .           ,  ,          . <br><br> <b>8.     </b> <br><br> 8.1.           ,    .          ,          .       . <br><br>  8.2.              ().               ( 6). <br><br>  8.3.         ,       .       ,     15.        ,    . <br><br>  8.4.           ‚Äî ,       .        ,   ‚Äî    .          ,    . <br><br> 8.5.        .           ,     .    ,            . <br><br> 8.6.           ,    ,  : <br><br> 1.   ; <br><br> 2.    (  ); <br><br> 3.    . <br><br> 8.7.  ,    8.2-8.4,          ,       </div></div><br><br><h3>   </h3><br><img src="https://habrastorage.org/files/e47/9ea/1b3/e479ea1b38ac4384b34dcea5773509ca.jpeg"><br><br>    . ,     .        -.  . . .  ‚Äî -        . <br><br>           ,       .           ,     , ,   Java. <br><br><img src="https://habrastorage.org/files/cff/36f/e52/cff36fe52db24885a56db87ba0d2ce76.png"><br><br>         ‚Äì ,      . <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text">        ,    ,          . <br><br> <b> ‚Äì  ,      .</b>  ,            .    ¬´¬ª   Windows,     ,       (   ,    ),     ,     (  ). <br><br> <b> ‚Äì ,     .</b>         ,   - ,    ,       .  ¬´¬ª ,    ,     ¬´¬ª . <br><br> <b> ‚Äì     ,        .</b>         ,     ,      .      80- ,     ,  77  . <br><br><img src="https://habrastorage.org/files/494/94e/91d/49494e91d2bc4edc812227cfa17780e1.png"><br><br> <b>,  , ,         .</b>    ,     ,           . , ,  BAE,      ,       ;    ,           .             . <br><br>    ,  ,       ,    ,       . <br><br> <b> - </b> ;  ,    ,   .        80- ,     ,     ¬´  -,  ¬ª.     ,      ,   /++,   (   )   ,       ,  ,  -  ,  ,   .   ,    GNAT      40 ,  90%   ,       (       )       . <br><br> <b>    .</b>  ,     ,        GNAT,              -      </div></div><br>          .        ¬´¬ª.      ,    ¬´¬ª. <br>       ( ): <br><ul><li> Ada </li><li> Algol-60 </li><li> Algol-68 </li><li>  C </li><li> CLU </li><li>  Fororth </li><li> Fortran (   2 ) </li><li>  Lisp </li><li> Modula-2 </li><li>  Pascal </li><li> PL/I </li><li> SETL </li><li> Simula-67 </li><li> Snobol-4 </li></ul></div><p>Source: <a href="https://habr.com/ru/post/273665/">https://habr.com/ru/post/273665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273651/index.html">IT risks in the process of buying shares</a></li>
<li><a href="../273653/index.html">Top 10 most important announcements of Microsoft in 2015</a></li>
<li><a href="../273657/index.html">152-FZ. Data Centers, Databases and Notifications</a></li>
<li><a href="../273659/index.html">The book "Path programmer"</a></li>
<li><a href="../273663/index.html">Background segmentation in the Intel RealSense SDK</a></li>
<li><a href="../273667/index.html">A bit about trends in the field of supercomputers</a></li>
<li><a href="../273669/index.html">An attempt to measure talent failed ...</a></li>
<li><a href="../273671/index.html">Seven things useful to know about programmers</a></li>
<li><a href="../273673/index.html">Relocation of IT-person to Germany: from A to Z</a></li>
<li><a href="../273677/index.html">Layout letters: 60 useful resources, guides and research</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>