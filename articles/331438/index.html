<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Artificial Intelligence Half-Life SDK: Retrospective</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the time of release in 1998, Half-life received a warm welcome for its game design, which was made possible by artificial intelligence. This AI inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Artificial Intelligence Half-Life SDK: Retrospective</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/380/acd/2b2/380acd2b214643c3ffd737580386a570.jpg" alt="image"><br><br>  At the time of release in 1998, Half-life received a warm welcome for its game design, which was made possible by artificial intelligence.  This AI influence has led to that.  that HL was called one of the <a href="http://aigamedev.com/open/review/top-ai-games/">most important games in history</a> . <br><br>  And even twenty years later, after studying its code, you can learn a lot about creating <u>simple but effective</u> AI systems.  All AI logic is hard-coded in C ++ and not too object-oriented, so it is much easier to understand in it than in more recent engines (although it is not so easy to expand it). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article we will look at the open SDK for Half-Life 1, analyze the various aspects of AI, such as the task scheduler system, its implementation, similar to finite automata, and the sensor system.  After reading the article, you will more deeply understand the principle of using these concepts and their implementation in games. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/b76/de4/d45/b76de4d45b81a7a25addcfdbe88db6bd.jpg" alt="Cooperative AI and Monsters"><br>  <em>Screenshot 1: Guard Barney fights with one of the monsters</em> <br><br><h3>  Download Half-Life SDK </h3><br>  Installing the Valve SDK for Half-Life is very simple (unlike the <a href="http://aigamedev.com/open/article/fear-sdk/">FEAR tools</a> ) and if you want to develop mods, then it only requires the original game.  Here's what you need: <br><br><ol><li>  <b>Download</b> version 2.3 of the Half-Life SDK, or <a href="http://metamod.sourceforge.net/files/sdk/">just source files</a> without resources, or a copy of the <a href="">full SDK</a> with models. </li><li>  <b>Unzip the</b> file to any directory, preferably to the game folder, if you want to develop using the SDK mods.  It takes a few seconds, as a result you will have a pack of directories with models and source code. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/65c/586/9f7/65c5869f7a632788b84d5d90ec81860f.png" alt="Half-Life SDK AI Files"><br>  <i>Screenshot 2: C ++ game code in Half-Life SDK version 2.3.</i> <br><br><h3>  We deal with the code </h3><br>  The codebase is not as well structured as in FEAR or even <a href="http://aigamedev.com/open/article/quake3-engine/">Quake 3</a> .  There are several subdirectories in it, but the files have not very clear names, and the implementation of C ++ classes is scattered across several files, from the names of which almost nothing can be understood. <br><br><ul><li> The full SDK has two folders that contain code: <code>Single-Player Source</code> and <code>Multiplayer Source</code> .  Both have a similar directory structure. </li><li>  Most of the game logic is in the <code>/dll/</code> subdirectory, which contains all the files needed to build hl.dll, which is also a framework for mods.  In addition, this directory contains AI code scattered across multiple files, with names like <code>*monster*.[h,cpp]</code> , <code>*ai*.[h,cpp]</code> and other files </li><li>  There are other directories in the source code directory, such as the <code>engine</code> , which contains header files that interact with the main executable file (as basic entities).  The <code>common</code> directory also contains similar low-level files used by the engine and game code. </li></ul><br>  If you study or modify AI, then you will spend most of your time on the <code>/dll/</code> directory, because it contains the behavior of various actors in the game. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/846/cb7/094/846cb70942175dd6d6ee3f8940d87823.jpg" alt="Scientist AI"><br>  <i>Screenshot 3: cutscene from the game with the scientist.</i> <br><br><h3>  Scheduler and goal system </h3><br>  The <code>schedule.[h,cpp]</code> files contain a very simple goal-driven system.  It consists of several levels of tasks that can be procedurally combined. <br><br><h4>  Tasks </h4><br>  Tasks are short atomized behaviors that have a specific purpose.  For example, most of the Half-Life actors support the following tasks: <code>TASK_WALK_PATH</code> , <code>TASK_CROUCH</code> , <code>TASK_STAND</code> , <code>TASK_GUARD</code> , <code>TASK_STEP_FORWARD</code> , <code>TASK_DODGE_RIGHT</code> , <code>TASK_FIND_COVER_FROM_ENEMY</code> , <code>TASK_EAT</code> , <code>TASK_STOP_MOVING</code> , <code>TASK_TURN_LEFT</code> , <code>TASK_REMEMBER</code>  They are defined as enumerations in the header file and are implemented as C ++ methods. <br><br><h4>  Conditions </h4><br>  Conditions are used to express the situation of an actor in the world.  As is the case for the <br><br><h4>  Plans </h4><br>  The plan consists of a series of tasks (with arbitrary parameters) and takes into account the bit field of conditions to determine when the plan is not applicable.  For easy debugging, the plan objects have names. <br><br><h4>  Goals </h4><br>  The goals are at a higher level and consist of plans.  The goal logic can, if necessary, select a plan based on the failed task and the current context.  Examples of goals from Half-Life: <code>GOAL_ATTACK_ENEMY</code> , <code>GOAL_MOVE</code> , <code>GOAL_TAKE_COVER</code> , <code>GOAL_MOVE_TARGET</code> and <code>GOAL_EAT</code> . <br><br>  The code used by Valve is extracted from the Quake engine, and is still fairly obvious, despite being converted to C ++;  files and struct have similar names. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/fd9/8ae/d20fd98ae1945257dda3b38dbe94f7ad.jpg"><br>  <i>Screenshot 4: paratroopers raised the alarm at the research center.</i> <br><br><h3>  State machine </h3><br>  In practice, all these plans and tasks are connected together in a structure similar to a finite state machine.  At the top level, the function in <code>monsterstate.cpp</code> is called to update the AI: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBaseMonster :: RunAI ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> );</code> </pre> <br>  It, in turn, calls the overloaded functions responsible for checking with <code>MaintainSchedule()</code> applicability of the current plan and selecting new ones with <code>GetSchedule()</code> .  They can be modified according to needs using the generated classes, see, for example, <code>barney.cpp</code> or <code>scientist.cpp</code> . <br><br>  At the lower level, the <code>StartTask()</code> and <code>RunTask()</code> functions implement logic for each of the task identifiers defined in the <code>enum</code> construct.  They are implemented in classes that are also inherited from <code>CBaseMonster</code> .  As a result, it largely looks like a finite state machine, implemented as a <code>switch</code> construction. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CScientist :: RunTask( Task_t *pTask ) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( pTask-&gt;iTask ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TASK_RUN_PATH_SCARED: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( MovementIsComplete() ) TaskComplete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( RANDOM_LONG(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">31</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">8</span></span> ) Scream(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TASK_MOVE_TO_TARGET_RANGE_SCARED: <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TASK_HEAL: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_fSequenceFinished ) { TaskComplete(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( TargetDistance() &gt; <span class="hljs-number"><span class="hljs-number">90</span></span> ) TaskComplete(); pev-&gt;ideal_yaw = UTIL_VecToYaw( <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ); ChangeYaw( pev-&gt;yaw_speed ); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CTalkMonster::RunTask( pTask ); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  A more typical approach would be to implement each of these <code>case</code> blocks in their own class, but with the existing implementation it is much easier to use the logic of one object in another, albeit at the cost of modularity. <br><br>  It is also interesting to note that AI stores two states: one ideal and one current.  Thus, it is easier for the game code to create goals for actors, and force them to find the best ways to achieve them.  This is an interesting combination of a finite state machine and a focused system. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d36/310/12b/d3631012b6943ea7500f6c55b0404913.jpg"><br>  <i>Screenshot 5: game cutscene with the scientist.</i> <br><br><h3>  Implementation of the sensory system </h3><br>  In the base <code>monster.[h,cpp]</code> there is a code that gives all the actors sight, smell, and hearing. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBaseMonster :: Look ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iDistance );</code> </pre> <br>  The view function checks various flags, such as <code>SF_MONSTER_PRISONER</code> and <code>SF_MONSTER_WAIT_TILL_SEEN</code> , to ensure that designers can control if necessary.  The equation also takes into account parameters such as scope and angle of view. <br><br><pre> <code class="cpp hljs">CSound* CBaseMonster :: PBestSound ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> );</code> </pre> <br>  The hearing and smell code works in a similar way, only using sound events.  A list of objects that require the attention of monsters is stored, and the sensor system selects the best one for focusing. <br><br><h3>  Results and additional reading </h3><br>  In general, the source code behind this system, although simple, is very informative.  If you want to choose an easy implementation of decision making by artificial intelligence, then you should choose this approach.  However, it may be worthwhile to implement each task in its own facility: these days they usually use this solution in commercial games. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/c04/aa8/284c04aa81b41e45f35def76a4212f84.jpg"><br>  <i>Screenshot 6: Spontaneous behavior of units in Half-Life.</i> <br><br>  The AI ‚Äã‚ÄãHalf-Life code contains other interesting ideas. <br><br><ol><li>  The game code represents the navigation points in the form of a 3D vector only and a location type!  They are tied to the downstream navigation system, but they can also be used in the old-school system of bread crumbs, followed by monsters. </li><li>  Half-Life has surprised many with the behavior of units.  However, there is no top-level AI in the game that controls these units, that is, all behavior manifests itself spontaneously. </li></ol><br>  If you want to recreate something more than just the <i>monster</i> from Half-Life, it is best to explore the bots framework.  It will allow you to create AI bots for multiplayer games that can be used in third-party half-life modes.  They can be found here: <br><br><ul><li>  <a href="http://hpb-bot.bots-united.com/hpb_bot.html">HPB Bot and HL Bot Framework</a> </li><li>  <a href="http://botman.planethalflife.gamespy.com/MOD_FAQ.shtml">Unofficial Mods FAQ for Half-Life [archive from Wayback Machine]</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/331438/">https://habr.com/ru/post/331438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331428/index.html">The final of the SAP contest Koder 2017 will be held live</a></li>
<li><a href="../331430/index.html">"Gonochki" on SVG</a></li>
<li><a href="../331432/index.html">SIP: this growth does not stop</a></li>
<li><a href="../331434/index.html">We put Selenium Grid on Apache Mesos wheels</a></li>
<li><a href="../331436/index.html">Monitoring System Delays with JHiccup</a></li>
<li><a href="../331440/index.html">Medici effect or is it possible to cross a peach and melon or Windows and iOs</a></li>
<li><a href="../331442/index.html">Consider Kotlin more closely</a></li>
<li><a href="../331444/index.html">Dynamic Apache NiFi cluster creation</a></li>
<li><a href="../331446/index.html">Abnormal GraphQL in Electron or as I wrote a desktop client for Tinder</a></li>
<li><a href="../331448/index.html">‚ÄúI can't just walk with the flag‚Äú Postgres - our everything ‚Äù. We need to prove with our hands that this works ‚Äù- Alexey Lustin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>