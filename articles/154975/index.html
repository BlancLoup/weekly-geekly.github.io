<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Filtering false matches between images using a dynamic match graph</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many modern computer vision algorithms are built on the basis of detecting and comparing the special points of visual images. On this topic, many arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Filtering false matches between images using a dynamic match graph</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/d2e/fa5/133/d2efa51335b641984233db766f4d7641.png"><br>  Many modern computer vision algorithms are built on the basis of detecting and comparing the special points of visual images.  On this topic, many articles were written on Habr√© (for example, <a href="http://habrahabr.ru/post/103107/">SURF</a> , <a href="http://habrahabr.ru/post/106302/">SIFT</a> ).  But in the majority of works, due attention is not paid to such an important stage as filtering of false correspondences between images.  Most often for these purposes apply <a href="http://ru.wikipedia.org/wiki/RANSAC">RANSAC-method</a> and stop at this.  But this is not the only approach to solve this problem. <br>  This article focuses on one of the alternative ways to filter false matches. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  Suppose we have two sets of singular points obtained from two images P and Q with n <sub>p</sub> and n <sub>q</sub> points, respectively. Each singular point is a pair p = {p <sub>d</sub> , p <sub>c</sub> }.  p <sub>d</sub> - is a local feature of a point (for example, a SURF descriptor), and p <sub>c</sub> = {x, y} are the coordinates of a singular point. <br>  We have a set of correspondences M = {c <sub>i</sub> = (i, i ') |  c <sub>i</sub> ‚àà C, i ‚àà P, i '‚àà Q}, constructed with the help of a certain metric (for example, as points with descriptors closest in the Euclidean metric).  For each correspondence, we construct a nonnegative evaluation function S <sub>c <sub>i</sub></sub> = f <sub>1</sub> (i <sub>d</sub> , i ' <sub>d</sub> ). <br><br>  For two matches c <sub>i</sub> = (i, i ') and c <sub>j</sub> = (j, j'), suppose that the distance between points i and j in the first image and points i 'and j' in the second image l <sub>ij</sub> and l <sub>i ' j '</sub> respectively.  Obviously, if these two matches are true, then we can align the image Q with respect to P with the scale factor l <sub>ij</sub> frasl;  l <sub>i'j '</sub> , and we say that this pair of matches votes for the scale l <sub>ij</sub> frasl;  l <sub>i'j '</sub> .  Now suppose that there is a visual image with n correct correspondences corresponding to it, then for each pair of these correspondences the scale factor should be approximately the same.  Such a scale will be called the scale coefficient of geometric consistency and denoted by s.  The scale factor of the geometric consistency of a pair of matches c <sub>i</sub> = (i, i ') and c <sub>j</sub> = (j, j') is expressed as: <br>  S <sub>c <sub>i</sub> c <sub>j</sub></sub> (s) = f <sub>2</sub> (| l <sub>ij</sub> - s * l <sub>i'j '</sub> |), where f <sub>2</sub> (x) is a non-negative monotonically decreasing function. <br><br>  Let the set M contain m correspondences M = {c <sub>1</sub> , ..., c <sub>m</sub> }.  Construct a graph G with m vertices, each vertex of which represents a correspondence from M. The edge weight between vertices i and j is defined as follows: <br>  w <sub>ij</sub> (s) = S <sub>c <sub>i</sub></sub> * S <sub>c <sub>j</sub></sub> * S <sub>c <sub>i</sub> c <sub>j</sub></sub> (s). <br>  A graph constructed in this way will be called a Dynamic Conformity Graph (hereinafter referred to as GHS). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The weighted adjacency matrix for DGS is denoted by A (s) and constructed as follows: <br><img src="https://habrastorage.org/storage2/8e3/874/5a9/8e38745a9752e165c797601d3911313f.gif"><br>  A (s) ‚àà R <sup>m * m</sup> is symmetric and non-negative. <br><br>  The correct visual image containing n singular points corresponds to a complete subgraph T ‚àà G with n vertices, which, as is easily seen, is a weighted duplicate of the maximum clique.  Such a subgraph has a high average intracluster estimate: <br><img src="https://habrastorage.org/storage2/b15/54e/8f4/b1554e8f4800ad910a37b84125c9451e.gif"><br>  If we represent T in the form of an indicator-vector y such that <img src="https://habrastorage.org/storage2/39b/103/1a4/39b1031a45ce67b9ee349aa5801147ab.gif">  , then the average intra cluster estimate can be rewritten in quadratic form: <br><img src="https://habrastorage.org/storage2/5a8/bb8/3c0/5a8bb83c06b1e30cd36b4d362935463d.gif">  where <img src="https://habrastorage.org/storage2/ac4/02b/726/ac402b726b021e4e97ada917dde284c6.gif">  , <img src="https://habrastorage.org/storage2/d04/389/f6a/d04389f6a54b9fccf1cdb8b753fa856b.gif">  . <br><br>  As is known, the Motzkin-Strauss theorem establishes a connection between the maximum clique and the local maximum of such a quadratic form: <br><img src="https://habrastorage.org/storage2/d49/98f/fe4/d4998ffe4f55b6d8153f449b3445aa13.gif">  where <img src="https://habrastorage.org/storage2/057/479/f59/057479f59205045a2ea84a4320c4bbce.gif">  - standard simplex in R <sup>m</sup> .  Simply put, the theorem says that a subset T of vertices of a graph G is a maximal clique if and only if its characteristic vector x <sup>T</sup> is a local maximum of the quadratic function f (x) in the standard simplex, where x <sub>i</sub> <sup>T</sup> = 1‚ÅÑ | T |  if i ‚àà T, x <sub>i</sub> <sup>T</sup> = 0 otherwise. <br><br>  Although the original Motzkin-Strauss theorem applies only to non-weighted graphs, Pavan and Pelillo generalized it to weighted graphs and established a connection between dense subgraphs and local maxima of the equations. <br><br>  The accepted norm l <sub>1</sub> has a number of advantages.  First, it has a simple probabilistic meaning: x <sub>i</sub> represents the probability that a complete subgraph contains a vertex i.  Secondly, the solution x is sparse, and only some components in the same subgraph are of great importance, the other components have sufficiently small values, which allows us to select a cluster by discarding those vertices that are noise, which is noise. <br><br>  Thus, the task of filtering correspondences is reduced to the problem of finding clusters of correspondences representing separate visual images.  In turn, to find such clusters, it is necessary to solve the optimization problem described above. <br><br><h4>  Algorithm Description </h4><br>  For scale s <sub>0</sub> , the optimization problem <img src="https://habrastorage.org/storage2/2ff/97c/3a1/2ff97c3a1ecfc9877fb4844bfdae0f9b.gif">  may have many local maxima.  Each large local maximum most often corresponds to the correct visual image, and a small local maximum most often occurs as a result of noise. <br><br>  When initializing x (1), the corresponding local solution x can be effectively obtained using the first-order self-assembly equation, which has the form: <br><img src="https://habrastorage.org/storage2/7bd/705/f49/7bd705f493787c5db84f3a6a689d406f.gif"><br><br>  It can be noted that the simplex Œî is invariant with respect to such dynamics, which means that any trajectory starting from Œî will remain in Œî.  In addition, it was proved that when A (s <sub>0</sub> ) is symmetric and with nonnegative elements, the objective function <img src="https://habrastorage.org/storage2/2ff/97c/3a1/2ff97c3a1ecfc9877fb4844bfdae0f9b.gif">  strictly increases along any non-constant trajectory of the self-assembly equation, and these asymptotically stable points are in strict one-to-one correspondence with local solutions of a quadratic function. <br><br>  Roughly speaking, in order to find all the large local maxima of x, many initial initializations are taken and thus ensure that all the large local maxima of a given simplex will be taken into account.  As mentioned above, for our task, each local maximum corresponds to a visual image, then it must have two properties: <br><ol><li>  <b>Locality property.</b>  The singular points of one visual image lie in a certain small neighborhood, therefore we need to initialize x (1) only in the neighborhood of each vertex of the GVD. </li><li>  <b>Non-intersection property.</b>  Different visual images, as a rule, do not contain common vertices in G, which means that if two local maxima x and y correspond to two different visual images, then (x, y) ~ 0. </li></ol><br><br>  Since we initialized x (1) for each vertex of the DGS and initialization of the vertices of the same visual image converge to approximately the same local maximum, we must merge the local maxima corresponding to the same visual images.  Due to this data redundancy, additional noise resistance is achieved.  All small local maxima corresponding to noise are also discarded. <br><br>  At the end, it is necessary to restore the visual image for each local maximum x.  Since  x <sub>i</sub> is the probability of occurrence of the vertex i in the visual image x, we can choose only those vertices whose entry into the visual image is most likely. <br><br><h4>  Algorithm parameters </h4><br>  As can be seen from the above description, the algorithm has a large number of adjustable parameters such as: <br><ul><li>  S <sub>c <sub>i</sub></sub> = f <sub>1</sub> (i <sub>d</sub> , i ' <sub>d</sub> ) is a function of conformity assessment </li><li>  S <sub>c <sub>i</sub> c <sub>j</sub></sub> (s) = f <sub>2</sub> (| l <sub>ij</sub> - s * l <sub>i'j '</sub> |) is a function for evaluating the geometric consistency of correspondences </li><li>  Œï is the threshold value for estimating the weight of the edge, for belonging to the initialization vicinity </li><li>  Œ¶ - the radius of the neighborhood for which the initialization x (1) is taken </li><li>  Œ® - threshold value for estimating the smallness of the local maximum </li><li>  Œ© - threshold value for merging neighborhoods </li><li>  Œò - threshold value of the probability of occurrence of the vertex in the visual image </li></ul><br><br><h4>  Experiments </h4><br>  Typical results of the algorithm are presented below. <br><img src="https://habrastorage.org/storage2/e6f/121/39a/e6f12139ad9440c69e3c77b31e0985d1.png"><br><img src="https://habrastorage.org/storage2/19b/56e/e79/19b56ee798ffdf0e893db487b6b25194.gif"><br><br><h4>  Conclusion </h4><br>  The application of the described algorithm in practice is difficult because of the high sensitivity to the parameters of the algorithm, which are chosen empirically for each set of input data.  Also, for the effective application of this method, a preliminary analysis of the input set of correspondences for the selection of the dominant scale factors is necessary. <br>  Due to the fact that the fight against noise occurs due to data redundancy, the algorithm requires a large amount of additional memory and time to process it. <br>  Therefore, this algorithm is interesting from the point of view of the approaches used in it to the analysis of correspondences, and not as an alternative, for example, to the RANSAC method mentioned at the beginning of the article. <br><br><h4>  Literature </h4><br><ul><li> Spanally Correspondences of Hairong Liu, Shuicheng Yan, National University of Singapore, Singapore </li><li>  T. Motzkin and E. Straus.  Maxima for the Theorem of Turan.  Canad.  J. Math, 1965. </li><li>  10. M. Pelillo, K. Siddiqi, and S. Zucker.  Matching hierarchical structures using association graphs.  TPAMI, 1999. </li></ul><br><br>  <b>UPD</b> Link to method sources: <a href="">dl.dropbox.com/u/15642384/src.7z</a> </div><p>Source: <a href="https://habr.com/ru/post/154975/">https://habr.com/ru/post/154975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154959/index.html">As I decided to quietly teach a python, but I got into the wilds of CS188.1x Artificial Intelligence</a></li>
<li><a href="../154963/index.html">Does LK write its operating system?</a></li>
<li><a href="../154969/index.html">Another bitcoin death. Now asic</a></li>
<li><a href="../154971/index.html">7 reasons why cloud technology needs Europe</a></li>
<li><a href="../154973/index.html">Steve Ballmer will show the Russian application on Windows 8</a></li>
<li><a href="../154977/index.html">Festival 404: published the first video reports</a></li>
<li><a href="../154981/index.html">Okie Dokie - the first Android client for YouTrack</a></li>
<li><a href="../154983/index.html">Ode to hard keyboard</a></li>
<li><a href="../154985/index.html">Harry potter and rational thinking methods</a></li>
<li><a href="../154987/index.html">Extreme Summit 440, Summit x670 and Summit x460 review presentations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>