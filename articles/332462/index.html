<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What if throwing all the excess out of the database into a distributed cache is our experience using Hazelcast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since Yandex.Money databases are forced to store a lot of secondary and temporary information, once such a solution has ceased to be optimal. Therefor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What if throwing all the excess out of the database into a distributed cache is our experience using Hazelcast</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/a25/4c8/cc3/a254c8cc304241dea0e74ebd2fd3be8c.png"></p><br><p>  Since Yandex.Money databases are forced to store a lot of secondary and temporary information, once such a solution has ceased to be optimal.  Therefore, a distributed Data Grid with Hazelcast-based in-memory database functions appeared in the infrastructure. </p><br><p>  In exchange for consistently high performance and fault tolerance, we got a curious implementation experience that doesn‚Äôt repeat the documentation.  Under the cut, you will find a story about solving Hazelcast problems when working under high loads, dealing with <strong>Split Brain</strong> , as well as impressions from working with a distributed data warehouse in a large infrastructure. <a name="habracut"></a></p><br><h1 id="zachem-ponadobilas-in-memory-baza">  Why did you need an in-memory database </h1><br><p>  In Yandex.Money, Hazelcast is used as an in-memory database and, secondarily, as a distributed cache for the Java infrastructure.  When making each payment, you need to hold a lot of information somewhere, which is no longer needed after the transaction, and it should be easily accessible.  We call such data the context of the user's session and relate to them the source and method of transferring money, the sign of transfer from the card, the way of confirming the transfer, etc. </p><br><p>  In addition to a longer response, it was inconvenient to maintain the script and store excess data in backups.  Many different payment contexts, other temporary data, the need to support automatic cleaning, the increasing load on the database - all this prompted us to reconsider the approach to storing temporary data. </p><br><p>  It was necessary to have separate scalable storage with high access speed.  The impetus for the change and the search for a more elegant and fast storage of temporary data was the earlier <a href="https://habrahabr.ru/company/yamoney/blog/326998/">partial replacement with PostgreSQL</a> . </p><br><p>  Among the key requirements for the solution sought were: </p><br><ul><li><p>  <strong>Fault tolerance</strong> at the level of a single data center (DC), and between the two available. </p><br></li><li><p>  <strong>The minimum memory overhead for data storage (memory overhead)</strong> .  First of all, the solution will be used as a data storage, therefore it is important to take into account the memory consumption by the storage itself.  In our case, we managed to distribute some local application caches according to the cluster memory, which gave us a dozen times gain. </p><br></li><li>  <strong>The cost of scaling</strong> .  Since the payment service is constantly building up muscles (not always linearly), the new database should be able to do this as cheaply as possible in production and in test or local environments. </li></ul><br><div class="spoiler">  <b class="spoiler_title">I will not bore the reader by listing the competitors and our iterations of choice - this information is under the spoiler, if you're curious.</b> <div class="spoiler_text"><p>  If you break down the three criteria described above in more detail, this is what the software you were looking for should be: </p><br><ul><li><p>  High read / write speed compared to a regular database and a small memory overhead for data storage. </p><br></li><li><p>  Fault tolerance when errors occur on individual nodes. </p><br></li><li><p>  Replication both inside data centers and between them. </p><br></li><li><p>  High uptime in work and the possibility of configuration on the fly. </p><br></li><li><p>  The ability to set a fixed lifetime of objects - TTL. </p><br></li><li><p>  Distributed storage (sharding) and load balancing on cluster nodes by the client. </p><br></li><li><p>  Support for cluster status monitoring and the ability to test on a local computer. </p><br></li><li><p>  Easy setup and maintenance of infrastructure, flexibility. </p><br></li><li>  Automatic cluster expansion, the ability to limit the amount of cache of a particular type of object. </li></ul><br><p>  In addition to all this, it would be great to get in the appendage a distributed locking mechanism, integration with applications, client-side cache, Memcache protocol support, as well as clients for JVM, Java, REST, Node.js. </p><br><p>  Most of these requirements are satisfied by the following products: </p><br><ol><li><p>  <strong>Redis</strong> - does not allow max-idle-seconds for cache entries, perform complex replication and limit the amount of memory for a specific type of object. </p><br></li><li><p>  <strong>Ehcache big memory</strong> - has good characteristics, but provides only a paid license. </p><br></li><li><p>  <strong>Gridgain</strong> is also good, but replication between the DC and inside the DC is only in the paid version. </p><br></li><li><p>  <strong>Infinispan</strong> - everything seems to be good, but rather complicated to set up and does not contain commercial support.  What is even sadder is that there is no information on the behavior in production in the network, and this increases our risks. </p><br></li><li>  <strong>Hazelcast</strong> meets all requirements and is actively used in production.  Moreover, it is on this system that migrate with Redis.  Of the minuses, only paid management studio for monitoring, which balances the API for implementing its monitoring system. </li></ol><br></div></div><br><p>  Now I‚Äôll tell you more about how everyone set up and what conclusions they made, because the difficulties with Hazelcast were connected just with the ‚Äúrake‚Äù of the configuration. </p><br><h1 id="klaster-o-25-nodah">  Cluster about 25 nodes </h1><br><p>  Since local and geo-redundancy is necessary for the Yandex.Money infrastructure, we have included nodes in two data centers in the Hazelcast cluster, as shown in the figure below. </p><br><p><img src="https://habrastorage.org/web/553/653/a28/553653a28f404bfe8c58d654828e00e4.png"><br>  <em>The diagram shows a Hazelcast cluster distributed between two remote DCs.</em> </p><br><p>  In total, it consists of 25 nodes divided into two groups.  Hazelcast stores data in a cluster in partitions, distributing these partitions between nodes.  Grouping partitions allows Hazelcast to back up partitions between groups.  We have combined each cluster of cluster nodes into clusters and obtained a simple and transparent data backup between the DC. </p><br><p>  Configuration example: </p><br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hazelcast</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.hazelcast.com/schema/config hazelcast-config-3.5.xsd"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.hazelcast.com/schema/config"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--      --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">network</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">port</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">auto-increment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">&gt;</span></span>5701<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">port</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">join</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">multicast</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--        --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tcp-ip</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  1 --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member</span></span></span><span class="hljs-tag">&gt;</span></span>192.168.0.0-255<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  2 --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member</span></span></span><span class="hljs-tag">&gt;</span></span>192.168.1.0-255<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tcp-ip</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">join</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">network</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--       --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">partition-group</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">group-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"CUSTOM"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   1     --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface</span></span></span><span class="hljs-tag">&gt;</span></span>192.168.0.*<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   2     --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface</span></span></span><span class="hljs-tag">&gt;</span></span>192.168.1.*<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">partition-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcast.logging.type"</span></span></span><span class="hljs-tag">&gt;</span></span>slf4j<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--      --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcast.health.monitoring.level"</span></span></span><span class="hljs-tag">&gt;</span></span>NOISY<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--     JMX --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcast.jmx"</span></span></span><span class="hljs-tag">&gt;</span></span>true<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--    SEGTERM   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcast.shutdownhook.enabled"</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">hazelcast</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  The network block is responsible for setting the addresses of the servers that will form the cluster (in our infrastructure, these are separate ranges for two data centers).  Partition-group contains settings for partition groups between which data is backed up.  Here is also a binding to two DCs for duplicating data in both. </p><br><h1 id="chto-esli-peregruzit-hazelcast-v-80-raz">  What if you overload Hazelcast 80 times </h1><br><p>  After setting up the system and some monitoring it, I can note the high read-write speed, which does not change even with increased loads (data is stored in memory).  But, like any other distributed system, Hazelcast is sensitive to bandwidth and network response.  Hazelcast is a Java application, which means it requires fine tuning of the garbage collector (Garbage Collector), according to the load profile. </p><br><p>  For fine tuning, you usually refer to the documentation, but there‚Äôs a clear lack of it.  Therefore, we are actively studying the source code and so brought to mind the configuration.  In general, the solution turned out to be reliable and coping with its tasks - this was confirmed by the load tests, the 80-fold load of which was not reflected in the Hazelcast metrics. </p><br><p><img src="https://habrastorage.org/web/4d6/0e7/106/4d60e7106d4946e080d04a7a4fb15567.png"><br>  <em>The graph shows the average execution time of insert operations and receiving data in Hazelcast for one of the clients.</em>  <em>The average insertion time was 2.1 ms, and the read time was 1.6 ms.</em>  <em>These numbers reflect the overall system performance: sending a request, running it in a cluster, networking, and deserializing the response.</em> </p><br><p>  But with a general positive background, there are several areas to which particular attention should be paid.  For example, we encountered the following problems when using Hazelcast: </p><br><ul><li><p>  The collapse of the cluster and Split Brain, fraught with downtime and violation of SLA. </p><br></li><li><p>  False triggered data policies that lead to data loss. </p><br></li><li><p>  Loading data without taking into account the settings of IMap leads to clogging of the storage. </p><br></li><li>  For a long time, commands are executed when the cluster structure is changed.  With a regular restart, the insertion and retrieval commands inhibit the cluster node. </li></ul><br><p>  And if there is little documentation for the product, I‚Äôll focus on solutions in more detail. </p><br><h2 id="razval-klastera-i-split-brain">  Cluster collapse and Split Brain </h2><br><p>  Errors in the network occur constantly, and Hazelcast processes them to eliminate data loss and inconsistency.  In our case, each Hazelcast node is launched as part of an application that performs the necessary settings and monitors.  This allows Hazelcast to be integrated into the infrastructure, provides more flexibility and provides uniform methods of supplying, monitoring, logging and managing the Yandex.Money infrastructure. </p><br><p>  The application runs Spring Boot, which implements its classLoader.  In the meantime, the self-written classLoader Spring Boot has one very bad bug.  In the event of an abnormal situation, the cluster sends an exception identifier to its nodes to handle the situation.  Nodes receive error messages and try to deserialize exception classes.  The Spring Boot class loader does not have time to load classes at high load and generates a <a href="https://github.com/spring-projects/spring-boot/commit/1d099035b1f732efdc36221d071402fa5f05fe43">NoClassDefFoundError</a> error. </p><br><p>  Ultimately, the cluster may fall apart, transforming into several smaller independent ‚Äúclusters‚Äù.  We have this just happened under load, and in the logs there were only NoClassDefFoundError classes of Hazelcast itself.  As a treatment, before launching the application, I had to forcefully unpack the classes of all libraries with the following command: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">springBoot</span></span> {requiresUnpack = ['com.hazelcast<span class="hljs-symbol"><span class="hljs-symbol">:hazelcast</span></span>', 'com.hazelcast<span class="hljs-symbol"><span class="hljs-symbol">:hazelcast-client</span></span>']} )</code> </pre> <br><p>  To prevent this from happening in the future, we simply turned off its package builder in spring boot: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">apply</span></span> plugin: <span class="hljs-string"><span class="hljs-string">'spring-boot'</span></span> bootRepackage { <span class="hljs-attribute"><span class="hljs-attribute">enabled</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Then when you start the application, you must explicitly unload the entire contents of the .jar at startup: </p><br><pre> <code class="hljs bash">-Dsun.misc.URLClassPath.disableJarChecking=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \<span class="hljs-variable"><span class="hljs-variable">$JAVA_OPTS</span></span> -cp \<span class="hljs-variable"><span class="hljs-variable">$jarfile</span></span>:<span class="hljs-variable"><span class="hljs-variable">$libDirectory</span></span>/*:. <span class="hljs-variable"><span class="hljs-variable">$mainClassName</span></span></code> </pre> <br><p>  Using the standard Class Loader eliminated class loading errors when the application was running, but required writing code to build the package for installation. </p><br><h2 id="lozhnye-srabatyvaniya-politik-evikta-dannyh">  False Data Policy Evict Triggers </h2><br><p>  In our infrastructure, Hazelcast is used primarily as a data warehouse; IMap is ideally suited for this - the distributed <strong>Map &lt;Key, Value&gt;</strong> .  To protect yourself from memory shortages and <strong>OutOfMemory</strong> exceptions, each of the IMap instances pre-configured on the Hazelcast side has an upper memory limit, as well as rotation policies for obsolete entries. </p><br><p><img src="https://habrastorage.org/web/a7d/6d1/edf/a7d6d1edf58e4d7f858b470f3c147dcc.png"><br>  <em>Garbage Collector at work.</em> </p><br><p>  To correctly remove unnecessary information, we use a bunch of TTL and MaxIDLE () parameters to limit the lifetime of the data in these collections, as well as limiting the size of the stored data on each node. </p><br><p>  The collection restriction policies by size (MaxSizePolicy) are several: </p><br><ul><li><p>  PER_NODE: The maximum number of entries for each JVM. </p><br></li><li><p>  PER_PARTITION: The maximum number of entries for one partition. </p><br></li><li><p>  USED_HEAP_SIZE: The maximum amount of memory that records of a particular collection can take is the sum of the calculated sizes of each record. </p><br></li><li><p>  USED_HEAP_PERCENTAGE: The same as USED_HEAP_SIZE, only in percentage. </p><br></li><li><p>  FREE_HEAP_SIZE: The minimum size of the remaining JVM allocated memory, based on the data of the JVM itself. </p><br></li><li>  FREE_HEAP_PERCENTAGE: the same as FREE_HEAP_SIZE, only in percent). </li></ul><br><p>  Initially used FREE_HEAP_PERCENTAGE, but eventually switched to USED_HEAP_PERCENTAGE.  The fact is that these similarly designed policies work in completely different ways: </p><br><ul><li><p>  FREE_HEAP_PERCENTAGE - starts to clear data in collections at Runtime.getRuntime (). FreeMemory () is less than the set limit.  Suppose I want to start panicking and deleting data if less than 10% of the memory available to the application is left.  Then we get a constant response of this policy under load.  And this is normal, because this is how a Java machine works when allocating and freeing memory. </p><br></li><li>  USED_HEAP_PERCENTAGE - works in a completely different way (and this can be understood only after carefully studying the source code of Hazelcast, it‚Äôs good that it is freely available), this policy works on each collection separately, and the calculated cost of the stored data, which is approximately equal to real value.  Since this is not JVM readings, but calculated data, the EntryCost change graph does not look like a cardiogram, and the sensor does not work erroneously and the data deletion process does not start. </li></ul><br><p>  As for FREE_HEAP_PERCENTAGE, we tried to configure the GC so that the threshold of available memory was never reached, but at best nothing changed.  Either there were problems with OldGen and Stop-the-World. </p><br><p>  Using USED_HEAP_PERCENTAGE, it was possible to completely get rid of problems with premature evikt data from the collections.  One of the features of the work of the evikta is the mechanism for selecting elements for removal (EvictionPolicy: LRU, RANDOM, etc.).  We need LRU (Last Recently Used), but, from his point of view, the data just downloaded and the data never requested have the same weight, which needs to be taken into account. </p><br><h2 id="zagruzka-dannyh-bez-ucheta-nastroek-imap">  Data download without IMap settings </h2><br><p>  Programming Hazelcast gives you the freedom to configure it ‚Äî for example, you can start the cluster node first and then apply the storage settings.  You should not do this, because after launching, the node is already included in the sharding mechanism, replication and backup of Hazelcast data.  Under the load in these fractions of a second, we can get a certain number of records in collections that have evicts default settings, i.e  infinite TTL in our case.  Records are immediately replicated and backed up to other nodes. </p><br><p>  While the problem manifested itself, enough time passed, and a decent amount of ballast accumulated in the cluster.  The settings are not applied to these records, and they themselves will never be deleted, because  in Hazelcast, the properties of each record are baked at the time of saving.  And finding and deleting all such records is not an entirely trivial task.  Conclusion: first we configure the instance, then we start it. </p><br><h2 id="dolgo-vypolnyayutsya-komandy-v-moment-izmeneniya-struktury-klastera">  For a long time, commands are executed when the cluster structure is changed. </h2><br><p>  Hazelcast responds adequately to the shutdown of one node or even half of the entire cluster, because the data is replicated between all participants.  But staffing behavior for Hazelcast is not so good for its customers.  The client has a wonderful smartRouting setting, which allows it to switch to another node on its own when the connection is lost by default. </p><br><p>  It works, but not fast enough, and all requests to add or receive data come to other nodes of the cluster with pre-established connections.  Delays in setting up a connection and operations with data under load do not fit into client timeouts (we limited the operation time to 400 ms), and their operations are interrupted.  Therefore, it is important to teach the client part to handle such errors and try to repeat the operation. </p><br><p>  In turn, it is also not the best idea to carry out operations without an expired timeout, because by default it is 60 seconds - does the client have enough patience?  All these problems can be avoided with a regular reboot of the Hazelcast node - it is enough not to use smartRouting on the client, and stop all its clients before stopping the node. </p><br><h1 id="monitoring-klastera">  Cluster Monitoring </h1><br><p>  Hazelcast has its own monitoring tool, the Management Center, available under the Enterprise license.  But all metrics are available on JMX and they can be collected, for example, using Zabbix.  So, in our network, the memory occupied by the application and, if necessary, any other available metric are monitored. </p><br><p>  Nevertheless, Zabbix is ‚Äã‚Äãpoor in terms of its ability to compile queries, build and design graphs, so it is more suitable as a source of data for <a href="https://grafana.com/">Grafana</a> .  To monitor collection sizes, hit rate, latency, their values ‚Äã‚Äãare sent to Graphite from the component that controls the launch of the Hazelcast node. </p><br><p>  Temporary data requires automatic cleaning, and you also need to keep an eye on it.  Therefore, the log gets every addition, deletion or evikt data from the collections.  Live logs are available at Kibana - Adele <a href="https://habrahabr.ru/company/yamoney/blog/328018/">recently talked</a> about this - and are great for investigating incidents or tracking the effectiveness of caches.  Such logging can be implemented using <strong>MapListener</strong> , which fully covers the needs of our team in monitoring the cluster. </p><br><h1 id="perezapusk-nod-klastera">  Restart cluster nodes </h1><br><p>  In order to make the process of restarting all the nodes of the cluster as painless as possible for the system, we use the following approach: </p><br><ul><li><p>  Each change to the Hazelcast settings ‚Äî setting up new or existing collections, monitoring, and allocating memory to the application ‚Äî is performed as part of the cluster release process as a component of our system. </p><br></li><li><p>  To automate the process of restarting all the nodes with the new settings, a script was written that, based on the monitoring data of the node, decides whether it can be restarted with the new version.  Hazelcast has PartitionService with information about the state of cluster partitions, including information about all data backups, isLocalMemberSafe ().  The script interprets this flag as a sign of the ability to safely restart a node - all its data can be recovered from other node backups. </p><br></li><li>  By itself, the isLocalMemberSafe () flag does not guarantee that everything will not fall apart in the next millisecond.  Therefore, we run Hazelcast with the following parameter: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hazelcast.shutdownhook.enabled"</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </li></ul><br><p>  This allows you to disable <strong>Terminate</strong> (hard disconnect) node when receiving a signal SEGTERM.  The script sends the SEGTERM node, the application context is closed with a call to Graceful Shutdown. </p><br><p>  This method ensures the regular output of the node from the cluster, waiting for complete data synchronization before turning off the node.  The process of cluster release takes about an hour in semiautomatic mode, and the node input to the cluster takes an average of 5 seconds. </p><br><h1 id="poterya-poloviny-nod-klastera">  Loss of half node nodes </h1><br><p>  An interesting schedule I noticed one good morning.  The maintenance service conducted exercises to disable one DC, and at some point the Hazelcast cluster was left without half of its nodes.  All data was successfully restored from the partition group backups, and the decrease in the number of nodes in the cluster had a positive effect on the speed of work. </p><br><p><img src="https://habrastorage.org/web/268/6c3/7d8/2686c37d82f34fd1b2ce21968197cba4.png"><br>  <em>With a complete shutdown of one DC, Hazelcast repartitioned the data to the remaining nodes, and the speed of work increased almost 2 times.</em> </p><br><p>  The question arises: why don't we leave 2 times less nodes?  Here is just the space for research - we will select a configuration that will provide maximum speed without harming fault tolerance. </p><br><h1 id="stoilo-li-ono-togo">  Was it worth it </h1><br><p>  The distributed in-memory database allowed organizing convenient and ‚Äúbeautiful‚Äù storage of a mass of temporary information.  In addition, the architecture was not only productive, but also well-scalable.  But I would be careful not to advise such distributed systems to everyone in a row, as they are rather difficult to maintain, the benefits of which can only be felt on a really large data stream. </p><br><p>  In addition, according to the results of the project, we learned not to trust solutions based only on their popularity (hi Spring Boot), as well as to thoroughly test a new product before implementation.  But even after all the settings described in the article, I will have to do something to twist and change: for example, I have yet to learn the ‚Äújoy‚Äù of updating from Hazelcast 3.5.5 to the latest version 3.8.  The point is that the versions are backwards incompatible and therefore the thrill is guaranteed.  But I will tell you about this some other time. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332462/">https://habr.com/ru/post/332462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332448/index.html">Delivery of billions of messages strictly once</a></li>
<li><a href="../332450/index.html">Moby / Docker in production. Failure history</a></li>
<li><a href="../332456/index.html">Running AMP applications on Cyclone V SoC</a></li>
<li><a href="../332458/index.html">Broadcast HPE Digitize: talk about our new products and solutions</a></li>
<li><a href="../332460/index.html">Why do I need your permanent collections? They are slow</a></li>
<li><a href="../332464/index.html">Color segmentation for dummies</a></li>
<li><a href="../332466/index.html">The market of detection and recognition systems: Emotions and "emotional calculations"</a></li>
<li><a href="../332468/index.html">How to pass an interview in a dream company? Tips from timlidov IT companies</a></li>
<li><a href="../332470/index.html">It's about time: a secure corporate instant messenger from a Russian integrator will be shown in Digital October</a></li>
<li><a href="../332472/index.html">Analysis of the backdoor group TeleBots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>