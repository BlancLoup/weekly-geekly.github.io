<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go Benchmarks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Benchmarks 
 Benchmarks are tests for performance. It is quite useful to have them in the project and compare their results from commit to commit. Go ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go Benchmarks</h1><div class="post__text post__text-html js-mediator-article"><h4>  Benchmarks </h4><br>  Benchmarks are tests for performance.  It is quite useful to have them in the project and compare their results from commit to commit.  Go has a very good toolkit for writing and running benchmarks.  In this article, I will show how to use the <code>testing</code> package to write benchmarks. <br><a name="habracut"></a><br><h4>  How to write a benchmark </h4><br>  It's easy to go.  Here is an example of the simplest benchmark: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); x != <span class="hljs-string"><span class="hljs-string">"42"</span></span> { b.Fatalf(<span class="hljs-string"><span class="hljs-string">"Unexpected string: %s"</span></span>, x) } } }</code> </pre><br>  Save this code to the bench_test.go file and run the <code>go test -bench=. bench_test.go</code>  <code>go test -bench=. bench_test.go</code> . <br>  You will see something like: <br><blockquote>  testing: warning: no tests to run <br>  Pass <br>  BenchmarkSample 10,000,000 206 ns / op <br>  ok command-line-arguments 2.274s <br></blockquote><br>  We see here that one iteration of the benchmark took 206 nanoseconds.  It was really easy.  But there are a couple more interesting things about benchmarks in Go. <br><br><h4>  What can you test with benchmarks? </h4><br>  By default, <code>go test -bench=.</code>  tests only the speed of your code, but you can add the <code>-benchmem</code> flag, which will allow you to test the memory consumption and the number of memory allocations.  It will look like this: <br><blockquote>  Pass <br>  BenchmarkSample 10,000,000 208 ns / op 32 B / op 2 allocs / op <br></blockquote><br>  Here we see the number of bytes and memory allocations per iteration.  Useful information as for me.  You can also include these results for each benchmark separately by calling the <code>b.ReportAllocs()</code> method. <br>  But that's not all, you can also set the bandwidth per iteration in bytes using the <code>b.SetBytes(n int64)</code> method.  For example: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { b.SetBytes(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); x != <span class="hljs-string"><span class="hljs-string">"42"</span></span> { b.Fatalf(<span class="hljs-string"><span class="hljs-string">"Unexpected string: %s"</span></span>, x) } } }</code> </pre><br>  Now the output will be: <br><blockquote>  Pass <br>  BenchmarkSample 5000000 324 ns / op 6.17 MB / s 32 B / op 2 allocs / op <br>  ok command-line-arguments 1.999s <br></blockquote><br>  You can see a column with a bandwidth that is equal to <code>6.17 MB/s</code> in my case. <br><br><h4>  Initial conditions for benchmarks </h4><br>  What if you need to do something before each iteration of the benchmark?  Of course, you do not want to include the time of this operation in the benchmark results.  I wrote a very simple <code>Set</code> data structure for testing: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { set <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} mu sync.Mutex } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *Set)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { s.mu.Lock() s.set[x] = <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} s.mu.Unlock() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *Set)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { s.mu.Lock() <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(s.set, x) s.mu.Unlock() }</code> </pre><br>  and benchmark for the <code>Delete</code> method: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSetDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testSet []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>; i++ { testSet = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(testSet, strconv.Itoa(i)) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { b.StopTimer() set := Set{set: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, elem := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> testSet { set.Add(elem) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, elem := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> testSet { set.Delete(elem) } } }</code> </pre><br>  This code has two problems: <br><ul><li>  The time and memory of creating a <code>testSet</code> slice <code>testSet</code> included in the first iteration (and this is not a very big problem, because there will be many iterations) </li><li>  Time and memory for the <code>Add</code> method call is included in each iteration. </li></ul><br>  For such cases, we have the <code>b.ResetTimer()</code> , <code>b.StopTimer()</code> and <code>b.StartTimer()</code> .  Here is their use in the previous benchmark: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkSetDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testSet []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1024</span></span>; i++ { testSet = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(testSet, strconv.Itoa(i)) } b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { b.StopTimer() set := Set{set: <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, elem := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> testSet { set.Add(elem) } b.StartTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, elem := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> testSet { set.Delete(elem) } } }</code> </pre><br>  Now the initial setting will not be taken into account in the results and we will see only the results of calling the <code>Delete</code> method. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Benchmark comparison </h4><br>  Of course, benchmarking is of little use if you cannot compare them after changing the code.  Here is a sample code that serializes the structure in <code>json</code> and a benchmark for it: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { X <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json.Marshal(t) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkToJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { tmp := &amp;testStruct{X: <span class="hljs-number"><span class="hljs-number">1</span></span>, Y: <span class="hljs-string"><span class="hljs-string">"string"</span></span>} js, err := tmp.ToJSON() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { b.Fatal(err) } b.SetBytes(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(js))) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := tmp.ToJSON(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { b.Fatal(err) } } }</code> </pre><br>  Suppose this code has already been added to git, now I want to try a cool trick and measure the performance gain (or drop).  I am slightly changing the <code>ToJSON</code> method: <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToJSON</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">`{"X": `</span></span> + strconv.Itoa(tX) + <span class="hljs-string"><span class="hljs-string">`, "Y": "`</span></span> + tY + <span class="hljs-string"><span class="hljs-string">`"}`</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  It's time to start benchmarks, this time we will save their output to files: <br><blockquote>  go test -bench =.  -benchmem bench_test.go&gt; new.txt <br>  git stash <br>  go test -bench =.  -benchmem bench_test.go&gt; old.txt <br></blockquote><br>  We can compare these results using the <a href="http://godoc.org/golang.org/x/tools/cmd/benchcmp">benchcmp</a> utility.  You can install it by running <code>go get golang.org/x/tools/cmd/benchcmp</code> .  Here are the comparison results: <br><blockquote>  # benchcmp old.txt new.txt <br>  benchmark old ns / op new ns / op delta <br>  BenchmarkToJSON 1579 495 -68.65% <br><br>  benchmark old MB / s new MB / s speedup <br>  BenchmarkToJSON 12.66 46.41 3.67x <br><br>  benchmark old allocates new allocs delta <br>  BenchmarkToJSON 2 2 + 0.00% <br><br>  benchmark old bytes delta <br>  BenchmarkToJSON 184 48 -73.91% <br></blockquote><br>  It is very useful to have such tables with changes, besides, they can add solidity to your pull requests in opensource projects. <br><br><h4>  Record Profiles </h4><br>  You can also record <code>cpu</code> and <code>memory</code> profiles during benchmarking: <br><blockquote>  go test -bench =.  -benchmem -cpuprofile = cpu.out -memprofile = mem.out bench_test.go <br></blockquote><br>  About profile analysis you can read a great <a href="http://blog.golang.org/profiling-go-programs">post</a> on the official Go blog. <br><br><h4>  Conclusion </h4><br>  Benchmarks are a great tool for a programmer.  And Go allows you to write and analyze benchmark results very easily.  New benchmarks allow you to find bottlenecks in performance, suspicious code (effective code is usually easier and easier to read), or using the wrong tools for tasks. <br><br>  Existing benchmarks will allow you to be more confident in the changes and their results can be a voice in your favor during the review.  Writing benchmarks gives great advantages to the programmer and the program, and I advise you to write more of them.  It's fun! </div><p>Source: <a href="https://habr.com/ru/post/268585/">https://habr.com/ru/post/268585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268575/index.html">Photoshop history</a></li>
<li><a href="../268577/index.html">Robonoch -2015</a></li>
<li><a href="../268579/index.html">Review TEKON SCADA</a></li>
<li><a href="../268581/index.html">Potentially, up to 1 million ‚Äúlive‚Äù VK.com accounts have been compromised by attackers.</a></li>
<li><a href="../268583/index.html">Supervisord and forever are no longer needed. Systemd</a></li>
<li><a href="../268587/index.html">Blocks. The internal structure of the Cach√© database file. Part 3</a></li>
<li><a href="../268593/index.html">Huawei and NTT DOCOMO successfully tested 5G technology in the field</a></li>
<li><a href="../268597/index.html">Mobile communications in Europe</a></li>
<li><a href="../268599/index.html">Enable HTTP / 2 in NGINX for the site</a></li>
<li><a href="../268605/index.html">Primary key - GUID or autoincrement? Part two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>