<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Indexes - 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time we looked at the PostgreSQL indexing mechanism , the interface of access methods , and two methods: a hash index and a B-tree . In this part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Indexes - 5</h1><div class="post__text post__text-html js-mediator-article"><br>  Last time we looked at <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">the PostgreSQL indexing mechanism</a> , the <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">interface of access methods</a> , and two methods: a <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash index</a> and a <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-tree</a> .  In this part of the deal indices GiST. <br><br><h1>  GiST </h1><br>  GiST is short for generalized search tree.  This is a balanced search tree, just like the previously considered b-tree. <br><br>  What is the difference?  The b-tree index is rigidly tied to the semantics of the comparison: the support of the operators ‚Äúmore‚Äù, ‚Äúless‚Äù, ‚Äúequal‚Äù is all that it is capable of (but it is capable of very well!).  But modern databases also store data types for which these operators simply do not make sense: geodata, text documents, pictures ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is where the GiST index method comes in.  It allows you to specify the principle of the distribution of data of any type on a balanced tree, and the method of using this view for access by some operator.  For example, an R-tree for spatial data with support for relative position operators (located on the left, right; contains, etc.) or an RD tree for sets with support for intersection or entry operators can be ‚Äúlaid down‚Äù in the GiST index. <br><br>  Due to the extensibility in PostgreSQL, it is quite possible to create a completely new access method from scratch: to do this, you need to implement an interface with an indexing mechanism.  But this requires thinking through not only the indexing logic, but also the page structure, effective implementation of locks, support of the proactive write log - which implies a very high qualification of the developer and greater complexity.  GiST simplifies the task by taking on low-level problems and providing its own interface: several functions related not to the technical field, but to the application area.  In this sense, we can say that GiST is a framework for building new access methods. <br><a name="habracut"></a><br><h2>  Device </h2><br>  GiST is a height-balanced tree consisting of page nodes.  Nodes consist of index entries. <br><br>  Each record of a leaf node (leaf record) contains, in the most general form, a certain <em>predicate</em> (a logical expression) and a link to a table row (TID).  Indexed data (key) must satisfy this predicate. <br><br>  Each internal node record (internal record) also contains a <em>predicate</em> and a link to the child node, all indexed data of the child subtree must satisfy this predicate.  In other words, the predicate of the inner record <em>includes</em> the predicates of all the child records.  This is an important property that replaces the GiST index with a simple ordering of the B-tree. <br><br>  The search in the GiST tree uses the special <em>consistent function</em> (consistent) - one of the functions defined by the interface, and implemented in its own way for each supported operator family. <br><br>  The consistency function is called for the index record and determines whether the predicate of this record is ‚Äúconsistent‚Äù with the search condition (of the form ‚Äú <em>indexed-field operator expression</em> ‚Äù).  For the internal record, it actually determines whether it is necessary to go down to the appropriate subtree, and for the sheet record, whether the indexed data satisfies the condition. <br><br>  The search, as usual in the tree, begins with the root node.  With the help of the consistency function, it becomes clear which subsidiaries it makes sense to enter (there may be several of them), and which ones - not.  Then the algorithm is repeated for each of the found child nodes.  If the node is a leaf, then the record selected by the consistency function is returned as one of the results. <br><br>  The search is performed in depth: the algorithm first tries to get to some leaf node.  This allows you to quickly return the first results (which may be important if the user is not interested in all the results, but only a few). <br><br>  Note once again that the consistency function should not have anything to do with the ‚Äúmore‚Äù, ‚Äúless‚Äù or ‚Äúequal‚Äù operators.  Its semantics may be completely different, and therefore it is not intended that the index will produce values ‚Äã‚Äãin any particular order. <br><br>  We will not consider the algorithms for inserting and deleting values ‚Äã‚Äãin GiST - for this we use several more <a href="https://postgrespro.ru/docs/postgresql/9.6/gist-extensibility.html">interface functions</a> .  But there is one important point.  When a new value is inserted into the index for it, such a parent record is selected so that its predicate should be expanded as little as possible (ideally, not expanded at all).  But when the value is deleted, the predicate of the parent record is no longer narrowed.  This happens only in two cases: when a page is divided into two (when there is not enough space on the page to insert a new index record) and when the index is completely rebuilt (using the reindex or vacuum full commands).  Therefore, the effectiveness of the GiST index with frequently changing data may degrade over time. <br><br>  Next we look at a few examples of indexes for different data types and the useful properties of GiST: <br><br><ul><li>  points (and other geometric objects) and search for the nearest neighbors; </li><li>  exception intervals and restrictions; </li><li>  full text search. </li></ul><br><h2>  R-tree for points </h2><br>  Let us demonstrate the above with the example of an index for points on a plane (similar indices can be constructed for other geometric objects).  A regular B-tree is not suitable for this data type, since comparison points are not defined for points. <br><br>  The idea of ‚Äã‚Äãan R-tree is that the plane is divided into rectangles, which together cover all indexed points.  The index record stores a rectangle, and the predicate can be formulated as follows: ‚Äúthe desired point lies inside this rectangle‚Äù. <br><br>  The root of the R-tree will contain some of the largest rectangles (perhaps even intersecting).  Child nodes will contain smaller rectangles nested in the parent, collectively covering all the underlying points. <br><br>  Sheet nodes, in theory, should contain indexed points, but the data type in all index records must match;  therefore, all the same rectangles are stored, but ‚Äúcollapsed‚Äù to dots. <br><br>  To visualize such a structure visually, below are the drawings of the three levels of the R-tree;  The points represent the coordinates of airports (similar to the airports table of the demo database, but more data is taken from the <a href="https://openflights.org/data.html">openflights.org</a> site). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>First level;</em>  <em>two large intersecting rectangles are visible.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Second level;</em>  <em>large rectangles are divided into smaller areas.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Third level;</em>  <em>each rectangle contains so many points to fit on one index page.</em> <br><br>  Now let's take a closer look at a very simple ‚Äúone-level‚Äù example: <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br> <code>postgres=# create table points(p point); <br> CREATE TABLE <br> postgres=# insert into points(p) values <br> (point '(1,1)'), (point '(3,2)'), (point '(6,3)'), <br> (point '(5,5)'), (point '(7,8)'), (point '(8,6)'); <br> INSERT 0 6 <br> postgres=# create index on points using gist(p); <br> CREATE INDEX <br></code> <br>  The index structure for such a partition will look like this: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  The created index can be used to speed up, for example, the following query: ‚Äúfind all points included in a given rectangle‚Äù.  This condition is formulated as follows: <code>p &lt;@ box '(2,1),(6,3)'</code> (operator <code>&lt;@</code> from the points_ops family means ‚Äúcontained in‚Äù): <br><br> <code>postgres=# set enable_seqscan = off; <br> SET <br> postgres=# explain(costs off) select * from points where p &lt;@ box '(2,1),(7,4)'; <br> QUERY PLAN <br> ---------------------------------------------- <br> Index Only Scan using points_p_idx on points <br> Index Cond: (p &lt;@ '(7,4),(2,1)'::box) <br> (2 rows) <br></code> <br>  The consistency function for such an operator (‚Äú <em>indexed-field &lt;@ expression</em> ‚Äù, where the <em>indexed-field</em> is a point and the <em>expression</em> is a rectangle) is defined as follows.  For an internal record, it returns ‚Äúyes‚Äù if its rectangle intersects with the rectangle defined by the <em>expression.</em>  For a sheet entry, the function returns ‚Äúyes‚Äù if its point (‚Äúcollapsed‚Äù rectangle) is contained in the rectangle defined by the <em>expression.</em> <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  The search begins at the root node.  The rectangle (2,1) - (7,4) intersects with (1,1) - (6,3), but does not intersect with (5,5) - (8,8), therefore it is not necessary to go down to the second sub-tree. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Having come to the leaf node, we sort through the three points contained there and return two of them as a result: (3.2) and (6.3). <br><br> <code>postgres=# select * from points where p &lt;@ box '(2,1),(7,4)'; <br> p <br> ------- <br> (3,2) <br> (6,3) <br> (2 rows) <br></code> <br><br><h3>  Inside </h3><br>  Regular pageinspect, alas, does not allow a peek inside the GiST index.  But there is another way - the extension gevel.  It is not included in the standard package;  See <a href="http://www.sai.msu.su/~megera/wiki/Gevel">installation instructions</a> . <br><br>  If everything is done correctly, three functions will be available to you.  First, some statistics: <br><br> <code>postgres=# select * from gist_stat('airports_coordinates_idx'); <br> gist_stat <br> ------------------------------------------ <br> Number of levels:      4       + <br> Number of pages:      690      + <br> Number of leaf pages:    625      + <br> Number of tuples:      7873     + <br> Number of invalid tuples:  0       + <br> Number of leaf tuples:   7184     + <br> Total size of tuples:    354692 bytes + <br> Total size of leaf tuples: 323596 bytes + <br> Total size of index:    5652480 bytes+ <br> <br> (1 row) <br></code> <br>  Here you can see that the index on the coordinates of the airport took 690 pages and consists of four levels: the root and two internal levels were shown above in the figures, and the fourth level - sheet. <br><br>  In fact, the index for eight thousand points will take up much less space: here, for clarity, it was created with a filling of 10%. <br><br>  Secondly, you can display the index tree: <br><br> <code>postgres=# select * from gist_tree('airports_coordinates_idx'); <br> gist_tree <br> ----------------------------------------------------------------------------------------- <br> 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + <br> 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK)         + <br> 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK)        + <br> 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK)      + <br> 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK)       + <br> 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK)       + <br> 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK)      + <br> ... <br></code> <br>  And thirdly, you can display the data itself, which is stored in the index records.  Thin point: the result of the function must be converted to the desired data type.  In our case, this type is box (bounding box).  For example, at the top level we see five entries: <br><br> <code>postgres=# select level, a from gist_print('airports_coordinates_idx') <br> as t(level int, valid bool, a box) where level = 1; <br> level |                  a <br> -------+----------------------------------------------------------------------- <br> 1 | (47.663586,80.803207),(-39.2938003540039,-90) <br> 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) <br> 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) <br> 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) <br> 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) <br> (5 rows) <br></code> <br>  Actually, the figures above were prepared just on the basis of these data. <br><br><h2>  Search and ordering operators </h2><br>  The operators considered so far (such as <code>&lt;@</code> in the predicate <code>p &lt;@ box '(2,1),(7,4)')</code> can be called search operators, since they specify the search conditions in the query. <br><br>  There is another type of statement - ordering.  They are used to indicate the order of results to be output in the order by clause, where simple fields are usually used.  Here is an example of such a request: <br><br> <code>postgres=# select * from points order by p &lt;-&gt; point '(4,7)' limit 2; <br> p <br> ------- <br> (5,5) <br> (7,8) <br> (2 rows) <br></code> <br><br>  Here <code>p &lt;-&gt; point '(4,7)'</code> is an expression using the ordering operator <code>&lt;-&gt;</code> , which denotes the distance from one argument to another.  The meaning of the query: give two points closest to the point (4.7).  Such a search is known as k-NN - k-nearest neighbor search. <br><br>  To support this type of query, the access method must define an additional <em>distance function</em> (distance), and the ordering operator must be included in the appropriate class of operators (for example, for points, the points_ops class).  Here is a query that shows the operators and their type (s - search, o - ordering): <br><br> <code>postgres=# select amop.amopopr::regoperator, amop.amoppurpose, amop.amopstrategy <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname = 'point_ops' <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'gist' <br> and amop.amoplefttype = opc.opcintype; <br> amopopr    | amoppurpose | amopstrategy <br> -------------------+-------------+-------------- <br> &lt;&lt;(point,point)  | s      |       1    <br> &gt;&gt;(point,point)  | s      |       5    <br> ~=(point,point)  | s      |       6   <br> &lt;^(point,point)  | s      |      10    <br> &gt;^(point,point)  | s      |      11    <br> &lt;-&gt;(point,point)  | o      |      15   <br> &lt;@(point,box)   | s      |      28     <br> &lt;@(point,polygon) | s      |      48     <br> &lt;@(point,circle)  | s      |      68     <br> (9 rows) <br></code> <br>  The numbers of the strategies are also shown here with their meaning decoding.  It is seen that the strategies are much more than the btree;  only part of them is supported for points.  For other data types, other strategies may be defined. <br><br>  The distance function is called for an index element and must determine the distance (taking into account the semantics of the operator) from the value defined by the expression (" <em>indexed-field ordering-operator expression</em> ") to the given element.  For a sheet item, this is simply the distance to the indexed value.  For an inner element, the function must return the minimum of the distances to the child leaf elements.  Since it would be quite expensive to go through all the child records, the function has the right to optimistically minimize the distance, but at the cost of worsening the search efficiency.  However, it should not exaggerate categorically - it will break the operation of the index. <br><br>  The distance function can return a value of any type that can be sorted (to order, PostgreSQL will use comparison semantics from the corresponding family of btree access method operators, as <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">described earlier</a> ). <br><br>  In the case of points on a plane, the distance is understood in the most usual sense: the value of the expression <code>(x1,y1) &lt;-&gt; (x2,y2)</code> is equal to the root of the sum of the squares of the differences of abscissa and ordinate.  For the distance from the point to the bounding rectangle, the <em>minimum</em> distance from the point to this rectangle is taken, or zero if the point is inside it.  This value is easy to calculate without circumventing child points, and it is guaranteed not more than the distance to any of the child points. <br><br>  Consider the search algorithm for the above query. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  The search begins at the root node.  It has two bounding rectangles.  The distance to (1.1) - (6.3) is 4.0, and to (5.5) - (8.8) - 1.0. <br><br>  Bypassing the child nodes occurs in order of increasing distance.  Thus, we first go down to the nearest child node and find the distances to the points (for clarity, we will show the figures in the figure): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  This information is already enough to return the first two points (5.5) and (7.8).  Since we know that the distance to the points inside the rectangle (1,1) - (6,3) is 4.0 or more, there is no need to go down to the first child node. <br><br>  What if we needed to find the first <em>three</em> points? <br><br> <code>postgres=# select * from points order by p &lt;-&gt; point '(4,7)' limit 3; <br> p <br> ------- <br> (5,5) <br> (7,8) <br> (8,6) <br> (3 rows) <br></code> <br><br>  Although all these points are contained in the second child node, we cannot return (8.6) without looking at the first child node, since there may be closer points (since 4.0 &lt;4.1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  This example explains the distance function requirements for internal records.  Choosing a smaller distance for the second record (4.0 instead of real 4.5), we worsened the efficiency (the algorithm began to look through the extra node in vain), but did not break the correctness of the work. <br><br>  Until recently, GiST was the only access method that could work with ordering operators.  But the situation has changed: the RUM method has already been added to this company (about which we will talk later), and it is possible that the good old B-tree will join them - the patch written by our colleague Nikita Glukhov is being discussed by the community. <br><br><h2>  R-tree for intervals </h2><br>  Another example of using the gist access method is indexing intervals, for example, time (type tsrange).  The difference is that the internal nodes of the tree will contain non-bounding rectangles, but bounding intervals. <br><br>  A simple example.  We will rent a house in the village and store in the table the booking intervals: <br><br> <code>postgres=# create table reservations(during tsrange); <br> CREATE TABLE <br> postgres=# insert into reservations(during) values <br> ('[2016-12-30, 2017-01-09)'), <br> ('[2017-02-23, 2017-02-27)'), <br> ('[2017-04-29, 2017-05-02)'); <br> INSERT 0 3 <br> postgres=# create index on reservations using gist(during); <br> CREATE INDEX <br></code> <br>  The index can be used, for example, to speed up the following query: <br><br> <code>postgres=# select * from reservations where during &amp;&amp; '[2017-01-01, 2017-04-01)'; <br> during <br> ----------------------------------------------- <br> ["2016-12-30 00:00:00","2017-01-08 00:00:00") <br> ["2017-02-23 00:00:00","2017-02-26 00:00:00") <br> (2 rows) <br> <br> postgres=# explain (costs off) select * from reservations where during &amp;&amp; '[2017-01-01, 2017-04-01)'; <br> QUERY PLAN <br> ------------------------------------------------------------------------------------ <br> Index Only Scan using reservations_during_idx on reservations <br> Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) <br> (2 rows) <br></code> <br>  The <code>&amp;&amp;</code> operator for intervals denotes the intersection;  thus, the request must return all intervals that intersect with the specified one.  For such an operator, the consistency function determines whether the specified interval intersects with the value in the inner or leaf entry. <br><br>  Note that in this case we are not talking about getting the intervals in a certain order, although the comparison operators are defined for the intervals.  For them, you can use the b-tree index, but in this case you will have to do without the support of such operations as: <br><br> <code>postgres=# select amop.amopopr::regoperator, amop.amoppurpose, amop.amopstrategy <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname = 'range_ops' <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'gist' <br> and amop.amoplefttype = opc.opcintype; <br> amopopr     | amoppurpose | amopstrategy <br> -------------------------+-------------+-------------- <br> @&gt;(anyrange,anyelement) | s      |      16    <br> &lt;&lt;(anyrange,anyrange)  | s      |       1    <br> &amp;&lt;(anyrange,anyrange)  | s      |       2       <br> &amp;&amp;(anyrange,anyrange)  | s      |       3   <br> &amp;&gt;(anyrange,anyrange)  | s      |       4       <br> &gt;&gt;(anyrange,anyrange)  | s      |       5    <br> -|-(anyrange,anyrange)  | s      |       6   <br> @&gt;(anyrange,anyrange)  | s      |       7    <br> &lt;@(anyrange,anyrange)  | s      |       8     <br> =(anyrange,anyrange)   | s      |      18   <br> (10 rows) <br></code> <br>  (In addition to equality, which is included in the class of operators for the btree access method.) <br><br><h3>  Inside </h3><br>  Inside you can look at all the same extension gevel.  You just need to remember to change the data type in the call to gist_print: <br><br> <code>postgres=# select level, a from gist_print('reservations_during_idx') <br> as t(level int, valid bool, a tsrange); <br> level |            a <br> -------+----------------------------------------------- <br> 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") <br> 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") <br> 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") <br> (3 rows) <br></code> <br><h2>  Exception restriction </h2><br>  The GiST index can be used to support exclusion constraints. <br><br>  The exclusion constraint ensures that the specified fields of any two rows of the table will not "match" each other in the sense of some operator.  If ‚Äúequal‚Äù is chosen as an operator, then the uniqueness constraint is obtained: the specified fields of any two lines are not equal to each other. <br><br>  Like the uniqueness constraint, the exception constraint is supported by an index.  You can select any operator, if only he: <br><br><ol><li>  supported by the index method ‚Äî the can_exclude property (for example, these are btree, gist, or spgist methods, but not gin); </li><li>  was commutative, that is, the condition must be satisfied: <em>a operator b</em> = <br>  <em>b operator a.</em> </li></ol><br>  Here is a list of suitable strategies and examples of operators (operators, as we remember, may be called differently and may not be available for all data types): <br><br><ul><li>  for btree: <br><ul><li>  Equals <code>=</code> </li></ul><br></li><li>  for gist and spgist: <br><ul><li>  "Intersection" <code>&amp;&amp;</code> </li><li>  "Coincidence" <code>~=</code> </li><li>  "Fit" <code>-|-</code> </li></ul><br></li></ul><br>  Note that it is possible to use the equality operator in restricting an exception, but it has no practical meaning: the uniqueness restriction will be more efficient.  That is why we did not deal with the limitations of the exception when talking about B-trees. <br><br>  Let us give an example of the use of an exception restriction  It is logical not to allow booking a lodge at overlapping time intervals. <br><br> <code>postgres=# alter table reservations add exclude using gist(during with &amp;&amp;); <br> ALTER TABLE <br></code> <br>  After creating an integrity constraint, we can add lines: <br><br> <code>postgres=# insert into reservations(during) values ('[2017-06-10, 2017-06-13)'); <br> INSERT 0 1 <br></code> <br>  But an attempt to insert an overlapping interval into the table will result in an error: <br><br> <code>postgres=# insert into reservations(during) values ('[2017-05-15, 2017-06-15)'); <br> ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" <br> DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")). <br></code> <br><br><h3>  Btree_gist extension </h3><br>  Let's complicate the task.  Our modest business is expanding and we are going to rent out a few houses: <br><br> <code>postgres=# alter table reservations add house_no integer default 1; <br> ALTER TABLE <br></code> <br>  We need to change the exclusion constraint to take into account the house number.  However, GiST does not support the equality operation for integers: <br><br> <code>postgres=# alter table reservations drop constraint reservations_during_excl; <br> ALTER TABLE <br> postgres=# alter table reservations add exclude using gist(during with &amp;&amp;, house_no with =); <br> ERROR: data type integer has no default operator class for access method "gist" <br> HINT: You must specify an operator class for the index or define a default operator class for the data type. <br></code> <br>  In this case, the <a href="https://postgrespro.ru/docs/postgresql/9.6/btree-gist">btree_gist</a> extension, which adds GiST support for operations specific to B-trees, will help.  In the end, GiST can work with any operators, so why not teach it to work with ‚Äúmore‚Äù, ‚Äúless‚Äù, ‚Äúequal‚Äù? <br><br> <code>postgres=# create extension btree_gist; <br> CREATE EXTENSION <br> postgres=# alter table reservations add exclude using gist(during with &amp;&amp;, house_no with =); <br> ALTER TABLE <br></code> <br>  Now we still can not book the first house on the same dates: <br><br> <code>postgres=# insert into reservations(during, house_no) values ('[2017-05-15, 2017-06-15)', 1); <br> ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl" <br></code> <br>  But we can book a second one: <br><br> <code>postgres=# insert into reservations(during, house_no) values ('[2017-05-15, 2017-06-15)', 2); <br> INSERT 0 1 <br></code> <br>  But you have to understand that, although GiST can somehow work with operations ‚Äúmore‚Äù, ‚Äúless‚Äù, ‚Äúequal‚Äù, the B-tree still copes with them better.  So this method should be used only if the GiST index is needed essentially - as in our example. <br><br><h2>  RD-tree for full-text search </h2><br><h3>  About full-text search </h3><br>  Let's start with a minimalist introduction to PostgreSQL full-text search (if you are in the subject, you can skip this section). <br><br>  The task of full-text search is to select those that <em>match the</em> search <em>query</em> among the set of <em>documents</em> <em>.</em>  (If there are a lot of results, then it is important to find the <em>best match,</em> but for now we will keep silent about it.) <br><br>  The document for the purposes of the search is reduced to a special type tsvector, which contains the <em>tokens</em> and their positions in the document.  Lexemes are words converted to a searchable form.  For example, standard words are reduced to lower case and their terminating endings are cut off: <br><br> <code>postgres=# set default_text_search_config = russian; <br> SET <br> postgres=# select to_tsvector('  ,  .  ,  ,    .'); <br> to_tsvector <br> -------------------------------------------------------------------- <br> '':3,5 '':13 '':2 '':9 '':11 '':4 '':7 <br> (1 row) <br></code> <br>  It also shows that some words (called <em>stop words</em> ) are generally dropped (‚Äúand‚Äù, ‚Äúby‚Äù), as they are supposed to be found too often for a search on them to be meaningful.  Of course, all these transformations are configured, but this is not about that now. <br><br>  The search query is represented by another type - tsquery.  A query, roughly speaking, consists of one or more lexemes connected by logical connectives: ‚Äúand‚Äù <code>&amp;</code> , ‚Äúor‚Äù <code>|</code>  , "Not" <code>!</code>  .  You can also use parentheses to specify the priority of operations. <br><br> <code>postgres=# select to_tsquery(' &amp; ( | )'); <br> to_tsquery <br> ---------------------------------- <br> '' &amp; ( '' | '' ) <br> (1 row) <br></code> <br>  For full-text search, a single match operator @@ is used. <br><br> <code>postgres=# select to_tsvector('  ,  .') @@ to_tsquery(' &amp; ( | )'); <br> ?column? <br> ---------- <br> t <br> (1 row) <br> <br> postgres=# select to_tsvector('  ,  .') @@ to_tsquery(' &amp; ( | )'); <br> ?column? <br> ---------- <br> f <br> (1 row) <br></code> <br>  This information will be enough for now.  Let's talk a little bit more about full-text search in one of the following parts on the GIN index. <br><br><h3>  Rd trees </h3><br>  In order for full-text search to work quickly, you must firstly store a tsvector column in the table (so as not to perform an expensive conversion each time you search), and second, build an index on this field.  One of the possible access methods for this is GiST. <br><br> <code>postgres=# create table ts(doc text, doc_tsv tsvector); <br> CREATE TABLE <br> postgres=# create index on ts using gist(doc_tsv); <br> CREATE INDEX <br> postgres=# insert into ts(doc) values <br> ('   '),  ('   '), (', , '), <br> ('  '), ('  '), (', , '), <br> ('  '),     ('  '),   (', , '); <br> INSERT 0 9 <br> postgres=# update ts set doc_tsv = to_tsvector(doc); <br> UPDATE 9 <br></code> <br>  The last step (conversion of the document in tsvector), of course, is convenient to assign to the trigger. <br><br> <code>postgres=# select * from ts; <br> doc      |       doc_tsv <br> -------------------------+-------------------------------- <br>      | '':3 '':2 '':4 <br>     | '':3 '':2 '':4 <br> , ,     | '':1,2 '':3 <br>     | '':2 '':3 '':1 <br>    | '':3 '':2 '':1 <br> , ,    | '':3 '':1,2 <br>        | '':3 '':2 <br>      | '':1 '':2 '':3 <br> , ,    | '':3 '':1,2 <br> (9 rows) <br></code> <br>  How should the index be arranged?  Directly R-tree is not suitable here - it is not clear what a ‚Äúbounding box‚Äù is for documents.  But you can apply some modification of this approach for sets - the so-called RD-tree (RD is the Russian Doll, the nested doll).  By set in this case, we understand the set of document lexemes, but in general a set can be any. <br><br>  The idea of ‚Äã‚ÄãRD-trees is to take a bounding set instead of a bounding box ‚Äî that is, a set containing all elements of the child sets. <br><br>  An important question is how to represent sets in index records.  Probably the most straightforward way is to simply list all the elements of a set.  Here‚Äôs how it might look: <br><br><img src="https://habrastorage.org/web/b35/990/7be/b359907bef99495e9f73b50a7c9d3fb3.png"><br><br>  Then, for example, for access by condition, <code>doc_tsv @@ to_tsquery('')</code> could be lowered only to those nodes that have the lexeme 'standing': <br><br><img src="https://habrastorage.org/web/f8a/2c5/fe2/f8a2c5fe24934c7a8dfda396c3b6657f.png"><br><br>  The problems of such a presentation are quite obvious.  The number of tokens in a document can be quite large, so index entries will take up a lot of space and fall into TOAST, making the index much less efficient.  Even if there are some unique tokens in each document, the union of the sets can still be very large - the higher to the root, the greater will be the index entries. <br><br>  Such a representation is sometimes used, but for other data types.  And for a full-text search, a different, more compact solution is used - the so-called <em>signature tree.</em>  His idea is well known to all who dealt with the Bloom filter. <br><br>  Each token can be represented by its <em>signature: a</em> bit string of a certain length, in which all the bits are zero, except for one.  The number of this bit is determined by the value of the hash function of the lexeme (about how the hash functions are arranged, we <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">said earlier</a> ). <br><br>  <em>The document signature</em> is called the bitwise ‚Äúor‚Äù signatures of all the tokens of the document. <br><br>  Suppose the signatures of our tokens are: <br><br> <code>    1000000 <br>    0001000 <br>   0000010 <br>   0010000 <br>   0000100 <br>     0100000 <br>     0000100 <br>   0000001 <br>    0000010 <br>     0000010 <br>    0010000 <br></code> <br>  Then the document signatures are obtained as follows: <br><br> <code>      0011010 <br>      0010110 <br> , ,      0110000 <br>      0011100 <br>     0010100 <br> , ,     0110000 <br>         0000011 <br>       1001010 <br> , ,     0100010 <br></code> <br><br>  The index tree can be represented as follows: <br><br><img src="https://habrastorage.org/web/4c4/a0f/699/4c4a0f6991114739b8079ac4ac63efe1.png"><br><br>  The advantages of this approach are obvious: index records have the same and small size, the index is compact.  But the drawback is also visible: because of the compactness, accuracy is lost. <br><br>  Consider the same condition <code>doc_tsv @@ to_tsquery('')</code> .  We calculate the search query signature in the same way as for the document: in our case, 0010000. The consistency function must output all the child nodes whose signature contains <em>at least one</em> bit from the query signature: <br><br><img src="https://habrastorage.org/web/2cd/ab2/337/2cdab23377984dcfa0acacc4c3c1dd0d.png"><br><br>  Compare with the picture above: it is clear that the tree is ‚Äúyellowed‚Äù - and this means that false positive responses occur (what we call errors of the first kind) and extra nodes are searched during the search.  Here we hooked the lexeme ‚Äúzalomat‚Äù, the signature of which, in misfortune, coincided with the signature of the sought lexeme ‚Äústanding‚Äù.  It is important that false negatives (errors of the second kind) in this scheme can not be, that is, we are guaranteed not to miss the desired value. <br><br>  In addition, it may happen that different documents will get the same signatures: in our example, there were no luck ‚Äúpeople, people, standing‚Äù and ‚Äúpeople, people, zalomati‚Äù (both have signature 0110000).  And if the tsvector value itself is not stored in the leaf index record, then the index itself will give false positives.  Of course, in this case, the access method will ask the index mechanism to recheck the result on the table, so that the user will not see these false positives.  But the effectiveness of the search may well suffer. <br><br>  In fact, the signature in the current implementation takes 124 bytes instead of seven bits in our pictures, so the probability of collisions is significantly less than in the example.  But after all, the documents in practice are indexed much more.  In order to somehow reduce the number of false positives of the index method, the implementation goes to the trick: the indexed tsvector is stored in the leaf index record, but only if it does not take up much space (just under 1/16 of a page, which is about half a kilobyte for 8 KB pages) . <br><br><h3>  Example </h3><br>  To see how indexing works on real data, take the pgsql-hackers mailing list archive.  The <a href="https://oc.postgrespro.ru/index.php/s/fRxTZ0sVfPZzbmd">version used in the example</a> contains 356,125 letters with the departure date, subject, author and text: <br><br> <code>fts=# select * from mail_messages order by sent limit 1; <br> -[ RECORD 1 ]------------------------------------------------------------------------ <br> id     | 1572389 <br> parent_id  | 1562808 <br> sent    | 1997-06-24 11:31:09 <br> subject   | Re: [HACKERS] Array bug is still there.... <br> author   | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; <br> body_plain | Andrew Martin wrote:                           + <br> | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + <br> | &gt; is still there. The regression test passes because the expected output+ <br> | &gt; has been fixed to the *wrong* output.                 + <br> |                                     + <br> | OK, I think I understand the current array behavior, which is apparently+ <br> | different than the behavior for v1.0x.                  + <br> ... <br></code> <br>  Add and fill the tsvector type column and build the index.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we will combine the three values ‚Äã‚Äã(subject, author and text of the letter) into one vector to show that the document does not have to be a single field, but may consist of completely arbitrary parts. </font><font style="vertical-align: inherit;">Some words, apparently, were rejected due to too large size. But in the end, the index is built and ready to support search queries: </font><font style="vertical-align: inherit;">Here you can see that, along with 898 matching lines, the access method returned another 7859 rows, which were eliminated by rechecking on the table. This clearly shows the negative impact of loss of accuracy on efficiency.</font></font><br><br> <code>fts=# alter table mail_messages add column tsv tsvector; <br> ALTER TABLE <br> fts=# update mail_messages <br> set tsv = to_tsvector(subject||' '||author||' '||body_plain); <br> NOTICE:  word is too long to be indexed <br> DETAIL:  Words longer than 2047 characters are ignored. <br> ... <br> UPDATE 356125 <br> fts=# create index on mail_messages using gist(tsv); <br> CREATE INDEX <br></code> <br><font style="vertical-align: inherit;"></font><br><br> <code>fts=# explain (analyze, costs off) <br> select * from mail_messages where tsv @@ to_tsquery('magic &amp; value'); <br> QUERY PLAN <br> ---------------------------------------------------------- <br> Index Scan using mail_messages_tsv_idx on mail_messages <br> (actual time=0.998..416.335 rows= <strong>898</strong> loops=1) <br> Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) <br> Rows Removed by Index Recheck: <strong>7859</strong> <br> Planning time: 0.203 ms <br> Execution time: 416.492 ms <br> (5 rows) <br></code> <br><font style="vertical-align: inherit;"></font><br><br><h3>  Inside </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To analyze the contents of the index, we again use the gevel extension: </font><font style="vertical-align: inherit;">Values ‚Äã‚Äãof a special type of gtsvector stored in index records are the signature itself, plus possibly the original tsvector. If there is a vector, then the number of tokens in it (unique words) is displayed, and if not, then the number of set (true) and cleared (false) bits in the signature. </font><font style="vertical-align: inherit;">It can be seen that in the root node the signature has degenerated to ‚Äúall units‚Äù - that is, one index level has become completely useless (and another one is almost completely useless with only four bits dropped).</font></font><br><br> <code>fts=# select level, a from gist_print('mail_messages_tsv_idx') as t(level int, valid bool, a gtsvector) where a is not null; <br> level |        a <br> -------+------------------------------- <br> 1 | 992 true bits, 0 false bits <br> 2 | 988 true bits, 4 false bits <br> 3 | 573 true bits, 419 false bits <br> 4 | 65 unique words <br> 4 | 107 unique words <br> 4 | 64 unique words <br> 4 | 42 unique words <br> ... <br></code> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h2>  Properties </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a look at the properties of the gist access method (requests </font></font><a href="https://habrahabr.ru/company/postgrespro/blog/326106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">were cited earlier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): There is no </font><font style="vertical-align: inherit;">support for sorting values ‚Äã‚Äãand uniqueness. The index, as we have seen, can be built on several columns and used in the exception constraints. </font><font style="vertical-align: inherit;">Index Properties: </font><font style="vertical-align: inherit;">And, the most interesting, column level properties. Some properties will be permanent: </font><font style="vertical-align: inherit;">(No sorting support; index cannot be used to search in an array; undefined values ‚Äã‚Äãare supported.) </font><font style="vertical-align: inherit;">But the two remaining properties, distance_orderable and returnable, will depend on the class of operators used. For example, for points see:</font></font><br><br> <code>amname |   name    | pg_indexam_has_property <br> --------+---------------+------------------------- <br> gist  | can_order   | f <br> gist  | can_unique   | f <br> gist  | can_multi_col | t <br> gist  | can_exclude  | t <br></code> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>name    | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | t <br> index_scan   | t <br> bitmap_scan  | t <br> backward_scan | f <br></code> <br><font style="vertical-align: inherit;"></font><br><br> <code>name     | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc         | f <br> desc        | f <br> nulls_first     | f <br> nulls_last     | f <br> orderable      | f <br> search_array    | f <br> search_nulls    | t <br></code> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>name     | pg_index_column_has_property <br> --------------------+------------------------------ <br> distance_orderable | t <br> returnable     | t <br></code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first property says that the distance operator is available to search for the nearest neighbors. </font><font style="vertical-align: inherit;">And the second is that the index can be used exclusively in index scanning. </font><font style="vertical-align: inherit;">In spite of the fact that not points, but rectangles are stored in leaf index records, the access method is able to return what is needed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the intervals: </font><font style="vertical-align: inherit;">For them, the distance function is not defined, hence the search for the nearest neighbors is impossible. </font><font style="vertical-align: inherit;">And full text search:</font></font><br><br> <code>name     | pg_index_column_has_property <br> --------------------+------------------------------ <br> distance_orderable | f <br> returnable     | t <br></code> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>name     | pg_index_column_has_property <br> --------------------+------------------------------ <br> distance_orderable | f <br> returnable     | f <br></code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to perform only index scans was also lost here, since only a signature without the actual data can appear in the leaf records. </font><font style="vertical-align: inherit;">However, this is a small loss, since the value of the tsvector type still does not interest anyone: it is used to select rows, but you need to show the source text, which is still not in the index.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Other data types </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we will denote several more types that are currently supported by the GiST access method, in addition to the geometrical types we have already examined (using dots for example), ranges, and full-text search types. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of the standard types, these are IP addresses </font></font><a href="https://postgrespro.ru/docs/postgresql/9.6/datatype-net-types"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the rest is added by extensions:</font></font><br><ul><li> <a href="https://postgrespro.ru/docs/postgresql/9.6/cube"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cube</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides the </font><a href="https://postgrespro.ru/docs/postgresql/9.6/cube"><font style="vertical-align: inherit;">cube</font></a><font style="vertical-align: inherit;"> data type for multidimensional cubes. </font><font style="vertical-align: inherit;">For it, as well as for geometric types on a plane, a class of GiST operators is defined: R-tree with the ability to search for nearest neighbors.</font></font><br></li><li> <a href="https://postgrespro.ru/docs/postgresql/9.6/seg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides the </font><a href="https://postgrespro.ru/docs/postgresql/9.6/seg"><font style="vertical-align: inherit;">seg</font></a><font style="vertical-align: inherit;"> data type for intervals with boundaries specified with a certain accuracy, and GiST index support for it (R-tree).</font></font><br></li><li> <a href="https://postgrespro.ru/docs/postgresql/9.6/intarray">intarray</a>         GiST-.    : gist__int_ops (RD-       )  gist__bigint_ops ( RD-).       ,  ‚Äî    . <br></li><li> <a href="https://postgrespro.ru/docs/postgresql/9.6/ltree">ltree</a>    ltree     GiST-   (RD-). <br></li><li> <a href="https://postgrespro.ru/docs/postgresql/9.6/pgtrgm">pg_trgm</a>     gist_trgm_ops      .    ‚Äî       GIN. <br></li></ul><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/337502/">Continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/333878/">https://habr.com/ru/post/333878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333866/index.html">Developer Life in Cyprus</a></li>
<li><a href="../333868/index.html">Cooking cache correctly</a></li>
<li><a href="../333870/index.html">Red Architecture - red help button for complex and confusing systems</a></li>
<li><a href="../333872/index.html">Openstack. Detective story or where the connection is lost? Part three</a></li>
<li><a href="../333874/index.html">Inside Docker Networks: How Docker Uses iptables and Linux Interfaces</a></li>
<li><a href="../333880/index.html">RubyMine 2017.2: Docker Compose, RuboCop auto-correction in the editor, improved VCS</a></li>
<li><a href="../333882/index.html">Security Week 29: How to crack ICO, RCE-bug in tens of millions of installations, Nukebot went to the people</a></li>
<li><a href="../333884/index.html">API Grace Rules</a></li>
<li><a href="../333888/index.html">How to explain the design of four years?</a></li>
<li><a href="../333890/index.html">Android Architecture Components. Part 3. LiveData</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>