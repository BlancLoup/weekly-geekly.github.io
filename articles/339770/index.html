<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript es8 and transition to async / await</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We recently published material " Promises in ES6: Patterns and Anti-Patterns ". It caused a serious interest of the audience, in the comments to it ou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript es8 and transition to async / await</h1><div class="post__text post__text-html js-mediator-article">  We recently published material " <a href="https://habrahabr.ru/company/ruvds/blog/339414/">Promises in ES6: Patterns and Anti-Patterns</a> ".  It caused a serious interest of the audience, in the comments to it our readers talked about the peculiarities of writing asynchronous code in modern JS projects.  By the way, we advise you to read their comments - you will find a lot of interesting things there. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/339770/"><img src="https://habrastorage.org/getpro/habr/post_images/62c/d3f/b31/62cd3fb315a5f5b12d7de940349edef8.jpg" alt="image"></a> <br><br>  Following the advice of the user <a href="https://habrahabr.ru/users/ilnuribat/">ilnuribat,</a> we added a survey to the material, the purpose of which was to find out the popularity of promises, callbacks and async / await constructions.  As of September 9, promises and async / await each received about 43% of the vote, with a small margin of async / await, and callbacks got 14%.  The main conclusion that can be made by analyzing the survey results and comments is that all the available technologies are important, however, more and more programmers are async / await.  Therefore, today we decided to publish a translation of an article about switching to async / await, which is a continuation of the material on promises. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Callbacks, promises, async / await</font> </h2><br>  Last week, <a href="https://medium.com/datafire-io/es6-promises-patterns-and-anti-patterns-bbb21a5d0918">I wrote about promises</a> , JS capabilities, which appeared in ES6.  Promises were a great way to break out of the <a href="http://callbackhell.com/">hell of callbacks</a> .  However, now, when support for <code>async / await</code> appeared in Node.js (from version 7.6.), I got the perception of promises as something like a temporary tool.  I must say that <code>async / await</code> can also be used in browser code thanks to transpilers like <a href="https://babeljs.io/">babel</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I want to say that in this material I will use the latest features of JS, including <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literals</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">pointer functions</a> .  View the list of ES6 innovations <a href="http://es6-features.org/">here</a> . <br><br><h2>  <font color="#3AC1EF">Why is async / await great?</font> </h2><br>  Until recently, asynchronous code in JavaScript, at best, looked awkward.  For developers who switched to JavaScript from languages ‚Äã‚Äãsuch as Python, Ruby, Java, and practically any other, callbacks and promises seemed to be unnecessarily complicated constructions that are prone to errors and completely confuse the programmer. <br><br>  The problem was that for the programmer there is not much difference between synchronous and asynchronous logic.  There are a lot of problems regarding performance and optimization that a programmer needs to think about when he is writing asynchronous code, but a completely different syntax is too much. <br><br>  Here are three examples that implement the same logic.  The first uses the usual synchronous functions, the second - callbacks, the third - promises.  Everyone solves the same problem: downloading information about the most popular article on HackerNews. <br><br>  Here is a hypothetical example of a synchronous version: <br><br><pre> <code class="hljs bash">// :    ! <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> hn = require(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> storyIDs = hn.getStories({storyType: <span class="hljs-string"><span class="hljs-string">'top'</span></span>}); <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> topStory = hn.getItem({itemID: storyIDs[0]}); console.log(`Top story: <span class="hljs-variable"><span class="hljs-variable">${topStory.title}</span></span> - <span class="hljs-variable"><span class="hljs-variable">${topStory.url}</span></span>`);</code> </pre> <br>  It's all very simple - nothing new for anyone who wrote on JS.  The code performs three steps: get a list of material IDs, download information about the most popular and display the result. <br><br>  All this is good, but in JavaScript you cannot block <a href="https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/">the event loop</a> .  Therefore, if article identifiers and information about a popular article come from a file, come in the form of a response to a network request, if they are read from the database, or if they get into the program as a result of performing any resource-intensive input-output operation, the corresponding commands should always be done asynchronous, using callbacks or promises (which is why the above code will not work, in fact, our <a href="https://www.npmjs.com/package/%40datafire/hacker_news">client for HackerNews is</a> <a href="https://github.com/DataFire/DataFire">based on promises</a> ). <br><br>  Here is the same logic implemented on callbacks (an example, again, hypothetical): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :    ! let hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); hn.getStories({storyType: <span class="hljs-string"><span class="hljs-string">'top'</span></span>}, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, storyIDs)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; hn.getItem({itemID: storyIDs[<span class="hljs-number"><span class="hljs-number">0</span></span>]}, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, topStory)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">Top story: ${topStory.title} - ${topStory.url}</span></span>`); }) })</code> </pre> <br>  Yeah.  Now the code fragments that implement the functionality we need are nested inside each other and we need to align them horizontally.  If there were 20 steps instead of three, then it would take 40 spaces to align the latter!  And if you need to add a new step somewhere in the middle, you would have to re-align everything that is below it.  This leads to huge and useless differences between different states of a file in Git.  In addition, note that we must handle errors at every step of the whole structure.  Grouping a set of operations in a single <code>try / catch</code> will not work. <br><br>  Let's try to do the same now, using the promises: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> hn.getStories({<span class="hljs-attr"><span class="hljs-attr">storyType</span></span>: <span class="hljs-string"><span class="hljs-string">'top'</span></span>})) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">storyIDs</span></span></span><span class="hljs-function"> =&gt;</span></span> hn.getItem({<span class="hljs-attr"><span class="hljs-attr">itemID</span></span>: storyIDs[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">topStory</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Top story: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${topStory.title}</span></span></span><span class="hljs-string"> - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${topStory.url}</span></span></span><span class="hljs-string">`</span></span>))</code> </pre> <br>  So, it already looks better.  All three steps are equally aligned horizontally and adding a new step somewhere in the middle is as easy as inserting a new line.  As a result, it can be said that the promise syntax is slightly verbose because of the need to use <code>Promise.resolve()</code> and because of all the <code>.then()</code> constructs present here. <br><br>  Now, having understood the usual functions, callbacks and promises, let's see how to do the same with the <code>async / await</code> construction: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> storyIDs = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> hn.getStories({<span class="hljs-attr"><span class="hljs-attr">storyType</span></span>: <span class="hljs-string"><span class="hljs-string">'top'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topStory = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> hn.getItem({<span class="hljs-attr"><span class="hljs-attr">itemID</span></span>: storyIDs[<span class="hljs-number"><span class="hljs-number">0</span></span>]}); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Top story: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${topStory.title}</span></span></span><span class="hljs-string"> - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${topStory.url}</span></span></span><span class="hljs-string">`</span></span>); })();</code> </pre> <br>  This is much better!  It looks like we did it as a synchronous code, except that the <code>await</code> keyword is used here.  In addition, we placed the code in an anonymous function, declared with the <code>async</code> in order to make this code fragment better suited for further work with it. <br><br>  It must be said that the methods <code>hn.getStories()</code> and <code>hn.getItem()</code> are designed so that they return promises.  When executed, the event loop is not blocked.  Thanks to <code>async / await</code> , for the first time in JS history, we were able to write asynchronous code using the usual declarative syntax! <br><br><h2>  <font color="#3AC1EF">Switch to async / await</font> </h2><br>  So, how to start using <code>async / await</code> in your projects?  If you are already working with promises, then you are ready to move to a new technology.  Any function that returns a promis can be called using the <code>await</code> keyword, which causes it to return the result of the promise resolution.  However, if you are going to switch to <code>async / await</code> from callbacks, you will first need to convert them to promises. <br><br><h3>  <font color="#3AC1EF">‚ñçMoving async / await from promises</font> </h3><br>  If you are one of those who are at the forefront of developers who have accepted promises, and in your code, to implement asynchronous logic, use <code>.then()</code> chains, switching to <code>async / await</code> will not be difficult: you just need to rewrite each <code>.then()</code> construct <code>.then()</code> using <code>await</code> . <br><br>  In addition, the <code>.catch()</code> block must be replaced with standard <code>try / catch</code> blocks.  As you can see, finally we can use the same approach for error handling in synchronous and asynchronous contexts! <br><br>  It is also important to note that the <code>await</code> keyword cannot be used <a href="https://gist.github.com/Rich-Harris/0b6f317657f5167663b493c722647221">at the top level of modules</a> .  It must be used inside functions declared with the <code>async</code> . <br><br><pre> <code class="hljs coffeescript">let hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    : Promise.resolve() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(_ =&gt; hn.getStories({storyType: <span class="hljs-string"><span class="hljs-string">'top'</span></span>})) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(storyIDs =&gt; hn.getItem({itemID: storyIDs[<span class="hljs-number"><span class="hljs-number">0</span></span>])) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(topStory =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(topStory)) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(e)) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    async / await: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(async () =&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">try</span></span></span></span><span class="hljs-function"><span class="hljs-params"> {   let storyIDs = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hn.getStories({storyType: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'top'</span></span></span></span><span class="hljs-function"><span class="hljs-params">});   let topStory = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hn.getItem({itemID: storyIDs[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]});   </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">console</span></span></span></span><span class="hljs-function"><span class="hljs-params">.log(topStory); }  </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catch</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (e) {   </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">console</span></span></span></span><span class="hljs-function"><span class="hljs-params">.error(e); } })()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Transfer to async / await from callbacks</font> </h3><br>  If your code still uses callback functions, the best way to switch to <code>async / await</code> is to pre-convert callbacks into promises.  Then, using the above method, the code using promises is rewritten using <code>async / await</code> .  You can read about how to convert callbacks into promises <a href="https://medium.com/datafire-io/es6-promises-patterns-and-anti-patterns-bbb21a5d0918">here</a> . <br><br><h2>  <font color="#3AC1EF">Patterns and pitfalls</font> </h2><br>  Of course, new technologies are always new problems.  Here are some useful patterns and sample errors you may encounter when translating your code into <code>async / await</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Cycles</font> </h3><br>  Ever since I started writing JS, passing functions as arguments to other functions was one of my favorite features.  Of course, callbacks are a mess, but I, for example, preferred to use <code>Array.forEach</code> instead of the usual <code>for</code> loop: <br><br><pre> <code class="hljs pgsql">const BEATLES = [<span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-string"><span class="hljs-string">'paul'</span></span>, <span class="hljs-string"><span class="hljs-string">'george'</span></span>, <span class="hljs-string"><span class="hljs-string">'ringo'</span></span>]; //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BEATLES.length; ++i) { console.log(BEATLES[i]); } //  <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>: BEATLES.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(beatle =&gt; console.log(beatle))</code> </pre> <br>  However, using <code>await</code> the <code>Array.forEach</code> method will not work properly, since it is designed to perform synchronous operations: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> storyIDs = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> hn.getStories({<span class="hljs-attr"><span class="hljs-attr">storyType</span></span>: <span class="hljs-string"><span class="hljs-string">'top'</span></span>}); storyIDs.forEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> itemID =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> details = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> hn.getItem({itemID});   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(details); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done!'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// !      ,    getItem()  . })();</span></span></code> </pre> <br>  In this example, <code>forEach</code> runs a bunch of simultaneous asynchronous calls to <code>getItem()</code> and returns immediately, without waiting for the results, so the first thing that is displayed on the screen is the string ‚Äúdone!‚Äù. <br><br>  If you need to wait for the results of asynchronous operations, it means that you need either a normal <code>for</code> loop (which will perform the operations sequentially) or the <code>Promise.all</code> construction (it will perform the operations in parallel): <br><br><pre> <code class="hljs pgsql">let hn = require(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(); (async () =&gt; { let storyIDs = await hn.getStories({storyType: <span class="hljs-string"><span class="hljs-string">'top'</span></span>}); //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (  ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; storyIDs.length; ++i) {   let details = await hn.getItem({itemID: storyIDs[i]});   console.log(details); } //  Promise.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> (  ) let detailSet = await Promise.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(storyIDs.map(itemID =&gt; hn.getItem({itemID}))); detailSet.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(console.<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>); })();</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçOptimization</font> </h3><br>  When using <code>async / await</code> you no longer need to think about what you are writing asynchronous code.  This is fine, but here lies the most dangerous trap of new technology.  The fact is that with this approach, you can forget about the little things that can have a huge impact on performance. <br><br>  Consider an example.  Suppose we want to get information about two Hacker News users and compare their karma.  Here is the usual implementation: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user1 = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> hn.getUser({<span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'sama'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user2 = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> hn.getUser({<span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'pg'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [more, less] = [user1, user2].sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> b.karma - a.karma); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${more.id}</span></span></span><span class="hljs-string"> has more karma (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${more.karma}</span></span></span><span class="hljs-string">) than </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${less.id}</span></span></span><span class="hljs-string"> (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${less.karma}</span></span></span><span class="hljs-string">)`</span></span>); })();</code> </pre> <br>  The code is quite working, but the second <code>getUser()</code> call will not be executed until the first one is completed.  The calls are independent, they can be executed in parallel.  Therefore, below is a better solution: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hn = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@datafire/hacker_news'</span></span>).create(); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([   hn.getUser({<span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'sama'</span></span>}),   hn.getUser({<span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'pg'</span></span>}), ]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [more, less] = users.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> b.karma - a.karma); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${more.id}</span></span></span><span class="hljs-string"> has more karma (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${more.karma}</span></span></span><span class="hljs-string">) than </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${less.id}</span></span></span><span class="hljs-string"> (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${less.karma}</span></span></span><span class="hljs-string">)`</span></span>); })();</code> </pre> <br>  It is worth noting that before using this method, it is necessary to make sure that the desired can be achieved by parallel execution of commands.  In many cases, asynchronous operations must be performed sequentially. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Hopefully, I was able to show you what great innovations the <code>async / await</code> construct has contributed to the development of asynchronous JavaScript code.  The ability to describe asynchronous constructions using the same syntax as synchronous is the standard of modern programming.  And the fact that now the same opportunity is available in JavaScript is a huge step forward for everyone who writes in this language. <br><br>  Dear readers!  We know from a survey from a previous publication that many of you use async / await.  Therefore, please share your experience. </div><p>Source: <a href="https://habr.com/ru/post/339770/">https://habr.com/ru/post/339770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339756/index.html">Non-satellite positioning and navigation systems</a></li>
<li><a href="../339758/index.html">IdM implementation. Part 1: What is IdM and what functionality does it apply to?</a></li>
<li><a href="../339760/index.html">[Translation] How I learned to program AI for the last two months</a></li>
<li><a href="../339762/index.html">DevOps now - like version control ten years ago, everyone will be there soon</a></li>
<li><a href="../339766/index.html">The book "Python for complex tasks: the science of data and machine learning"</a></li>
<li><a href="../339772/index.html">WeChat. Serialize the object - get SMS</a></li>
<li><a href="../339774/index.html">Memorize Less, Know More: Operator Tips</a></li>
<li><a href="../339782/index.html">Black triangles</a></li>
<li><a href="../339784/index.html">The relationship between the number of combinations and the binomial coefficients</a></li>
<li><a href="../339786/index.html">Like the others: Monitoring & Tracing Tools in Odnoklassniki</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>