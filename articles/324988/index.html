<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java implementation of a hashed binary tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One friend of mine likes to say (I don‚Äôt know if these are his words or he took them somewhere) that programmers go for two reasons: if you want to be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java implementation of a hashed binary tree</h1><div class="post__text post__text-html js-mediator-article">  One friend of mine likes to say (I don‚Äôt know if these are his words or he took them somewhere) that programmers go for two reasons: if you want to become a hacker or if you want to write games.  My second case.  Always interested in the development of games, and the part that is responsible for artificial intelligence in games.  I spent a lot of time studying path finding algorithms.  Implementing the next version of <a href="http://www.policyalmanac.org/games/aStarTutorial_rus.htm">the A * algorithm</a> in Java, I ran into an interesting situation related to the TreeSet and TreeMap collections. <br><a name="habracut"></a><br>  Just want to introduce two concepts that I will use throughout the article: a <i>search for equality</i> and a <i>search for comparison</i> .  I‚Äôll <i>search for equality</i> in a search in a collection where the <b>equals</b> and <b>hashCode</b> methods are used to compare elements.  <i>Search by comparison</i> or search based on the comparison I will call the search for an element in the collection, where the <b>compare</b> and <b>compareTo</b> methods are used to compare the elements. <br><br>  The A * algorithm uses two collections to store waypoints: <u>an open list</u> and a <u>closed list</u> .  The point of the path, roughly speaking, has three important attributes for us: the X coordinate, the Y coordinate, and the value of the metric function ‚Äî F. For a closed list, only two addition and search operations are needed.  With the open list, everything is somewhat more complicated.  With an open list, in addition to the operations of adding and searching for an element, you must also find the smallest point by the value of the metric function. <br><br>  For a closed list, choose <b>HashSet,</b> everything is obvious, for add and search operations, it is great, unless of course you have written a good hash function.  There are difficulties with choosing a collection for an open list.  If you select <b>HashSet</b> , as well as for the closed list, we get the best asymptotics for insert, search and delete operations - O (1), but the minimum search will be performed for O (n).  When choosing a <b>TreeSet</b> or <b>TreeMap,</b> we will have O (log (n)) to insert and search, but to find and delete the minimum we will have the same O (log (n)).  You can see the asymptotics of various collections <a href="https://habrahabr.ru/post/237043/">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another important detail associated with <b>TreeMap</b> and <b>TreeSet</b> is that all operations with these collections use comparisons.  Thus, if we are interested in the search taking into account the coordinates of the points, then to find the minimum we use the value of the metric function, and this will lead to the fact that the operation may not be performed for the point at which this value was changed.  Moreover, when inserting new values, we can get an incorrectly constructed tree: if we consider points with identical coordinates equal and take this into account in the comparator, then the insertion of a new value into the tree will not occur. <br><br>  It makes sense to use a collection based on a binary tree, since elements are not added to the open list as often, while the search for the minimum element by the value of the metric function is performed at each iteration of the search algorithm.  This is due to the fact that adding to an open list depends on the presence of a similar (by coordinates) element in a closed list, which grows over time and there are more and more points in it - the more points in a closed list, the less likely it is to add an element to an open list. list.  But I would also like to have the advantages of the <b>HashSet</b> collection. <br><br>  I decided to generalize the problem.  Let some data structure be defined in which there is a set of fields.  Let also some fields define the equivalence relation of two elements of a given structure, while other fields define order relations (in other words, the equals and hashCode methods use one object field, and the compare and compareTo methods use others). <br>  <i><b>Objective: to</b> implement a data structure in which the operation of searching for an element based on equality is performed with the asymptotics O (1), and the insertion and deletion operations worked taking into account operations and comparison and equality, and built a binary tree so that the smallest element would be the root .</i> <br><br>  Since for my purposes I need to store the points in the open list, taking into account their coordinates, I can uniquely determine the hash function based on the size of the permeability map so that there are no collisions in it, so I decided in the collection to set the maximum number of elements . <br><br><img src="https://habrastorage.org/files/63f/743/a2d/63f743a2d06f4c15ab2762bb261182f4.png" alt="image"><br><br>  The idea is very simple: we will place the elements of the collection into an array on the basis of hashing, and immediately place the same elements in a binary tree.  We need an inner class for packing items into tree nodes: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node parent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node left; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node right; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> V data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(V data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = data; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  <b>Type V</b> defines a collection element, it must extend the Comparable class so that you can perform a comparison to build a tree. <br><br>  In a class, in addition to pointers to the left and right descendant, there is a pointer to the ancestor.  This is done to optimize the process of removing an item from the tree - having the progenitor of the item to be deleted can be excluded from the tree-by-root removal algorithm, you can use an array of items to search.  A field named <b>k</b> contains the number of nodes in the subtree if they are not consecutively increasing nodes along the left descendant. <br><img src="https://habrastorage.org/files/911/2c7/db2/9112c7db2e16460eadf71e0dcb381ed8.png" alt="image"><br><br>  Inside the collection there should be a pointer to the root of the tree and an array of collection elements where null is stored in empty cells, and in the filled instances of the <b>Node</b> class, where the value of the added element (or more precisely, the value of the pointer to the object instance) will be stored in the <b>data</b> field: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashTree</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node root = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node[] nodes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HashTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node[capacity]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getElementHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E element)</span></span></span></span>; ‚Ä¶ }</code> </pre> <br>  Like type V, <b>type E</b> defines a collection element.  By default, the collection is empty, so the pointer to the root element is null and the array is also filled with <b>null</b> values.  An abstract class with the abstract <b>getElementHash</b> method that allows you to override the hash code calculation. <br><br>  Now to the methods.  <b>AddElement</b> method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = getElementHash(element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodes[index] != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Node&lt;E&gt; node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node&lt;&gt;(element); nodes[index] = node; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = connectNodes(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root, node); }</code> </pre> <br>  In the method we get the hash code of the added element.  Create a new tree node with a new element as data and add it to the tree and to the array, where the hash code defines the index in the array.  The insertion of an element into an array has the asymptotics O (1), the insertion into the tree is O (log (n)), the total asymptotics is O (log (n)). <br><br>  <b>RemoveElement</b> method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = getElementHash(element); Node node = nodes[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } nodes[index] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; E data = (E) node.data; Node l = getElemInArray(node.left); Node r = getElemInArray(node.right); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { l.parent = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { r.parent = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } l = connectNodes(l, r); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.parent == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root.parent = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = getElementHash((E) node.parent.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodes[p] != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {<span class="hljs-comment"><span class="hljs-comment">//    , //   ,    if (nodes[p].left == node) { nodes[p].left = null; } if (nodes[p].right == node) { nodes[p].right = null; } } connectNodes(nodes[p], l); return data; }</span></span></code> </pre> <br>  Here, using the hash code of the element to be deleted, the tree node to be deleted is extracted from the array.  Using the ancestor of the node to be deleted, we perform the removal of the element, during which we have to cause subtree binding 2 times, each of the operations in the worst case has asymptotics - O (log (n)).  As a result, the method has the asymptotics O (log (n)). <br><br>  The <b>connectNodes</b> method performs the join of both a single node and a subtree.  Moreover, the binding occurs with the use of comparison.  Thus, at the top of the tree is always the smallest element. <br><br>  <b>ConnectNodes</b> method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Node </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectNodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node parent, Node node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parent; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare(node, parent) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectNodes(node, parent); } Node cur = parent; Node n = node; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cur != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { cur.left = n; n.parent = cur; cur.k++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare(n, cur.left) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cur.right = cur.left; cur.left = n; n.parent = cur; cur.k++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cur.right = n; n.parent = cur; cur.k++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare(n, cur.left) &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Node tmp = cur.left; cur.left = n; n.parent = cur; cur.k++; cur = n; n = tmp; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare(n, cur.right) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; compare(n, cur.left) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cur.k++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.right.k &lt; cur.left.k) { Node tmp = cur.right; cur.right = n; n.parent = cur; cur = n; n = tmp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cur = cur.left; } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compare(n, cur.left) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cur.k++; cur = cur.left.k &lt; cur.right.k ? cur.left : cur.right; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parent; }</code> </pre> <br>  The <b>connectNodes method</b> should be given special attention.  Adding a new element is performed using this method in relation to the root and the new element.  We assume that the tree is not empty: <br><img src="https://habrastorage.org/files/65b/07e/457/65b07e457614475b9e9b9262e0deccc8.png" alt="image"><br><br>  Perhaps 4 cases: <br><ol><li>  new element is smaller than the root; </li><li>  A new element is smaller than the left child; </li><li>  A new element is larger than the left child, but smaller than the right element. </li><li>  new item more right descendant. </li></ol><br><br>  <b>Case 1.</b> <br>  In this situation, parent becomes the left descendant of the new element, if parent is the root of the tree, then the new, added element will be the new root. <br><img src="https://habrastorage.org/files/cb7/7f8/b5f/cb77f8b5fa314395a741b9257d87e246.png" alt="image"><br><br>  <b>Case 2.</b> <br>  There are two possible options: the right descendant is defined and the right descendant is not defined.  If the left descendant is not defined, then we consider that the left descendant has more significance the new node.  In both situations, the new element becomes the left descendant of parent, and the left (which was the left descendant before adding) becomes the right descendant.  However, in the second case, you must attach the old right descendant right to the new right descendant left.  Joining left to right will occur according to the same rules as in the cases described. <br><img src="https://habrastorage.org/files/b19/4d2/05c/b194d205c38846fbbd1b23edc26e6d87.png" alt="image"><br><br>  <b>Case 3.</b> <br>  In this case, either a transition is performed on the left subtree and a new node is added to it, if there are fewer nodes in it than in the right subtree, or the right subtree is replaced by the inserted node and the right subtree is added to it. <br><img src="https://habrastorage.org/files/8b1/743/697/8b17436970c44456a8c445bd683cea44.png" alt="image"><br><br>  <b>Case 4.</b> <br>  In this case, a transition is performed on the subtree in which there are the least nodes.  The number of nodes accumulates in the k field. <br><img src="https://habrastorage.org/files/e78/1b8/c98/e781b8c989dc4368aaa02ac3a0593bd8.png" alt="image"><br><br>  Now we estimate the asymptotics of the <b>connectNodes</b> method.  In the best case, when nodes without descendants are added to the tree in decreasing order, the asymptotics will be equal to O (1), since in this case put the new element in the place of the progenitor.  If we are talking about tying a node with descendants and a smaller one than the progenitor, then we will need to go through the node's subtree.  For case 2 in paragraph <i><b>a), the</b></i> asymptotics is O (1), and in point <i><b>b)</b></i> one must again go through the subtree of the inserted node. <br>  Note that the field <b>k</b> at the nodes increases for all cases except the 1st, this is done to fill the tree symmetrically, but not violating the increasing order in the left subtree if it meets. <br><br>  To assess the difficulty of walking through a tree, it is enough to estimate its height.  The height of the tree will be the desired asymptotics.  A separate issue is the presence of a length sequence on the left subtree.  Considering the presence of such subtrees, in the worst case, the asymptotic behavior of the binding can be considered as the asymptotic behavior of the binding to the subtree that we want to bind, and at best, as O (1) (2 case). <br><img src="https://habrastorage.org/files/14a/d2e/c4a/14ad2ec4a7fb4727851ac2315901c1d9.png" alt="image"><br><br>  Since when we connect nodes we deal with nodes inside a tree, it means that the height of any subtree can be considered as not exceeding the height of the tree itself.  Thus, estimating the height of the entire binary tree, we obtain the asymptotics of the connectNodes method.  Due to the fact that the selection of a subtree for insertion is chosen based on the node's <b>k</b> field (in which the subtree size is stored, except for successive increasing nodes, they are counted as one node), the tree tends to fill its next level only after filling the previous one (excluding, of course, the above case 1).  Thus, the tree will look like: <br><img src="https://habrastorage.org/files/6a2/cd0/bfb/6a2cd0bfbd0b4403907f3313ae979530.png" alt="image"><br><br>  Thus, if n is the number of nodes in the tree, then <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>h</mi></msubsup><msup><mn>2</mn><mi>i</mi></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.397ex" height="3.142ex" viewBox="0 -935.7 6198.6 1352.7" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-3D" x="878" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-73" x="2184" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-75" x="2654" y="0"></use><g transform="translate(3226,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-68" x="1242" y="499"></use><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-30" x="1124" y="0"></use></g></g><g transform="translate(5353,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-69" x="707" y="557"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>h</mi></msubsup><msup><mn>2</mn><mi>i</mi></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> n = \ sum_ {i = 0} ^ h 2 ^ i </script>  .  From which it follows that the height of the tree <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>h</mi><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn></mrow></msub><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.212ex" height="2.66ex" viewBox="0 -832 8702.4 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-68" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-3D" x="854" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-6C" x="2160" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-6F" x="2459" y="0"></use><g transform="translate(2944,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-67" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-32" x="675" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-28" x="3875" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMATHI-6E" x="4265" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-2B" x="5088" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-31" x="6088" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-29" x="6589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-2212" x="7201" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/324988/&amp;xid=17259,15700023,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhhHQSnPUv6TZovkTS0mdqAIE-jlAA#MJMAIN-31" x="8201" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>h</mi><mo>=</mo><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>‚àí</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> h = \ log_ {2} (n + 1) - 1 </script>  .  It follows that the asymptotics of the <b>connectNodes</b> method is O (log (n)). <br><br>  You can search for an element not in the tree, but in an array based on the hash code, so the search operation has the asymptotics O (1).  And since the tree is organized as a binary, the minimum element is always at the root of the comparison and the asymptotics of the minimum search - O (1).  I note that the removal of the minimum element has the asymptotic behavior of O (log (n)), since during the removal it is required to reorganize the tree, starting from the root using the <b>connectNodes</b> method. <br><br>  At first glance, the operation of deleting the minimum element in the implemented collection has a worse asymptotics than the <b>HashSet</b> collection, but do not forget that before removing the minimum element, you must first find it, and this requires performing operations with the asymptotics O (n).  Thus, the final asymptotics of the operation of deleting the minimum element in the HashSet collection will be O (n). <br><br>  Checking the presence of an element in the collection, as mentioned above, is performed on the basis of checking for an array element <b>null</b> by its index determined by the hash code of the element.  Verification is performed with the <b>contains</b> method and has the asymptotics O (1): <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = getElementHash(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodes[index] != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Also, based on the hash code, an equality search is performed with the same asymptotics using the <b>getElement</b> method: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (E) nodes[getElementHash(element)].data; }</code> </pre> <br>  The realized collection is not without flaws.  It requires more memory, it needs a hash function without collisions, and to implement the iteration of the elements, it is necessary to implement a tree walk, which is also not fun, but this collection is intended for other purposes.  The main advantage is the ability to search for elements of the same type according to different criteria with the best asymptotics.  As applied to my task, it was a search for equality based on the coordinates and a search for the minimum element based on a comparison of the values ‚Äã‚Äãof the metric function. <br><br>  In the end, I‚Äôll give the results of testing the collection for speed compared to the <b>LinkedHashMap</b> , <b>TreeSet</b> and <b>HashSet</b> collections.  All collections were filled with 1000 values ‚Äã‚Äãof type <b>Integer</b> and, with the collections filled, the following operations were performed: <br><ol><li>  placing a new item in the collection; </li><li>  checking for the presence in the collection of an element with a specified value (the check was performed twice for an element that was in the collection and for an element that was not in the collection); </li><li>  search and delete is minimal by comparing the item; </li><li>  deletion added in item 1 of the item. </li></ol><br>  The test results are shown in the table: <br><table><thead><tr><th>  Collection </th><th>  Number of repetitions </th><th>  Time spent </th></tr></thead><tbody><tr><td>  LinkedHashMap </td><td>  10,000,000 </td><td>  1985 ¬± 90 ms </td></tr><tr><td>  Treeset </td><td>  10,000,000 </td><td>  1190 ¬± 25 ms </td></tr><tr><td>  Hashset </td><td>  1,000,000 </td><td>  4350 ¬± 100 ms </td></tr><tr><td>  Hashtree </td><td>  10,000,000 </td><td>  935 ¬± 25 ms </td></tr></tbody></table><br>  As a result, we have more than 2 times the speed of the <b>HashTree</b> collection compared to <b>LinkedHashMap</b> and 1.27 times <b>faster</b> than the <b>TreeSet</b> (there is no sense in considering <b>HashSet</b> at all).  The checks were performed on a machine with 4GB of RAM and an AMD Phenom (tm) II X4 940 processor, the OS is 32-bit Windows7 Professional. </div><p>Source: <a href="https://habr.com/ru/post/324988/">https://habr.com/ru/post/324988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324978/index.html">Cones stuffed with 15 years of using actors in C ++. Part II</a></li>
<li><a href="../324980/index.html">Webinar "Testing applications for vulnerabilities. The practice of building SDLC</a></li>
<li><a href="../324982/index.html">First experience with Google API (for example, ContactsAPI) and OAuth2.0 on pure HTTP</a></li>
<li><a href="../324984/index.html">Basic concepts of the chrono library (C ++)</a></li>
<li><a href="../324986/index.html">Calculation of the correcting FIR filter on the FPGA</a></li>
<li><a href="../324990/index.html">Advantages of SDN: on the example of VMware vSphere integration with Huawei Cloud Fabric</a></li>
<li><a href="../324992/index.html">How to create an Internet of things from LEGO bricks based on AWS IoT platform</a></li>
<li><a href="../324994/index.html">Native Data Centers: Overview of Russian Data Centers (Part 1)</a></li>
<li><a href="../324996/index.html">Relevant connection - specific and universal attributes</a></li>
<li><a href="../324998/index.html">Clustering text documents according to semantic features (part two: model description)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>