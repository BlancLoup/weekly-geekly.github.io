<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of load scripts for browser / mobile games. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr. In the last article I talked about automating the process of load testing in the game company where I work. Now it's time to stop at some sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of load scripts for browser / mobile games. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr.  In the <a href="https://habr.com/post/342380/">last</a> article I talked about automating the process of load testing in the game company where I work.  Now it's time to stop at some specific tasks that we had to face in preparation for the testing process of the games themselves. <br><br>  There is a big difference between testing different banking / retail processes and games.  In the first case, users perform their tasks almost in isolation from each other and use only those data and elements that they see in the window of their browsers or other clients at the moment, which facilitates the development of load scripts.  In games, users (players) are in a dynamically changing world and are often influenced by each other.  In my imagination, the difference looks like this: <br><br><img src="https://habrastorage.org/webt/-v/nb/vq/-vnbvquw4dtis1phixarblwhiyg.png"><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      That is, in the first case, users, through a series of similar actions, arrive at the final result and go to the next round.  The game is a random chaos in the center of which is the game world, on which players constantly influence, change the in-game data, exerting a direct influence both on themselves and on other players.  Also, players can chat, unite in guilds and hack PvP. <br><br>  Thus, when developing load scripts, one has to reckon with a variety of conditions, dynamic data, and so on.  It seems to me that people who create bots for different online games should be engaged in something similar in order to automate certain tasks of the same type.  But in our tests we try to implement all the game activities. <br><br><h3>  Relevant data problem </h3><br>  When developing scripts for emulating banking business processes, scripts (usually) <br>  rely on data that they ‚Äúsee‚Äù at a specific stage (on a web page for example).  That is, to proceed to the next step, it is only necessary to pack the previously prepared (or taken from the same page) data into the right places and send them. <br><br>  One of the main problems in the development of scripts for the game is the complexity of tracking (tracking) changes that occurred before this particular moment, before executing the command.  Information about the changed state of objects, resources, units, etc. can come at any time, even after performing non-specific actions.  If you skip this update, the virtual user (VU, thread in Jmeter) will be out of sync with the game and start generating errors ala ‚Äúnot enough resources‚Äù or ‚Äúno place on the map‚Äù and turn the load test into something useless.  Of course, there is always the likelihood that the script will still produce something like ‚Äúyou can‚Äôt attack an ally‚Äù if it became such a second ago, but the same will happen in a real client. <br><br>  Also complicating life is the fact that almost always all the source data and the current state of affairs in the game world come to the client only when logged into the game (usually a huge JSON of several megabytes) and then the client proceeds from these initial data and passing changes in the relevant state, that is, he knows about the current state of affairs.  The same should be implemented in the script, it is necessary that each VU ‚Äúremembers‚Äù that the game sends at the login stage and then accurately transfer and modify this data during the test.  The following is an example of how I solved the problem with one of the games of the company InnoGames. <br><br><h3>  Forge of Empires </h3><br>  (I hope this will not be reckoned for advertising, I need to describe the essence of the problem and the solution, but I cannot without a brief description of the game itself) <br><br>  This is a town-planning simulator in which a player starts from the Stone Age and gradually, developing technologies, conquering provinces, fighting with other players, promotes and expands his city to ... endgame, which is very far away. <br><br>  A newly registered player after login sees something like the following: an empty field and one main large building (GZ), a couple of trees and roads on it: <br><img src="https://habrastorage.org/webt/rk/cc/9d/rkcc9dy_n1ugr6grgbofsne5wom.png" alt="image"><br><br>  The unoccupied field itself and the objects are divided into squares, depending on the size you have to reckon with the size of the building itself and the free space on the map.  Buildings are divided into types: residential, industrial, military, cultural, roads, and more.  Different buildings produce different resources: residential - people and money, production - goods and resources, cultural - happiness and so on.  When building each building, it is necessary to take into account the same resources, and if they are not enough, you must either wait, or, for example, build a new house to fill the population.  Feel where I am getting at?  These are not accounting entries to emulate :) <br><br><h3>  Building </h3><br>  In the town-planning simulator, the main business process (let's call it that) is the construction itself.  This is the first and main problem when creating scripts for games of this kind.  The problem of building a building is divided into several subtasks that need to be addressed simultaneously: <br><br><ol><li>  Understand the size of the building and find free time on the map under it </li><li>  (Pre-verify available resources) </li><li>  <b>A new building must be connected to the main one through the road, otherwise it will be useless.</b> </li><li>  It is necessary to diversify the load, that is, we do not have to shove the same building every time, but build diverse ones in order to produce different resources, including units. </li></ol><br>  Point number 3 especially scared me, the need to use some complex algorithms came to my head, which is particularly unrealistic in terms of testing with Jmeter and several thousand VU.  It is necessary to use as simple as possible algorithms and structures, otherwise the question about the hardware of the load generators themselves will be a stake. <br><br>  After a few hours of thinking, the idea of ‚Äã‚Äãa simple algorithm came up; I called it ‚Äúconstruction by layers‚Äù.  Its essence is as follows.  As you can see in the screenshot above, the GZ is pressed to the edge of the map beyond which you cannot build anything and it played into the hands.  Each VU after login first of all builds a road along the contour of the map and the main building, and only then builds the necessary buildings, along this road, while there is space.  Thus, all buildings built along the road will be connected to the GZ.  Next, we build the next ‚Äúlayer‚Äù of the road along the contour of the constructed buildings.  Thus, we build the original road based on the condition: for example, if the border of the map is to the left, empty to the right, and something is above or below the checked square, then we can probably build a road. <br><br>  Something like this (green square - GZ, yellow - road, black - any building): <br><br><img src="https://habrastorage.org/webt/nx/b2/3j/nxb23jxgik6kvvbit5opdjkzv3i.gif"><br><br><h3>  Go </h3><br>  Since this game communicates with the client exclusively via http with JSON, I use the additional <a href="https://mvnrepository.com/artifact/org.json/json/20180130">org.json</a> library in <a href="https://mvnrepository.com/artifact/org.json/json/20180130">Jmeter</a> to work and parse requests / responses in the <b>post and pre processors</b> . <br><br>  First of all, as I mentioned above, you need to correctly parse and save all the necessary initial data during login, when performing actions that initialize the user session.  Regarding this game - this is the only time when we can find out and remember how our city looks at the moment, our resources, as well as all the necessary meta-information about the cost of buildings, units, goods that we need afterwards. <br><br>  To simplify the code afterwards and reduce memory consumption by each java-thread, we save only the ones we use from the entire data set, so we first need to create and connect two simple auxiliary classes Entity and ExistEntity - the first is responsible for any building available in the game in principle ( with cost, size, functions and other), and the second for the already built in the city (with coordinates). <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Entity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String id; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String type; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Integer width; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Integer length; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Integer money; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Integer supplies; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Integer population; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String tech_id; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String demand_for_happiness; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String provided_happiness; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String era; ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExistEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String id; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String cityentity_id; <span class="hljs-comment"><span class="hljs-comment">//   Entity protected String type; protected Integer x; protected Integer y; ‚Ä¶ }</span></span></code> </pre> <br>  The first POST request, <b>StaticData_getData,</b> returns a huge JSON weighing 1-2 megabytes.  Let's parse it, create a structure, for example, HashMap and fill it with Entity objects with id keys, to subsequently refer to this hash map for information about each specific building: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json.JSONArray; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json.JSONObject; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.innogames.jmeter.foe.Entity; JSONArray responseData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONArray(prev.getResponseDataAsString()); Map allBuildings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-comment"><span class="hljs-comment">//      Map availableBuildings = new HashMap(); // ,    () JSONArray buildings = responseData.getJSONObject("responseData").getJSONArray("buildings"); for (int i = 0; i &lt; buildings.length(); i++) { JSONObject building = buildings.getJSONObject(i); String id = building.getString("id"); String type = building.getString("type"); String name = building.getString("name"); //  : Integer width = (building.has("width")) ? building.getInt("width") : 0; Integer length = (building.has("length")) ? building.getInt("length") : 0; //    : JSONObject requirements = building.getJSONObject("requirements"); Integer money = (requirements.getJSONObject("resources").has("money")) ? requirements.getJSONObject("resources").get("money") : 0; .... //         : String min_era = requirements.getString("min_era"); String tech_id = (requirements.has("tech_id") &amp;&amp; (!requirements.isNull("tech_id"))) ? requirements.getString("tech_id") : null; Integer provided_happiness = (building.has("provided_happiness") &amp;&amp; (!building.isNull("provided_happiness"))) ? building.getInt("provided_happiness") : 0; //        Entity e = new Entity(id, type, min_era, width, length, money, supplies, population, tech_id, provided_happiness ); allBuildings.put(e.getId(), e); // ,      .... if (e.getEraRank() &lt;= userEraRank &amp;&amp; tech_researched == true) { availableBuildings.put(e.getId(), e); } } } //   -   ,     vars.putObject("availableBuildings", availableBuildings); vars.putObject("allBuildings", allBuildings);</span></span></code> </pre><br>  Now every virtual user knows all the necessary information about the buildings.  Next, you need to "remember" the territory, its size and current location of buildings in the city itself.  I also used HashMap, which uses <b>java.awt.Point</b> class objects with X, Y coordinates as keys and String values ‚Äã‚Äãwith the name of the building type in this coordinate. <br><br>  The territory of the city itself is not a square, but consists of a set of open areas, 4x4 in size, so initially we fill this hash map with zeros in all coordinates that are open and accessible to the user.  In addition, we need to use the data from the previous step, since  we only get the building coordinates from this query, must also ‚Äúfill in‚Äù other coordinates, based on the width and height of the building. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json.JSONArray; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json.JSONObject; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.innogames.jmeter.foe.Entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.innogames.jmeter.foe.ExistEntity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.Point; Integer maxBuildingId = <span class="hljs-number"><span class="hljs-number">0</span></span>; JSONArray responseData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONArray(prev.getResponseDataAsString()); Map allBuildings = vars.getObject(<span class="hljs-string"><span class="hljs-string">"allBuildings"</span></span>); Map cityTerritory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-comment"><span class="hljs-comment">//      //            JSONArray entities = unlocked_areas.getJSONObject("responseData").getJSONArray("unlocked_areas"); for (int i = 0; i &lt; unlocked_areas.length(); i++) { Integer x = (unlocked_areas.getJSONObject(i).has("x")) ? unlocked_areas.getJSONObject(i).getInt("x") : 0; Integer y = (unlocked_areas.getJSONObject(i).has("y")) ? unlocked_areas.getJSONObject(i).getInt("y") : 0; Integer width_ = (unlocked_areas.getJSONObject(i).has("width")) ? unlocked_areas.getJSONObject(i).getInt("width") : 0; Integer length_ = (unlocked_areas.getJSONObject(i).has("length")) ? unlocked_areas.getJSONObject(i).getInt("length") : 0; for (Integer xx = x; xx &lt;= x + width_ - 1; xx++) { for (Integer yy = y; yy &lt;= y + length_ - 1; yy++) { p = new Point(xx, yy); cityTerritory.put(p, "0"); } } } //  ""       JSONArray entities = responseData.getJSONObject("responseData").getJSONArray("buildings"); for (int i = 0; i &lt; entities.length(); i++) { Integer id = entities.getJSONObject(i).getInt("id"); String cityentity_id = entities.getJSONObject(i).getString("cityentity_id"); String type = entities.getJSONObject(i).getString("type"); int x = (entities.getJSONObject(i).has("x")) ? entities.getJSONObject(i).getInt("x") : 0; int y = (entities.getJSONObject(i).has("y")) ? entities.getJSONObject(i).getInt("y") : 0; ExistEntity ee = new ExistEntity(String.valueOf(id), cityentity_id, type, x, y); if (id &gt;= maxBuildingId) maxBuildingId = id; Entity e = allBuildings.get(cityentity_id); for (int xx = x; xx &lt;= x + e.getWidth() - 1; xx++) { for (int yy = y; yy &lt;= y + e.getLength() - 1; yy++) { cityTerritory.put(new Point(xx, yy), e.getType()); } } } //      ,      vars.putObject("cityTerritory", cityTerritory);</span></span></code> </pre><br>  With the help of vars.putObject () now each thread (VU) will know all the necessary information, it remains only to update these objects in time at each stage of the script if the game sends the corresponding data. <br><br><h3>  Build </h3><br>  Now, knowing the cost, size of buildings, as well as the current location of objects in the virtual city, you can begin to build new buildings.  The first step, as I wrote earlier, is the first ‚Äúlayer‚Äù of the road along the contour of the map so that all subsequent buildings have a connection with the main one. <br><br>  Add the Sampler <b>jsr223 pre-processor</b> to the HTTP and form the request.  We go through each square, look for an empty one and the one surrounded by at least one (out of 8) occupied by another object (including the border) is a square.  Thus, we will ‚Äúcircle‚Äù any expensive object, including the border of the territory (there is a lot of room for optimizations, I hope someone will suggest a better algorithm): <br><br><pre> <code class="java hljs">... Map cityTerritory = vars.getObject(<span class="hljs-string"><span class="hljs-string">"cityTerritory"</span></span>); Map availableBuildings = vars.getObject(<span class="hljs-string"><span class="hljs-string">"availableBuildings"</span></span>); Integer maxBuildingId = Integer.valueOf(vars.get(<span class="hljs-string"><span class="hljs-string">"maxBuildingId"</span></span>)); Iterator cityTerritory = map.entrySet().iterator(); <span class="hljs-comment"><span class="hljs-comment">//    while (it.hasNext()) Map.Entry entry = (Map.Entry) it.next(); Point key = (Point) entry.getKey(); String value = (String) entry.getValue(); key_x = (int) key.x; key_y = (int) key.y; if (value.equals("0")) { //       ( )   if (map.containsKey(new Point(key_x, key_y - 1))) a = map.get(new Point(key_x, key_y - 1)); else a = "-1"; if (map.containsKey(new Point(key_x - 1, key_y - 1))) b = map.get(new Point(key_x - 1, key_y - 1)); else b = "-1"; if (map.containsKey(new Point(key_x + 1, key_y))) c = map.get(new Point(key_x + 1, key_y)); else c = "-1"; if (map.containsKey(new Point(key_x - 1, key_y))) d = map.get(new Point(key_x - 1, key_y)); else d = "-1"; if (map.containsKey(new Point(key_x, key_y + 1))) e = map.get(new Point(key_x, key_y + 1)); else e = "-1"; if (map.containsKey(new Point(key_x - 1, key_y + 1))) f = map.get(new Point(key_x - 1, key_y + 1)); else f = "-1"; if (map.containsKey(new Point(key_x + 1, key_y - 1))) g = map.get(new Point(key_x + 1, key_y - 1)); else g = "-1"; if (map.containsKey(new Point(key_x + 1, key_y - 1))) h = map.get(new Point(key_x + 1, key_y - 1)); else h = "-1"; //        ( ) if ((!a.equals("0") &amp;&amp; !a.equals("street")) || (!b.equals("0") &amp;&amp; !b.equals("street")) || (!d.equals("0") &amp;&amp; !d.equals("street")) || (!c.equals("0") &amp;&amp; !c.equals("street")) || (!e.equals("0") &amp;&amp; !e.equals("street")) || (!f.equals("0") &amp;&amp; !f.equals("street")) || (!g.equals("0") &amp;&amp; !g.equals("street"))) { //      maxBuildingId = maxBuildingId + 1; vars.put("maxBuildingId", String.valueOf(maxBuildingId)); x = String.valueOf(key_x); y = String.valueOf(key_y); ...... } } }</span></span></code> </pre><br>  Next we need to build the building itself.  Suppose now it does not matter what we are, only its size is important to us.  Correspondingly, we search for an coordinate on an imaginary map from which there are empty squares at a distance of the width of the building along the X axis and the height of the building along the Y axis, and there is a road in one of the eight squares in the corners of the building (I really check the top 4, thus filling the city goes from top to bottom): <br><br><img src="https://habrastorage.org/webt/k6/9u/i8/k69ui8uvw4kbenuqllqqmtm4xvs.png"><br><br>  It is also necessary to make sure that throughout the desired territory of the future building there will not be any object (wood for example) <br><br><pre> <code class="java hljs">Iterator it = cityTerritory.entrySet().iterator(); Integer checkSizeW = targetBuilding.getWidth() - <span class="hljs-number"><span class="hljs-number">1</span></span>; Integer checkSizeL = targetBuilding.getLength() - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    while (it.hasNext()) { Map.Entry entry = (Map.Entry) entries.next(); Point key = (Point) entry.getKey(); String value = (String) entry.getValue(); if (value.equals("0")) { //    ,    //   ,       ,       4-   : if ((cityTerritory.containsKey(new Point(key.x - 1, key.y - 1)) &amp;&amp; cityTerritory.containsKey(new Point(key.x - 1, key.y)) &amp;&amp; cityTerritory.containsKey(new Point(key.x, key.y - 1)) &amp;&amp; cityTerritory.containsKey(new Point(key.x - 1, key.y + checkSizeL)) &amp;&amp; cityTerritory.containsKey(new Point(key.x + checkSizeW, key.y - 1)) &amp;&amp; cityTerritory.containsKey(new Point(key.x + checkSizeW, key.y + checkSizeL))) &amp;&amp; (cityTerritory.get(new Point(key.x - 1, key.y)).equals("street") || cityTerritory.get(new Point(key.x, key.y - 1)).equals("street") || cityTerritory.get(new Point(key.x - 1, key.y + checkSizeL)).equals("street") || cityTerritory.get(new Point(key.x + checkSizeW, key.y - 1)).equals("street")) ) { boolean isFree = true; //  ,            : for (int W = 0; W &lt;= checkSizeW; W++) { for (int L = 0; L &lt;= checkSizeL; L++) { if (!map.containsKey(new Point(key.x + W, key.y + L))) { sFree = false; } else { if (!map.get(new Point(key.x + W, key.y + L)).equals("0")) { isFree = false; } } } } if (isFree) { //   } } } } }</span></span></code> </pre><br>  At the very top level of the Jmeter test plan, we add a <b>Post-processor</b> that will respond to each incoming response from the game, parse it and update the objects, since we need to track resource changes and also update the virtual map with new buildings: <br><br><pre> <code class="java hljs">JSONArray responseData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSONArray(response); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; responseData.length(); m++) { <span class="hljs-comment"><span class="hljs-comment">//       : if (responseData.getJSONObject(m).getString("requestClass").equals("CityMapService")) { JSONArray city_map_entities = responseData.getJSONObject(m).getJSONArray("responseData"); for (int i = 0; i &lt; city_map_entities.length(); i++) { JSONObject city_map_entity = city_map_entitis.get(i); if (city_map_entity.toString().contains("CityMapEntity")) { Integer id = city_map_entity..getInt("id"); String cityentity_id = city_map_entity..getString("cityentity_id"); String type = city_map_entity..getString("type"); Integer x = (city_map_entity..has("x")) ? city_map_entity..getInt("x") : 0; Integer y = (city_map_entity..has("y")) ? city_map_entity..getInt("y") : 0; Entity e = availableBuildings.get(cityentity_id); if (id &gt;= maxBuildingId) maxBuildingId = id; for (int xx = x; xx &lt;= x + e.getWidth() - 1; xx++) { for (int yy = y; yy &lt;= y + e.getLength() - 1; yy++) { cityTerritory.put(new Point(xx, yy), e.getType()); } } } } //        else if (responseData.getJSONObject(m).getString("requestClass").equals("ResourceService") &amp;&amp; responseData.getJSONObject(m).getString("requestMethod").equals("getPlayerResources")) { JSONObject resources = responseData.getJSONObject(m).getJSONObject("responseData").getJSONObject("resources"); vars.putObject("resources", resources); Integer money = (resources.has("money")) ? resources.getInt("money") : 0; Integer supplies = (resources.has("supplies")) ? resources.getInt("supplies") : 0; Integer population = (resources.has("population")) ? resources.getInt("population") : 0; Integer strategy_points = (resources.has("strategy_points")) ? resources.getInt("strategy_points") : 0; vars.put("money", String.valueOf(money)); vars.put("supplies", String.valueOf(supplies)); vars.put("population", String.valueOf(population)); vars.put("strategy_points", String.valueOf(strategy_points)); } }</span></span></code> </pre><br><h3>  Total </h3><br>  After a total of one 12-hour load test, you can see a really built city with various buildings that are connected to the main building, which means that they are functioning quite well: <br><img src="https://habrastorage.org/webt/su/fl/w9/suflw9ffacsbt2om6ndzjqqjv4c.png"><br><br>  Thank you for your attention, I decided not to dump everything in a pile and break the topic into several parts.  The next part will be devoted to solving the same problem, but in more severe conditions, when the game client uses the HTTP protocol with protobuf, and receives updates via a web socket with STOMP. <br><br>  Leave a link to our <a href="https://github.com/innogames">githab</a> , can find something interesting. <br><br>  Good luck and relevant tests. </div><p>Source: <a href="https://habr.com/ru/post/354348/">https://habr.com/ru/post/354348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354338/index.html">Miners will not pass</a></li>
<li><a href="../354340/index.html">We increase the disk mass without steroids. Overview of the Western Digital Ultrastar Data102 102 Disk Shelf and Storage Configuration</a></li>
<li><a href="../354342/index.html">Internship for atypical programmers</a></li>
<li><a href="../354344/index.html">Quest to eliminate heart arrhythmia</a></li>
<li><a href="../354346/index.html">HR Meetup. How to survive the explosive growth of the IT team</a></li>
<li><a href="../354350/index.html">Elastic opens X-Pack source code</a></li>
<li><a href="../354354/index.html">Event digest for HR-specialists in the field of IT for May 2018</a></li>
<li><a href="../354356/index.html">Marvin Minsky "The Emotion Machine": Chapter 1: Representing the Mind as a Cloud of Resources</a></li>
<li><a href="../354358/index.html">Marvin Minsky "The Emotion Machine": Chapter 1 "Adult Emotions"</a></li>
<li><a href="../354362/index.html">New chips to manage applications in hybrid cloud environments, or what Citrix NetScaler MAS 12.0 can do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>