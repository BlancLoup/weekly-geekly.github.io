<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why it is worth switching completely to Ceylon or Kotlin (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, Kotlin has been gaining active popularity. And what if you try to choose more exotic languages ‚Äã‚Äãand apply the same arguments to them? The a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why it is worth switching completely to Ceylon or Kotlin (part 1)</h1><div class="post__text post__text-html js-mediator-article"><p>  Recently, Kotlin has been gaining active popularity.  And what if you try to choose more exotic languages ‚Äã‚Äãand apply the same arguments to them?  The article was written based on <a href="https://habrahabr.ru/company/mailru/blog/329294/">this</a> , almost repeating all the arguments for Kotlin.  The main task: to show that Ceylon can almost the same as Kotlin, with reference to Java.  But apart from that, Ceylon has something else that will be described in the next article. </p><br><p>  I want to talk about a new programming language called Ceylon and explain why you should use it in your next project.  I used to write in Java (long and long, over 10 years, starting with Java 1.4 and ending with Java 8), and I liked Java.  Then Scala made a big impression on me, as a result of which Java as a language began to love somewhat less.  But fate brought me to the language of Ceylon, and in the last year and a half we write on Ceylon wherever possible.  In real commercial projects, the truth is internal.  And at the moment I can‚Äôt imagine a situation in which it would be better to choose Java, I don‚Äôt see Java as the language in which to start new projects. </p><br><p>  Ceylon is developed in Red Hat, the author of the language is Gavin King, known for such a framework as Hibernate.  It was created by people who understand Java flaws well, the main goal was to solve purely applied problems, to ensure the easiest readability of the code, to avoid any ambiguities and pitfalls, the foremost thing was the predictability and structural beauty of the language.  Much attention was also paid to acceptable compile times.  Currently, the language version is 1.3.2, I immediately became acquainted with the language when version 1.2.0 was released. </p><br><p>  Although Ceylon is compiled into JavaScript, I will focus on its primary environment, the JVM. </p><br><p>  So, there are several reasons why you should completely switch to Ceylon (the order coincides with the items of the same name in the corresponding Kotlin article): </p><a name="habracut"></a><br><p>  <strong>0 # Java Compatibility</strong> </p><br><p>  Like Kotlin, like Scala, Ceylon is 100% compatible with Java.  You can literally continue to work on your old Java project, but already using Ceylon.  All Java frameworks will also be available, and, whatever framework you write, Ceylon will be easily accepted by a stubborn Java lover.  You can call code from Java without problems, Java code is also called without problems. </p><br><p>  <strong>1 # Familiar syntax</strong> </p><br><p>  One of the main features of Ceylon is the most convenient syntax for existing developers.  If you take an existing Java developer, then with the understanding of Ceylon syntax, it will not have the slightest problem.  Even languages ‚Äã‚Äãlike Scala and Kotlin will be less similar to Java.  Below is a code showing a significant number of language constructions, similar to the Kotlin example: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Foo(String a) { String b= "b"; // unmodifiable variable <span class="hljs-type"><span class="hljs-type">Integer</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; // variable means modifiable <span class="hljs-type"><span class="hljs-type">void</span></span> hello() { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> str = "Hello"; print("``str`` World"); } <span class="hljs-type"><span class="hljs-type">Integer</span></span> sum(<span class="hljs-type"><span class="hljs-type">Integer</span></span> x, <span class="hljs-type"><span class="hljs-type">Integer</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-type"><span class="hljs-type">Float</span></span> maxOf(<span class="hljs-type"><span class="hljs-type">Float</span></span> a, <span class="hljs-type"><span class="hljs-type">Float</span></span> b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> b }</code> </pre> <br><p>  Accordingly, you can continue to write without problems in Java style on Ceylon. </p><br><p>  <strong>2 # Interpolation of lines</strong> </p><br><p>  This is a smarter and more readable version of String.format () from Java, embedded in the language: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> x = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> y = <span class="hljs-number"><span class="hljs-number">7</span></span>; print("sum of ``x`` and ``y`` is ``x + y``") ; // sum <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre> <br><p>  IMHO syntax here will be more pleasant than in Kotlin, I don‚Äôt even want to compare it with Java. </p><br><p>  <strong>3 # Type inference</strong> </p><br><p>  Ceylon will infer your types if you think it will improve readability: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> a = "abc"; // <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> inferred <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> String <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> inferred <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span> <span class="hljs-type"><span class="hljs-type">Float</span></span> c = <span class="hljs-number"><span class="hljs-number">0.7</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> declared explicitly List&lt;String&gt; d = ArrayList&lt;String&gt;(); // <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> declared explicitly</code> </pre> <br><p>  <strong>4 # Smart casts (Smart Casts)</strong> </p><br><p>  The Ceylon compiler keeps track of your logic and, to the extent possible, performs type casting, i.e. you no longer need the instanceof checks after the explicit cast: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> obj) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(obj.uppercased) <span class="hljs-comment"><span class="hljs-comment">// obj is now known to be a String }</span></span></code> </pre> <br><p>  <strong>5 # Intuitive Equals</strong> </p><br><p>  You can no longer explicitly call equals (), because the == operator now checks for structural equality: </p><br><pre> <code class="hljs ruby">value john1 = Person(<span class="hljs-string"><span class="hljs-string">"John"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//we</span></span> override equals <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Person value john2 = Person(<span class="hljs-string"><span class="hljs-string">"John"</span></span>); print(john1 == john2); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> (structural equality) print(john1 === john2); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> (referential equality)</code> </pre> <br><p>  <strong>6 # Arguments by default</strong> </p><br><p>  You no longer need to define several identical methods with different arguments: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> build(String title, <span class="hljs-type"><span class="hljs-type">Integer</span></span> width = <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span> height = <span class="hljs-number"><span class="hljs-number">600</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Frame(title, width, height); }</code> </pre> <br><p>  <strong>7 # Named Arguments</strong> </p><br><p>  In conjunction with the default arguments, named arguments eliminate the need to use Builders: </p><br><pre> <code class="hljs pgsql">build("PacMan", <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>) // equivalent build {title = "PacMan"; width = <span class="hljs-number"><span class="hljs-number">400</span></span>; height = <span class="hljs-number"><span class="hljs-number">300</span></span>;} // equivalent build {title = "PacMan"; height = <span class="hljs-number"><span class="hljs-number">300</span></span>;} // equivalent <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> width</code> </pre> <br><p>  <strong>8 # switch expression</strong> </p><br><p>  The branch statement is replaced with a much more readable and flexible switch statement: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (obj) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"x is 1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"x is 2"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"x is 3 or 4"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (<span class="hljs-string"><span class="hljs-string">"x is String"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>([<span class="hljs-type"><span class="hljs-type">Integer</span></span> a, <span class="hljs-type"><span class="hljs-type">Float</span></span> b, <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>]) {<span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (<span class="hljs-string"><span class="hljs-string">"x is tuple with Integer ``a``, Float ``b`` and String ``c``"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"x is out of range"</span></span>);}</code> </pre> <br><p>  switch can work as an expression, also the result of switch can be assigned to a variable: </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>|IllegalStateException res = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(obj) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(is <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> IllegalStateException();</code> </pre> <br><p>  This is not a complete pattern matching, but for most cases the current functionality is enough. </p><br><p>  Unlike Kotlin, Ceylon requires that all conditions be disjoint to the switch, that is, do not overlap, which is much more logical for the switch.  If a range mapping is required or conditions may overlap, then the usual if should be used. </p><br><p>  <strong>9 # Properties</strong> </p><br><p>  You can add custom set &amp; get behavior to public fields, i.e., stop stuffing code with crazy getters and setters. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Frame() { variable <span class="hljs-type"><span class="hljs-type">Integer</span></span> width = <span class="hljs-number"><span class="hljs-number">800</span></span>; variable <span class="hljs-type"><span class="hljs-type">Integer</span></span> height = <span class="hljs-number"><span class="hljs-number">600</span></span>; <span class="hljs-type"><span class="hljs-type">Integer</span></span> pixels =&gt; width * height; }</code> </pre> <br><p>  <strong>10 # Data Class</strong> </p><br><p>  Unfortunately, this functionality is not yet available.  I would very much like to have immutable classes in which the toString (), equals (), hashCode () and copy () are overridden by the automaton, but, unlike Java, they did not occupy 100 lines of code. </p><br><p>  But the fact that this is not yet in the language does not mean that it is impossible to do.  I will give an example of how the necessary functionality is implemented through libraries through the means of the language itself: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">shared </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params"> name, shared </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params"> email, shared </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Integer</span></span></span></span><span class="hljs-class"><span class="hljs-params"> age</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataObject</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>) </span></span>{} value john = <span class="hljs-type"><span class="hljs-type">Person</span></span>(<span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"john@gmail.com"</span></span>, <span class="hljs-number"><span class="hljs-number">112</span></span>); value johnAfterBirhstday = john.copy&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;({`<span class="hljs-type"><span class="hljs-type">Person</span></span>.age`-&gt;<span class="hljs-number"><span class="hljs-number">113</span></span>;}); assertEquals(john, john.copy&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;()); assertEquals(john.hash, john.copy&lt;<span class="hljs-type"><span class="hljs-type">Person</span></span>&gt;().hash);</code> </pre> <br><p>  That is, at the library level, it turned out to redefine toString, leave the class immutable, we were able to create clones and changes to individual attributes.  Unfortunately, it does not work as fast as it could if support was in the language.  And there is no type checking at compile time = if we clone with redefinition in age and specify the string as the value, we get an error in runtime.  The fact that there is no such functional yet is definitely bad.  But the fact that we can write the necessary functionality independently at the library level is very good. </p><br><p>  <strong>11 # Operator Overloading</strong> </p><br><p>  A predefined set of statements that can be overloaded to improve readability: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) satisfies </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Summable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class">&gt; { shared actual </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> plus(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vy</span></span></span><span class="hljs-class">); } value v = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class">(2.0, 3.0) + </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class">(4.0, 1.0);</span></span></code> </pre> <br><p>  <strong>12 # Destructuring Declarations</strong> </p><br><p>  Some objects can be destructured, which is useful, for example, to iterate a map: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ([key -&gt; [val1, val2, val3]] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Key: ``key``"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Value: ``val1``, ``val2``, ``val3``"</span></span>); }</code> </pre> <br><p>  <strong>13 # Ranges</strong> </p><br><p>  To improve readability: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">100</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)) { ... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>) { ... }</code> </pre> <br><p>  In contrast, Kotlin did without the downTo keyword. </p><br><p>  <strong>14 # Extension Functions</strong> </p><br><p>  They are not.  It may appear that this possibility was considered in the early language specifications.  But instead of the extension functions, in principle, top level functions work.  If we, for example, want to add the sayHello method to the String class, then "world" .sayHello () does not look much better than sayHello ("world").  In the future they may appear. </p><br><p>  In principle, the corresponding functions available for the class allow you to find the IDE itself, sometimes it works. </p><br><p>  <strong>15 # Security Null</strong> </p><br><p>  Java should be called an almost statically typed language.  Inside it, a variable of type String does not necessarily refer to a String ‚Äî it can refer to null.  And although we are used to this, it reduces the security of checking for static typing, and as a result, Java developers are forced to live in constant fear of NPE. </p><br><p>  In Ceylon, this problem is resolved by dividing into types that allow and not allow null.  By default, types do not allow null, but you can convert them to allowable if you add?: </p><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; a = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; // compile <span class="hljs-literal"><span class="hljs-literal">error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>? b = <span class="hljs-string"><span class="hljs-string">"xyz"</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; // no problem</code> </pre> <br><p>  Due to the functional union types String?  it's just syntactic sugar for String | Null.  Accordingly, you can write: </p><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">variable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>|<span class="hljs-keyword"><span class="hljs-keyword">Null</span></span>  = <span class="hljs-string"><span class="hljs-string">"xyz"</span></span>;  = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; // no problem</code> </pre> <br><p>  Ceylon forces you to fight NPE when you refer to a type that allows null: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> x = b.length <span class="hljs-comment"><span class="hljs-comment">// compile error: b might be null</span></span></code> </pre> <br><p>  It may look cumbersome, but due to its several capabilities it is really useful.  We still have smart type conversions where types that admit null are converted to not allowing: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> x = b.length // <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> problem</code> </pre> <br><p>  You can also use the secure call?., It returns null instead of dropping NPE: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> x = b?.length; // <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> nullable <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br><p>  You can chain safe calls to avoid nested if-non-null checks that we sometimes write in other languages.  And if by default we need a non-null value, then we use the elvis operator else </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = ship?.captain?.name <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> "unknown";</code> </pre> <br><p>  If all this does not suit you and NPE is absolutely necessary for you, then tell about it clearly: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> x = b?.length <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NullPointerException() // same <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> below <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(!NullPointerException x);</code> </pre> <br><p>  <strong>16 # Improved lambda</strong> </p><br><p>  This is a good lambda system - the perfect balance between readability and conciseness thanks to several sensible solutions.  The syntax is simple: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">value</span></span> sum = (<span class="hljs-type"><span class="hljs-type">Integer</span></span> x, <span class="hljs-type"><span class="hljs-type">Integer</span></span> y) =&gt; x + y; // <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">Integer</span></span>(<span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> res = sum(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>) // res == <span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre> <br><p>  Accordingly, the syntax can be: </p><br><pre> <code class="hljs coffeescript">numbers.filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> =&gt;</span></span> x.isPrime() ); numbers.filter(isPrime)</code> </pre> <br><p>  This allows us to write concise functional code: </p><br><pre> <code class="hljs swift"> persons .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> ( (it) =&gt; it.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(byIncreasing(<span class="hljs-type"><span class="hljs-type">Person</span></span>.name)) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> ( <span class="hljs-type"><span class="hljs-type">Person</span></span>.email ) .each ( <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> );</code> </pre> <br><p>  The lambda system plus syntactic features of the language makes Ceylon a good tool for creating DSL.  An example of a DSL similar to Anko in Ceylon syntax: </p><br><pre> <code class="hljs axapta"> VerticalLayout { padding = dip(<span class="hljs-number"><span class="hljs-number">30</span></span>); { editText { <span class="hljs-keyword"><span class="hljs-keyword">hint</span></span> = <span class="hljs-string"><span class="hljs-string">"Name"</span></span>; textSize = <span class="hljs-number"><span class="hljs-number">24.0</span></span>; }, editText { <span class="hljs-keyword"><span class="hljs-keyword">hint</span></span> = <span class="hljs-string"><span class="hljs-string">"Password"</span></span>; textSize = <span class="hljs-number"><span class="hljs-number">24.0</span></span>; }, button { <span class="hljs-string"><span class="hljs-string">"Login"</span></span>; textSize = <span class="hljs-number"><span class="hljs-number">45.0</span></span>; } } };</code> </pre> <br><p>  <strong>17 # IDE support</strong> </p><br><p>  By the way, it's pretty good.  There is an eclipse plugin, there is an IDEA plugin.  Yes, in terms of features and bugs, everything is somewhat worse than in Scala or Kotlin.  But in principle, you can work and quite comfortably, the problems of IDE at the speed of development have virtually no effect. </p><br><p>  So, if you take the strengths of Kotlin, Ceylon is inferior to Kotlin by the lack of DataObject functionality (which can be emulated independently by means of libraries).  Otherwise, it provides not less features, but with a more pleasant syntax for reading. </p><br><p>  Well, just like on Kotlin, on Ceylon you can write for Android. </p><br><p>  After reading the above, you might get the impression - why do we need this?  The same is in Kotlin, almost 1 in 1. </p><br><p>  And the fact that in Ceylon there are things that are not present in either Kotlin or Scala, and due to these things the language itself is in many ways much better than other languages.  For example, union types, intersection types, enumerated types, more powerful generics, modularity, herd, annotations and metamodel, tuples, for comprehensions.  What really changes the approach to programming, allows you to write a much more reliable, understandable and universal code.  But about it in the <a href="https://habrahabr.ru/post/330796/">following</a> part. </p><br><div class="spoiler">  <b class="spoiler_title">For interested few useful links.</b> <div class="spoiler_text"><p>  <a href="https://ceylon-lang.org/documentation/1.3/introduction/">https://ceylon-lang.org/documentation/1.3/introduction/</a> <br>  <a href="https://ceylon-lang.org/documentation/1.3/faq/language-design/">https://ceylon-lang.org/documentation/1.3/faq/language-design/</a> <br>  <a href="https://dzone.com/articles/a-qa-with-gavin-king-on-ceylon">https://dzone.com/articles/a-qa-with-gavin-king-on-ceylon</a> <br>  <a href="https://www.slant.co/versus/116/390/~scala_vs_ceylon">https://www.slant.co/versus/116/390/~scala_vs_ceylon</a> <br>  <a href="https://www.slant.co/versus/390/1543/~ceylon_vs_kotlin">https://www.slant.co/versus/390/1543/~ceylon_vs_kotlin</a> <br>  <a href="https://dzone.com/articles/ceylon-enterprise-ready">https://dzone.com/articles/ceylon-enterprise-ready</a> <br>  <a href="http://tryge.com/2013/12/13/ceylon-and-kotlin/">http://tryge.com/2013/12/13/ceylon-and-kotlin/</a> </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330412/">https://habr.com/ru/post/330412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330400/index.html">Typed components in Vue.js, or how to make friends Vue, TypeScript and Webpack</a></li>
<li><a href="../330402/index.html">Initialization lists in C ++: good, bad, evil</a></li>
<li><a href="../330406/index.html">Theory and practice of unattended upgrades in Ubuntu</a></li>
<li><a href="../330408/index.html">PyConRu 2017 preliminary program: speakers from Disney, Facebook, Yandex, JetBrains, Tinkoff Bank</a></li>
<li><a href="../330410/index.html">Features ‚Äìwebkit-box or how to ‚Äúfriend‚Äù flexbox with old Safari</a></li>
<li><a href="../330414/index.html">Journey inside Avito: platform</a></li>
<li><a href="../330416/index.html">Intelligence is a new milestone in the development of localization systems</a></li>
<li><a href="../330418/index.html">Creating a simple audio editor</a></li>
<li><a href="../330422/index.html">Redux: an attempt to get rid of the need to think during API requests</a></li>
<li><a href="../330424/index.html">Joint security in the cloud according to RUVDS, HUAWEI and Kaspersky Labs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>