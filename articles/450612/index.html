<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intro Newton Protocol: what can fit in 4 kilobytes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I participated in the Revision 2019 demostsen competition in the PC 4k intro category, and my intro won first place. I did coding and graphi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intro Newton Protocol: what can fit in 4 kilobytes</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png" alt="image"></div><br>  Recently, I participated in the Revision 2019 demostsen competition in the PC 4k intro category, and my intro won first place.  I did coding and graphics, and dixan composed music.  The main rule of the competition is to create an executable file or website that is only 4096 bytes in size.  This means that everything has to be generated using mathematics and algorithms;  in no other way will it be possible to squeeze images, video and audio into such a tiny amount of memory.  In this article I will talk about the pipeline rendering of their intro Newton Protocol.  Below you can see the finished result, or <a href="">click here</a> to see how it looked live on Revision, or <a href="http://www.pouet.net/prod.php%3Fwhich%3D81041">go to pouet</a> to comment and download the intro that participated in the contest.  About the work of competitors and corrections can be <a href="http://www.pouet.net/party.php%3Fwhich%3D1550%26amp%3Bwhen%3D2019">found here</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iIIu7kPCN-8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Very popular in the 4k intro discipline is the Ray marching distance fields technique, because it allows you to set complex shapes in just a few lines of code.  However, the disadvantage of this approach is the speed of implementation.  To render a scene, you need to find the point of intersection of the rays with the scene, first determine what you see, for example, the beam from the camera, and then the subsequent rays from the object to the light sources to calculate the lighting.  When working with ray marching, these intersections cannot be found in one step, you need to take many small steps along the beam and evaluate all objects at each point.  On the other hand, when using ray tracing, you can find the exact intersection by checking each object only once, but the set of shapes that can be used is very limited: to calculate the intersection with the ray, you need to have a formula for each type. <br><br>  In this intro, I wanted to simulate very accurate lighting.  Since for this it was necessary to reflect millions of rays in the scene, in order to achieve such an effect, ray tracing seemed like a logical choice.  I confined myself to a single figure ‚Äî a sphere, because the intersection of the ray and the sphere is calculated quite simply.  Even the walls in the intro are actually very large areas.  In addition, it simplified the physics simulation;  it was enough to take into account only collisions between spheres. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To illustrate the amount of code that fits in 4096 bytes, below I presented the full source code of the finished intro.  All parts, with the exception of HTML at the end, are encoded as a PNG image in order to compress them into a smaller volume.  Without this compression, the code would occupy almost 8900 bytes.  The part called Synth is a trimmed version of the <a href="https://github.com/mbitsnbites/soundbox">SoundBox</a> .  I used the <a href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a> and <a href="https://github.com/laurentlb/Shader_Minifier">Shader Minifier</a> to package the code in this minimized format.  In the end, almost everything is compressed into PNG using <a href="http://www.pouet.net/prod.php%3Fwhich%3D59298">JsExe</a> .  The full compilation pipeline can be viewed in the source code of my previous 4k intro <a href="https://github.com/Bercon/CoreCritical">Core Critical</a> , because it completely coincides with the one presented here. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/274/690/e5b27469046c9c34bfb14fc2fbe33fa5.png"></div><br>  <i>Music and synthesizer are fully implemented in Javascript.</i>  <i>The part on WebGL is divided into two parts (highlighted in green in the code);</i>  <i>she sets up the rendering pipeline.</i>  <i>Elements of physics and ray tracer are GLSL shaders.</i>  <i>The rest of the code is encoded in a PNG image, and HTML is added to the end of the resulting image without modification.</i>  <i>The browser ignores the image data and executes only the HTML code, which, in turn, decodes the PNG back into javascript and executes it.</i> <br><br><h3>  Rendering pipeline </h3><br>  The figure below shows the rendering pipeline.  It consists of two parts.  The first part of the pipeline is a physics simulator.  The intro scene contains 50 spheres colliding with each other inside the room.  The room itself is made up of six spheres, some of which are smaller than others to create more curved walls.  The two vertical sources of illumination in the corners are also spheres, that is, there are 58 spheres in the scene.  The second part of the pipeline is the ray tracer, which renders the scene.  The diagram below shows the rendering of a single frame at time t.  A physics simulation takes the previous frame (t-1) and simulates the current state.  The ray tracer takes the current positions and positions of the previous frame (for the speed channel) and renders the scene.  Then post-processing combines the previous 5 frames and the current frame to reduce distortion and noise, and then creates a finished result. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6a/848/ac0/f6a848ac09343ca15abfd03393a7ceeb.png"></div><br>  <i>Frame rendering at time t.</i> <br><br>  The physical part is quite simple, on the Internet you can find many tutorials on creating a primitive simulation for spheres.  Position, radius, speed and mass are stored in two 1 x 58 textures. I used the Webgl 2 functionality, which allows rendering in several render targets, so the data of two textures are recorded simultaneously.  The same functionality is used by the ray tracer to create three textures.  Webgl does not provide any access to the NVidia RTX ray tracing API or DirectX Raytracing (DXR), so everything is done from scratch. <br><br><h3>  Ray tracer </h3><br>  By itself, ray tracing is a rather primitive technique.  We release a beam into the scene, it is reflected 4 times, and if it enters the light source, the color of the reflections accumulates;  otherwise, we get black.  In 4096 bytes (which include music, synthesizer, physics, and rendering) there is no place for creating complex accelerating ray tracing structures.  Therefore, we use the brute force method, that is, we check all 57 spheres (the front wall is excluded) for each ray, without making any optimizations to exclude part of the spheres.  This means that to ensure 60 frames per second in 1080p resolution, you can emit only 2-6 rays, or samples per pixel.  This is not nearly enough to create a smooth lighting. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/2ce/72d/b232ce72d49f57a69b96d402ec0bb148.png"></div><br>  <i>1 sample per pixel.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e52/77d/19e/e5277d19e5a7b897b8dd9046eaae6f26.png"></div><br>  <i>6 samples per pixel.</i> <br><br>  How to cope with it?  At first I investigated the ray tracing algorithm, but it was already utterly simplified.  I managed to improve performance a bit by eliminating cases where the beam starts inside the sphere, because such cases are applicable only with transparency effects, and only opaque objects were present in our scene.  After that, I combined each if condition into a separate operator to avoid optional branching: despite the ‚Äúextra‚Äù calculations, this approach is still faster than a bunch of conditional statements.  It was also possible to improve the sampling pattern: instead of emitting rays at random, we could distribute them around the scene in a more uniform pattern.  Unfortunately, this did not help and resulted in wavy artifacts in each algorithm I tried.  However, this approach created good results for still images.  As a result, I returned to using a completely random distribution. <br><br>  Neighboring pixels should have very similar lighting, so why not use them when calculating the lighting of a single pixel?  We do not want to blur textures, only the lighting, so you need to render them in separate channels.  Also, we do not want to blur objects, so we must take into account the identifiers of objects in order to know which pixels can be blurred calmly.  Since we have objects reflecting light and we need clear reflections, it is not enough just to find out the ID of the first object that the beam encounters.  I used a special case for pure reflective materials to also include in the channel of object identifiers the IDs of the first and second objects visible in the reflections.  In this case, the blur can smooth out the lighting in objects in reflections, while at the same time preserving the borders of objects. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/a24/a6b/f69a24a6b9094903309af27b5606e923.png"></div><br>  <i>Channel textures, we do not need to blur it.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/c4a/7f6/a4fc4a7f6ec4fa0552542edf7204cb58.png"></div><br>  <i>Here in the red channel contains the ID of the first object, in the green - the second, and in the blue - the third.</i>  <i>In practice, all of them are encoded into a single value of the float format, in which the integer part stores the identifiers of objects, and the fractional one denotes roughness: 332211.RR.</i> <br><br>  Since there are objects with different roughness in the scene (some spheres are rough, on others the lighting is scattered, in the third there is a mirror reflection), I store the roughness to control the blur radius.  There are no small details in the scene, so I used a large 50 x 50 kernel with the weights in the form of inverse squares to blur.  It does not take into account the world space (this could be realized in order to get more accurate results), because on surfaces angled in some directions it blurs a large area.  This blur creates a fairly smooth image, but still well visible artifacts, especially in motion. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/553/f9d/ca6553f9d61bc8f7dda51ba41c2cbf28.png"></div><br>  <i>Lighting channel with blur and still noticeable artifacts.</i>  <i>In this image there are noticeable blurred points on the back wall, which are caused by a small bug with the identifiers of the second reflected object (the rays leave the scene).</i>  <i>On the finished image, this is not very noticeable, because clear reflections are taken from the texture channel.</i>  <i>Illumination sources also become blurred, but I liked this effect and I left it.</i>  <i>If desired, this can be prevented by changing object identifiers depending on the material.</i> <br><br>  When objects are in the scene and the camera shooting the scene is moving slowly, the lighting in each frame should remain constant.  Therefore, we can blur not only in the XY coordinates of the screen;  we can blur in time.  If we assume that the illumination does not change too much over 100 ms, then we can average it for 6 frames.  But for this time window, the objects and the camera will still go some distance, so a simple calculation of the average for 6 frames will create a very blurry image.  However, we know where all the objects and the camera were in the previous map, so we can calculate the velocity vectors in the screen space.  This is called temporary reprojection.  If I have a pixel at time t, then I can take the speed of this pixel and calculate where it was at time t-1, and then calculate where the pixel at time t-1 is at time t-2, and so on. back 5 frames.  Unlike blur in the screen space, I used the same weight for each frame, i.e.  just averaged the color between all the frames for a temporary ‚Äúblur‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/a4c/e42/1fca4ce4250f372223862a34472add21.png"></div><br>  <i>A pixel velocity channel telling where the pixel was in the last frame based on the movement of the object and the camera.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/bb5/1f6/011bb51f60e3b3066c87ee4a1d46d403.png"></div><br>  <i>To avoid joint blurring of objects, we will again use the channel of object identifiers.</i>  <i>In this case, we take into account only the first object that the beam encountered.</i>  <i>This provides anti-aliasing within the object, i.e.</i>  <i>in the reflections.</i> <br><br>  Of course, a pixel might not be visible in the previous frame;  it could be hidden by another object or be out of view of the camera.  In such cases, we cannot use the previous information.  This check is performed separately for each frame, so we get from 1 to 6 samples or frames per pixel, and use those that are possible.  The figure below shows that for slow objects this is not a very serious problem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5b/c89/8fc/c5bc898fc8ac6ff9b5a0c8685312604f.png"></div><br>  <i>When objects move and open up new parts of the scene, we do not have 6 frames of information to average it for these parts.</i>  <i>This image shows areas that have 6 frames (white), as well as those in which they are missing (gradually dimming shades).</i>  <i>The appearance of the contours is caused by the randomization of the sampling locations for the pixel in each frame and the fact that we take the object identifier from the first sample.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/570/c4c/b4a/570c4cb4a84f008a497678b0b735930e.png"></div><br>  <i>Blurred lighting is averaged over six frames.</i>  <i>The artifacts are almost imperceptible and the result is stable over time, because in each frame only one of six frames changes, in which the lighting is taken into account.</i> <br><br>  Combining all this, we get the finished image.  Illumination is blurred by neighboring pixels, while textures and reflections remain clear.  Then all this is averaged between six frames in order to create an even smoother and more stable image over time. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png"></div><br>  <i>The finished image.</i> <br><br>  The attenuation artifacts are still noticeable, because I averaged several samples per pixel, although I took the channel of the object identifier and speed for the first intersection.  You can try to fix it and get a smoothing in the reflections, discarding samples, if they do not coincide with the first, or at least if the first collision does not coincide in order.  In practice, the tracks are almost invisible, so I did not bother to eliminate them.  The boundaries of objects are also distorted, because the speed channels and object identifiers cannot be smoothed.  I considered the possibility of rendering the entire image at a resolution of 2160p with a further decrease in scale to 1080p, but my NVidia GTX 980ti is not capable of processing such resolutions at 60fps, so I decided to abandon this idea. <br><br>  In general, I am very pleased with how the intro turned out.  I managed to squeeze everything I had in it, and despite the small bugs, the end result was very high quality.  In the future, you can try to eliminate bugs and improve anti-aliasing.  It is also worth experimenting with features such as transparency, motion blur, various shapes and object transformations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba9/f56/e02/ba9f56e02c13d046f73e888540a0d75e.png"></div></div><p>Source: <a href="https://habr.com/ru/post/450612/">https://habr.com/ru/post/450612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450600/index.html">Communication with the reverse side of the moon - satellite relay "Tseyutsyao" (Shorty bridge)</a></li>
<li><a href="../450602/index.html">"How we build IaaS": materials on the work of 1cloud</a></li>
<li><a href="../450604/index.html">We eliminate the prime of a billion numbers faster than Wikipedia</a></li>
<li><a href="../450606/index.html">One day in the life of a restaurant model</a></li>
<li><a href="../450608/index.html">Fucking among us</a></li>
<li><a href="../450614/index.html">Joomla Digest for April 2019</a></li>
<li><a href="../450618/index.html">Why, according to statistics from Yandex and StackOverfow C #, are programmers the cheapest?</a></li>
<li><a href="../45062/index.html">Yahoo Search Beat: Key Engineer Goes To Microsoft</a></li>
<li><a href="../450620/index.html">Neutrino Mystery from Supernova 1987A</a></li>
<li><a href="../450626/index.html">Fix design pattern - Singleton in PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>