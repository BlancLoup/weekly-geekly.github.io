<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exception Security Guarantees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Error handling errors are the most common source of error. 

 The ravings that came to mind when writing this article 

 The main battles over the fac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exception Security Guarantees</h1><div class="post__text post__text-html js-mediator-article">  <i>Error handling errors are the most common source of error.</i> <i><br><br></i>  The ravings that came to mind when writing this article <br><br>  The main battles over the fact that it is better to use when programming in C # - exceptions or return codes for processing are gone into the distant past (*), but there are still no other kinds of battles: yes, ok, we stopped at exception handling, but how do we handle them "correctly"? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are many points of view on what is ‚Äúright‚Äù, most of which boils down to the fact that you need to catch only those exceptions that you can handle, and throw all the rest to the calling code.  Well, and if an incomprehensible exception came to the upper level in a bold way, then shoot the entire application as a whole, since it is no longer clear whether it is, birth, in a consistent state or not. <br><br>  There are many pros and cons of this method of intercepting and handling exceptions, but today I want to consider a slightly different topic.  Namely, the topic of ensuring a consistent state of the application in the light of the occurrence of an exception - three levels of security exceptions. <br><a name="habracut"></a><br><br><h4>  Three types of warranty </h4><br><br>  In the late 1990s, Dave Abrahams offered three levels of security exceptions: a basic guarantee, a strict guarantee, and a guarantee of the absence of exceptions.  This idea was warmly received by the C ++ community of developers, and after its popularization (and some modification) with the Sutter coat of arms, the exclusion security guarantees became widely used in boost, in the standard C ++ library, and in application development. <br><br>  Initially, these guarantees were proposed by Dave Abrahams to implement the STLPort library in C ++, but the very idea of ‚Äã‚Äãexceptions security is not specific to a programming language and can be used in other languages ‚Äã‚Äãthat use exceptions as the main error handling mechanism, such as Java or C #.  In addition, there are currently two versions of the definitions of security guarantees for exceptions: (1) the original version proposed by Dave Abrahams and (2) a modified version popularized by Sutter and Stroustrup, and more suitable not only for libraries, but also for applications. <br><br><h5>  Basic warranty </h5><br><br>  <b>The original definition is</b> : ‚Äú <i>in the case of exceptions there should be no resource leaks</i> ‚Äù. <br><br>  <b>The current definition is</b> : ‚Äú <i>when any exception occurs in a certain method, the state of the program must remain consistent</i> ‚Äù.  This means not only the absence of resource leaks, but also the preservation of class invariants, which is a more general criterion, compared to the basic definition. <br><br>  The difference between these two formulations is due to the fact that initially this guarantee was proposed for the implementation of the library in C ++ and had no relation to application applications.  But if we talk about a more general case (that is, about an application, and not just about a library), then we can say that resource leaks are only one source of bugs, but far from unique.  Preserving the invariant at any stable point in time (**) is a guarantee that no external code can ‚Äúsee‚Äù the mismatched state of the application, which, you see, is no less important than the absence of resource leaks.  Few users of the banking application will be interested in memory leaks, if, when transferring money from one account to another, money can ‚Äúgo‚Äù from one account, but ‚Äúnot reach‚Äù another. <br><br><h5>  Strict warranty </h5><br><br>  As for the definition of a strict guarantee of exceptions, the original and current definitions are similar and boil down to the following: ‚Äú <i>if an exception occurs during the operation, this should not have any impact on the state of the application</i> ‚Äù. <br><br>  In other words, a strict exception guarantee ensures transactional operations when we receive either all or nothing.  In this case, when an exception occurs, we must roll back to the state of the application, which was before the operation, and move to a new state only if the entire operation was successfully completed. <br><br><h5>  Guarantee no exceptions </h5><br><br>  The assurance of the absence of exceptions comes down to the following: ‚Äú <i>under no circumstances will the function generate exceptions</i> ‚Äù. <br><br>  This guarantee is the simplest in terms of definition, however, it is not as simple as it seems.  Firstly, it is practically impossible to provide it in the general case, especially in the .Net environment, when an exception can occur at almost any point of the application.  In practice, only units of operations follow this guarantee, and it is on the basis of such operations that guarantees of previous levels are built.  In C #, then one of the few operations that provide this guarantee is link assignment, and in C ++, the swap function implements the exchange of values.  It is on the basis of these functions that a strict exception guarantee is often implemented, when all the ‚Äúdirty work‚Äù is performed in a temporary object, which is then assigned to the resulting value. <br><br>  Secondly, in some cases it is impossible to ensure the normal operation of other functions, unless some operations follow the guarantee of the absence of exceptions.  So, for example, in C ++, in order to provide even a basic guarantee of exceptions (or rather resource leaks) in containers, it is necessary that the destructor of the user type does not generate exceptions. <br><br>  The three exclusion security guarantees discussed above go from the weakest to the strongest;  however, each subsequent warranty is a superset of the previous one.  This means that the fulfillment of a strict warranty by an automatic machine entails the fulfillment of a basic guarantee, and the guarantee of the absence of exceptions entails the fulfillment of a strict guarantee.  If the code does not even respond to the basic guarantee of exceptions, then it is a time bomb in your application and sooner or later will lead to unpleasant consequences, breaking it up into hell. <br><br>  Now let's look at a few examples. <br><br><h4>  Examples of breach of basic warranty </h4><br><br>  The main way to prevent memory leaks and resources in C ++ is <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> (Resource Acquisition Is Initialization) idiom, which is that an object captures a resource in the constructor and frees it in the destructor.  And since the call to the destructor is performed automatically when the object goes out of scope for any reason, including when an exception occurs, it is not surprising that the same idiom is also used to ensure the safety of exceptions. <br><br>  In C #, this idiom has migrated as an <b>IDisposable</b> interface and <b>using</b> constructs, however, unlike C ++, it is applicable to manage the lifetime of a resource in a certain area of ‚Äã‚Äãview, and is not suitable for managing the set of resources captured in the designer. <br><br>  Let's look at this example: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//  ,   </font> <br> <font color="#0000ff">class</font> DisposableA : IDisposable <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() {} <br> } <br> <br> <font color="#008000">//      </font> <br> <font color="#0000ff">class</font> DisposableB : IDisposable <br> { <br> <font color="#0000ff">public</font> DisposableB() <br> { <br> disposableA = <font color="#0000ff">new</font> DisposableA(); <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Exception( <font color="#A31515">"OOPS!"</font> ); <br> } <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() {} <br> <br> <font color="#0000ff">private</font> DisposableA disposableA; <br> } <br> <br> <font color="#008000">// -  </font> <br> <font color="#0000ff">using</font> ( <font color="#0000ff">var</font> disposable = <font color="#0000ff">new</font> DisposableB()) <br> { <br> <font color="#008000">// !  Dispose     </font> <br> <font color="#008000">// DisposableB,   DisposableA</font> <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  So, we have two disposable-classes: <b>DisposableA</b> and <b>DisposableB</b> , each of which captures some managed resource in the constructor and releases it in the <b>Dispose</b> method.  Let's not consider the finalizer for now, because it will not help us in any way to guarantee a deterministic order of resource release, which in some cases is vital. <br><br>  In this case, when an exception is thrown by the constructor of the class <b>DisposableB,</b> we will never call the <b>Dispose</b> method, because a <b>disposable</b> object never existed.  In this regard, the behavior of most mainstream programming languages ‚Äã‚Äãis more or less the same, but there are some differences.  The similarity lies in the fact that if the constructor "falls", the calling code will not be able to get a reference to the object that has not yet been constructed and to explicitly release its resources.  However, unlike C ++, in which the call to the destructor of fully constructed fields is performed automatically, this is not the case in the ‚Äúcontrolled‚Äù C # language (***). we will get a ‚Äúresource drain‚Äù (or at least their non-deterministic release). <br><br>  The same problem can manifest itself in a more subtle way.  In the case considered earlier, it is clearly seen that we created an instance of the disposable object, after which an exception is generated.  But there are cases when the lack of a basic guarantee of exceptions is a little more difficult to see. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> Base : IDisposable <br> { <br> <font color="#0000ff">public</font> Base() <br> { <br> <font color="#008000">//   </font> <br> } <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() {} <br> } <br> <br> <font color="#0000ff">class</font> Derived : Base, IDisposable <br> { <br> <font color="#0000ff">public</font> Derived( <font color="#0000ff">object</font> data) <br> { <br> <font color="#0000ff">if</font> (data == <font color="#0000ff">null</font> ) <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> ArgumentNullException( <font color="#A31515">"data"</font> ); <br> <font color="#008000">// OOPS!!</font> <br> } <br> } <br> <font color="#008000">//   -  </font> <br> <font color="#0000ff">using</font> ( <font color="#0000ff">var</font> derived = <font color="#0000ff">new</font> Derived( <font color="#0000ff">null</font> )) <br> {} <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Generating an exception in the constructor of the class <b>Derived</b> violates the basic guarantee of exceptions and leads to a leak of resources, since the <b>Base</b> class <b>Dispose</b> method is not called (****).  Again, since the compiler knows about the <b>IDisposable</b> interface only through the prism of the <b>using</b> construct, in all cases when the disposable object is a field of another class, only the programmer is responsible for calling <b>Dispose</b> . <br><br>  In addition to the base class, field initializers can play a similar joke, when the constructor of one of the fields can generate an exception: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> ComposedDisposable : IDisposable <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">void</font> Dispose() {} <br> <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> DisposableA disposableA = <font color="#0000ff">new</font> DisposableA(); <br> <font color="#008000">//  ,   DisposableB ? OOPS!!</font> <br> <font color="#0000ff">private</font> <font color="#0000ff">readonly</font> DisposableB disposableB = <font color="#0000ff">new</font> DisposableB(); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In this case, if the constructor of the <b>DisposableB</b> class when initializing the <b>disposableB</b> field generates an exception, it will not be possible to intercept it and release the already captured resources.  In C ++, there is such a thing as interception of exceptions that occurred in the initialization list (see <a href="http://my.safaribooksonline.com/book/programming/cplusplus/0201700735/exception-handling/373">Exception and Member Initialization</a> ), however, there is no such possibility in C #, so there is one way out of this situation: try not to allow it. <br><br>  As for all previous cases, providing a basic guarantee of exceptions completely falls on the shoulders of the developer, since C # does not provide any "sugar" for these purposes.  <b>All we have to do is either create sub-objects in the right order and</b> <b>create a disposable field at the very end of the constructor, or wrap their creation in a try / catch block and clear all resources in the event of an exception.</b> <br><br><h4>  An example of a strict exemption guarantee.  Object initializer and collection initializer </h4><br><br>  The examples of violation of the basic warranty of the exceptions given above, although they are not contrived, are not so often found.  And if the C # compiler cannot help us in the case of creating objects containing several managed resources, it can help in some other cases, for example, in creating objects and collections. <br><br>  The initializer of objects and collections (object initializer and collection initializer) ensure that the object is created and initialized or the collection is filled with a list of items.  Let's consider the following example. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> Person <br> { <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> FirstName { <font color="#0000ff">get</font> ; <font color="#0000ff">set</font> ; } <br> <font color="#0000ff">public</font> <font color="#0000ff">string</font> LastName { <font color="#0000ff">get</font> ; <font color="#0000ff">set</font> ; } <br> <font color="#0000ff">public</font> <font color="#0000ff">int</font> Age { <font color="#0000ff">get</font> ; <font color="#0000ff">set</font> ; } <br> } <br> <br> <font color="#0000ff">var</font> person = <font color="#0000ff">new</font> Person <br> { <br> FirstName = <font color="#A31515">"Bill"</font> , <br> LastName = <font color="#A31515">"Gates"</font> , <br> Age = 55, <br> }; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  At first glance it may seem that this is just syntactic sugar for the following: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> person = <font color="#0000ff">new</font> Person(); <br> person.FirstName = <font color="#A31515">"Bill"</font> ; <br> person.LastName = <font color="#A31515">"Gates"</font> ; <br> person.Age = 55; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  However, in reality, <b>when the object initializer is called, a temporary variable is created, then the properties of this particular variable are changed, and only then it is assigned to the new object</b> : <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">var</font> tmpPerson = <font color="#0000ff">new</font> Person(); <br> tmpPerson.FirstName = <font color="#A31515">"Bill"</font> ; <br> tmpPerson.LastName = <font color="#A31515">"Gates"</font> ; <br> tmpPerson.Age = 55; <br> <font color="#0000ff">var</font> person = tmpPerson; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  This ensures the atomicity of the object creation process and the inability to use a partially initialized object in the case of an exception being thrown by one of the setters.  A similar principle lies in the initializer of collections, when objects are added to the temporary collection and only after it is filled in, the temporary variable is assigned to the new object. <br><br>  The principle underlying these two concepts can easily be used in our own implementation of the strict guarantee of exceptions in our own code.  To do this, it suffices to perform all changes in the internal state of an object in a certain time variable and only after they are completed will the atomically change its real state. <br><br><h4>  Conclusion </h4><br><br>  Correct exception handling is not a simple matter, and, as some examples have shown, sometimes even the basic exception guarantee is difficult.  However, the provision of such guarantees is a vital prerequisite when developing applications, since it is much easier to hide the entire complexity of working with resources in one place than to smudge it with a thin layer throughout the entire application.  The golden rule, formulated a decade ago by Scott Meyers, is still in force: <i>create classes that are easy to use correctly and difficult to use incorrectly</i> , and the guarantee of exceptions in this plays clearly not the last role. <br><br>  If we talk about the practical application of these guarantees, then a few points should be remembered.  First, the code that does not perform the basic exception guarantee is incorrect;  based on it, it is simply impossible to create an application whose state will not break when it is used or changed (*****).  Secondly, do not be paranoid and seek the maximum guarantee.  It‚Äôs almost impossible to guarantee that there are no 100% exceptions due to the presence of asynchronous exceptions, but even implementing a strict guarantee in many cases can be unnecessarily expensive. <br><br>  To conclude, we can say the following: <em>security guarantees for exceptions are not a panacea, but an excellent foundation for building robust applications</em> . <br><br>  ---------------------- <br><br>  (*) In fact, the ‚Äúhot‚Äù debate, in general, was not for one simple reason: you cannot program on the .Net platform without exception handling.  Such debates are relevant, for example, in the C ++ language, especially when it comes to low-level programming. <br><br>  (**) In general, no one ever requires the invariant to be preserved;  usually it is necessary to preserve the invariant ‚Äúbefore‚Äù and ‚Äúafter‚Äù the call of the <b>open</b> method, but it is not necessary to save it after calling the <b>private</b> method that performs only a ‚Äúpart‚Äù of the work. <br><br>  (***) It may seem quite amusing that a more ‚Äútricked‚Äù language such as C # may not do something that old C ++ does, but it really is.  As an example, let's rewrite the code discussed earlier with C # to C ++: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">class</font> Resource1 <br> { <br> <font color="#0000ff">public</font> : <br> Resource1() <br> { <br> <font color="#008000">//   , -  </font> <br> <font color="#008000">//      </font> <br> } <br> ~Resource1() <br> { <br> <font color="#008000">//   </font> <br> } <br> }; <br> <br> <font color="#0000ff">class</font> Resource2 <br> { <br> <font color="#0000ff">public</font> : <br> Resource2() <br> { <br> <font color="#008000">//      resource1_  </font> <br> <font color="#0000ff">throw</font> std::exception( <font color="#A31515">"Yahoo!"</font> ); <br> } <br> <font color="#0000ff">private</font> : <br> Resource1 resource1_; <br> }; <br> <br> <br> <font color="#008000">// -      Resource2</font> <br> Resource2 resource2;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  As mentioned earlier in C ++ (as opposed to C #), when an exception is generated, the destructors of already constructed fields (i.e., sub-objects) will be called automatically in the class constructor.  This means that in this case the call to the destructor of the <b>Resource1</b> object will occur automatically and there will be no resource leaks. <br><br>  Such differences in the behavior of C # and C ++ languages ‚Äã‚Äãare easily explained.  In C ++, a resource is everything, including dynamically allocated memory, so resource management tools are at a higher level.  An application programmer working with the C # language uses resources in the using block much more often than it seizes resources in the constructor.  And if he faces such a task, he will have to solve it on his own, without the help of the compiler. <br><br>  By the way, the Coat of Arms Sutter already told about it once in his article: <a href="http://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/">‚ÄúConstructor Exceptions in C ++, C #, and Java‚Äù</a> . <br><br>  (****) Maybe I already got hold of these notes, but this is quite important and, it seems, the last but one.  Such an example is often loved to ask at interviews, so now, my readers know the correct answer to it! <br><br>  (*****) Everything said in this article applies only to synchronous exceptions, since it is almost impossible to guarantee consistent asynchronous exceptions such as <b>OutOfMemoryException</b> or <b>ThreadAbortException</b> .  Behind the proof here: " <a href="http://sergeyteplyakov.blogspot.com/2011/01/threadabort.html">On the dangers of the Thread.Abort method.</a> " </div><p>Source: <a href="https://habr.com/ru/post/126374/">https://habr.com/ru/post/126374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../126368/index.html">Theory of Radiation Monitoring</a></li>
<li><a href="../126369/index.html">Is Linux Unix?</a></li>
<li><a href="../126371/index.html">Unlimited Internet from Beeline - unspecified payment terms</a></li>
<li><a href="../126372/index.html">UI-day from Mail.Ru Group at SumIT</a></li>
<li><a href="../126373/index.html">Solving Sudoku using a real-time webcam</a></li>
<li><a href="../126375/index.html">8123 bytes is enough for everyone</a></li>
<li><a href="../126377/index.html">Store automation or how to compete with supermarkets</a></li>
<li><a href="../126379/index.html">KinectFusion - build a 3D scene in real time</a></li>
<li><a href="../126382/index.html">The second season of the Lift project starts - a reality show to find investors in a startup</a></li>
<li><a href="../126384/index.html">ThinkPad X220: Compact Professional Laptop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>