<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Practical techniques for using multi-thread computing when working with the Revit API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am an architect, for a long time I designed buildings and structures, but since last summer I began programming in C # using the Revit API. I alread...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Practical techniques for using multi-thread computing when working with the Revit API</h1><div class="post__text post__text-html js-mediator-article">  I am an architect, for a long time I designed buildings and structures, but since last summer I began programming in C # using the Revit API.  I already have several add-on modules for Revit and now I want to share some development experiences for Revit.  It is assumed that readers can write macros for Revit in C #. <br><br>  Recently, exploring multi-threaded calculations came to some unexpected conclusions and got rid of the misconceptions associated with the work of Revit API.  In this article I will write how to speed up the work of macros several times, what are the limitations when working with parallel computing in Revit API, so that finally there are no questions left. <br><a name="habracut"></a><br>  The last time I wrote about parallel computing, I solved an abstract problem, considering the work of computing in multi-threaded mode.  Now consider the following practical task: <br><br><ol><li>  Select a few hundred walls, find the middle of each wall in the plan. </li><li>  Check the distance between the middle points of all the walls, and find the two most closely spaced walls relative to their centers. </li><li>  Perform this task in several ways and determine the fastest in terms of computation speed. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When performing parallel computations, we can work directly with Revit API objects (in this case, with Wall), but at the same time, we need to keep two things in mind: <br><br><ol><li>  <b>We cannot open several parallel transactions at once.</b>  At the same time, only one transaction can be opened in Revit, and by creating transactions for parallel computing, we will simultaneously create several parallel transactions. </li><li>  <b>Inside transactions, you cannot modify Revit API objects in parallel mode.</b>  Therefore, always separate the data processing of Revit API objects and the transformation of the project. </li></ol><br><br>  It would seem that you can proceed to the test, but there is another circumstance.  When performing some calculations in a loop with Revit objects, it is important to prevent the intermediate values ‚Äã‚Äãfrom being recalculated (in our case, the calculation of the midpoint of the wall).  As it turns out, this is a very expensive operation that you definitely need to cache. <br><br>  We will go further in the studies and create a class that will even get the properties of Revit API objects first, that is, cache them.  In addition, our class will be able to cache the value of the midpoint of the wall.  Well, let's get started now. <br>  First, create a WallTesting macro.  Do not forget to add a couple of libraries needed to work with parallel computing. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Threading.Tasks; //      <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Collections.Concurrent; //,   </code> </pre> <br><br>  And now we will create a caching class that will first obtain the properties of wall objects necessary for the operation. <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyCacheWall //          Wall    { private LocationCurve wallLine; //   ,     private XYZ p1 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> XYZ(); //     private XYZ p2 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> XYZ(); //      <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> XYZ pCenter; //   ,   ,      <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> MyCacheWall (LocationCurve WallLine) //    { this.wallLine = WallLine; //     -        } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> XYZ GetPointCenter (<span class="hljs-type"><span class="hljs-type">bool</span></span> cash) //,    ,      //          { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cash) //   { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pCenter == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { p1 = wallLine.Curve.GetEndPoint(<span class="hljs-number"><span class="hljs-number">0</span></span>); p2 = wallLine.Curve.GetEndPoint(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pCenter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> XYZ((p2.X + p1.X)/<span class="hljs-number"><span class="hljs-number">2</span></span>, (p2.Y + p1.Y)/<span class="hljs-number"><span class="hljs-number">2</span></span>, (p2.Z + p1.Z)/<span class="hljs-number"><span class="hljs-number">2</span></span>);//      <span class="hljs-number"><span class="hljs-number">9</span></span>   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pCenter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //  { p1 = wallLine.Curve.GetEndPoint(<span class="hljs-number"><span class="hljs-number">0</span></span>); p2 = wallLine.Curve.GetEndPoint(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pCenter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> XYZ((p2.X + p1.X)/<span class="hljs-number"><span class="hljs-number">2</span></span>, (p2.Y + p1.Y)/<span class="hljs-number"><span class="hljs-number">2</span></span>, (p2.Z + p1.Z)/<span class="hljs-number"><span class="hljs-number">2</span></span>);//      <span class="hljs-number"><span class="hljs-number">9</span></span>   } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span> GetLenght (XYZ x) //,          { XYZ vector = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> XYZ((pCenter.X - xX), (pCenter.Y - xY), (pCenter.Z - xZ)); //          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vector.GetLength(); //        } }</code> </pre><br><br>  In general, the composition of the caching class and its work is painted in the comments.  Now we can write the WallWithCashParallel method, which will work with our caching class MyCashWall and will be able to perform our tasks in parallel or sequential mode, and we will also be able to choose whether to cache the midpoint calculation. <br><br><pre> <code class="hljs pgsql">string WorkWithWallCashParallel(Document doc, ICollection&lt;ElementId&gt; selectedIds, <span class="hljs-type"><span class="hljs-type">bool</span></span> cash, <span class="hljs-type"><span class="hljs-type">bool</span></span> parallel) // cash   ,        // parallel         { List&lt;MyCacheWall&gt; wallList = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;ThisApplication.MyCacheWall&gt;(); //   -         Wall List &lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt; minPoints = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); //          ConcurrentBag &lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt; minPointsBag = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ConcurrentBag&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); //   ,       DateTime <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; //          DateTime start = DateTime.Now; //  <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (ElementId e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> selectedIds) //     Wall    MyWall. //    ,   ,        { Element el = doc.GetElement(e); //    Id Wall w = el <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Wall; //,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (w != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) //  - { wallList.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MyCacheWall (w.<span class="hljs-keyword"><span class="hljs-keyword">Location</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> LocationCurve)); //   MyCacheWall         Wall } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parallel) //     { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Threading.Tasks.Parallel.<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, wallList.Count, x =&gt; //      MyWall  //          ().      { List &lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt; allLenght = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); //   wallList[x].GetPointCenter(cash); //    .      <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (MyCacheWall nn <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> wallList) //       () { <span class="hljs-type"><span class="hljs-type">double</span></span> n = wallList[x].GetLenght( nn.GetPointCenter(cash) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n != <span class="hljs-number"><span class="hljs-number">0</span></span>) //      allLenght.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(n); //        } allLenght.Sort(); //   minPointsBag.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(allLenght[<span class="hljs-number"><span class="hljs-number">0</span></span>]); //       });//  minPoints.AddRange(minPointsBag); //    ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>      { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; wallList.Count &gt; x; x++) //      MyWall  //          ().      { List &lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt; allLenght = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;<span class="hljs-type"><span class="hljs-type">double</span></span>&gt;(); //   wallList[x].GetPointCenter(cash); //    .      <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (MyCacheWall nn <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> wallList) //       () { <span class="hljs-type"><span class="hljs-type">double</span></span> n = wallList[x].GetLenght( nn.GetPointCenter(cash) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n != <span class="hljs-number"><span class="hljs-number">0</span></span>) //      allLenght.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(n); //        } allLenght.Sort(); //   minPoints.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(allLenght[<span class="hljs-number"><span class="hljs-number">0</span></span>]); //      }//  } minPoints.Sort(); //    <span class="hljs-type"><span class="hljs-type">double</span></span> minPoint = minPoints[<span class="hljs-number"><span class="hljs-number">0</span></span>]; //      end = DateTime.Now; //    TimeSpan ts = (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ts.TotalMilliseconds.ToString() + " . " + "\n.    - " + (minPoint*<span class="hljs-number"><span class="hljs-number">304.8</span></span>).ToString(); }</code> </pre><br><br>  In the attached file, you will also find the WorkWithWall and WorkWithWallCashValue methods. <br>  The WorkWithWall method solves our problems in parallel and sequential mode, works directly with Revit API objects, but does not cache the calculation of the midpoint of the wall. <br><br>  The WorkWithWallCashValue method also solves our problems in parallel and sequential mode, it works directly with Revit API objects, but this method caches the calculation of the midpoint of the wall. <br><br>  Now we will create the main working method WallTesting: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> WallTesting () { Document doc = this.Document; //  Selection selection = this.Selection; //    ICollection&lt;ElementId&gt; selectedIds = this.Selection.GetElementIds(); //     TaskDialog.<span class="hljs-keyword"><span class="hljs-keyword">Show</span></span>("Revit", "*** ***\n" +"\n ,   - " + WorkWithWall(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) +"\n ,   - " + WorkWithWall(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) +"\n\n***    ***\n" +"\n ,   - " + WorkWithWallCashValue(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) +"\n ,   - " + WorkWithWallCashValue(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) +"\n\n***     ***\n" +"\n ,   - " + WorkWithWallCashParallel(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) +"\n ,   - " + WorkWithWallCashParallel(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) +"\n\n***       ***\n" +"\n ,   - " + WorkWithWallCashParallel(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) +"\n ,   - " + WorkWithWallCashParallel(doc, selectedIds, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) ); }</code> </pre> <br><br>  Now the work is completed, it remains to create about 2000 walls, run the macro and see how it works.  I did not make an exception handler, in case the walls are not highlighted before running the macro.  So, do not forget to select the walls first. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/509/a0d/14e/509a0d14edb02bb09c9df246f71b8474.jpg" alt="image"><br><br>  <b>findings</b> <br><br>  In general, we can draw quite interesting conclusions.  Let us take the benchmark with which we will compare everything, sequential processing of objects in a loop without any caching of intermediate results. <br><br>  It is obvious that it is unreasonable to process arrays of elements without saving the results of intermediate calculations (midpoint of the wall).  At the same time, the speed of parallel processing of Revit API elements directly compared to simple sequential processing of Revit API elements will decrease with an increase in the number of processed elements in the loop.  The difference reaches up to 6 times when processing a cycle of 2000 walls. <br><br>  If we cache the values ‚Äã‚Äãof intermediate calculations (we preserve the values ‚Äã‚Äãof the middle point of the wall), we will already get a substantial increase in speed, the calculations will become faster by 414 and 170 times with parallel and sequential processing of the walls of an array of 2000 walls. <br><br>  If we spend a little more time to create classes that cache the properties of the Revit API elements, we will also get a solid performance gain ‚Äî 212 and 80 times with parallel and sequential processing of our own classes.  However, the need to calculate the average point of the walls at each cycle pass remains a bottleneck of such a solution. <br>  But if you make classes that cache the properties of Revit objects, then you just need to make caching and intermediate values ‚Äã‚Äãof the calculations.  When such classes work in parallel and sequential mode, the difference compared to simple sequential processing of Revit API elements is 354 and 127 times. <br><br>  <b>Conclusion</b> <br><br>  In most cases, it is enough to think through the code properly and simply not to allow repeated calculations of the same values.  <b>Parallel computations will help to make such code 2 times faster, but it matters if you want to cycle more than a few thousand objects or perform complex computations in a loop.</b>  Obviously, it is not necessary to parallelize the calculations if there are only a couple of dozens of objects in the loop. <br><br>  If you are going to process a large number of Revit API objects, creating caching classes that preserve both object properties and intermediate values ‚Äã‚Äãwill not give a greater performance increase compared to working directly with Revit API objects (provided that intermediate calculations are cached for Revit API objects).  But with this approach, it may be easier to write code to calculate intermediate results. <br><br>  <b>PS:</b> If you want to experiment and see for yourself how different methods behave with different numbers of selected walls, I attached sample files.  This is the file "Test2000Wall.rvt" in which there are 2000 walls with a distance of 1000mm from each other (in the axes).  Top right, the distance between the walls in the axes of 700mm. <br><br>  The file "TestParallelWall.cs" is a ready macro for tests.  This macro processes 2,000 walls in approximately 12 minutes.  Obviously, you should not experiment with processing arrays of elements without saving the results of intermediate calculations.  To do this, a macro "TestLightParallelWall.cs" was created with the WorkWithWall method deleted.  This macro processes 2,000 walls in a few seconds. <br><br>  <a href="">bim3d.ru/fileadmin/images/user_upload/Test2000Wall.rvt</a> <br>  <a href="">bim3d.ru/fileadmin/images/user_upload/TestParallelWall.cs</a> <br>  <a href="">bim3d.ru/fileadmin/images/user_upload/TestLightParallelWall.cs</a> <br><br>  <b>PS.PS:</b> The first version of this article contained various inaccuracies and even misconceptions regarding parallel computations in Revit.  I beg your petition and post this more accurate version of the article. </div><p>Source: <a href="https://habr.com/ru/post/321816/">https://habr.com/ru/post/321816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321804/index.html">Acquaintance with Styled components</a></li>
<li><a href="../321808/index.html">Webinar: Introduction to Singularity</a></li>
<li><a href="../321810/index.html">The best architecture based on Docker and Kubernetes - myth or reality?</a></li>
<li><a href="../321812/index.html">Welcome to Tarantool Meetup March 2</a></li>
<li><a href="../321814/index.html">Check the open-source server World of Warcraft CMaNGOS</a></li>
<li><a href="../321818/index.html">Online store at 1C-Bitrix and box office: the requirements of the law 54-FZ</a></li>
<li><a href="../321820/index.html">Has MVC died for the frontend?</a></li>
<li><a href="../321822/index.html">Web animation: where, why and why</a></li>
<li><a href="../321824/index.html">The refactoring of the J.Money payment process - the awakening of force</a></li>
<li><a href="../321826/index.html">Getting to know the team of Java stack courses on Hexlet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>