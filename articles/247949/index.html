<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Questions about indexes that you do not need to ask</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After answering 14 questions about the indexes that you were embarrassed to ask , I had a lot more comments, clarifications and corrections. To compil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Questions about indexes that you do not need to ask</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9g/ig/w4/9gigw45e0huiizekceijopxqm5u.jpeg"></div><br><br>  After answering <a href="http://habrahabr.ru/post/247373/">14 questions about the indexes that you were embarrassed to ask</a> , I had a lot more comments, clarifications and corrections.  To compile from all this article looked like a venture with a minimum of benefit.  And it made me wonder, and why should we be ‚Äúashamed to ask‚Äù such questions at all?  Shame not to know?  Is there a way to figure it out without driving yourself into the paint?  There is.  And he will relieve from numerous inaccuracies that abound in many "answers."  You will feel literally every byte of your base with your fingertips. <br><br>  To do this, I propose to ‚Äúraise the hood‚Äù from SQL Server and plunge into the sweet world of hexadecimal dumps.  It may be that everything inside is much easier than you thought. <br><a name="habracut"></a><br><h2>  Preparing a workplace </h2><br>  In my experiments, I will use the free SQL Server 2014 Express Edition along with the usual Management Studio.  But almost all of the knowledge gained is rooted in SQL Server 7.0, originally from the nineties, and it will not be difficult to use the acquired skills in old installations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For most of the examples, we will need the included 3604. trace flag. I will not replicate it in each of them, but I assume that it is always on.  Just remember - if neither the dump nor the errors are visible, then add to the beginning of your code: <br><br><pre><code class="sql hljs">DBCC TRACEON(3604) GO</code> </pre> <br>  Some commands require an explicit database name.  In my case, it's ‚ÄúLab.‚Äù  If you have chosen a different identifier, do not forget to make the appropriate changes.  The same applies to some other values.  For example, the physical addresses of the pages may well be different.  I will try to remind you of this, but try to keep abreast of your code. <br><br>  Server responses often return a lot of fields or other data, of which only a small part of them will be of lively interest.  Since this is not about the SELECT command - adjusting the output is not easy.  Therefore, I will periodically cut off the excess, here and there.  Do not be surprised if you see a lot more data than me. <br><br><h2>  Page organization </h2><br>  In SQL Server, the basic structure for organizing data is a page of 8192 bytes (8KB or 8KiB, as you like).  It can be addressed by specifying the file code (FID - File ID), of which it is part (below we will see it in sys.database_files), and the page code (PID - Page ID) in this file.  We will write this address in the form of ‚ÄúFID: PID‚Äù.  For example, 1: 142 would mean page with code 142 in file with code 1. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> FID = file_id, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, physical_name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.database_files</code> </pre><br><pre> <code class="hljs pgsql">FID <span class="hljs-type"><span class="hljs-type">name</span></span> physical_name <span class="hljs-comment"><span class="hljs-comment">----------- --------------- ------------------- 1 Lab D:\Lab.mdf 2 Lab_log D:\Lab_log.ldf</span></span></code> </pre><br>  Pages of both cluster and ordinary indexes are organized in the form of trees (B-Tree).  Like any tree, it has a root (root node), leaves (leaf nodes) and intermediate nodes (intermediate nodes, but we can call them branches, continuing the vegetable analogy).  To make it easy to distinguish these elements from each other without visualizing, there is the concept of an index level.  Zero value means the level of leaves, the maximum - the root of the tree.  All that is between the branches. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/ks/cb/hmkscbporacjvl2f5la-jmoemro.png"></div><br><br>  Let's create a simple table for 1000 entries with a clustered index.  The first column will be a simple auto-increment field, the second will be the same value, but with a minus sign, the third will be a binary value 0x112233445566778, which is convenient to use as a marker in the dump. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> [dbo].[ClusteredTable] ( [<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>] [<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED, [A] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (-[<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>]) PERSISTED <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, [B] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">CONVERT</span></span>([<span class="hljs-built_in"><span class="hljs-built_in">binary</span></span>](<span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-number"><span class="hljs-number">0x1122334455667788</span></span>)) PERSISTED <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> [dbo].[ClusteredTable] <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>; GO 1000</code> </pre><br>  Now we will use the undocumented, but immortal DBCC IND command for paging autopsies.  The first argument is to specify the name or code of the database where the table is located.  The second is the name of this table (or the code of the corresponding object), the third is the index code.  There is a fourth optional parameter - partition code.  But it does not interest us in this context, in contrast to the index code, which I will discuss in more detail.  A value of 0 indicates that the Heap level is being requested.  In essence, this is a data layer with no indexes.  Number 1 is reserved for the cluster index (displayed along with the data, as in Heap).  In all other cases, you simply specify the code of the corresponding index.  Let's look at the cluster index of our table. <br><br><blockquote>  Since 2012, the DMV function sys.dm_db_database_page_allocations has been introduced.  It is somewhat more convenient to use, gives more detailed information and has a lot of other advantages.  All our examples can be easily reproduced using it. <br></blockquote><br><pre> <code class="sql hljs">DBCC IND('Lab', 'ClusteredTable', 1) GO</code> </pre><br><pre> <code class="hljs objectivec">PageFID PagePID IndexID PageType IndexLevel ------- ----------- ----------- -------- ---------- <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">78</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">77</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">79</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  As a server response, we get a list of index pages found.  The first columns are already familiar to us FID and PID, which together give the address of the page.  IndexID once again confirms that we are working with a cluster index.  The page type (PageType) with a value of 1 is data, 2 is index, 10 is IAM (Index Allocation Map), which has an indirect relation to indexes and we will ignore it.  Another friend of ours is the index level (IndexLevel).  By its maximum value, we see the root of the clustered index - page 1:79.  According to zero values ‚Äã‚Äã- leaves 1:77, 1:80, 1:89, 1:90. <br><br><h2>  Page structure </h2><br>  Mentally, we can already draw a tree of pages.  But this is easy to do only when we have two levels.  And they could be much more.  Therefore, researching the page itself is indispensable.  We start with the root and use another undocumented, but the same immortal command - DBCC PAGE. <br><br>  As the first argument, as well as DBCC IND, it takes the name or code of the base.  Next comes a pair of FID and PID of the page you are looking for.  The last value is the output format of the following available values: <br><br><ul><li>  0 - header only; </li><li>  1 - header, dumps and slot index; </li><li>  2 - header and full dump; </li><li>  3 - header and maximum detail for each slot. </li></ul><br>  In order not to explain the meaning of some terms in the abstract, just take a look at the root page dump (do not forget to substitute your page addresses): <br><br><pre> <code class="sql hljs">DBCC PAGE('Lab', 1, 79, 2) GO</code> </pre><br><pre> <code class="hljs erlang-repl">PAGE: (<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">79</span></span>) ... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A000: <span class="hljs-number"><span class="hljs-number">01020001</span></span> <span class="hljs-number"><span class="hljs-number">00800001</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000</span></span>b00 <span class="hljs-number"><span class="hljs-number">00000000</span></span> .................... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A014: <span class="hljs-number"><span class="hljs-number">00000400</span></span> <span class="hljs-number"><span class="hljs-number">78000000</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>c1f8c00 <span class="hljs-number"><span class="hljs-number">4</span></span>f000000 <span class="hljs-number"><span class="hljs-number">01000000</span></span> ....x...l.?.O....... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A028: <span class="hljs-number"><span class="hljs-number">23000000</span></span> cc000000 <span class="hljs-number"><span class="hljs-number">0e000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> #...I............... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A03C: <span class="hljs-number"><span class="hljs-number">9</span></span>dcd3779 <span class="hljs-number"><span class="hljs-number">01000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> .I7y................ <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A050: <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">06000000</span></span> .................... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A064: <span class="hljs-number"><span class="hljs-number">074</span></span>d0000 <span class="hljs-number"><span class="hljs-number">00010006</span></span> <span class="hljs-number"><span class="hljs-number">44010000</span></span> <span class="hljs-number"><span class="hljs-number">50000000</span></span> <span class="hljs-number"><span class="hljs-number">01000687</span></span> .M......D...P......? <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A078: <span class="hljs-number"><span class="hljs-number">02000059</span></span> <span class="hljs-number"><span class="hljs-number">00000001</span></span> <span class="hljs-number"><span class="hljs-number">0006</span></span>ca03 <span class="hljs-number"><span class="hljs-number">00005</span></span>a00 <span class="hljs-number"><span class="hljs-number">00000100</span></span> ...Y......E...Z..... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>A08C: <span class="hljs-number"><span class="hljs-number">00002121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> ..!!!!!!!!!!!!!!!!!! ... <span class="hljs-number"><span class="hljs-number">000000001431</span></span>BFE0: <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">21212121</span></span> !!!!!!!!!!!!!!!!!!!! <span class="hljs-number"><span class="hljs-number">000000001431</span></span>BFF4: <span class="hljs-number"><span class="hljs-number">21212121</span></span> <span class="hljs-number"><span class="hljs-number">81007600</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>b006000 !!!!..vk`. OFFSET TABLE: Row - Offset <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x3) - <span class="hljs-number"><span class="hljs-number">129</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x81) <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x2) - <span class="hljs-number"><span class="hljs-number">118</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x76) <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x1) - <span class="hljs-number"><span class="hljs-number">107</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x6b) <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x0) - <span class="hljs-number"><span class="hljs-number">96</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>x60)</code> </pre><br>  At this stage, I want to show the structure of the page as a whole, so I cut out most of the dump that does not affect this. <br><br>  It all starts with a 96-byte header, the end of which I noted in the output above with a break, so that it is more readable.  In everyday life it is not there.  Behind the heading are records with data called ‚Äúslots‚Äù (I did not begin to translate this term).  More precisely, they try to go after the title.  But the data in the database - a variable value.  Tuples are added, deleted, updated.  Therefore, they can be placed not immediately after the title, but completely in a chaotic order, with an interval after the title, and between the slots too. <br><br>  In order to control their current location, at the very end of the page is the index of these slots.  Each element occupies two bytes, stores the slot offset on the page as little-endian (that is, the latest value 0x6000 in our dump we read byte by bye backwards - 0x0060) and are numbered from the end.  The most recent is slot 0, in front of it slot 1 and so on.  The index of the slots and the data seem to move towards each other from different sides of the page.  The decryption of their index is given in the dump itself after the OFFSET TABLE header.  Compare it with the index dump at the end of the page - 81007600 6b006000. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t4/1q/xo/t41qxovit82x8eiqyr5el_ihcsy.png"></div><br><br><h2>  Record structure </h2><br>  Now let's take a look at the slots themselves in detail and for this we apply the output mode 1 for the DBCC PAGE instruction. <br><br><pre> <code class="sql hljs">DBCC PAGE('Lab', 1, 79, 1) GO</code> </pre><br><pre> <code class="hljs vhdl">... Slot <span class="hljs-number"><span class="hljs-number">0</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x60, Length <span class="hljs-number"><span class="hljs-number">11</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">11</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x0000000014B1A060 <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">06000000</span></span> <span class="hljs-number"><span class="hljs-number">074</span></span>d0000 <span class="hljs-number"><span class="hljs-number">000100</span></span> .....M..... Slot <span class="hljs-number"><span class="hljs-number">1</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x6b, Length <span class="hljs-number"><span class="hljs-number">11</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">11</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x0000000014B1A06B <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">06440100</span></span> <span class="hljs-number"><span class="hljs-number">00500000</span></span> <span class="hljs-number"><span class="hljs-number">000100</span></span> .D...P..... Slot <span class="hljs-number"><span class="hljs-number">2</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x76, Length <span class="hljs-number"><span class="hljs-number">11</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">11</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x0000000014B1A076 <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">06870200</span></span> <span class="hljs-number"><span class="hljs-number">00590000</span></span> <span class="hljs-number"><span class="hljs-number">000100</span></span> .?...Y..... Slot <span class="hljs-number"><span class="hljs-number">3</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x81, Length <span class="hljs-number"><span class="hljs-number">11</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">11</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x0000000014B1A081 <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">06</span></span>ca0300 <span class="hljs-number"><span class="hljs-number">005</span></span>a0000 <span class="hljs-number"><span class="hljs-number">000100</span></span> .E...Z..... ...</code> </pre><br>  These are the same four slots that we saw before, only their binary representation is cut from the page dump and served on a platter, which obviously will facilitate their further research. <br><br>  The first byte of each of them (0x06) contains information about the type of record.  More precisely, only bits 1‚Äì3 (in our case, 011b = 3) are responsible for it, which can take one of the following values: <br><br><ol><li>  0 - data; </li><li>  1/2 - forwarded / forwarding records; </li><li>  3 - index; </li><li>  4 - binary data (blob); </li><li>  5/6/7 - ghost entries for index / data / versions. </li></ol><br>  Since in our tests we will not see the zero bit set, we can safely say that the record describes the index if the low part of the byte is 0x06. <br><br>  In our case, the first byte is the key value for which the clustered index is built, followed by the page address in the slightly inverted PID: FID format.  That is, for slot 3 the key ID value will be 0xca030000 (970 in decimal form after the little-endian coup), the PID is 0x5a000000 (90), the FID is 0x0100 (1).  What can be translated as: "to search for records with ID from 970, go to page 1:90".  For slot 2, we get ID = 0x87020000 (647), PID = 59000000 (89), FID = 0x0100 (1).  And we read: "for entries with ID from 647 to 970 (which slot 3 already serves), follow page 1:89".  And so, all four slots send us to four pages, each for its own range of values.  We have already seen these four pages at the very beginning, when we have speculatively built a tree on the list of pages.  Look at the very first output of the DBCC IND command.  These are the same addresses as pages with leaf level data (PageType = 1, IndexLevel = 0). <br><br>  If our table were much larger, these records would refer to the pages of the intermediate level index (Index Level of the root minus one level).  And if we look for, say, the value ID = 743794, then in the root page we would get a slot, which is responsible for a sufficiently wide range of 700000-750000.  It would send us to a similar page, with the exception that there we would narrow the search range to slot 743000-744000.  Which, in turn, would have sent already to the page with the data where the records 743750-743800 are stored. <br><br><img src="https://habrastorage.org/webt/bz/e2/zt/bze2ztx2srywhkpzad6aekwcsk0.png"><br><br>  After talking about the data, let's go to page 1:89, serving values ‚Äã‚Äãfrom 657 to 970, which we just discovered. <br><br><pre> <code class="sql hljs">DBCC PAGE('Lab', 1, 89, 1) GO</code> </pre><br><pre> <code class="hljs vhdl">... Slot <span class="hljs-number"><span class="hljs-number">0</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x60, Length <span class="hljs-number"><span class="hljs-number">23</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = PRIMARY_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = NULL_BITMAP <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">23</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x0000000011F1A060 <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">10001400</span></span> <span class="hljs-number"><span class="hljs-number">87020000</span></span> <span class="hljs-number"><span class="hljs-number">79</span></span>fdffff <span class="hljs-number"><span class="hljs-number">11223344</span></span> <span class="hljs-number"><span class="hljs-number">55667788</span></span> ....?...yyyy.<span class="hljs-string"><span class="hljs-string">"3DUfw. 0000000000000014: 030000 ... Slot 1, Offset 0x77, Length 23, DumpStyle BYTE Record Type = PRIMARY_RECORD Record Attributes = NULL_BITMAP Record Size = 23 Memory Dump @0x0000000011F1A077 0000000000000000: 10001400 88020000 78fdffff 11223344 55667788 ........xyyy."</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>DUfw. <span class="hljs-number"><span class="hljs-number">0000000000000014</span></span>: <span class="hljs-number"><span class="hljs-number">030000</span></span> ... ...</code> </pre><br>  The data page is not fundamentally different from the pages with an index.  It's all the same title and the same slots with their index at the bottom of the page.  For example, I was limited to only a couple of first entries, on the dump of which we will go through a sequence. <br><br><ol><li>  0x10.  Record type with which you are already familiar.  Bits 1‚Äì3 give us a value of 0, which indicates a data page.  But the set bit 4 still pops up. It signals that the record has a NULL BITMAP bitmap, where one bit is assigned to each field of the table under study.  If this bit is set, it is considered that the value in the corresponding field is NULL. </li><li>  0x00.  The second byte is responsible for tricky ghosted-forwarded records, starting with SQL Server 2012, and we are not interested in it now. </li><li>  0x1400.  All types can be classified as types with fixed length and variable.  The most obvious example is binary (n) and varbinary (n).  Immediately after this, the values ‚Äã‚Äãwill go directly to the data with fixed-type types.  And it itself indicates what offset in the slot will begin the next piece of information.  The given value (namely, 20 in decimal form after a reversal from little-endian) = 2 (first bytes with types) + 2 (these bytes) + 4 (bytes to type int in the ID field) + 4 (bytes to the same type in field A) + 8 (byte on binary field B). </li><li>  0x87020000 / 88020000 are the values ‚Äã‚Äãof 647 and 648, which are, nothing more than the values ‚Äã‚Äãof the ID field.  Remember, earlier we wrote that slot 2 maintains records starting with ID = 647. That‚Äôs what they are. </li><li>  0xFFFFFD79 / 0xFFFFFD78 - and these are already the values ‚Äã‚Äãof the field "A" (-647, -648), which we calculated using the formula -ID. </li><li>  0x11223344 55667788 - a portion of the data logically completes our binary marker, which we defined for field B. </li><li>  0x0300 - the number of columns.  As expected - there are three (ID, A, B). </li><li>  0x00 - and this is the same NULL BITMAP, which I mentioned earlier.  Its length depends on the number of columns (bit per each) and is rounded to the nearest byte.  In our case, one byte will be enough to store three bits (for three ID, A, B fields).  Since we do not have NULL values, all bits are cleared. </li></ol><br><br><h2>  Normal indexes </h2><br>  Now, let's create in our table a regular, non-clustered index across field A and see how it differs from the cluster index. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> [IX_ClusteredTable] <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> [dbo].[ClusteredTable] ( [A] <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span></code> </pre><br>  Let's see which pages are involved and for this we indicate the code of the new index - 2. <br><br><pre> <code class="sql hljs">DBCC IND('Lab', 'ClusteredTable', 2) GO</code> </pre><br><pre> <code class="hljs objectivec">PageFID PagePID IndexID PageType IndexLevel ------- ----------- ----------- -------- ---------- <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">94</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">93</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">118</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">119</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Very familiar picture.  There are leaves-level pages, which we recognize by IndexLevel = 0. Only now they have type PageType = 2, that is, they are index pages, not pages with data.  There is a root node with the same IndexLevel = 1, PageType = 2. At its address 1: 119 we will continue further research. <br><br><pre> <code class="sql hljs">DBCC PAGE('Lab', 1, 119, 1) GO</code> </pre><br><pre> <code class="hljs vhdl">Slot <span class="hljs-number"><span class="hljs-number">0</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x60, Length <span class="hljs-number"><span class="hljs-number">15</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">15</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x000000001095A060 <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">0618</span></span>fcff ffe80300 <span class="hljs-number"><span class="hljs-number">005</span></span>d0000 <span class="hljs-number"><span class="hljs-number">000100</span></span> ..uyye...]..... Slot <span class="hljs-number"><span class="hljs-number">1</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x6f, Length <span class="hljs-number"><span class="hljs-number">15</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">15</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x000000001095A06F <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">065</span></span>afeff ffa60100 <span class="hljs-number"><span class="hljs-number">00760000</span></span> <span class="hljs-number"><span class="hljs-number">000100</span></span> .Z?yy¬¶...v.....</code> </pre><br>  And again, nothing fundamentally new.  The same title, the same slots.  Are these two slots that refer to the two pages (1:93, 1: 118) found above?  We decompose on the shelves.  The first byte with type 0x06 says that it is an index.  The last 6 bytes are PID: FID, which we already know how to disassemble.  After transformation into the usual format, we get exactly 1:93 (0x5d000000 0100) and 1: 118 (0x7600000000 0100).  But between them we are waiting for an interesting surprise.  For example, for slot 1, the values ‚Äã‚Äã0x5AFEFFFF and 0xA6010000 are nothing but -422 and 422. That is, in addition to the value of the field A, which we included in the index, it also contains the value of the cluster key ID. <br><br>  The rest of the scheme is similar to that observed in a cluster index.  The range from -1000 to -422 is served by page 1:93, from -422 to page 1: 118.  With the only exception that the clustered index we have referred to pages with data, and where does this one lead?  Let's go, we'll see. <br><br><pre> <code class="sql hljs">DBCC PAGE('Lab', 1, 118, 1) GO</code> </pre><br><pre> <code class="hljs vhdl">... m_pageId = (<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">118</span></span>) m_headerVersion = <span class="hljs-number"><span class="hljs-number">1</span></span> m_type = <span class="hljs-number"><span class="hljs-number">2</span></span> ... Slot <span class="hljs-number"><span class="hljs-number">0</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x60, Length <span class="hljs-number"><span class="hljs-number">12</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = NULL_BITMAP <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">12</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x000000001331A060 <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">165</span></span>afeff ffa60100 <span class="hljs-number"><span class="hljs-number">00020000</span></span> .Z?yy¬¶...... Slot <span class="hljs-number"><span class="hljs-number">1</span></span>, Offset <span class="hljs-number"><span class="hljs-number">0</span></span>x6c, Length <span class="hljs-number"><span class="hljs-number">12</span></span>, DumpStyle BYTE <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = INDEX_RECORD <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Attributes = NULL_BITMAP <span class="hljs-keyword"><span class="hljs-keyword">Record</span></span> Size = <span class="hljs-number"><span class="hljs-number">12</span></span> Memory Dump @<span class="hljs-number"><span class="hljs-number">0</span></span>x000000001331A06C <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span>: <span class="hljs-number"><span class="hljs-number">165</span></span>bfeff ffa50100 <span class="hljs-number"><span class="hljs-number">00020000</span></span> .[?yy?...... ...</code> </pre><br>  I deliberately left one line from the heading so that we could once again see that fate brought us to the index page (page type m_type = 2).  Everything else you probably already read joking.  Should not confuse even a new record type - 0x16, because it is 0x10 + 0x06.  The first term is bit 4 of the presence of NULL_BITMAP, which we saw on the data pages.  The second is the type of index. <br><br>  They are surely followed by the values ‚Äã‚Äã-422 (0x5AFEFFFF for slot 0) and -421 (0x5BFEFFFF for slot 1) from column A. We believe that the previous index level said that page 1: 118 works from -422.  These values ‚Äã‚Äãare followed by cluster keys (422, 421), which also do not surprise us.  And then - only the number of columns (0x0200) and NULL_BITMAP (0x00), as on data pages.  Note that there are no links to the data pages themselves. <br><br>  Did you know before that the usual index works through a cluster (if available, of course)?  And if you clustered on a large (especially natural) key, then you have the risk of getting bloated secondary indexes?  I hope no.  Also, they didn‚Äôt know much of this article, because then there is a lot of sense in it :) <br><br>  I want to think that now, you will be wary of statements with style: ‚ÄúAn important characteristic of a clustered index is that all values ‚Äã‚Äãare sorted in a certain order, either increasing or decreasing‚Äù from the article mentioned at the beginning.  Knowing that the location of the pages is unknown, that orderliness on the page is determined by the slots index, it is a stretch to talk only about quasi-orderliness.  And better that the cluster index ... clusters.  Yes, he does it perfectly.  You know exactly which pages have a data cluster from X to Y. <br><br>  I would like to hope that now you can, with pleasure from the work done, explore the work of the indices with Heap.  Find answers to the questions: ‚Äúis the GUID good for a clustered index,‚Äù ‚Äúhow does page split work in such cases,‚Äù ‚Äúdoes UNIQUIFIER look like,‚Äù ‚Äúis the Heap true faster for insertion?‚Äù And many others on your own. conditions. Returning to the title of the article, "you will not need to ask them." <br><br>  See you soon under the hood, I hope you like this process. </div><p>Source: <a href="https://habr.com/ru/post/247949/">https://habr.com/ru/post/247949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247935/index.html">About input [type = range], the multiple parameter and how to make everything work</a></li>
<li><a href="../247939/index.html">Customization of workflows in YouTrack. My experience tweaking YouTrack as HelpDesk</a></li>
<li><a href="../247943/index.html">The outgoing voice era</a></li>
<li><a href="../247945/index.html">The first report from the project Devuan</a></li>
<li><a href="../247947/index.html">Manual installation of complex boards on components 0402, 0603, QFN, LQFP and THT</a></li>
<li><a href="../247951/index.html">Unity3D Editor: Tips and Tricks</a></li>
<li><a href="../247953/index.html">Automation of building information protection systems in accordance with the order of FSTEC ‚Ññ21</a></li>
<li><a href="../247957/index.html">Pretend smart</a></li>
<li><a href="../247959/index.html">Mathematics Management, with emoticons</a></li>
<li><a href="../247961/index.html">Why relational DBMSs are great for startups: An example from the history of the development of Kato messenger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>