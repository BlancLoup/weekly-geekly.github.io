<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Determine the weight of chess pieces by regression analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 

 This article focuses on a small programmer etude on machine learning. His idea came to me during the passage of the Machine Learning c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Determine the weight of chess pieces by regression analysis</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/54a/41c/ddb/54a41cddb26a65d98a05c4fcde9bf9eb.jpg" align="right">  Hello, Habr! <br><br>  This article focuses on a small programmer etude on machine learning.  His idea came to me during the passage of the <a href="https://www.coursera.org/learn/machine-learning">Machine Learning</a> course, which is well-known to many here, read by Andrew Ng on Curser.  After becoming acquainted with the methods described in the lectures, I wanted to apply them to some real problem.  It did not take long to search for a topic - as the subject area, it simply suggested an optimization of one‚Äôs own chess engine. <br><br><h3>  Introduction: about chess programs </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/fe2/f43/090/fe2f4309061f637bb0622e6e0781c982.jpg" align="left"><br>  We will not go deep into the architecture of chess programs in detail - this could be the subject of a separate publication or even a series of them.  Consider only the most basic principles.  The main components of almost any non-protein chess player are the <i>search</i> and <i>evaluation of positions</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The search is a search of options, that is, an iterative deepening of the game tree.  The evaluation function displays a set of positional signs on a numerical scale and serves as a target function for finding the best move.  It is applied to the leaves of a tree, and gradually ‚Äúreturns‚Äù to its original position (root) using the <a href="https://chessprogramming.wikispaces.com/Alpha-Beta">alpha-beta procedure</a> or its variations. <br><br>  Strictly speaking, <i>this</i> score can take only three values: win, lose or draw - 1, 0 or ¬Ω.  By <a href="https://en.wikipedia.org/wiki/Zermelo%2527s_theorem_%2528game_theory%2529">the Zermelo theorem,</a> for any given position, it is uniquely determined.  In practice, due to a combinatorial explosion, no computer is able to calculate the variants to the leaves of a complete game tree (an exhaustive analysis in endgame databases is a separate case; 32-figured tables will not appear in the foreseeable future ... and in the boundless, most likely, also).  Therefore, the programs work in the so-called <i>Shannon model</i> ‚Äî they use a truncated game tree and an approximate estimate based on various heuristics. <br><a name="habracut"></a><br>  Search and evaluation do not exist independently of each other, they must be well balanced.  Modern reboring algorithms are no longer a ‚Äúblunt‚Äù search of options; they include numerous special rules, including those related to position evaluation. <br><br>  The first such search enhancements appeared at the dawn of chess programming, in the 60s of the 20th century.  We can mention, for example, the technique of the <i>forced variant (PV)</i> - the extension of individual branches of the search until the position ‚Äúcalms down‚Äù (the shahs and mutual taking of figures are completed).  Extensions significantly increase the tactical vigilance of a computer, and also lead to the fact that the search tree becomes very heterogeneous - the length of individual branches can be several times longer than the length of neighboring, less prospective.  Other improvements to the search, on the contrary, represent a <i>cutoff</i> or <i>reduction of the search</i> - and here the same static assessment can serve as a criterion for discarding bad options. <br><br>  Parameterization and improvement of search by machine learning methods is a separate interesting topic, but now we will leave it aside.  For now let's deal only with the evaluation function. <br><br><h3>  How the computer evaluates the position </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/af0/9c9/5c3/af09c95c30d256cb470644731b576d02.jpg" width="150" align="right">  A static score is a linear combination of various attributes of a position, taken with some weights.  What are these signs?  First of all, the number of pieces and pawns on both sides.  The next important sign is the position of these figures, centralization, the occupation of long-range figures with open lines and diagonals.  Experience shows that taking into account only these two factors - the sum of the material and the relative value of the fields (fixed in the form of tables for each type of figures) - if there is a quality search, it can already provide the strength of the game in the range up to 2000-2200 Elo points.  This is the level of a good first grade or master candidate. <br><br>  Further refinement of the assessment may include more and more subtle signs of the chess position: the presence and advancement of the passing pawns, the proximity of the pieces to the position of the enemy king, his pawn cover, etc. function <a href="http://chessprogramming.wikispaces.com/Kaissa">of several dozen signs</a> .  All of them are described in detail in the book The Machine Plays Chess, the bibliographic reference to which is given at the end of the article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/575/b7b/725575b7b28335fcef266f9bfb645e15.jpg" width="180" align="left"><br>  One of the most "clever" evaluation functions was at the car Deep Blue, famous for its matches with Kasparov in 1996-97.  (You can read a detailed history of these matches in a recent <a href="http://geektimes.ru/post/241538/">series of articles on Geektimes</a> .) <br><br>  It is widely believed that the power of Deep Blue was based solely on the tremendous speed of searching through the options.  200 million positions per second, complete (without cut-offs) enumeration by 12 half-moves - the chess programs on modern hardware are just approaching such parameters.  However, it was not only speed.  In terms of the "chess knowledge" in the evaluation function, this machine is also far superior to all.  Deep Blue score was implemented in hardware and included up to 8,000 different signs.  Strong grandmasters were attracted to adjust its coefficients (it is reliably known about working with Joel Benjamin, test batches with different versions of the machine were played by David Bronstein). <br><br>  Without having such resources as creators of Deep Blue, we will limit the task.  Of all the signs of the position that are taken into account for the calculation of the assessment, we take the most significant - the ratio of the material on the board. <br><br><h3>  The cost of figures: the simplest models </h3><br>  If you take any chess book for beginners, immediately after the chapter with a description of the chess moves is usually given a table of the comparative value of the figures, something like this: <br><table><tbody><tr><th>  Type of </th><th>  Cost of </th></tr><tr><td>  Pawn </td><td>  one </td></tr><tr><td>  Horse </td><td>  3 </td></tr><tr><td>  Elephant </td><td>  3 </td></tr><tr><td>  Rook </td><td>  five </td></tr><tr><td>  Queen </td><td>  9 </td></tr><tr><td>  King </td><td>  ‚àû </td></tr></tbody></table>  The king is sometimes credited with the final cost, obviously greater than the sum of all the material on the board ‚Äî for example, 200 units.  In this study, we will leave His Majesty alone, and we will not consider kings at all.  Why?  The answer is simple: they are always present on the board, so their material values ‚Äã‚Äãare mutually subtracted, and they do not affect the overall balance of power. <br><br>  Given the value of the figures should be considered only as some basic benchmarks.  In reality, the pieces may ‚Äúbecome more expensive‚Äù and ‚Äúcheaper‚Äù depending on the situation on the board, as well as on the stage of the game.  As a first-order amendment, combinations of two or three figures ‚Äî one‚Äôs own and one‚Äôs opponent‚Äôs are usually considered. <br><br>  This is how the third world champion <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D0%25BF%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B0%25D0%25BD%25D0%25BA%25D0%25B0,_%25D0%25A5%25D0%25BE%25D1%2581%25D0%25B5_%25D0%25A0%25D0%25B0%25D1%2583%25D0%25BB%25D1%258C">Jos√© Raul Capablanca</a> evaluated various combinations of material in his classic ‚ÄúChess Game Tutorial‚Äù: <br><br><blockquote><img src="https://habrastorage.org/getpro/habr/post_images/ab6/83b/8d5/ab683b8d524b41ba252d4ecd23ba9dcd.jpg" width="250" align="right" title="Jos√© Raul Capablanca" alt="- ">  <i>From the point of view of the general theory, the elephant and the horse should be considered equally valuable, although, in my opinion, the elephant in most cases turns out to be a stronger figure.</i>  <i>Meanwhile, it is considered quite established that two bishops are almost always stronger than two horses.</i> <i><br><br></i>  <i>The bishop in the game against pawns is stronger than the knight, and together with the pawns it also turns out to be stronger against the rook than the knight.</i>  <i>The bishop and the rook are also stronger than the knight and the rooks, but the queen and knight may turn out to be stronger than the queen and bishop.</i>  <i>An elephant often costs more than three pawns, but this is rarely said about a horse;</i>  <i>he may even be weaker than three pawns.</i> <i><br><br></i>  <i>The rook is equal in strength to the knight and two pawns, or to the bishop and two pawns, but, as mentioned above, the bishop is stronger than the knight in the fight against the rook.</i>  <i>Two rooks are somewhat stronger than the queen.</i>  <i>They are slightly weaker than two horses and an elephant and even weaker than two elephants and a horse.</i>  <i>The power of the horses decreases as the exchange of pieces on the board, the power of the rooks, on the contrary, increases.</i> <i><br><br></i>  <i>Finally, as a rule, three light pieces are stronger than a queen.</i> </blockquote><br><br>  It turns out that most of these rules can be satisfied by remaining within the linear model, and simply slightly shifting the value of the figures from their "school" values.  For example, <a href="http://chessprogramming.wikispaces.com/Simplified%2Bevaluation%2Bfunction">in one of the articles</a> the following boundary conditions are given: <br><br><pre><code class="bash hljs">B &gt; N &gt; 3P B + N = R + 1.5P Q + P = 2R</code> </pre> <br>  And values ‚Äã‚Äãsatisfying them: <br><br><pre> <code class="bash hljs">P = 100 N = 320 B = 330 R = 500 Q = 900 K = 20000</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/3b2/796/83d/3b279683d6c5835fb58f0fbe6fcf0253.jpg" width="350" align="right"><br>  <i>The names of the variables correspond to the designations of pieces in the English notation: P - pawn, N - knight, B - bishop, R - rook, Q - queen, K - king.</i>  <i>The costs hereinafter are indicated in hundredths of a pawn.</i> <br><br>  In fact, this set of values ‚Äã‚Äãis not the only solution.  Moreover, even non-compliance with some of the ‚Äúinequalities to them.  Capablanca will not lead to a sharp drop in the strength of the game of the program, but only affect its style features. <br><br>  As an experiment, I spent a small match-tournament of four versions of my <a href="http://greko.su/">GreKo</a> engine with different weights of figures against three other programs - each version played 3 matches for 200 games with ultra-small time control (1 second + 0.1 seconds per turn).  The results are shown in the table: <br><br><table><tbody><tr><th>  Version </th><th>  Pawn </th><th>  Horse </th><th>  Elephant </th><th>  Rook </th><th>  Queen </th><th>  vs.  Fruit 2.1 </th><th>  vs.  Crafty 23.4 </th><th>  vs.  Delfi 5.4 </th><th>  Rating </th></tr><tr><td>  GreKo 12.5 </td><td>  100 </td><td>  400 </td><td>  400 </td><td>  600 </td><td>  1200 </td><td>  61.0 </td><td>  76.0 </td><td>  71.0 </td><td>  2567 </td></tr><tr><td>  Greko a </td><td>  100 </td><td>  300 </td><td>  300 </td><td>  500 </td><td>  900 </td><td>  55.0 </td><td>  69.0 </td><td>  73.0 </td><td>  2552 </td></tr><tr><td>  Greko b </td><td>  100 </td><td>  320 </td><td>  330 </td><td>  500 </td><td>  900 </td><td>  57.0 </td><td>  71.0 </td><td>  64.0 </td><td>  2548 </td></tr><tr><td>  Greko c </td><td>  100 </td><td>  325 </td><td>  325 </td><td>  550 </td><td>  1100 </td><td>  72.5 </td><td>  74.5 </td><td>  69.0 </td><td>  2575 </td></tr></tbody></table>  We see that some variations in the scales of the figures lead to fluctuations in the strength of the game in the range of 20-30 points of Elo.  Moreover, one of the test versions showed an even better result than the main version of the program.  However, it is premature to unequivocally assert that the game is being enhanced on such a small number of games - the confidence interval for calculating the rating is a comparable amount of several dozen Elo points. <br><br>  The ‚Äúclassic‚Äù values ‚Äã‚Äãof chess material were obtained intuitively, by the chess players understanding their practical experience.  Attempts have also been made to bring some mathematical basis for these values ‚Äã‚Äã- for example, on the basis of the mobility of figures, the number of fields that they can keep under control.  We will try to approach the question experimentally - based on the analysis of a large number of chess games.  To calculate the value of figures, we <i>do not need an</i> approximate assessment of the positions of these parties - only their results, as the most objective measure of success in chess. <br><br><h3>  Material overweight and logistic curve </h3><br>  For statistical analysis, a PGN file was taken, containing almost 3000 chess games in a blitz between 32 different chess engines, in the range from 1800 to 3000 Elo points.  With the help of a specially written utility for each game, a list of material relationships arising on the board was compiled.  Each correlation of the material did not fall into the statistics immediately after the capture of a piece or the transformation of a pawn - first, there should have been a reciprocal capture or several "quiet" moves.  Thus, short-term ‚Äúmaterial jumps‚Äù were filtered by 1-2 turns during exchanges. <br><br>  Then, using the scale ‚Äú1-3-3-5-9‚Äù already known to us, the material balance of the position was calculated, and for each of its values ‚Äã‚Äã(from -24 to 24), the number of points scored by White was accumulated.  The statistics obtained are presented in the following graph: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/668/e64/f36/668e64f369bcd78d665eb9fb6eee22ec.png"><br><br>  On the x-axis, the material balance of the ŒîM position from the point of view of White, in pawns.  It is calculated as the difference between the total value of all white pieces and pawns and the same value for black.  On the y axis, the sample is the expected result of the game (0 is Black‚Äôs victory, 0.5 is a draw, 1 is White‚Äôs victory).  We see that the experimental data are very well described by the <i>logistic curve</i> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/905/fad/43a/905fad43a469fd3bd6cc30fc9921a5de.png" alt="p(\Delta M)=\frac{1}{1+e^{-\alpha \Delta M}}" title="p (\ Delta M) = \ frac {1} {1 + e ^ {- \ alpha \ Delta M}}"><br><br>  A simple visual selection allows you to define a curve parameter: <i>Œ± = 0.7</i> , its dimension is reverse pawns. <br>  For comparison, the graph shows two more logistic curves with different values ‚Äã‚Äãof the parameter <i>Œ±</i> . <br><br>  What does this mean in practice?  Suppose we see a randomly chosen position in which White has an advantage of 2 pawns ( <i>ŒîM = 2</i> ).  With a probability close to 80%, we can say: the game will end in white victory.  Similarly, if White lacks an bishop or a knight ( <i>ŒîM = -3</i> ), their chances of not losing are only about 12%.  Positions with material equality ( <i>ŒîM = 0</i> ), as one would expect, most often end in a draw. <br><br><h3>  Formulation of the problem </h3><br>  Now we are ready to formulate an optimization problem for the evaluation function in terms of logistic regression. <br>  Let us be given a set of vectors of the following form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f6/516/b7d/1f6516b7dd4eee59bddf36ceea2602ad.png" alt="x_j=(\Delta_P,\Delta_N,\Delta_B,\Delta_R,\Delta_Q)_j" title="x_j = (\ Delta_P, \ Delta_N, \ Delta_B, \ Delta_R, \ Delta_Q) _j"><br><br>  where <i>Œîi, i = P ... Q</i> is the difference between the number of white and black pieces of type <i>i</i> (from pawn to queen, we do not count the king).  These vectors are material ratios that are encountered in batches (several vectors usually correspond to one batch). <br><br>  Let also the vector <i>y <sub>j</sub></i> be given, the components of which take the values ‚Äã‚Äã0, 1 and 2. These values ‚Äã‚Äãcorrespond to the outcomes of the games: 0 - Black wins, 1 - Draw, 2 - White wins. <br><br>  It is required to find the vector of figures <i>Œ∏</i> value: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a2/33f/4bb/1a233f4bb378d094af1ef66205fd2f1a.png" alt="\theta=(\theta_P, \theta_N, \theta_B, \theta_R, \theta_Q)" title="\ theta = (\ theta_P, \ theta_N, \ theta_B, \ theta_R, \ theta_Q)"><br><br>  minimizing cost function for logistic regression: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/173/1cc/a03/1731cca030c122aef66c4d2ee08fc495.png" alt="J(\theta)=\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}log(h_\theta(x^{(i)}))+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]" title="J (\ theta) = \ frac {1} {m} [sum_ {i = 1} ^ {m} y ^ {(i)} log (h_ \ theta (x ^ {(i)})) + ( 1-y ^ {(i)}) log (1-h_ \ theta (x ^ {(i)}))]">  , <br>  Where <br><img src="https://habrastorage.org/getpro/habr/post_images/c1a/c1c/634/c1ac1c63472566dbdb184a4a9eda51b5.png" alt="h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}" title="h_ \ theta (x) = \ frac {1} {1 + e ^ {- \ theta ^ Tx}}">  - logistic function for vector argument. <br><br>  To prevent "retraining" and the effects of instability in the found solution, the regularization parameter can be added to the cost function, which does not give the coefficients in the vector to take too large values: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c2/b0f/9ac/3c2b0f9ac67f82aeca95b2a3bc9a042a.png" alt="J_{reg}(\theta)=J(\theta)+\frac{\lambda}{2m}\sum_{j=1}^{5}{\theta_j^2}" title="J_ {reg} (\ theta) = J (\ theta) + \ frac {\ lambda} {2m} \ sum_ {j = 1} ^ {5} {\ theta_j ^ 2}"><br><br>  The value of the coefficient for the regularization parameter is chosen small, in this case the value <i>Œª = 10 <sup>-6 was used</sup></i> . <br><br>  To solve the minimization problem, we apply the simplest method of gradient descent with a constant step: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6f/9ba/54e/e6f9ba54e3d783599d2ce26cfac8c796.png" alt="\theta_{n+1}\leftarrow \theta_n - \alpha \nabla J_{reg}(\theta_n)" title="\ theta_ {n + 1} \ leftarrow \ theta_n - \ alpha \ nabla J_ {reg} (\ theta_n)"><br><br>  where the components of the gradient function <i>J <sub>reg</sub></i> have the form: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ee/9c7/3ae/6ee9c73ae79647b6db2477dc20d918b3.png" alt="(\nabla J_{reg})_0=\frac{1}{m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)})-y^{(i)})x_0^{(i)}}" title="(\ nabla J_ {reg}) _ 0 = \ frac {1} {m} \ sum_ {i = 1} ^ {m} {(h _ {\ theta} (x ^ {(i)}) - y ^ {( i)}) x_0 ^ {(i)}}"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/90f/462/9d4/90f4629d435b0f026193a1d4aebb1125.png" alt="(\nabla J_{reg})_j=\frac{1}{m}\sum_{i=1}^{m}{(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}} - \frac{\lambda}{m}{\theta_j}" title="(\ nabla J_ {reg}) _ j = \ frac {1} {m} \ sum_ {i = 1} ^ {m} {(h _ {\ theta} (x ^ {(i)}) - y ^ {( i)}) x_j ^ {(i)}} - \ frac {\ lambda} {m} {\ theta_j}"><br><br>  Since we are looking for a symmetric solution, with material equality giving the probability of the outcome of the party ¬Ω, the zero coefficient of the vector <i>Œ∏ is</i> always set to zero, and for the gradient we only need the second of these expressions. <br><br>  We will not consider the derivation of the above formulas here.  For those interested in their rationale, I strongly recommend the already mentioned <a href="https://www.coursera.org/learn/machine-learning">course on machine learning</a> on Coursera. <br><br><h3>  Program and Results </h3><br>  Since the first part of the task - parsing PGN-files and highlighting a set of attributes for each position - was already practically implemented in the chess engine code, the remaining part was also decided to write in C ++.  The source code of the program and test batches of batches in PGN files <a href="https://github.com/WinPooh/pgnlearn">are available on github</a> .  The program can be built and run under Windows (MSVC) or Linux (gcc). <br><br>  The ability to use in the future, specialized tools like Octave, MATLAB, R, etc.  it is also provided for - in the course of its work, the program generates an intermediate text file with feature sets and batch outcomes, which can easily be imported into these environments. <br><br>  The file contains a textual representation of a set of vectors <i>x <sub>j</sub></i> - a matrix of dimension <i>mx (n + 1)</i> , the first 5 columns of which contain the components of material balance (from pawn to queen), and in the 6th, the result of the game. <br><br>  Consider a simple example.  Below is a PGN record of one of the test batches. <br><br><pre> <code class="bash hljs">[Event <span class="hljs-string"><span class="hljs-string">"OpenRating 31"</span></span>] [Site <span class="hljs-string"><span class="hljs-string">"BEAR-HOME"</span></span>] [Date <span class="hljs-string"><span class="hljs-string">"2013.05.09"</span></span>] [Round <span class="hljs-string"><span class="hljs-string">"1"</span></span>] [White <span class="hljs-string"><span class="hljs-string">"Simplex 0.9.7"</span></span>] [Black <span class="hljs-string"><span class="hljs-string">"IvanHoe 999946f"</span></span>] [Result <span class="hljs-string"><span class="hljs-string">"0-1"</span></span>] [TimeControl <span class="hljs-string"><span class="hljs-string">"60+1"</span></span>] [PlyCount <span class="hljs-string"><span class="hljs-string">"96"</span></span>] 1. d4 d5 2. c4 e6 3. e3 c6 4. Nf3 Nd7 5. Nbd2 Nh6 6. e4 Bb4 7. a3 Ba5 8. cxd5 exd5 9. exd5 cxd5 10. Qe2+ Kf8 11. Qb5 Nf6 12. Bd3 Qe7+ 13. Kd1 Bb6 14. Re1 Bd7 15. Qb3 Be6 16. Re2 Qc7 17. Qb4+ Kg8 18. Nb3 Bf5 19. Bb1 Bxb1 20. Rxb1 Nf5 21. Bd2 a5 22. Qa4 h6 23. Rc1 Qb8 24. Bxa5 Qf4 25. Qb4 Bxa5 26. Nxa5 Kh7 27. Nxb7 Rab8 28. a4 Ne4 29. h3 Rhc8 30. Ra1 Rc7 31. Qa3 Rcxb7 32. g3 Qc7 33. Rc1 Qa5 34. Rxe4 dxe4 35. Rc5 Qa6 36. Nd2 Nxd4 37. Rc4 Nb3 38. Nxb3 Qxc4 39. Nd2 Rd8 40. Qc3 Qf1+ 41. Kc2 Qe2 42. f4 e3 43. b4 Rc7 44. Kb3 Qd1+ 45. Ka2 Rxc3 46. Nb1 Qxa4+ 47. Na3 Rc2+ 48. Ka1 Rd1<span class="hljs-comment"><span class="hljs-comment"># 0-1</span></span></code> </pre> <br>  The corresponding fragment of the intermediate file is: <br><br><pre> <code class="bash hljs"> 0 0 0 0 0 0 1 0 0 0 0 0 2 0 0 0 0 0 2 -1 0 0 0 0 2 0 0 -1 0 0 1 0 0 -1 0 0 1 1 0 -2 0 0</code> </pre> <br>  In the 6th column, 0 is the result of the game everywhere, Black wins.  In the remaining columns - the balance of the number of pieces on the board.  In the first line, the full material equality, all components are equal to 0. The second line is White's extra pawn, this is the position after the 24th move.  Let's pay attention that the previous exchanges are not reflected in any way, they happened too quickly.  After the 27th move, White already has 2 extra pawns - this is line 3. And so on.  Before Black‚Äôs final attack on White‚Äôs pawn and knight for two rooks: <br><br><img src="http://kasparovchess.crestbook.com/extensions/chess_diagram/gendiag.php?fen=3r4/2r2ppk/7p/8/PP3P2/1KQ1p1PP/3Nq3/8&amp;size=29&amp;style=alpha" title="3r4 / 2r2ppk / 7p / 8 / PP3P2 / 1KQ1p1PP / 3Nq3 / 8" alt="3r4/2r2ppk/7p/8/PP3P2/1KQ1p1PP/3Nq3/8"><br><br>  As well as exchanges in the opening, the final moves in the game did not affect the contents of the file.  They were eliminated by the ‚Äúfilter tactic‚Äù because they were a series of takeovers, shahs and departures from them. <br><br>  The same records are created for all analyzed games, on average 5-10 lines per game are obtained.  After parsing the PGN base with batches, this file arrives at the input of the second part of the program, which deals with the actual minimization problem. <br><br>  As a starting point for gradient descent, you can, for example, take a vector with the values ‚Äã‚Äãof the weights of the figures from the textbook.  But it is more interesting not to give any prompts to the algorithm, and start from scratch.  It turns out that our cost function is rather ‚Äúgood‚Äù - the trajectory quickly, in a few thousand steps, goes to the global minimum.  How the cost of the pieces changes is shown in the following graph (each step was normalized to the weight of the pawn = 100): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc4/a8b/d3d/dc4a8bd3d99f307a4baac960d64ec666.png"><br><br><div class="spoiler">  <b class="spoiler_title">Graph of the convergence of the cost function</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/660/606/e4e6606063dd1e7fa9eb6e5657dc1886.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Text output of the program</b> <div class="spoiler_text"><pre> <code class="bash hljs">C:\CHESS&gt;pgnlearn.exe OpenRating.pgn Reading file: OpenRating.pgn Games: 2997 Created file: OpenRating.mat Loading dataset... [ 20196 x 5 ] Solving (gradient method)... Iter 0: [ 0 0 0 0 0 ] -&gt; 0.693147 Iter 1000: [ 0.703733 1.89849 2.31532 3.16993 6.9148 ] -&gt; 0.470379 Iter 2000: [ 0.735853 2.08733 2.51039 3.47418 7.7387 ] -&gt; 0.469398 Iter 3000: [ 0.74429 2.13676 2.56152 3.55386 7.95879 ] -&gt; 0.46933 Iter 4000: [ 0.746738 2.15108 2.57635 3.57697 8.02296 ] -&gt; 0.469324 Iter 5000: [ 0.747467 2.15535 2.58077 3.58385 8.0421 ] -&gt; 0.469324 Iter 6000: [ 0.747685 2.15663 2.58209 3.58591 8.04785 ] -&gt; 0.469324 Iter 7000: [ 0.747751 2.15702 2.58249 3.58653 8.04958 ] -&gt; 0.469324 Iter 8000: [ 0.747771 2.15713 2.58261 3.58672 8.0501 ] -&gt; 0.469324 Iter 9000: [ 0.747777 2.15717 2.58265 3.58678 8.05026 ] -&gt; 0.469324 Iter 10000: [ 0.747779 2.15718 2.58266 3.58679 8.0503 ] -&gt; 0.469324 PIECE VALUES: Pawn: 100 Knight: 288.478 Bishop: 345.377 Rook: 479.66 Queen: 1076.56 Press ENTER to finish</code> </pre> </div></div><br>  After normalization and rounding, we obtain the following set of values: <br><table><tbody><tr><th>  Type of </th><th>  Cost of </th></tr><tr><td>  Pawn </td><td>  100 </td></tr><tr><td>  Horse </td><td>  288 </td></tr><tr><td>  Elephant </td><td>  345 </td></tr><tr><td>  Rook </td><td>  480 </td></tr><tr><td>  Queen </td><td>  1077 </td></tr><tr><td>  King </td><td>  ‚àû </td></tr></tbody></table>  Check whether the "rules of Capablanca"? <br><table><tbody><tr><th>  Ratio </th><th>  Numerical values </th><th>  Performed? </th></tr><tr><td>  <font color="#088A29">B&gt; n</font> </td><td>  <font color="#088A29">345&gt; 288</font> </td><td>  <font color="#088A29">Yes</font> </td></tr><tr><td>  <font color="#088A29">B&gt; 3P</font> </td><td>  <font color="#088A29">345&gt; 3 * 100</font> </td><td>  <font color="#088A29">Yes</font> </td></tr><tr><td>  <font color="#DF0101">N&gt; 3P</font> </td><td>  <font color="#DF0101">288 &lt;3 * 100</font> </td><td>  <font color="#DF0101">not</font> </td></tr><tr><td>  <font color="#088A29">B + N = R + 1.5P</font> </td><td>  <font color="#088A29">345 + 288 ~ = 480 + 1.5 * 100</font> </td><td>  <font color="#088A29">yes (with an error of &lt;0.5%)</font> </td></tr><tr><td>  <font color="#DF0101">Q + P = 2R</font> </td><td>  <font color="#DF0101">1077 + 100&gt; 2 * 480</font> </td><td>  <font color="#DF0101">not</font> </td></tr></tbody></table>  The result is quite encouraging.  Not knowing anything about the events actually taking place on the board, considering only the outcomes of the games and the material removed from the board, our algorithm managed to derive the values ‚Äã‚Äãof the figures that are close enough to their traditional values. <br><br>  Can the obtained values ‚Äã‚Äãbe used to enhance the game program?  Alas, at this stage the answer is negative.  The test blitz matches show that the strength of the game GreKo practically did not change from the use of the parameters found, and in some cases even decreased.  Why did it happen?  One of the obvious reasons is the already mentioned close connection between the search and the position evaluation.  The search engine has a whole range of heuristics for cutting off unpromising branches, and the criteria for these cutups (threshold values) are closely tied to a static estimate.  Changing the cost of the figures, we dramatically shift the scale of the values ‚Äã‚Äã- the shape of the search tree changes, new balancing of the constants for all heuristics is required.  This is quite a time consuming task. <br><br><h3>  Experiment with lots of people </h3><br>  Let's try to expand our experiment, having considered games not only computers, but also people.  As a data set for training, we take the games of two outstanding modern grandmasters - world champion <a href="http://www.pgnmentor.com/players/Carlsen/">Magnus Carlsen</a> and ex-champion <a href="http://www.pgnmentor.com/players/Anand/">Anand Viswanathan</a> , as well as the representative of the 19th century romantic chess <a href="http://www.pgnmentor.com/players/Anderssen/">Adolf Andersen</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a62/a43/18c/a62a4318ca63f8a5e17c42c1bd75864f.jpg" width="400" title="Anand and Carlsen" alt="  "><br>  <i>Anand and Carlsen vie for world crown</i> <br><br>  The table below presents the results of solving the regression problem for the games of these chess players. <br><table><tbody><tr><th></th><th>  Anand </th><th>  Carlsen </th><th>  Andersen </th></tr><tr><td>  Pawn </td><td>  100 </td><td>  100 </td><td>  100 </td></tr><tr><td>  Horse </td><td>  216 </td><td>  213 </td><td>  286 </td></tr><tr><td>  Elephant </td><td>  230 </td><td>  243 </td><td>  289 </td></tr><tr><td>  Rook </td><td>  355 </td><td>  352 </td><td>  531 </td></tr><tr><td>  Queen </td><td>  762 </td><td>  786 </td><td>  1013 </td></tr><tr><td>  King </td><td>  ‚àû </td><td>  ‚àû </td><td>  ‚àû </td></tr></tbody></table>  It is easy to see that the ‚Äúhuman‚Äù values ‚Äã‚Äãof the figures were not at all what beginners teach in textbooks.  In the case of Carlsen and Anand, a smaller scale of the scale is striking - the queen costs just over 7.5 pawns, respectively, the entire range for other pieces shrank.  The bishop is still a bit more expensive than the knight, but he and the other do not reach the traditional three pawns.  Two rooks are weaker than a queen, etc. <br><br>  It must be said that a similar picture is observed not only in Vichy and Magnus, but also for the majority of grandmasters, whose parties were able to be tested.  And some dependence on the style was not found.  Values ‚Äã‚Äãare shifted from the classical ones in the same direction both for positional masters like Mikhail Botvinnik and Anatoly Karpov, and for attacking chess players - Mikhail Tal, Judit Polgar ... <br><br>  One of the few exceptions was Adolf Andersen - the best European player of the mid-XIX century, the author of the famous <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D1%2583%25D0%25B2%25D1%258F%25D0%25B4%25D0%25B0%25D0%25B5%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25B0%25D1%2580%25D1%2582%25D0%25B8%25D1%258F">"evergreen party"</a> .  Here for him the values ‚Äã‚Äãof the figures were very close to those that use computer programs.  A variety of fantastic hypotheses are being suggested, such as the secret cheating of the German maestro through a portal in time ... (Joke, of course. Adolf Andersen was an extremely decent person, and would never allow himself that to happen.) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/2d7/763/ab42d77635459e6bebf194d437383452.jpg" title="Adolf Andersen" alt=" "><br>  <i>Adolf Andersen (1818-1879),</i> <i><br></i>  <i>computer man</i> <br><br>  Why is there such an effect with compression of the figure value range?  Of course, we should not forget about the extreme limitations of our model - the consideration of additional positional factors could make significant adjustments.  But, probably, the matter is in the weak technique of realizing the material advantage by a person - relatively modern chess programs, of course.  Simply put, it is hard for a person to play the queen without error, because he has too many possibilities.  I recall a textbook anecdote about Lasker (in other versions - Capablanca / Alekhine / Tale), who allegedly played with a handicap with an occasional fellow traveler on the train.  The culmination phrase was: "The Queen only hinders!" <br><br><h3>  Conclusion </h3><br>  We considered one of the aspects of the evaluation function of chess programs - the cost of the material.  We made sure that this part of the static estimate in the Shannon model has a completely ‚Äúphysical‚Äù meaning - it is smoothly connected (via a logistic function) with the probability of the outcome of the batch.  Then we looked at several common combinations of the weights of the figures, and assessed the order of their influence on the strength of the game of the program. <br><br>  With the help of the regression apparatus on the games of various chess players, both live and computer, we determined the optimal values ‚Äã‚Äãof the pieces under the assumption of a purely material evaluation function.  They found an interesting effect of lower material cost for people compared to machines, and ‚Äúsuspected cheating‚Äù of one of the chess classics.  We tried to apply the values ‚Äã‚Äãfound in the real engine and ... did not achieve much success. <br><br>  Where to go next?  For a more accurate assessment of the position, you can add new chess knowledge to the model - that is, increase the dimension of the vectors <i>x</i> and <i>Œ∏</i> .  Even staying in the area of ‚Äã‚Äãonly material criteria (without taking into account the fields occupied by pieces on the board), you can add a number of relevant attributes: two bishops, a pair of queen and a knight, a pair of rook and bishop, multi-colored, the last pawn in the endgame ... Chess players are well known how the value of the figures may depend on their combination or stage of the party.  In chess programs, the corresponding weights (bonuses or penalties) can reach tenths of a pawn or more. <br><br>  One of the possible ways (along with an increase in the sample size) is to use for training the games played by the previous version of the same program.  In this case, there is hope for greater consistency of some evaluation features with others.  It is also possible to use, as a function of cost, not the success of predicting the outcome of the game (which may end in a few dozen moves after the position under consideration), but the correlation of the static estimate with the dynamic one ‚Äî that is,  with the result of alpha-beta search to a certain depth. <br><br>  However, as noted above, for the direct enhancement of the game program, the results obtained may be unsuitable.  It often happens like this: after training in a series of tests, the program begins to better <i>solve the tests</i> (in our case, to predict the results of the games), but it is not <i>better to play</i> !  At present, intensive testing has become mainstream in chess programming exclusively in a practical game.  New versions of top engines before release are tested on tens and hundreds of thousands of games with ultrashort time controls ... <br><br>  In any case, I plan to conduct a series of experiments on the statistical analysis of chess games.  If this topic is of interest to the Habr audience, if you receive any non-trivial results, the article can be continued. <br><br>  <i>In the course of research, no chess piece has suffered.</i> <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/c29/575/f37c29575343ce9bdd5de7145bfde4c4.jpg" width="400"><br><h3>  Bibliography </h3><br>  <b>Adelson-Velsky, G.M .;</b>  <b>Arlazarov, V.L .;</b>  <b>Bitman, A.R.</b>  <b>and others. - The machine plays chess.</b>  M .: Science, 1983 <br>  The book of the authors of the Soviet program "Kaissa", describing in detail both the general algorithmic foundations of chess programs, and specific details of the implementation of the evaluation function and the search for "Kaissa". <br><br>  <b>Kornilov E. - Programming chess and other logic games.</b>  SPb .: BHV-Petersburg, 2005 <br>  A more modern and "practical" book, contains a large number of code examples. <br><br>  <b>Feng-hsiung Hsu - Behind Deep Blue.</b>  Princeton University Press, 2002 <br>  The book is one of the creators of the chess machine Deep Blue, in detail telling about the history of its creation and internal structure.  The appendix contains texts of all chess games played by Deep Blue in official competitions. <br><br><h3>  Links </h3><br>  <a href="http://chessprogramming.wikispaces.com/">The Chessprogramming Wiki</a> is an extensive collection of materials on all the theoretical and practical aspects of chess programming. <br><br>  <a href="http://satirist.org/learn-game/">Machine Learning in Games</a> is a website dedicated to machine learning in games.  Contains a large number of scientific articles on research in the field of chess, checkers, go, reversi, backgammon, etc. <br><br>  <a href="http://chessprogramming.wikispaces.com/Kaissa">Kaissa</a> is a page dedicated to Kaissa.  The coefficients of its evaluation function are presented in detail. <br><br>  <a href="https://stockfishchess.org/">Stockfish</a> is the strongest open source software today. <br><br>  <a href="https://chessprogramming.wikispaces.com/file/view/RYBKA_FRUIT_Mar11.pdf">A comparison of Rybka 1.0 beta and Fruit 2.1</a> <br>  Detailed comparison of the internal structure of two popular chess programs. <br><br>  <a href="http://greko.su/">GreKo</a> - chess program author of the article. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was used as one of the sources of test computer batches. </font><font style="vertical-align: inherit;">Also, based on its move generator and parser PGN-notation, a utility was made for analyzing experimental data. </font></font><br><br> <a href="https://github.com/WinPooh/pgnlearn"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pgnlearn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - utility code and sample files with batches on github.</font></font></div><p>Source: <a href="https://habr.com/ru/post/254753/">https://habr.com/ru/post/254753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254741/index.html">Traffic Inspector: full reboot</a></li>
<li><a href="../254743/index.html">Stepic seeking talents</a></li>
<li><a href="../254747/index.html">Comparison of deep learning libraries on the example of the handwriting numbers classification problem</a></li>
<li><a href="../254749/index.html">Bubot is a very easy Python 3 framework for robot programming and home automation.</a></li>
<li><a href="../254751/index.html">How Wheatfield Diffie helped Bob and Alice trick Eve</a></li>
<li><a href="../254755/index.html">From complex to simple: the evolution of interfaces of mobile trading terminals</a></li>
<li><a href="../254757/index.html">We write the postal address, as humans</a></li>
<li><a href="../254759/index.html">Genetic algorithm - visual implementation</a></li>
<li><a href="../254761/index.html">Universal Remote for Arduino</a></li>
<li><a href="../254763/index.html">We get acquainted with Fabric.js. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>