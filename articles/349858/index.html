<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS Works: Service Workers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[We advise you to read] Other 19 parts of the cycle  Part 1: Overview of the engine, execution time mechanisms, call stack 
 Part 2: About the V8 inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS Works: Service Workers</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br>  Here is a translation of the eighth part of a series of materials about the features of the work of various JavaScript mechanisms.  Today‚Äôs article is about service workers.  Here we look at their features, talk about their life cycle, their support in browsers, and scenarios for their use. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/349858/"><img src="https://habrastorage.org/webt/0i/lg/0h/0ilg0h51095uecpt1xtynfx3os4.jpeg"><br></a> <a name="habracut"></a><br><h2>  <font color="#3AC1EF">Progressive web applications</font> </h2><br>  Progressive web applications are likely to become more and more popular.  They are aimed at ensuring that the user perceives them not as regular web pages, but as something like classic desktop applications that work normally, regardless of whether the computer is connected to the Internet or not. <br><br>  From here comes one of the basic requirements for progressive web applications, which is to ensure their reliable operation when there is no or unstable network connection.  Service workers are an important technical part of implementing similar application behavior. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e0/43e/c4c/4e043ec4cd0310a0879349f12d4dd3dd.jpg"></div><br>  <i><font color="#999">Application, service worker, cache and network resources</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here you can see a simplified diagram of the relationship between an application, a service worker, a cache managed by a service worker, and network resources.  Ideally, proper organization of the application interaction with the service worker and cache will allow the user to work normally with the application even without connecting to the network. <br><br><h2>  <font color="#3AC1EF">Features of service workers</font> </h2><br>  If you want to learn how <a href="https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API">service workers</a> should study, you should look at the <a href="https://habrahabr.ru/company/ruvds/blog/348424/">previous</a> material in this series, which is dedicated to web workers.  In general, it can be said that service workers are a type of web workers, or more precisely, they are similar to <a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker">shared workers</a> .  In particular, the following important features of service workers can be identified: <br><br><ul><li> They run in their own global context, <code>ServiceWorkerGlobalScope</code> . <br></li><li>  They are not tied to a specific page. <br></li><li>  They do not have access to the DOM. <br></li></ul><br>  ServiceWorkers API deserves special attention for the reason that it allows applications to support offline work scenarios, giving the programmer complete control over how the application interacts with external resources. <br><br><h2>  <font color="#3AC1EF">Service Worker Life Cycle</font> </h2><br>  The life cycle of a service worker has nothing to do with the life cycle of a web page.  It includes the following steps: <br><br><ul><li>  Loading <br></li><li>  Installation <br></li><li>  Activation <br></li></ul><br><h3>  <font color="#3AC1EF">‚ñçDownload</font> </h3><br>  At this stage of the life cycle, the web browser loads a <code>.js</code> file containing the code of the service worker. <br><br><h3>  <font color="#3AC1EF">‚ñçInstallation</font> </h3><br>  In order to install a service worker, you first need to register it.  This is done in javascript code.  When the service worker is registered, the browser is prompted to run the installation in the background. <br><br>  By registering a service worker, you tell the web browser where its <code>.js</code> file is located.  Take a look at the following code: <br><br><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'serviceWorker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navigator) { window.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   navigator.serviceWorker.register(<span class="hljs-string"><span class="hljs-string">'/sw.js'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(registration)</span></span></span></span> {     //       console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'ServiceWorker registration successful'</span></span>);   }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {     //         console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'ServiceWorker registration failed: '</span></span>, err);   }); }); }</code> </pre> <br>  It checks whether the Service Worker API is supported in the current environment.  If this API is supported, then the service worker <code>/sw.js</code> . <br><br>  The <code>register()</code> method can be easily called every time the page loads.  The browser will independently find out if the corresponding service worker has already been registered and will correctly process the repeated request for registration. <br><br>  An important feature in working with the <code>register()</code> method is the location of the service worker file.  In this case, you can see that the service worker file is located in the root of the domain.  As a result, the service domain will be the entire domain.  In other words, this service worker will receive <code>fetch</code> events (which we will discuss below) generated by all pages from this domain.  Similarly, if you register a service worker file located at <code>/example/sw.js</code> , this service worker will only see <code>fetch</code> events from pages whose URL starts with <code>/example/</code> (i.e., for example, <code>/example/page1/</code> , <code>/example/page2/</code> ). <br><br>  During the installation of the service worker, it is recommended to load and cache static resources.  After caching, the installation of the web worker will be successfully completed.  If the download fails, it will automatically attempt to reinstall.  As a result, after successful installation of the web worker, the developer can be sure that all the necessary static materials are in the cache. <br><br>  All this illustrates the fact that it is impossible to say that it is absolutely necessary that the registration of the web worker takes place after the <code>load</code> event, but it is recommended to do this. <br><br>  Why?  Imagine that a user first opens a web application.  At this moment, the service worker for this application has not yet been loaded; moreover, the browser cannot find out in advance whether the application will use the service worker.  If the service worker is installed, the browser will need to spend additional system resources.  These resources would otherwise go on rendering the web page.  As a result, the launch of the service worker installation process may delay the loading and output of the page.  Usually, the developers strive to show the working page of the application to the user as soon as possible, but in our case the application cannot work normally without a service worker. <br><br>  Please note that the above reasoning makes sense only when talking about the first visit to the page.  If, after installing the service worker, the user visits the same page again, re-installation will not be performed, which means that the speed of the working page will not be affected.  After the first visit to the application page, the service worker will be activated, as a result, it will be able to handle loading and caching events on subsequent visits to the web application.  As a result, the application will be ready to work in a limited network connection. <br><br><h3>  <font color="#3AC1EF">‚ñçActivation</font> </h3><br>  After installing the service worker, we proceed to the next stage of its life cycle - activation.  At this step, the developer has the opportunity to work with the data that was cached earlier. <br><br>  After activation, the service worker will be able to manage all the pages that fall within his scope.  It is worth noting that the service worker‚Äôs mechanisms will not act on the page that registered it until this page is reloaded. <br><br>  After the service worker receives control, he may be in one of the following states: <br><br><ul><li>  Event handling  The service worker awaits the arrival of <code>fetch</code> and <code>message</code> events that occur when the pages make network requests or send messages.  When an event arrives, the service worker processes it. <br></li><li>  Stop.  The system stops the service worker to save resources. <br></li></ul><br>  Here is the life cycle of the service worker: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d14/f3c/8cd/d14f3c8cd452c63eb7a2330d7c575bf1.png"></div><br>  <i><font color="#999">Service Worker Life Cycle</font></i> <br><br><h2>  <font color="#3AC1EF">Processing the installation process inside the service worker</font> </h2><br>  A service worker, after the registration process was launched, is able to influence what is happening.  In particular, we are talking about the <code>install</code> event handler in the service worker code. <br><br>  Here's what the service worker needs to do when handling the <code>install</code> event: <br><br><ul><li>  Open cache. <br></li><li>  Put in the cache the necessary materials. <br></li><li>  Confirm caching of all required materials. <br></li></ul><br>  Here is a simple example of handling an <code>install</code> event in a service worker: <br><br><pre> <code class="hljs lua">var CACHE_NAME = <span class="hljs-string"><span class="hljs-string">'my-web-app-cache'</span></span>; var urlsToCache = [ <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/styles/main.css'</span></span>, <span class="hljs-string"><span class="hljs-string">'/scripts/app.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'/scripts/lib.js'</span></span> ]; self.addEventListener(<span class="hljs-string"><span class="hljs-string">'install'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> { // event.waitUntil    ,  , //    ,   //    . event.waitUntil(   caches.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(CACHE_NAME)     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cache)</span></span></span></span> {       console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Opened cache'</span></span>);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache.addAll(urlsToCache);     }) ); });</code> </pre> <br>  If all materials are successfully cached, this means a successful installation of the service worker.  If something fails to load, then the installation will be declared invalid.  Therefore, you should pay special attention to what data you want to put in the cache. <br><br>  It should be noted here that handling the <code>install</code> event inside the service worker is optional. <br><br><h2>  <font color="#3AC1EF">Working with the cache during the execution of the application</font> </h2><br>  This is where the fun begins.  This is where we will look at the mechanisms for intercepting requests, returning cached data and caching new materials. <br><br>  After the service worker is installed and the user moves to another page of the application or refreshes the page on which it is located, the service worker will start receiving <code>fetch</code> events.  Here is an example that shows how to return cached content or execute new queries, and then cache the result: <br><br><pre> <code class="hljs lua">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> { event.respondWith(   //        //            //  - .   caches.<span class="hljs-built_in"><span class="hljs-built_in">match</span></span>(event.request)     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span></span> {       //     ,  ,      .       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;       }       //  .     -  ,       //       .       //          ,       //      ,   ,       //     .       var fetchRequest = event.request.clone();             //     ,     ,       //          ,        // ,  ,     .       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(fetchRequest).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(         <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span></span> {           //  ,                <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!response || response.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> !== <span class="hljs-number"><span class="hljs-number">200</span></span> || response.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> !== <span class="hljs-string"><span class="hljs-string">'basic'</span></span>) {             <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;           }           //   ,      .           //    ,     ,           //    ,   ,           //        .           var responseToCache = response.clone();           caches.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(CACHE_NAME)             .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cache)</span></span></span></span> {               //       .               cache.put(event.request, responseToCache);             });           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;         }       );     })   ); });</code> </pre> <br>  Here is what happens in general: <br><br><ul><li>  The <code>event.respondWith()</code> construct defines how we will respond to the <code>fetch</code> event.  We pass from <code>caches.match()</code> promise that analyzes the request and finds out if there are any cached responses to the similar request stored in any of the created caches. <br></li><li>  If the cache finds what you need, the answer is retrieved from it. <br></li><li>  If no match is found in the cache, the <code>fetch</code> operation is performed. </li><li>  The status of the response is checked (we need status 200).  In addition, we check the type of response that should be equal to <code>basic</code> , which indicates that this is a request from our domain.  Requests for materials from third-party sources will not be cached in this case. <br></li><li>  The answer is added to the cache. <br></li></ul><br>  Request and response objects must be cloned, as they are <a href="https://streams.spec.whatwg.org/">streams</a> .  The stream can be processed only once.  However, both the service worker and the browser need to work with these threads. <br><br><h2>  <font color="#3AC1EF">Service Worker Update</font> </h2><br>  When a user visits a web application, the browser tries to reload the <code>.js</code> file that contains the code of the service worker.  This process is performed in the background. <br><br>  If there is even the smallest difference between the service worker file that was downloaded and the current file, the browser will decide that there are changes in the worker code.  This means that the application should use a new service worker. <br><br>  The browser will start this new service worker and raise the <code>install</code> event.  However, at this moment, the old worker is still responsible for the interaction of the application with the outside world.  Therefore, the new service worker will be in a state of waiting. <br><br>  After the current open page of the web application is closed, the old service worker will be stopped by the browser, and the newly installed service worker will have full control over what is happening.  At this point, its <code>activate</code> event will be <code>activate</code> . <br><br>  Why is all this necessary?  In order to avoid the problem of having two versions of a web application running simultaneously in different browser tabs.  This, in fact, is quite common, and the situation in which different tabs are controlled by different web workers can cause serious errors (for example, using different data schemes for local information storage). <br><br><h2>  <font color="#3AC1EF">Deleting cache data</font> </h2><br>  When processing the <code>activate</code> event of a new version of the service worker, they usually work with the cache.  In particular, old caches are deleted here.  If you do this earlier, during the installation of a new worker, the old service worker will not be able to work normally. <br><br>  Here is an example of how you can delete files from the cache that were not placed in the white list (in this case, the white list is represented by <code>page-1</code> and <code>page-2</code> entries): <br><br><pre> <code class="hljs lua">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'activate'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> { var cacheWhitelist = [<span class="hljs-string"><span class="hljs-string">'page-1'</span></span>, <span class="hljs-string"><span class="hljs-string">'page-2'</span></span>]; event.waitUntil(   //     .   caches.keys().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cacheNames)</span></span></span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.all(       //     .       cacheNames.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cacheName)</span></span></span></span> {         //         ,         //   .         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cacheWhitelist.indexOf(cacheName) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) {           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caches.delete(cacheName);         }       })     );   }) ); });</code> </pre> <br><h2>  <font color="#3AC1EF">Using HTTPS</font> </h2><br>  During the development of a web application, service workers will normally work on <code>localhost</code> , but after the release of the application in production you will need to use HTTPS (perhaps, if you are not using HTTPS yet, this is a very good reason to improve the situation). <br><br>  A service worker who is not HTTPS protected is subject <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D1%2582%25D0%25B0%25D0%25BA%25D0%25B0_%25D0%25BF%25D0%25BE%25D1%2581%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0">to intermediary attacks</a> , since an attacker can intercept connections and create fake responses to application requests.  That is why, in order to make the system safer, the developer must register service workers on the pages that are served via HTTPS.  In particular, it gives confidence that the service worker loaded into the browser was not modified during the transmission of its code over the network. <br><br><h2>  <font color="#3AC1EF">Browser support</font> </h2><br>  While the situation with the <a href="https://caniuse.com/">support of</a> service workers browsers is not perfect, but it is improving: <br><br><div style="text-align:center;"> <a href="https://lh6.googleusercontent.com/352_EjjjNui8j7lMxvXkYqtDqHY_QKV-oeR6RwxRrcN36GoIXc9tcsX06YqgKqvB7fSMcdes6ea72Zb3Z7IoDSg_u3PuaBZwE3jONmTSS2i851E0Sx3FiPizPGmiYXQ1glE65ITCsS-3TpbPHQ"><img src="https://habrastorage.org/getpro/habr/post_images/145/37a/1ac/14537a1ac97a1f8148df6c49ecb030dd.png"></a> </div><br>  <i><font color="#999">Support for service workers in browsers</font></i> <br><br>  <a href="https://jakearchibald.github.io/isserviceworkerready/">Here</a> you can watch the process of introducing support for API service workers to browsers. <br><br><h2>  <font color="#3AC1EF">Usage scenarios</font> </h2><br>  Service workers open the way for great web application features.  Here are some of them: <br><br><ul><li>  Push notifications.  They allow users to configure periodic notifications coming from web applications. <br></li><li>  Background sync.  This mechanism makes it possible to postpone the execution of certain actions until the user has a stable connection to the Internet.  When using the background synchronization system, the developer can be sure that if the user, say, wants to save changes to a document edited in a web application without access to the network, these changes will not be lost. <br></li><li>  Periodic synchronization (expected feature).  This is an API that provides functionality for managing periodic background synchronization. <br></li><li>  Work with geofences (expected opportunity).  This feature allows the application to provide the user with useful functionality based on its geographic location, and, in particular, based on the events of a user‚Äôs entry into a predetermined area. <br></li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Service workers are a promising technology that is the basis for progressive web applications.  This technology, as well as its individual capabilities, is not yet supported by all browsers, but we have every reason to expect an improvement in the situation.  Therefore, it is possible that in the foreseeable future, service worker talents will be able to fully open up in all leading browsers, giving developers new tools and ideas. <br><br>  Previous parts of a series of articles: <br><br>  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">How JS Works: About V8 Inside and Code Optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">How JS works: memory management, four types of memory leaks and how to deal with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">How JS works: event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">How JS: WebSocket and HTTP / 2 + SSE work.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">How JS Works: Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">How JS Works: Web Workers and Five Use Cases</a> <br><br>  <b>Dear readers!</b>  Which scenarios for using service workers in your projects seem most interesting to you? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/349858/">https://habr.com/ru/post/349858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349840/index.html">iPaaS - cloud ESB ... or not?</a></li>
<li><a href="../349842/index.html">Check Point Technical Support (TAC). Quick Start Guide</a></li>
<li><a href="../349844/index.html">Microsatellites for Earth Remote Sensing</a></li>
<li><a href="../349852/index.html">Extension methods for .NET standard library types</a></li>
<li><a href="../349854/index.html">Migrate API and what it eat. On the example of the migration of the forum Drupal 7. Part 1</a></li>
<li><a href="../349860/index.html">Regular expressions in Python from simple to complex. Details, examples, pictures, exercises</a></li>
<li><a href="../349862/index.html">Application Release Automation: Release Management Automation "Goes to the Cloud"</a></li>
<li><a href="../349864/index.html">Natasha - a library for extracting structured information from texts in Russian</a></li>
<li><a href="../349866/index.html">W3View - straight web UI path</a></li>
<li><a href="../349868/index.html">Changes in the Java 10 Standard Library</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>