<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SDAccel - check data transfer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article ‚ÄúSDAccel - first acquaintance‚Äù I tried to describe the basics of using OpenCL on Xilinx FPGAs. Now it is time to share the res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SDAccel - check data transfer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/5ab/3c0/22c/5ab3c022cece4d2b9ca5c8c6a757bae2.png"><br><br>  In the previous article <a href="https://habrahabr.ru/post/326628/">‚ÄúSDAccel - first acquaintance‚Äù</a> I tried to describe the basics of using OpenCL on Xilinx FPGAs.  Now it is time to share the results of experiments on data transfer on the ADM-PCIe-KU3 module.  Data transfer in both directions is checked.  The source code of the programs is posted on GitHub: <a href="https://github.com/dsmv/sdaccel">https://github.com/dsmv/sdaccel</a> <a name="habracut"></a><br><br><h1 id="apparatura">  Equipment </h1><br><p>  All experiments were performed on Alpha-Data module ADM-PCIe_KU3. </p><br><img src="https://habrastorage.org/web/d3f/244/84d/d3f24484d24d40e5b34873ab8042913a.jpg"><br><p>  The central element is the FPGA Xilinx Kintex UltraScale KU060 <br>  Two SODIMM DDR3-1600 modules are connected to the FPGA;  The memory width is 72 bits, this makes it possible to use a memory controller with error correction. </p><br><p>  It is possible to connect two QSFP modules.  Each QSFP module is four bidirectional lines with a transmission rate of up to 10 Gbit / s.  This makes it possible to use 1G, 10G, 40G Ethernet, including the implementation of Low-Latency Network Card.  There is also an interesting feature - entering the second label from the GPS receiver.  But in this paper, all this is not used. </p><br><h1 id="server-nimbix">  NIMBIX server </h1><br><p>  The NIMBIX server provides various computing services, including the SDAccel development environment and, more importantly, the execution of the program on the selected hardware module. </p><br><h1>  Calculator model </h1><br><p>  I want to remind you what the OpenCL system is. </p><br><img src="https://habrastorage.org/files/742/e33/750/742e337501ad4a1cbd972ac86c0b5ccb.png"><br><p>  The system consists of HOST computer and computer, which are interconnected by bus.  In this case, it is PCI Express v3.0 x8; </p><br><p>  Application software consists of two parts: </p><br><ul><li>  Program HOST computer. </li><li>  One or more functions to work on the computer. </li></ul><br><p>  Data exchange takes place only through global memory, in this case it is two SODIMM modules. </p><br><p>  The application software requires infrastructure that someone must provide.  In this case, the company Xilinx.  The infrastructure includes: </p><br><ul><li>  opencl library - implementation of OpenCL standard functions. </li><li>  module driver - provides interaction with the module. </li><li>  DSA package.  This is the basis for developing your own firmware FPGA. </li></ul><br><p>  The DSA package contains basic firmware, which includes controllers for PCI Express, dynamic memory, and possibly for other nodes.  The basic firmware contains an element called OpenCL Region.  It is within this element that all the functions of the OpenCL kernels will be implemented.  Firmware uploads into OpenCL Regions are done via PCI Express using Partial Reconfiguration technology.  It should be noted that Xilinx has greatly advanced in download speed.  If in previous versions the download took a few minutes, then what is now about 5 seconds.  And in version 2017.2 it is announced that it is possible not to reload the firmware at all. </p><br><p>  Currently, there are two packages available for the ADM-PCIe-KU3 as part of the SDAccel package: </p><br><ul><li>  xilinx: adm-pcie-ku3: 2ddr: 3.3 </li><li>  xilinx: adm-pcie-ku3: 2ddr-xpr: 4.0 </li></ul><br><p>  Both packages have support for two memory controllers and PCI Express v3.0 x8;  Note the suffix -xpr.  This is quite an important distinction.  Option without xpr fixes the position of DDR controllers and PCI Express.  The version with xpr captures only the position of PCI Express, and the DDR controllers are involved in tracing OpenCL application functions.  This difference leads to differences in results.  A variant without xpr is divorced faster, and a variant with xpr can get a more optimal trace.  For this project, it turned out 1 hour 11 minutes for the option without xpr and 1 hour 32 minutes for the option xpr.  Logs <a href="https://github.com/dsmv/sdaccel/wiki/note_07---compare-2ddr%253A3.3-and-2ddr%253A4.0-xpr">here</a> . </p><br><p>  By the way, each DSA package includes its own driver. </p><br><h1 id="programma-check_transfer">  Program CHECK_TRANSFER </h1><br><p>  The program is designed to test the continuous transmission of data in three modes: </p><br><ul><li>  From FPGA to SODIM and to computer </li><li>  From computer to SODIMM and to FPGA </li><li>  Simultaneous transmission in two directions </li></ul><br><p>  In my opinion, checking the speed of work without checking the data does not make much sense.  Therefore, using OpenCL, I implemented a FPGA node for the test sequence generator and a test sequence for the test sequence node. </p><br><p>  The OpenCL standard provides for the exchange between a device and a computer only through the device‚Äôs global memory.  This is usually SODIMM dynamic memory.  And here a very interesting question arises about the possibility of transferring data with speed limits.  On the ADM-PCIe-KU3 module, two SODIM DDR3-1600 are applied.  The exchange rate for one SODIMM is about 10 GB / s.  The exchange rate on the bus PCI Express v3.0 x8 - about 5 GB / s (so far it turned out much less).  Those.  It is possible to write into memory one block coming from PCI Express and simultaneously read the second block for processing inside the FPGA.  What to do if you still need to return the result?  PCI Express provides bidirectional streaming at high speed.  But the memory has one bus, and the speed will be divided between reading and writing.  This is where the second SODIMM is needed.  We have the opportunity to specify in which module the buffer will be placed for processing. </p><br><h1 id="operacionnaya-sistema">  operating system </h1><br><p>  SDAccel can only work under some Linux systems.  In the list of available systems CentOS 6.8, CentOS 7.3, Ubuntu 16.04, RedHat 6.8, RedHat 7.3;  The first experiments I started on CentOs 6.7;  Then I tried to use Ubuntu 16.04, but it didn‚Äôt work there.  At the moment I am using CentOS 7.3 and am very pleased with this system.  However, when setting up SDAccel there are a number of subtleties.  The main problem is that the default network interface name is ‚Äúenp6s0‚Äù.  This name does not understand the Xilinx license server.  He needs the usual ‚Äúeth0‚Äù. <br>  Setting up here: <a href="">https://github.com/dsmv/sdaccel/wiki/note_04---Install-CentOS-7-and-SDAccel-2017.1</a> </p><br><p>  Qt 5.9.1 is installed but not working.  It requires a newer gcc and git compiler.  This is also solved, the details here: <a href="">https://github.com/dsmv/sdaccel/wiki/note_05---Install-Qt-5.9.1-and-Git-2.9.3</a> </p><br><h1 id="sistemy-razrabotki">  Development systems </h1><br><p>  For development I use two systems: </p><br><ul><li>  SDAccel 2017.1 - for the development of kernel and small test programs HOST </li><li>  Qt 5.9.1 - for developing more complex programs.  Qt is used only for developing HOST programs. </li></ul><br><h1 id="organizaciya-proekta-na-github">  Project organization on GitHub </h1><br><p>  The <a href="https://github.com/dsmv/sdaccel"><strong>dsmv / sdaccel repository is</strong></a> designed to develop examples for SDAccel.  At the moment there is only one program check_transfer.  The project uses a number of GitHub features: </p><br><ul><li>  <a href="https://github.com/dsmv/sdaccel">README.md</a> - the first file that is visible to the visitor. </li><li>  <a href="https://github.com/dsmv/sdaccel/wiki">WiKi</a> - program description </li><li>  <a href="https://github.com/dsmv/sdaccel/wiki/Development-Notes">Development Notes</a> - notes on development </li><li>  <a href="https://github.com/dsmv/sdaccel/issues">Issues</a> - task list </li><li>  <a href="https://github.com/dsmv/sdaccel/projects">Projects</a> - project management </li><li>  And also there is <a href="https://dsmv.github.io/sdaccel/check_transfer/index.html">documentation</a> on the program formed by Doxygen </li></ul><br><h2 id="osnovnye-katalogi-programmy">  The main directories of the program </h2><br><ul><li>  useful - useful scripts to customize the system </li><li>  qt - directory for Qt sources </li><li>  sdx_wsp / check_transfer - SDAccel working directory </li></ul><br><p>  In this project, the sources for Qt and SDAssel are the same, although they are in different directories.  However, it is assumed that Qt will develop much more complex programs. </p><br><h1 id="dva-rezhima-vyvoda">  Two output modes </h1><br><p> <a href=""><img src="https://habrastorage.org/web/558/45a/c1f/55845ac1f49842f68dc9fe25176a2c12.png"></a> <br>  (Click on image to enlarge) </p><br><p>  The figure shows the appearance of the terminal while the program is running.  Pay attention to the table.  This is a table with the current status of the test.  While working, it is very interesting to know what actually happens.  Moreover, there is a mode without time limit.  The table helps a lot.  Unfortunately, there are problems.  SDAccel is based on Eclipse.  I did not manage to learn how to run the program from the environment in an external terminal.  And in the built-in terminal the table does not work.  I had to make a run mode without a table.  By the way, the Nsight Eclipse Edition system for programming NVIDIA devices is also not able to run programs in an external terminal.  Or maybe I do not know something? </p><br><h1 id="megabayty-ili-mebibayty-">  Megabytes or mebabytes? </h1><br><p>  I belong to those people who know for sure that 1 kilobyte is 1024 bytes (and also assume that at 1 kilometer 1024 meters).  But it is already illegal.  To avoid confusion, the program can measure in both modes and the current mode is displayed in the log. </p><br><p>  Let's look at some pieces of program code. </p><br><h1 id="kernel--gen_cnt">  Kernel gen_cnt </h1><br><p>  The kernel code gen_cnt () is very simple.  The function fills an array of a given size with a test data block. </p><br><pre><code class="cpp hljs">__kernel __attribute__ ((reqd_work_group_size(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_cnt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __global ulong8 *pOut, __global ulong8 *pStatus, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint size )</span></span></span><span class="hljs-function"> </span></span>{ uint blockWr; ulong8 temp1; ulong8 checkStatus; ulong8 addConst; checkStatus = pStatus[<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp1 = pStatus[<span class="hljs-number"><span class="hljs-number">1</span></span>]; addConst = pStatus[<span class="hljs-number"><span class="hljs-number">2</span></span>]; blockWr = checkStatus.s0 &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; __attribute__((xcl_pipeline_loop)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ii=<span class="hljs-number"><span class="hljs-number">0</span></span>; ii&lt;size; ii++) { pOut[ii] = temp1; temp1.s0 +=addConst.s0; temp1.s1 +=addConst.s1; temp1.s2 +=addConst.s2; temp1.s3 +=addConst.s3; temp1.s4 +=addConst.s4; temp1.s5 +=addConst.s5; temp1.s6 +=addConst.s6; temp1.s7 +=addConst.s7; } blockWr++; checkStatus.s0 = ((ulong)blockWr)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span> | <span class="hljs-number"><span class="hljs-number">0xAA56</span></span>; pStatus[<span class="hljs-number"><span class="hljs-number">0</span></span>] = checkStatus; pStatus[<span class="hljs-number"><span class="hljs-number">1</span></span>] = temp1; }</code> </pre> <br><p>  The variable temp1 is of type ulong8.  This is the standard OpenCL type which is a vector of eight 64-bit numbers.  You can refer to the elements of the vector by the names s0..s7 or so temp1.s [ii].  It is quite convenient.  The width of the vector is 512 bits.  This corresponds to the width of the internal bus for the SODIMM controller.  One of the elements of optimization is the exchange with only 512 bit data with memory.  According to the pStatus pointer, a block with status information is located, the current value and constants are read from it.  For each 64-bit field, its own constant is used.  This allows you to make not only a simple counter, but also something more complicated.  Although so far the program makes only a simple counter.  At the end of the function, the current data value and the number of filled blocks are recorded. </p><br><h1 id="check_cnt_m2a--i-check_read_input">  check_cnt_m2a and check_read_input </h1><br><p>  To implement the check, I wrote two functions, one check_read_input - reads data from the dynamic memory and writes them to the pipe.  The second, check_cnt_m2a, reads the data from the pipe and checks it.  Probably in this case, the division into two kernels and their connection through the pipe is redundant.  But it was interesting for me to test this technology. </p><br><p>  Code <a href="">here</a> </p><br><h1 id="struktura-programmy-host">  HOST program structure </h1><br><p>  The program is based on the use of virtual classes <a href="https://dsmv.github.io/sdaccel/check_transfer/classTF__Test.html">TF_Test</a> and <a href="https://dsmv.github.io/sdaccel/check_transfer/classTF__TestThread.html">TF_TestThread</a> ;  Based on these classes, two testing classes have been developed. </p><br><ul><li>  <a href="https://dsmv.github.io/sdaccel/check_transfer/classTF__CheckTransferOut.html">TF_CheckTransferOut</a> - check transfer from device to computer </li><li>  <a href="https://dsmv.github.io/sdaccel/check_transfer/classTF__CheckTransferIn.html">TF_CheckTransferIn</a> - check transfer from computer to device </li></ul><br><p>  The base class TF_Test contains functions: </p><br><table><thead><tr><th>  Title </th><th>  Purpose </th></tr></thead><tbody><tr><td>  Prepare () </td><td>  Training </td></tr><tr><td>  Start () </td><td>  Launch </td></tr><tr><td>  Stop () </td><td>  Stop </td></tr><tr><td>  StepTable () </td><td>  Table display step </td></tr><tr><td>  isComplete () </td><td>  Test completed </td></tr><tr><td>  GetResult () </td><td>  Output </td></tr></tbody></table><br><p>  The <a href="https://dsmv.github.io/sdaccel/check_transfer/main_8cpp.html">main ()</a> function creates one instance of each class and starts execution. <br>  Each testing class creates its own flow of execution, in which it is exchanged with the module.  The main function calls Prepare () for each class.  Inside this function, a stream is created, memory is allocated and all the preparation is done.  After both classes are ready, a start is called, which causes the main testing cycle to start.  When you press Ctrl-C or at the end of a specified test time, Stop () is called.  Classes stop their work and using the isComplete () function inform main () about it.  After stopping, GetResult () is called to get the result.  During the test, the main () function calls a StepTable every 100 ms to update the table.  This allows you to update status information without interfering with the data exchange. <br>  This approach turned out to be very convenient for building test programs.  Here, all tests are built on the same template.  As a result, they can be run in parallel, or one by one.  This program easily organizes the mode of both a single run of one of the tests and a simultaneous start. </p><br><h1 id="rezhimy-vypolneniya-opencl-programmy">  Modes of execution of the OpenCL program </h1><br><p>  The SDAccel system provides three program execution modes: </p><br><ul><li>  Emulation-CPU - everything runs on a HOST processor </li><li>  Emulation-HW - OpenCL functions are performed on the Vivado simulator </li><li>  System - work on real hardware. </li></ul><br><p>  In more detail - in the previous <a href="https://habrahabr.ru/topic/edit/326628/">article</a> . </p><br><p>  It is interesting to compare the speed of work in three environments.  The comparison is very revealing: </p><br><table><thead><tr><th>  Emulation CPU </th><th>  Emulation-hw </th><th>  System </th></tr></thead><tbody><tr><td>  200 MB / s </td><td>  0.1 MB / s </td><td>  2000 MB / s </td></tr></tbody></table><br><p>  I rounded the numbers to see the order better.  Actually, the speed difference between Emulation-CPU and Emulation-HW shows that in the development of FPGA firmware it is necessary to switch to C / C ++ or something similar.  Winning four orders of magnitude is a lot, it covers all the drawbacks of C ++.  It should be noted that the development of VHDL / Verilog will not disappear, and these languages ‚Äã‚Äãwill most likely have to be used to achieve maximum performance.  The possibility of creating an OpenCL kernel on VHDL / Verilog looks very promising; this will allow combining high speed of development and limiting characteristics of the FPGA.  But this is a topic for a separate study and a separate article. </p><br><h1 id="rezultat-trassirovki">  Trace result </h1><br><p><img src="https://habrastorage.org/web/200/e9f/dfd/200e9fdfd9e64eaf8a2936ace1c4c59e.png"></p><br><p>  That's what happened.  Note the number of DSPs for gen_cnt.  To implement eight 64-bit counters, 128 DSP blocks were required.  This is 16 blocks per counter.  Most likely this is the result of the work of the optimizer on the disclosure of the cycle. </p><br><h1 id="razlichiya-v-metodah-optimizacii-dlya-fpga-i-gpu">  Differences in optimization methods for FPGA and GPU </h1><br><p>  To achieve maximum results, different optimization methods should be applied.  GPU has a fixed structure.  If, conditionally speaking, one processor element of a GPU can perform one operation, then in order to perform 100 operations in parallel, 100 processor elements must be used.  But in FPGA it is not the only option.  Yes, we can write one kernel and place several copies in the FPGA.  But this leads to a lot of overhead.  Xilinx recommends using no more than 16 kernel, or rather memory ports.  But inside one element there are no restrictions on parallelization.  Actually the gen_cnt example shows this.  There immediately in the code eight 64-bit adders are recorded.  In addition, the optimizer worked and launched a cycle.  For a GPU, this example should be written differently, for example, make one kernel to get a 64-bit sample and run eight instances at once. </p><br><h1 id="chto-mozhet-pokazat-emulation-hw">  What Emulation-HW can show </h1><br><p>  This mode can show what is happening on the memory access bus.  The picture shows the process of reading data from memory function check_read_input (). </p><br><p> <a href=""><img src="https://habrastorage.org/web/75f/f6e/72a/75ff6e72adc04d92a717308dbe2ceaca.png"></a> <br>  (Click to enlarge) </p><br><p>  First of all, you can see how long the data is coming.  The delay from the first request until the first data 512 ns.  Secondly, it is clear that the reading is in blocks of 16 words (512 bits in size).  When developing on VHDL, I would use a larger block size.  But apparently the controller is able to combine the blocks and this does not lead to a slowdown.  In the third it is clear that there are gaps in data acquisition.  They are also explicable.  The frequency of OpenCL 250 MHz, the memory bus frequency for SODIMM DDR3-1600 is 200 MHz.  The gaps correspond exactly to the transition from the 200 MHz bus to the 250 MHz bus. </p><br><h1 id="rezultaty">  results </h1><br><p>  The results are interesting, but I expected to achieve higher speeds. </p><br><h3 id="odinochnye-testy">  Single tests </h3><br><table><thead><tr><th>  Computer </th><th>  Enter [MiB / s] </th><th>  Conclusion [MiB / s] </th></tr></thead><tbody><tr><td>  Intel Core-i5, PCIe v2.0 x8 </td><td>  2048 </td><td>  1837 </td></tr><tr><td>  Intel Core-i7, PCIe v3.0 x8 </td><td>  2889 </td><td>  2953 </td></tr></tbody></table><br><h3 id="dvunapravlennyy-test">  Bidirectional test </h3><br><table><thead><tr><th>  Computer </th><th>  Enter [MiB / s] </th><th>  Conclusion [MiB / s] </th></tr></thead><tbody><tr><td>  Intel Core-i5, PCIe v2.0 x8 </td><td>  1609 </td><td>  1307 </td></tr><tr><td>  Intel Core-i7, PCIe v3.0 x8 </td><td>  2048 </td><td>  2057 </td></tr></tbody></table><br><p>  For comparison, on our module with a similar FPGA the record input speed was 5500 MiB / s, although for several reasons it had to be reduced to 5000. So there are opportunities for increasing the exchange rate. </p><br><h1 id="chto-dalshe">  What's next </h1><br><p>  Work will continue. </p><br><ul><li>  SDAccel 2017.2 exploration </li><li>  Implementation of the convolution node based on the FPFFTK library by Alexander Kapitanov ( <a href="https://habrahabr.ru/users/capitanov/" class="user_link">capitanov</a> ) </li><li>  Develop your own DSA packages, including those with support for 10G Ethernet </li><li>  And most importantly - the development of its own module, the name already exists - DSP135P </li></ul><br><p>  PS I want to thank <a href="https://github.com/karakozov">Vladimir Karakozov</a> for his help in developing the testing program template. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337568/">https://habr.com/ru/post/337568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337556/index.html">SAMBA File Server Based on Linux CentOS 7</a></li>
<li><a href="../337558/index.html">What is LinkedList under the hood?</a></li>
<li><a href="../337560/index.html">Why did we do VOD on WebRTC</a></li>
<li><a href="../337564/index.html">Specific use of Redux in Polymer and Vue</a></li>
<li><a href="../337566/index.html">How to resurrect a jaguar for a thousand hours?</a></li>
<li><a href="../337572/index.html">Open speech recognition problems. Lecture in Yandex</a></li>
<li><a href="../337576/index.html">Kibana Dashboards PDF Reports</a></li>
<li><a href="../337578/index.html">How I stopped loving Angular</a></li>
<li><a href="../337580/index.html">The task of rewarding: feel like a manager</a></li>
<li><a href="../337582/index.html">Validating React Components with Livr.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>