<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to log in NodeJS to the boys in the yard respected</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What infuriates you most when you are trying to organize readable logs in your NodeJS application? Personally, I am extremely strained by the absence ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to log in NodeJS to the boys in the yard respected</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/5a/em/fo/5aemfoyk841-ll_xjint9es2kao.jpeg"></p><br><p>  What infuriates you most when you are trying to organize readable logs in your NodeJS application?  Personally, I am extremely strained by the absence of any sane mature standards for creating a trace ID.  In this article we will talk about what options there are for creating a trace ID, let's figure out how <a href="https://github.com/jeff-lewis/cls-hooked">continuation-local storage or CLS</a> works on our fingers and call the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxy</a> force to help all this with absolutely any logger. </p><a name="habracut"></a><br><h2 id="pochemu-v-nodejs-voobsche-est-problema-s-sozdaniem-trace-id-dlya-kazhdogo-zaprosa">  Why does NodeJS even have a problem with creating a trace ID for each request? </h2><br><p>  In the old-long-old times, when the mammoths still walked the earth, all-all-all servers were multithreaded and created in a new stream to the request.  In the framework of this paradigm, the creation of a trace ID is trivial, since  There is such a thing as <a href="https://en.wikipedia.org/wiki/Thread-local_storage">thread-local storage or TLS</a> , which allows you to store in memory some data that is available to any function in this stream.  It is possible at the beginning of the processing of the request to accumulate a random ID, put it in TLS and then read it in any service and do something with it.  The trouble is that in NodeJS it will not work. </p><br><p>  NodeJS is single-threaded (not quite, considering the appearance of workers, but within the framework of the problem with trace ID, no one plays any role), so you can forget about TLS.  Here the paradigm is different - to juggle with a bunch of different callbacks within the same thread, and as soon as the function wants to do something asynchronous, send this asynchronous request, and give the processor time to another function in the queue (if you are wondering how this thing works, proudly called Event Loop under the hood, I recommend <a href="https://jsblog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810">this series of articles</a> to read).  If you think about how NodeJS understands which callback when to call, we can assume that each of them must correspond to some kind of ID.  Moreover, NodeJS even has an API that provides access to these IDs.  We will use them. </p><br><p>  In the old times, when the mammoths were already extinct, but people still did not know the benefits of the central sewage system (NodeJS v0.11.11) we had <a href="https://nodejs.org/docs/v0.11.11/api/process.html">addAsyncListener</a> .  Based on it, <a href="https://github.com/othiym23">Forrest Norvell</a> created the first implementation of <a href="https://github.com/othiym23/node-continuation-local-storage">continuation-local storage or CLS</a> .  But we will not talk about how it worked then, as this API (I‚Äôm talking about addAsyncLustener) ordered to live long.  He was no longer in NodeJS v0.12. </p><br><p>  Before NodeJS 8, there was no official way to keep track of asynchronous events.  And, finally, in version 8, NodeJS developers have restored justice and presented us with the <a href="https://nodejs.org/docs/latest-v11.x/api/async_hooks.html">async_hooks API</a> .  If you want to learn more about async_hooks, I recommend reading <a href="https://itnext.io/a-pragmatic-overview-of-async-hooks-api-in-node-js-e514b31460e9">this article</a> .  Based on the async_hooks, the previous implementation of the CLS was refactored.  The library is called <a href="https://github.com/Jeff-Lewis/cls-hooked">cls-hooked</a> . </p><br><h2 id="cls-pod-kapotom">  CLS under the hood </h2><br><p>  In general terms, the scheme of the CLS can be represented as follows: </p><br><p><img src="https://habrastorage.org/webt/ix/xe/wj/ixxewjdn0xn7r5feuvgdl1vnjow.jpeg" alt="CLS overview"></p><br><p>  Let's take it a little more detail: </p><br><ol><li>  Suppose we have a typical <a href="https://github.com/expressjs/express">Express</a> web server.  First, create a new CLS namespace.  Once and for the entire lifetime of the application. </li><li>  Secondly, we will make middleware, which for each request will create its own CLS context. </li><li>  When a new request arrives, this middleware is called (Function # 1). </li><li>  In this function we create a new CLS context (as one option, you can use <a href="https://github.com/jeff-lewis/cls-hooked">Namespace.run</a> ).  In Namespace.run we pass the function, which will be executed in the context of our context. </li><li>  CLS adds a newly created context to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> with contexts on the <a href="https://nodejs.org/api/async_hooks.html">current execution ID</a> key. </li><li> Each CLS namespace has an <code>active</code> property.  CLS assigns this property a link to our context. </li><li>  In the context context, we make some kind of asynchronous query, say, to the database.  The database driver is passed a callback, which will be called when the request is completed. </li><li>  The asynchronous <a href="https://nodejs.org/api/async_hooks.html">init</a> hook is <a href="https://nodejs.org/api/async_hooks.html">triggered</a> .  It adds the current context to the Map with contexts by async ID (ID of the new asychronous operation). </li><li>  Since  our function no longer has any additional instructions, it completes execution. </li><li>  An asynchronous <a href="https://nodejs.org/api/async_hooks.html">after</a> hook <a href="https://nodejs.org/api/async_hooks.html">works</a> for it.  It assigns the <code>active</code> property to the namespace <code>undefined</code> (in fact, not always, since we may have several nested contexts, but for the simplest case, this is the case). </li><li>  An asynchronous <a href="https://nodejs.org/api/async_hooks.html">destroy</a> hook is <a href="https://nodejs.org/api/async_hooks.html">triggered</a> for our first asynchronous operation.  It removes the context from the Map with contexts by the async ID of this operation (it is the same as the current execution ID of the first callback). </li><li>  The request to the database is completed and the second callback is called. </li><li>  An asynchronous <a href="https://nodejs.org/api/async_hooks.html">before</a> hook <a href="https://nodejs.org/api/async_hooks.html">fires</a> .  Its current execution ID is the same as the async ID of the second operation (database query).  The namespace's <code>active</code> property is assigned the context found in the Map with contexts by the current execution ID.  This is the same context that we created before. </li><li>  Now the second callback itself is running.  Practicing some kind of business logic, dancing devils, pouring vodka.  Inside this we can get <a href="https://github.com/jeff-lewis/cls-hooked">any value from the context by key</a> .  CLS will try to find the given key in the current context or return <code>undefined</code> . </li><li>  An asynchronous <a href="https://nodejs.org/api/async_hooks.html">after</a> hook is triggered for this callback when it is completed.  It assigns the <code>active</code> property to the namespace <code>undefined</code> . </li><li>  An asynchronous <a href="https://nodejs.org/api/async_hooks.html">destroy</a> hook is <a href="https://nodejs.org/api/async_hooks.html">triggered</a> for this operation.  It removes the context from the Map with contexts by the async ID of this operation (it is the same as the current execution ID of the second callback). </li><li>  The garbage collector (GC) frees the memory associated with the context object, since  we have no more links to it in the application. </li></ol><br><p>  This is a simplified view of what is going on under the hood, but it covers the main phases and steps.  If you have a desire to dig a little deeper, I recommend to get acquainted with the <a href="">samples</a> .  There are only 500 lines of code. </p><br><h2 id="sozdanie-trace-id">  Create trace ID </h2><br><p>  So, having dealt with the CLS, we will try to use this thing for the benefit of mankind.  Let's create middleware, which for each request creates its own CLS context, creates a random trace ID and adds it to the context using the <code>traceID</code> key.  Then inside ofigilliarda our controllers and services we get this trace ID. </p><br><p>  For <a href="https://github.com/expressjs/express">express, a</a> similar middleware might look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsNamespace = cls.createNamespace(<span class="hljs-string"><span class="hljs-string">'app'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req  res -  event emitters.      CLS     clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() clsNamespace.run(() =&gt; { clsNamespace.set('traceID', traceID) next() }) }</span></span></code> </pre> <br><p>  And in our controller or service we can get this traceID with just one line of code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'traceID'</span></span>) }</code> </pre> <br><p>  True, without adding this trace ID to the logs of the benefits of it, like a snowthrower in the summer. </p><br><p>  Let's get a simple formatter for <a href="https://github.com/winstonjs/winston">winston</a> , which will add the trace ID automatically. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { createLogger, format, transports } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'winston'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addTraceId = printf(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = info.message <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'taceID'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traceID) { message = <span class="hljs-string"><span class="hljs-string">`[TraceID: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${traceID}</span></span></span><span class="hljs-string">]: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = createLogger({ <span class="hljs-attr"><span class="hljs-attr">format</span></span>: addTraceId, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> transports.Console()], })</code> </pre> <br><p>  And if all loggers supported custom formatters in the form of functions (many of them have reasons not to do this), then this article probably would not exist.  So how could you add a trace ID to the logs of my <a href="https://github.com/pinojs/pino">favorite pino</a> ? </p><br><h2 id="vzyvaem-k-proxyhttpsdevelopermozillaorgen-usdocswebjavascriptreferenceglobal_objectsproxy-daby-podruzhit-lyuboy-loger-i-cls">  Call for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a> in order to make friends with ANY logger and CLS </h2><br><p>  A few words about the Proxy itself: this is such a thing that wraps our original object and allows you to override its behavior in certain situations.  In a strictly limited list of situations (according to science, they are called <code>traps</code> ).  The full list can be found <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">here</a> , we are only interested in trap <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get">get</a> .  It allows us to override the return value when accessing the property of an object, i.e.  if we take the object <code>const a = { prop: 1 }</code> and wrap it in a proxy, then with the help of trap <code>get</code> we can return everything we want, when we refer to <code>a.prop</code> . </p><br><p>  In the case of <code>pino</code> idea is as follows: we create a random trace ID for each request, create a <a href="">child pino instance</a> , into which we send this trace ID, and put this child instance in CLS.  Then we wrap our source logger in Proxy, which will use this very child instance for logging, if there is an active context and it has a child logger, or use the source logger. </p><br><p>  For such a case, the proxy will look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pino = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pino'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = pino() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loggerCls = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(logger, { get(target, property, receiver) { <span class="hljs-comment"><span class="hljs-comment">//    CLS  ,   target = clsNamespace.get('loggerCls') || target return Reflect.get(target, property, receiver) }, })</span></span></code> </pre> <br><p>  Our middleware will look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req  res -  event emitters.      CLS     clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() const loggerWithTraceId = logger.child({ traceID }) clsNamespace.run(() =&gt; { clsNamespace.set('loggerCls', loggerWithTraceId) next() }) }</span></span></code> </pre> <br><p>  And we can use the logger like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { loggerCls.info(<span class="hljs-string"><span class="hljs-string">'Long live rocknroll!'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  // {"level":30,"time":1551385666046,"msg":"Long live rocknroll!","pid":25,"hostname":"eb6a6c70f5c4","traceID":"9ba393f0-ec8c-4396-8092-b7e4b6f375b5","v":1} }</span></span></code> </pre> <br><h2 id="cls-proxifyhttpsgithubcomkeenondrumscls-proxify">  <a href="https://github.com/keenondrums/cls-proxify">cls-proxify</a> </h2><br><p>  Based on the above idea, a <a href="https://github.com/keenondrums/cls-proxify">small library cls-proxify</a> was created.  She works out of the box with <a href="https://github.com/expressjs/express">express</a> , <a href="https://github.com/koajs/koa">koa</a> and <a href="https://github.com/fastify/fastify">fastify</a> .  In addition to creating a trap for <code>get</code> , it creates <a href="https://github.com/keenondrums/cls-proxify">other traps</a> to give the developer more freedom.  Because of this, we can use Proxy to wrap functions, classes, and more.  <a href="https://github.com/keenondrums/cls-proxify">There is a live demo of how to integrate pino and fastify, pino and express</a> . </p><br><p>  I hope you did not waste your time, and the article was just a little useful to you.  Please kick and criticize.  We will learn to code better together. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/442452/">https://habr.com/ru/post/442452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442442/index.html">Senior Engineer in search of work. About tasks on technical interviews and theoretical questions</a></li>
<li><a href="../442444/index.html">Myths of modern popular physics</a></li>
<li><a href="../442446/index.html">Digital transformation on the example of the Call Center of any business</a></li>
<li><a href="../442448/index.html">Concurrency and error patterns hidden in code: Deadlock</a></li>
<li><a href="../442450/index.html">Blockchain and medical data: how it works</a></li>
<li><a href="../442454/index.html">Magic Leap plans to add digital layers to the real world</a></li>
<li><a href="../442456/index.html">How to save resources in the browser and not break the web. Yandex report</a></li>
<li><a href="../442458/index.html">Handmade chasm or the path from the RPA pilot to company-wide implementation</a></li>
<li><a href="../442460/index.html">We help Queryable Provider to deal with interpolated strings</a></li>
<li><a href="../442464/index.html">How to grow manned "Dragon"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>