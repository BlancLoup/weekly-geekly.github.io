<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to procedural animation: inverse kinematics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 4. Introduction to Gradient Descent 
 This part is a theoretical introduction to inverse kinematics and contains a software solution based on gra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to procedural animation: inverse kinematics</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/35d/9c4/3eb/35d9c43ebc0848148cb18a757de2fba9.png"></div><br><h2>  Part 4. Introduction to Gradient Descent </h2><br>  This part is a theoretical introduction to <strong>inverse kinematics</strong> and contains a software solution based on <strong>gradient descent</strong> .  This article will not be a comprehensive guide on this topic, it is just a general introduction.  In the next section, we show the actual implementation of this algorithm in C # in Unity. <br><br>  The series consists of the following parts (parts 1-3 are presented in the <a href="https://habrahabr.ru/post/332164/">previous post</a> ): <br><br><ul><li>  <a href="https://habrahabr.ru/post/332164/">Part 1. Introduction to procedural animation</a> </li><li>  <a href="https://habrahabr.ru/post/332164/">Part 2. Mathematics of direct kinematics</a> </li><li>  <a href="https://habrahabr.ru/post/332164/">Part 3. Realization of direct kinematics</a> </li><li>  Part 4. Introduction to Gradient Descent </li><li>  Part 5. Inverse kinematics for a robotic arm </li><li>  Part 6. Inverse kinematics of tentacles </li><li>  <s>Part 7. Inverse kinematics of spider legs</s> </li></ul><a name="habracut"></a><br><h3>  Introduction </h3><br>  The previous part of the series (‚ÄúRealization of direct kinematics‚Äù) presents a solution to the problem of <strong>direct kinematics</strong> .  We have a function <code>ForwardKinematics</code> , which defines a point in space, which is currently related to the robot arm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we have a specific point in space that we want to achieve, then <code>ForwardKinematics</code> can be used to assess the proximity of the manipulator, taking into account the current configuration of the connections.  The distance from the target is a function that can be implemented as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceFromTarget</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] angles</span></span></span><span class="hljs-function">)</span></span> { Vector3 point = ForwardKinematics (angles); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3.Distance(point, target); }</code> </pre> <br>  Finding a solution to the problem of inverse kinematics means that we need to minimize the value returned by the <code>DistanceFromTarget</code> function.  Minimizing a function is one of the well-known problems, both in programming and in mathematics.  The approach we will use is based on a technique called <b>gradient descent</b> ( <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA">Wikipedia</a> ).  Despite the fact that it is not the most effective, the technique has its advantages: it is not specific to solve a specific problem and there is enough knowledge for it that most programmers have. <br><br><div class="spoiler">  <b class="spoiler_title">Analytical solution of inverse kinematics</b> <div class="spoiler_text">  Gradient descent is an optimization algorithm.  It can be used for all problems that do not have an exact equation.  This is not our case, because we have already derived the equation of direct kinematics in the section "Mathematics of direct kinematics": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/294/5d9/dfc/2945d9dfc5c01b27fd4391697f57c476.png"></div><br><br>  Distance from target point <img src="https://habrastorage.org/getpro/habr/post_images/0f4/83c/f0b/0f483cf0bc1869cb29ddcd977f7ebef8.png">  is set as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a28/bc4/343/a28bc43438282749f8c44ce995b2faea.png"></div><br><br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/493/7bb/d89/4937bbd8973a79b614e57761a75505d3.png">  - this is the <a href="https://en.wikipedia.org/wiki/Norm_(mathematics)">Euclidean norm of the</a> vector <img src="https://habrastorage.org/getpro/habr/post_images/473/076/7be/4730767be0b7beb0f17faf17d041c460.png">  . <br><br>  An analytical solution to this problem can be found by minimizing <img src="https://habrastorage.org/getpro/habr/post_images/db5/691/ce0/db5691ce0ff105a209f72c9572a878f8.png">  which is a function <img src="https://habrastorage.org/getpro/habr/post_images/9a6/e70/ebc/9a6e70ebca832c8565457b00e9cab48d.png">  . <br><br>  There are other, more structured approaches to solving the problem of inverse kinematics.  To get started is to look at the <strong>matrix Denavita-Hartenberg</strong> ( <a href="https://en.wikipedia.org/wiki/Denavit%25E2%2580%2593Hartenberg_parameters">Wikipedia</a> ). </div></div><br><h3>  Gradient descent </h3><br>  The easiest way to understand the work of gradient descent is to imagine a hilly relief.  We are in a random place and want to reach the lowest point.  Let's call it a <strong>minimum of</strong> relief.  At each step, the gradient descent tells us to move in a direction that lowers our height.  If the geometry of the relief is relatively <em>simple</em> , then this approach will lead us to the very bottom of the valley. <br><br>  The graph below shows the standard case in which a gradient descent will be successful.  In this simplest example, we have a function.  It takes one parameter (X axis) and returns the error value (Y axis).  We start with a random point on the X axis (blue and green points).  Gradient descent should make us move in the direction of the minimum (blue and green arrows). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42d/aa5/1b9/42daa51b9ff8d205e1f18f70fe1c4b4f.png"></div><br><br>  If we look at the function as a whole, then the direction of motion is obvious.  Unfortunately, the gradient descent does not have in advance information about where the minimum is located.  The best guess that the algorithm can allow is to move towards a slope, also called a <strong>gradient</strong> function.  If you are on a mountain, release the ball and it will reach the valley.  The graph below shows the gradient of the error function at two different points. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/27f/cf1/5a227fcf1ed38e1e7399e462781979b1.png"></div><br><br><div class="spoiler">  <b class="spoiler_title">How good is the relief?</b> <div class="spoiler_text">  For a gradient descent to be effective, the function that we minimize must meet certain requirements.  If the relief of the function is relatively smooth, then the probability of successful application of the gradient descent is higher.  If the function has gaps or multiple maxima, then it is especially difficult, because it takes a much longer journey to reach the bottom of the valley. <br><br>  This is how the relief for a robotic arm with two connections (controlled by <img src="https://habrastorage.org/getpro/habr/post_images/3d7/dd7/fa4/3d7dd7fa411c81dd02eaf7771b2d30d6.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/698/de9/a08/698de9a08ec75b67b276137c8edb55b1.png">  ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/698/b31/b78698b31a42ab3d9eca6278ce4512f5.png"><br></div></div><br><h3>  Gradient estimate </h3><br>  If you studied mathematical analysis, you probably know that the <strong>gradient of a</strong> function is directly related to its <strong>derivative</strong> .  However, to calculate the derivative of a function, it is necessary that it satisfy certain mathematical properties, and it is impossible to guarantee the fulfillment of this requirement for any problem in the general case.  Moreover, for analytic taking of a derivative, it is necessary that the error function be represented in an analytical form.  And we do not always have an analytical view of the function that needs to be minimized. <br><br>  In all such cases, it is impossible to find the <em>true</em> derivative of the function.  The solution is a rough estimate of its value.  The graph below shows how it is in one dimension.  By discrete sampling of nearby points, the local gradient of the function can be approximately obtained.  If the error function is less on the left, then we move to the left, if on the right, then we move to the right. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/08e/ff9/5c908eff95d2d4b206332be0a6dc4828.png" alt="image"></div><br><br><div class="spoiler">  <b class="spoiler_title">What is the difference between gradient and derivative?</b> <div class="spoiler_text">  The concepts of gradient and arbitrary are closely related. <br><br>  <strong>A gradient</strong> or <strong>oblique derivative of a</strong> function is a vector pointing in the direction of the fastest climb.  In the case of one-dimensional functions (as in our graphs), the gradient is equal to or <img src="https://habrastorage.org/getpro/habr/post_images/220/4b9/e49/2204b9e4903e2f35b9129261c479e4c0.png">  if the function goes up, or <img src="https://habrastorage.org/getpro/habr/post_images/3b3/c3e/342/3b3c3e34275c881b5645e1b9bb4f8035.png">  if the function goes down.  If the function is defined through two variables (for example, a robotic arm with two connections), then the gradient is the ‚Äúarrow‚Äù ( <em>unit vector</em> ) of the two elements directed towards the steepest ascent. <br><br>  <strong>The derivative of a</strong> function, in contrast to a gradient, is simply a number that determines the speed at which the function rises as it moves in the direction of the gradient. <br><br>  In this article we will not seek to calculate the true gradient of the function.  Instead, we will create an assessment.  Our approximate gradient is a vector that we hope is pointing in the direction of the fastest climb.  As we will see, this will not necessarily be a unit vector. </div></div><br><div class="spoiler">  <b class="spoiler_title">How important is sampling?</b> <div class="spoiler_text">  It is very important.  A sample of nearby points requires an evaluation of the function at a certain distance from the current position.  This distance is <em>critical</em> . <br><br>  Look at the chart: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a3/6c1/83d/4a36c183d9a8514c869a85b700c09b0c.png"></div><br><br>  This sampling distance used for gradient estimation is too large.  Gradient descent erroneously ‚Äúassumes‚Äù that the right side is higher than the left.  As a result, the algorithm will move in the wrong direction. <br><br>  Reducing the sampling distance can reduce this problem, but it will never be possible to get rid of it.  Moreover, a shorter sampling distance leads to an ever slower approach to the solution. <br><br>  This problem can be solved with the help of more complex variations of gradient descents. </div></div><br><div class="spoiler">  <b class="spoiler_title">What if a function has several local minima?</b> <div class="spoiler_text">  In general, such a ‚Äúgreedy‚Äù approach gives us no guarantee that we will actually reach the lowest point of the valley.  If there are other valleys, then we can get stuck in one of them and cannot achieve our true goal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/07a/0ef/e8907a0ef42cde6b83884ae120705afc.png"></div><br><br>  Taking into account the above naive description of the gradient descent, we can see that this is exactly what will happen with the function on the graph above.  This function has three <strong>local minima</strong> creating three separate valleys.  If we initialize the gradient descent at a point from the green area, it will end at the bottom of the green valley.  The same applies to the red and blue areas. <br><br>  All these problems can also be solved with the help of complicated variations of the gradient descent. </div></div><br><h3>  Maths </h3><br>  Now that we have a general understanding of the graphic work of gradient descent, let's see how to translate it into the language of mathematics.  The first step is to calculate the gradient of our error function. <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  at a specific point <img src="https://habrastorage.org/getpro/habr/post_images/6af/9a7/4fb/6af9a74fb8a7b1c5e436ae42b5482ff4.png">  .  We need to find the direction in which the function grows.  The gradient of a function is closely related to its derivative.  Therefore, it would be nice to start creating our estimate by examining how the derivative is calculated. <br><br>  Mathematically, the derivative of the function <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  called <img src="https://habrastorage.org/getpro/habr/post_images/14d/be8/a07/14dbe8a07af5c0cb7d6d371935ef5a21.png">  .  Its value is at the point <img src="https://habrastorage.org/getpro/habr/post_images/6af/9a7/4fb/6af9a74fb8a7b1c5e436ae42b5482ff4.png">  equally <img src="https://habrastorage.org/getpro/habr/post_images/5ad/73b/5e6/5ad73b5e6aed66a4b494f7cf3cfce419.png">  , and it shows how fast the function grows.  According to her: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/430/084/309/430084309d415970dc7f3d61213afadb.png">  locally grows upwards; </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3c3/25a/2e2/3c325a2e27ba96fa48ac1efa80f3de5e.png">  locally down; </li><li><img src="https://habrastorage.org/getpro/habr/post_images/719/da3/3c2/719da33c202d4266d8118cd7edd4d883.png">  locally flat. </li></ul><br>  The idea is to use assessment <img src="https://habrastorage.org/getpro/habr/post_images/5ad/73b/5e6/5ad73b5e6aed66a4b494f7cf3cfce419.png">  to calculate the gradient denoted <img src="https://habrastorage.org/getpro/habr/post_images/727/1c6/30b/7271c630b547b67fcffe52dcfa3db43e.png">  .  Mathematically <img src="https://habrastorage.org/getpro/habr/post_images/14d/be8/a07/14dbe8a07af5c0cb7d6d371935ef5a21.png">  is defined as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27a/7c2/a22/27a7c2a2270e2a7274fe25aa65da3306.png"></div><br><br>  The graph below shows what this means: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/b38/358/928b383581bf6d92947443ca3b83b8fe.gif"></div><br><br>  In our case, to estimate the derivative, we need to sample the error function at two different points.  Short distance between them <img src="https://habrastorage.org/getpro/habr/post_images/f67/798/da0/f67798da06fef8d3ab367f9b9315c931.png">  Is the <strong>sampling distance</strong> we talked about in the previous section. <br><br>  Summarize.  To calculate the true derivative of the function, you must use the limit.  Our gradient is a rough estimate of the derivative created using a fairly small sampling distance: <br><br><ul><li>  <strong>Derivative</strong> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27a/7c2/a22/27a7c2a2270e2a7274fe25aa65da3306.png"></div><br></li><li>  <strong>Approximate gradient</strong> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83b/259/049/83b259049d47af3ca8ffd56e06f43527.png"></div></li></ul><br>  In the next section, we will see how these two concepts differ with several variables. <br><br>  Having found the approximate derivative, we need to move in the opposite direction to go down the function.  This means that you need to update the parameter. <img src="https://habrastorage.org/getpro/habr/post_images/6af/9a7/4fb/6af9a74fb8a7b1c5e436ae42b5482ff4.png">  in the following way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/c1f/3d0/3d0c1f3d051cef8314940e7b54d32fc9.png"></div><br><br>  Constant <img src="https://habrastorage.org/getpro/habr/post_images/5e8/daa/a7e/5e8daaa7e7caf8e2e982714e3d0742db.png">  often called <strong>learning rate</strong> .  It determines how fast we will move along the gradient.  The greater the value, the faster the solution will be found, but the more likely it is to miss it. <br><br><div class="spoiler">  <b class="spoiler_title">lim?</b> <div class="spoiler_text">  If you have not studied mathematical analysis, you may not be familiar with the concept of <strong>limits</strong> .  Limits is a mathematical tool that allows us <em>to reach infinity</em> . <br><br>  Consider our conditional example.  The smaller the sampling distance <img src="https://habrastorage.org/getpro/habr/post_images/983/059/d44/983059d4409ffae8fab74a84c611c38d.png">  the better we can estimate the true gradient of the function.  However, we cannot ask <img src="https://habrastorage.org/getpro/habr/post_images/169/cdb/69b/169cdb69bc78e91e2049d3fbd7a6a6dc.png">  because division by zero is not allowed.  Limits allow us to circumvent this problem.  We can not divide by zero, but with the help of limits we can set a number conventionally close to zero, but <em>in fact it</em> is not equal. </div></div><br><h3>  Several variables </h3><br>  The solution we found works in one dimension.  This means that we have defined a derivative of the function of the form <img src="https://habrastorage.org/getpro/habr/post_images/8a6/2f8/023/8a62f80238c716735f14ce8693062416.png">  where <img src="https://habrastorage.org/getpro/habr/post_images/6af/9a7/4fb/6af9a74fb8a7b1c5e436ae42b5482ff4.png">  Is one number.  In this particular case, we can find a fairly accurate approximate value of the derivative of the sample function. <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  at two points: <img src="https://habrastorage.org/getpro/habr/post_images/6af/9a7/4fb/6af9a74fb8a7b1c5e436ae42b5482ff4.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/62d/5c0/3e5/62d5c03e51ad091e197e95a461e20eb3.png">  .  The result is a single number indicating an increase or decrease in function.  We used this number as a gradient. <br><br>  The function with one parameter corresponds to a single-joint robot manipulator.  If we want to perform a gradient descent for more complex manipulators, then it is necessary to specify the gradient of functions with several variables.  For example, if our robotic arm has three joints, the function will be more like <img src="https://habrastorage.org/getpro/habr/post_images/f28/cf4/8d3/f28cf48d3bef4f607ff0f5d147f84996.png">  .  In this case, the gradient is a vector consisting of three numbers showing the local behavior <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  in the three-dimensional space of its parameters. <br><br>  We can introduce the concept of <strong>partial derivatives</strong> , which, in essence, are ‚Äútraditional‚Äù derivatives, calculated for each of the variables: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/9f1/0ee/5799f10ee166a40d13d3c89645415348.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cb/c51/3f3/7cbc513f31e30ac240269a3f14524a89.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/b3f/88b/e58b3f88b1c1b90a5a34cdd6030492c6.png"></div><br><br>  They represent three different scalar numbers, each of which shows how the function grows in a certain direction (or along the axis).  To calculate the total gradient, we approximate each partial derivative with a corresponding gradient using sufficiently small sample distances. <img src="https://habrastorage.org/getpro/habr/post_images/f67/798/da0/f67798da06fef8d3ab367f9b9315c931.png">  , <img src="https://habrastorage.org/getpro/habr/post_images/730/cc5/247/730cc52472ad8494620dd88844a97380.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/3d7/c2f/e21/3d7c2fe213aaa2c0676d3058354330e2.png">  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f38/88b/ef0/f3888bef01bf0b6a4e892275b20cf5c9.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/662/d8c/24e662d8c8ee06cacf461863567363f9.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/70a/490/7bc70a4906c33a371a02bae1bbf5e972.png"></div><br><br>  For our gradient descent, we will use a vector containing all three results as the gradient: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/2ec/1e4/5ac2ec1e4de2fd3423eb201a581e211b.png"></div><br><br><div class="spoiler">  <b class="spoiler_title">This is not a single vector!</b> <div class="spoiler_text">  The skew derivative of a function is a unit vector that indicates the direction of the fastest ascent.  Directions are vectors of unit length.  However, it is easy to see that the calculated gradient is not necessarily a unit vector. <br><br>  Although this may look like <em>violence against mathematics</em> (and perhaps it is so!), But it will not necessarily become a problem for our algorithm.  We need a vector pointing in the direction of the fastest climb.  Using approximate values ‚Äã‚Äãof partial derivatives as elements of such a vector satisfies our constraints.  If we need this to be a unit vector, then we can simply normalize it by dividing it by its length. <br><br>  Using a single vector gives us the advantage of determining the maximum speed with which we move along the surface.  This speed is learning rate <img src="https://habrastorage.org/getpro/habr/post_images/5e8/daa/a7e/5e8daaa7e7caf8e2e982714e3d0742db.png">  .  Using a non-normalized vector means that we will be faster or slower, depending on the slope <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  .  This is neither good nor bad, it is just another approach to solving our problem. <br></div></div><br><h2>  Part 5. Inverse kinematics for a robotic arm </h2><br>  After a long journey into mathematics of direct kinematics and geometric analysis of gradient descent, we are finally ready to demonstrate the working implementation of the problem of inverse kinematics.  In this section, we will show how it can be applied to a robot manipulator, similar to the one shown below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a4/2cf/37b/5a42cf37b278c9d4376f496bf64d2faf.gif" alt="image"><br><br><h3>  Introduction </h3><br>  The previous part outlines the mathematical foundations of a technique called <strong>gradient descent</strong> .  We have a function <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  receiving parameter <img src="https://habrastorage.org/getpro/habr/post_images/ff2/6ef/e7f/ff26efe7f94a181ffa1f0a65f9274b43.png">  each joint of the robot manipulator.  This parameter is the current joint angle.  For a given articulation configuration <img src="https://habrastorage.org/getpro/habr/post_images/9a6/e70/ebc/9a6e70ebca832c8565457b00e9cab48d.png">  function <img src="https://habrastorage.org/getpro/habr/post_images/f98/a1d/645/f98a1d645050b80a8335359b208819b6.png">  returns one value indicating how far the final link of the manipulator robot is from the target point <img src="https://habrastorage.org/getpro/habr/post_images/0f4/83c/f0b/0f483cf0bc1869cb29ddcd977f7ebef8.png">  .  Our task is to find the values. <img src="https://habrastorage.org/getpro/habr/post_images/9a6/e70/ebc/9a6e70ebca832c8565457b00e9cab48d.png">  minimizing <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  . <br><br>  To do this, we first calculate the gradient of the function at the current <img src="https://habrastorage.org/getpro/habr/post_images/9a6/e70/ebc/9a6e70ebca832c8565457b00e9cab48d.png">  .  <strong>Gradient</strong> is a vector showing the direction of the fastest climb.  Simply put, this is an arrow indicating the direction in which the function grows.  Each element of the gradient is an approximate value of the partial derivative. <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  . <br><br>  For example, if a robotic arm has three joints, then we will have a function <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  that takes three parameters: <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  , <img src="https://habrastorage.org/getpro/habr/post_images/a3d/f35/bfb/a3df35bfb983320e4886f942f10f2dbf.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/2f0/8a1/c1d/2f08a1c1d5beb0c79414300a6fcb9eac.png">  .  Then our gradient <img src="https://habrastorage.org/getpro/habr/post_images/727/1c6/30b/7271c630b547b67fcffe52dcfa3db43e.png">  is set as: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ac/2ec/1e4/5ac2ec1e4de2fd3423eb201a581e211b.png"><br><br>  Where: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f38/88b/ef0/f3888bef01bf0b6a4e892275b20cf5c9.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/662/d8c/24e662d8c8ee06cacf461863567363f9.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/70a/490/7bc70a4906c33a371a02bae1bbf5e972.png"></div><br><br>  but <img src="https://habrastorage.org/getpro/habr/post_images/f67/798/da0/f67798da06fef8d3ab367f9b9315c931.png">  , <img src="https://habrastorage.org/getpro/habr/post_images/730/cc5/247/730cc52472ad8494620dd88844a97380.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/3d7/c2f/e21/3d7c2fe213aaa2c0676d3058354330e2.png">  - sufficiently small values. <br><br>  We got an approximate gradient <img src="https://habrastorage.org/getpro/habr/post_images/727/1c6/30b/7271c630b547b67fcffe52dcfa3db43e.png">  .  If we want to minimize <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  then you need to move in the opposite direction.  This means an update. <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  , <img src="https://habrastorage.org/getpro/habr/post_images/a3d/f35/bfb/a3df35bfb983320e4886f942f10f2dbf.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/2f0/8a1/c1d/2f08a1c1d5beb0c79414300a6fcb9eac.png">  in the following way: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a2/e33/109/3a2e331090c01c1ff281ff98611e15ac.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec0/1b8/502/ec01b85029b57cd6d4093a4cceb816d7.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/4e9/1ac/73d4e91ac6309ec974c92c7199f21b8c.png"></div><br><br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/5e8/daa/a7e/5e8daaa7e7caf8e2e982714e3d0742db.png">  - this is the <strong>learning rate</strong> , a positive parameter that controls the speed of removal from the rising gradient. <br><br><h3>  Implementation </h3><br>  Now we have all the knowledge necessary to implement a simple gradient descent in C #.  Let's start with a function that calculates the approximate value of the partial gradient of the <code>i</code> -th articulation.  As mentioned above, for this we need to create a function sample. <img src="https://habrastorage.org/getpro/habr/post_images/914/e51/fa2/914e51fa2259c7c994c7198b38625a18.png">  (which is our error function <code>DistanceFromTarget</code> , described in ‚ÄúIntroducing Gradient Descent‚Äù) at two points: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PartialGradient</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] angles, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  , //     float angle = angles[i]; // : [F(x+SamplingDistance) - F(x)] / h float f_x = DistanceFromTarget(target, angles); angles[i] += SamplingDistance; float f_x_plus_d = DistanceFromTarget(target, angles); float gradient = (f_x_plus_d - f_x) / SamplingDistance; //  angles[i] = angle; return gradient; }</span></span></code> </pre> <br>  When this function is called, it returns a single number that determines how the distance from the target changes as a function of the rotation of the joint. <br><br>  We need to cycle through all the joints, calculating their effect on the gradient. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InverseKinematics</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] angles</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Joints.Length; i ++) { <span class="hljs-comment"><span class="hljs-comment">//   //  : Solution -= LearningRate * Gradient float gradient = PartialGradient(target, angles, i); angles[i] -= LearningRate * gradient; } }</span></span></code> </pre> <br>  Repeated calls to <code>InverseKinematics</code> move the robotic arm closer to the target point. <br><br><h3>  Premature termination </h3><br>  One of the main problems of inverse kinematics implemented by this naive approach is the low probability of the final convergence of the gradient.  Depending on the values ‚Äã‚Äãchosen for <code>LearningRate</code> and <code>SamplingDistance</code> very possible that the manipulator will ‚Äúswing‚Äù alongside the true solution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bc/88a/ead/8bc88aead567d0e14462a799807d1a6e.gif"><br><br>  This is because we update the corners too often, and this leads to a ‚Äúhop‚Äù over the true point.  The correct solution to this problem is the use of adaptive learning rate, which varies depending on the proximity to the solution.  A cheaper alternative is to stop the optimization algorithm if we are closer than a certain threshold value: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InverseKinematics</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] angles</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DistanceFromTarget(target, angles) &lt; DistanceThreshold) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Joints.Length <span class="hljs-number"><span class="hljs-number">-1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i --) { <span class="hljs-comment"><span class="hljs-comment">//   //  : Solution -= LearningRate * Gradient float gradient = PartialGradient(target, angles, i); angles[i] -= LearningRate * gradient; //   if (DistanceFromTarget(target, angles) &lt; DistanceThreshold) return; } }</span></span></code> </pre> <br>  If we repeat this check after each rotation of the articulation, we will perform the minimum number of movements required. <br><br>  To further optimize the motion of the manipulator, we can apply a gradient descent in the reverse order.  If we start at the end link and not at the bottom, this will allow us to make shorter movements.  In general, these small tricks allow you to get closer to a more <i>natural</i> solution. <br><br><h3>  Restrictions </h3><br>  One of the characteristics of real joints is that they usually have a limited range of possible angles of rotation.  Not all joints can rotate 360 ‚Äã‚Äãdegrees around its axis.  So far we have not imposed any restrictions on our optimization algorithm.  This means that we are likely to get this behavior: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ba/4f8/a17/9ba4f8a1748f60c266ed2e65c1d63ec8.gif" alt="image"><br><br>  The solution is pretty obvious.  We will add minimum and maximum angles to the <code>RobotJoint</code> class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RobotJoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Axis; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 StartOffset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MinAngle; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MaxAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartOffset = transform.localPosition; } }</code> </pre> <br>  then you need to make sure that we limit the corners to the desired range: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InverseKinematics</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] angles</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DistanceFromTarget(target, angles) &lt; DistanceThreshold) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Joints.Length <span class="hljs-number"><span class="hljs-number">-1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i --) { <span class="hljs-comment"><span class="hljs-comment">//   //  : Solution -= LearningRate * Gradient float gradient = PartialGradient(target, angles, i); angles[i] -= LearningRate * gradient; //  angles[i] = Mathf.Clamp(angles[i], Joints[i].MinAngle, Joints[i].MaxAngle); //   if (DistanceFromTarget(target, angles) &lt; DistanceThreshold) return; } }</span></span></code> </pre> <br><h3>  Problems </h3><br>  Even with limited angles and premature termination, the algorithm we used is very simple.  Too simple.  Many problems can arise with this solution, and most of them are associated with a gradient descent.  As it is written in ‚ÄúIntroducing Gradient Descent,‚Äù the algorithm can get stuck in <strong>local minima</strong> .  They are <em>suboptimal solutions</em> : unnatural or undesirable ways of achieving the goal. <br><br>  Look at the animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/931/b13/40e931b138d3282015972235a7a3d77a.gif"></div><br>  The arm of the manipulator went too far, and when it returned to its original position, it turned over.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The best way to avoid this is to use </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the comfort function</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If we have reached the required point, then we need to try to change the orientation of the manipulator to a more comfortable, natural position. </font><font style="vertical-align: inherit;">It should be noted that this is not always possible. </font><font style="vertical-align: inherit;">Changing the orientation of the manipulator can cause the algorithm to increase the distance to the target, which may contradict its parameters.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 6. Inverse kinematics of tentacles </font></font></h2><br><h3>  Introduction </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous section, we explored the use of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gradient descent</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to implement the inverse kinematics of a robotic arm. The movement performed by mechanisms is quite simple, because they do not have the complexity of real human body parts. Each joint of the robotic arm is controlled by the engine. In the human body, each muscle is de facto an independent motor that can stretch and contract. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some creatures have body parts that have several degrees of freedom. An example is the trunk of an elephant and the tentacle of an octopus. Modeling such body parts is a particularly difficult task, because the above traditional techniques cannot create realistic results.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will start with an example from the previous part and gradually come to a behavior that will be quite realistic for our purposes. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentacle rigging </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the robot manipulator we created, each part moved independently of the others. </font><font style="vertical-align: inherit;">Tentacles, unlike a robot, can be bent. </font><font style="vertical-align: inherit;">This is a necessary feature that cannot be ignored if we want to focus on realism. </font><font style="vertical-align: inherit;">Our tentacle must be able to bend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Unity component that allows this feature to be implemented is called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skinned Mesh Renderer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/981/636/b8f/981636b8ff30f6e22bf1dee0905de817.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, Unity does not provide the ability to create a skinning mesh renderer in the editor. </font><font style="vertical-align: inherit;">A 3D model editor is required, for example, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The image below shows the tentacle model that we will use in this part. </font><font style="vertical-align: inherit;">Inside you can see several </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bones</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connected to each other. </font><font style="vertical-align: inherit;">These are objects that allow us to bend the model.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/319/fc6/b4e/319fc6b4e2336cb6e3583b4406dba640.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this tutorial, we will not explore adding bones to models, also called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rigging</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A good introduction to the subject can be found in the </font></font><a href="https://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Bones"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender 3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> article </font><a href="https://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Bones"><font style="vertical-align: inherit;">: Noob to Pro / Bones</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bones and joints </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next stage of realization of the inverse tentacle kinematics is the attachment of a script to each bone </font></font><code>RobotJoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Because of this, we give our inverse kinematics algorithm the opportunity to bend the tentacle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a normal octopus, each joint can rotate freely in all three axes. Unfortunately, the code written for the robot manipulator allows rotation of the joints along one axis only. If we try to change this, we will add a new level of complexity to our code. Instead, we can cyclically change the axis of the joints so that the joint 0 turns in X, the joint 1 in Y, the joint 2 in Z, and so on. This can lead to unnatural behavior, but such a problem you may never have if the bones are small enough.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the downloadable Unity project sold with this tutorial, the script </font></font><code>SetRobotJointWeights</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">automatically initializes the parameters of all tentacle junctions. </font><font style="vertical-align: inherit;">You can do it manually to have more precise control over the movement of each bone.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comfort function </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The animation below shows two tentacles. </font><font style="vertical-align: inherit;">The tentacle on the left stretches to the red sphere using an algorithm from Inverse Kinematics for a Robotic Arm. </font><font style="vertical-align: inherit;">The right tentacle adds a whole new level of realism, twisting spirally, in a more organic style. </font><font style="vertical-align: inherit;">This example should be enough to understand why the tentacles need their own tutorial.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/673/d56/53e673d567b7ee469d2f942461b00082.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradient descent is used for both tentacles. </font><font style="vertical-align: inherit;">The difference lies in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the error function</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which they seek to minimize. </font><font style="vertical-align: inherit;">The mechanical tentacle on the left simply seeks to reach the ball, it does not care about all the other parameters. </font><font style="vertical-align: inherit;">As soon as the final link touches the ball, the approach is considered complete and the tentacle just stops moving. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The tentacle on the right minimizes another function. </font><font style="vertical-align: inherit;">The function </font></font><code>DistanceFromTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used for the manipulator is replaced with a new, more complex function. </font><font style="vertical-align: inherit;">We can make this new feature </font></font><code>ErrorFunction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">take into account other parameters that are important to us. </font><font style="vertical-align: inherit;">Tentacles shown in this tutorial minimize three different functions:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distance to target</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ready</font></font><br><br></li><li> <strong>  </strong> :      ,     .       ,       .       ,   ,      .       ,    .             .  Unity      ‚Äî <code>Quaternion.Angle</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationPenalty = Mathf.Abs ( Quaternion.Angle(EndEffector.rotation, Destination.rotation) / <span class="hljs-number"><span class="hljs-number">180f</span></span> );</code> </pre> <br>          .        . <br><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torsion</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : keep parts of the body unnaturally uncomfortable. </font><font style="vertical-align: inherit;">This parameter ‚Äúpenalizes‚Äù curvilinear motions, causing inverse kinematics to perform a more linear, simple turn. </font><font style="vertical-align: inherit;">To calculate the penalty for torsion, we first need to determine what ‚Äútorsion‚Äù is in this context. </font><font style="vertical-align: inherit;">It is easiest to define it as the average angle for all joints. </font><font style="vertical-align: inherit;">Such a penalty tends to keep the tentacle relaxed, and ‚Äúpunishes‚Äù solutions that require a large number of bends.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> torsionPenalty = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; solution.Length; i++) torsionPenalty += Mathf.Abs(solution[i]); torsionPenalty /= solution.Length;</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These three limitations lead to a more realistic tentacle movement. </font><font style="vertical-align: inherit;">A more complex version can provide fluctuations, even when the conditions satisfy all other restrictions.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use different units?</font></font></b> <div class="spoiler_text">   ,  ,      .       ,     ‚Äî  .       ,          ,       . <br><br>       <img src="https://habrastorage.org/getpro/habr/post_images/43d/301/721/43d3017219e30bc7086564e9afdb5237.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/703/db3/abb/703db3abb5dfb986f61bad7a764a4cd2.png">  .           : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrorFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] angles</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NormalisedDistance(target, angles) * DistanceWeight + NormalisedRotation(target, angles) * RotationWeight + NormalisedTorsion (target, angles) * TorsionWeight ; }</code> </pre> <br>           .      ,        . ,   <code>TorsionWeight</code> ,    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have no analytical definition!</font></font></b> <div class="spoiler_text">       .  ,     ,   .            . <br><br>       , , ,    .     ,      ,          .    ,      (!)   ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enhancements </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practically there are no restrictions for making improvements to our model. Improving the realism of the tentacles will definitely help slowdown function. Tentacles should move slower when approaching the goal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the tentacles should not intersect each other. To avoid this, use colliders for each joint. However, this can lead to freakish behavior. In our code, collisions are ignored and it can come closer to a solution in which self-intersections occur. The solution is to change the fitness function so that solutions with self-intersection have high penalties. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[A ready-made Unity project with scripts and 3D models can be purchased for $ 10 on the </font></font><a href="https://www.patreon.com/posts/8928832"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> page of the </font><font style="vertical-align: inherit;">author of the original article.]</font></font></i> <br><br> <i> , ,            .      :</i> </div><p>Source: <a href="https://habr.com/ru/post/332198/">https://habr.com/ru/post/332198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332188/index.html">Three days like all ticket offices in the country should become online (in fact, not)</a></li>
<li><a href="../332190/index.html">The tale of how an Android developer spammers, and that came out of it</a></li>
<li><a href="../332192/index.html">Canvas - almost like SVG</a></li>
<li><a href="../332194/index.html">ArrayBuffer and SharedArrayBuffer in JavaScript, part 3: race streams and Atomics</a></li>
<li><a href="../332196/index.html">How to organize secure access using VPN</a></li>
<li><a href="../332200/index.html">VeeamON 2017: what marketers do not write in blogs</a></li>
<li><a href="../332202/index.html">About analytics and silver bullets or ‚ÄúWhat does Rambler / Top 100 have to do with it?‚Äù</a></li>
<li><a href="../332204/index.html">GitLab 9.3 released: Code Quality and inter-project pipeline schedules</a></li>
<li><a href="../332206/index.html">How to repeat anyroom.io service in several JS lines and without a backend</a></li>
<li><a href="../332208/index.html">Solving the traveling salesman problem with the Little algorithm with visualization on the plane</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>