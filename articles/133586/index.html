<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt Quick and Box2d: Simulate Physics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post participates in the competition " Smart phones for smart posts " 

 Even despite the fact that many programmers at the moment are not in a h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt Quick and Box2d: Simulate Physics</h1><div class="post__text post__text-html js-mediator-article">  This post participates in the competition " <a href="http://habrahabr.ru/company/Nokia/blog/132522/">Smart phones for smart posts</a> " <br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/dc5/568/16b/dc556816b058b84ecd25281af1fe73c1.jpg" alt="image"><br>  Even despite the fact that many programmers at the moment are not in a hurry to put the development of their applications and games on Qt Quick, the infrastructure around the technology itself is growing and developing every day. <br><br>  So it came to the simulation of physics in two-dimensional space.  Or rather, before the appearance of the QML-plugin.  which allows, with the inherent Qt Quick, to easily integrate the physics engine Box2D into its applications.  That's about it today and talk.  Or rather, let's look at the example of the implementation of a simple arkanoid, how quickly you can create a simple game, never before working with physics engines and almost neznaya terminology. <br><a name="habracut"></a><br><h4>  Link QML and Box2d </h4><br>  First of all, we need to get the source of the plugin.  To do this, click on the link <a href="https://gitorious.org/qml-box2d/qml-box2d/trees/master">gitorious.org/qml-box2d/qml-box2d/trees/master</a> and on the right click on the ‚ÄúDownload master as tar.gz‚Äù button.  Postpone until the archive aside and go to Qt Creator. <br><br>  Here, we create a new project, such as "Qt Qucik Application".  In the wizard, enter the name, location in the file system, select the Qt profile, then, further, complete. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And now one of the most important parts begins.  And usually one of the most difficult in OTHER languages ‚Äã‚Äãand technologies.  You must actually connect the plugin to the newly created application.  To do this, unpack the resulting archive into the root directory of the application and rename the resulting directory qml-box2d-qml-box2d to qml-box2d.  B we add one new line to the .pro file of our application: <br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span>(qml-box2d/box2d-static.pri)</code> </pre> <br>  And main.cpp we will result in such type: <br><pre> <code class="hljs rust">#include &lt;QtGui/QApplication&gt; #include <span class="hljs-string"><span class="hljs-string">"qmlapplicationviewer.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"box2dplugin.h"</span></span> Q_DECL_EXPORT int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *argv[]) { QScopedPointer&lt;QApplication&gt; app(createApplication(argc, argv)); Box2DPlugin plugin; plugin.registerTypes(<span class="hljs-string"><span class="hljs-string">"Box2D"</span></span>); QScopedPointer&lt;QmlApplicationViewer&gt; viewer(QmlApplicationViewer::create()); viewer-&gt;setOrientation(QmlApplicationViewer::ScreenOrientationLockLandscape); viewer-&gt;setMainQmlFile(QLatin1String(<span class="hljs-string"><span class="hljs-string">"qml/Quickanoid/main.qml"</span></span>)); viewer-&gt;showExpanded(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app-&gt;exec(); }</code> </pre><br>  Here the line #include "box2dplugin.h" includes the plugin header, and the lines <br><pre> <code class="hljs objectivec"> Box2DPlugin plugin; plugin.registerTypes(<span class="hljs-string"><span class="hljs-string">"Box2D"</span></span>);</code> </pre><br>  register in the application the types of Qt / Box2D, which will be available and necessary for us in the future in QML. <br>  That's all.  This is enough to connect the plugin as a statically linked library.  Of course, a plugin can be assembled as an independent unit and put in a general directory of all QML plug-ins in the system.  But for our goal and the first option.  The appearance of the resulting project is approximately as follows: <br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/053/640/c3b053640eb0f0bca0bfb118ced05680.jpg" alt="image"><br><br>  If we try to compile the application now, we will see the standard Hello World, which is the default project template in Qt Quick.  But it is not interesting.  We are interested in using physics. <br><br><h4>  We formalize the description of the game </h4><br>  So, we have decided what we will do arkanoid.  We list what we need in the toy of this plan: <br><ul><li>  The default 360x640 window is for easier porting to mobile devices in the future.  And of course fixing it in landscape mode. </li><li>  The background of the application is a simple picture, against which it will be convenient to play. </li><li>  4 walls bordering our world at the edges of the window. </li><li>  Bulb flying within the world. </li><li>  Platform at the bottom of the window, to beat the ball. </li><li>  Several bricks in the upper part of the window, which must be knocked down with our ball. </li><li>  Time counter on the screen. </li><li>  Starting and finishing screens of the game. </li></ul><br><h4>  Implement the task </h4><br>  It is for this simple TZ that we will work further.  As shown above, in main.cpp, we have already instructed our application to run in landscape mode.  It means more need to edit C ++ - we have no code.  Open the main.qml file and bring it to the form: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QtQuick</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Box2D</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Image</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: screen; <span class="hljs-attribute"><span class="hljs-attribute">source</span></span>: <span class="hljs-string"><span class="hljs-string">"images/bg.jpeg"</span></span> width: <span class="hljs-number"><span class="hljs-number">640</span></span> height: <span class="hljs-number"><span class="hljs-number">360</span></span> World { id: world width: screen.width height: screen.height gravity.x: <span class="hljs-number"><span class="hljs-number">0</span></span> gravity.y: <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre><br>  What have we done?  We created a window with the size of 640x360, set its background and added one child element of the World type, which in the future should be the ancestor for all physical objects.  As it is easy to guess, the World object describes the entire game world and sets its basic parameters, namely: <br><ul><li>  gravity ‚Äî X and Y gravity. For our application, gravity is not needed. </li><li>  And a few parameters, with the correct translation of which, unfortunately, I have problems: timeStep, velocityIterations, positionIterations, frameTime </li></ul><br>  Their description can be peeped in the box2dworld.h header file. <br><br>  An empty three-line physical world is cool.  But let's dilute it with statics.  Or walls, as you like.  Create a new QML file, let's call it Wall.qml.  add next to the application and fill in the following contents: <br><pre> <code class="hljs mel">import QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> import Box2D <span class="hljs-number"><span class="hljs-number">1.0</span></span> Body { property <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">source</span></span> bodyType: Body.Static fixtures: Box { anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> friction: <span class="hljs-number"><span class="hljs-number">1.0</span></span> } Rectangle { anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"brown"</span></span> } Image { id: <span class="hljs-keyword"><span class="hljs-keyword">image</span></span> anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>: <span class="hljs-string"><span class="hljs-string">"images/wall.jpg"</span></span> fillMode: Image.Tile } }</code> </pre><br><h5>  Break on theory </h5><br>  The wall, like all objects on the scene (and the Wold object is essentially a scene), are objects of type Body.  Therefore, Body is the base class for all physical elements.  It has the following properties: <br><ul><li>  active - enable / disable physics on the element </li><li>  linearVelocity - linear acceleration </li><li>  fixtures - the boundaries of the body, which will be determined by collisions </li><li>  bodyType - body type, static, dynamic or kinematic </li><li>  fixedRotation - disable rotation </li><li>  sleepingAllowed - allow physics to automatically turn off to save resources </li><li>  linearDamping, angularDamping, bullet - not clear at first glance </li></ul><br>  The body, as such, cannot handle collisions with other objects.  In order to teach the body this, you must set the fixtures property.  Values ‚Äã‚Äãfor this property can be Circle, Box and Polygon.  All of them are descendants of the base class Fixture, which is responsible for interacting with other objects.  Independently, of course, it is not available from QML, but only after three of its descendants.  We list the properties available for clarity. <br>  Fixture class: <br><ul><li>  density </li><li>  friction - friction force </li><li>  restitution - resilience / recoil </li><li>  groupIndex - the index in the group (presumably the group is one Body object) </li><li>  collidesWith - list of objects.  with which the current object is in contact at the moment </li><li>  sensor, categories - advanced parameters </li></ul><br>  Each of the descendants slightly extends this class with its own properties: <br><ul><li>  The Box class does not add new properties, but uses standard widths and heights to define the boundaries of the rectangle. </li><li>  The Circle class introduces the radius property, which oddly enough is the radius of a circular object, such as a wheel. </li><li>  The Polygon class adds a verticles property containing a list of object vertices for more accurate physical simulation. </li></ul><br><h5>  Back to practice </h5><br>  From theory it becomes clear that the wall is a physical body (Body) of the rectangle type (Box) and is graphically represented as a filled picture.  And now, having one wall, we can create as many walls as we like, we also need them 4. Open the main.qml and inside the World object, after gravity.y: 0, add a description of our walls: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Wall</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: wallLeft width: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { bottom: parent.bottom left: parent.left top: parent.top } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wall</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: wallRight width: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { bottom: parent.bottom right: parent.right top: parent.top } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wall</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: wallTop height: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { left: parent.left right: parent.right top: parent.top } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wall</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: wallBottom height: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { left: parent.left right: parent.right bottom: parent.bottom } }</code> </pre><br>  We save everything and run our application, on the screen we will see a background image and 4 walls framing the world at the edges. <br><img src="https://habrastorage.org/getpro/habr/post_images/d5d/364/954/d5d364954cc2518dcc84d63c7eb63c0e.jpg" alt="image"><br>  Further, according to the plan we have a ball that can fly within our world and hit the walls.  To describe the ball, create the Ball.qml file and fill it with the following contents: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QtQuick</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Box2D</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: ball fixedRotation: false sleepingAllowed: false fixtures: Circle { id: circle radius: <span class="hljs-number"><span class="hljs-number">12</span></span> anchors.fill: parent density: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">friction</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">restitution</span></span>: <span class="hljs-number"><span class="hljs-number">1.05</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Image</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: circleRect anchors.centerIn: parent width: circle.radius * <span class="hljs-number"><span class="hljs-number">2</span></span> height: width smooth: true source: <span class="hljs-string"><span class="hljs-string">"images/ball.png"</span></span> } }</code> </pre><br>  The same as with the wall, but instead of Box we have Circle.  Add our ball to the world we created, after describing the last wall in the World object, we add the ball description: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Ball</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: ball x: parent.width/<span class="hljs-number"><span class="hljs-number">2</span></span> y: parent.height/<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  We start, we see the ball in the center of the screen, which does not move anywhere due to the lack of gravity and linear acceleration.  From clever what ... <br>  The next step is a platform representing the only player control with which we will beat the ball.  According to the previous scheme, the new Platform.qml file, in it: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QtQuick</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Box2D</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: platform width: platformBg.width height: platformBg.height x: parent.width/<span class="hljs-number"><span class="hljs-number">2</span></span> - width/<span class="hljs-number"><span class="hljs-number">2</span></span> y: parent.height - platformBg.height - <span class="hljs-number"><span class="hljs-number">5</span></span> bodyType: Body.Static fixtures: Box { id: platformBox anchors.fill: parent friction: <span class="hljs-number"><span class="hljs-number">10</span></span> density: <span class="hljs-number"><span class="hljs-number">300</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Image</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: platformBg smooth: true source: <span class="hljs-string"><span class="hljs-string">"images/platform.png"</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">MouseArea</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">anchors.fill</span></span>: parent drag.target: platform drag.axis: Drag.XAxis drag.minimumX: <span class="hljs-number"><span class="hljs-number">0</span></span> drag.maximumX: screen.width - platform.width } }</code> </pre><br>  This physical object differs from the others in that we allow the user to lead them around the screen with the mouse / finger cursor in the horizontal direction.  After the Ball description, we add a description of the platform to main.qml: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Platform</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: platform }</code> </pre><br>  At the moment, I advise you to remember our walls.  For good, we know that they work, but since we are limited by the screen size, we can hide our walls off the screen.  so as not to hurt the eyes and do not interfere.  To do this, in turn, we will add one of the following properties to each of the Wall objects inside the World: left leftMargin: -width, right rightMargin: -width, top topMargin: -height, and bottom bottomMargin: -height.  After that, we re-launch and look at what we get: <br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/1e0/18c/5fa1e018cf3bf52a6ccfa40f99cc2cc0.jpg" alt="image"><br><br>  The next item of our plan.  Bricks that must be knocked down with a ball.  But!  We must not forget that we will not have enough space on the screen.  Therefore, we will try to implement this part of the game differently.  Namely - at the top of the screen there will be several bricks of green color, on which it is constantly necessary to hit the ball, preventing them from turning red.  If the brick becomes red finally - peel on it already to no purpose.  And in the game, we introduce a timer that counts the amount of time until all the bricks turn red.  The animation of the transition from green to red will be equal to for example 20 seconds.  After the brick turns red, it disappears.  If we have time to get on the brick, then the 20-second timer is reset and the brick begins to redden again.  Let's start with the description of the brick in the Brick.qml file: <br><pre> <code class="hljs php">import QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> import Box2D <span class="hljs-number"><span class="hljs-number">1.0</span></span> Body { id: brick width: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.width/<span class="hljs-number"><span class="hljs-number">5</span></span> - <span class="hljs-number"><span class="hljs-number">5</span></span> height: <span class="hljs-number"><span class="hljs-number">15</span></span> anchors { top: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.top topMargin: -height/<span class="hljs-number"><span class="hljs-number">2</span></span> } signal disappear() property bool contacted : <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> bodyType: Body.<span class="hljs-keyword"><span class="hljs-keyword">Static</span></span> fixtures: Box { anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> friction: <span class="hljs-number"><span class="hljs-number">1.0</span></span> onBeginContact: { contacted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } onEndContact: { contacted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } } Timer { id: timer interval: <span class="hljs-number"><span class="hljs-number">20000</span></span>; running: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; repeat: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> onTriggered: { brick.visible = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; brick.active = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; disappear(); } } Rectangle { id: brickRect anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> radius: <span class="hljs-number"><span class="hljs-number">6</span></span> state: <span class="hljs-string"><span class="hljs-string">"green"</span></span> states: [ State { name: <span class="hljs-string"><span class="hljs-string">"green"</span></span> when: brick.contacted PropertyChanges { target: brickRect color: <span class="hljs-string"><span class="hljs-string">"#7FFF00"</span></span> } PropertyChanges { target: timer running: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } }, State { name: <span class="hljs-string"><span class="hljs-string">"red"</span></span> when: !brick.contacted PropertyChanges { target: brickRect color: <span class="hljs-string"><span class="hljs-string">"red"</span></span> } PropertyChanges { target: timer running: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } ] transitions: [ Transition { from: <span class="hljs-string"><span class="hljs-string">"green"</span></span> to: <span class="hljs-string"><span class="hljs-string">"red"</span></span> ColorAnimation { from: <span class="hljs-string"><span class="hljs-string">"#7FFF00"</span></span>; to: <span class="hljs-string"><span class="hljs-string">"red"</span></span>; duration: <span class="hljs-number"><span class="hljs-number">20000</span></span>; } } ] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ brick.visible = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; brick.active = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; state = <span class="hljs-string"><span class="hljs-string">"green"</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ brick.visible = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; brick.active = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre><br>  As you can see, there is also nothing complicated here: a description of the body, a description of its display, two states with smooth animation of the transition between them, a timer counting down 20 seconds with a restart after each collision with the ball and the auxiliary function show ().  In the main.qml file, after the platform announcement, we add the advertisements of our bricks: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Brick</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: brick1 x: <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">onDisappear</span></span>: bricksCount-- } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Brick</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: brick2 anchors { left:brick1.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">onDisappear</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">bricksCount--</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Brick</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: brick3 anchors { left:brick2.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">onDisappear</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">bricksCount--</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Brick</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: brick4 anchors { left:brick3.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">onDisappear</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">bricksCount--</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Brick</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: brick5 anchors { left:brick4.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">onDisappear</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">bricksCount--</span></span> }</code> </pre><br>  By the way, don‚Äôt ask me why I didn‚Äôt use the Row and Repeat elements - using them to automatically create the Body type, the application crashes.  At the very beginning of the file we will add the declaration of a new variable, after determining the height and width: <br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> bricksCount: <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  According to it, we will count the number of remaining bricks, when it reaches the example of two - we end the game.  That is, the logic of user interaction with the game will be simple - it is necessary that at least three bricks remain on the screen as much as possible.  We describe the seconds counter at the very bottom of the World object: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Text</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: secondsPerGame anchors { bottom: parent.bottom left: parent.left } <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: "<span class="hljs-selector-tag"><span class="hljs-selector-tag">white</span></span>" <span class="hljs-selector-tag"><span class="hljs-selector-tag">font</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pixelSize</span></span>: 36 <span class="hljs-selector-tag"><span class="hljs-selector-tag">text</span></span>: "0" <span class="hljs-selector-tag"><span class="hljs-selector-tag">Timer</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">interval</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">running</span></span>: true; <span class="hljs-attribute"><span class="hljs-attribute">repeat</span></span>: true onTriggered: secondsPerGame.text = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(secondsPerGame.text) + <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br>  What do we have left?  It remains to add the start and finish screens, well, a bit to correct the logic of the game.  Actually it is the little things that you can omit in the article.  I‚Äôll just give you a complete final listing of the main.qml file: <br><pre> <code class="hljs mel">import QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> import Box2D <span class="hljs-number"><span class="hljs-number">1.0</span></span> Image { id: screen; <span class="hljs-keyword"><span class="hljs-keyword">source</span></span>: <span class="hljs-string"><span class="hljs-string">"images/bg.jpeg"</span></span> width: <span class="hljs-number"><span class="hljs-number">640</span></span> height: <span class="hljs-number"><span class="hljs-number">360</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bricksCount: <span class="hljs-number"><span class="hljs-number">5</span></span> World { id: world width: screen.width height: screen.height visible: false <span class="hljs-keyword"><span class="hljs-keyword">gravity</span></span>.x: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">gravity</span></span>.y: <span class="hljs-number"><span class="hljs-number">0</span></span> Wall { id: wallLeft width: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { bottom: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.bottom left: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.left leftMargin: -width top: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.top } } Wall { id: wallRight width: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { bottom: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.bottom right: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.right rightMargin: -width top: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.top } } Wall { id: wallTop height: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { left: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.left right: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.right topMargin: -height top: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.top } } Wall { id: wallBottom height: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors { left: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.left right: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.right bottom: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.bottom bottomMargin: -height } onBeginContact: { console.<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>(other) finishGame() } } Ball { id: ball x: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.width/<span class="hljs-number"><span class="hljs-number">2</span></span> y: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.height/<span class="hljs-number"><span class="hljs-number">2</span></span> } Platform { id: platform } Brick { id: brick1 x: <span class="hljs-number"><span class="hljs-number">3</span></span>; onDisappear: bricksCount-- } Brick { id: brick2 anchors { left:brick1.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } onDisappear: bricksCount-- } Brick { id: brick3 anchors { left:brick2.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } onDisappear: bricksCount-- } Brick { id: brick4 anchors { left:brick3.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } onDisappear: bricksCount-- } Brick { id: brick5 anchors { left:brick4.right leftMargin: <span class="hljs-number"><span class="hljs-number">5</span></span> } onDisappear: bricksCount-- } Text { id: secondsPerGame anchors { bottom: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.bottom left: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.left } <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"white"</span></span> font.pixelSize: <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> Timer { id: scoreTimer interval: <span class="hljs-number"><span class="hljs-number">1000</span></span>; running: true; repeat: true onTriggered: secondsPerGame.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span> = parseInt(secondsPerGame.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> } } } Item { id:screenStart anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> visible: false Text { id: startGame anchors.centerIn: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"white"</span></span> font.pixelSize: <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-string"><span class="hljs-string">"Start Game!"</span></span> MouseArea { anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> onClicked: { screen.startGame() } } } } Item { id:screenFinish anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> visible: false Text { id: score anchors.centerIn: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"white"</span></span> font.pixelSize: <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-string"><span class="hljs-string">"Game over! Your score is: "</span></span> + secondsPerGame.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span> } Text { id: restartGame anchors { top: score.bottom horizontalCenter: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.horizontalCenter } <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>: <span class="hljs-string"><span class="hljs-string">"white"</span></span> font.pixelSize: <span class="hljs-number"><span class="hljs-number">36</span></span> <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-string"><span class="hljs-string">"Restart Game!"</span></span> MouseArea { anchors.fill: <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> onClicked: { screen.startGame() } } } } function startGame() { screen.state = <span class="hljs-string"><span class="hljs-string">"InGame"</span></span>; bricksCount = <span class="hljs-number"><span class="hljs-number">5</span></span> brick1.show() brick2.show() brick3.show() brick4.show() brick5.show() secondsPerGame.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span> = <span class="hljs-string"><span class="hljs-string">"0"</span></span> platform.x = screen.width/<span class="hljs-number"><span class="hljs-number">2</span></span> - platform.width/<span class="hljs-number"><span class="hljs-number">2</span></span> ball.linearVelocity.x = <span class="hljs-number"><span class="hljs-number">0</span></span> ball.linearVelocity.y = <span class="hljs-number"><span class="hljs-number">0</span></span> ball.active = true; ball.x = platform.x + platform.width/<span class="hljs-number"><span class="hljs-number">2</span></span> ball.y = platform.y - ball.height ball.x = screen.width/<span class="hljs-number"><span class="hljs-number">2</span></span> ball.y = screen.height/<span class="hljs-number"><span class="hljs-number">2</span></span> ball.applyLinearImpulse(Qt.point(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>), Qt.point(ball.x, ball.y)) scoreTimer.running = true } function finishGame(){ screen.state = <span class="hljs-string"><span class="hljs-string">"FinishScreen"</span></span>; brick1.<span class="hljs-keyword"><span class="hljs-keyword">hide</span></span>() brick2.<span class="hljs-keyword"><span class="hljs-keyword">hide</span></span>() brick3.<span class="hljs-keyword"><span class="hljs-keyword">hide</span></span>() brick4.<span class="hljs-keyword"><span class="hljs-keyword">hide</span></span>() brick5.<span class="hljs-keyword"><span class="hljs-keyword">hide</span></span>() ball.active = false; ball.applyLinearImpulse(Qt.point(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), Qt.point(ball.x, ball.y)) scoreTimer.running = false } onBricksCountChanged: { console.<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>(bricksCount) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bricksCount &lt;=<span class="hljs-number"><span class="hljs-number">2</span></span>){ finishGame() } } Component.onCompleted: { startGame() } states: [ State { name: <span class="hljs-string"><span class="hljs-string">"StartScreen"</span></span> PropertyChanges { target: screenStart visible: true } }, State { name: <span class="hljs-string"><span class="hljs-string">"InGame"</span></span> PropertyChanges { target: world visible: true } }, State { name: <span class="hljs-string"><span class="hljs-string">"FinishScreen"</span></span> PropertyChanges { target: screenFinish visible: true } } ] state: <span class="hljs-string"><span class="hljs-string">"StartScreen"</span></span> }</code> </pre><br><h4>  In total </h4><br>  Here is a demo application.  Now I propose to look at what happened in the end, and then read a couple of concluding lines and write my impressions of the work done by the developers of the plugin.  We look: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/IP__u5ze0ik%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhgNNhaVxJEv07sb98P-HWHUXiUWPw" frameborder="0" allowfullscreen=""></iframe><br>  In my opinion it turned out well.  In fact, the development of the application itself and the writing of this article took only two evenings (yesterday and today).  First of all, it speaks of the simplicity and very low threshold for entering development using QML, and secondly, of the quality of the code that developers over and over again manage to achieve both the Qt framework and third-party developers writing similar plug-ins for it. <br><br>  A plus.  Of course, I want to note that Box2D itself is not tied to any OS and is platform independent, therefore, the created application will work equally well on desktop as well as on mobile platforms.  Well, even in this example, you can see screenshots from under Windows and videos from under Linux. <br><br>  Of course.  This article does not cover all the functionality of Box2D, which was transferred to QML, there are still at least Joint s.  On the other hand, I believe that this material is quite enough for understanding the essence of things.  And already having an idea about the QML / Box2D bundle, you can easily rivet toys using physics.  It can also be labyrinths using the phone‚Äôs accelerometer and falling cubes that are fun to blow from each other, cars and cars like X-Moto, and much more.  In this case, do not forget.  that QML is only a wrapper on C ++ classes and the application itself will work as if originally written in C ++. <br><br>  As usual, source codes can be <a href="http://code.google.com/p/quickanoid/downloads/list">collected</a> on the project page: <a href="http://code.google.com/p/quickanoid/downloads/list">code.google.com/p/quickanoid/downloads/list</a> <br><br>  Thank you for your time. </div><p>Source: <a href="https://habr.com/ru/post/133586/">https://habr.com/ru/post/133586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133577/index.html">Micromouse - competition for small robots</a></li>
<li><a href="../133578/index.html">We use "Yandex Music" outside the browser</a></li>
<li><a href="../133579/index.html">Hasof endofunctors and their monoidal structure</a></li>
<li><a href="../133582/index.html">Who is a "good programmer"?</a></li>
<li><a href="../133583/index.html">St. Petersburg habravstrecha: Floors</a></li>
<li><a href="../133587/index.html">Preorder for ¬µTorrent Plus open</a></li>
<li><a href="../133588/index.html">Moscow Rescue Service will not reach the age of majority?</a></li>
<li><a href="../133589/index.html">Another SED or ...?</a></li>
<li><a href="../133591/index.html">Professional 2: Sony Ericsson Xperia pro review</a></li>
<li><a href="../133592/index.html">Highlights of the HighLoad ++ 2011 Conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>