<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing the motion component for RTS in Unreal engine 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Dmitry, I am a programmer. I just finished refactoring the ship movement component for a real-time tactical game project in which playe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing the motion component for RTS in Unreal engine 4</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/498/8b7/68b/4988b768bcd3ae74e6f86c7cb44966f9.jpg" alt="image"><br><br>  Hi, my name is Dmitry, I am a programmer.  I just finished refactoring the ship movement component for a real-time tactical game project in which players can assemble their own space fleet and lead it into battle.  The movement component has been in correspondence three times already, from the release to the beginning of the development of the alpha version.  A lot of rakes were collected, both architectural and network.  I will try to bring all this experience and tell you about the Navigation Volume, Movement component, AIController, Pawn. <br><a name="habracut"></a><br>  <b>Task: to implement the process of moving a spacecraft on a plane.</b> <br><br>  Conditions of the problem: <br><ul><li>  The ship has a maximum speed, turning speed and acceleration speed.  These parameters determine the dynamics of the movement of the ship. </li><li>  You must use the Navigtaion Volume to automatically search for obstacles and lay a safe path. </li><li>  There should not be a constant synchronization of position coordinates over the network. </li><li>  We can start from different current speed states. </li><li>  Everything should be native to the Unreal architecture 4. </li></ul><br><h4>  Process architecture </h4><br>  We divide the task into two stages: the first is the search for the optimal path, the second is the movement to the end point under the cursor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Task one.  Search for the best path </h5><br>  Consider the conditions and architecture of the process of finding the optimal path in the Unreal engine 4. Our <b>UShipMovementComponent</b> is a component of the movement that is inherited from the <b>UPawnMovementComponent</b> , since  the final unit, the ship, will be the heir of <b>APawn</b> . <br><br>  In turn, <b>UPawnMovementComponent</b> is a descendant of <b>UNavMovementComponent</b> , which adds <b>FNavProperties to</b> it in its composition - these are navigation parameters describing the given <b>APawn</b> , and which <b>AIController</b> will use when searching for the path. <br><br>  Suppose we have a level at which our ship is located, static objects and a navigation volume covering it.  We ship the ship from one point of the map to another and this is what happens inside UE4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f9/721/2c6/6f97212c6b6a0f3504492abd02ed3860.jpg" alt="scheme41.jpg"><br><br>  1) <b>APawn</b> , finds <b>ShipAIController</b> within itself (in our case, it is just the heir of <b>AIController</b> , which has one single method) and calls the path search method we created. <br>  2) Inside this method, we first prepare a request to the navigation system, then send it and get control points of motion. <br><br><pre><code class="hljs rust">TArray&lt;FVector&gt; AShipAIController::SearchPath(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FVector&amp; location) { FPathFindingQuery Query; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> bValidQuery = PreparePathfinding(Query, location, NULL); UNavigationSystem* NavSys = UNavigationSystem::GetCurrent(GetWorld()); FPathFindingResult PathResult; TArray&lt;FVector&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NavSys) { PathResult = NavSys-&gt;FindPathSync(Query); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PathResult.<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> != ENavigationQueryResult::Error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PathResult.IsSuccessful() &amp;&amp; PathResult.Path.IsValid()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(FNavPathPoint point : PathResult.Path-&gt;GetPathPoints()) { <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>.Add(point.Location); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DumpToLog(<span class="hljs-string"><span class="hljs-string">"Pathfinding failed."</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, FColor::Red); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DumpToLog(<span class="hljs-string"><span class="hljs-string">"Can't find navigation system."</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, FColor::Red); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>; }</code> </pre> <br>  3) These points are returned by <b>APawn</b> 's list in a convenient format ( <b>FVector</b> ).  Further, the process of movement starts. <br>  Basically, <b>APawn</b> has <b>ShipAIController</b> , which when it calls <b>PreparePathfinding (),</b> calls <b>APawn</b> and receives a <b>UShipMovementComponent</b> , inside which it finds <b>FNavProperties</b> , which it passes to the navigation system to find the path. <br><br><h5>  Task two.  Movement to the end point. </h5><br>  So, we returned a list of control points of the movement.  The first point is always our current position, the last is our destination.  In our case, this is the place where we clicked the cursor, sending the ship. <br>  Here it is worth making a small digression and tell about how we are going to build work with the network.  Divide it into steps and write out each of them: <br><br>  1) We call the start method - <b>AShip :: CommandMoveTo ()</b> : <br><br><pre> <code class="hljs cpp">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">STARFALL_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AShip</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> APawn, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ITeamInterface { ... UFUNCTION(BlueprintCallable, Server, Reliable, WithValidation, Category = <span class="hljs-string"><span class="hljs-string">"Ship"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommandMoveTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommandMoveTo_Implementation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CommandMoveTo_Validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; ... }</code> </pre> <br>  Pay attention - on the client side, all Pawns have no <b>AIController</b> , they are only on the server.  Therefore, when the client calls the ship dispatch method to the new location, we must perform all the errors on the server.  In other words, the search for the path for each ship will be occupied by the server.  Because it is <b>AIController that</b> works with the navigation system. <br>  2) Once inside the <b>CommandMoveTo ()</b> method, we found a list of control points, we call the next one to start the movement of the ship.  This method must be called on all clients. <br><br><pre> <code class="hljs cpp">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">STARFALL_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AShip</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> APawn, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ITeamInterface { ... UFUNCTION(BlueprintCallable, Reliable, NetMulticast, Category = <span class="hljs-string"><span class="hljs-string">"Ship"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartNavMoveFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartNavMoveFrom_Implementation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; ... }</code> </pre> <br>  In this method, a client who has no control points includes the first coordinate transferred to him in the list of control points and ‚Äústarts the engine‚Äù, starting the movement.  At this moment, on the server, we start sending the remaining intermediate and end points of our path through timers: <br><br><pre> <code class="hljs php">void AShip::CommandMoveTo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FVector&amp; location) { ... GetWorldTimerManager().SetTimer(timerHandler, FTimerDelegate::CreateUObject(this, &amp;AShip::SendNextPathPoint), <span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); ... }</code> </pre> <br><pre> <code class="hljs cpp">UCLASS() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">STARFALL_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AShip</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> APawn, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ITeamInterface { ... FTimerHandle timerHandler; UFUNCTION(BlueprintCallable, Reliable, NetMulticast, Category = <span class="hljs-string"><span class="hljs-string">"Ship"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendPathPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendPathPoint_Implementation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FVector&amp; location)</span></span></span></span>; ... }</code> </pre> <br>  On the client side, as the ship begins to accelerate and move to the first control point of its path, it gradually gets the rest and puts them into an array.  This allows us to unload the network and stretch the sending data in time, distributing the load on the network. <br><br>  We finish with the retreat and return to the essence of the issue.  The current task is to start the flight towards the nearest control point.  Note that under the conditions, our ship has a turning speed, acceleration and maximum speed.  Consequently, at the moment of sending to a new destination, the ship can, for example, fly at full speed, stand, only accelerate, or be in the process of turning.  Therefore, the ship must conduct itself differently, based on the current speed characteristics and destination.  We have identified three main lines of behavior of the ship: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/297/97d/aeb/29797daeb0760390b8b9bd17d5e3da0f.png" alt="scheme3.png"><br><br><ul><li>  We can fly to the destination point without limiting ourselves in acceleration to at least the maximum speed and we will have enough turning speed to fit into the turn and arrive at the place. </li><li>  Considering our speed, we will fly too fast, so we will try to fly to the destination point on a short course, and when the ship‚Äôs nose indicates clearly in its direction, we will try to accelerate to the maximum speed </li><li>  If the path of movement takes more time than stupidly turn around and fly in a straight line, then we will go in a simple way. </li></ul><br>  So before you start moving to a point, we need to decide what speed parameters we will fly.  To do this, we implement the method of flight simulation.  I will not give her code here, if someone is very interested - write, tell.  The essence of it is simple - we, using the current <b>DeltaTime</b> , all the time we move the vector of our position and turn the direction of gaze forward, simulating the rotation of the ship.  These are the simplest operations on vectors, with the participation of the <b>FRotator</b> .  With a little effort of imagination, you realize it easily. <br><br>  The only point worth mentioning is that in each iteration of the turn of the ship you need to remember how far we have turned it.  If it is more than 180 degrees, this means that we are starting to circle around the destination point and we need to try the following speed parameters to try to get to the control point.  Naturally, at first we are trying to fly at full speed, then at a reduced one (we are now working at an average speed), and if none of these options came up, it means the ship should just turn around and fly. <br><br>  I want to draw your attention that all the logic of assessing the situation and the processes of movement should be implemented in <b>AShip</b> - because <b>AIController</b> 'and we do not have on the client, and the <b>UShipMovementComponent</b> plays a different role (about it a little lower, we have almost reached it).  Therefore, in order for our ships to move independently and without constant synchronization of coordinates with the server (which is not necessary), we must implement the motion control logic inside the <b>AShip</b> . <br><br>  So now the most important thing about all of this is our component of the <b>UShipMovementComponent</b> movement.  It should be realized that the components of these types are motors.  Their function is to give gas forward and rotate an object.  They do not think about what logic the object should move, they do not think about the state of the object.  They are only responsible for the actual movement of the object.  For fuel injection and space shift.  The logic of working with <b>UMovementComponent</b> and his heirs is as follows: we are at the <b>Tick ‚Äã‚Äã()</b> given to us, do all our mathematical calculations related to the parameters of our component (speed, maximum speed, speed of rotation), and then set the <b>UMovementComponent :: Velocity</b> parameter to relevant to the shift of our ship in this tick, then call <b>UMovementComponent :: MoveUpdatedComponent ()</b> - this is where the shift of our ship and its rotation. <br><br><pre> <code class="hljs ruby">void UShipMovementComponent::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) { Super::TickComponent(DeltaTime, TickType, ThisTickFunction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!PawnOwner <span class="hljs-params"><span class="hljs-params">||</span></span> !UpdatedComponent <span class="hljs-params"><span class="hljs-params">||</span></span> ShouldSkipUpdate(DeltaTime)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckState(EShipMovementState::Accelerating)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentSpeed &lt; CurrentMaxSpeed) { CurrentSpeed += Acceleration; AccelerationPath += CurrentSpeed*DeltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentSpeed = CurrentMaxSpeed; RemoveState(EShipMovementState::Accelerating); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckState(EShipMovementState::Braking)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentSpeed &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>.0f) { CurrentSpeed -= Acceleration; DeaccelerationPath += CurrentSpeed*DeltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentSpeed = <span class="hljs-number"><span class="hljs-number">0</span></span>.0f; CurrentMaxSpeed = MaxSpeed; RemoveState(EShipMovementState::Braking); RemoveState(EShipMovementState::Moving); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckState(EShipMovementState::SpeedDecreasing)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CurrentSpeed &gt; CurrentMaxSpeed) { CurrentSpeed -= Acceleration; DeaccelerationPath += CurrentSpeed*DeltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CurrentSpeed = CurrentMaxSpeed; RemoveState(EShipMovementState::SpeedDecreasing); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CheckState(EShipMovementState::Moving) <span class="hljs-params"><span class="hljs-params">||</span></span> CheckState(EShipMovementState::Turning)) { MoveForwardWithCurrentSpeed(DeltaTime); } } ... void UShipMovementComponent::MoveForwardWithCurrentSpeed(float DeltaTime) { Velocity = UpdatedComponent-&gt;GetForwardVector() * CurrentSpeed * DeltaTime; MoveUpdatedComponent(Velocity, AcceptedRotator, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); UpdateComponentVelocity(); } ...</code> </pre> <br>  I will say two words about the states that appear here.  They are necessary in order to combine different processes of movement.  We can, for example, reduce the speed (because for maneuver we need to go to the average speed) and turn in the direction of the new destination point.  In the motion component, we use them only to evaluate work with speed: do we need to continue to pick up speed, or its reduction, etc.  All the logic relating to transitions from one state of motion to another, as I said, occurs in <b>AShip</b> : for example, we go at maximum speed, and we are changed to a destination point, and to achieve it we need to slow down to the average. <br><br>  And the last two pennies about <b>AcceptedRotator</b> .  This is our turn of the ship in this tick.  In the <b>AShip tick,</b> we call the following method of our <b>UShipMovementComponent</b> : <br><br><pre> <code class="hljs rust"><span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> UShipMovementComponent::AcceptTurnToRotator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FRotator&amp; RotateTo) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(FMath::Abs(RotateTo.Yaw - UpdatedComponent-&gt;GetComponentRotation().Yaw) &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } FRotator tmpRot = FMath::RInterpConstantTo(UpdatedComponent-&gt;GetComponentRotation(), RotateTo, GetWorld()-&gt;GetDeltaSeconds(), AngularSpeed); AcceptedRotator = tmpRot; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>RotateTo = (GoalLocation - ShipLocation) .Rotation ()</b> - i.e.  This is a rotator, which means in what value the rotation of the ship should be in order to look at the destination point.  And in this method, we estimate, but does not the ship look at the destination point?  If it looks, then such a result is returned, then we no longer need to turn around.  And our <b>AShip,</b> in its logic of assessing the situation, will reset the state of <b>EShipMovementState :: Turning</b> - and the <b>UShipMovementComponent</b> will no longer seek to rotate.  Otherwise, we take the rotation of the ship and interpret it taking into account the <b>DeltaTime</b> and the speed of the turn of the ship.  Then we apply this turn in the current tick, when calling <b>UMovementComponent :: MoveUpdatedComponent</b> . <br><br><h4>  Perspectives </h4><br>  It seems to me that in this reincarnation of the <b>UShipMovementComponent</b> all the problems that we encountered at the prototype stage were taken into account.  Also, this version turned out to be expandable and now it is possible to develop it further.  For example, the process of turning the ship: if we just turn the ship, it will look boring, as if it is strung on a rod that rotates it.  However, add a slight roll of the nose in the direction of rotation, and this process becomes much more attractive. <br><br>  Also now synchronization of the intermediate positions of the ship is realized to the minimum.  As soon as we fly to the destination, we synchronize the data with the server.  So far, the difference in the final position on the server and the client diverges by a very small amount, but if it increases, there are many ideas about how to rotate this synchronization smoothly, without jerks and ship ‚Äújumps‚Äù in space.  But I will tell about it already probably another time. </div><p>Source: <a href="https://habr.com/ru/post/253711/">https://habr.com/ru/post/253711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253697/index.html">Basics of the combat system in games</a></li>
<li><a href="../253699/index.html">Who came up with the first computer virus?</a></li>
<li><a href="../253701/index.html">Feed operators in Perl 6</a></li>
<li><a href="../253703/index.html">Ruby Together - Ruby Language Development Foundation</a></li>
<li><a href="../253705/index.html">HowTo: DMARC</a></li>
<li><a href="../253713/index.html">The digest of interesting materials for the mobile # 95 developer (March 16-22)</a></li>
<li><a href="../253715/index.html">Pros and cons of customized development without TZ</a></li>
<li><a href="../253717/index.html">MailChimp UX Team: Patterns and SVG Animation [Part 5 of the Book]</a></li>
<li><a href="../253719/index.html">Remote control of your smartphone with Node.js and Socket.io</a></li>
<li><a href="../253721/index.html">So you need a form</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>