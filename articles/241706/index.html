<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does the ConcurrentBag in .Net</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Among concurrent collections, the ConcurrentDictionary is the most popular. ConcurrentQueue and ConcurrentStack are also often used. 

 In general, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does the ConcurrentBag in .Net</h1><div class="post__text post__text-html js-mediator-article">  Among concurrent collections, the ConcurrentDictionary is the most popular.  ConcurrentQueue and ConcurrentStack are also often used. <br><br>  In general, the solution of locking parts of a collection for a thread-safe hash table is very simple, logical, and therefore even more beautiful. <br><br>  The structure of ConcurrentDictionary was even described in an article on the Habr√© <a href="http://habrahabr.ru/post/198104/">Under the hood of a Dictionary and ConcurrentDictionary</a> .  ConcurrentBag is not so popular, as it is used mainly where the Producer-Consumer pattern is implemented.  Moreover, this structure works best when the same stream is engaged in adding and removing data from the collection.  Why this happens will be discussed below. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  The basis of this structure is a simple idea to divide all data between threads so that each stream works as often as possible with its ‚Äúvirtual‚Äù part of the repository. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In .Net, as is known, to make a variable not in one instance for all threads, but its own instance in each thread, the <a href="http://msdn.microsoft.com/en-us/library/system.threadstaticattribute(v%3Dvs.110).aspx">[ThreadStatic]</a> attribute is used.  In the .Net Framework 4.0, the <a href="http://msdn.microsoft.com/en-us/library/vstudio/dd642243(v%3Dvs.100).aspx">ThreadLocal</a> class has been added, which is a convenient wrapper for working with such data. <br><br><img src="https://habrastorage.org/files/146/0f6/756/1460f6756b0f4da7b32f836240242bc9.png"><br><br>  In ConcurrentBag, data is stored in ThreadLocal m_locals.  That is, each thread that works with this structure has its own ThreadLocalList instance.  There are also volatile m_headList and m_tailList variables that point to the first and last element in m_locals respectively.  This is necessary in order to receive IEnumerator when you need to get the entire collection. <br><br>  References to the "head" and "tail" in m_locals exist, since the storage is implemented through a unidirectional <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA">linked list</a> .  That is, the thread has an instance of ThreadLocalList, in this class there is a ThreadLocalList field m_nextList, indicating the next instance of ThreadLocalList in another thread.  This means that from a single thread, you can access all instances of this variable in all threads, ‚Äústepping‚Äù on m_nextList. <br><br>  Next we will deal with the structure of the class ThreadLocalList.  It is also a bidirectional linked list.  The element is represented by the usual class Node.  The pointer to the first and last element is m_head and m_tail, respectively.  It is also worth noting that there is a Thread m_ownerThread field that stores a link to the current owner of the instance.  Why the current and not the creator will be discussed below.  The result is the following structure: <br><br><img src="https://habrastorage.org/files/5ac/fc8/09a/5acfc809a44d4ce3b147022a08cf8397.png"><br><br><h4>  Add item </h4><br><h5>  Getting ThreadLocalList </h5><br>  First, the ThreadLocalList for the current thread is obtained or created, if it was not created, the m_headList and m_tailList pointers are updated accordingly.  And the creation takes place in a synchronized code, where the lock is on the GlobalListLock (the same m_locals).  This is required to update m_tailList.  Also, this lock is used, as you can guess from the name, wherever a lock is needed on the entire collection, that is, in CopyTo, ToArray, GetEnumerator, Count, IsEmpty via the FreezeBag and UnFreezeBag methods. <br><br>  Also, when creating, we first try to find ThreadLocalList without an owner, that is, the thread that used this collection and died the death of the brave.  We find such a list, if any, and assign a reference to the current thread to the m_ownerThread field. <br><br><div class="spoiler">  <b class="spoiler_title">Search unused list</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ThreadLocalList </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetUnownedList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ThreadLocalList currentList = m_headList; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (currentList != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentList.m_ownerThread.ThreadState == System.Threading.ThreadState.Stopped) { currentList.m_ownerThread = Thread.CurrentThread; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentList; } currentList = currentList.m_nextList; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/files/2e5/b80/b6f/2e5b80b6ff6e44f0865200706382bbeb.png"><br><br><h5>  Adding an item to ThreadLocalList </h5><br>  The second step is to add an item to the ThreadLinkedList.  It is added to the standard "head" without locks.  However, if the number of elements in ThreadLocalList is less than two, then a lock is imposed on the current sheet instance when the element is added, since in this case data loss is possible.  This is due to the fact that another thread at this time can take data from the ThreadLocalList of the current thread (stealing thread). <br><br><h4>  Getting item from collection </h4><br>  When a thread wants to take an item from a collection, it first goes to its ThreadLocalList and if it is not empty, it takes an item from the head of the linked list.  If the local storage is empty, it goes through m_nextList through all the storages of other threads and searches for a non-empty list.  If found, then "steals" (steal) element from there.  Moreover, he must ‚Äústeal‚Äù an element without confusing and preventing the owner from adding the element correctly to the flow.  There is a crucial point.  <b>If we take an item from a coherent list of another thread, then we take it not from the ‚Äúhead‚Äù, but from the ‚Äútail‚Äù.</b>  That is, if there are more than two elements in a linked list, then the stream can steal an element without blocking the entire sheet.  That is, in this case, the ‚Äúrace condition‚Äù is impossible, since there is at least one intermediate element between the element being added and the element to be taken. <br><br><img src="https://habrastorage.org/files/e5f/113/ff7/e5f113ff74e544d8a19569732e52b8cc.png"><br><br>  If the elements are less than two, then you can‚Äôt just add without blocking, just as if there are less than three elements, then you can‚Äôt take the element without synchronization.  The following will show an example of adding and removing items, when these operations are performed on empty vaults, and when there are two items. <br><br><h5>  Testing thread performance with your ThreadLocalList </h5><br><div class="spoiler">  <b class="spoiler_title">Code for testing (option 1)</b> <div class="spoiler_text"><pre> <code class="cs hljs">Task task1, task2, task3; ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; bagInt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inputSize = <span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] inputDataInt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[inputSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { inputDataInt[i] = i; } Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); task1 = Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outInt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { bagInt.Add(inputDataInt[i]); bagInt.TryTake(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outInt); } }); task2 = Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outInt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { bagInt.Add(inputDataInt[i]); bagInt.TryTake(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outInt); } }); task3 = Task.Factory.StartNew(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outInt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { bagInt.Add(inputDataInt[i]); bagInt.TryTake(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outInt); } }); Task.WaitAll(task1, task2, task3); sw.Stop();</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Code for testing (option 2)</b> <div class="spoiler_text"><pre> <code class="cs hljs">Task task1, task2, task3; ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; bagInt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inputSize = <span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] inputDataInt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[inputSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { inputDataInt[i] = i; } Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); task1 = Task.Factory.StartNew(() =&gt; { bagInt.Add(<span class="hljs-number"><span class="hljs-number">-2</span></span>); bagInt.Add(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outInt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { bagInt.Add(inputDataInt[i]); bagInt.TryTake(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outInt); } }); task2 = Task.Factory.StartNew(() =&gt; { bagInt.Add(<span class="hljs-number"><span class="hljs-number">-2</span></span>); bagInt.Add(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outInt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { bagInt.Add(inputDataInt[i]); bagInt.TryTake(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outInt); } }); task3 = Task.Factory.StartNew(() =&gt; { bagInt.Add(<span class="hljs-number"><span class="hljs-number">-2</span></span>); bagInt.Add(<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outInt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; inputSize; i++) { bagInt.Add(inputDataInt[i]); bagInt.TryTake(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> outInt); } }); Task.WaitAll(task1, task2, task3); sw.Stop();</code> </pre><br></div></div><br>  In this example, there are three threads, each one enters and immediately takes the element n-times. <br>  In this example, all threads will only work with their ThreadLocalList. <br>  In the second case, before performing these operations, we will add two elements in each stream to the local list.  And it turns out that all threads will change the size of their list from 2 to 3 and back. <br><br>  An int array of size 100 * 1024 * 1024. <br>  On an empty collection (option 1) - 16 seconds, <br>  In the local storage, first two elements were added (option 2) - 12 seconds. <br><br><img src="https://habrastorage.org/files/b78/6c4/40e/b786c440e432469fa38f1cc74a7d8ce7.png"><br><br>  ThreadLocalList has a m_currentOp property, indicating the current operation that is being performed on the collection (None, Add, Take).  However, during the operation it is reset to None, if the number of elements is less than 2 or 3 to add and take, respectively (then lock to the list is performed). <br>  When a thread wants to steal an item from the list of another thread, it first waits until the current operation becomes None.  This is done using <a href="http://msdn.microsoft.com/en-us/library/system.threading.thread.spinwait(v%3Dvs.110).aspx">SpinWait</a> . <br><br><pre> <code class="cs hljs">SpinWait spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (list.m_currentOp != (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ListOperation.None) { spinner.SpinOnce(); }</code> </pre><br>  Blocking on add and take occurs not only when the number of elements is less than 2-3, but also when the field m_needSync = true.  It indicates that the entire collection has been locked.  When the entire collection is locked, a lock is also iteratively applied to the entire ThreadLocalList of all the threads. <br><br><h4>  Conclusion </h4><br>  Summing up, I would like to note two basic principles: <br><br>  1) Each thread tries to work only with its part of the repository; <br>  2) Even if the stream does not find data in itself, we try to avoid blocking the local list of data from another stream when we ‚Äústeal‚Äù data from it. <br><br>  In English, Simon Cooper rather briefly and well described all the basic principles in the article. <br>  <a href="https://www.simple-talk.com/blogs/2012/03/26/inside-the-concurrent-collections-concurrentbag/">Inside the Concurrent Collections: ConcurrentBag</a> . </div><p>Source: <a href="https://habr.com/ru/post/241706/">https://habr.com/ru/post/241706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241694/index.html">Cocos2d-x: Using your own C ++ class in Lua</a></li>
<li><a href="../241696/index.html">Translation of the online textbook "Problem Solving with Algorithms and Data Structures"</a></li>
<li><a href="../241698/index.html">As a programmer to success went</a></li>
<li><a href="../241700/index.html">Simple Science - Digest Experiences # 36</a></li>
<li><a href="../241704/index.html">How to become a programmer or Learn Java for 1 year</a></li>
<li><a href="../241708/index.html">SOPKA: why are ‚Äúwhite hackers‚Äù for the Russian missile forces?</a></li>
<li><a href="../241710/index.html">HTML generation: more convenient than helpers and pure HTML</a></li>
<li><a href="../241714/index.html">Each one in a thousand: again about Testflight</a></li>
<li><a href="../241716/index.html">Vulnerability in Find My Mobile service allows an attacker to get remote access to the Samsung smartphone</a></li>
<li><a href="../241718/index.html">ARM announced mbed v3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>