<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Auto Test Concepts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky and, unfortunately, I have no time to write a great article, but I really want to share some ideas. So let me test ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Auto Test Concepts</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, my name is Dmitry Karlovsky and, unfortunately, I have no time to write a great article, but I really want to share some ideas.  So let me test a little note about programming on you.  Today we will talk about automated testing: </p><br><ol><li>  Why do we write tests? </li><li>  What are the tests? </li><li>  How do we write tests? </li><li>  How should they write? </li><li>  Why are unit tests bad? </li></ol><br><p><img src="https://habrastorage.org/webt/_r/ae/i2/_raei2w0ae6tcygs_cpijc8-omu.png" alt="Correct test pyramid"></p><a name="habracut"></a><br><h1 id="zadachi-avtomaticheskogo-testirovaniya">  Auto Test Tasks </h1><br><p>  From more important to less: </p><br><ol><li>  <strong>Defect detection as early as possible.</strong>  Before the user sees, before posting to the server, before submitting for testing, before committing. </li><li>  <strong>Localization problems.</strong>  The test affects only part of the code. </li><li>  <strong>Acceleration development.</strong>  Test execution is much faster than manual checking. </li><li>  <strong>Current documentation.</strong>  The test is a simple and guaranteed to use. </li></ol><br><h1 id="ortogonalnye-klassifikacii">  Orthogonal classifications </h1><br><ol><li>  Object classification </li><li>  Classification by test type </li><li>  Classification by type of testing process </li></ol><br><p>  In any case, I emphasize that we are talking exclusively about automated testing. </p><br><h1 id="obekty-testirovaniya">  Test objects </h1><br><ol><li>  <strong>A module</strong> or <strong>unit</strong> is a minimal piece of code that can be tested independently of the rest of the code.  Module testing is also known as unit testing. </li><li>  <strong>The component</strong> is a relatively independent part of the application.  May include other components and modules. </li><li>  <strong>An application</strong> or <strong>system</strong> is a degenerate case of a component that indirectly includes all other components. </li></ol><br><h1 id="tipy-testov">  Types of tests </h1><br><ol><li>  <strong>Functional</strong> - checking compliance with functional requirements </li><li>  <strong>Integration</strong> - testing the compatibility of neighboring test objects </li><li>  <strong>Stress</strong> - performance check </li></ol><br><h1 id="vidy-processov-testirovaniya">  Types of testing processes </h1><br><ol><li>  <strong>Acceptance</strong> - check new / changed functionality. </li><li>  <strong>Regression</strong> - checking for defects in unchanged functionality. </li><li>  <strong>Smoke</strong> - check the main functionality for obvious defects. </li><li>  <strong>Full</strong> - check all the functionality. </li><li>  <strong>Configuration</strong> - check all the functionality on different configurations. </li></ol><br><h1 id="kolichestvo-testov">  The number of tests </h1><br><ul><li>  Tests are code. </li><li>  Any code takes time to write. </li><li>  Any code takes time to support. </li><li>  Any code may contain errors. </li></ul><br><p>  The more tests, the slower the development. </p><br><h1 id="polnota-testirovaniya">  Completeness of testing </h1><br><ul><li>  Tests should check all user scripts. </li><li>  Tests should go into each branch of logic. </li><li>  Tests should test all equivalence classes. </li><li>  Tests should check all boundary conditions. </li><li>  Tests should check the response to non-standard conditions. </li></ul><br><p>  The more complete the tests, the faster the refactoring and testing, and as a result, the delivery of new functionality. </p><br><h1 id="biznes-prioritety">  Business priorities </h1><br><ol><li>  <strong>Maximize development speed.</strong>  The developer needs to write a minimum of tests that are quickly executed. </li><li>  <strong>Minimize defects.</strong>  It is necessary to ensure maximum coverage. </li><li>  <strong>Minimize development costs.</strong>  We need to spend a minimum of effort on writing and maintaining the code (including tests). </li></ol><br><h1 id="strategii-testirovaniya">  Testing strategies </h1><br><p>  Depending on <strong>priorities</strong> , there are several basic strategies: </p><br><ol><li>  <strong>Quality</strong>  We write <em>functional</em> tests for all <em>modules</em> .  We check their compatibility with <em>integration</em> tests.  We add tests for all non-degenerate <em>components</em> .  Do not forget about the <em>integration</em> <em>component</em> .  Sprinkled with tests of the entire <em>application</em> .  Multi-level exhaustive testing will require a lot of time and resources, but will make it more likely to detect defects. </li><li>  <strong>Speed</strong>  We use only <em>smoke</em> testing applications.  We know for sure that the main functions work, and we will fix the rest, if suddenly.  Thus, we quickly deliver the functionality, but spend a lot of resources on bringing it to mind. </li><li>  <strong>Cost</strong>  We write tests only for the entire application.  Critical defects are thus detected in advance, which reduces the cost of support and, as a consequence, the relatively high <strong>speed of</strong> delivery of new functionality. </li><li>  <strong>Quality and speed</strong> .  We cover all (including degenerate) <em>components</em> with tests, which gives maximum coverage with a minimum of tests, and therefore a minimum of defects at high speed, resulting in a relatively low <strong>cost</strong> . </li></ol><br><h1 id="primer-prilozheniya">  Sample application </h1><br><p>  So that my analytics is not completely unfounded, let's create the simplest application of two components.  It will contain a name entry field and a block with a welcome message addressed to this name. </p><br><pre><code class="hljs perl">$my_hello $mol_list rows / &lt;= Input $mol_string value?val &lt;=&gt; name?val \ &lt;= Output $my_hello_message target &lt;= name - $my_hello_message $mol_view <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> / \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hello</span></span></span><span class="hljs-function">, &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function"> \</span></span></code> </pre> <br><p>  Those who are not familiar with this notation, I suggest to look at the equivalent TypeScript code: </p><br><pre> <code class="hljs scala">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$my_hello</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$mol_list</span></span></span><span class="hljs-class"> </span></span>{ rows() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-type"><span class="hljs-type">Input</span></span>() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-type"><span class="hljs-type">Output</span></span>() ] } <span class="hljs-meta"><span class="hljs-meta">@mem</span></span> <span class="hljs-type"><span class="hljs-type">Input</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$.$mol_string.make({ value : next =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name( next ) , }) } <span class="hljs-meta"><span class="hljs-meta">@mem</span></span> <span class="hljs-type"><span class="hljs-type">Output</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$.$my_hello_message.make({ target : ()=&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name() , }) } <span class="hljs-meta"><span class="hljs-meta">@mem</span></span> name( next = '' ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next } } export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$my_hello_message</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">$mol_view</span></span></span><span class="hljs-class"> </span></span>{ sub() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-symbol"><span class="hljs-symbol">'Hello</span></span>, ' , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target() ] } target() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> '' } }</code> </pre> <br><p>  <code>@mem</code> is a reactive caching decorator.  <code>this.$</code> - di-context.  Binding occurs through property overrides.  <code>.make</code> simply creates an instance and overrides the specified properties. </p><br><h1 id="komponentnoe-testirovanie">  Component Testing </h1><br><p>  With this approach, we use real dependencies whenever possible. </p><br><p>  What should mock up anyway: </p><br><ol><li>  Interaction with the outside world (http, localStorage, location, etc.) </li><li>  Undetermined (Math.random, Date.now and etc.) </li><li>  Particularly slow things (the calculation of cryptographic hash and TP) </li><li>  Asynchrony (synchronous tests are easier to understand and debug) </li></ol><br><p>  So, first we write a test for the embedded component: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Components tests <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> $my_hello_message $mol_test({ <span class="hljs-string"><span class="hljs-string">'print greeting to defined target'</span></span>() { const app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $my_hello_message app.target = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> $mol_assert_equal( app.sub().join( <span class="hljs-string"><span class="hljs-string">''</span></span> ) , <span class="hljs-string"><span class="hljs-string">'Hello, Jin'</span></span> ) } , })</code> </pre> <br><p>  And now we add tests to the external component: </p><br><pre> <code class="hljs perl">// Components tests of $my_hello $mol_test({ <span class="hljs-string"><span class="hljs-string">'contains Input and Output'</span></span>() { const app = new $my_hello $mol_assert_like( app.sub() , [ app.Input() , app.Output() , ] ) } , <span class="hljs-string"><span class="hljs-string">'print greeting with name from input'</span></span>() { const app = new $my_hello $mol_assert_equal( app.Output().sub().join( <span class="hljs-string"><span class="hljs-string">''</span></span> ) , <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> ) app.Input().value( <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> ) $mol_assert_equal( app.Output().sub().join( <span class="hljs-string"><span class="hljs-string">''</span></span> ), <span class="hljs-string"><span class="hljs-string">'Hello, Jin'</span></span> ) } , })</code> </pre> <br><p>  As you can see, all we need is a public interface component.  Pay attention, we don't care what property is and how the value is transferred to Output.  We check exactly the requirements: so that the displayed greeting matches the name entered by the user. </p><br><h1 id="modulnoe-testirovanie">  Unit testing </h1><br><p>  For unit tests, it is necessary to isolate the module from the rest of the code.  When a module does not interact with other modules, the tests are the same as the component ones: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Unit tests <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> $my_hello_message $mol_test({ <span class="hljs-string"><span class="hljs-string">'print greeting to defined target'</span></span>() { const app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> $my_hello_message app.target = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> $mol_assert_equal( app.sub().join( <span class="hljs-string"><span class="hljs-string">''</span></span> ), <span class="hljs-string"><span class="hljs-string">'Hello, Jin'</span></span> ) } , })</code> </pre> <br><p>  If the module needs other modules, they are replaced by plugs and we check that communication with them is as expected. </p><br><pre> <code class="hljs smalltalk">// <span class="hljs-type"><span class="hljs-type">Unit</span></span> tests of <span class="hljs-string"><span class="hljs-string">$m</span></span>y_hello <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_test({ <span class="hljs-string"><span class="hljs-string">'contains Input and Output'</span></span>() { const app = new <span class="hljs-string"><span class="hljs-string">$m</span></span>y_hello const <span class="hljs-type"><span class="hljs-type">Input</span></span> = {} as <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_string app.<span class="hljs-type"><span class="hljs-type">Input</span></span> = ()=&gt; <span class="hljs-type"><span class="hljs-type">Input</span></span> const <span class="hljs-type"><span class="hljs-type">Output</span></span> = {} as <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_hello_message app.<span class="hljs-type"><span class="hljs-type">Output</span></span> = ()=&gt; <span class="hljs-type"><span class="hljs-type">Output</span></span> <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_assert_like( app.sub() , [ <span class="hljs-type"><span class="hljs-type">Input</span></span> , <span class="hljs-type"><span class="hljs-type">Output</span></span> , ] ) } , <span class="hljs-string"><span class="hljs-string">'Input value binds to name'</span></span>() { const app = new <span class="hljs-string"><span class="hljs-string">$m</span></span>y_hello app.<span class="hljs-string"><span class="hljs-string">$ </span></span>= <span class="hljs-type"><span class="hljs-type">Object</span></span>.create( <span class="hljs-string"><span class="hljs-string">$ </span></span>) const <span class="hljs-type"><span class="hljs-type">Input</span></span> = {} as <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_string app.<span class="hljs-string"><span class="hljs-string">$.</span></span><span class="hljs-string"><span class="hljs-string">$m</span></span>ol_string = function(){ return <span class="hljs-type"><span class="hljs-type">Input</span></span> } as any <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_assert_equal( app.name() , <span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-type"><span class="hljs-type">Input</span></span>.value( <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> ) <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_assert_equal( app.name() , <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> ) } , <span class="hljs-string"><span class="hljs-string">'Output target binds to name'</span></span>() { const app = new <span class="hljs-string"><span class="hljs-string">$m</span></span>y_hello app.<span class="hljs-string"><span class="hljs-string">$ </span></span>= <span class="hljs-type"><span class="hljs-type">Object</span></span>.create( <span class="hljs-string"><span class="hljs-string">$ </span></span>) const <span class="hljs-type"><span class="hljs-type">Output</span></span> = {} as <span class="hljs-string"><span class="hljs-string">$m</span></span>y_hello_message app.<span class="hljs-string"><span class="hljs-string">$.</span></span><span class="hljs-string"><span class="hljs-string">$m</span></span>ol_hello_message = function(){ return <span class="hljs-type"><span class="hljs-type">Output</span></span> } as any <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_assert_equal( <span class="hljs-type"><span class="hljs-type">Output</span></span>.title() , <span class="hljs-string"><span class="hljs-string">''</span></span> ) app.name( <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> ) <span class="hljs-string"><span class="hljs-string">$m</span></span>ol_assert_equal( <span class="hljs-type"><span class="hljs-type">Output</span></span>.title() , <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> ) } , })</code> </pre> <br><p>  Mocking is not free - it leads to more complicated tests.  But the saddest thing is that having checked the work with mocks, you cannot be sure that with real modules it will all work correctly.  If you were attentive, you already noticed that in the last code we expect that the name should be passed through the <code>title</code> property.  And this leads us to two types of errors: </p><br><ol><li>  The correct module code may give errors on mocks. </li><li>  A defective module code may <strong>not</strong> give errors on mocks. </li></ol><br><p>  And finally, the tests, it turns out, do not check the requirements (let me remind you that the greeting with the substituted name should be displayed), and the implementation (such a method is called inside with such and such parameters).  This means that tests are fragile. </p><br><blockquote>  <strong>Fragile tests</strong> are tests that break down at equivalent implementation changes. <br><br>  <strong>Equivalent changes</strong> are such implementation changes that do not break the code‚Äôs compliance with functional requirements. </blockquote><br><h1 id="test-driven-development">  Test Driven Development </h1><br><p>  The TDD algorithm is quite simple and quite useful: </p><br><ol><li>  <strong>We write the test</strong> , we make sure that it falls, which means that the test is actually testing something and changes in the code are really necessary. </li><li>  <strong>We write code</strong> until the test stops falling, which means that we have fulfilled all the requirements. </li><li>  <strong>Refactor code</strong> , making sure that the test does not fall, which means that our code still meets the requirements. </li></ol><br><p>  If we write fragile tests, then at the refactor step they will constantly fall, requiring research and adjustment, which reduces the programmer's productivity. </p><br><h1 id="integracionnye-testy">  Integration tests </h1><br><p>  To overcome the cases remaining after the modular tests, they invented an additional type of tests - integration tests.  Here we take several modules and check that they interact correctly: </p><br><pre> <code class="hljs perl">// Integration tests of $my_hello $mol_test({ <span class="hljs-string"><span class="hljs-string">'print greeting with name'</span></span>() { const app = new $my_hello $mol_assert_equal( app.Output().sub().join( <span class="hljs-string"><span class="hljs-string">''</span></span> ) , <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> ) app.Input().value( <span class="hljs-string"><span class="hljs-string">'Jin'</span></span> ) $mol_assert_equal( app.Output().sub().join( <span class="hljs-string"><span class="hljs-string">''</span></span> ), <span class="hljs-string"><span class="hljs-string">'Hello, Jin'</span></span> ) } , })</code> </pre> <br><p>  Yeah, we got that latest component test.  In other words, we somehow wrote all the component tests that checked the requirements, but additionally recorded in the tests a specific implementation of logic.  This is usually redundant. </p><br><h1 id="statistika">  Statistics </h1><br><table><thead><tr><th>  Criteria </th><th>  Cascaded component </th><th>  Modular + Integrational </th></tr></thead><tbody><tr><td>  CLOS </td><td>  17 </td><td>  34 + 8 </td></tr><tr><td>  Complexity </td><td>  Simple </td><td>  Complex </td></tr><tr><td>  Incapsulation </td><td>  Black box </td><td>  White box </td></tr><tr><td>  Fragility </td><td>  Low </td><td>  High </td></tr><tr><td>  Coverage </td><td>  Full </td><td>  Extra </td></tr><tr><td>  Velocity </td><td>  High </td><td>  Low </td></tr><tr><td>  Duration </td><td>  Low </td><td>  High </td></tr></tbody></table><br><h1 id="ssylki-po-teme">  Related Links </h1><br><ul><li>  <a href="https://habrahabr.ru/post/353080/">Misconceptions about automated testing</a> - continuation of the history of automated testing </li><li>  <a href="https://habrahabr.ru/post/275249/">The problem of duplication and obsolescence of knowledge in mock-objects or Integration tests is good</a> - here the author says the right things, but calls the component tests integration tests. </li><li>  <a href="https://habrahabr.ru/company/badoo/blog/336194/">Tautological tests</a> - here the author shows the disadvantages of mocking, which is the basis of the unit tests. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351430/">https://habr.com/ru/post/351430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351418/index.html">FastTrack Training. "Network Basics". "Value of Collaboration Products from Cisco." Eddie Martin December 2012</a></li>
<li><a href="../351420/index.html">The digest of interesting materials for the mobile developer # 245 (March 12 - March 18)</a></li>
<li><a href="../351424/index.html">SNAP Issues: Incomplete Object Paradigm and Premature Typing</a></li>
<li><a href="../351426/index.html">Restore Microsoft Money online features. Quotes</a></li>
<li><a href="../351428/index.html">Is it possible to teach artificial intelligence to joke?</a></li>
<li><a href="../351432/index.html">Comparison of Material Design CSS frameworks</a></li>
<li><a href="../351434/index.html">Solving big problems with a small semantic analyzer</a></li>
<li><a href="../351436/index.html">Analysis of trends in the cryptocurrency market (for example, Bitcoin)</a></li>
<li><a href="../351438/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ306 (March 12 - 18, 2018)</a></li>
<li><a href="../351440/index.html">How to create a 3D analytics application for iPhone?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>