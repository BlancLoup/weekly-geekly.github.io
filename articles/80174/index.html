<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automate Undo / Redo functionality using .NET Generics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article Automating Undo / Redo with .NET Generics by Sergey Archipenko. 

 Introduction 

 This article describes a library that pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automate Undo / Redo functionality using .NET Generics</h1><div class="post__text post__text-html js-mediator-article">  Translation of the article <a href="http://www.codeproject.com/KB/cs/AutomatingUndoRedo.aspx">Automating Undo / Redo with .NET Generics by</a> Sergey Archipenko. <br><br><h4>  Introduction <br><br></h4>  This article describes a library that provides undo / redo functionality for every action in your application.  You can use complex data structures and complex algorithms without thinking about how they will be transferred to the previous state upon user request or as a result of an error. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Prerequisites <br><br></h4>  If you have ever developed a graphics editor or designer for complex data, you are faced with the time-consuming task of implementing undo / redo functionality that would be supported throughout the application.  Implementing paired Do and Undo methods for each operation is a boring and error-prone process when you develop something more serious than a calculator.  As a result of my experiments, I found a way to make undo / redo support transparent for business logic.  To achieve this, we will use the magic generics. <br>  This project is published on <a href="http://www.codeplex.com/DejaVu/">CodePlex</a> so that everyone can use it or contribute. <br><br><h4><a name="habracut"></a>  Code usage <br></h4><br>  There are two good news.  First, the public properties of your data classes do not need to be changed.  We just declare private fields differently than usual.  Secondly, business logic does not need to be changed either.  All that is needed is to mark the beginning and end of this code like a transaction.  Thus, the code will look like this: <br><br> <code><font color="black">UndoRedoManager.Start( <font color="#A31515">"My Command"</font> ); <font color="#008000">// </font> <br> <br> myData1.Name = <font color="#A31515">"Name1"</font> ; <br> myData2.Weight = 33; <br> myData3.MyList.Add(myData2); <br> <br> UndoRedoManager.Commit(); <font color="#008000">// </font></font></code> <br> <br>  You can roll back all changes in this block with a single line of code: <br><br> <code>UndoRedoManager.Undo(); <br></code> <br>  The following line applies the undone changes again: <br><br> <code>UndoRedoManager.Redo(); <br></code> <br>  Let me draw your attention to the fact that no matter how many objects took part in the operation and what types of data were used, all changes can be applied / canceled as a result of one transaction.  You can work with both reference and data types by value.  UndoRedoFramework also supports List and Dictionary data types.  Let's now look at how to declare a data class and implement this functionality.  The bottom line is that private fields must be wrapped in a special generic type UndoRedo &lt;&gt;: <br><br> <code><font color="black"><font color="#0000FF">class</font> MyData <br> { <br> <font color="#0000FF">private</font> <font color="#0000FF">readonly</font> UndoRedo name = <font color="#0000FF">new</font> UndoRedo&lt; <font color="#0000FF">string</font> /&gt;( <font color="#A31515">""</font> ); <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">string</font> <font color="#0000FF">string</font> Name <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> name.Value; } <br> <font color="#0000FF">set</font> { name.Value = <font color="#0000FF">value</font> ; } <br> } <br> <font color="#008000">//...</font> <br> <br> }</font></code> <br> <br>  Below is the classic property declaration with an auxiliary field, so you can compare it with the previous example. <br><br> <code><font color="black"><font color="#0000FF">class</font> MyData <br> { <br> <font color="#0000FF">private</font> <font color="#0000FF">string</font> name = <font color="#A31515">""</font> ; <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">string</font> <font color="#0000FF">string</font> Name <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> name; } <br> <font color="#0000FF">set</font> { name = <font color="#0000FF">value</font> ; } <br> } <br> <font color="#008000">//...</font> <br> <br> }</font></code> <br> <br>  There are three key differences in these code fragments: <br><ul><li>  I use the UndoRedo &lt;&gt; generic type for the auxiliary field.  The field itself does not store values, but refers to a container that stores value for us. </li><li>  When we need to refer to an auxiliary field, we use name.Value instead of name.  You can see that name.Value is used without casting.  This is because Value always has a type that is enclosed in UndoRedo &lt;...&gt; brackets. </li><li>  Private field is declared read only.  This is done because the field is a container that is responsible for storing information about changes.  It should exist as much as the parent entity.  We do not need to change the container itself although, of course, we can change the Value. </li></ul><br>  This solution works for both reference types and types by value. <br><br><h4>  Implementation <br><br></h4>  If you are not interested in implementation details, you can safely move on to the next section.  In this article I will draw your attention only to a couple of basic implementation details.  I hope you look at the source code for more detailed information.  It is rather short and simple.  The main classes in the framework are UndoRedoManager and UndoRedo &lt;&gt;.  UndoRedoManager is a facade class that contains static methods for manipulating commands.  The following is a partial list of methods: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">class</font> UndoRedoManager <br> { <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> IDisposable Start( <font color="#0000FF">string</font> commandCaption) { ... } <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">void</font> Commit() { ... } <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">void</font> Cancel() { ... } <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">void</font> Undo() { ... } <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">void</font> Redo() { ... } <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">bool</font> CanUndo { <font color="#0000FF">get</font> { ... } } <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">bool</font> CanRedo { <font color="#0000FF">get</font> { ... } } <br> <br> <font color="#0000FF">public</font> <font color="#0000FF">static</font> <font color="#0000FF">void</font> FlushHistory() { ... } <br> }</font></code> <br> <br>  In addition to the UndoRedoManager class, the framework provides the following objects: <br><ul><li>  UndoRedoManager </li><li>  History </li><li>  Command </li><li>  Change </li><li>  OldValue, NewValue </li></ul><br>  In other words, UndoRedoManager keeps a history of commands.  Each team has its own list of modifications.  Each Change object stores the old and new values.  The Change object is created by the UndoRedo () class when the user makes modifications.  As you remember, we used the UndoRedo () class when declaring auxiliary fields in the examples above.  This class is responsible for creating the Change object and filling it with the old and new values.  Below is the main part of this class: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">class</font> UndoRedo : IUndoRedoMember <br> { <br> <font color="#008000">//...</font> <br> <br> TValue tValue; <br> <br> <font color="#0000FF">public</font> TValue Value <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> tValue; } <br> <font color="#0000FF">set</font> <br> { <br> <font color="#0000FF">if</font> (!UndoRedoManager.CurrentCommand.ContainsKey( <font color="#0000FF">this</font> )) <br> { <br> Change change = <font color="#0000FF">new</font> Change(); <br> change.OldState = tValue; <br> UndoRedoManager.CurrentCommand[ <font color="#0000FF">this</font> ] = change; <br> } <br> tValue = <font color="#0000FF">value</font> ; <br> } <br> } <br> <font color="#008000">//...</font> <br> <br> }</font></code> <br> <br>  The code above is a key part of the entire framework.  It shows how changes are captured within the custom property that we declared in the previous section.  Thanks to generics, we can avoid type conversions in the Value property.  The Change object is created inside this command at the very first attempt to set the property.  So  we have the lowest possible performance loss.  When a user invokes a command, each Change object is populated with a new value.  The framework automatically calls the OnCommit method for each changed property: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">class</font> UndoRedo : IUndoRedoMember <br> { <br> <font color="#008000">//...</font> <br> <br> <font color="#0000FF">void</font> IUndoRedoMember.OnCommit( <font color="#0000FF">object</font> change) <br> { <br> ((Change)change).NewState = tValue; <br> } <br> <font color="#008000">//...</font> <br> <br> }</font></code> <br> <br>  The old and new values ‚Äã‚Äãobtained above are used by the framework to perform undo / redo operations.  Further, in the Performance section, you will see that all these actions create a very small loss of performance.  In a real application, it may be less than 1%. <br><br><h4>  Collections <br><br></h4>  As I mentioned earlier, changes in lists and dictionaries can be applied / undone in the same way as in simple properties.  For these purposes, the library provides the UndoRedoList &lt;&gt; and UndoRedoDictionary &lt;&gt; classes, which have the same interfaces as the standard List &lt;&gt; and Dictionary &lt;&gt; classes.  However, despite this similarity, the internal implementation of these classes is complemented by the possibility of undo / redo.  Consider how a data object can declare a list: <br><br> <code><font color="black"><font color="#0000FF">class</font> MyData <br> { <br> <font color="#0000FF">private</font> <font color="#0000FF">readonly</font> UndoRedoList myList= <font color="#0000FF">new</font> UndoRedoList(); <br> <br> <font color="#0000FF">public</font> UndoRedoList MyList <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> myList; } <br> } <br> }</font></code> <br> <br>  The trick here is that the list supports transactions, and the link to the list is not.  In other words, we can add, delete and sort elements and all these changes can be correctly undone.  But we cannot change the link to the list to a link to another list, because it is readonly. <br><br>  In fact, from my experience, I can say that this does not create difficulties, because, in most cases, the list that is stored in the class field exists as much as the parent data object.  If you are used to a different design and would like to change the link to the list, this can be done in a slightly more cunning way.  Combine two generic UndoRedo &lt;&gt; and UndoRedoList &lt;&gt; as shown below: <br><br> <code><font color="black"><font color="#0000FF">private</font> <font color="#0000FF">readonly</font> UndoRedo&lt;UndoRedoList&gt; myList ...</font></code> <br> <br>  Dictionary can be used in the same way as the list, so I will not repeat. <br><br><h4>  Protection against failures </h4><br>  Sometimes code execution is interrupted as a result of an error.  An I / O error or internal error can compromise data integrity even if the error has been handled properly.  UndoRedoFramework can help here and bring the data to the initial state.  If the code runs without errors, all changes will be saved.  Otherwise, it will be rolled back: <br><br> <code><font color="black"><font color="#0000FF">try</font> <br> { <br> UndoRedoManager.Start( <font color="#A31515">"My Command"</font> ); <br> <font color="#008000">//      </font> <br> <br> <font color="#008000">//...</font> <br> <br> UndoRedoManager.Commit(); <br> } <br> <font color="#0000FF">catch</font> (Exception) <br> { <br> UndoRedoManager.Cancel(); <br> }</font></code> <br> <br>  In addition, with the same success you can use a more elegant entry of this code: <br><br> <code><font color="black"><font color="#0000FF">using</font> (UndoRedoManager.Start( <font color="#A31515">"My Command"</font> )) <br> { <br> <font color="#008000">//      </font> <br> <br> <font color="#008000">//...</font> <br> <br> UndoRedoManager.Commit(); <br> }</font></code> <br> <br>  As you can see, in the last example there is no rollback of unsuccessful changes.  This is possible due to the fact that the rollback will be performed automatically if the execution of the code does not reach the call of the Commit method, i.e.  in case of error.  This behavior provides a high degree of reliability, even if you do not need the undo / redo functionality itself.  The application will recover from any error and keep working. <br><br><h4>  UI and data synchronization <br></h4><br>  Complex UI is often implemented using the Model-View-Controller pattern.  In a simple Windows application, there are only data and view layers.  However, in both cases, the developer must write some code to synchronize between the UI and the data.  The demo project contains the main form with three UI controls: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/5d8/297/ba75d8297b2044c95eebee2a5aa0fa00.png" alt="image"><br><br><ul><li>  EditCityControl </li><li>  CitiesChartControl </li><li>  UndoRedoControl, displays two lists of commands that can be applied / canceled for city data. </li></ul><br><br>  These controls show different views of the same city data.  Real application, i.e.  designer or editor, consists of dozens of such controls.  There is a problem of data synchronization: if one of the controls changes the data, ALL of the controls must update their data, since changing one entity can change other entities in accordance with business logic. <br><br>  So what do we need?  First, the code performing the synchronization must know about the changes made by the controller or anywhere in the business logic.  Secondly, it must reload the controls on the form so that they display the new data. <br><br>  This problem can be solved in different ways - good and bad.  I want the code to be incoherent.  The form should not know much about the components, and the components should not know about the existence of each other.  Honestly, I'm too lazy to write the synchronization code every time I add a new component to the form.  Take a look at the demo project in this article and you will see a very simple form: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">partial</font> <font color="#0000FF">class</font> DemoForm : Form <br> { <br> <font color="#0000FF">public</font> DemoForm() <br> { <br> InitializeComponent(); <br> <br> <font color="#008000">// init data</font> <br> <br> CitiesList cities = CitiesList.Load(); <br> chartControl.SetData(cities); <br> editCityControl.SetData(cities); <br> } <br> }</font></code> <br> <br>  The form simply loads the initial data into the controls.  Thus, the form does not synchronize.  Event handlers for controls also do not synchronize, for example, the EditCityControl has an event handler for the 'Remove City' button: <br><br> <code><font color="black"><font color="#0000FF">private</font> <font color="#0000FF">void</font> removeCity_Click( <font color="#0000FF">object</font> sender, EventArgs e) <br> { <br> <font color="#0000FF">if</font> (CurrentCity != <font color="#0000FF">null</font> ) <br> { <br> UndoRedoManager.Start( <font color="#A31515">"Remove "</font> + CurrentCity.Name); <br> cities.Remove(CurrentCity); <br> UndoRedoManager.Commit(); <br> } <br> }</font></code> <br> <br>  Despite this, all controls on the form are updated when the data changes.  This is due to the special event of the framework, which is triggered when data is changed / canceled.  This allows us to put all the UI update code in one place of control: <br><br> <code><font color="black"><font color="#0000FF">public</font> EditCityControl() <br> { <br> <font color="#008000">//...</font> <br> <br> UndoRedoManager.CommandDone += <font color="#0000FF">delegate</font> { ReloadData(); }; <br> <font color="#008000">//...</font> <br> <br> }</font></code> <br> <br>  Thus, simply by subscribing to the CommandDone event, the control solves a number of problems.  The control always displays updated data when it changes in some other component.  In addition, an update will be performed when the user performs an undo or redo operation. <br><br><h4>  Performance <br><br></h4>  Productivity and optimization always compete with each other ... and perhaps with the girl developer for his free time.  In this article I will consider only the first two factors.  Fortunately, editors and designers do not set strict performance requirements for most operations, unlike real-time systems.  I still give a brief analysis of performance for some cases: <br><br><ul><li>  Reading data does not lead to loss of performance.  Thanks to generics, we avoid type conversion and boxing / unboxing.  Values ‚Äã‚Äãare returned immediately, in this case there is no need to search the change history. </li><li>  Any attempt to change a property causes one lookup in the internal hash table.  In addition, the first attempt to change a property copies its value to the change history. </li><li>  Any attempt to change the list causes one search in the internal hash table.  In addition, when you first try to change the list, the framework creates a copy of the list and writes it to the change history of the list. </li><li>  Any attempt to change the dictionary causes one search in the internal hash table and creates two small objects.  The framework never creates a complete copy of the dictionary.  Instead, it stores only changes directly in the history. </li><li>  The Undo and Redo methods only restore changed values.  They do not perform any action with unchanged values. </li></ul><br><br>  In other words, without significant performance loss you can: <br><br><ul><li>  Read and modify any properties. </li><li>  Read and modify medium sized lists. </li><li>  Read and moderately change large dictionaries. </li></ul><br>  Although, performance may decrease if you frequently change several large lists.  In this case, I would recommend reviewing the design of the data and splitting up large lists. <br><br>  Below I give the performance test data for my real application.  In this example, the user resizes the graphic object in the designer.  The average operation performs 5500 readings, 70 changes of properties and 4 changes of dictionaries.  All additional work related to undo / redo takes less than 0.7 milliseconds.  Below are the test results: <br><table><tbody><tr><td></td><td>  Number of calls </td><td>  Total ms </td><td>  Total, % </td></tr><tr><td>  <strong>Resize and redraw image</strong> </td><td></td><td>  <strong>159,328</strong> </td><td>  <strong>100%</strong> </td></tr><tr><td>  <strong>Performing undo / redo operations</strong> </td><td></td><td>  <strong>0.677</strong> </td><td>  <strong>0.425%</strong> </td></tr><tr><td>  Command initialization </td><td>  one </td><td>  0.008 </td><td>  0.005% </td></tr><tr><td>  Reading property </td><td>  5461 </td><td>  0.114 </td><td>  0.071% </td></tr><tr><td>  Property record </td><td>  71 </td><td>  0.026 </td><td>  0.017% </td></tr><tr><td>  Change dictionary </td><td>  four </td><td>  0.065 </td><td>  0.041% </td></tr><tr><td>  Command completion </td><td>  one </td><td>  0.463 </td><td>  0.291% </td></tr></tbody></table><br><h4>  Memory <br><br></h4>  UndoRedoFramework only uses memory to save changes.  Memory consumption does not depend on the total size of the data, but only on how much data has been changed.  Those.  the size of your change history will be several kilobytes, even if the total data size is several megabytes.  The history size is not limited by default, but it can be limited using the static property UndoRedoManager.MaxHistorySize.  This property determines the number of transactions that are stored in the history.  Older operations will be deleted from the history when the specified number of operations has been reached. <br><br>  I would also like to describe some points related to links and garbage collection: a link that is stored in a field can be replaced with another link.  If there are no other references to this object, it will be a candidate for removal by the garbage collector.  This does not suit us, because we want to be able to return to the previous state.  Fortunately, the link is stored in the history and the object will not be deleted by the garbage collector, even if it is not already used in the data model. <br><br>  So  old objects will not be candidates for removal as long as the corresponding operation is stored in history.  This ensures data integrity, but you should keep this in mind when evaluating the memory used. <br><br><h4>  Generics or Proxy <br></h4><br>  An alternative approach to implementing undo / redo functionality is to use a proxy.  Proxies use the .NET call context feature to intercept property calls.  This approach allows you to save information about changes and subsequently undo changes.  You can find articles that implement this approach on this site.  These are good articles written by professionals in this field.  Now I would like to describe the differences of these approaches. <br><br>  A proxy means that the changes are intercepted by some "external" method.  They intercept the setter's call to the property before it is executed by the property.  Undo change is also an external operation.  In order to restore the previous value of the property, the proxy calls the property setter at its discretion.  In this case, various side effects are possible: what if a property change affects other properties?  What if the property generates a notification event?  What if this property uses business logic associated with another property whose value has not yet been restored?  Thus, if you use "rich" properties, undo / redo can lead to unpredictable consequences. <br><br>  On the other hand, generics work from the inside.  This technique intercepts and recovers changes without affecting the property and its logic.  The process of restoring change happens completely unnoticed.  Business rules and notifications are not duplicated.  Thus, the integrity of the data cannot be compromised during the recovery of changes. <br><br><h4>  Further work <br></h4><br>  I develop and prototype additional functionality: <br><br><ul><li>  An implementation of "isolated change stores" where data changes are stored independently.  This can be used in multiple document applications where the user can change / cancel changes in each document separately. </li><li>  File support in transactions.  In some cases, data processing may use intermediate files, such as resource files or just temporary files.  In this case, versions of these files must be compatible with data in memory, changes in which can be undone.  The framework will have the ability to undo changes to files along with changes to in-memory data. </li><li>  Multithreading support for the previous two tasks. </li></ul><br><br>  This project is published on <a href="http://www.codeplex.com/DejaVu/">CodePlex</a> so that everyone can use it or contribute. </div><p>Source: <a href="https://habr.com/ru/post/80174/">https://habr.com/ru/post/80174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../80168/index.html">Three ASUS Waveface Concept Gadgets</a></li>
<li><a href="../80169/index.html">Samsung has integrated a transparent display into the IceTouch player.</a></li>
<li><a href="../80170/index.html">Another ‚Äúlesson‚Äù on ExtJS. Item Templates</a></li>
<li><a href="../80171/index.html">Universal password, unique for each server and service</a></li>
<li><a href="../80173/index.html">A look at the interior of the Boeing 787</a></li>
<li><a href="../80175/index.html">Have you left for the summer? Be prepared for Mail.ru to delete all your mail.</a></li>
<li><a href="../80189/index.html">New type of passes</a></li>
<li><a href="../80191/index.html">Merry Christmas!</a></li>
<li><a href="../80192/index.html">Cyborg RAT - mouse for fans of transformers from Mad Catz</a></li>
<li><a href="../80193/index.html">Music from Tristram (Diablo)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>