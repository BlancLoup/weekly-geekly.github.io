<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GSON. Add a little rigor to it and solve the problem of memory overflow when processing large JSON files.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably many have come across Google's GSON library, which easily turns JSON files into Java objects and back. 

 For those who did not come across i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GSON. Add a little rigor to it and solve the problem of memory overflow when processing large JSON files.</h1><div class="post__text post__text-html js-mediator-article">  Probably many have come across Google's GSON library, which easily turns JSON files into Java objects and back. <br><br>  For those who did not come across it, I prepared a short description under the spoiler.  He also described the solutions on GSON of two problems that he really encountered in his work (solutions are not necessarily optimal or better, but perhaps they may be useful to someone): <br><br>  1) Checks that we have not lost any fields from the JSON file, as well as checks that all the required fields in the Java class have been filled (we make GSON more strict); <br>  2) Manual parsing using GSON, when you have to handle a very large JSON file to avoid the error out of memory. <br><a name="habracut"></a><br>  So, first, what is GSON on the fingers: ... <br><div class="spoiler">  <b class="spoiler_title">Those who already know about GSON will most likely not be interested, you can skip</b> <div class="spoiler_text">  ... GSON allows literally two lines to convert JSON into Java objects.  It is very often used for integration between different platforms and systems, serialization and deserialization, as well as for interaction between the web part in javascript and the Java backend. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, we have say, such json, received from another application: <br><br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"summary"</span></span>: { <span class="hljs-string"><span class="hljs-string">"test1_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1444415"</span></span>, <span class="hljs-string"><span class="hljs-string">"test2_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4444935"</span></span> }, <span class="hljs-string"><span class="hljs-string">"results"</span></span>: { <span class="hljs-string"><span class="hljs-string">"details"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"test1_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1444415"</span></span>, <span class="hljs-string"><span class="hljs-string">"test2_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4444935"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"test1_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1444415"</span></span>, <span class="hljs-string"><span class="hljs-string">"test2_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4444935"</span></span> } ] } }</code> </pre> <br>  We describe a similar structure in Java objects (heters and setters, etc. I will not write for simplicity): <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonContainer</span></span></span><span class="hljs-class"> </span></span>{ DataContainer summary; ResultContainer results; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultContainer</span></span></span><span class="hljs-class"> </span></span>{ List&lt;DataContainer&gt; details; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataContainer</span></span></span><span class="hljs-class"> </span></span>{ String test1_id; String test1_id; }</code> </pre><br><br>  And literally two lines convert one into another. <br><br><pre> <code class="java hljs"> Gson gson = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GsonBuilder().create(); JsonContainer jsonContainer = gson.fromJson(json, JsonContainer.class);<span class="hljs-comment"><span class="hljs-comment">//  Json  Java ... // -  String json = gson.toJson(jsonContainer);//   Java  json</span></span></code> </pre><br><br>  As you can see, everything is very simple.  If we don‚Äôt like names that are wrong for Java, use the SerializedName annotation, that is, we write: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonContainer</span></span></span><span class="hljs-class"> </span></span>{ DataContainer summary; ResultContainer results; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultContainer</span></span></span><span class="hljs-class"> </span></span>{ List&lt;DataContainer&gt; details; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataContainer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@SerializedName</span></span>(<span class="hljs-string"><span class="hljs-string">"test1_id"</span></span>) String test1Id; <span class="hljs-meta"><span class="hljs-meta">@SerializedName</span></span>(<span class="hljs-string"><span class="hljs-string">"test2_id"</span></span>) String test2Id; }</code> </pre><br>  Naturally, not only String can be automatically used as field types, but also any primitive and their wrappers, enum, date (the date format can be specified), objects with generics, and much more.  For enum values, you can also specify SerializedName if the value in json does not match the name of the enum constant.  You can also, of course, add your own handlers for individual classes, like this: <br><br><pre> <code class="java hljs">Gson gson = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GsonBuilder().registerTypeAdapter(DataContainer.class, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataContainerDeserializer&lt;DataContainer&gt;()).create(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataContainerDeserializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonDeserializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JsonElement json, Type type, JsonDeserializationContext context)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> JsonParseException </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//   JsonElement     return /*   Java  */ } }  ,     JsonDeserializer .  ,   GSON'        .</span></span></code> </pre><br></div></div><br><br><h3>  Problem number 1. Unstable conversions </h3><br>  When converting from json to Java, GSON ignores all fields that are missing in the Java class and does not pay attention to the NotNull annotations.  It would seem that there is no special problem, well, it ignores and ignores, for many purposes (for example, the evolution of classes during serialization / deserialization) this is very convenient.  Yes, it's really convenient sometimes.  But imagine that we integrated with another company's system and suddenly the object field turned into objects (by mistake, the developers were ‚Äúon the other side‚Äù because we didn‚Äôt notice in the design of that home system ‚Äùafter 12 at night the carriage turns into a pumpkin, that is, field1 becomes field2 ", for a million other reasons).  Either they added an important field, but forgot to tell us.  Worse, if the integration works in both directions: system A sent us an object with extra fields (which we did not know), GSON ignored them, we did something with the object and sent it back to system A, and they safely wrote it down to the base, having decided that we have deleted extra fields for our own reasons.  Everything is a spoiled phone in action and it's good if you manage to catch it with QA or analytics on some side, or they may not. <br><br>  I could not find a normal solution in GSON itself, how to make it more stringent.  Yes, it was possible to fasten a separate validation using json schemes or somehow do manual validation, but it seemed to me that much better to use the capabilities of GSON itself, namely JsonDeserializer, turned into a Validator (maybe someone can suggest the best way) proper class: <br><br><div class="spoiler">  <b class="spoiler_title">Big source code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.test; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.common.collect.ObjectArrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.gson.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.gson.annotations.SerializedName; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gnu.trove.set.hash.THashSet; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.validation.constraints.NotNull; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.annotation.Annotation; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Field; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Type; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestGson</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String json = <span class="hljs-string"><span class="hljs-string">"{\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"summary\": {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"test1_id\": \"1444415\",\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"test2_id\": \"4444935\"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" },\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"results\": {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"details\": [\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"test1_id\": \"1444415\",\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"test2_id\": \"4444935\"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" },\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"test1_id\": \"1444415\",\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" \"test2_id\": \"4444935\"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" ]\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String [ ] args)</span></span></span><span class="hljs-function"> </span></span>{ Gson gson = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GsonBuilder() .registerTypeAdapter(DataContainer.class, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VaidateDeserializer&lt;DataContainer&gt;()) <span class="hljs-comment"><span class="hljs-comment">//     DataContainer .create(); JsonContainer jsonContainer = gson.fromJson(json, JsonContainer.class); } static class JsonContainer { DataContainer summary; ResultContainer results; } static class ResultContainer { List&lt;DataContainer&gt; details; } static class DataContainer { @NotNull @SerializedName("test1_id") String test1Id; @SerializedName("test2_id") String test2Id; } static class VaidateDeserializer&lt;T&gt; implements JsonDeserializer&lt;T&gt; { private Set&lt;String&gt; fields = null; //      private Set&lt;String&gt; notNullFields = null; //       NotNull private void init(Type type) { Class cls = (Class) type; Field[] fieldsArray = ObjectArrays.concat(cls.getDeclaredFields(), cls.getFields(), Field.class); //     (, ,        fields = new THashSet&lt;String&gt;(fieldsArray.length); notNullFields = new THashSet&lt;String&gt;(fieldsArray.length); for(Field field: fieldsArray) { String name = field.getName().toLowerCase(); //     Annotation[] annotations = field.getAnnotations(); //     boolean isNotNull = false; for(Annotation annotation: annotations) { if(annotation instanceof NotNull) { //     NotNull isNotNull = true; } else if(annotation instanceof SerializedName) { name = ((SerializedName) annotation).value().toLowerCase(); //   SerializedName        fields  notNullFields } } fields.add(name); if(isNotNull) { notNullFields.add(name); } } } @Override public T deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException { if(fields == null) { init(type); //            } Set&lt;Map.Entry&lt;String, JsonElement&gt;&gt; entries = json.getAsJsonObject().entrySet(); Set&lt;String&gt; keys = new THashSet&lt;String&gt;(entries.size()); for (Map.Entry&lt;String, JsonElement&gt; entry : entries) { if(!entry.getValue().isJsonNull()) { //   json,    null keys.add(entry.getKey().toLowerCase()); //       json } } if (!fields.containsAll(keys)) { //    json,    Java  -  throw new JsonParseException("Parse error! The json has keys that isn't found in Java object:" + type); } if (!keys.containsAll(notNullFields)) { //   Java    NotNull,   json   -  throw new JsonParseException("Parse error! The NotNull fields is absent in json for object:" + type); } return new Gson().fromJson(json, type); //     GSON } } }</span></span></code> </pre><br></div></div><br>  Actually, what we do.  In the comments, everything is described in sufficient detail, but the bottom line is that we assign the JsonDeserializer to the class that we are going to check (or all classes).  When we first refer to it with reflection, we raise the class structure and annotations to the fields (they are already saved and we don‚Äôt waste time on reflection) if we find extra fields in json or the absence of fields marked as NotNull by us falling with JsonParseException.  Naturally, in production you can fall more gently by writing errors to logs or to a separate collection.  In any case, we can immediately find out "that these are the wrong bees and they give the wrong honey" and change something until we have lost important data.  But now GSON will work strictly. <br><br><h3>  Problem number 2. Large files and memory overflow </h3><br>  As far as I know, GSON receives all data immediately into memory, that is, by making fromJson we get a heavy object with the entire json structure in memory.  While json files are small this is not a problem, but if there suddenly appears to be an array of a couple of million objects, we risk getting out of memory.  Of course, it would be possible to abandon GSON and work in my project with two different json parsing libraries (but for a number of reasons this would not be desirable), but fortunately there is a gson.stream.JsonReader that allows you to parse json on tokens without loading everything in memory (or, say, discarding to a disk in some format or periodically writing the results to a database).  In fact, GSON itself works with JsonReader.  The general algorithm for working with JsonReader is also very simple (I will write briefly only the essence of the work, since everything will depend on the structure of each particular json, especially as there are excellent examples of use in the Javadoc, JsonReader): <br><br><pre> <code class="java hljs">JsonReader jsonReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonReader(reader); <span class="hljs-comment"><span class="hljs-comment">//   reader,  fileReader,     json   ,</span></span></code> </pre><br>  jsonReader has the following methods: <br><br><pre> <code class="java hljs">- hasNext() -      (, ,   ..) - peek() -    (, ,       ..) - skipValue -   - beginObject(), beginArray() -    /      - endObject(), endArray() -   /      - nextString() -       -  ..</code> </pre><br><br>  Pay attention only to the fact that hasNext () returns a value only for the current object / array, and not the entire file (this turned out to be unexpected for me), and the fact that you should always carefully check the type of token using peek ().  Otherwise, parsing large files in this way will of course be somewhat less convenient than just one fromJson () command, but nevertheless it is written in a few hours for a simple json structure.  If you know the best way to get GSON to work with the file piece by piece without loading a heavy object into memory, write it in the comments, I would be very grateful (it only occurred to me to save the parsed objects in the JsonDeserializer and give null, but this solution looks much less beautiful) than honest parsing tokens).  Immediately I answer, I did not want to use other libraries for a number of reasons in this case, but the advice in which libraries these problems can be solved more easily will also be useful for me. <br><br>  Thank you all for your attention. <br><br>  ** PS ** I also advise you to look at my opensource project [useful-java-links] (https://github.com/Vedenin/useful-java-links/tree/master/link-rus) - perhaps the most complete collection useful Java libraries, frameworks and Russian-language instructional videos.  There is also a similar [English version] (https://github.com/Vedenin/useful-java-links/) of this project and start the opensource subproject [Hello world] (https://github.com/Vedenin/useful-java -links / tree / master / helloworlds) for preparing a collection of simple examples for different Java libraries in one maven project (I will be grateful for any help). </div><p>Source: <a href="https://habr.com/ru/post/245263/">https://habr.com/ru/post/245263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245251/index.html">Hi, I'm a designer, and I want everything to look the same everywhere.</a></li>
<li><a href="../245253/index.html">What prevents web studios from scaling up their business, and how internal projects can help with this?</a></li>
<li><a href="../245255/index.html">Bypassing github.com blocking in Windows using DNSCrypt</a></li>
<li><a href="../245257/index.html">The greenest technopark in the world, or why start an IT business in India?</a></li>
<li><a href="../245259/index.html">Welcome to GDG DevFest Omsk 2014</a></li>
<li><a href="../245267/index.html">Functional Modeling</a></li>
<li><a href="../245269/index.html">How to invent a bike and get to know FRP</a></li>
<li><a href="../245271/index.html">Asterisk. Sending and receiving faxes</a></li>
<li><a href="../245277/index.html">Professional development managers. Kaizen practice training on internship in Japan</a></li>
<li><a href="../245279/index.html">Toaster. Enhanced tag subscription: Receive instant email notifications of all new issues for any tag.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>