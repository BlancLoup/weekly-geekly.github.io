<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Resumable functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An interesting event happened in the C ++ world last week. Microsoft announced the release of an update to the C ++ compiler in Visual Studio 2013. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Resumable functions</h1><div class="post__text post__text-html js-mediator-article">  An interesting event happened in the C ++ world last week.  Microsoft <a href="http://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/">announced</a> the release of an update to the C ++ compiler in Visual Studio 2013. In itself, updating the compiler separately from Visual Studio or its service pack is already a non-trivial event for Microsoft.  But even more interesting is what went into this update.  The full list can be read on the link above, and I will focus on only one point - the resumable functions.  For a complete understanding of the situation: Microsoft has pretty much prorolled the C ++ Standardization Committee and the gcc \ clang developers, releasing (here we must carefully) implementing the experimental and not yet approved features of the future C ++ 17 standard, based on the experimental and not yet approved features of the future C ++ 14 standard, which in turn are corrections of the C ++ 11 features that are not yet heavily incorporated into the everyday programming. <br><br>  Enough geeky move, is not it? <br><br>  And below will be a translation of an article from <a href="http://meetingcpp.com/index.php/br/items/resumable-functions-async-and-await.html">meetingcpp.com</a> , telling about what this feature is and how to use it. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the recent BUILD conference, Herb Sutter <a href="http://channel9.msdn.com/Events/Build/2013/2-306">talked</a> about the future of C ++.  His report was full of beautiful examples in C ++ 11 and C ++ 14.  And suddenly, straight from nowhere - resumable features.  Herb is one of the authors of a document describing std :: future and resumable functions, so their very mention was not a surprise for me, but what surprised me was how much attention he paid to this topic and the fact that resumable functions will be included in the update to Visual Studio 2013 (though not in the release of VS2013, but still much earlier than the next version of the IDE). <br><br>  I will start with a small spoiler: this is at least C ++ 1y, it will not be included in C ++ 14, but in the future exactly asynchronous and parallel programming will be in the trend of language development, so resumable functions will become an integral part of the new standard.  In the future, this feature will be supported by all compilers, and at the moment Microsoft is walking ahead of the rest of the world with its own implementation.  It's no secret that this functionality has some analogy with async / await from the C # language. <br><br><h5>  What is the resumable function? </h5><br>  This, in fact, is the main question that we are trying to find out.  Before I begin to explain what this could be and how the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> document defines <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">them</a> , I have to make a small stop and tell what futures are, since the resumable functions are based on the assumption that std :: future will be extended with the .then () method as it is supposed in document <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3634.pdf">N3634</a> .  future is the result of an asynchronous operation.  This is one of the basic concepts of asynchronous programming.  future is the place where information is stored about the status of the asynchronous task and its result, if it is already available.  You can call the get () method, which will wait for the asynchronous operation to complete and return its result to you (this is already implemented in the standard), or register a handler for its completion through the .then () method (which is not yet standard).  The absence of .then () in C ++ 11 is one of the most criticized errors, it will probably be fixed in C ++ 14, along with some other improvements to std :: future. <br><br>  C ++ 11 was added to C ++ lambdas, so that in combination it makes it possible to build a chain of asynchronous calls to lambda functions (callbacks).  Now it will be possible to start the execution of the asynchronous task and respond to its completion in the handler registered via the .then () method.  ‚ÄúRead the server‚Äôs response, then parse it, then process it, ...‚Äù.  With error checking and logging along the way.  This approach is commonplace in some languages, but not yet in C ++.  A proper understanding of such a powerful mechanism can seriously affect how you will write code in the future. <br><br>  A short example to demonstrate std :: future: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f_int = make_dummy_future(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = f_int.get() <span class="hljs-comment"><span class="hljs-comment">//     f_int.then([](std::future&lt;int&gt; i){/* deal with it */}) //  </span></span></code> </pre> <br><br>  The idea behind the resumable function is to allow the compiler to take care of building a chain of futures attached to each other and call them correctly using .then (). <br>  This is achieved through the announcement of two new keywords: async and await.  Please note that this has nothing to do with the library std :: async, this is NOT a library, this is an extension of a programming language.  The function is marked with the async keyword after its declaration, but prior to its specification on the generated exceptions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resumable_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> async</span></span></code> </pre><br><br>  So now the compiler knows that this is a resumable function.  And the fun begins.  Although this is a function, it is still quite limited in capabilities.  The first of these is its return type - it can be either void or std :: future / std :: shared_future.  Perhaps the types that can be converted to std:: (shared_) future will also be allowed, but implicit conversions are not the best solution here, so maybe the committee decides to choose strict type matching.  The current document still permits to return T, implicitly converting it to <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <h5> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> </h5> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <h5> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> </h5> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <h5> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> </h5> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <h5> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> </h5> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> <h5> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> </h5> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> <h5> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> </h5> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> <ul><li> <code><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get(). <br>   is_ready(),   future <br> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code></code></code> </li> <li> <code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> <pre> <code class="hljs lua"><code><code><code><code><code><code class="cpp"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } } <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code></code></code> <h5> <code class="hljs lua"><code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } } <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code></code> </h5> <code class="hljs lua"><code class="cpp">std::future. <br> <br>  resumable      .    await   <span class="hljs-string"><span class="hljs-string">""</span></span>      future,         .   await      (, ,  <span class="hljs-string"><span class="hljs-string">"!"</span></span>). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); std::future&lt;uint64_t&gt; rhs = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      <span class="hljs-string"><span class="hljs-string">"       ?"</span></span>.  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n<span class="hljs-number"><span class="hljs-number">-1</span></span>); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n<span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , <span class="hljs-string"><span class="hljs-string">"dataflow"</span></span>    await     .        future,   .    ++<span class="hljs-number"><span class="hljs-number">11</span></span>  ++<span class="hljs-number"><span class="hljs-number">14</span></span>    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str-&gt;<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([](future&lt;int&gt; op)// lambda <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.get() + <span class="hljs-number"><span class="hljs-number">11</span></span>; }); } future&lt;void&gt; g() { shared_ptr s = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(s).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([s](future&lt;int&gt; op) // lambda <span class="hljs-number"><span class="hljs-number">2</span></span> { s-&gt;<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(<span class="hljs-number"><span class="hljs-number">512</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count + <span class="hljs-number"><span class="hljs-number">11</span></span>; } future g() async { stream s = ...; int pls11 = await f(s); s.<span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { std::istream fi = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file).get(); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>().get()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>    <span class="hljs-string"><span class="hljs-string">" "</span></span> -    future::get()       std::future.        ,  get()  <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().  ,  . <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::istream fi) { auto ret = std::make_shared&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); auto <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = std::make_shared&lt;std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>&gt;&gt;( [=]{ fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>([=](std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> chunk) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( chunk.size() ) { *ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *ret; }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>)(); }); }</code> <br> <br>     .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()      .             async/await: <br> <br> <code class="cpp">task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>( std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file, std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> suffix ) __async { std::istream fi = __await <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(file); std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret, chunk; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( (chunk = __await fi.<span class="hljs-built_in"><span class="hljs-built_in">read</span></span>()).size() ) ret += chunk + suffix; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> <br> <br>         <code>task&lt;std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;</code> ,            .    await  ,    .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    <span class="hljs-string"><span class="hljs-string">""</span></span>  ,        std::future,         <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    <span class="hljs-number"><span class="hljs-number">2</span></span> :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      <span class="hljs-string"><span class="hljs-string">"  "</span></span>:    ,   ,            ,          -      <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      <span class="hljs-string"><span class="hljs-string">""</span></span>,      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <code><a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code><code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++<span class="hljs-number"><span class="hljs-number">14.</span></span>     -,    ( ?) ++<span class="hljs-number"><span class="hljs-number">14</span></span>     (  )  -   .   -    ++<span class="hljs-number"><span class="hljs-number">11</span></span>        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++<span class="hljs-number"><span class="hljs-number">14</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    <span class="hljs-number"><span class="hljs-number">2013</span></span> . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    <span class="hljs-string"><span class="hljs-string">"resumable"</span></span>,   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   <span class="hljs-string"><span class="hljs-string">" "</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>.  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = low; i &lt;= high; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> i; } }</code> <br> <br> <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>    <i>i</i>       sequence.    <code>sequence   ,      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>.          -     ,    ,  .      <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>  await     .</code></code></code></code></code></code> </pre> <code><code><code><code><code><code class="cpp">std::future. <br> <br>  resumable      .    await   ""      future,         .   await      (, ,  "!"). <br> <br>      .      await  -     std::future,      .    ,      Hartmut Kaiser -    : <br> <br> std::future&lt;uint64_t&gt; fibonacci(uint64_t n) async { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs = std::async(&amp;fibonacci, n-1); std::future&lt;uint64_t&gt; rhs = fibonacci(n-2); return await lhs + await rhs; }</code> <br> <br>   resumable     .   lhs  std::future  ,         await,     std::future  . <br> <br>    , resumable  -   ,   await  future       .         ,    ,       await.   ,           await.   ,           ,     . <br> <br>   <br>      resumable ,      "       ?".  - . ,            .  resumable         .    Thomas Heller    (  )  resumable . <br> <br> <code class="cpp">std::future&lt; uint64_t&gt; fibonacci(uint64_t n) { if (n &lt; 2) return std::make_ready_future(n); std::future&lt;uint64_t&gt; lhs_future = std::async(&amp;fibonacci, n-1); //.unwrap(); std::future&lt;uint64_t&gt; rhs_future = fibonacci(n-2); return dataflow( unwrapped([](uint64_t lhs, uint64_t rhs) { return lhs + rhs; }) , lhs_future, rhs_future ); }</code> <br> <br>     .  , "dataflow"    await     .        future,   .    ++11  ++14    -     . <br> <br>       -  resumable ? <br>    ,          ,           .    Hartmut Kaiser         ,   resumable   .  ,               \ .               ,           . <br> <br>   resumable  <br>    -   (      )  resumable .   -   ,  ,   .         async/await,       (if/else, for  ..).   .     <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3650.pdf">N3650</a> ,      std::future: <br> <br> <code class="cpp">future&lt;int&gt; f(shared_ptr str) { shared_ptr&lt;vector&gt; buf = ...; return str-&gt;read(512, buf) .then([](future&lt;int&gt; op)// lambda 1 { return op.get() + 11; }); } future&lt;void&gt; g() { shared_ptr s = ...; return f(s).then([s](future&lt;int&gt; op) // lambda 2 { s-&gt;close(); }); }</code> <br> <br>        resumable : <br> <br> <code class="cpp">future&lt;void&gt; f(stream str) async { shared_ptr&lt;vector&gt; buf = ...; int count = await str.read(512, buf); return count + 11; } future g() async { stream s = ...; int pls11 = await f(s); s.close(); }</code> <br> <br>   resumable        (,   ,    ).              .     ,   Herb Sutter     BUILD: <br> <br> <code class="cpp">std::string read( std::string file, std::string suffix ) { std::istream fi = open(file).get(); std::string ret, chunk; while( (chunk = fi.read().get()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>    " " -    future::get()       std::future.        ,  get()  then().  ,  . <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) { return open(file) .then([=](std::istream fi) { auto ret = std::make_shared&lt;std::string&gt;(); auto next = std::make_shared&lt;std::function&lt;task()&gt;&gt;( [=]{ fi.read() .then([=](std::string chunk) { if( chunk.size() ) { *ret += chunk + suffix; return (*next)(); } return *ret; }); }); return (*next)(); }); }</code> <br> <br>     .then()      .             async/await: <br> <br> <code class="cpp">task&lt;std::string&gt; read( std::string file, std::string suffix ) __async { std::istream fi = __await open(file); std::string ret, chunk; while( (chunk = __await fi.read()).size() ) ret += chunk + suffix; return ret; }</code> <br> <br>         <code>task&lt;std::string&gt;</code> ,            .    await  ,    .then().      __async  __await   ,       Visual Studio. <br> <br>     .      ,     - .     std::future, auto  .then ,     -     ,        .        resumable .      ,   ,         ,        async/await.   resumable        ,    ""  ,        std::future,         1:0   resumable . <br> <br>  .   ,  resumable          .    ,        ++?  .     .   .  -    2 :         .      -     ? .   ,       .          .     ?  ?               futures (-    ).   ,         ,   ,     .     resumable       (, )      "  ":    ,   ,            ,          -      " ". <br> <br>     , resumable     .     std::(shared_)future  void.    ,       boost::future  hpx::future. ,      "",      .   - resumable     VArgs,      -.      ,      variadic templates.    ,  ,  resumable   ,    ,     <a href="http://isocpp.org/files/papers/N3722.pdf"></a> <code><code>std::future -       copy/move . <br> <br>    <br>    ,      ++14.     -,    ( ?) ++14     (  )  -   .   -    ++11        .   ,      -  ++y1.     resumable  -     (TS),       - WG21.   ,     resumable    ,      .         ,     .    ,     CTP  Visual Studio     ( <i>.</i> :   !).       __async  __await. <br> <br>  ,         .      ++14   .then()  future, await        std::future::get. <br> <br>  <br>     .    -      ,     -   .   resumable    .    ,   Cilk (      - ).   - resumable  -      -  ,    . <br> <br>        (        __async\__await ?).   resumable   STL  Boost      -  . <br> <br>    ,  resumable  -   -   (. ). , ,      .  -,         ?       ,    ,  ,   - . <br> <br>  ,    ,     resumable .  -    resumable lambda functions ?     -    WG21,    2013 . <br> <br>  -  N3722 <br>          resumable .     ,    async   resumable.  ,  resumable    "resumable",   - .    await  . <br> <br>       ,   std::future    .  ,        s,    : <br> <br>  get(),         then(),   callable object    s, s&amp;  const s.          get().</code> <br>   is_ready(),   future <br></code> <br> <br>     ,      <code><code class="cpp">s::promise_type,     resumable .      set_value(T)  set_exception(exception_ptr).      s::promise_type  s. <br> <br></code>  <br>      ,   " "   "".  STL  ,        ,           ,   -        .    - sequence  ,   ,        ,       ( ). <br> <br>          yield: <br> <br> sequence&lt;int&gt; range(int low, int high) resumable { for(int i = low; i &lt;= high; ++i) { yield i; } }</code> <br> <br> yield    <i>i</i>       sequence.    <code>sequence   ,      yield.          -     ,    ,  .      yield  await     .</code></code></code></code></code></code> </li> </ul></div><p>Source: <a href="https://habr.com/ru/post/203724/">https://habr.com/ru/post/203724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../203704/index.html">Theory of a Large Supercomputer</a></li>
<li><a href="../203706/index.html">How to run a program without an operating system: part 6. Support for working with disks with the FAT file system</a></li>
<li><a href="../203708/index.html">Black Hat USA 2013. What was a little about the reports</a></li>
<li><a href="../203714/index.html">US Department of Health threatens 23andMe</a></li>
<li><a href="../203720/index.html">MakeItLab & CoolRF at the International Exhibition Center</a></li>
<li><a href="../203726/index.html">Comparative study of the results of applying Scrum- and Kanban approaches based on case studies and modeling</a></li>
<li><a href="../203728/index.html">Selling design online store. Part 3. Design elements</a></li>
<li><a href="../203730/index.html">Qualcomm and Xilinx began shipping samples of microcircuits manufactured using 20nm technology</a></li>
<li><a href="../203732/index.html">Contests InterSystems: faster, higher, stronger!</a></li>
<li><a href="../203734/index.html">On Friday, the commercial launch of Falcon-9 v1.1 from SpaceX will take place (with the launch launch on the Web)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>