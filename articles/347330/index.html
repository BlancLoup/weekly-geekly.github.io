<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing AI for a turn-based game on Node.js (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again, friends! 

 Not so long ago, I shared with you my experience of using a neural network to solve the problem of choosing an action by a bo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing AI for a turn-based game on Node.js (part 2)</h1><div class="post__text post__text-html js-mediator-article">  Hello again, friends! <br><br>  Not so long ago, I shared with you my experience of using a neural network to solve the problem of choosing an action by a bot.  To learn more about the essence of the problem, please read <a href="https://habrahabr.ru/post/345576/">the first part of the article</a> . <br><br>  And I turn to the story of the next stage of work! <br><a name="habracut"></a><br><h3>  Decision tree </h3><br>  After an unsuccessful (but very useful) experience with the neural network, I began to study decision trees and game theory.  In the course of studying the issue, I had a lot of ideas and concepts, but I stopped at the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  A bot already has a set of actions (nodes) at the very first level of the tree.  These are the actions among which the bot will later select the best for the current game situation. </li><li>  The bot makes a "simulation" of each action, i.e.  trying to commit it "in the mind."  The result of such an action will be a change in the game situation, in other words, the transition of the environment to another state. </li><li>  The new state is passed to the function of assessing the situation, the result of which is a certain value - <i>score</i> action. </li><li>  After calculating the <i>score, the</i> bot generates a list of actions that can be performed from a new virtual situation.  Then we recursively repeat points 2 and 3 until the bot can do something other than complete the move. </li><li>  When <i>scores are</i> calculated for all actions at one level of the tree, the maximum <i>score</i> returns to the parent level of the tree and is added to the <i>score of</i> the action that generated the child's list of actions.  Thus, <i>score</i> values ‚Äã‚Äãseem to ‚Äúfloat‚Äù from the extreme branches of the tree to the roots. </li><li>  When the tree walk is completed, every action that a bot can do at the moment will have a <i>score</i> .  Now we just have to choose the action with the maximum <i>score</i> value and apply it. </li></ol><br>  The following is a recursive function describing this algorithm: <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildActionBranch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">situation</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionList = createActionList(situation); <span class="hljs-comment"><span class="hljs-comment">/*  createActionList   ,              .    actionList            (newSituation). */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; actionList.length; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(actionList[i].type !== <span class="hljs-string"><span class="hljs-string">"endTurn"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*       ,      */</span></span> actionList[i].branch = buildActionBranch(actionList[i].newSituation); <span class="hljs-comment"><span class="hljs-comment">/*  selfScore -       ,   score     ,            */</span></span> actionList[i].score = actionList[i].selfScore + actionList[i].branch[<span class="hljs-number"><span class="hljs-number">0</span></span>].score; <span class="hljs-comment"><span class="hljs-comment">/* actionList[i].branch[0] -      score    */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { actionList[i].score = actionList[i].selfScore; } } <span class="hljs-comment"><span class="hljs-comment">/*     score   */</span></span> actionList.sort(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.score &lt;= b.score) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.score &gt; b.score) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } }); <span class="hljs-comment"><span class="hljs-comment">/*  actionList    branch   ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> actionList; }</code> </pre> <br></div></div><br>  This is only a schematic representation of the recursive function, in fact in the construction of the tree there are nuances, which I will discuss later.  I also implemented a function for writing data about the decision tree to a file so that later you can visually see how it looks. <br><br><img src="https://habrastorage.org/webt/sf/4u/9_/sf4u9_ie1lqkpcdqem_pp4wumim.jpeg"><br>  <i>Decision tree (JSON file size: 4kb)</i> <br><br>  This tree is built for a move, where the character has already spent some energy and only 5 options are given to him: 3 moves to adjacent cells, use the Hit The Lights ability and end the turn.  At each node you can see the name of the action, <i>score</i> - the number above and <i>selfScore</i> - the number below.  You can easily see how the <i>score</i> is formed at the root level.  Due to the fact that all arrays are sorted by <i>score</i> , the optimal solution is always on top.  Consider another tree: <br><br><img src="https://habrastorage.org/webt/tm/sp/z6/tmspz6adadicnxw8yngw4rexvrc.jpeg"><br>  <i>A tree with an open best solution (JSON file size: 169kb)</i> <br>  Unfortunately, I will not be able to show you the full tree for this case, since it will take about 80,000 pixels in height.  Let's walk along the opened branch from right to left: <br><br>  377 (endTurn) + 378 (move) + 373 (cast Defender Of The Faith) + 312 (cast Punishment Due) + 218 (move) = 1658 <br><br>  For the <i>move</i> action, the <i>score</i> value is 1660. The difference is 2 points due to the rounding of numbers to integer values ‚Äã‚Äãwhen displayed on the screen.  Let's look at the <i>selfScore</i> values ‚Äã‚Äãfor the first tree level: the move action with <i>selfScore</i> equal to 218 is not the largest among the neighboring nodes.  The best action at this level is to use "Defender Of The Faith" ( <i>selfScore</i> = 244).  However, the total score (1660 versus 1652) is still greater for the <i>move</i> action.  It turns out that without thinking through the actions for the whole course, using the ability in this situation would not be so optimal. <br><br>  Now let's take a closer look at the various aspects of this algorithm. <br><br><h4>  Assessment of the situation </h4><br>  To assess the situation, use the following function: <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">situationCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">activeChar, myTeam, enemyTeam, wallPositions</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effectScores = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     score += activeChar.curHealth / activeChar.maxHealth * 110; score += activeChar.curMana / activeChar.maxMana * 55; var positionWeights = arenaService.calculatePositionWeight(activeChar.position, activeChar, myTeam.characters, enemyTeam.characters, arenaService.getOptimalRange(activeChar), wallPositions); score += positionWeights[0] * 250 + Math.random(); score += positionWeights[1] * 125 + Math.random(); for(var j = 0; j &lt; activeChar.buffs.length; j++){ if(activeChar.buffs[j].score) { effectScores = activeChar.buffs[j].score(activeChar, myTeam.characters, enemyTeam.characters, wallPositions); score += this.calculateEffectScore(effectScores, activeChar.buffs[j].name); } } for(j = 0; j &lt; activeChar.debuffs.length; j++){ if(activeChar.debuffs[j].score) { effectScores = activeChar.debuffs[j].score(activeChar, myTeam.characters, enemyTeam.characters, wallPositions); score -= this.calculateEffectScore(effectScores, activeChar.debuffs[j].name); } } //myTeam -    for(var i = 0; i &lt; myTeam.characters.length; i++){ if(myTeam.characters[i].id !== activeChar.id) { var ally = myTeam.characters[i]; score += ally.curHealth / ally.maxHealth * 100; score += ally.curMana / ally.maxMana * 50; for(j = 0; j &lt; ally.buffs.length; j++){ if(ally.buffs[j].score) { effectScores = ally.buffs[j].score(ally, myTeam.characters, enemyTeam.characters, wallPositions); score += this.calculateEffectScore(effectScores, ally.buffs[j].name); } } for(j = 0; j &lt; ally.debuffs.length; j++){ if(ally.debuffs[j].score) { effectScores = ally.debuffs[j].score(ally, myTeam.characters, enemyTeam.characters, wallPositions); score -= this.calculateEffectScore(effectScores, ally.debuffs[j].name); } } } } //enemyTeam -  for(i = 0; i &lt; enemyTeam.characters.length; i++){ var enemy = enemyTeam.characters[i]; score -= Math.exp(enemy.curHealth / enemy.maxHealth * 3) * 15 - 200; score -= enemy.curMana / enemy.maxMana * 50; for(j = 0; j &lt; enemy.buffs.length; j++){ if(enemy.buffs[j].score) { effectScores = enemy.buffs[j].score(enemy, enemyTeam.characters, myTeam.characters, wallPositions); score -= this.calculateEffectScore(effectScores, enemy.buffs[j].name); } } for(j = 0; j &lt; enemy.debuffs.length; j++){ if(enemy.debuffs[j].score) { effectScores = enemy.debuffs[j].score(enemy, enemyTeam.characters, myTeam.characters, wallPositions); score += this.calculateEffectScore(effectScores, enemy.debuffs[j].name); } } } return score; }</span></span></code> </pre><br></div></div><br>  This method runs over all the characters involved in the battle and charges a certain number of points for various parameters: <br><br><ul><li>  <b>Health</b> .  The higher the percentage of allied health, the more points.  Moreover, the dependence is linear: <br><br><pre> <code class="javascript hljs"> score += activeChar.curHealth / activeChar.maxHealth * <span class="hljs-number"><span class="hljs-number">110</span></span>;</code> </pre><br>  But when assessing the health of the characters of the <b>enemy,</b> points are accrued according to the following formula: <br><br><pre> <code class="javascript hljs"> score -= <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.exp(enemy.curHealth / enemy.maxHealth * <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">15</span></span> - <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br><img src="https://habrastorage.org/webt/rn/tn/nn/rntnnnzysdmqyvwc8zwbxtnx5u8.png"><br>  <i>The graph of the above function in the range from 0 to 1 on the axis of the current health</i> <br><br>  With the full health of opponents from the total number of points are subtracted about the same values, which are added to the allies.  However, the lower the health of a particular character, the more points this situation will pick up.  At low health points will no longer be deducted, but added.  This is done so that the bots focus their efforts on destroying a single target, instead of ‚Äúsmearing‚Äù the damage on the enemy team. </li><li>  <b>Mana (resource for the use of abilities).</b>  There are already no complicated functions, everything is linear for both allies and opponents. </li><li>  <b>Position.</b>  I have already casually mentioned the assessment of the position of the character on the battlefield. <br>  It consists of two parts: attacking and defensive.  The best attacking position is 3 enemy characters within sight and at the optimum distance to attack.  The best defensive position is 2 allies within sight and at the optimum distance for using support abilities.  Positioning points are awarded only for the active character, since changing the positions of other characters will still affect the value of the corresponding indicators for the active one. </li><li>  <b>Effects.</b>  The most difficult part of the evaluation function.  Bot needs to determine <br>  how much one effect imposed on a character is more important than another.  For this, each effect has a <i>score</i> function.  For example, buff (buff) <br>  ‚ÄúCauterization‚Äù gradually restores a character‚Äôs health, but burns his mana.  For this effect, the <i>score</i> function looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> score: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">owner, myTeam, enemyTeam, walls</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = {}; <span class="hljs-comment"><span class="hljs-comment">/* buffer - ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; myTeam.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myTeam[i].id === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.casterId) buffer = myTeam[i]; } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> heal = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variant * <span class="hljs-number"><span class="hljs-number">80</span></span>) * (<span class="hljs-number"><span class="hljs-number">1</span></span> + buffer.spellPower); <span class="hljs-comment"><span class="hljs-comment">/*       ,    */</span></span> heal = arenaService.calculateExpectedHeal(heal, buffer); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> positionWeights = arenaService.calculatePositionWeight(owner.position, owner, myTeam, enemyTeam, arenaService.getOptimalRange(owner), walls); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">effectScore</span></span>: heal / <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">leftScore</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left * <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">offensivePositionScore</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">defensivePositionScore</span></span>: - positionWeights[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">healthScore</span></span>: - owner.curHealth / owner.maxHealth * <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-attr"><span class="hljs-attr">manaScore</span></span>: owner.curMana / owner.maxMana * <span class="hljs-number"><span class="hljs-number">15</span></span> }; }</code> </pre><br></div></div><br>  So, the <i>score</i> function for the effect returns an object with 6 properties: <br><br><ul><li>  <i>effectScore.</i>  The modifier of the numerical indicators of the effect itself: the size of the damage caused, the healing received, the increase or decrease in the characteristics, etc. </li><li>  <i>leftScore.</i>  Time modifier effect. </li><li>  <i>offensivePositionScore.</i>  Modifier attacking position. </li><li>  <i>defensivePositionScore.</i>  Defensive position modifier. </li><li>  <i>healthScore.</i>  The amount of health modifier effect holder. </li><li>  <i>manaScore.</i>  Mana modifier for the effect owner. </li></ul><br>  In the situation assessment function, all these modifiers are summed up.  This amount will be an indicator of the "quality" of this effect. <br><br>  For all these modifiers about the effect of <i>"Cauterization",</i> we can draw the following conclusions: <br><br><ul><li>  The more health he recovers, the higher the amount. </li><li>  The more he will hold on the character, the higher the amount. </li><li>  The location of the opponents does not affect the amount. </li><li>  The further we are from the allies, the higher the amount.  Since  there is no one to rely on and be safe. </li><li>  The less health the character has, the higher the amount. </li><li>  The more mana left in the character, the higher the amount.  After all, we do not want this effect to completely leave us without mana, if it is so small. </li></ul><br></li></ul><br><h4>  Action simulation </h4><br>  In order to evaluate the result of the execution of the bot action: <br><br><ol><li>  Fully copies the state of the environment so that all its further actions do not change the original state. </li><li>  Performs a simulation of an action (moving or using an ability) </li><li>  Evaluates the new state of the environment using the evaluation function </li></ol><br>  We will return to copying a bit later, but for now let's take a closer look at what the simulation is like using the example of one of the simplest mechanics abilities in the game - ‚ÄúDie By The Sword‚Äù. <br><br><img src="https://habrastorage.org/webt/z9/un/7k/z9un7kjqacg16ticl-wq1ot5c5k.jpeg"><br>  Each ability in the game has a <i>cast</i> function that deals damage, heals, applies effects, and so on.  Let's look at the <i>cast</i> function for <i>‚ÄúDie By The Sword‚Äù</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> cast : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caster, target, myTeam, enemyTeam, walls</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> caster.spendEnergy(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energyCost()); caster.spendMana(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.manaCost()); <span class="hljs-comment"><span class="hljs-comment">/* ,           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cooldown(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(caster.checkHit()){ <span class="hljs-comment"><span class="hljs-comment">/*             */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> physDamage = randomService.randomInt(caster.minDamage * (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variant * <span class="hljs-number"><span class="hljs-number">0.35</span></span>), caster.maxDamage * (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variant * <span class="hljs-number"><span class="hljs-number">0.35</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> critical = caster.checkCrit(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(critical){ physDamage = caster.applyCrit(physDamage); } <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> physDamage = target.applyResistance(physDamage, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      ,      */</span></span> caster.soundBuffer.push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name); <span class="hljs-comment"><span class="hljs-comment">/*      physDamage */</span></span> target.takeDamage(physDamage, caster, {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-attr"><span class="hljs-attr">icon</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.icon(), <span class="hljs-attr"><span class="hljs-attr">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.role()}, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, critical, myTeam, enemyTeam); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*      ,     */</span></span> caster.afterMiss(target.charName, {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, <span class="hljs-attr"><span class="hljs-attr">icon</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.icon(), <span class="hljs-attr"><span class="hljs-attr">role</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.role()}, myTeam, enemyTeam); } <span class="hljs-comment"><span class="hljs-comment">/*       ,     */</span></span> caster.afterCast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, myTeam, enemyTeam); }</code> </pre><br></div></div><br>  From the function it is clear that inside this function there are at least 3 operations of a random nature (determining damage, determining hit, determining critical impact), as well as utilitarian methods like adding sounds for playback on the client.  Naturally, when it comes to predicting the consequences, we cannot use this function.  Therefore, in addition to the <i>cast</i> function, each ability also has <i>castSimulation</i> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> caster.spendEnergy(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.energyCost()); caster.spendMana(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.manaCost()); <span class="hljs-comment"><span class="hljs-comment">/* ,           */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cd = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cooldown(); <span class="hljs-comment"><span class="hljs-comment">/*    -         */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> physDamage = (caster.minDamage * (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variant * <span class="hljs-number"><span class="hljs-number">0.35</span></span>) + caster.maxDamage * (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variant * <span class="hljs-number"><span class="hljs-number">0.35</span></span>)) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*            */</span></span> physDamage = caster.hitChance * ((<span class="hljs-number"><span class="hljs-number">1</span></span> - caster.critChance) * physDamage + caster.critChance * (<span class="hljs-number"><span class="hljs-number">1.5</span></span> + caster.critChance) * physDamage); physDamage = target.applyResistance(physDamage, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      ""   */</span></span> target.takeDamageSimulation(physDamage, caster, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, myTeam, enemyTeam); caster.afterCastSimulation(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);</code> </pre><br>  For the simulation of movement actions, the same method is used - we simply cut off the unnecessary and replace random methods with a mathematical expectation. <br><br><h3>  Optimization </h3><br>  After the basic algorithm was built, I saw for the first time that the bots ponder the course and take actions.  It was very cool to see how they decide how to act in this or that situation.  But then the following problem suddenly surfaced - sometimes they think oooooochen for a long time.  So long that <i>Socket.io</i> crashes because the ping event doesn‚Äôt occur due to busy <i>Node.js</i> tree computing.  It's time to do optimization. <br><br><h4>  1) Release of flow </h4><br>  The first thing that occurred to me was to make the construction of the tree asynchronous.  Using the <i>async</i> library and the <i>eachOf</i> method <i>,</i> I converted all passes through the action lists to asynchronous, and all returns in <i>callback</i> 'and.  But it only got worse: (The tree was built slowly one and a half times, and debugging the asynchronous construction of a deep tree is another quest ... <br><br>  Then I began to experiment with <i>process.nextTick</i> , I tried to wrap different pieces of code in it, but did not notice any effect. <br>  As a result, I came to the following scheme: <br><br><ul><li>  For the very first list of actions, we asynchronously start building branches. </li><li>  For all nested branches, the tree will be synchronized. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   -  " "     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildActionBranchAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myTeam, enemyTeam, activeCharId, wallPositions, cb</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   ,   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionList = self.createActionList(myTeam, enemyTeam, activeCharId, wallPositions); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.eachOf(actionList, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actionInList, index, cb</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> process.nextTick(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(actionInList.type != <span class="hljs-string"><span class="hljs-string">"endTurn"</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> actionInList.branch = self.buildActionBranchSync(actionInList.myTeamState, actionInList.enemyTeamState, actionInList.activeCharId, wallPositions); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(actionInList.branch &amp;&amp; actionInList.branch[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { actionInList.score = actionInList.selfScore + actionInList.branch[<span class="hljs-number"><span class="hljs-number">0</span></span>].score; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { actionInList.score = actionInList.selfScore; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { actionInList.score = actionInList.selfScore; } cb(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, temp</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(err){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err); } actionList.sort(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.score &lt;= b.score) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.score &gt; b.score) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } }); cb(actionList); }) }</code> </pre><br></div></div><br>  This solution turned out to be the best one I reviewed, but it is still blocking.  The socket continues to fall with a long "thinking" course.  If someone has any ideas about changing the architecture of building a tree and using the <i>process.nextTick</i> , I will be happy to help) <br><br><h4>  2) Memory release </h4><br>  Another problem was that sometimes the bot thought for so long that I got an error like <i>JavaScript heap out of memory</i> .  It is clear that there is an overflow of RAM, since the decision tree simply does not fit in the default memory space of 512 MB.  You can, of course, expand the allotted space, but this is still wrong, it is better to try to meet the minimum.  The weak point of my architecture was that I had to keep the states of all combat situations as I was building a tree.  And since the objects before the simulation are completely copied, the memory simply chokes.  The first thing I did was reduce the weight of the objects before building the tree.  So, for example, there is a number of properties for the <i>Character</i> object, which do not participate at all in the simulation: inventory, an array of messages to the log, an array of sounds for playback, frame colors for characters, etc.  Now, before building the tree, the object objects are lightened as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightWeightTeamBeforeSimulation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">team</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> team.teamName; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> team.lead; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; team.characters.length; i++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> char = team.characters[i]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.battleTextBuffer; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.logBuffer; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.soundBuffer; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.battleColor; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.charName; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.gender; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.isBot; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.portrait; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.race; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.role; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.state; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.calcParamsByPoint; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.calcItem; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.updateMods; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.removeRandomBuff; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.removeRandomDebuff; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.removeAllDebuffs; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.removeRandomDOT; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.stealRandomBuff; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.afterDealingDamage; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.afterDamageTaken; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.afterMiss; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.removeImmobilization; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.afterCast; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> char.getSize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; char.abilities.length; j++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ability = char.abilities[j]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ability.cast; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ability.icon; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ability.role; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; char.buffs.length; j++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effect = char.buffs[j]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> effect.icon; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> effect.role; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> effect.apply; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; char.debuffs.length; j++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> effect = char.debuffs[j]; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> effect.icon; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> effect.role; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> effect.apply; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> team; }</code> </pre><br></div></div><br>  Thus, I managed to reduce the size of the object of each character by more than 40%.  But even this did not save me from memory overflow.  I discussed the problem with a colleague and we found out that it does not make sense to keep a branch in memory after it returns us a list of actions.  After all, we are only interested in the most successful solution, and the rest without the need.  Now immediately after returning the result, the branch is simply deleted: <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildActionBranchSync</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myTeam, enemyTeam, activeCharId, wallPositions</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actionList = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createActionList(myTeam, enemyTeam, activeCharId, wallPositions); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; actionList.length; z++){ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> actionList[z].branch = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildActionBranchSync(actionList[z].myTeamState, actionList[z].enemyTeamState, actionList[z].activeCharId, wallPositions); actionList[z].score = actionList[z].selfScore + actionList[z].branch[<span class="hljs-number"><span class="hljs-number">0</span></span>].score; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> actionList[z].branch; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* sort actionList */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> actionList; }</code> </pre><br></div></div><br>  After that, I forgot about memory overflow forever. <br><br><h4>  3) Reduction of the list of actions </h4><br>  Despite all the previous optimizations, thinking about the move still sometimes took about 30 seconds: (The next step was to add an additional <i>usageLogic</i> function for each ability, which described the acceptability of its use depending on the situation. For example, there is no point throwing healing on a character with maximum health, therefore Before building a list of actions involving such an ability, we will perform the following check: <br><br><pre> <code class="javascript hljs"> usageLogic: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*     60% */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.curHealth &lt; target.maxHealth * <span class="hljs-number"><span class="hljs-number">0.6</span></span>; }</code> </pre><br>  Thus, both bots have become smarter and the number of actions for selection has been reduced by several times.  Nevertheless, there was one ability that spawned a large number of actions: <br><br><img src="https://habrastorage.org/webt/sj/6e/xh/sj6exht53vqnf8ckibaeq-cqf9a.jpeg"><br>  <i>The ability "Speed ‚Äã‚ÄãOf Light" allows you to heat your character to a position within a radius of 6 cells around him.</i> <br><br>  It turns out that in the worst case, this ability generates 35 actions.  The decision tree here is very wide.  The solution came naturally after I completed the <i>usageLogic</i> functions for abilities.  After all, you can also eliminate unsuccessful points for moving.  Above, I have already mentioned the scales of positions and the function <i>calculatePositionWeight</i> .  So, at the stage of building a list of cells available for movement, you can evaluate the profitability of each and eliminate the weakest positions: <br><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMovePoints = []; <span class="hljs-comment"><span class="hljs-comment">/*    ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movePoints = arenaService.findMovePoints(myTeam, enemyTeam, activeChar, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, wallPositions); <span class="hljs-comment"><span class="hljs-comment">/*          */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; movePoints.length; i++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weights = arenaService.calculatePositionWeight(movePoints[i], activeChar, myTeam.characters, enemyTeam.characters, arenaService.getOptimalRange(activeChar), wallPositions); <span class="hljs-comment"><span class="hljs-comment">/*       (weights[0])  ,        (weights[1]) */</span></span> bestMovePoints.push({ <span class="hljs-attr"><span class="hljs-attr">point</span></span>: movePoints[i], <span class="hljs-attr"><span class="hljs-attr">weightScore</span></span>: weights[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">6</span></span> + weights[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">4</span></span> }) } <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> bestMovePoints.sort(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.weightScore &lt;= b.weightScore) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.weightScore &gt; b.weightScore) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } }); <span class="hljs-comment"><span class="hljs-comment">/*    3  */</span></span> bestMovePoints = bestMovePoints.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bestMovePoints.length; j++){ <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> }</code> </pre><br></div></div><br>  I applied this approach to both normal movement and abilities that move a character ( <i>‚ÄúSpeed ‚Äã‚ÄãOf Light‚Äù</i> ). <br><br><h4>  4) Thinking threshold </h4><br>  Even with this optimization, there are times when thinking is delayed. <br><br><img src="https://habrastorage.org/webt/el/gl/jb/elgljbgxfvtmpaaawg-vkgnnvak.jpeg"><br>  <i>The ‚ÄúI don't wanna Stop‚Äù ability recovers 850 energy.</i> <br><br>  The ability to use this ability increases the thinking time by 2 or even 3 times, because  after any action, you can almost completely restore energy and start thinking over the course again. <br><br>  In order to avoid such ‚Äúlong‚Äù thoughts, I introduced a threshold time for building a tree.  At the moment it is 3 seconds.  Before building a new branch with options, I check with this time.   ,             ,    .           .         2000   ,    <i>Heroku</i>   <i>¬´FREE¬ª</i>  700   .      ,          3 .     ,     ,       , , ,   . <br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, I was able to solve the problem with the help of a decision tree. </font><font style="vertical-align: inherit;">Let's try to understand the advantages and disadvantages of this approach. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benefits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can track the entire "train of thought" bot and find errors </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fine-tuning each ability, effect, and rating points allows you to control the balance of combat </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No need to collect data for the training sample, and also save the sample in the database </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No need to store the neural network model in the database </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Easily add new abilities without having to adapt AI to them. </font></font></li></ol><br>  <b>Disadvantages</b> : <br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For each action, the tree must be built from scratch, which is very expensive for server resources. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bots are not trained, they will repeat the same mistakes over and over again. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You need to debug and configure the internal decision-making algorithm. </font></font></li></ol><br> ,     .                 .           ,          . ,       : <br><br><pre> <code class="javascript hljs"> score += activeChar.curHealth / activeChar.maxHealth * <span class="hljs-number"><span class="hljs-number">110</span></span>;</code> </pre><br>  110,  ,  ¬´ ¬ª,      ,         ,    .           ¬´¬ª.        ¬´¬ª   ,           ¬´¬ª      .       . <br><br>    ,    .         ,        . <br><br> <i>PS        .  ,           .   ,  .</i> </div><p>Source: <a href="https://habr.com/ru/post/347330/">https://habr.com/ru/post/347330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347316/index.html">IT infrastructure of Navalny headquarters and collection of signatures: hardware and networks</a></li>
<li><a href="../347320/index.html">Navalny Headquarters IT infrastructure and collection of signatures: Reaper-2018</a></li>
<li><a href="../347322/index.html">Not a feature, but a bug</a></li>
<li><a href="../347324/index.html">Risks of using virtual number services for receiving SMS when registering on Internet resources</a></li>
<li><a href="../347328/index.html">Creating parametric database objects in nanoCAD Mechanics (Part 2)</a></li>
<li><a href="../347332/index.html">We read data from the open part of KOMPAS-3D files for integration with Pilot-ICE</a></li>
<li><a href="../347338/index.html">The obvious benefit: how and why to use the service approach beyond IT</a></li>
<li><a href="../347340/index.html">Scales and barcodes: How retailers and manufacturers ended up in a deep ... puddle</a></li>
<li><a href="../347342/index.html">Navalny Headquarters IT infrastructure and signature collection: project management</a></li>
<li><a href="../347344/index.html">Features of industrial aerial photography. Part I. Preparatory rake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>