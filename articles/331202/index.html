<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Build a Linux kernel module without accurate header files</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine that you have a Linux kernel image for an Android phone, but you don‚Äôt have any source code or kernel header files. Imagine that the kernel ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Build a Linux kernel module without accurate header files</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/9ae/726/129/9ae7261299624624a5e3ccb8bed313db.jpg"></div><br>  Imagine that you have a Linux kernel image for an Android phone, but you don‚Äôt have any source code or kernel header files.  Imagine that the kernel has support for loading modules (fortunately), and you want to build a module for a given kernel.  There are several good reasons why you can‚Äôt just build a new core from source and just end up on that (for example, there is no support for some important device in the assembled core, like an LCD or touchscreen).  With the ever-changing Linux kernel ABI and the lack of source files and header files, you might think that you are completely stumped. <br><br>  As a statement of fact, if you assemble a kernel module using other header files (rather than those used to build the kernel image you have ‚Äî note.), The module cannot load with errors depending on how much header files were different from those required.  He may complain about bad signatures, bad versions and other things. <br><br>  But more about this further. <br><a name="habracut"></a><br><h1>  Kernel configuration </h1><br>  The first step is to find the kernel sources as close as possible to the image of the kernel.  Probably getting the right configuration is the most difficult part of the whole module building process.  Start with the kernel version number that can be read from <code>/proc/version</code> .  If, like me, you are assembling a module for an Android device, try Android kernels from Code Aurora, Cyanogen or Android, the ones closest to your device.  In my case, it was the core of msm-3.0.  Note that you do not need to search for exactly the same source version as the version of your kernel image.  Minor version differences are most likely not to be a hindrance.  I used the kernel source 3.0.21, while the version of the existing kernel image was 3.0.8.  Do not try, however, to use the source code for the 3.1 kernel if you have a 3.0.x kernel image. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If the kernel image that you have is kind enough to provide the <code>/proc/config.gz</code> file, you can start with this, otherwise, you can try to start with the default configuration, but in this case you need to be extremely careful ( although I will not go into the details of using the default configuration, as I was lucky not to resort to this, then there will be some details as to why the correct configuration is so important). <br><br>  Assuming that <code>arm-eabi-gcc</code> is accessible through one of the paths in the PATH environment variable, and that the terminal is open in the folder with the kernel source files, you can start the kernel configuration and the installation of header files and scripts: <br><br><pre> <code class="hljs lua">$ mkdir build $ gunzip <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.gz &gt; build/.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span> #   ,  ,   .<span class="hljs-built_in"><span class="hljs-built_in">config</span></span> $ make silentoldconfig prepare headers_install scripts ARCH=arm CROSS_COMPILE=arm-eabi- O=build KERNELRELEASE=`adb shell uname -r`</code> </pre><br>  The <code>silentoldconfig</code> is most likely to ask if you want to enable certain options.  You can choose defaults, but this may well not work. <br><br>  You can use something else in <code>KERNELRELEASE</code> , however, this must match exactly the version of the kernel from which you plan to load the module. <br><br><h1>  Writing a simple module </h1><br>  To create an empty module, you need to create two files: the source and the <code>Makefile</code> .  <code>hello.c</code> following code in the file <code>hello.c</code> , in a separate directory: <br><br><pre> <code class="hljs swift">#include &lt;linux/module.h&gt; <span class="hljs-comment"><span class="hljs-comment">/* Needed by all modules */</span></span> #include &lt;linux/kernel.h&gt; <span class="hljs-comment"><span class="hljs-comment">/* Needed for KERN_INFO */</span></span> #include &lt;linux/<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>.h&gt; <span class="hljs-comment"><span class="hljs-comment">/* Needed for the macros */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int __init hello_start(void) { printk(<span class="hljs-type"><span class="hljs-type">KERN_INFO</span></span> <span class="hljs-string"><span class="hljs-string">"Hello world\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void __exit hello_end(void) { printk(<span class="hljs-type"><span class="hljs-type">KERN_INFO</span></span> <span class="hljs-string"><span class="hljs-string">"Goodbye world\n"</span></span>); } module_init(hello_start); module_exit(hello_end);</code> </pre><br>  Place the following text in the <code>Makefile</code> in the same directory: <br><br><pre> <code class="hljs">obj-m = hello.o</code> </pre><br>  Building the module is simple enough, but at this stage the module will not be able to load. <br><br><h1>  Module assembly </h1><br>  In a normal kernel build, the kernel build system creates the file <code>hello.mod.c</code> , the contents of which can create various problems: <br><br><pre> <code class="hljs lisp">MODULE_INFO(<span class="hljs-name"><span class="hljs-name">vermagic</span></span>, VERMAGIC_STRING)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  The value of <code>VERMAGIC_STRING</code> determined by the <code>VERMAGIC_STRING</code> macro, which is located in the <code>include/generated/utsrelease.h</code> generated by the kernel build system.  By default, this value is determined by the kernel version and git repository status.  This is what <code>KERNELRELEASE</code> when configuring the kernel.  If <code>VERMAGIC_STRING</code> does not match the kernel version, loading the module will result in a message of this kind in the <code>dmesg</code> : <br><br><pre> <code class="hljs pgsql">hello: <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> magic <span class="hljs-string"><span class="hljs-string">'3.0.21-perf-ge728813-00399-gd5fa0c9'</span></span> should be <span class="hljs-string"><span class="hljs-string">'3.0.8-perf'</span></span></code> </pre><br>  Further, we also have the definition of the module structure here: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> module __this_module __attribute__((section(<span class="hljs-string"><span class="hljs-string">".gnu.linkonce.this_module"</span></span>))) = { .name = KBUILD_MODNAME, .init = init_module, <span class="hljs-meta"><span class="hljs-meta">#ifdef CONFIG_MODULE_UNLOAD .exit = cleanup_module, #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> .arch = MODULE_ARCH_INIT, };</span></span></code> </pre><br>  By itself, this definition looks harmless, but the <code>struct module</code> structure defined in <code>include/linux/module.h</code> carries an unpleasant surprise: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class"> {</span></span> (...) <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_UNUSED_SYMBOLS (...) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> (...) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Startup function. */</span></span></span><span class="hljs-meta"> int (*init)(void); (...) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_GENERIC_BUG (...) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_KALLSYMS (...) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> (...) (... plenty more ifdefs ...) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_MODULE_UNLOAD (...) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Destruction function. */</span></span></span><span class="hljs-meta"> void (*exit)(void); (...) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> (...) }</span></span></code> </pre><br>  This means that in order for the <code>init</code> pointer to be in the right place, <code>CONFIG_UNUSED_SYMBOLS</code> must be defined in accordance with what our kernel image uses.  So what about the exit pointer, is <code>CONFIG_GENERIC_BUG</code> , <code>CONFIG_KALLSYMS</code> , <code>CONFIG_SMP</code> , <code>CONFIG_TRACEPOINTS</code> , <code>CONFIG_JUMP_LABEL</code> , <code>CONFIG_TRACING</code> , <code>CONFIG_EVENT_TRACING</code> , <code>CONFIG_FTRACE_MCOUNT_RECORD</code> , <code>CONFIG_TRACEPOINTS</code> , <code>CONFIG_JUMP_LABEL</code> , <code>CONFIG_TRACING</code> , <code>CONFIG_EVENT_TRACING</code> , <code>CONFIG_FTRACE_MCOUNT_RECORD</code> <br><br>  You begin to understand why it is usually supposed to use exactly the same header files with which our kernel was compiled? <br><br>  Next, define character versions: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modversion_info</span></span></span></span> ____versions[] __used __attribute__((section(<span class="hljs-string"><span class="hljs-string">"__versions"</span></span>))) = { { <span class="hljs-number"><span class="hljs-number">0</span></span>xsomehex, <span class="hljs-string"><span class="hljs-string">"module_layout"</span></span> }, { <span class="hljs-number"><span class="hljs-number">0</span></span>xsomehex, <span class="hljs-string"><span class="hljs-string">"__aeabi_unwind_cpp_pr0"</span></span> }, { <span class="hljs-number"><span class="hljs-number">0</span></span>xsomehex, <span class="hljs-string"><span class="hljs-string">"printk"</span></span> }, };</code> </pre><br>  These definitions are taken from the <code>Module.symvers</code> file, which is generated in accordance with the header files. <br><br>  Each such record represents the character required by the module, and which signature should have the character.  The first character, <code>module_layout</code> , depends on what the <code>struct module</code> looks like, that is, it depends on which configuration options mentioned earlier are enabled.  The second, <code>__aeabi_unwind_cpp_pr0</code> , is a function specific to ABI ARM, and the last is for our calls to the <code>printk</code> function. <br><br>  The signature of each character may differ depending on the kernel code for this function and the compiler used to build the kernel.  This means that if you build a kernel from source, as well as modules for a given kernel, and then rebuild a kernel after modifying, for example, the <code>printk</code> function, even in a compatible way, the modules that were built initially will not boot with the new kernel. <br><br>  So, if we build a kernel with sources and configurations that are close enough to those with which the existing kernel image was built, there is a chance that we will not get the same signatures as in our kernel image, and it cursed while loading the module: <br><br><pre> <code class="hljs pgsql">hello: disagrees about <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> symbol symbol_name</code> </pre><br>  Which means that we need the correct, appropriate kernel image, the <code>Module.symvers</code> file, which we don‚Äôt have. <br><br><h1>  Studying the core </h1><br>  Because the kernel does these checks when loading modules, it also contains a list of characters that it exports and the corresponding signatures.  When a kernel loads a module, it goes through all the characters that the module requires in order to find them in its symbol table (or other module symbol tables that the module uses) and check the corresponding signatures. <br><br>  The kernel uses the following function to search in its symbol table (in kernel / module.c): <br><br><pre> <code class="hljs rust"><span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> each_symbol_section(<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> (*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">)</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">symsearch</span></span></span></span> *arr, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span></span> *owner, void *data), void *data) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mod</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">symsearch</span></span></span></span> arr[] = { { __start___ksymtab, __stop___ksymtab, __start___kcrctab, NOT_GPL_ONLY, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, { __start___ksymtab_gpl, __stop___ksymtab_gpl, __start___kcrctab_gpl, GPL_ONLY, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, { __start___ksymtab_gpl_future, __stop___ksymtab_gpl_future, __start___kcrctab_gpl_future, WILL_BE_GPL_ONLY, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, #ifdef CONFIG_UNUSED_SYMBOLS { __start___ksymtab_unused, __stop___ksymtab_unused, __start___kcrctab_unused, NOT_GPL_ONLY, <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, { __start___ksymtab_unused_gpl, __stop___ksymtab_unused_gpl, __start___kcrctab_unused_gpl, GPL_ONLY, <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, #endif }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (each_symbol_in_section(arr, ARRAY_SIZE(arr), NULL, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-function">)) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">true</span></span></span><span class="hljs-function">; </span></span>(...)</code> </pre><br>  The structure used in this function is defined in include / linux / module.h: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">symsearch</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_symbol</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *crcs; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { NOT_GPL_ONLY, GPL_ONLY, WILL_BE_GPL_ONLY, } licence; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> unused; };</code> </pre><br>  Note: this kernel code has not changed significantly over the past four years (apparently, since the release of the kernel 3.0 being considered, - approx. Lane). <br><br>  What we have above in the <code>each_symbol_section</code> function is three (or five, when the <code>CONFIG_UNUSED_SYMBOLS</code> config <code>CONFIG_UNUSED_SYMBOLS</code> enabled) fields, each of which contains the beginning of the symbol table, its end, and two flags. <br><br>  These data are static and constant, which means that they will appear in the kernel binary as is.  By scanning the kernel for three successive sequences of three pointers in the address space of the kernel and following <code>integer</code> values ‚Äã‚Äãfrom the definitions in <code>each_symbol_section</code> , we can determine the location of the symbol tables and signatures, and recreate the Module.symvers file from the kernel binary. <br><br>  Unfortunately, most kernels are compressed today ( <code>zImage</code> ), so a simple search for a compressed image is impossible.  A compressed core actually represents a small binary, followed by a compressed stream.  You can scan the <code>zImage</code> file in order to find the compressed stream and get an unpacked image from it. <br><br>  I wrote a script for <a href="https://github.com/glandium/extract-symvers">decompression and extraction of information about the kernel symbols in automatic mode</a> .  This should work with any fresh version of the kernel, provided that the kernel is not relocatable and you know the base address in memory where it is loaded.  The script accepts options for the number and order of bits (endianness) of the architecture, and by default uses values ‚Äã‚Äãappropriate for ARM.  The base address, however, must be specified.  It can be found, on the ARM cores, in the <code>dmesg</code> : <br><br><pre> <code class="bash hljs">$ adb shell dmesg | grep <span class="hljs-string"><span class="hljs-string">"\.init"</span></span> &lt;5&gt;[01-01 00:00:00.000] [0: swapper] .init : 0xc0008000 - 0xc0037000 ( 188 kB)</code> </pre><br>  (note. Lane - however, not all kernels output this data to the log, I happened to meet one such practically unique case, when, apparently, due to reduced configuration options, this information was not output, in that case you can refer to the PAGE_OFFSET configuration in the <a href="https://github.com/torvalds/linux/blob/master/arch/arm/Kconfig">arch</a> file <a href="https://github.com/torvalds/linux/blob/master/arch/arm/Kconfig">/ arm / Kconfig</a> and just hope that the vendor used one of the defaults). <br><br>  The base address in the example above is <code>0xc0008000</code> . <br><br>  If, like me, you are interested in loading a module on an Android device, then the kernel binary you have is a full <b>boot</b> image.  The boot image contains other things besides the kernel, so you cannot directly use it with the script above.  The only exception is if the kernel in the <b>boot</b> image is compressed, and the part of the script that expects a compressed image at the entrance still finds the kernel. <br><br>  If the kernel is not compressed, you can use the unbootimg program as outlined in <a href="https://glandium.org/blog/%3Fp%3D2214">this post</a> in order to get a kernel image from your <b>boot</b> image.  Once you have a kernel image, the script can be run as follows: <br><br><pre> <code class="bash hljs">$ python extract-symvers.py -B 0xc0008000 kernel-filename &gt; Module.symvers</code> </pre><br><h1>  Kernel build </h1><br>  Now that we have the correct <code>Module.symvers</code> file for the kernel from which we want to load the module, we can finally assemble the module (again, assuming <code>arm-eabi-gcc</code> accessible from the <code>PATH</code> , and that the terminal is open in the source directory): <br><br><pre> <code class="bash hljs">$ cp /path/to/Module.symvers build/ $ make M=/path/to/module/<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> ARCH=arm CROSS_COMPILE=arm-eabi- O=build modules</code> </pre><br>  That's all.  You can copy the file hello.ko to the device and load the module: <br><br><pre> <code class="bash hljs">$ adb shell <span class="hljs-comment"><span class="hljs-comment"># insmod hello.ko # dmesg | grep insmod &lt;6&gt;[mm-dd hh:mm:ss.xxx] [id: insmod]Hello world # lsmod hello 586 0 - Live 0xbf008000 (P) # rmmod hello # dmesg | grep rmmod &lt;6&gt;[mm-dd hh:mm:ss.xxx] [id: rmmod]Goodbye world</span></span></code> </pre><br>  This article is a translation of a <a href="https://glandium.org/blog/%3Fp%3D2664">posting on the Mike Hommey blog</a> . </div><p>Source: <a href="https://habr.com/ru/post/331202/">https://habr.com/ru/post/331202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331188/index.html">Our experience with Kubernetes in small projects (review and video report)</a></li>
<li><a href="../331192/index.html">Introduction to the A * algorithm</a></li>
<li><a href="../331194/index.html">Competence does not have gender: on gender balance and the trend of development of female coding</a></li>
<li><a href="../331196/index.html">Self-sufficient controllers on Xamarin.Forms: "Re-use the code to the maximum!". Part 2</a></li>
<li><a href="../331200/index.html">Augmented Reality for state leaders</a></li>
<li><a href="../331204/index.html">Hackers steal money from banks more often than from their clients</a></li>
<li><a href="../331206/index.html">The API from Watson and what these tools can give to your service or application</a></li>
<li><a href="../331208/index.html">A fistful of relays. Part 4. System commands or what can fit in 8 machine instructions?</a></li>
<li><a href="../331210/index.html">Self-registration of the second factor for two-factor authentication based on the RADIUS protocol</a></li>
<li><a href="../331212/index.html">Development kit from analytics to outsourced artists</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>