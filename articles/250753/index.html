<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Linux works with memory. Yandex Workshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. My name is Vyacheslav Biryukov. In Yandex, I manage the search operation team. Recently, for the students of the Information Technology Courses o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Linux works with memory. Yandex Workshop</h1><div class="post__text post__text-html js-mediator-article">  Hey.  My name is Vyacheslav Biryukov.  In Yandex, I manage the search operation team.  Recently, for the students of the Information Technology Courses of Yandex, I gave a lecture on working with memory in Linux.  Why memory?  The main answer is: I like working with memory.  In addition, information about it is quite small, and the one that is, as a rule, is irrelevant, because this part of the Linux kernel changes quite quickly and does not have time to get into the books.  I will talk about the x86_64 architecture and about the Linux kernel version 2.6.32.  Most likely the kernel version is 3.x. <br><br><video>  http://video.yandex.ru/users/ya-events/view/3493/ </video><br><br>  This lecture will be useful not only for system administrators, but also for developers of high-load systems.  It will help them understand exactly how interaction with the operating system kernel occurs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Terms </h3><br>  <b>Resident memory</b> is the amount of memory that is now in the RAM of the server, computer, laptop. <br>  <b>Anonymous memory</b> is a memory excluding file cache and memory that has a file backend on disk. <br>  <b>Page fault</b> - memory trap.  Regular mechanism when working with virtual memory. <br><a name="habracut"></a><br><br><div class="error">  The presentation at http://www.slideshare.net/yandex/linux-44775898 is not available. </div><br><br><h3>  Memory pages </h3><br>  Work with memory is organized through pages.  The memory size is usually large, addressing is present, but the operating system and hardware are not very convenient to work with each of the addresses separately, therefore all memory is paginated.  Page size - 4 KB.  There are also pages of a different size: the so-called Huge Pages of 2 MB and pages of 1 GB in size (we will not talk about them today). <br><br>  <i>Virtual memory</i> is the address space of the process.  The process works not with physical memory directly, but with virtual memory.  Such an abstraction makes it easier to write application code, not to think that you can accidentally refer to the wrong memory addresses or addresses of another process.  This simplifies the development of applications, and also allows you to exceed the size of the main RAM through the mechanisms described below.  Virtual memory consists of main memory and a swap device.  That is, the amount of virtual memory can be in principle of unlimited size. <br><br>  To manage virtual memory in the system there is an option <code>overcommit</code> .  It ensures that we do not reuse memory size.  It is controlled via sysctl and can be in the following three values: <br><ul><li>  0 is the default value.  In this case, heuristics are used, which ensures that we are not able to allocate virtual memory in the process much more than is in the system; </li><li>  1 - says that we do not follow the amount of allocated memory.  This is useful, for example, in programs for calculations that allocate large data arrays and work with them in a special way; </li><li>  2 - a parameter that allows you to strictly limit the amount of virtual memory of the process. </li></ul><br>  You can see how much memory we have committed, how much is used and how much we can still allocate, in the <code>CommitLimit</code> and <code>Commited_AS</code> lines from the file <code>/proc/meminfo</code> . <br><br><h3>  Memory Zones and NUMA </h3><br>  In modern systems, all virtual memory is divided into <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> nodes.  Once we had computers with one processor and one memory bank (memory bank).  Such architecture was called <a href="http://en.wikipedia.org/wiki/Uniform_memory_access">UMA</a> (SMP).  Everything was very clear: one system bus for communication of all components.  Later it became inconvenient, began to limit the development of architecture, and, as a result, NUMA was invented. <br><br><img src="https://habrastorage.org/files/c00/672/1eb/c006721eb04a4f80a52b17a7c20ddca2.png"><br><br>  As you can see from the slide, we have two processors that communicate with each other via some channel, and each of them has its own buses, through which they communicate with their memory banks.  If we look at the picture, the delay from CPU 1 to RAM 1 in the NUMA node will be two times less than from CPU 1 to RAM 2. We can get this data and other information using the <code>numactl hardware</code> command. <br><br>  We see that the server has two nodes and information on them (how much free physical memory is in each node).  Memory is allocated on each node separately.  Therefore, you can consume all the free memory on one node, and the other - to underload.  To prevent this from happening (this is typical of databases), you can start the process with the numactl interleave = all command.  This allows you to distribute the allocation of memory between the two nodes evenly.  Otherwise, the kernel selects the node on which the scheduling process was scheduled to start and always tries to allocate memory on it. <br><br>  Also, the memory in the system is divided into Memory Zones.  Each NUMA node is divided into a number of such zones.  They serve to support a special iron that cannot communicate across the entire range of addresses.  For example, ZONE_DMA is 16 MB of the first addresses, ZONE_DMA32 is 4 GB.  We look at the memory zones and their status through the file <code>/proc/zoneinfo</code> . <br><br><h3>  Page cache </h3><br>  Through Page Cache in Linux, all read and write operations are by default.  It is of dynamic size, that is, it is he who will eat all your memory, if it is free.  As the old joke says, if you need free memory in the server, just pull it out of the server.  Page Cache divides all the files that we read into pages (the page, as we said, is 4 KB).  You can see if there are any pages of a particular file in Page Cache using the <code>mincore()</code> system call.  Or using the <a href="http://hoytech.com/vmtouch/">vmtouch</a> utility, which is written using this system call. <br><br>  How does the recording go?  Any recording does not happen on the disk immediately, but in Page Cache, and this is done almost instantly.  Here you can see an interesting "anomaly": writing to disk is much faster than reading.  The fact is that when reading (if there is no given file page in Page Cache) we will go to the disk and wait synchronously for a response, and the record in turn will go instantly to the cache. <br><br>  The downside of this behavior is that in fact the data is not recorded anywhere - they are simply in memory, and sometime they will need to be flushed to disk.  At each page at record the flag is put down (it is called dirty).  Such a ‚Äúdirty‚Äù page appears in Page Cache.  If many such pages are accumulated, the system understands that it is time to drop them onto a disk, otherwise you can lose them (if power is suddenly lost, our data will also be lost). <br><br><h3>  Process memory </h3><br>  The process consists of the following segments.  We have a stack that grows down;  He has a limit on which he can not grow. <br><br><img src="https://habrastorage.org/files/993/389/576/993389576e9c4f66b36cc7bf49cc0203.png"><br><br>  Then comes the mmap region: there are all the process-mapped process files that we opened or created using the <code>mmap()</code> system call.  Next comes a large amount of unallocated virtual memory that we can use.  From the bottom upwards, the heap grows - this is an area of ‚Äã‚Äãanonymous memory.  Below are the areas of the binary that we run. <br><br>  If we are talking about memory inside a process, then working with pages is also inconvenient: as a rule, memory allocation within a process occurs in blocks.  Very rarely you need to select one or two pages, usually you need to select at once some interval of pages.  Therefore, in Linux there is such a thing as a virtual memory area (VMA), which describes some kind of address space inside the virtual address space of this process.  Each such VMA has its own rights (read, write, execute) and scope: it can be private or shared (which is ‚Äúfiddling (share)‚Äù with other processes in the system). <br><br><h3>  Memory allocation </h3><br>  Memory allocation can be divided into four cases: there is an allocation of private memory and memory, which we can share with someone (share);  The two other categories are the division into anonymous memory and the one that is associated with the file on the disk.  The most common memory allocation functions are malloc and free.  If we are talking about <code>glibc malloc()</code> , then it allocates anonymous memory in such an interesting way: it uses heap to allocate small volumes (less than 128 KB) and <code>mmap()</code> for large volumes.  This allocation is necessary so that the memory is spent more optimally and it can easily be given to the system.  If there is not enough memory in the heap to allocate, the system call <code>brk()</code> called, which expands the heap.  The <code>mmap()</code> system call is responsible for mapping the contents of a file to the address space.  <code>munmap()</code> in turn frees the mapping.  <code>mmap()</code> has flags that control the visibility of changes and the level of access. <br><br><img src="https://habrastorage.org/files/15f/234/c2a/15f234c2a750468e91f10b0da5ea671f.png"><br><br>  In fact, Linux does not allocate all the requested memory at once.  The process of allocating memory ‚Äî Demand Paging ‚Äî begins with what we request from the system core a memory page, and it falls into the Only Allocated area.  The kernel responds to the process: here is your memory page, you can use it.  And nothing else happens.  No physical allocation occurs.  And it will happen only if we try to make an entry on this page.  At this moment, the call will go to the Page Table - this structure translates the virtual addresses of the process into the physical addresses of the RAM.  Two blocks will also be involved: MMU and TLB, as can be seen from the figure.  They allow you to speed up the allocation and serve to translate virtual addresses into physical ones. <br><br><img src="https://habrastorage.org/files/92c/530/148/92c530148ad846f0aab3af3975ce2494.png"><br><br>  After we understand that this page in the Page Table does not correspond to anything, that is, there is no connection with the physical memory, we get Page Fault - in this case, minor (minor), since there is no access to the disk.  After this process, the system can write to the allocated memory page.  For the process, all this happens transparently.  And we can observe an increase in the counter of the minor Page Fault for the process by one unit.  There is also a major Page Fault - in the case when the disk is accessed for the contents of the page (in the case of <code>mmpa()</code> ). <br><br>  One of the Linux memory tricks ‚Äî Copy On Write ‚Äî allows you to do very fast fork processes. <br><br><h3>  Work with files and memory </h3><br>  The memory subsystem and the file subsystem are closely related.  Since working with the disk directly is very slow, the kernel uses RAM as a layer. <br><br>  <code>malloc()</code> uses more memory: copying to user space.  Also, more CPU is consumed, and we get more context switches than if we worked with the file via <code>mmap()</code> . <br><br>  What conclusions can be made?  We can work with files as with memory.  We have a lazy loading, that is, we can zapapit a very, very large file, and it will be loaded into the process memory via Page Cache only as needed.  Everything also happens faster because we use fewer system calls and, in the end, it saves memory.  It is also worth noting that at the end of the program the memory does not disappear anywhere and remains in Page Cache. <br><br>  In the beginning it was said that all the writing and reading go through Page Cache, but sometimes for some reason, there is a need to deviate from this behavior.  Some software products work in this way, for example, MySQL with InnoDB. <br><br>  We can tell the kernel that in the near future we will not work with this file, and we can force you to unload the file pages from Page Cache using special system calls: <br><ul><li>  posix_fadvide (); </li><li>  madvise (); </li><li>  mincore (). </li></ul><br>  The vmtouch utility can also extract file pages from Page Cache - the ‚Äúe‚Äù key. <br><br><h3>  Readahead </h3><br>  Let's talk about Readahead.  If we read the files from the disk via Page Cache every page one by one, then we will have quite a lot of Page Fault and we will often go to disk for data.  Therefore, we can control the size of Readahead: if we read the first and second pages, the kernel realizes that, most likely, we need a third one.  And since it is expensive to walk on the disk, we can read a little more in advance by loading the file in advance into Page Cache and responding in the future from it.  This way, the replacement of future heavy major page faults with the minor (minor) page fault. <br><br>  So we gave everyone a memory, all the processes are satisfied, and suddenly our memory is over.  Now we need to somehow release it.  The process of searching and allocating free memory in the kernel is called Page Reclaiming.  In memory, there may be memory pages that cannot be retrieved - locked pages (locked).  Besides them there are four more categories of pages.  Kernel pages that should not be unloaded, because it will slow down the entire system;  The Swappable pages are such pages of anonymous memory that can not be unloaded anywhere except in the swap device;  Syncable Pages - those that can be synchronized with the disk, and in the case of an open file only for reading - such pages can be easily removed from memory;  and Discardable Pages are those pages that you can simply refuse. <br><br><h3>  Sources of replenishment Free List </h3><br>  To put it simply, the kernel has one large Free List (in fact, it is not) in which memory pages are stored that can be issued to processes.  The kernel tries to maintain the size of this list in some non-zero state in order to quickly allocate memory to processes.  This list is replenished by four sources: Page Cache, Swap, Kernel Memory and OOM Killer. <br><br>  We must distinguish between hot and cold areas of the memory and somehow replenish our Free Lists with them.  Page Cache is based on the LRU / 2 queue principle.  There is an active list of pages (Active List) and an inactive list (Inactive List) of pages between which there is some connection.  Allocation requests are arriving in the Free List.  The system gives pages from the head of this list, and the pages from the tail of the inactive list fall into the tail of the list.  New pages, when we read a file through Page Cache, always get into the head and go to the end of the inactive list, if these pages did not have at least one more appeal.  If such treatment was in any place of the inactive list, then the pages immediately fall into the head of the active list and begin to move towards its tail.  If at this moment again they are addressed, then the pages again make their way to the top of the list.  Thus, the system tries to balance the lists: the hottest data is always in Page Cache in the active list, and the Free List is never replenished at their expense. <br><br>  Also here it is worth noting an interesting behavior: pages that fill up the Free List, which in turn arrive from the inactive list, but have not yet been allocated for allocation, can be returned back to the inactive list (in this case, to the head of the inactive list) . <br><br>  In total, we get five such sheets: Active Anon, Inactive Anon, Active File, Inactive File, Unevictable.  Such lists are created for each NUMA node and for each Memory Zone. <br><br><h3>  A few words about cgroups </h3><br>  With the help of <a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a> we can limit several processes by any parameters.  In this case, we are interested in memory: we can limit memory without swap, and we can limit memory and swap.  For each group, we can tie our own Out Of Memory Killer.  Using cgroups, you can conveniently get memory statistics for a process or group of processes in terms of anonymous and non-anonymous memory, use of Page Cache and others (/sys/fs/cgroup/memory/memory.stat).  When using cgroups with memory limitation, Page Reclaiming is of two kinds: <br><ul><li>  Global Reclaiming, when we are looking for memory for the whole system - we replenish the Free Lists system; </li><li>  Target Reclaiming, when we release the memory in one of the cgroup - in case of lack of memory in it. </li></ul><br>  <b>Books</b> <br>  For those who want to take a closer look at the device and the work of Linux with memory, I recommend reading: <br><ul><li>  SystemsPerformance: Enterprise and the Cloud; </li><li>  Linux System Programming: Talking Directly to the Kernel and C Library; </li><li>  Linux Kernel Development (3rd Edition). </li></ul></div><p>Source: <a href="https://habr.com/ru/post/250753/">https://habr.com/ru/post/250753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250733/index.html">Introducing the Realtek RTL8954C debug card</a></li>
<li><a href="../250735/index.html">What DDoS protection services do not negotiate or why protection does not work</a></li>
<li><a href="../250743/index.html">Weekly assembly Vivaldi 1.0.105.7</a></li>
<li><a href="../250745/index.html">The story of one failure (the development of the first mobile game) with conclusions and tips</a></li>
<li><a href="../250749/index.html">Where do the security gaps come from?</a></li>
<li><a href="../250755/index.html">Configure autoscaling in InfoboxCloud</a></li>
<li><a href="../250757/index.html">5 invalid errors when collecting product reviews</a></li>
<li><a href="../250759/index.html">Interesting moments of work Linq to Sql</a></li>
<li><a href="../250761/index.html">Brakes ng-repeat? No - just ngAnimate + transition to css</a></li>
<li><a href="../250763/index.html">Analysis of the problem ‚ÄúMirror in the corridor‚Äù and outrage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>