<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ Inheritance: beginner, intermediate, advanced</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, inheritance is described at three levels: beginner, intermediate and advanced. Expert no. And not a word about SOLID. Fair. 
 Beginne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ Inheritance: beginner, intermediate, advanced</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, inheritance is described at three levels: beginner, intermediate and advanced.  Expert no.  And not a word about SOLID.  Fair. </p><br><h1 id="beginner">  Beginner </h1><br><h3 id="chto-takoe-nasledovanie">  What is inheritance? </h3><br><p>  Inheritance is one of the fundamental principles of OOP.  According to it, a class can use variables and methods of another class as its own. </p><br><p>  A class that inherits data is called a subclass (subclass), derived class, or child class (child).  A class from which data or methods are inherited is called a super class, a base class, or a parent.  The terms ‚Äúparent‚Äù and ‚Äúchild‚Äù are extremely useful for understanding inheritance.  As the child receives the characteristics of its parents, the derived class receives the methods and variables of the base class. </p><br><p>  Inheritance is useful because it allows you to structure and reuse code, which, in turn, <a name="habracut"></a>  can significantly speed up the development process.  Despite this, inheritance should be used with caution, since most changes in the superclass will affect all subclasses, which can lead to unintended consequences. </p><br><p> In this example, the <code>turn_on()</code> method and the <code>serial_number</code> variable <code>serial_number</code> not declared or defined in the <code>Computer</code> subclass.  However, they can be used because they are inherited from the base class. </p><br><p>  <em>Important note</em> : private variables and methods cannot be inherited. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Types of inheritance </h3><br><p>  There are several types of inheritance in C ++: </p><br><ul><li>  public ( <code>public</code> ) - public ( <code>public</code> ) and protected ( <code>protected</code> ) data is inherited without changing the level of access to them; </li><li>  protected ( <code>protected</code> ) - all inherited data becomes protected; </li><li>  private ( <code>private</code> ) - all inherited data becomes private. </li></ul><br><p>  For the base class <code>Device</code> , the data access level does not change, but since the derived <code>Computer</code> class inherits the data as private, the data becomes private for the <code>Computer</code> class. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  The <code>Computer</code> class now uses the <code>turn_on()</code> method like any private method: <code>turn_on()</code> can be called from within the class, but an attempt to call it directly from <code>main</code> will result in an error during compilation.  For the base class <code>Device</code> , the <code>turn_on()</code> method <code>turn_on()</code> remained public, and can be called from <code>main</code> . </p><br><h3 id="konstruktory-i-destruktory">  Constructors and destructors </h3><br><p>  In C ++, constructors and destructors are not inherited.  However, they are called when the child class initializes its object.  Constructors are called one after the other hierarchically, starting with the base class and ending with the last derived class.  Destructors are called in reverse order. </p><br><p>  <em>Important note:</em> this article does not cover virtual desktops.  Additional material on this topic can be found for example <a href="https://habr.com/ru/post/64280/">in this article on Habr√©</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Constructors: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Destroyers: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  Multiple inheritance </h3><br><p>  Multiple inheritance occurs when a subclass has two or more superclasses.  In this example, the <code>Laptop</code> class inherits both <code>Monitor</code> and <code>Computer</code> at the same time. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  Multiple Inheritance Issues </h3><br><p>  Multiple inheritance requires careful design, as it can lead to unintended consequences.  Most of these effects are caused by ambiguity in inheritance.  In this example, the <code>Laptop</code> inherits the <code>turn_on()</code> method from both parents and it is unclear which method should be called. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  In spite of the fact that private data is not inherited, it is impossible to allow ambiguous inheritance by changing the level of access to data to private data.  When compiling, first a search for a method or a variable occurs, and afterwards - checking the level of access to them. </p><br><h1 id="intermediate">  Intermediate </h1><br><h3 id="problema-romba">  Diamond problem </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  Diamond problem is a classic problem in languages ‚Äã‚Äãthat support the possibility of multiple inheritance.  This problem occurs when classes <code>B</code> and <code>C</code> inherit <code>A</code> , and class <code>D</code> inherits <code>B</code> and <code>C</code> </p><br><p>  For example, classes <code>A</code> , <code>B</code> and <code>C</code> define the <code>print_letter()</code> method.  If <code>print_letter()</code> will be called by class <code>D</code> , it is unclear which method should be called ‚Äî a method of class <code>A</code> , <code>B</code> or <code>C</code>  Different languages ‚Äã‚Äãhave different approaches to solving diamond-shaped problems.  In C ++, the solution to the problem is left to the discretion of the programmer. <br><br clear="all">  A diamond-shaped problem is primarily a design problem, and it should be provided at the design stage.  At the design stage, it can be resolved as follows: </p><br><ul><li>  call the method of a particular superclass; </li><li>  refer to the object of a subclass as an object of a particular superclass; </li><li>  override the problematic method in the last child class (in the code, <code>turn_on()</code> in the <code>Laptop</code> subclass). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  If the <code>turn_on()</code> method was not redefined in the Laptop, calling <code>Laptop_instance.turn_on()</code> will result in a compile error.  A <code>Laptop</code> object can access two <code>turn_on()</code> method <code>turn_on()</code> at the same time: <code>Device:Computer:Laptop.turn_on()</code> and <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  The diamond problem: Constructors and destructors </h3><br><p>  Since in C ++, when initializing an object of a child class, the constructors of all parent classes are called, another problem arises: the constructor of the base class <code>Device</code> will be called twice. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  Virtual inheritance </h3><br><p>  Virtual inheritance prevents the appearance of multiple base class objects in the inheritance hierarchy.  Thus, the constructor of the base class <code>Device</code> will be called only once, and calling the <code>turn_on()</code> method without redefining it in the child class will not cause a compilation error. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Note</em> : Virtual inheritance in the <code>Computer</code> and <code>Monitor</code> classes will not allow diamond-shaped inheritance if the child class of the <code>Laptop</code> class <code>Device</code> from the <code>Device</code> class is not virtual ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Abstract class </h3><br><p>  In C ++, a class in which there exists at least one pure virtual method (pure virtual) is considered to be abstract.  If the virtual method is not overridden in the child class, the code will not compile.  Also, it is impossible to create an abstract class object in C ++ - an attempt will also cause an error during compilation. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Interface </h3><br><p>  C ++, unlike some OOP languages, does not provide a separate keyword for the interface.  However, the implementation of the interface is possible by creating a pure abstract class (pure abstract class) - a class in which only method declarations are present.  Such classes are also often called abstract base classes (Abstract Base Class - ABC). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Advanced </h1><br><p>  Although inheritance is a fundamental principle of OOP, it should be used with caution.  It is important to think that any code that will be used is likely to be changed and can be used in a way that is not obvious to the developer. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  Inheritance from implemented or partially implemented class </h3><br><p>  If inheritance does not occur from the interface (a pure abstract class in the context of C ++), but from a class in which there are any implementations, it is worth considering that the class of the heir is associated with the parent class of the closest possible connection.  Most changes in the parent's class can affect the heir, which can lead to unexpected behavior.  Such changes in the behavior of the heir are not always obvious - an error may occur in the already tested and working code.  This situation is exacerbated by the presence of a complex class hierarchy.  It is always worth remembering that the code can be changed not only by the person who wrote it, and the paths of inheritance that are obvious to the author may not be taken into account by his colleagues. </p><br><p>  In contrast, it is worth noting that inheritance from partially implemented classes has an undeniable advantage.  Libraries and frameworks often work like this: they provide the user with an abstract class with several virtual and many implemented methods.  Thus, the greatest amount of work has already been done - complex logic has already been written, and the user needs only to customize the ready-made solution to fit his needs. </p><br><h3 id="interfeys-1">  Interface </h3><br><p>  Inheritance from the interface (pure abstract class) presents inheritance as the possibility of structuring code and protecting the user.  Since the interface describes what work will be done by the implementation class, but does not describe how, any user of the interface is protected from changes in the class that implements this interface. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Interface: usage example </h3><br><p>  First of all, it is worth noting that the example is closely related to the concept of polymorphism, but will be considered in the context of inheritance from a pure abstract class. </p><br><p>  An application running abstract business logic must be configured from a separate configuration file.  At an early stage of development, the formatting of this configuration file was not fully formed.  Taking out file parsing for an interface provides several advantages. </p><br><p>  The lack of unambiguity regarding the formatting of the configuration file does not slow down the process of developing the main program.  Two developers can work in parallel - one on business logic, and the other on the parser.  Since they interact through this interface, each of them can work independently.  This approach makes it easier to cover the code with unit tests, since the necessary tests can be written using the mock for this interface. </p><br><p>  Also, when changing the format of the configuration file, the business logic of the application is not affected.  The only thing that requires a complete transition from one formatting to another is to write a new implementation of an already existing abstract class (parser class).  In the future, returning to the original file format requires minimal work - replacing one already existing parser with another. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Inheritance offers many benefits, but must be carefully designed to avoid problems for which it opens up.  In the context of inheritance, C ++ provides a wide range of tools that opens up a lot of opportunities for the programmer. </p><br><p>  And SOLID is good. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/445948/">https://habr.com/ru/post/445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445928/index.html">How we increased Tensorflow Serving performance by 70%</a></li>
<li><a href="../445932/index.html">Client application security: practical tips for Front-end developer</a></li>
<li><a href="../445936/index.html">Electronics development. About microcontrollers on fingers</a></li>
<li><a href="../445940/index.html">AMA with Habr, v 7.0. Lemon, Donates and News</a></li>
<li><a href="../445946/index.html">MWC: instructions for use</a></li>
<li><a href="../445952/index.html">Trillion Little Shingles</a></li>
<li><a href="../445954/index.html">AI accelerator from HSE, MTS and Rostelecom</a></li>
<li><a href="../445958/index.html">SPDS GraphiCS - facade and roofing system</a></li>
<li><a href="../445962/index.html">Internship in IT: manager's point of view</a></li>
<li><a href="../445964/index.html">A student information security Olympiad will take place at MEPI: how to participate and what does it give</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>