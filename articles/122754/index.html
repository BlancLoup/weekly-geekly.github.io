<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C parallel network computing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, habrazhiteli! Recently, I had to write a program for parallel computation of a definite integral. Naturally, after finishing work, some expe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C parallel network computing</h1><div class="post__text post__text-html js-mediator-article">  Good day, habrazhiteli!  Recently, I had to write a program for parallel computation of a definite integral.  Naturally, after finishing work, some experience was acquired, and I would like to share this experience with you.  I‚Äôll say at once that within the framework of this article I will not consider parsing an integrable function, but I‚Äôll focus on the interaction between threads and computers. <br><br><h4>  Formulation of the problem </h4><br>  Of course, before you start writing code you need to set yourself a task correctly, the requirements for the program were as follows: <br><ul><li>  Calculations must be performed on several machines in parallel (within the local network) </li><li>  Calculations must be multithreaded </li><li>  Access to computers on which calculations are made, non-permanent </li></ul><br><a name="habracut"></a><br>  That is, it is necessary to write a program that would run on several computers (apparently on workstations) and waited for instructions to calculate the integral, then read it and send the result back to the one who asked to count. <br><br>  Since we have to deal with the network, we choose a probabilistic method for calculating the integral, we will use <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%259C%25D0%25BE%25D0%25BD%25D1%2582%25D0%25B5-%25D0%259A%25D0%25B0%25D1%2580%25D0%25BB%25D0%25BE">the Monte Carlo method</a> .  It is easily parallelized, two ways are obvious: <br><ul><li>  By segments, that is, each calculator generates n points on a certain segment </li><li>  By the number of generated points, that is, each calculator generates n / (number of calculators) points on the whole integration segment </li></ul><br>  I will choose the second method, without particularly citing anything, I simply will not have to transfer the beginning and end of their segments to the calculators. <br>  So, we need a server (calculator) that will wait for the task, read it and return the result.  And we also need a client with whom the user will interact. <br>  How to find a server for computing?  Knowing all IPs by heart or writing them down somewhere is not the best option, considering that the IP addresses of the servers are dynamic, plus they may consider another task at the moment or simply be offline.  The solution is simple; we will use a broadcast request to find the currently available servers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second problem is which transport to use to exchange information?  For the broadcast request, obviously we will use UDP.  But for the interaction between the client and the server, you can use both UDP and TCP.  But there will be fewer problems with TCP, since we will not have to check the status of the connection.  If the socket closes on the other hand, the OS itself will detect this and let us know. <br><br>  The final interaction is as follows: the server waits for a connection on a TCP socket and simultaneously responds to broadcast requests, indicating its presence to clients.  As soon as the client has connected and has given the task - we suspend the answers to the broadcast requests, we calculate, we answer the client, we start the cycle again.  The client is the same: sends a request, forms a list of servers, shares a task between them, gets the results and displays them to the user. <br><br><h4>  Server </h4><br>  Let's write the server first.  First of all, we will agree on which port we will wait for requests from clients, let it be the port - number 38199. Then we will declare the structure for the client to send the job to the server. <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#define</font> RCVPORT 38199 <br> <font color="#0000ff">#define</font> FUNC(x) x*x <font color="#008000">//        x^2</font> <br> <font color="#008000">//     </font> <br> typedef <font color="#0000ff">struct</font> { <br> <font color="#0000ff">int</font> limits; <br> <font color="#0000ff">int</font> numoftry; <br> } task_data_t;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  As can be seen from the code above, the client will send the server the upper limit of integration and the number of attempts that he must make. <br><br>  It is clear that we will do the calculations in several streams, so we will create an argument and a structure for the calculator threads: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//    </font> <br> typedef <font color="#0000ff">struct</font> { <br> <font color="#0000ff">int</font> limits; <font color="#008000">//  </font> <br> <font color="#0000ff">long</font> numoftry; <font color="#008000">//      </font> <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> *results; <font color="#008000">//   </font> <br> } thread_args_t; <br> <br> <font color="#008000">//   </font> <br> <font color="#0000ff">void</font> *calculate( <font color="#0000ff">void</font> *arg) { <br> <font color="#008000">//        thread_args_t</font> <br> thread_args_t *tinfo = (thread_args_t*) arg; <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> result = 0; <br> <font color="#0000ff">int</font> xlim = tinfo-&gt;limits; <br> <font color="#0000ff">int</font> trys = tinfo-&gt;numoftry; <br> unsigned a = xlim; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; trys; ++i) { <br> <font color="#0000ff">int</font> div = rand_r(&amp;a); <br> <font color="#0000ff">int</font> div2 = rand_r(&amp;a); <br> <font color="#0000ff">double</font> x = div % xlim + (div2/(div2*1.0 + div*1.0)) ; <br> result += FUNC(x); <br> } <br> *(tinfo-&gt;results) = result; <br> <font color="#0000ff">return</font> NULL; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  I draw attention to the fact that the <b>rand_r</b> function is <b>used (unsigned int * seedp)</b> .  Because this function uses a local variable to store the intermediate value between calls.  We cannot allow the use of a global variable for all threads, as will be the case when using the <b>rand ()</b> function, as this will cause their mutual blocking. <br><br>  After running all computational threads, the main thread will hang on the <b>pthread_join ()</b> function and will not be able to do anything if the client dies during the calculations to avoid empty calculations, run another thread that will check the client status. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//     </font> <br> typedef <font color="#0000ff">struct</font> { <br> <font color="#0000ff">int</font> sock; <font color="#008000">//   </font> <br> pthread_t *calcthreads; <font color="#008000">//       </font> <br> <font color="#0000ff">int</font> threadnum; <font color="#008000">//   </font> <br> } checker_args_t; <br> <br> <font color="#008000">//        SIGUSR1</font> <br> <font color="#0000ff">void</font> thread_cancel( <font color="#0000ff">int</font> signo) { <br> pthread_exit(PTHREAD_CANCELED); <br> } <br> <br> <font color="#008000">//    </font> <br> <font color="#0000ff">void</font> *client_check( <font color="#0000ff">void</font> *arg) { <br> <font color="#008000">//       checker_args_t</font> <br> checker_args_t *args = (checker_args_t*) arg; <br> <font color="#0000ff">char</font> a[10]; <br> recv(args-&gt;sock, &amp;a, 10, 0); <font color="#008000">//     TCP,      </font> <br> <font color="#008000">// ,  recv       -1</font> <br> <font color="#0000ff">int</font> st; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; args-&gt;threadnum; ++i) <br> st = pthread_kill(args-&gt;calcthreads[i], SIGUSR1); <font color="#008000">//    SIGUSR1</font> <br> <font color="#0000ff">return</font> NULL; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  For compulsory completion of computing threads, I decided to use signals, since no memory is allocated as a result of their work, there is nothing to fear.  Although using the <b>pthread_cancel ()</b> function and the <b>pthread_cleanup_push ()</b> and <b>pthread_cleanup_pop ()</b> macros would be more appropriate.  Of course, the <b>thread_cancel ()</b> function is written which will be executed when the signal is received.  And remember that at the beginning of the program, before starting threads, you need to set the correct mask for signal processing, otherwise we risk just leaving the program. <br><br>  Now let's write a thread that will respond to broadcast requests.  So that the main thread could easily hang, waiting for the client, and our additional thread would respond to requests at that moment. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> *listen_broadcast( <font color="#0000ff">void</font> *arg) { <br> <font color="#0000ff">int</font> *isbusy = arg; <br> <font color="#008000">//      broadcast</font> <br> <font color="#0000ff">int</font> sockbrcast = socket(PF_INET, SOCK_DGRAM, 0); <br> <font color="#0000ff">if</font> (sockbrcast == -1) { <br> perror( <font color="#A31515">"Create broadcast socket failed"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#008000">//       broadcast</font> <br> <font color="#0000ff">int</font> port_rcv = RCVPORT; <br> <font color="#0000ff">struct</font> sockaddr_in addrbrcast_rcv; <br> bzero(&amp;addrbrcast_rcv, <font color="#0000ff">sizeof</font> (addrbrcast_rcv)); <br> addrbrcast_rcv.sin_family = AF_INET; <br> addrbrcast_rcv.sin_addr.s_addr = htonl(INADDR_ANY); <br> addrbrcast_rcv.sin_port = htons(port_rcv); <br> <font color="#008000">//  </font> <br> <font color="#0000ff">if</font> (bind(sockbrcast, ( <font color="#0000ff">struct</font> sockaddr *) &amp;addrbrcast_rcv, <br> <font color="#0000ff">sizeof</font> (addrbrcast_rcv)) &lt; 0) { <br> perror( <font color="#A31515">"Bind broadcast socket failed"</font> ); <br> close(sockbrcast); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#0000ff">int</font> msgsize = <font color="#0000ff">sizeof</font> ( <font color="#0000ff">char</font> ) * 18; <br> <font color="#0000ff">char</font> hellomesg[18]; <br> bzero(hellomesg, msgsize); <br> <font color="#008000">//    broadcast' </font> <br> <font color="#008000">fcntl(sockbrcast, F_SETFL, O_NONBLOCK);</font> <br> <br> <font color="#008000">//   </font> <br> fd_set readset; <br> FD_ZERO(&amp;readset); <br> FD_SET(sockbrcast, &amp;readset); <br> <br> <font color="#008000">// </font> <br> <font color="#0000ff">struct</font> timeval timeout; <br> timeout.tv_sec = 3; <br> timeout.tv_usec = 0; <br> <br> <font color="#0000ff">struct</font> sockaddr_in client;; <br> bzero(&amp;client, <font color="#0000ff">sizeof</font> (client)); <br> socklen_t servaddrlen = <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in); <br> <font color="#0000ff">char</font> helloanswer[18]; <br> bzero(helloanswer, msgsize); <br> strcpy(helloanswer, <font color="#A31515">"Hello Client"</font> ); <br> <font color="#0000ff">int</font> sockst = 1; <br> <font color="#0000ff">while</font> (sockst &gt; 0) { <br> sockst = <font color="#0000ff">select</font> (sockbrcast + 1, &amp;readset, NULL, &amp;readset, NULL); <br> <font color="#0000ff">if</font> (sockst == -1) { <br> perror( <font color="#A31515">"Broblems on broadcast socket"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <font color="#0000ff">int</font> rdbyte = recvfrom(sockbrcast, ( <font color="#0000ff">void</font> *) hellomesg, msgsize,MSG_TRUNC, <br> ( <font color="#0000ff">struct</font> sockaddr*) &amp;client, <br> &amp;servaddrlen); <br> <font color="#0000ff">if</font> (rdbyte == msgsize &amp;&amp; strcmp(hellomesg, <font color="#A31515">"Hello Integral"</font> ) == 0 &amp;&amp; <br> *isbusy == 0) { <br> <font color="#0000ff">if</font> (sendto(sockbrcast, helloanswer, msgsize, 0, <br> ( <font color="#0000ff">struct</font> sockaddr*) &amp;client, <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in)) &lt; 0) { <br> perror( <font color="#A31515">"Sending answer"</font> ); <br> close(sockbrcast); <br> exit(EXIT_FAILURE); <br> } <br> } <br> FD_ZERO(&amp;readset); <br> FD_SET(sockbrcast, &amp;readset); <br> } <br> <font color="#0000ff">return</font> NULL; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Everything is simple, create a socket and wait for requests.  As a request received - respond to it.  And one complication, whether to respond to a request or not, is decided by the value of the isbusy variable. <br><br>  Finally got to the main'a: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> ** argv) { <br> <font color="#008000">//      -  - </font> <br> <font color="#0000ff">if</font> (argc &gt; 2) { <br> fprintf(stderr, <font color="#A31515">"Usage: %s [numofcpus]\n"</font> , argv[0]); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#0000ff">int</font> numofthread; <br> <br> <font color="#0000ff">if</font> (argc == 2) { <br> numofthread = atoi(argv[1]); <br> <font color="#0000ff">if</font> (numofthread &lt; 1) { <br> fprintf(stderr, <font color="#A31515">"Incorrect num of threads!\n"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> fprintf(stdout, <font color="#A31515">"Num of threads forced to %d\n"</font> , numofthread); <br> } <font color="#0000ff">else</font> { <br> <font color="#008000">//   ,   -  </font> <br> numofthread = sysconf(_SC_NPROCESSORS_ONLN); <br> <font color="#0000ff">if</font> (numofthread &lt; 1) { <br> fprintf(stderr, <font color="#A31515">"Can't detect num of processors\n"</font> <br> <font color="#A31515">"Continue in two threads\n"</font> ); <br> numofthread = 2; <br> } <br> fprintf(stdout, <font color="#A31515">"Num of threads detected automatically it's %d\n\n"</font> , <br> numofthread); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  I think the verification of the arguments can not be explained ... <br><br>  Set a mask for signals, and run the thread to listen to requests: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">struct</font> sigaction cancel_act; <br> memset(&amp;cancel_act, 0, <font color="#0000ff">sizeof</font> (cancel_act)); <br> cancel_act.sa_handler = thread_cancel; <br> sigfillset(&amp;cancel_act.sa_mask); <br> sigaction(SIGUSR1, &amp;cancel_act, NULL); <br> <br> <font color="#008000">//    broadcast'</font> <br> pthread_t broadcast_thread; <br> <font color="#0000ff">int</font> isbusy = 1; <font color="#008000">//(int*) malloc(sizeof(int));</font> <br> <font color="#008000">//         broadcast</font> <br> <font color="#008000">// 0 - , 1- </font> <br> isbusy = 1; <br> <font color="#0000ff">if</font> (pthread_create(&amp;broadcast_thread, NULL, listen_broadcast, &amp;isbusy)) { <br> fprintf(stderr, <font color="#A31515">"Can't create broadcast listen thread"</font> ); <br> perror( <font color="#A31515">"Detail:"</font> ); <br> exit(EXIT_FAILURE); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  Now we create a socket with which the clients will connect: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> listener; <br> <font color="#0000ff">struct</font> sockaddr_in addr; <br> listener = socket(PF_INET, SOCK_STREAM, 0); <br> <font color="#0000ff">if</font> (listener &lt; 0) { <br> perror( <font color="#A31515">"Can't create listen socket"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> addr.sin_family = AF_INET; <br> addr.sin_port = htons(RCVPORT); <br> addr.sin_addr.s_addr = INADDR_ANY; <br> <font color="#0000ff">int</font> a = 1; <br> <font color="#008000">//   SO_REUSEADDR      </font> <br> <font color="#0000ff">if</font> (setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;a, <font color="#0000ff">sizeof</font> (a)) &lt; 0) { <br> perror( <font color="#A31515">"Set listener socket options"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#008000">//  </font> <br> <font color="#0000ff">if</font> (bind(listener, ( <font color="#0000ff">struct</font> sockaddr*) &amp;addr, <font color="#0000ff">sizeof</font> (addr)) &lt; 0) { <br> perror( <font color="#A31515">"Can't bind listen socket"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#008000">//     </font> <br> <font color="#0000ff">if</font> (listen(listener, 1) &lt; 0) { <br> perror( <font color="#A31515">"Eror listen socket"</font> ); <br> exit(EXIT_FAILURE); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We start the computational cycle: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//  </font> <br> <font color="#0000ff">int</font> needexit = 0; <br> <font color="#0000ff">while</font> (needexit == 0) { <br> fprintf(stdout, <font color="#A31515">"\nWait new connection...\n\n"</font> ); <br> <font color="#0000ff">int</font> client; <br> isbusy = 0; <font color="#008000">//     </font> <br> <font color="#0000ff">struct</font> sockaddr_in addrclient; <br> socklen_t addrclientsize = <font color="#0000ff">sizeof</font> (addrclient); <br> client = accept(listener, ( <font color="#0000ff">struct</font> sockaddr*)&amp;addrclient, <br> &amp;addrclientsize); <br> <font color="#0000ff">if</font> (client &lt; 0) { <br> perror( <font color="#A31515">"Client accepting"</font> ); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  We quietly hang on accept'e, since a separate thread deals with responses to broadcast requests. <br>  After the client has connected to us, we check the data from him, and we start to calculate: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">isbusy = 1; <font color="#008000">//    </font> <br> task_data_t data; <br> <font color="#0000ff">int</font> read_bytes = recv(client, &amp;data, <font color="#0000ff">sizeof</font> (data), 0); <br> <font color="#0000ff">if</font> (read_bytes != <font color="#0000ff">sizeof</font> (data) || data.limits &lt; 1 || data.numoftry &lt; 1) { <br> fprintf(stderr, <font color="#A31515">"Invalid data from %s on port %d, reset peer\n"</font> , <br> inet_ntoa(addrclient.sin_addr), ntohs(addrclient.sin_port)); <br> close(client); <br> isbusy = 0; <br> } <font color="#0000ff">else</font> { <br> fprintf(stdout, <font color="#A31515">"New task from %s on port %d\nlimits: %d\n"</font> <br> <font color="#A31515">"numoftrys: %d\n"</font> , inet_ntoa(addrclient.sin_addr), <br> ntohs(addrclient.sin_port), data.limits, data.numoftry); <br> thread_args_t *tinfo; <br> pthread_t *calc_threads = <br> (pthread_t*) malloc( <font color="#0000ff">sizeof</font> (pthread_t) * numofthread); <br> <font color="#0000ff">int</font> threads_trys = data.numoftry % numofthread; <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> *results = <br> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> ) * numofthread); <br> tinfo = (thread_args_t*) malloc( <font color="#0000ff">sizeof</font> (thread_args_t) * <br> numofthread); <br> <font color="#008000">//   </font> <br> <font color="#0000ff">int</font> numofthreadtry = data.numoftry / numofthread + 1; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; numofthread; ++i) { <br> tinfo[i].limits = data.limits; <br> tinfo[i].numoftry = numofthreadtry; <br> tinfo[i].results = &amp;results[i]; <br> <font color="#0000ff">if</font> (pthread_create(&amp;calc_threads[i], NULL, calculate, &amp;tinfo[i]) <br> != 0) { <br> fprintf(stderr, <font color="#A31515">"Can't create thread by num %d"</font> , i); <br> perror( <font color="#A31515">"Detail:"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> } <br> <br> <font color="#008000">//      </font> <br> checker_args_t checker_arg; <br> checker_arg.calcthreads = calc_threads; <br> checker_arg.threadnum = numofthread; <br> checker_arg.sock = client; <br> pthread_t checker_thread; <br> <font color="#0000ff">if</font> (pthread_create(&amp;checker_thread, NULL, client_check, <br> &amp;checker_arg) != 0) { <br> fprintf(stderr, <font color="#A31515">"Can't create checker thread"</font> ); <br> perror( <font color="#A31515">"Detail:"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <font color="#0000ff">int</font> iscanceled = 0; <font color="#008000">//   ?</font> <br> <font color="#0000ff">int</font> *exitstat; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; numofthread; ++i) { <br> pthread_join(calc_threads[i], ( <font color="#0000ff">void</font> *) &amp;exitstat); <br> <font color="#0000ff">if</font> (exitstat == PTHREAD_CANCELED) <br> iscanceled = 1; <font color="#008000">//  </font> <br> } <br> <font color="#0000ff">if</font> (iscanceled != 1) { <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> *res = ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> )); <br> bzero(res, <font color="#0000ff">sizeof</font> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> )); <br> *res = 0.0; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = 0; i &lt; numofthread; ++i) <br> *res += results[i]; <br> pthread_kill(checker_thread, SIGUSR1); <br> <font color="#0000ff">if</font> (send(client, res, <font color="#0000ff">sizeof</font> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> ), 0) &lt; 0) { <br> perror( <font color="#A31515">"Sending error"</font> ); <br> } <br> close(client); <br> free(res); <br> <font color="#008000">//free(checker_arg);</font> <br> free(results); <br> free(calc_threads); <br> free(tinfo); <br> isbusy = 0; <br> fprintf(stdout, <font color="#A31515">"Calculate and send finish!\n"</font> ); <br> } <font color="#0000ff">else</font> { <br> fprintf(stderr, <font color="#A31515">"Client die!\n"</font> ); <br> close(client); <br> <font color="#008000">//free(checker_arg);</font> <br> free(results); <br> free(calc_threads); <br> free(tinfo); <br> } <br> <br> <br> } <br> <br> } <br> <br> <font color="#0000ff">return</font> (EXIT_SUCCESS); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  The rest of the code is simple: <br><ol><li>  Run computational threads </li><li>  Run a thread checking state </li><li>  We wait until everything is calculated </li><li>  We respond to the client </li><li>  We start the computational cycle again </li></ol><br>  I draw your attention to the fact that it is not necessary to complete the checking thread, because it completes itself when the socket is closed with the client. <br><br>  All server is ready. <br><br><h4>  Customer </h4><br>  The client will be arranged as follows: <br><ol><li>  We form the list of servers </li><li>  To work with each server create thread </li><li>  Waiting for results and exit </li></ol><br>  To work with each server, it is convenient to create a separate thread, this will allow working with them asynchronously. <br><br>  Just like in the server, we will declare the structure for data exchange.  As well as the structure of the argument for threads working with servers. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//     </font> <br> typedef <font color="#0000ff">struct</font> { <br> <font color="#0000ff">int</font> limits; <br> <font color="#0000ff">int</font> numoftry; <br> } task_data_t; <br> <br> <font color="#008000">//      </font> <br> typedef <font color="#0000ff">struct</font> { <br> <font color="#0000ff">int</font> limits; <font color="#008000">// </font> <br> <font color="#0000ff">int</font> numoftry; <font color="#008000">//    </font> <br> <font color="#0000ff">struct</font> sockaddr_in *server; <font color="#008000">//       </font> <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> *results; <font color="#008000">//   </font> <br> } thread_args_t;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In the client, it does not need to set the port to listen on, because the server responds to where the packet came from, so let's take the one that the OS assigns to us.  So, the function (thread) working with the server: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#008000">//     </font> <br> <font color="#0000ff">void</font> *send_thread( <font color="#0000ff">void</font> *arg) { <br> thread_args_t *task_data = (thread_args_t*) arg; <br> <font color="#0000ff">int</font> servsock = socket(PF_INET, SOCK_STREAM, 0); <br> <font color="#0000ff">if</font> (servsock &lt; 0) { <br> perror( <font color="#A31515">"Create new socket to server"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <font color="#0000ff">struct</font> sockaddr_in listenaddr; <br> listenaddr.sin_family = AF_INET; <br> listenaddr.sin_addr.s_addr = INADDR_ANY; <br> listenaddr.sin_port = 0; <br> <br> <font color="#0000ff">if</font> (bind(servsock, ( <font color="#0000ff">struct</font> sockaddr*) &amp;listenaddr, <font color="#0000ff">sizeof</font> (listenaddr)) &lt; 0) { <br> perror( <font color="#A31515">"Can't create listen socket"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> socklen_t servaddrlen = <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in); <br> <font color="#0000ff">if</font> (connect(servsock, ( <font color="#0000ff">struct</font> sockaddr*)task_data-&gt;server, <br> servaddrlen) &lt; 0) { <br> perror( <font color="#A31515">"Connect to server failed!"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> task_data_t senddata; <br> senddata.limits = task_data-&gt;limits; <br> senddata.numoftry = task_data-&gt;numoftry; <br> <br> <font color="#0000ff">if</font> (send(servsock, &amp;senddata, <font color="#0000ff">sizeof</font> (senddata), 0) &lt; 0) { <br> perror( <font color="#A31515">"Sending data to server failed"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#0000ff">int</font> recv_byte = recv(servsock, task_data-&gt;results, <font color="#0000ff">sizeof</font> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> ), 0); <br> <font color="#0000ff">if</font> (recv_byte == 0) { <br> fprintf(stderr, <font color="#A31515">"Server %s on port %d die!\nCancel calculate, on all"</font> , <br> inet_ntoa(task_data-&gt;server-&gt;sin_addr), <br> ntohs(task_data-&gt;server-&gt;sin_port)); <br> exit(EXIT_FAILURE); <br> } <br> fprintf(stdout, <font color="#A31515">"Server %s on port %d finish!\n"</font> , <br> inet_ntoa(task_data-&gt;server-&gt;sin_addr), <br> ntohs(task_data-&gt;server-&gt;sin_port)); <br> <font color="#0000ff">return</font> NULL; <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  main is very similar to the main server, plus commented out in some detail, I will not discuss it too much. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">int</font> main( <font color="#0000ff">int</font> argc, <font color="#0000ff">char</font> ** argv) { <br> <font color="#0000ff">if</font> (argc &lt; 3) { <br> fprintf(stderr, <font color="#A31515">"Usage: %s limits numoftry [maxserv]\n"</font> , argv[0]); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#0000ff">int</font> numoftry = atoi(argv[2]); <br> <font color="#0000ff">if</font> (numoftry == 0) { <br> fprintf(stderr, <font color="#A31515">"Num of try is invalid\n"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <font color="#0000ff">int</font> maxservu = 1000000; <br> <font color="#0000ff">if</font> (argc == 4) { <br> maxservu = atoi(argv[3]); <br> <font color="#0000ff">if</font> (maxservu &lt; 1) { <br> fprintf(stderr, <font color="#A31515">"Error number of max servers\n"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> } <br> <font color="#0000ff">int</font> limits = atoi(argv[1]); <br> <font color="#0000ff">if</font> (limits == 0) { <br> fprintf(stderr, <font color="#A31515">"Limits is invalid\n"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#008000">//      broadcast</font> <br> <font color="#0000ff">int</font> sockbrcast = socket(PF_INET, SOCK_DGRAM, 0); <br> <font color="#0000ff">if</font> (sockbrcast == -1) { <br> perror( <font color="#A31515">"Create broadcast socket failed"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <br> <br> <font color="#008000">//       broadcast</font> <br> <font color="#0000ff">int</font> port_rcv = 0; <br> <font color="#0000ff">struct</font> sockaddr_in addrbrcast_rcv; <br> bzero(&amp;addrbrcast_rcv, <font color="#0000ff">sizeof</font> (addrbrcast_rcv)); <br> addrbrcast_rcv.sin_family = AF_INET; <br> addrbrcast_rcv.sin_addr.s_addr = htonl(INADDR_ANY); <br> addrbrcast_rcv.sin_port = 0; <font color="#008000">//htons(port_rcv);</font> <br> <font color="#008000">//  </font> <br> <font color="#0000ff">if</font> (bind(sockbrcast, ( <font color="#0000ff">struct</font> sockaddr *) &amp;addrbrcast_rcv, <br> <font color="#0000ff">sizeof</font> (addrbrcast_rcv)) &lt; 0) { <br> perror( <font color="#A31515">"Bind broadcast socket failed"</font> ); <br> close(sockbrcast); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#008000">//    broadcast</font> <br> <font color="#0000ff">int</font> port_snd = 38199; <br> <font color="#0000ff">struct</font> sockaddr_in addrbrcast_snd; <br> bzero(&amp;addrbrcast_snd, <font color="#0000ff">sizeof</font> (addrbrcast_snd)); <br> addrbrcast_snd.sin_family = AF_INET; <br> addrbrcast_snd.sin_port = htons(port_snd); <br> addrbrcast_snd.sin_addr.s_addr = htonl(0xffffffff); <br> <br> <font color="#008000">//  broadcast  </font> <br> <font color="#0000ff">int</font> access = 1; <br> <font color="#0000ff">if</font> (setsockopt(sockbrcast, SOL_SOCKET, SO_BROADCAST, <br> ( <font color="#0000ff">const</font> <font color="#0000ff">void</font> *) &amp;access, <font color="#0000ff">sizeof</font> (access)) &lt; 0) { <br> perror( <font color="#A31515">"Can't accept broadcast option at socket to send"</font> ); <br> close(sockbrcast); <br> exit(EXIT_FAILURE); <br> } <br> <font color="#0000ff">int</font> msgsize = <font color="#0000ff">sizeof</font> ( <font color="#0000ff">char</font> ) * 18; <br> <font color="#0000ff">void</font> *hellomesg = malloc(msgsize); <br> bzero(hellomesg, msgsize); <br> strcpy(hellomesg, <font color="#A31515">"Hello Integral"</font> ); <br> <font color="#008000">//  broadcast</font> <br> <font color="#0000ff">if</font> (sendto(sockbrcast, hellomesg, msgsize, 0, <br> ( <font color="#0000ff">struct</font> sockaddr*) &amp;addrbrcast_snd, <font color="#0000ff">sizeof</font> (addrbrcast_snd)) &lt; 0) { <br> perror( <font color="#A31515">"Sending broadcast"</font> ); <br> close(sockbrcast); <br> exit(EXIT_FAILURE); <br> } <br> <br> <font color="#008000">//    broadcast' </font> <br> fcntl(sockbrcast, F_SETFL, O_NONBLOCK); <br> <br> <font color="#008000">//   </font> <br> fd_set readset; <br> FD_ZERO(&amp;readset); <br> FD_SET(sockbrcast, &amp;readset); <br> <br> <font color="#008000">// </font> <br> <font color="#0000ff">struct</font> timeval timeout; <br> timeout.tv_sec = 3; <br> timeout.tv_usec = 0; <br> <br> <font color="#0000ff">struct</font> sockaddr_in *servers = <br> ( <font color="#0000ff">struct</font> sockaddr_in*) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in)); <br> bzero(servers, <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in)); <br> <font color="#0000ff">int</font> servcount = 0; <br> <font color="#0000ff">int</font> maxserv = 1; <br> socklen_t servaddrlen = <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in); <br> <font color="#008000">//    servers</font> <br> <font color="#0000ff">while</font> ( <font color="#0000ff">select</font> (sockbrcast + 1, &amp;readset, NULL, &amp;readset, &amp;timeout) &gt; 0) { <br> <font color="#0000ff">int</font> rdbyte = recvfrom(sockbrcast, ( <font color="#0000ff">void</font> *) hellomesg, msgsize,MSG_TRUNC, <br> ( <font color="#0000ff">struct</font> sockaddr*) &amp;servers[servcount], <br> &amp;servaddrlen); <br> <font color="#0000ff">if</font> (rdbyte == msgsize &amp;&amp; strcmp(hellomesg, <font color="#A31515">"Hello Client"</font> ) == 0) { <br> servcount++; <br> <br> <font color="#0000ff">if</font> (servcount &gt;= maxserv) { <br> servers = realloc(servers, <br> <font color="#0000ff">sizeof</font> ( <font color="#0000ff">struct</font> sockaddr_in) * (maxserv + 1)); <br> <font color="#0000ff">if</font> (servers == NULL) { <br> perror( <font color="#A31515">"Realloc failed"</font> ); <br> close(sockbrcast); <br> exit(EXIT_FAILURE); <br> } <br> bzero(&amp;servers[servcount], servaddrlen); <br> maxserv++; <br> } <br> FD_ZERO(&amp;readset); <br> FD_SET(sockbrcast, &amp;readset); <br> } <br> } <br> <font color="#0000ff">int</font> i; <br> <font color="#0000ff">if</font> (servcount &lt; 1) { <br> fprintf(stderr, <font color="#A31515">"No servers found!\n"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> <font color="#0000ff">if</font> (argc &gt; 3 &amp;&amp; maxservu &lt;= servcount) <br> servcount = maxservu; <br> <font color="#0000ff">for</font> (i = 0; i &lt; servcount; ++i) { <br> printf( <font color="#A31515">"Server answer from %s on port %d\n"</font> , <br> inet_ntoa(servers[i].sin_addr), ntohs(servers[i].sin_port)); <br> } <br> printf( <font color="#A31515">"\n"</font> ); <br> free(hellomesg); <br> <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> *results = <br> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> *) malloc( <font color="#0000ff">sizeof</font> ( <font color="#0000ff">long</font> <font color="#0000ff">double</font> ) * servcount); <br> <font color="#008000">//      </font> <br> pthread_t *tid = (pthread_t*) malloc( <font color="#0000ff">sizeof</font> (pthread_t) * servcount); <br> <font color="#0000ff">for</font> (i = 0; i &lt; servcount; ++i) { <br> thread_args_t *args = (thread_args_t*) malloc ( <font color="#0000ff">sizeof</font> (thread_args_t)); <br> args-&gt;limits = limits; <br> args-&gt;numoftry = numoftry / servcount + 1; <br> args-&gt;results = &amp;results[i]; <br> args-&gt;server = &amp;servers[i]; <br> <br> <font color="#0000ff">if</font> (pthread_create(&amp;tid[i], NULL, send_thread, args) != 0) { <br> perror( <font color="#A31515">"Create send thread failed"</font> ); <br> exit(EXIT_FAILURE); <br> } <br> } <br> <font color="#0000ff">long</font> <font color="#0000ff">double</font> res = 0; <br> <font color="#008000">//   </font> <br> <font color="#0000ff">for</font> (i = 0; i &lt; servcount; ++i) <br> pthread_join(tid[i], NULL); <br> <br> <font color="#008000">//  </font> <br> <font color="#0000ff">for</font> (i = 0; i &lt; servcount; ++i) <br> res += results[i]; <br> res /= numoftry; <br> res *= limits; <br> <br> <br> free(servers); <br> printf( <font color="#A31515">"\nResult: %Lf\n"</font> , res); <br> <font color="#0000ff">return</font> (EXIT_SUCCESS); <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Performance testing </h4><br><h5>  Performance depending on the number of threads </h5><br>  I ran the program on the same computer, with the same input data, with a different number of threads. <br>  Client run with parameters 2 1000000000;  Server with parameters 1, 2, 4, 8. <br>  Results respectively: 0m37.063s, 0m20.576s, 0m20.329s, 0m21.029s.  It should be borne in mind that the results that showed time need to take 4 seconds that we wait for the servers. <br>  The processor on the machine <b>Core (TM) 2 Duo CPU T5470</b> .  As expected, the processor has two cores and, accordingly, it makes no sense to run more than 2 threads, and so: doubling the number of threads gives <br>  double acceleration. <br><br>  We also tested the <b>Asus 1215p</b> , the result has the same dependence on the number of threads as above <br><br><h5>  Performance depending on the number of machines </h5><br>  Now I started the server on 1, 2, 4, 8, 16 computers, the number of threads is equal to the number of cores, that is, two threads. <br>  Here are the results: 0m10.268s, 0m5.122s, 0m2.487s, 0m1.265, 0m0.766s. <br>  Again we get the expected result, with each new computer the calculations will be accelerated by 2 times. <br><br><h4>  Total </h4><br>  As a result, we get a program that simultaneously computes the integral and is resistant to all sorts of troubles that may occur during operation.  Unfortunately, due to the large size of the article, it was not possible to consider everything in somewhat greater detail.  But I hope that my example will help beginners to avoid some of the mistakes that occurred to me.  Source codes of programs with make files can be found <a href="http://narod.ru/disk/16480757001/HabrTopicIntegralOnNetwork.tar.xz.html">here</a> . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/122754/">https://habr.com/ru/post/122754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122746/index.html">A tale about how a good young man fought a three-headed snake, or How to embed SVG graphics in Adobe InDesign documents - part one</a></li>
<li><a href="../122747/index.html">Recovery strategy for damaged table in MySQL</a></li>
<li><a href="../122748/index.html">Youtube and numbers on the keyboard</a></li>
<li><a href="../122751/index.html">Voice tree on Asterisk do it yourself</a></li>
<li><a href="../122753/index.html">Working with AD: Search by SIDHistory attribute</a></li>
<li><a href="../122755/index.html">How to make money on bitcoins, or my mining experience</a></li>
<li><a href="../122756/index.html">Software for PC and smartphone interaction</a></li>
<li><a href="../122757/index.html">Creation and use of dynamic libraries written in various languages ‚Äã‚Äã(C / C ++, Pascal)</a></li>
<li><a href="../122758/index.html">Get access from java to javascript via swt browser</a></li>
<li><a href="../122759/index.html">Virtual Publishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>