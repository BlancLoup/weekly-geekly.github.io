<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ext JS on server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When it comes to the Ext JS library, there is quite a lot of negativity from the experts: hard, expensive, buggy. As a rule, most of the problems asso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ext JS on server</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/wl/0h/yu/wl0hyunbvr2q-wqwydwamsfk804.png" width="250" align="left" alt="Photos from here https://github.com/tj/palette">  When it comes to the Ext JS library, there is quite a lot of negativity from the experts: hard, expensive, buggy.  As a rule, most of the problems associated with the inability to cook it.  A project correctly assembled using Sencha Cmd with all css, pictures weighs in production in the region of 1Mb, which is comparable to the same Angular.  And the glitches are not much more ... <br><br>  It is possible to relate differently to this offspring of the company Sencha, but even its principled opponents recognize that it is difficult to find the best solution for building serious intranet projects. <br><br>  In my opinion, the most valuable thing in Ext JS is not a collection of UI components, but a rather successful OOP architecture.  Even taking into account the rapid development of JS in recent years, many of the necessary things that were implemented in Ext JS 7 years ago, are still missing in native classes (namespaces, mixins, static properties, convenient calling of parent methods).  This is what prompted me a few years ago to experiment with the launch of the Ext JS classes in the bend.  About the first such experiments I have already done posts on Habr√©.  This article describes a new implementation of old ideas and a number of fresh ones. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before we begin, attention to the question: what do you think, where is the execution and what does the below code fragment do? <br><br><pre><code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.message.model.Message'</span></span>, { .... <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> newMessage() { ......... this.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, data); ...... } ... })</code> </pre> <a name="habracut"></a><br>  This code is executed on the server and raises the "newmessage" event in all instances of the class "Module.message.model.Message" on all client machines connected to the server. <br><br>  To illustrate the possibilities of using Ext JS server, let's analyze a simple chat project.  Login will not do anything, just when entering the user enters a nickname.  You can post general or private messages.  Chat should work in real time.  Those interested can immediately try all this stuff in business. <br><br><h2>  Installation </h2><br>  To run, we need nodejs 9+ and redis-server (assuming they are already installed). <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/extjs-backend-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> extjs-backend-example npm i</code> </pre><br>  We get the server: <br><br><pre> <code class="bash hljs">node server</code> </pre><br>  Open <a href="http://localhost/">localhost</a> : 3000 / www / auth / in the browser <br>  Enter some nickname and click "enter". <br><br>  The project is demo, so there is no support for old browsers (there are ES8 constructions), use the new Chrome or FF. <br><br><h2>  Server </h2><br>  Let's go in order. <br><br>  Server code (server.js) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   http-  express //   Ext JS     express const express = require('express'); const staticSrv = require('extjs-express-static'); const app = express(); const bodyParser = require('body-parser'); //    global = { config: require('config') } //     Ext JS require('extjs-on-backend')({ //     express app, //         wsClient: 'Base.wsClient' }); //    Ext.Loader.setPath('Api', 'protected/rest'); Ext.Loader.setPath('Base', 'protected/base'); Ext.Loader.setPath('Www', 'protected/www'); //   http   app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); //     Ext JS  app.use('/api/auth', Ext.create('Api.auth.Main')); app.use('/www/auth', Ext.create('Www.login.controller.Login')); //    app.use(staticSrv(__dirname + '/static')); //   const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br>  As you can see, everything is more or less standard for the server on express.  Of interest is the connection of classes Ext JS for the maintenance of the corresponding routes: <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-string"><span class="hljs-string">'/api/auth'</span></span>, Ext.create(<span class="hljs-string"><span class="hljs-string">'Api.auth.Main'</span></span>)); app.use(<span class="hljs-string"><span class="hljs-string">'/www/auth'</span></span>, Ext.create(<span class="hljs-string"><span class="hljs-string">'Www.login.controller.Login'</span></span>));</code> </pre><br><h3>  REST API implementation </h3><br>  The class Api.auth.Main serves requests to the REST API (protected / rest / auth / Main.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Api.auth.Main'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Api.Base'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   //     routes: [ { path: '/', get: 'login'}, { path: '/restore', post: 'restoreLogin' }, { path: '/registration', post: 'newuser'}, { path: '/users', get: 'allUsers'} ] //     : // {query: &lt;...&gt;, params: &lt;...&gt;, body: &lt;...&gt;} ,async login(data) { return {data:[{ id:1, subject: 111, sender:222, }]} } ,async restoreLogin() { ... } ,async newuser() { ... } ,async allUsers() { .... } })</span></span></code> </pre><br><h3>  Generate HTML pages, use XTemplate on server </h3><br>  The second class Www.login.controller.Login builds a regular html page with a login form (protected / www / login / controller / Login.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Www.login.controller.Login'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//      "" : // ,    .. extend: 'Www.Base' //    //   ,   .. ,baseTpl: 'view/inner' //     // ,   ,loginFormTpl: 'login/view/login' //  ,routes: [ { path: '/', get: 'loginForm', post: 'doLogin'} ] //  html   //       ,async loginForm () { return await this.tpl(this.loginFormTpl, { pageTitle: 'Login page', date: new Date() }); } ,async doLogin (params, res) { if(params.body.name &amp;&amp; /^[a-z0-9]{2,10}$/i.test(params.body.name)) { this.redirect(`/index.html?name=${params.body.name}`, res); return; } return await this.tpl(this.loginFormTpl, { pageTitle: 'Login page', date: new Date() }); } })</span></span></code> </pre><br>  The templates use the standard XTemplate (protected / www / login / view / login.tpl) <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span>{pageTitle} (date: {[Ext.Date.format(values.date,'dmY')]})<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"post"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag">&gt;</span></span>enter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Everything described above is quite a standard set, the meticulous reader will say, and for this there was no need to fence this garden with the transfer of Ext JS to the server.  Therefore, we turn to the second part of the article, where it will be shown what all this was intended for. <br><br><h2>  Customer </h2><br>  Create a normal client Ext JS application in the static directory.  In this example, I deliberately do not consider the use of cmd, took the already assembled ext-all and the standard theme.  Build issues is a separate topic, which may devote a separate post. <br><br>  It all starts with app.js <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Ext.Loader.setConfig({ enabled: true, paths: { "Core": "app/core", "Admin": "app/admin", "Module": "app/admin/modules", "Ext.ux": "ext/ux" } }); //    this.token = Ext.data.identifier.Uuid.createRandom()(); //      //    () //    (   ) Ext.WS = Ext.create('Core.WSocket', { token: this.token, user: new URLSearchParams(document.location.search).get("name") }); //   Ext.application({ name: 'Example', extend: 'Ext.app.Application', requires: ['Admin.*'], autoCreateViewport: 'Admin.view.Viewport' })</span></span></code> </pre><br>  The presence of a web socket is a crucially important point, it allows him to realize all the magic described below. <br><br>  The layout of the elements on the page is contained in the class Admin.view.Viewport (static / app / view / Viewport.js).  There is nothing interesting. <br><br>  The main functional elements (list of users, message panel and form of sending) are implemented as separate modules. <br><br><h3>  a list of users </h3><br>  The simple algorithm of this list operation is as follows: at the moment of opening the page, current users are loaded from the server.  When new users are connected, the server generates an ‚Äúadd‚Äù event in the class ‚ÄúModule.users.model.UserModel‚Äù, when disconnected, the ‚Äúremove‚Äù event is triggered in the same class.  The whole thing is that the event is initiated on the server side, and you can track it on the client. <br><br>  Now, first things first.  On the client side, data juggles Store (static / app / modules / users / store / UsersStore.js) <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.users.store.UsersStore'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.data.Store'</span></span> ,<span class="hljs-attr"><span class="hljs-attr">autoLoad</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> ,<span class="hljs-attr"><span class="hljs-attr">total</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//         this.dataModel = Ext.create('Module.users.model.UserModel'); //      this.dataModel.on({ add: (records) =&gt; { this.onDataAdd(records) }, remove: (records) =&gt; { this.onDataRemove(records) } }) this.callParent(arguments) } //   load ,async load() { //      const data = await this.dataModel.$read(); //   this.total = data.total; //    UI this.loadData(data.data); } ,getTotalCount() { return this.total; } //          ,onDataAdd(records) { this.add(records[0]); } //   --  ,onDataRemove(records) { this.remove(this.getById (records[0].id)) } });</span></span></code> </pre><br>  There are 2 interesting points.  First, in the string ‚Äúconst data = await this.dataModel. $ Read ();‚Äù the server method of the model is called.  Now you do not need to use Ajax, support protocols, etc., just call the server method as local.  At the same time, security is not sacrificed (more on this below). <br><br>  Secondly, the standard construction of this.dataModel.on (...) allows you to track events that will be generated by the server. <br><br>  The model is a bridge between the client and server part of the application.  It is like a dualism of light - it realizes the properties of both the frontend and bekend.  Let's look at the model carefully. <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.users.model.UserModel'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.data.DataModel'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scope:client */</span></span> ,testClientMethod() { ... } ,testGlobalMethod() { ... } <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,privateServerMethod() { .... } <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $read(params) { <span class="hljs-comment"><span class="hljs-comment">//      redis const keys = await this.getMemKeys('client:*'); let data = [], name; for(let i = 0;i&lt;keys.length;i++) { //         name = await this.getMemKey(keys[i]); if(name) { data.push({ id: keys[i].substr(7), name }) } } //    return { total: data.length, data } } })</span></span></code> </pre><br>  Pay attention to the comments / * scope: server * / and / * scope: client * / - these constructions are labels for the server by which it determines the type of method. <br><br>  testClientMethod - this method runs exclusively on the client and is available only on the client side. <br>  testGlobalMethod - this method runs on the client and on the server and is available for use for the client and server side. <br>  privateServerMethod - the method runs on the server and is available for calling only on the server. <br>  $ read is the most interesting type of method that runs only on the server side, but you can call it both on the client and on the server.  The prefix "$" makes any server method available on the client side. <br><br>  You can monitor the connection and disconnection of a client using a web socket.  For each user connection an instance of the class ‚ÄúBase.wsClient‚Äù is created (protected / base / wsClient.js) <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Base.wsClient'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.WsClient'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ,usersModel: Ext.create('Module.users.model.UserModel') //       ,async onStart() { //   "add"    this.usersModel.fireEvent('add', 'all', [{id: this.token, name: this.req.query.user}]); //     redis await this.setMemKey(`client:${this.token}`, this.req.query.user || ''); //   ""      , //     await this.queueProcess(`client:${this.token}`, async (data, done) =&gt; { const res = await this.prepareClientEvents(data); done(res); }) } //      ,onClose() { //   "remove"    this.usersModel.fireEvent('remove', 'all', [{id: this.token, name: this.req.query.user}]) this.callParent(arguments); } })</span></span></code> </pre><br>  The ‚ÄúfireEvent‚Äù method, in contrast to the standard one, has an additional parameter, where it is transmitted on which client the event should be triggered.  It is possible to pass a single client identifier, an array of identifiers, or the string ‚Äúall‚Äù.  In the latter case, the event will be triggered on all connected clients.  Otherwise, this is a standard fireEvent. <br><br><h3>  Sending and receiving messages </h3><br>  The form controller is responsible for sending messages (static / app / admin / modules / messages / view / FormController.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.view.FormController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span> ,init(view) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view = view; <span class="hljs-comment"><span class="hljs-comment">//     this.model = Ext.create('Module.messages.model.Model'); //      this.msgEl = this.view.down('[name=message]'); //     this.usersGrid = Ext.getCmp('users-grid') //    "" this.control({ '[action=submit]' : {click: () =&gt; {this.newMessage() }} }) } //     ,newMessage() { let users = []; //     const sel = this.usersGrid.getSelection(); if(sel &amp;&amp; sel.length) { sel.forEach((s) =&gt; { users.push(s.data.id) }) } //        if(users.length &amp;&amp; users.indexOf(Ext.WS.token) == -1) users.push(Ext.WS.token); //       this.model.$newmessage({ to: users, user: Ext.WS.user, message: this.msgEl.getValue() }) //    this.msgEl.setValue(''); } });</span></span></code> </pre><br>  On the server, the message is not stored anywhere, just the event "newmessage" is triggered.  Of interest is the call ‚Äúthis.fireEvent ('newmessage', data.to, msg);‚Äù, where clients' identifiers are sent as message recipients.  Thus, the delivery of private messages is implemented (static / app / admin / modules / messages / model / Model.js). <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.model.Model'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.data.DataModel'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $newmessage(data) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msg = { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: data.user, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: data.message } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.to &amp;&amp; Ext.isArray(data.to) &amp;&amp; data.to.length) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, data.to, msg); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, <span class="hljs-string"><span class="hljs-string">'all'</span></span>, msg); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } })</code> </pre><br>  As in the case of users, the data for the message list drives Store (static / app / admin / modules / messages / store / MessagesStore.js) <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.store.MessagesStore'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.data.Store'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: [<span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//       Ext.create('Module.messages.model.Model', { listeners: { newmessage: (mess) =&gt; { this.add(mess) } } }) this.callParent(arguments); } });</span></span></code> </pre><br>  In general, this is all that is interesting in this example. <br><br><h2>  Possible questions </h2><br>  <b>Availability of server methods on the client is, of course, good, but what about security?</b>  <b>It turns out that an evil hacker can see the server code and try to hack the back-end?</b> <br><br>  No, it will not work.  First, all server methods are removed from the class code when sent to the client browser.  For this purpose, comments are intended directives / * scope: ... * /.  Secondly, the code of the most public server method is replaced by an intermediate structure that implements the remote call mechanism on the client side. <br><br>  <b>Again about security.</b>  <b>If server methods can be called on the client, it turns out, can I call any such method?</b>  <b>And if this is a database cleanup method?</b> <br><br>  From the client, you can only call methods that have the $ prefix in their name.  For such methods, you yourself determine the logic of checks and accesses.  The external user does not have any access to server methods without $, he will not even see them (see previous answer) <br><br>  <b>It looks like you got a monolithic system in which the client and server are inextricably linked.</b>  <b>Is horizontal scaling possible?</b> <br><br>  The system really looks monolithic, but it is not.  The client and the server can live on different machines.  The client can be run on any third-party web server (Nginx, Apache, etc.).  The question of separating the client and the server is very simply solved by the automatic project builder (I can write a separate post about this).  The system uses queues to implement the internal service message exchange mechanism (namely, Redis is required for this).  Thus, the server part can be easily scaled horizontally by simply adding new machines. <br><br>  <b>In the usual approach to development, as a rule, the backend provides a certain set of APIs to which you can connect diverse client applications (website, mobile application).</b>  <b>In your case, it turns out that only a client written on Ext JS can work with a backend?</b> <br><br>  On the server, in particular in the models of modules, some business logic is implemented.  In order to provide access to it through the REST API, a rather small ‚Äúwrapper‚Äù is required.  The corresponding example is presented in the first part of this article. <br><br><h2>  findings </h2><br>  As you can see, for comfortable coding of quite complex applications, it is quite possible to do with one library at the frontend and backend.  This provides significant benefits. <br><br>  <b>Accelerating the development process.</b>  Each of the team members can work on the back-end and the frontend.  Downtime due to ‚ÄúI am waiting for this API to appear on the server‚Äù becomes irrelevant. <br><br>  <b>Less code.</b>  The same parts of the code can be used on the client and on the server (verification, verification, etc.). <br><br>  <b>Maintaining such a system is much easier and cheaper.</b>  Instead of two diverse programmers, the system will be able to support one (or the same two but interchangeable).  For the same reason, the risks associated with running a team are also lower. <br><br>  <b>The ability out of the box to create real-time systems.</b> <br><br>  <b>Using a unified testing system for backends and fronts.</b> </div><p>Source: <a href="https://habr.com/ru/post/431180/">https://habr.com/ru/post/431180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431170/index.html">Scientist from China announced the birth of genetically modified children</a></li>
<li><a href="../431172/index.html">What do we expect from Blizzard? Past, Present and Future of the Diablo Series</a></li>
<li><a href="../431174/index.html">Simulation theory: interconnection of quantum chemical calculations and reality</a></li>
<li><a href="../431176/index.html">Microservices, APIs, and Innovations: All the Power of the API</a></li>
<li><a href="../431178/index.html">Parasite words in English</a></li>
<li><a href="../431184/index.html">WIFI multi-hop mesh with Mesh Connex technology</a></li>
<li><a href="../431186/index.html">Designing Types: How to make invalid states ineffable on C #</a></li>
<li><a href="../431188/index.html">Technical aspects of Internet blocking in Russia. Problems and Prospects</a></li>
<li><a href="../431190/index.html">How to assess the level of an SEO company without entering into an agreement with it</a></li>
<li><a href="../431192/index.html">Firecracker introduces AWS - ‚Äúmicro-virtualization‚Äù for Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>