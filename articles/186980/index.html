<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32F4Discovery - we connect the camera via DCMI interface</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="STM32F4Discovery - we connect the camera via DCMI interface 

 Once, when connecting a camera from a mobile phone to an STM32F407VGT6 microcontroller ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32F4Discovery - we connect the camera via DCMI interface</h1><div class="post__text post__text-html js-mediator-article"><h4>  STM32F4Discovery - we connect the camera via DCMI interface </h4><br><br><img align="left" src="https://habrastorage.org/storage2/019/9f9/9ce/0199f99ce27d7c60203b70d278c6e627.png">  Once, when connecting a camera from a mobile phone to an <b>STM32F407VGT6</b> microcontroller (which takes place on the <b>STM32F4Discovery</b> board), I did not even think that this controller has a special hardware interface for this case.  Maybe I didn‚Äôt read the datasheet inattentively, but I always thought that only the chips in the <b>UFBGA176</b> and <b>LQFP packages</b> with 144 legs have a <b>DCMI</b> interface.  However, not so long ago, I discovered the voiced detail: the 100-legged <b>STM32F407</b> also has DCMI on board. <br>  Being a great lover of studying and jointly launching various mobile iron (in particular, LCD and cameras) with the MK, I simply could not get past such a discovery, and decided to fill this gap in studying the STM32 periphery.  Actually, this material is devoted to the description of the implementation of the arisen venture. <a name="habracut"></a><br><br><h5>  <b>Just a little theory.</b> </h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, you need to imagine what is at stake - or rather, what a CMOS-camera is, and with what it is eaten. <br>  This type of camera provides information output from the sensor in digital form: RGB, YCbCr, and also in compressed form - JPEG.  Different cameras have their own nuances in terms of capabilities, I will consider a very specific case of a camera with a small resolution (VGA, 640x480), which I had pulled out from time immemorial from the <b>Siemens C72</b> phone ( <b>PixelPlus PO2030N</b> sensor).  This camera is the most suitable for studying in view of the simplicity of functioning and the type belonging to a more or less common one.  A long time ago, I eliminated a small board for it (for greater convenience of connection) - with a 2.8 V stabilizer and pull-up resistors on the <b>I2C</b> bus.  Here it is (cable and camera connector hidden under the casing). <br><br><img src="https://habrastorage.org/storage2/cdd/85c/ecb/cdd85cecb310ea068d1545c67e3dde87.png" alt="image"><br><br>  In addition to nuances in the field of data format, cameras may also differ in the number of synchronization pins.  Most (in my opinion) sensors have special conclusions on line and frame synchronization;  but there are cameras that have only a pixel strobe output, and they let know about the beginning of a new line / frame with the help of special transmitted codes (for example, <b>0x00</b> or <b>0xFF</b> ).  The camera that I have available has external synchronization pins. <br>  You can estimate the approximate schematic image of the camera as a block. <br><br><img src="https://habrastorage.org/storage2/0bf/b66/688/0bfb66688daea6e65b596d469f4a0c12.png"><br><br>  For the most part, CMOS cameras are controlled via the <b>I2C interface</b> (although I have come across devices that are controlled via the <b>UART</b> ).  I2C is used to configure various parameters, such as: resolution, color gamma, output data format, etc. <br>  The <b>EXTCLK</b> output is the clocking of the camera that needs to be provided from the outside.  <b>DCLK</b> is a strobe signal, on the leading or trailing edge of which data is recorded on the camera data bus (for example, data bytes of one pixel of the matrix, or data bytes of "half-pixel" if the camera operates in <b>RGB565</b> mode).  <b>HSYNC</b> is a horizontal synchronization signal indicating the beginning of a new line, and <b>VSYNC</b> is a synchronization signal whose active level indicates the beginning of a new frame.  Conclusions <b>D0..D7</b> - data bus;  As a rule, in such cameras it is eight-bit. <br>  Now more about the synchronization signals. <br><br><img src="https://habrastorage.org/storage2/159/aef/938/159aef9387f0ea7ddaf7436ec81fcf0d.png"><br><br>  The graphs show that the camera is configured to <b>activate the DCLK</b> signal only during the active <b>HSYNC</b> phase (this is exactly what interests us, the clock signal during the ‚Äúline feed‚Äù period is not interesting for us).  If the camera is configured for a resolution of 320x240, then 320 <b>DCLK</b> pulses fit into the period of each <b>HSYNC</b> pulse, and 240 <b>HSYNC</b> during the <b>VSYNC</b> period. <br>  When you increase the scale, we see what is happening on the data bus. <br><br><img src="https://habrastorage.org/storage2/f23/cdd/04c/f23cdd04cface68b9b0d3b71c39d694a.png"><br><br>  On the leading edge (in this case), a byte is removed from the data bus, which can be sent directly to the display for display, or ‚Äúadded‚Äù to a buffer for further processing. <br><br><h5>  <b>In theory, everything is more or less clear, now about the <b>DCMI</b> interface of the <b>STM32</b> microcontroller.</b> </h5><br><br>  The <b>DCMI</b> interface is able to work with a data bus with a width of up to 14 bits, it supports both hardware and software synchronization, as well as data formats: YCbCr, RGB and JPEG. <br>  In addition, <b>DCMI</b> contains a <b>FIFO</b> buffer, it has the ability to configure interrupts (including filling the data register) and setting up work via <b>DMA</b> . <br><br><img src="https://habrastorage.org/storage2/990/dbb/326/990dbb3269c59873fd044da950a6e8c9.png"><br><br>  Interrupts from <b>DCMI</b> can be <b>triggered</b> when the following conditions <b>occur</b> : line termination, frame termination, receiving buffer overflow, detection of a synchronization error (during internal synchronization). <br>  The absence of a special camera clock output introduced me to some surprise.  I do not know for what reasons the developers of <b>SGS Microelectronics</b> refused it, but for me, it would be very convenient to have, for example, a tunable clock source. <br>  Personally, I used a general-purpose timer-counter, switched on in the PWM mode to generate a 4 MHz square wave.  Of course, I won‚Äôt get a big FPS, but I‚Äôll just make a reservation - the display I use is not connected to the <b>FSMC</b> , so the longest function in the whole circuit is the LCD display function, therefore, at a higher frequency, the display is disrupted .  Therefore, before unloading, I turn off the timer, and after it - I turn on the timer again. <br>  The <b>DCMI</b> hardware module contains, in addition to the data register, ten control / status registers.  These are: control register ( <b>DCMI_CR</b> ), status register ( <b>DCMI_SR</b> ), interrupt status register ( <b>DCMI_RIS</b> ), interrupt enable register ( <b>DCMI_IER</b> ), interrupt mask register ( <b>DCMI_MIS</b> ), interrupt flag reset register ( <b>DCMI_ICR</b> ), internal synchronization code register ( <b>DCMI_ESCR</b> ) , the internal synchronization code mask reset register ( <b>DCMI_ESUR</b> ), the register of starting values ‚Äã‚Äãwhen capturing a part of the frame ( <b>DCMI_CWSTRT</b> ) and the fragment fragment size register in CropWindow mode ( <b>DCMI_CWSIZE</b> ).  And, of course, the data register is <b>DCMI_DR</b> . <br>  In this case, the registers related to the capture of part of the frame and internal synchronization do not interest us.  I also decided to leave the interrupts so far, so the only <b>thing</b> worth considering in more detail is the <b>DCMI_CR</b> control <b>register</b> and the <b>DCMI_SR</b> status <b>register</b> . <br><br>  The control register allows us to fully customize the format of interaction with the camera: the size of the data bus, the active levels of the <b>HSYNC</b> and <b>VSYNC lines</b> , etc. <br><br><img src="https://habrastorage.org/storage2/de2/12b/e57/de212be5787e089d110810d75797c0a1.png"><br><br>  In order.  The <b>ENABLE</b> bit - needless to say, the inclusion of the interface in the work.  <b>EDM</b> field ( <b>extended data mode</b> ) - data bus size;  The tire of my camera is eight-bit, so this field should be set to the value ‚Äú00‚Äù.  The <b>FCRC</b> ( <b>frame capture rate control</b> ) field allows you to adjust the FPC a bit: 00 ‚Äî all incoming frames are captured, 01 is every second frame, 10 is every fourth.  The <b>VSPOL</b> and <b>HSPOL bits</b> are the active levels of frame and line synchronization lines.  Active levels are ignored and data are not captured during active periods, this should be taken into account.  <b>PCKPOL</b> - bit of active pixel strobe level - on which edge of the signal to read data from the bus: front or back.  <b>ESS</b> is the bit for selecting the synchronization method: external or internal.  <b>JPEG</b> ‚Äî select incoming data format ‚Äî compressed or not.  <b>CROP</b> - bit for selecting the frame fragment capture ( <b>crop window</b> ).  If this bit is set to one, the interface will capture the data in the window defined by the values ‚Äã‚Äãin the <b>DCMI_CWSTRT</b> and <b>DCMI_CWSIZE registers</b> . <br><br><h5>  <b>So, set up.</b> </h5><br>  Since I am used to using the standard periphery library from ST (although I never use it in the first iterations of working with the new periphery, until I dig into the registers with "pens"), I‚Äôll bring up the settings using the library. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCMIInitialRoutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DCMI_InitTypeDef DCMI_CamType; DCMI_DeInit(); DCMI_CamType.DCMI_CaptureMode = DCMI_CaptureMode_Continuous; DCMI_CamType.DCMI_CaptureRate = DCMI_CaptureRate_All_Frame; DCMI_CamType.DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b; DCMI_CamType.DCMI_SynchroMode = DCMI_SynchroMode_Hardware; DCMI_Init(&amp;DCMI_CamType); DCMI_CaptureCmd(ENABLE); DCMI_Cmd(ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Actually, for my needs, it was possible not to touch a single bit in the <b>DCMI_CR</b> register ‚Äî by default, they were reset ‚Äî except for the <b>CAPTURE</b> and <b>ENABLE</b> bits. <br>  The interface is configured and ready to go.  After the clock signal is sent to the camera, the interface will begin to accept the data we need to process. <br>  The task to start with I set myself as simple as possible - to display the image on the display, so that the data processing will be minimal. <br>  The status register <b>DCMI_SR</b> will help us in timely reading of data from the receiving buffer. <br><br><img src="https://habrastorage.org/storage2/9de/7dc/6df/9de7dc6dfc4209a6f183c0b77e59adce.png"><br><br>  A very meager number of bits is available for reading - only three.  The <b>HSYNC</b> and <b>VSYNC bits</b> indicate the status of the corresponding lines: active phase, or line feed;  The most interesting is the <b>FNE</b> bit.  He tells us to fill the buffer with data.  Or not filling. <br>  Checking in the constant cycle the state of the <b>FNE</b> bit in the <b>DCMI_SR</b> , we learn about the arrival of data in the receiving thirty-two-bit buffer.  In my case, the data will be located as follows: <br><br><img src="https://habrastorage.org/storage2/68f/337/86c/68f33786c0a6515116456140d1835b0b.png"><br><br>  When setting the <b>FNE</b> bit in the status register <b>DCMI_SR</b> , the receiving buffer will contain four bytes, the data of two adjacent pixels: <b><i>Byte0</i></b> and <b><i>Byte1</i></b> - 16 bits of pixel <b>n</b> , and <b><i>Byte2</i></b> and <b><i>Byte3</i></b> - 16 bits of pixel <b>n + 1</b> .  I just need to combine them and send them for display on the display.  So, this is how the main loop looks like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((DCMI_GetFlagStatus(DCMI_FLAG_FNE)) == RESET); <span class="hljs-comment"><span class="hljs-comment">//Waiting for the buffer TIM_Cmd(TIM3, DISABLE); //Disable CAM clock cam_grab = (DCMI-&gt;DR); //Reading buffer SendDataByte_LCD (cam_grab); cam_grab = (DCMI-&gt;DR)&gt;&gt;16; //Reading 2nd part of the buffer SendDataByte_LCD (cam_grab); TIM_Cmd(TIM3, ENABLE); //Enable CAM clock again }</span></span></code> </pre><br>  That is, I am waiting for the <b>FNE</b> bit in the <b>DCMI_SR</b> status register to be <b>set</b> , and after that, I unload 16 bits of data into the display in two <b>steps</b> . <br>  At this point, I would like to come to a logical conclusion, but it was not there. <br>  After flashing and restarting the MK on the display, I saw ... no, I saw my very own familiar physique, but in black and blue shades.  Red and green colors were completely absent. <br>  After a brief clash with the debager, the following was discovered: the interface data register contained only 16 data bits of a single pixel, with the lower 8 bits located at <b><i>Byte0</i></b> (see figure above), and the older ones at <b><i>Byte2</i></b> .  The spaces <b><i>Byte1</i></b> and <b><i>Byte3</i></b> were empty.  Until now, I did not understand where such a discrepancy is from the documentation of reality, and, perhaps, I will contact STM. <br>  As a result, it was possible to obtain an image from the camera using the <b>DCMI</b> interface, although not without some difficulties.  In the picture I bring a photo of the display on which the image of the <b>STM32F3Discovery</b> demo <b>boards</b> from my camera was displayed. <br><br><img src="https://habrastorage.org/storage2/6f6/634/1bc/6f66341bc90a03b33f15de3cfd61130c.png"><br><br>  And here is what we will see on the pins of <b>EXTCLK</b> , <b>PIXCK</b> , <b>HSYNC</b> and <b>VSYNC</b> , if we connect a logic analyzer. <br><br><img src="https://habrastorage.org/storage2/530/610/cd2/530610cd28d99ee6cef684269e1d85bf.png"><br><br>  Everything looks exactly as expected: 240 <b>HSYNC</b> pulses fit in the duration of one <b>VSYNC</b> , 320 <b>PIXCK</b> - in one <b>HSYNC</b> .  In the active phase of the <b>HSYNC, the</b> camera does not issue <b>PIXCK</b> signals - exactly as it was configured. <br>  Generally speaking, the interface has somewhat disappointed me.  The lack of a ‚Äúregular‚Äù leg of the clocking of the camera, the absence of more or less interesting built-in chips (what about the hardware JPEG encoder?), And even dancing with a tambourine around a half <b>FIFO</b> ... <br>  <b>While</b> organizing the work with the camera on the <b>PIXCK</b> , <b>HSYNC</b> and <b>VSYNC</b> interrupts, I didn‚Äôt have as much smut as I had while working with the camera using hardware <b>DCMI</b> . <br>  Nevertheless, in the near future I will try to capture the frame, compress it in <b>JPEG</b> , and try to write a picture on the SD card. <br>  Ps.  Just in case, I give a link to the project for <b>Code :: Blocks</b> - it will suddenly come in handy to someone. <br><br>  <a href="https://www.dropbox.com/sh/nfjdwqsdzlr7djm/9v2mQM8uYV">www.dropbox.com/sh/nfjdwqsdzlr7djm/9v2mQM8uYV</a> </div><p>Source: <a href="https://habr.com/ru/post/186980/">https://habr.com/ru/post/186980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186960/index.html">FlexCloud - Home P2P cloud of the future</a></li>
<li><a href="../186962/index.html">Technopark Mail.Ru from the inside</a></li>
<li><a href="../186968/index.html">Google fixed a vulnerability that allowed to get full remote access to Glass</a></li>
<li><a href="../186976/index.html">HideOut: games with augmented reality</a></li>
<li><a href="../186978/index.html">Radioastron rips templates</a></li>
<li><a href="../186988/index.html">Difficult in the obvious: how we made the call interface to Yandex.Shell</a></li>
<li><a href="../186990/index.html">Parse "Opposition - Military Chronicle" (1996-1997, Doc)</a></li>
<li><a href="../186992/index.html">Good morning</a></li>
<li><a href="../186994/index.html">New API HeadHunter and termination of support for API 1.0</a></li>
<li><a href="../186998/index.html">Why you should not overclock the timer Windows or megawatts wasted</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>