<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Labeled pointers, or how to fit an object in one inte</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have ever written an application in Objective-C, you should be familiar with the NSNumber class, a wrapper that turns a number into an object. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Labeled pointers, or how to fit an object in one inte</h1><div class="post__text post__text-html js-mediator-article">  If you have ever written an application in Objective-C, you should be familiar with the <b>NSNumber</b> class, a wrapper that turns a number into an object.  A classic use case is the creation of a numeric array filled with objects of the form <b>[NSNumber numberWithInt: someIntValue];</b>  . <br><br>  It would seem, why create an entire object, allocate memory for it, then clean it up if we need an ordinary small int?  Apple also thought so, and therefore NSNumber is often not an object at all, and behind the pointer to it lies ... emptiness. <br><br>  If you're wondering how this is how it turns out, and what's the point about tagged pointers - welcome to the cat! <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  A bit of pointer alignment theory </h4><br>  Everyone knows that a pointer is a normal int, which the system takes as an address in memory.  The variable containing the pointer to the object is an int with a value of the form 0x7f84a41000c0.  The whole nature of "pointing" is how the program uses it.  In C, we can get the index value by simply casting: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *somePointer = ...; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> pointerIntegerValue = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)somePointer;</code> </pre> <br>  <i>( <b>uintptr_t</b> is a standard typdef for integers that is large enough to hold a pointer. This is necessary because the pointer sizes vary depending on the platform)</i> <br><br>  Virtually every computer architecture has such a thing as <i>pointer alignment</i> .  It means that a pointer to a data type must be a multiple of a power of two.  For example, a pointer to a 4-byte int must be a multiple of four.  Violation of restrictions imposed by alignment of pointers can lead to a significant decrease in performance or even a complete crash of the application.  Also, correct alignment is necessary for atomic reading and writing to memory.  In short, alignment of pointers is a serious thing, and you should not try to break it. <br><br>  If you create a variable, the compiler can check the alignment: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; }</code> </pre><br>  However, things are not so simple in the case of dynamically allocated memory: <br><br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *ptr = malloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*ptr));</code> </pre><br>  <i>Malloc</i> has no idea what kind of data it will be, it simply allocates four bytes, not knowing if it is an <i>int</i> , or two <i>short</i> , four <i>char</i> , or something else. <br>  And therefore, in order to observe the correct alignment, it uses a very paranoid approach and returns a pointer aligned so far that this boundary is suitable for absolutely any type of data.  On Mac OS X, <i>malloc</i> always returns pointers aligned on the 16-byte boundary. <br><br>  Due to alignment, unused bits remain in the pointer.  Here is what the hex pointer looks like, evened out by 16 bytes: <br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0</span></span>x------<span class="hljs-number"><span class="hljs-number">-0</span></span></code> </pre><br>  The last digit hex is <i>always</i> zero.  In general, it may be quite a valid pointer that does not comply with these conditions (for example, char *), but the pointer to the object must always end in zero bits. <br><br><h4>  Some theory of tagged pointers </h4><br>  Knowing the empty bits at the end of the pointer, you can go further and try to use them.  Why not use them as an indicator that this is not a real pointer to an object?  Then we could store the data right here, in the pointer itself, without having to allocate expensive memory?  Yes, yes, these are the very labeled pointers. <br><br>  Systems that use labeled pointers perform an additional check ‚Äî they look at the low-order bit, and if it is zero, then we have a real object.  If this is a unit, then we are not an object but something else, and the information from the pointer will have to be extracted in a non-standard way.  Typically, the data type is stored immediately after the low-order bit, and then the data itself follows. <br><br>  This is how a valid binary object would look like: <br><pre> <code class="objectivec hljs">...<span class="hljs-number"><span class="hljs-number">.0000</span></span> ^   </code> </pre><br>  And this is a labeled pointer: <br><pre> <code class="objectivec hljs">....xxx1 ^   </code> </pre><br><br>  All this can be implemented in various ways, but in Objective-C the low bit of the labeled pointer is always one, and the next three indicate the class of the pointer. <br><br><h4>  Application of tagged pointers </h4><br>  Labeled pointers are often used in languages ‚Äã‚Äãwhere everything is an object.  When 3 is agreed, 3 + 4 includes two objects, and even the creation of a third one, the allocation of memory for objects and the extraction of data from them begins to play a significant role in overall performance.  All this fuss with the creation of objects, access to slow memory, entering values ‚Äã‚Äãinto an object that no one uses, many times exceeds the cost of the addition. <br><br>  Using tagged pointers saves us from these adversities for all types that fit in those empty bits.  Small ints are ideal candidates for this role - they take up very little space and are widely used. <br><br>  This is what a regular triple would look like: <br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span></code> </pre><br>  But the troika, hidden in a labeled pointer: <br><pre> <code class="objectivec hljs"> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> <span class="hljs-number"><span class="hljs-number">1011</span></span> ^ ^ ^   | | |    (<span class="hljs-number"><span class="hljs-number">5</span></span>) |  </code> </pre><br>  Here I assumed that the five is used to designate int, but in fact it remains at the discretion of the system, and everything can change at any time. <br><br>  The observant reader probably already noticed that we only have 28 bits left on the 32-bit system and 60 on the 64-bit one.  And the integers can take on large values.  That's right, not every int can be hidden in a labeled pointer, for some you will have to create a full-fledged object. <br><br>  When everything fits in one pointer, there is no need to allocate a separate memory, to clear it.  Also, we simply save a small amount of memory, which we would have to allocate for a separate object.  This may seem insignificant with the addition of three and four, but with a large number of operations on numbers, this increase is very noticeable. <br><br>  The presence of bits indicating the type of data in the pointer makes it possible to store there not only int, but also floating-point numbers, and even several ASCII characters (8 for a 64-bit system).  Even an array with a pointer to one element can fit in a labeled pointer!  In general, any fairly small and widely used data type is an excellent candidate for use within a labeled pointer. <br><br><h5>  Well, enough theory, go to practice! </h5><br>  We will take <a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-06-lets-build-nsnumber.html">MANumber</a> as a basis <a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-06-lets-build-nsnumber.html">‚Äî a</a> custom implementation of NSNumber, and add support for labeled pointers there. <br><habracut><br>  I want to note that labeled pointers are a very, very closed API, so you can't even think about using them in a real project.  Under the definition of an object class, only three bits are allocated - in total, only eight classes can be involved simultaneously.  If you accidentally intersect with the class used by Apple, that's all.  And, due to the fact that this information can change in absolutely any way, at any time, the likelihood that trouble will happen once equals one hundred percent. <br><br>  However, nothing prevents us from playing with them, even if we never have the opportunity to use them safely. <br><br>  Well, let's begin.  The <i>private _objc_insert_tagged_isa</i> function allows <i>you</i> to <i>assign a</i> certain class to a specific tag.  Here is its prototype: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _objc_insert_tagged_isa(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> slotNumber, Class isa);</code> </pre><br>  You transfer the slot number (tag) and the required class to it, and it tells them in a certain table for further use during execution. <br><br>  Virtually any class on labeled pointers needs a close class that will create a normal object in the event that the value does not fit within the pointer.  For NSNumber, these will be particularly large ints and doubles, which are very difficult to push into the pointer, and I will not do this here. <br><br>  For this there are two approaches.  The first is to create two completely different classes, with some common ancestor for the code, which will be repeated in both descendants.  The second is that within the same class we will use different code, depending on the value that we need to keep.  I will use the second approach, so it seemed to me easier for this particular case. <br><br>  To store the value of a variable, I used a <a href="http://cupsofcocoa.com/2011/05/22/objective-c-lesson-14-structs-and-unions/">union</a> : <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> u; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d; };</code> </pre><br>  This is followed by some constants that define the information in the labeled index.  First - the slot number, I took it equal to one: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kSlot = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  I also decided to determine the number of labeled pointers - this is needed to further extract the values: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kTagBits = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  MANumber, in addition to the value itself, stores its type, indicating how to interact with it, and since we need to compress everything to the maximum, and we have only three possible types, I allocated two bits to this: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kTypeBits = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Although I did not implement double support, I still left room for it in order to maintain uniformity with the usual MANumber and facilitate my possible double support in the future. <br><br>  And finally, since the type of integers that we store is long long, it would be nice to know for sure how many bits it takes: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kLongLongBits = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) * CHAR_BIT;</code> </pre><br>  Here, I assume that the pointer type is long long, I did not try to support 32-bit systems. <br><br>  For more convenience, I have written several helper functions.  The first creates a labeled MANumber, taking as input the data type and value: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> TaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> type) {</code> </pre><br>  Let me remind the structure of the labeled pointer.  The low bit is always one.  It is followed by three bits indicating the class of the object, and only then the object data itself.  In our case, these are the two bits that define the type, and after them the value itself.  Here is a string that combines and records all this information using bitwise operations: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ptr = (__bridge <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((value &lt;&lt; (kTagBits + kTypeBits)) | (type &lt;&lt; kTagBits) | (kSlot &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  In connection with the strange double type conversion - I use <a href="http://developer.apple.com/library/ios/">ARC,</a> and he is very selective in this matter.  Therefore, when you convert pointers to objects into pointers to non-objects, a __bridge is needed, and the int pointer will not allow you to convert it to int.  That is why I first convert to void *, and then all this into an object. <br><br>  With this all, and now I return the newly created pointer: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre><br>  Also, I created a function that checks whether a pointer is marked or not.  All she does is check the low-order bit, but because of the stupid double type conversion, she had to be rendered into a separate function. <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> IsTaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> pointer) { uintptr_t value = (uintptr_t)(__bridge <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)pointer; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Finally, a function that extracts all the information from a labeled pointer.  Since C does not support returning multiple values ‚Äã‚Äãat once, I created a special structure for this: it contains the type and the value itself <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TaggedPointerComponents { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> type; };</code> </pre><br>  This function first converts the pointer to an int, using the same type conversion, only in the opposite direction: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TaggedPointerComponents ReadTaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> pointer) { uintptr_t value = (uintptr_t)(__bridge <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)pointer;</code> </pre><br>  Then we start to extract the necessary information.  The first four bits can be ignored, and the value is extracted by a simple shift: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TaggedPointerComponents components = { value &gt;&gt; (kTagBits + kTypeBits),</code> </pre><br>  To get the type, you must not only move, but also apply a mask <br><pre> <code class="objectivec hljs"> (value &gt;&gt; kTagBits) &amp; ((<span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; kTypeBits) - <span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre><br>  As a result, all components are received, and we simply return them in the form of a structure. <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> components; }</code> </pre><br>  At some point, we have to tell the runtime that we are a class that runs on labeled pointers by calling the <i>_objc_insert_tagged_isa</i> function.  Best suited for this + initialize.  For security reasons, Objective-C Runtime does not like to overwrite a slot, and therefore you first need to write nil, and only then our new class: <br><pre> <code class="objectivec hljs"> + (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)initialize { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> == [MANumber <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]) { _objc_insert_tagged_isa(kSlot, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); _objc_insert_tagged_isa(kSlot, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } }</code> </pre><br>  Now we can proceed to the process of creating labeled pointers.  I wrote two methods: <i>+ numberWithLongLong:</i> and <i>+ numberWithUnsignedLongLong:.</i>  These methods attempt to create objects on labeled pointers, and if the value is too large, they simply create ordinary objects. <br><br>  These methods can create a labeled pointer only for a specific set of values ‚Äã‚Äã- they must fit in kLongLongBits - kTagBits - kTypeBits, or 58 bits in a 64-bit system.  One bit is needed to designate a sign, for a total, the maximum value of long long is 2 in 57, the minimum in -57. <br><pre> <code class="objectivec hljs"> + (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)numberWithLongLong: (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)value { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> taggedMax = (<span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; (kLongLongBits - kTagBits - kTypeBits - <span class="hljs-number"><span class="hljs-number">1</span></span>)) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> taggedMin = -taggedMax - <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  It remains the most simple.  If the value is outside the limits, we perform the usual dance with alloc / init.  Otherwise, we create a labeled pointer with the given value and the class INT: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(value &gt; taggedMax || value &lt; taggedMin) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> alloc] initWithLongLong: value]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TaggedPointer(value, INT); }</code> </pre><br>  For unsigned long long, everything is the same, except for increasing the set of values ‚Äã‚Äãdue to an unnecessary sign bit: <br><pre> <code class="objectivec hljs"> + (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)numberWithUnsignedLongLong:(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)value { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> taggedMax = (<span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; (kLongLongBits - kTagBits - kTypeBits)) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(value &gt; taggedMax) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> alloc] initWithUnsignedLongLong: value]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)TaggedPointer(value, <span class="hljs-built_in"><span class="hljs-built_in">UINT</span></span>); }</code> </pre><br>  Now we need an accessor type for our pointers so that we can simply call the [self type], without worrying about the bits, the mask, and so on.  All he does is check the pointer with the IsTaggedPointer function, and if it is tagged, call ReadTaggedPointer.  If the pointer is normal, simply return _type: <br><pre> <code class="objectivec hljs"> - (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)type { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsTaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadTaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>).type; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _type; }</code> </pre><br>  The accessor of values ‚Äã‚Äãwill be somewhat more complicated due to difficulties with the sign.  First of all, let's check if it‚Äôs a regular pointer: <br><pre> <code class="objectivec hljs"> - (<span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Value)value { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!IsTaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value; }</code> </pre><br>  For the tagged ones, we will first have to read the value using ReadTaggedPointer.  At the output, we have unsigned long long, so we have to work a little if the value really has a sign. <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value = ReadTaggedPointer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>).value;</code> </pre><br>  Create a local variable of the union Value type for the return value: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Value v;</code> </pre><br>  If it is unsigned, then everything is simple - put the value in v, and that's it: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> type]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == <span class="hljs-built_in"><span class="hljs-built_in">UINT</span></span>) { vu = value; }</code> </pre><br>  With signed, everything is not so simple.  First, let's check the sign bit - it is hidden in bit 57: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == INT) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> signBit = (<span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; (kLongLongBits - kTagBits - kTypeBits - <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  If the bit is equal to one, then all the bits that follow 57 bits need to be filled with ones, this is necessary for the given long long to be a valid 64-bit negative number.  This procedure is called sign extension, in short its essence is this: negative numbers begin with ones, and the first zero is the first significant bit.  Therefore, to expand a negative number, you simply add units to the left: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(value &amp; signBit) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> mask = (((<span class="hljs-number"><span class="hljs-number">1</span></span>ULL &lt;&lt; kTagBits + kTypeBits) - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; (kLongLongBits - kTagBits - kTypeBits)); value |= mask; }</code> </pre><br>  With positive numbers, you do not need to do anything - they are already filled with zeros on the left.  So just fill in v: <br><pre> <code class="objectivec hljs"> vi = value; }</code> </pre><br>  If we got some other type, then things are bad, we will have to throw out: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> abort();</code> </pre><br>  As a result, we return v: <br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v; } }</code> </pre><br>  Having written all this code, we get the opportunity to work with the new MANumber, as with the usual one, with the only difference being that we will have to access the values ‚Äã‚Äãnot directly, but through accessor methods.  We can even compare labeled and regular MANumber using <i>compare:</i> and <i>isEqual:.</i> <br><br><h4>  findings </h4><br>  Labeled pointers are a great addition to the Cocoa and Objective-C runtime, which allows you to significantly increase the speed of work and reduce memory costs when working with NSNumber. <br><br>  We can write our own classes that work with labeled pointers to shed light on the internal structure of NSNumber, however, due to the very limited number of free slots, there is no way to use them in real code.  This is purely Cocoa's pre -rigative, greatly accelerating its work. <br>  Well, it runs perfectly, and we can only be glad that inside this simple NSNumber there is such a wonderful mechanism. <br><br>  <i>(Free translation of <a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">fresh Friday Q &amp; A</a> by Mike Ash)</i> <br><h5>  UPDATE: </h5>  As promised, the practical application of labeled pointers was not long in coming. </habracut></div><p>Source: <a href="https://habr.com/ru/post/149012/">https://habr.com/ru/post/149012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149001/index.html">Selective logging of SQL queries in Hibernate</a></li>
<li><a href="../149004/index.html">Hot summer build Opera 12.50</a></li>
<li><a href="../149006/index.html">We do it yourself Single-Side Arduino with a COM port on board</a></li>
<li><a href="../149007/index.html">Destructive printers for the healthcare modernization program</a></li>
<li><a href="../149010/index.html">Masking numeric values ‚Äã‚Äãusing autoNumeric and Knockout</a></li>
<li><a href="../149014/index.html">Background Image Design of the Start Screen in Windows 8</a></li>
<li><a href="../149015/index.html">Unpacking Perl2Exe</a></li>
<li><a href="../149016/index.html">How can Inkscape be useful for web developers?</a></li>
<li><a href="../149017/index.html">Siemens builds a very large wind turbine</a></li>
<li><a href="../149019/index.html">Stock robot in 45 minutes led to a loss of 440 million dollars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>