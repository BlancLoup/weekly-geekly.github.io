<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Headless Chrome Works</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Already from the name it is clear that a headless browser is something without a head. In the context of the frontend, it is an indispensable develope...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Headless Chrome Works</h1><div class="post__text post__text-html js-mediator-article">  Already from the name it is clear that a headless browser is something without a head.  In the context of the frontend, it is an indispensable developer tool with which you can test the code, check the quality and conformity of the layout.  Vitaly Slobodin on Frontend Conf decided that it was necessary to get acquainted with the device of this tool more closely. <br><br>  Under the cut are the components and features of Headless Chrome, interesting scenarios for using Headless Chrome.  The second part about Puppeteer is a convenient Node.js library for managing Headless mode in Google Chrome and Chromium. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Vitaly Slobodin - a former PhantomJS developer - the one who closed it and buried it.  Sometimes Konstantin Tokarev ( <u><a href="https://github.com/annulen">annulen</a></u> ) helps in the "resurrected" version of QtWebKit - the very QtWebKit, where there is support for ES6, Flexbox and many other modern standards. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Vitali loves to explore browsers, digging into WebKit, Chrome, and so on, in his free time.  About browsers today and talk, namely about the headless browsers and their entire family of ghosts. <a name="habracut"></a><br><br><h2>  <strong>What is a headless browser?</strong> <br></h2><br>  Already from the name it is clear that this is something without a head.  In the context of the browser, this means the following. <br><br><ol><li>  It has <strong>no real content rendering</strong> , that is, it <strong>draws</strong> everything in memory. </li><li>  Due to this, it <strong>consumes less memory</strong> , because you do not need to draw pictures or gigabyte PNGs that people are trying to put on the backend using a bomb. </li><li>  It <strong>works faster</strong> because it doesn‚Äôt need to draw anything on a real screen. </li><li>  It has a <strong>software interface for management</strong> .  You ask - it does not have an interface, buttons, windows?  How to manage it?  Therefore, of course, it has an interface for management. </li><li>  An important feature is the <strong>ability to install on a bare Linux server</strong> .  This is necessary so that if you have a freshly installed Ubuntu or Red Hat, you can just throw a binary there or put a package, and the browser will work out of the box.  No shamanism or voodoo magic is needed. </li></ol><br>  This is how a typical WebKit-based browser looks like.  You can not get a grasp of the components - it's just a visual image. <br><br><img src="https://habrastorage.org/webt/un/7p/zj/un7pzjwjsn1a3psu2augn59jmj0.jpeg"><br><br>  We are only interested in the top Browser UI component.  This is the same user interface - windows, menus, pop-up notifications and everything else. <br><br><img src="https://habrastorage.org/webt/14/ds/oa/14dsoabrnydhu5hb6iovu_gd2m8.jpeg"><br><br>  It looks like a headless browser.  Notice the difference?  We completely remove the user interface.  He is no more.  <strong>Only the browser remains</strong> . <br><br>  Today we will talk about Headless Chrome ().  What is the difference between them?  In fact, Chrome is a branded version of Chromium, which has proprietary codecs, the same H.264, integration with Google services and everything else.  Chromium is just an open implementation. <br><br><img src="https://habrastorage.org/webt/ti/14/-e/ti14-etgpuf8lm5euapnu1qk3rs.jpeg"><br><br>  Date of birth Headless Chrome: 2016.  If you came across it, you can ask me a tricky question: ‚ÄúHow so, I remember the news of 2017?‚Äù The fact is that a team of engineers from Google contacted the developers of PhantomJS in 2016, when they just started to implement Headless -mode in chrome.  We wrote whole gugldoki, how we will implement the interface and stuff.  Then Google wanted to make the interface fully compatible with PhantomJS.  It was only later that a team of engineers came to the decision not to make such compatibility. <br><br>  About the management interface (API), which is the Chrome DevTools protocol, we'll talk later and see what you can do with it. <br><br>  This article will be built on the principle of the pyramid Puppeteer (with the English. Puppeteer).  A good name is chosen - the puppeteer is the one who controls all the others! <br><br><img src="https://habrastorage.org/webt/4y/2i/lq/4y2ilqrqu3fxx8lrinrjp90zgfq.jpeg"><br><br>  At the base of the pyramid is Headless Chrome - headless Chrome - what is it? <br><br><h2>  <strong>Headless chrome</strong> <br></h2><br><img src="https://habrastorage.org/webt/tx/id/ql/txidqlimkcdam_vcyah-fu4vlk0.jpeg"><br><br>  In the center - Headless browser - the same Chromium or Chrome (usually Chromium).  It has the so-called Renders (RENDERER) - the processes that draw the contents of the page (your window).  Moreover, each tab needs its own renderer, so if you open a lot of tabs, then Chrome will launch the same number of processes for drawing. <br><br>  Over all this is your application.  If we take Chromium or Headless Chrome, then on top of it will be Chrome, or some kind of application in which you can embed it.  The closest analogue can be called Steam.  Everyone knows that in essence Steam is just a browser to the Steam site.  He is certainly not headless, but looks like this scheme. <br><br>  There are 2 ways to embed headless Chrome in your application (or use it): <br><br><ol><li>  Standard when you take a <strong>Puppeteer</strong> and use Headless Chrome. <br></li><li>  When you take a component of the <strong>Headless library</strong> , that is, a library that implements headless mode, and embeds it in your application, say, in C ++. <br></li></ol><br>  You ask why C ++ is on the front end?  The answer is DevTools C ++ API.  You can differently implement and use the power of headless Chrome.  If you use Puppeteer, communication with a headless browser will be done via web sockets.  If you embed the Headless library in a desktop application, you will use the native interface, which is written in C ++. <br><br>  But besides all this, you still have additional things, including: <br><br><ul><li>  <strong>Custom networking</strong> - custom implementation of interaction with the network.  Suppose you work in a bank or in a government structure that consists of three letters and starts with ‚ÄúF‚Äù, and you use a very clever authentication or authorization protocol, which is not supported by browsers.  Therefore, you may need a custom handler for your network.  You can simply take your already implemented library and use it in Chrome. </li><li>  <strong>Mojo modules</strong> .  The closest analogue of Mojo are the native binding in Node.js to your native libraries, written in C ++.  Mojo does the same thing - you take your native library, write the Mojo interface for it, and then you can call the methods of your native library in your browser. </li></ul><br><h3>  Chromium components <br></h3><br><img src="https://habrastorage.org/webt/zh/-x/jf/zh-xjfbpq4mjz2ntcwr_tjriuhe.jpeg"><br><br>  Again I hear the tricky question: ‚ÄúWhy do I need this terrible scheme?  I am writing under (insert the name of your favorite framework). " <br><br><blockquote>  I believe that a developer should know how his tool works.  If you are writing under React, you need to know how React works.  If you write under Angular, you should know that Angular is under the hood. <br></blockquote><br>  Because in which case, say, a fatal mistake or a very serious bug in production, you have to deal with the ‚Äúguts‚Äù, and you can just get lost there - where, what and how.  If you, for example, write tests or use Headless Chrome, you can also face some of its odd behavior and bugs.  Therefore, I will briefly tell you what components Chromium has.  When you see a large stack trace, you will already know which way to dig and how it can be fixed. <br><br>  The lowest level of the <strong>Platform layer</strong> .  Its components are: <br><br><ul><li>  <strong>Ozone</strong> , the abstract window manager in Chrome, is what the window manager of the operating system interacts with.  On Linux, this is either X-server or Wayland.  On Windows, this is the windows window manager. </li><li>  <strong>Scheduler</strong> is the same scheduler without which we are nowhere, because we all know that Chrome is a multi-process application, and we need to somehow manage all the threads, processes and everything else. </li><li>  <strong>Net</strong> - the browser should always have a component to work with the network, for example, HTTP parsing, creating headers, editing, etc. </li></ul><br>  <strong>Content layer</strong> is the largest component in Chrome.  It includes: <br><br><ul><li>  <strong>Blink</strong> is a WebCore based web engine.  It can take HTML as a string, parse, execute javascript and that's it.  He doesn‚Äôt know anything else anymore: neither work with the network, nor draw - all this happens on top of Blink. <br>  Blink includes: a heavily modified version of WebCore - a web engine for working with HTML and CSS;  V8 (JavaScript engine);  as well as an API for all the extensions we use in Chrome, for example, the ad blocker.  It also includes the DevTools protocol. <br></li><li>  <strong>Content API</strong> is an interface with which you can very easily use all the features of the web engine.  Since there are so many things inside Blink (probably more than a million interfaces), in order not to get lost in all these methods and functions, we need a Content API.  You enter HTML, the engine will automatically process it, parse the DOM, build OM OM, execute JavaScript, start timers, handlers and everything else. <br></li></ul><br>  <strong>Headless layer</strong> - a headless browser level: <br><br><ul><li>  <strong>Headless library</strong> . </li><li>  <strong>Embedder API</strong> interface for embedding Headless library into the application. </li><li>  <strong>Client API</strong> is the interface that Puppeteer uses. </li></ul><br>  <strong>Application layer</strong> : <br><br><ul><li>  Your application ( <strong>Embedding app</strong> ); </li><li>  Gadgets, for example, <strong>Headless shell</strong> . </li></ul><br>  Now let's go up from the depths a little higher, activate - now the front end will go. <br><br><img src="https://habrastorage.org/webt/_p/p6/10/_pp610df2doffm9nfysj-62ioea.jpeg"><br><br><h3>  Chrome DevTools protocol <br></h3><br>  We all came across the Chrome DevTools protocol because we use the Chrome developer panel or a remote debugger - the same development tools.  If you run the developer‚Äôs tools remotely, communication with the browser takes place using the DevTools protocol.  When you set up a debugger, see code coverage, use geolocation or something else - everything is managed with DevTools. <br><br><img src="https://habrastorage.org/webt/qe/wy/2b/qewy2b3vwphvwanus0zqqnnxeq4.jpeg"><br><br>  In fact, the DevTools protocol itself has a huge number of methods.  Your developer tool does not have access, probably, to 80% of them.  Actually there you can do everything! <br><br>  Let's take a look at what this protocol is.  In fact, it is very simple.  It has 2 components: <br><br><ol><li>  DevTools target ‚Äî the tab you are inspecting; <br></li><li>  DevTools client - let's say this is a developer panel that is running remotely. <br></li></ol><br><img src="https://habrastorage.org/webt/-a/t8/ch/-at8chx2k1wsarzbzqhxtftflay.jpeg"><br><br>  They communicate using simple JSON: <br><br><ul><li>  There is a command identifier, the name of the method to be executed, and some parameters. </li><li>  We send a request and get a response, which also looks very simple: an identifier that is needed because all the commands that are executed using the protocol are asynchronous.  So that we can always compare which answer to which team came to us, we need an identifier. </li><li>  Is there a result.  In our case, it is a result object with the following attributes: <strong>type:</strong> <strong>"number",</strong> <strong>value:</strong> <strong>2,</strong> <strong>description:</strong> <strong>"2"</strong> , an exception was not thrown: <strong>wasThrown:</strong> <strong>false.</strong> <br></li></ul><br>  But among other things, your tab can send events back to you.  Suppose that when an event occurred on a page, or there was an exception on a page, you will receive a notification via this protocol. <br><br><img src="https://habrastorage.org/webt/-f/nc/8g/-fnc8gvu6h9dy5p5ovh3wf0v6ua.jpeg"><br><br><img src="https://habrastorage.org/webt/h0/tx/ud/h0txudupxhjb8brbckihbe7wzum.jpeg"><br><br><h2>  <strong>Puppeteer</strong> <br></h2><br>  You can install Puppeteer with your favorite package manager - be it yarn, npm or whatever. <br><br>  It is also easy to use it - just request it in your Node.js-script, and already, in fact, you can use it. <br><br><img src="https://habrastorage.org/webt/pi/ia/or/piiaoriro3hvbrm_yhvd1h-scq4.jpeg"><br><br>  Under the link <a href="https://try-puppeteer.appspot.com/">https://try-puppeteer.appspot.com</a> you can write a script directly on the site, execute it and get the result directly in the browser.  All this will be implemented using Headless Chrome. <br><br>  Consider the simplest script under Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch() ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'http://devconf.ru/'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.emulateMedia(<span class="hljs-string"><span class="hljs-string">'screen'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.pdf({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'./devconf.pdf, printBackground: true }); await browser.close() ; })();</span></span></code> </pre> <br>  Here we just open the page and print it in PDF.  Let's see the work of this script in real time: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Everything will be cool, but it is not clear what is inside.  Of course, we have a headless browser, but we see nothing.  Therefore, the Puppeteer has a special flag called headless: false: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({ <span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre><br>  It is needed to launch a headless browser in headful mode, when you can see a window and see what happens to your page in real time, that is, how your script interacts with your page. <br><br><img src="https://habrastorage.org/webt/qz/oo/ie/qzooiejebek5gqaww2gw9tv0sgc.jpeg"><br><br>  This is what the same script will look like when we add this flag.  On the left, a browser window appears - more clearly. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Pluses of Puppeteer:</strong> <br><br>  + This is the Node.js library for headless Chrome. <br>  + Support for legacy versions of Node.js&gt; = 6. <br>  + Easy installation. <br>  + High-level API to control this whole gigantic machine. <br><br>  Headless Chrome installs easily and without interfering with the system.  When you first install, Puppeteer downloads the Chromium version and installs it directly into the node_modules folder just for your architecture and OS.  You do not need to download anything extra, it does it automatically.  You can also use your favorite version of Chrome, which is installed on your system.  This can also be done - Puppeteer provides you with this API. <br><br>  Unfortunately, there are also disadvantages, if we take exactly the basic installation. <br><br>  <strong>Cons Puppeteer</strong> : <br><br>  - <strong>No top-level functions</strong> : synchronization of bookmarks and passwords;  profile support;  hardware acceleration, etc. <br>  - <strong>Software rendering</strong> is the most significant minus.  All calculations and rendering occur on your CPU.  But even here, Google engineers will soon surprise us - the work on the implementation of hardware acceleration is already underway.  Already, you can try to use it if you are brave and courageous. <br>  - Until recently, there was no support for extensions - now there IS!  If you are a clever developer, you can take your favorite AdBlock, indicate how Puppeteer will use it, and all ads will be blocked. <br>  - <strong>No audio / video support</strong> .  Because, well, why headless-browser audio and video. <br><br>  <strong>What can the Puppeteer:</strong> <br><br><ul><li>  Isolation sessions. </li><li>  Virtual timers. </li><li>  Interception of network requests. </li></ul><br>  And a couple of cool things that I will show a little further. <br><br><h4>  Session isolation <br></h4><br>  What is it, what is it eaten with, and will we not feed ourselves?  - Do not choke! <br><br>  Session isolation is a <strong>separate ‚Äúrepository‚Äù for each tab</strong> .  When you launch Puppeteer, you can create a new page, and each new page can have a separate repository, including: <br><br><ul><li>  cookes; <br></li><li>  local storage; <br></li><li>  cache <br></li></ul><br>  All pages will live independently of each other.  This is necessary, for example, to maintain the atomicity of tests. <br><br>  Session isolation <strong>saves resources and time when running parallel sessions</strong> .  Suppose you are testing a site that is built in a development mode, that is, the bundle is not minimized, and weighs 20 MB.  If you just want to cache it, you can tell Puppeteer to use the cache shared by all pages that are created, and this bundle will be cached. <br><br>  You can <strong>serialize sessions for later use</strong> .  You write a test that checks some action on your site.  But you have a problem - the site requires authorization.  You will not constantly add before each test for authorization on the site.  Puppeteer allows you to log in to the site once, and then reuse this session in the future. <br><br><h4>  Virtual timers <br></h4><br>  You may already be using virtual timers.  If you moved the slider in a developer tool that speeds up or slows down the animation (and washed your hands after that, of course!), Then at that moment you used virtual timers in the browser. <br><br>  The browser can use virtual timers instead of real ones in order to <strong>‚Äúscroll‚Äù time forward</strong> to speed up page loading or end animation.  Suppose you have the same test, you go to the main page, and there is animation for 30 seconds.  It is unprofitable for anyone to wait for the test all this time.  Therefore, you can simply speed up the animation so that it will be completed instantly when the page loads, and your test continues. <br><br>  You can <strong>stop the time while the network request is running</strong> .  For example, you are testing your application's reaction to when a request that goes to the backend is executed for a very long time, or returns with an error.  You can stop time - Puppeteer allows it. <br><br>  On the slide below there is another option: <strong>stop and continue the work of the</strong> renderer.  In the experimental mode, it was possible to tell the browser not to engage in rendering, and later, if necessary, request a screenshot.  Then the headless Chrome would quickly draw everything, give a screenshot, and again stop drawing anything.  Unfortunately, the developers have already managed to change the principle of operation of this API, and such a function no longer exists. <br><br>  A schematic view of the virtual timers below. <br><br><img src="https://habrastorage.org/webt/dy/zm/bu/dyzmbucfttmfjlbsdkpmlk6bypq.jpeg"><br><br>  In the top line there are two usual timers: the first starts in the first unit of time and is executed in one unit of time, the second starts in the third unit of time and is executed in three units of time. <br><br>  Acceleration timers - they run one after the other.  When we suspend them, we have a period of time, after which all the timers start. <br><br>  Consider this by example.  Below is a cropped piece of code that essentially just loads a page with an animation with codepen.io and waits: <br><br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https ://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page.goto(url, { waitUnitl: 'load' }); // # 2 })();</span></span></code> </pre><br><br>  <a href="https://www.youtube.com/watch%3Fv%3DWPcahL2K27w%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1454">This is a</a> demonstration of performance during the report - just an animation. <br><br>  Now, using the Chrome DevTools protocol, we‚Äôll send a method called Animation.setPlaybackRate, passing in the parameters to it the playbackRate with the value 12: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page._client.send('Animation.setPlaybackRate', { playbackRate: 12 }); // # 3 await page.goto(url, { waitUntil: 'load' }); // # 2</span></span></code> </pre><br>  We load the same link, and the animation began to work much faster.  This is due to the fact that we used a virtual timer and accelerated the animation playback 12 times. <br><br>  Let's now conduct an experiment - pass the playbackRate: 0 - and see what happens.  And there will be this: there is no animation at all, it does not play.  Zero and negative values ‚Äã‚Äãsimply pause the entire animation. <br><br><h4>  Work with network queries <br></h4><br>  You can <strong>intercept network requests</strong> by setting the following flag: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.setRequestlnterception(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  In this mode, an additional event appears that triggers when a network request is sent or arrives. <br><br>  You can <strong>change the query on the fly</strong> .  This means that you can completely change all its contents (body) and its headers, inspect, even cancel the request. <br><br>  This is required in order to <strong>handle authorization or authentication</strong> , including basic HTTP authentication. <br><br>  You can also <strong>cover code (JS / CSS)</strong> .  With the help of Puppeteer you can automate all this.  We all know utilities that can load a page, show which classes are used in it, etc.  But are we satisfied with them?  I think no. <br><br><blockquote>  The browser knows better which selectors and classes are used - the same browser!  He always knows which JavaScript is executed, which is not, which CSS is used, and which is not. <br></blockquote><br>  Again, the Chrome DevTools protocol comes to the rescue: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all ( [ page.coverage.startJSCoverage(), page.coverage.startCSSCoverage() ]); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [jsCoverage, cssCoverage] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>,all([ page.coverage.stopJSCoverage(), page.coverage.stopCSSCoverage() ]):</code> </pre><br>  In the first two lines we launch a relatively new feature that allows you to find out the coverage of the code.  We launch JS and CSS, go to some page, then say - stop - and we can see the results.  And these are not some imaginary results, but those that the browser sees precisely at the expense of the engine. <br><br>  In addition, there is already a plug-in, which for the Puppeteer all this is exported to istanbul. <br><br>  At the top of the Puppeteer pyramid is a script that you wrote on Node.js - he is like the godfather to all the lower points. <br><br><img src="https://habrastorage.org/webt/gx/j6/xl/gxj6xlxcpfwiuekgcszpnijrzf8.jpeg"><br><br>  But ... "not everything is calm in the Danish kingdom ..." - as William Shakespeare wrote. <br><br><h2>  <strong>What is wrong with headless browsers?</strong> <br></h2><br>  Headless browsers have problems despite the fact that all their cool features can do so much. <br><br><h4>  The difference in rendering pages on different platforms <br></h4><br>  I really love this item and constantly talk about it.  Let's look at this picture. <br><br><img src="https://habrastorage.org/webt/62/r2/rj/62r2rjsc0ggbgpedb5lhp_tceki.jpeg"><br><br>  Here is a regular page with plain text: on the right - drawing in Chrome on Linux, on the left - under Windows.  Those who test with screenshots know that a value is always set, called the ‚Äúerror threshold‚Äù, which determines when the screenshot is considered identical and when it is not. <br><br>  In fact, the problem is that no matter how hard you try to set this threshold, the error will always go beyond this limit, and you will still receive false positive results.  This is due to the fact that all pages, and even web fonts are rendered differently on all three platforms - on Windows using the same algorithm, on MacOS differently, on Linux in general the zoo.  <strong>You can not just take and test screenshots</strong> . <br><br>  You will say: "I just need a reference machine, where I will run all these tests and compare screenshots."  But in fact, this is wildly inconvenient, because you have to wait for CI, and you want to check here and now locally on the machine that you have not broken anything.  If your reference screenshots are made on a Linux machine, and you have a Mac, then there will be false results. <br><br><blockquote>  That's why I say that do not test with screenshots at all - forget it. <br></blockquote><br>  By the way, if you still want to test with screenshots, there is a wonderful article by Roman Dvornov " <a href="https://habr.com/company/avito/blog/350604/">Unit-testing with screenshots: breaking the sound barrier</a> ."  This is straight detective fiction. <br><br><h4>  Locks <br></h4><br>  Many large content providers do not like it when you do scraping or get their content in an illegal way.  Imagine that I am a large content provider, and I want to play one game with you.  There are two GET requests in two different browsers. <br><img src="https://habrastorage.org/webt/ku/ys/5e/kuys5eq81wzsqfci9kpddrd-ahm.jpeg"><br><br>  Can you guess where Chrome is here?  Option "both" is not accepted - Chrome there is only one.  Most likely, you will not be able to answer this question, and I, as a large content provider, can: on the right, PhantomJS, and on the left, Chrome. <br><img src="https://habrastorage.org/webt/l8/vc/lt/l8vcltt3bh-ccdysbg3azvqjxxe.jpeg"><br><br>  I can go to such an extent that I will detect your browsers (which is exactly Chrome or FireFox) by matching the order of the HTTP headers in your requests.  If the host goes first - I clearly know - this is Chrome.  Then I can not compare.  Yes, of course, there are more complex algorithms - we check not only the order, but also the values, etc.  etc.  But the important thing is that I can compare your headlines with molds, check who you are, and then just block you or not block. <br><br><h4>  Unable to implement some functions (Flash) <br></h4><br>  Have you ever studied in depth, right hardcore, Flash in browsers?  Once I looked in - then I didn‚Äôt sleep for half a year. <br><br>  We all remember how we used to watch YouTube when there was still a Flash: the movie is spinning, everything is fine.  But the moment an embedded object is created on a Flash-type page, it always requests a real window from your OS.  That is, besides the window of your browser, inside the YouTube-window Flash there was another window of your OS.  Flash cannot work if you do not give it a real window - and not just a real window, but a window that is visible on your screen.  Therefore, it is impossible to implement some functions in headless browsers, including Flash. <br><br><h4>  Full automation and bots <br></h4><br>  As I said earlier, large content providers are very afraid when you write spiders or grabbings, which simply steal information that is provided for a fee. <br><br>  In the course are different tricks.  There are articles on how to detect headless browsers.  I can say that <strong>you can‚Äôt find headless browsers</strong> .  All the methods that are described there are bypassed.  For example, there were detection methods using Canvas.  I remember there was even one script that watched the mouse move across the screen and filled in the Canvas.  We are people and move the mouse rather slowly, and Headless Chrome is much faster.  The script understood that the Canvas filled up too quickly means that this is most likely Headless Chrome.  We also bypassed it, just slowing down the browser is not a problem. <br><br><h4>  No standard (single) API <br></h4><br>  If you watched headless implementations in other browsers - be it Safari or FireFox - there it is all implemented using the webdriver API.  Chrome has the Chrome DevTools protocol.  In Edge nothing is clear at all - what is there, what is not. <br><br><h4>  WebGL? <br></h4><br>  People also ask WebGL in headless mode.  From this <a href="http://bit.ly/headlesswebgl">link</a> you can get on the Google Chrome bugtracker.  There, developers are actively voting for the implementation of the headless mode for WebGL, and he can already draw something.  They are now simply held back by hardware rendering.  As soon as the implementation of hardware rendering is completed, WebGL will automatically be available, that is, something can be done in the background. <br><br>  But it is not all that bad! <br><br>  We have a second player on the market - on May 11, 2018 there was <a href="https://blogs.windows.com/msedgedev/2018/05/11/introducing-edge-devtools-protocol/">news</a> that Microsoft, in its Edge browser, decided to implement almost the same protocol that is used in Google Chrome.  They specially created a consortium where they discuss the protocol they want to bring to the industry standard so that you can take your script and run it under Edge, and under Chrome, and under FireFox. <br><br>  But there is one ‚Äúbut‚Äù - Microsoft Edge has no headless mode, unfortunately.  They have a vote where people write: ‚ÄúGive us a headless mode!‚Äù - but they are silent.  Probably something sawing in secret. <br><br><h2>  <strong>TODO (conclusion)</strong> <br></h2><br>  I told it all so that you could come to your manager, or, if you are a manager, to the developer, and say: ‚ÄúThat's it!  <strong>We do not want Selenium anymore - give us a Puppeteer!</strong>  We will test it.  If this happens, I will be happy. <br><br>  But if you can study, like me, browsers using Puppeteer, actively post bugs, or send a pull request, then I will be glad even more.  This <a href="https://github.com/GoogleChrome/puppeteer">tool</a> in OpenSource is on GitHub, written in Node.js - you can just take it and contribute to it. <br><br>  The case of Puppeteer is unique in that there are two teams in Google: one is Puppeteer, the other is the headless mode.  If the user finds a bug, writes about it on GitHub, then if this bug is not in Puppeteer, but in Headless Chrome, the bug goes to the Headless Chrome team.  If they fix it there, the Puppeteer updates very quickly.  Due to this, it turns out a single ecosystem when the community helps to improve the browser. <br><br>  Therefore, I urge you to help improve the tool that is used not only by you, but also by other developers and testers. <br><br>  Contacts: <br><br><ul><li>  github.com/vitallium </li><li>  vk.com/vitallium </li><li>  twitter.com/vitalliumm </li></ul><br><blockquote>  <a href="http://frontendconf.ru/moscow/2018/">Frontend Conf Moscow</a> - a specialized conference of front-end developers will be held <strong>on October 4 and 5 in Moscow</strong> , in Infospace.  <a href="http://frontendconf.ru/moscow/2018/abstracts/">The list of</a> accepted reports has already been published on the conference website. <br><br>  In our newsletter, we regularly do thematic reviews of speeches, talk about transcripts and future events that have come out - <a href="http://eepurl.com/bb99tn">subscribe</a> to be the first to receive news. <br><br>  And this is a link to our <a href="https://www.youtube.com/c/FrontendChannel">Youtube channel</a> on the frontend; it contains all the presentations related to the development of the client side of projects. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/421137/">https://habr.com/ru/post/421137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421127/index.html">Friday webinars from Skillbox: development and developers</a></li>
<li><a href="../421129/index.html">How to reduce code review from two weeks to several hours. Experience team Yandex. Market</a></li>
<li><a href="../421131/index.html">Critical 1Cloud Server Vulnerability</a></li>
<li><a href="../421133/index.html">LINK. Paper keyboard. Very large buttons</a></li>
<li><a href="../421135/index.html">Au / Ni / MgO: heat transfer at the nanometer level</a></li>
<li><a href="../421139/index.html">Frontend Conf - with user care</a></li>
<li><a href="../421141/index.html">Mutational analysis, or how to test tests</a></li>
<li><a href="../421143/index.html">Mini-review of Aurora Labs S-Titanium Pro, a metal 3D printer</a></li>
<li><a href="../421147/index.html">Monsters after the holidays: AMD Threadripper 2990WX 32-Core and 2950X 16-Core</a></li>
<li><a href="../421149/index.html">Some words about gradients</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>