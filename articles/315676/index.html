<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extensions to C and C ++. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article (and I hope that the series of articles) is devoted to non-standard extensions of C and C ++ languages ‚Äã‚Äãthat exist in almost every compi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extensions to C and C ++. Part 1</h1><div class="post__text post__text-html js-mediator-article">  This article (and I hope that the series of articles) is devoted to non-standard extensions of C and C ++ languages ‚Äã‚Äãthat exist in almost every compiler. <br><br>  Language extensions are additional features and features of the language that are not included in the standard, but nevertheless are supported by compilers.  It is very interesting to investigate these extensions - first of all because they did not originate from scratch;  each extension is the result of the urgent need arising from a large number of programmers.  And I find it doubly interesting - since I like programming languages ‚Äã‚Äãand I develop my own, it often turns out that many of my ideas are implemented precisely in extensions of the language.  Standards of C and C ++ languages ‚Äã‚Äãare developing extremely slowly, and sometimes, reading the description of extensions, I just want to exclaim ‚Äúwell, that's obvious!  Why is this still not in the standard? " <br><br>  Language extensions are such a ‚Äúgray‚Äù, shadow area, about which they usually write little and know little.  But it is precisely with this that she is interesting! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I can say in advance what will be considered general purpose compilers gcc, msvs, clang, intel, embarcadero, compilers for iar and keil microcontrollers, and, if possible, many other compilers.  Most extensions in GCC, which is not surprising - free development contributes to the realization of different language features.  In addition, information on GCC extensions is all gathered in one place, and information on the rest of the compilers will have to be collected bit by bit.  Therefore, let's start with GCC. <br><a name="habracut"></a><br><h3>  <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">C language extensions</a> </h3><br><h4>  Control statements and code blocks as expressions </h4><br>  the most obvious idea, applied with might and main in modern hybrid (imperative-functional) languages.  A code block can be a value in an expression.  The value is the value of the last expression of this block of code. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = <span class="hljs-number"><span class="hljs-number">100</span></span> + ({ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = foo (); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) z = y; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> z = - y; z; });</code> </pre> <br><h4>  Local tags </h4><br>  The labels used for the goto operator, by default, have a scope limited by function.  Sometimes - for example, when opening macros - it is unsafe, and it is advisable to limit the scope of the label to the current code block.  Such labels require prior announcement using the <b>__label__ keyword</b> .  The label itself is declared in the usual way, but now its scope is a block, not a function. <br><br><h4>  Tags as values </h4><br>  Another interesting and powerful low-level feature associated with the goto operator is the use of labels as values.  In fact, this possibility also exists only in Assembler, where the label is only an address in the code.  In GCC, however, a special label type was refused, and for converting a label to the type void * for some reason they introduced the unary operator &amp;&amp;.  It looks very nice and hacker: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[] = { &amp;&amp;foo, &amp;&amp;bar, &amp;&amp;hack }; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i];</code> </pre> <br>  I must say that with the filing of Dijkstra, the goto operator is in disfavor with most programmers.  In many cases, this is indeed justified, but one should not forget that C is a hacker language, which means it has an ideology of preference for opportunities over limitations.  And if in some specific place, for example, in the kernel of the operating system, you need goto, it is better to use it than to fence assembler inserts.  And there are a lot of ways to spoil the code or make it unreadable, among which goto is far from the first place. <br><br><h4>  Nested functions </h4><br>  Lambda functions in C ++ appeared only in C ++ 11.  Meanwhile, in Turbo Pascal there was an opportunity to invest some functions in others.  With the advent of C ++ and classes, nothing has changed - classes could be nested in functions and other classes, but it was still impossible to nest functions in functions.  GCC corrects this annoying asymmetry in language. <br><br>  Nested functions support access to ambient variables, but unlike C ++ lambda do not require an explicit indication of "closures", and unlike the lambda of high-level languages, they do not organize such "closures" automatically.  Another interesting feature is the goto from the nested function to the ambient one.  This is more like a type of throwing an exception. <br><br><h4>  Redirecting a call with a variable number of arguments to another function </h4><br>  Special language constructs designed to transfer a variable number of function arguments to another function with a variable number of arguments, and information on the number of arguments is not required.  As is known, the standard way of working with a variable number of arguments in C are the macros va_start (), va_arg (), va_end () and the type va_list.  The method is based on the fact that the arguments of functions in C are written to the stack in the reverse order, and these macros simply provide access to the stack memory.  But in this expansion, we clearly see something new.  What is this? <br><br>  <b>void * __builtin_apply_args ()</b> - the function allocates memory on the stack and copies the arguments of the calling function there. <br><br>  <b>void * __builtin_apply (void (* function) (), void * arguments, size_t size)</b> - the function accepts a data block created with __builtin_apply_args, a function pointer and a stack size for it;  inside the function call is formed with the passed arguments.  Returns a data block on the stack that stores the return value returned from function. <br><br>  <b>void __builtin_return (void * result)</b> - the function replaces the usual return (that is, after this buildin the code is no longer executed) and returns the result of the execution of the function packed in the result. <br><br>  Thus, the mechanism is completely different from va_list and can be applied when there is a function with a variable number of arguments that does not have a v-version (that is, a version that accepts va_list ‚Äî such as vprintf). <br><br>  For some time now, two more builtins appeared, used only in inline functions, which are always rigidly inline (and not to compiler depreciation, as is the case with ordinary inline functions). <br><br>  <b>__builtin_va_arg_pack ()</b> represents the entire list of unnamed arguments;  This builtin is substituted directly in place of the variable-length argument list. <br>  <b>__builtin_va_arg_pack_len ()</b> returns the number of unnamed arguments. <br><br>  As you can guess from the inline mandatory requirements, these builtins work rather at the compilation stage, no stack manipulation, etc.  in runtime is not performed. <br><br><h4>  Typeof operator </h4><br>  The compilation operator returns the type of the expression.  A similar decltype operator appeared in C ++ not so long ago.  However, I remind you that now we are considering extensions of C, and not C ++!  (although they are of course also available in gcc c ++) <br><br><h4>  Short Conditional Operator </h4><br>  Expression: <br><br><pre> <code class="cpp hljs">x ? x : y</code> </pre> <br>  can be shortened to: <br><br><pre> <code class="cpp hljs">x ? : y</code> </pre> <br>  This is a convenient form of writing, especially if x itself is a long expression.  By the way, this form is called <a href="https://en.wikipedia.org/wiki/Elvis_operator">Elvis operator</a> and it differs from the <a href="https://en.wikipedia.org/wiki/Null_coalescing%2520operator">Null coalescing_operator</a> (existing for example in C #) in that the Elvis operator leads the first operand to the bool type and compares it to false, and the Null coalescing compares the operand strictly with the special value null. <br><br><h4>  Types __int128 and long long </h4><br>  Another obvious extension for 128-bit and 64-bit integers.  The long long type is standardized both in C and C ++, there is no standard for 128-bit numbers yet.  I wonder if it will, then what will it be called?  long long long and unsigned long long long? <br><br><h4>  complex </h4><br>  Support for complex numbers of any type at the language level.  I'm not sure that it makes sense to introduce such types into the language, but I remind you that this is C, there are no native objects, constructors, templates, and so on (and in fact this is a template type).  The language introduces support for suffixes 'i' and 'j' (they are the same), operators __real__ and __imag__, as well as a set of auxiliary functions. <br><br>  A sufficiently deep language support allows you to think about what needs to be in the language in order to be able to comfortably implement and use such special types without embedding directly into the compiler. <br><br><h4>  floating types, half precision </h4><br>  Additional floating point types: __float80, __float128, __fp16. <br>  In fact, if you open the <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a> standard, it turns out that the types are somewhat larger than the well-known float and double (and long double, if anyone remembers). <br><br><h4>  Decimal float </h4><br>  Another interesting floating point format is base 10, not 2 (see the link above, there are some of these formats too).  Let me remind you that the classic float and double in some cases give amusing errors due to the fact that the internal base of the degree is 2, and the textual writing of numbers is decimal (that is, base 10).  For example, 0.1 + 0.2! = 0.3 <br><br>  Base point 10 floating point numbers are used in financial calculations where such errors should not accumulate and lead to money leaks. <br><br><h4>  Hex floats </h4><br>  This is a way to write hexadecimal numbers with floating point (also due to the fact that using decimal notation it is not possible to write certain numbers for sure).  Instead of the letter 'e' used for a hexadecimal digit, the letter 'p' is used for exponential notation.  How do you like this number: 0x12c0a34.f09de78p3?  In my opinion, very much hacker. <br><br><h4>  Fixed point </h4><br>  Fixed-point numbers are another useful extension in GCC.  On some platforms, there may not be an FPU, sometimes fixed-point calculations may be faster or more convenient.  At the low level, these are regular integers, for which the price of discharges is accepted, which is different from the generally accepted one.  Theoretically, it would be possible to resolve any ratio of the whole and fractional parts, but GCC adopted some specific ratios for the main word sizes (2, 4 and 8 bytes) implemented in the <b>_Fract</b> and <b>_Accum</b> type <b>modifiers</b> .  Besides, for some reason this possibility is not included in all compilers, so I didn‚Äôt manage to verify this feature in practice. <br><br>  Another <b>_Sat</b> modifier <b>is</b> used for calculations with saturation - this is a special mode of handling overflows, in which if the result of calculations does not fit into the range of this type, then the maximum or minimum value that is possible for this type is stored in the variable.  Accuracy is lost, but no sign transitions occur, which may be preferable in some cases (color, sound, etc.) <br><br><h4>  Named address spaces </h4><br>  A very useful thing for architectures with multiple address spaces.  For example, for different microcontrollers.  There is a RAM, flash, eeprom, all of which are several banks.  And independent addressing systems for each address space. <br><br><h4>  Zero Length Arrays </h4><br>  They are used in structures as the last element, if the structure is a variable-length object header.  For low-level code is very convenient.  In those cases, if the extension is not available (in other compilers), it was necessary to make an array of one element, which is generally not correct - the variable length of the object may be zero.  And an extra size can lead to unnecessary memory allocations, etc. <br><br><h4>  Empty structures </h4><br>  Unlike C ++, where such structures are officially allowed, in C it is an extension.  And in C, their size (sizeof) is really zero, unlike C ++, where for some reason it is 1 byte. <br><br><h4>  Arrays whose size is determined at runtime </h4><br>  The obvious thing.  There is a alloca () function that allocates memory on the stack;  it does not need to be released.  GCC adds the ability to declare arrays at the language level in this way: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[n]; }</code> </pre> <br>  Moreover, GCC allows you to declare nested structures with variable-length array fields! <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[n]; }; }</code> </pre> <br>  And also functions with arrays of variable length (where the length is indicated in the function argument list): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data[len][len])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  And if you want to specify the length after the array, then this is possible!  GCC introduces a special syntax for preliminary declaration of a variable in the function argument list, which is by the way extremely interesting for many other applications (but this is already a separate topic): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data[len][len], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h4>  Variable Argument Macros </h4><br>  Such macros appeared in the standard C99 and C ++ 11.  In the GCC, they appeared earlier.  Also supported some improvements in relation to the standard version.  In fact, a macro with a variable number of parameters is a syntax that allows you to transfer a variable number of arguments to a macro and use the package of these arguments as a whole to transfer to other language entities that support a variable number of arguments (functions, other macros and in C ++ also templates).  In the macro declaration, the package of arguments is denoted as three dots "...", and in the body, as the identifier <b>__VA_ARGS__</b> . <br><br>  Now for the extensions.  The first is that instead of three dots and __VA_ARGS__, you can use normal names, which are declared with three dots and are used without them.  This improves the readability of the code, and generally a very beautiful idea in and of itself. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOG(args...) fprintf (stderr, args)</span></span></code> </pre> <br>  The second is the correct work with the ‚Äúfinal commas‚Äù.  For any code generation (and macros are also code generation), situations inevitably arise when a comma appears at the end of the list of any objects.  According to the mind, programming languages ‚Äã‚Äãshould consider this situation to be normal, but unfortunately most languages ‚Äã‚Äã(including C) regard this as an error.  Therefore, they came up with crutches - a special syntax ## __ VA_ARGS__, which removes the comma in the event that the package of arguments is empty. <br><br><h4>  Lightweight rules for wrapping lines in the preprocessor </h4><br>  The preprocessor itself is a very ugly and dangerous thing (which I regularly mention in comments to various articles).  but once it is, it is quite logical to alleviate some strict requirements.  In particular, the preprocessor in C for implementing multi-line macros uses a very strange and silly syntax with backslashes.  This extension allows the presence of whitespace characters after backslashes (the characters are invisible, it is easy to accidentally enter them in the process of editing the code and not notice them). <br><br><h4>  Indexing non-lvalue arrays </h4><br>  Now it seems obvious, but in C90 for some reason it was impossible to index non-lvalue arrays.  Fortunately, in both C99 and C ++ this is possible. <br><br><h4>  Arithmetic with void * pointers and function pointers </h4><br>  Arithmetic operations on such pointers are allowed.  The size of addressable objects is assumed to be 1 byte (but a strange consequence follows: sizeof (void) and sizeof are 1 of functional type ... which is not good). <br><br><h4>  Pointers to arrays with qualifiers </h4><br>  Subtleties and differences from the standard of implementation of work with pointers to arrays with qualifiers (const and others) in GCC C. <br><br><h4>  Not constant initializers </h4><br>  Obvious thing, but according to the standard it is impossible to use non-constant objects in initialization lists (in curly brackets).  This extension opens such an opportunity: <br><br><pre> <code class="cpp hljs">foo (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> g) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> beat_freqs[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { fg, f+g }; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h4>  Compound Literals </h4><br>  One more obvious thing, to which everyone is approaching from different sides, but in no way can they realize it completely, irrevocably and correctly (which is the most important thing).  Compound literals that can be used as objects of arrays, functions, and unions ‚Äî not only for initialization, but also simply in code ‚Äî for assignment, passing as arguments to functions. <br><br><pre> <code class="cpp hljs">obj = ((struct foo) {x + y, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **tbl = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *[]) { <span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-string"><span class="hljs-string">"y"</span></span>, <span class="hljs-string"><span class="hljs-string">"z"</span></span> };</code> </pre> <br>  For such literals, temporary objects of the appropriate type are created, which participate in expressions;  therefore, for example, it is possible (it would seem impossible, because the constant is not lvalue): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = ++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-number"><span class="hljs-number">1</span></span> };</code> </pre> <br><h4>  Designated (designated) elements in initialization lists </h4><br>  And one more beautiful extension of the initialization lists - inside the lists, you can specify not only all elements in a row, but also specific elements using the syntax of designators.  For arrays, these are unary square brackets in which the index of the element is indicated.  So. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[<span class="hljs-number"><span class="hljs-number">6</span></span>] = { [<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">29</span></span>, [<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">15</span></span> };</code> </pre> <br>  equivalent to: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[<span class="hljs-number"><span class="hljs-number">6</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  You can use ranges: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widths[] = { [<span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-number"><span class="hljs-number">9</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> ... <span class="hljs-number"><span class="hljs-number">99</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">100</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  For structures, a similar syntax with a unary point is used: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = {</span></span> .y = yvalue, .x = xvalue };</code> </pre> <br>  You can mix both types of designators, and in the same initialization list you can use both designators and just elements: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ptarray</span></span></span><span class="hljs-class">[10] = {</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>].y = yv2, {<span class="hljs-number"><span class="hljs-number">33</span></span>,<span class="hljs-number"><span class="hljs-number">44</span></span>}, [<span class="hljs-number"><span class="hljs-number">2</span></span>].x = xv2, [<span class="hljs-number"><span class="hljs-number">0</span></span>].x = xv0 };</code> </pre> <br>  By the way, this extension is not implemented in C ++ and was never dragged into the standard.  A pity, this is one of the most beautiful extensions, and one of the things that is now in C and not in C ++. <br><br><h4>  Ranges in case </h4><br>  The ability to use ranges (with a triple-point) in a switch statement as case arguments: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(c) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> ... <span class="hljs-string"><span class="hljs-string">'Z'</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  funny, but the GCC authors recommend to surround the ellipsis with spaces, referring to the fact that otherwise there may be problems with parsing of integers (they are probably afraid that the numbers will be recognized as real).  With proper parsing this should not be, longer operators should take precedence over short ones starting with the same characters.  Anyway. <br><br><h4>  Reduction to the type of union of any object that is a member of the union. </h4><br>  If there is an association: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d; };</code> </pre> <br>  That can be done by explicitly casting the type of objects int and double to type foo: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> foo u; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y; u = (<span class="hljs-keyword"><span class="hljs-keyword">union</span></span> foo) x; u = (<span class="hljs-keyword"><span class="hljs-keyword">union</span></span> foo) y;</code> </pre> <br>  Similarly, when passing arguments to a function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hack</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">union</span></span></span></span><span class="hljs-function"><span class="hljs-params"> foo)</span></span></span></span>; hack ((<span class="hljs-keyword"><span class="hljs-keyword">union</span></span> foo) x);</code> </pre> <br><h4>  Mix declaration variables and code </h4><br>  The most familiar thing in C ++ in C90 is also an extension (it was included in the standard in C99). <br><br><h4>  Attributes of functions, variables, types, labels, enumerations, control statements </h4><br>  The special keyword <b>__</b> attribute <b>__</b> , which allows you to assign attributes (meta information) defined by the compiler to various language constructs.  After the keyword in parentheses indicates the name of the attribute.  Attributes can be very different.  Some attributes are common, others are specific to a particular architecture.  Attributes may also have arguments, which are indicated in parentheses after the attribute name.  Here are some attributes (in fact, there are a lot of them, and perhaps this topic is worthy of a separate article). <br><br>  <b>Attributes of functions:</b> <br><blockquote>  noreturn, - a fukntion never returns control, <br>  pure - a function without side effects (the value depends only on the arguments), <br>  format - has arguments in the style of the printf format string; </blockquote><br>  <b>Tag Attributes:</b> <br><blockquote>  unused - the label is not used for transition using goto. <br> hot ‚Äî       <br> cold ‚Äî       </blockquote><br> <b>  </b> <br><blockquote> deprecated ‚Äî     ,        </blockquote><br> <b> </b> <br><blockquote> fallthrough ‚Äî    switch/case    break,        break. </blockquote><br> <b> </b> <br><blockquote> aligned (N) ‚Äî  </blockquote><br><h4>          </h4><br>     ,       ,          (     ,           ). <br><br><h4>    C++ </h4><br>   ,       ‚Äî     ,         . ,    . <br><br><h4>     </h4><br>       (    ),    ‚Äî     ,         . <br><br><h4>  Escape </h4><br>  '\e'         .     <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BD%25D0%25BE%25D1%2581%25D0%25B8%25D0%25BC%25D1%258B%25D0%25B9_%25D0%25BD%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2580_%25D1%2581%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B2">  </a> ,           ,    POSIX. <br><br><h4>       </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__alignof__ keyword</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns the alignment required for a field in some type or just for some type. </font><font style="vertical-align: inherit;">Alignment 1 - byte boundary (the lowest possible), 2 - by word boundary, 4 - by double word boundary, etc.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inline functions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is a well-known C ++ feature transferred in C. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using volatile </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some features of using volatile in GCC. </font><font style="vertical-align: inherit;">From curious - if in the code there is such:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *ptr; <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> *ptr;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then GCC interprets this as reading from the memory pointed to by ptr and generates the corresponding code </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using assembly inserts </font></font></h4><br>       GCC;    ,   ,    - ,      .  ,    ‚Äî        ;     ,        .      GCC     ,  . <br><br><h4>       </h4><br> -      .  __const__, __asm__,  .. <br><br><h4>   </h4><br>   enum  ;     ,       .       ,      . <br><br><h4>      </h4><br>     .  <b>__FUNCTION__</b> ( <b>__func__</b> )  <b>__PRETTY_FUNCTION__</b>    ,    . __PRETTY_FUNCTION__    ‚Äî . <br><br><h4>        </h4><br>      .    (built-in')        ( ,     ..),          . <br><br><h4>     </h4><br>         ( SIMD ‚Äî single instruction, multiple data). <br><br>       (   vector_size)        .     ,         .        . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v4si __attribute__ ((vector_size (<span class="hljs-number"><span class="hljs-number">16</span></span>))); v4si a = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; v4si b = {<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; v4si c; a = b + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a = b + {1,1,1,1}; a = 2 * b; // a = {2,2,2,2} * b; c = a &gt; b; // c = {0, 0,-1, 0} c = a == b; // c = {0,-1, 0,-1}</span></span></code> </pre> <br>      <b>__builtin_shuffle</b>              : <br><br><pre> <code class="cpp hljs"> v4si a = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; v4si b = {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>}; v4si mask1 = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; v4si mask2 = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}; v4si res; res = __builtin_shuffle (a, mask1); <span class="hljs-comment"><span class="hljs-comment">/* res is {1,2,2,4} */</span></span> res = __builtin_shuffle (a, b, mask2); <span class="hljs-comment"><span class="hljs-comment">/* res is {1,5,3,6} */</span></span></code> </pre> <br><h4>    offsetof </h4><br>  <b>offsetof</b> ,        ,     : <br><br><pre> <code class="cpp hljs">offsetof(s, m) (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)&amp;(((s *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-‚Ä∫m)</code> </pre> <br> ,        (-  )        ;    offsetof    __builtin_offsetof <br><br><h4>    (builtins) </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This concept is rarely distinguished as an independent entity - but in vain. Built-in functions occupy an intermediate place between the keywords of a language and ordinary functions and are used everywhere, and most programmers do not even think about their nature. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example sine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin ()</font></font></b> .   ,     (   )              FPU,       (    FPU   ,     ).     (builtin)    ,    ,    .        ,   ,  Cilk Plus,  ,           .. <br><br><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pragmas are directives intended, in general, to finely control the compilation process directly from source; </font><font style="vertical-align: inherit;">they can be attributed both to the preprocessor and to the language itself (in fact, it is difficult for me to attribute them somewhere unequivocally, and the preprocessor has long merged with the language). </font><font style="vertical-align: inherit;">GCC supports both general purpose pragmas and specific platforms. </font><font style="vertical-align: inherit;">The topic is big and interesting, as well as builtins, so maybe it will be discussed in a separate part.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unnamed fields of structures and associations </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In structures and unions you can declare nested unnamed structures and unions. </font><font style="vertical-align: inherit;">The fields of these nested structures and associations will be directly accessible:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d; } foo; foo.b = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br>  ,          ;    ,            ,            . <br><br>         Plan9 ("-fplan9-extensions"),     ,       Go:  (embedding)    ,        ‚Äî                  ,  ,     ++,     ,      (    ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; } s1; <span class="hljs-comment"><span class="hljs-comment">//     typedef' typedef struct { int x; s1; int y; } s2; s2 obj; obj.a = 10; //    </span></span></code> </pre> <br><h4> Thread-Local  </h4><br>     ,      thread-local storage.        TLS,          . <br><br><h4>   </h4><br>      ,           .   .     '0b'. <br><br>   ,         '0o'        .      . <br><br><h3> <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html"> gcc ++</a> </h3><br><h4>  volatile </h4><br>    volatile  GCC C++,   . <br><br><h4>   ( C99) </h4><br>   restrict    ,       ,       .  ,           ,  .         . <br><br>   GCC    restrict       this. <br><br><h4> ¬´¬ª (vague)  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some constructions in C ++ require space in the object files and can appear simultaneously in several translation units. </font><font style="vertical-align: inherit;">These are inline functions, virtual function tables (VTables), type_info objects, and template instantiation results. </font><font style="vertical-align: inherit;">GCC supports the placement of such objects in the COMDAT section of the object file, which makes it possible to eliminate duplicate objects at the linking stage.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interface and implementation pragmas </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such pragmas allow you to explicitly tell the compiler whether an object is an interface or an implementation. </font><font style="vertical-align: inherit;">An additional crutch to "indefinite linking".</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instantiation of templates </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pattern instantiation methods in GCC. </font><font style="vertical-align: inherit;">Methods to ensure that only one copy of each template instance is generated for specific template parameters. </font><font style="vertical-align: inherit;">The topic is big, I will only mention here</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Retrieving a function pointer from a pointer to a class member function </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The obvious expansion of capabilities associated with the '-&gt; *' and '. *' Operations. </font><font style="vertical-align: inherit;">If a pointer to a class field at a low level is a byte offset of this field inside a class, then a method pointer is a full function pointer, and GCC adds the ability to cast the type of method pointer to a regular function pointer.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++ attributes </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some attributes (set via the __attribute__ keyword) are applicable only to C ++. </font><font style="vertical-align: inherit;">A few examples: abi_tag - a way of specifying the mangling of variable and function names; </font><font style="vertical-align: inherit;">init_priority is the initialization priority for global objects.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Declaring multiple versions of a function </font></font></h4><br>  .    target          ‚Äî      (       ,       ..). -    ,    ,       . <br><br><h4>    </h4><br>   inline namespace (    GCC    ). <br><br><h4>   (Type Traits) </h4><br>      ,         .   ,         (     ,   ,     D).       ‚Äî   : <br><br><pre> <code class="cpp hljs">__is_abstract (type) __is_base_of (base_type, derived_type) __is_class (type) __is_empty (type) __is_enum (type) __is_literal_type (type)</code> </pre> <br><h4>  ++ </h4><br>  ,       (++17) .        (..    ),        . <br><br><h4>         </h4><br>  Also interesting.    ,            . <br><br><ul><li> G++     void*       . </li><li>     '&lt;?', '&gt;?', '&lt;?='  '&gt;?=' ( ,    ) </li><li>    (   ) </li><li>      new </li><li>   float  complex (   ) </li><li> implicit typename extension (      ) </li><li>        , typedef'    ,    </li><li>            .  ,  ? </li><li>            ;          . </li></ul><br><h4>  backward compatibility </h4><br>        ++  .      . <br><br><ul><li> ,    for,     ;    -fpermissive    . </li><li>        extern ¬´C¬ª;            . </li></ul><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, some extensions can hardly be called extensions: these are either well-known features, or - even worse - crutches designed to ensure compatibility with some ancient and inherited standards, circumvent unsuccessful solutions in language design, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, others are truly pearls among language features, and it is a pity that they are not included in the standard.</font></font></div><p>Source: <a href="https://habr.com/ru/post/315676/">https://habr.com/ru/post/315676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315664/index.html">Configuring Virtual Private Network on AWS EC2 from OpenVPN on Linux</a></li>
<li><a href="../315666/index.html">How Phoenix Kills React</a></li>
<li><a href="../315668/index.html">Code for which I still feel ashamed</a></li>
<li><a href="../315672/index.html">Kemerovo hackathon "DevTime"</a></li>
<li><a href="../315674/index.html">Competition of projects in the field of advertising technologies Go to AdTech</a></li>
<li><a href="../315678/index.html">Https support without any settings</a></li>
<li><a href="../315680/index.html">Greenland programmer (PHP creator): ‚ÄúI hate programming. But I love to solve problems. ‚Äù</a></li>
<li><a href="../315682/index.html">The digest of interesting materials for the mobile # 180 developer (November 14-20)</a></li>
<li><a href="../315684/index.html">Mars rover, landing coordinates</a></li>
<li><a href="../315688/index.html">Silent software development crisis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>