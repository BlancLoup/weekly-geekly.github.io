<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about the promises</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About promises (promises) is already written a lot. This article is just an attempt to collect the most practical use of promises with sufficiently de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about the promises</h1><div class="post__text post__text-html js-mediator-article"><p>  About promises (promises) is already written a lot.  This article is just an attempt to collect the most practical use of promises with sufficiently detailed explanations of how this works. </p><br><h1 id="obschie-svedeniya-ob-obeschaniyah">  General promises </h1><br><p>  First a few definitions. </p><br><p>  Promises (promises) are objects that allow you to streamline the execution of asynchronous calls. </p><br><p>  An asynchronous call is a function call in which the execution of the main code stream does not wait for the call to complete.  For example, the execution of the http request does not interrupt the execution of the main thread.  That is, the request is executed, and immediately, without waiting for its completion, the code following this call is executed, and the result of the http request is processed after its completion by the callback function (callback function). </p><br><p>  Next, we will consistently deal with the functioning of promises.  For the time being, we will proceed from the fact that we already have an object that promises to perform a certain asynchronous call.  We will talk about where promises come from and how to form them yourself. </p><br><a name="habracut"></a><br><p>  <b>1.</b> Promises provide a mechanism for managing the sequence of asynchronous calls.  In other words, a promise is just a wrapper over an asynchronous call.  The promise may resolve successfully or fail.  The essence of the mechanism is as follows.  Each promise provides two functions: then () and catch ().  As an argument, a callback function is passed to each of the functions.  The callback function in then is called if the promise is successfully resolved, and in catch if it is an error: </p><br><pre><code class="javascript hljs">promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      }).catch(function(error){ //     });</span></span></code> </pre> <br><p>  <b>2.</b> The next point to understand.  A promise is allowed only once.  In other words, an asynchronous call that occurs within a promise is executed only once.  In the future, the promise simply returns the saved result of the asynchronous call, no longer fulfilling it.  For example, if we have some promise promise, then: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    promise.then(function(result){ //      , //       }); //      promise.then(function(result){ //      . //       //   });</span></span></code> </pre> <br><p>  <b>3.</b> The then () and catch () functions return promises.  Thus, you can build a chain of promises.  The result, which the callback function returns in then (), is passed as an argument to the input of the next callback function ().  And the throw (message) call argument is passed as an argument to the callback function in catch (): </p><br><pre> <code class="javascript hljs">promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ( ) return result1; //     }).then(function(result){ //  result      result1, //     if(condition){ throw("Error message"); } }).catch(function(error){ //      , //   ,      //    error    "Error message" });</span></span></code> </pre> <br><p>  <b>4.</b> As a result, the callback function in then () can return not only a value, but also another promise.  In this case, the next call to then () will be passed the result of the resolution of this promise: </p><br><pre> <code class="javascript hljs">promise1.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise2.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -  return result3; }); }).then(function(result){ //   result      result3 }).catch(function(error){ //   });</span></span></code> </pre> <br><p>  <b>5.</b> You can do the same by building the resolution of the promises in one linear chain without investments: </p><br><pre> <code class="javascript hljs">promise1.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result1</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise2; }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result2</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -  return result3; }).then(function(result){ //   result      result3 }).catch(function(error){ //   });</span></span></code> </pre> <br><p>  Notice that each promise chain ends with a call to catch ().  If this is not done, then the errors that occur will disappear in the depths of the promises, and then it will be impossible to determine where the error occurred. </p><br><h2 id="podvodim-itog">  Summarize </h2><br><p>  If it is necessary to make a sequence of asynchronous calls (that is, when each next call must be executed strictly after the previous one is completed), then these asynchronous calls must be built into a chain of promises. </p><br><h1 id="otkuda-berutsya-obeschaniya">  Where promises come from </h1><br><p>  Promises can be obtained in two ways: either the functions of the library used can return ready-made promises, or you can independently wrap promises asynchronous calls to functions that do not support promises (promisification).  Consider each option separately. </p><br><h2 id="obeschaniya-bibliotechnyh-funkciy">  Promises Library Functions </h2><br><p>  Many modern libraries support work with promises.  You can find out whether the library supports the promise or not from the documentation.  Some libraries support both asynchronous call handling options: callback functions and promises.  Consider a few examples from life. </p><br><h3 id="biblioteka-raboty-s-bazami-dannyh-waterline-orm">  Library work with databases Waterline ORM </h3><br><p>  The <a href="https://github.com/balderdashy/waterline-docs">documentation</a> provides the following example of working with library functions (for example, data sampling): </p><br><pre> <code class="javascript hljs">Model.find({<span class="hljs-attr"><span class="hljs-attr">id</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]}).exec(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error){ <span class="hljs-comment"><span class="hljs-comment">//   } else{ //   ,   data } });</span></span></code> </pre> <br><p>  It seems that everything is beautiful.  However, if after data sampling and processing it is necessary to do some more data operations, for example, updating records in one table, then inserting new records in another table, then the nesting of callback functions becomes such that readability of the code begins to strive to zero: </p><br><pre> <code class="javascript hljs">Model.find({<span class="hljs-attr"><span class="hljs-attr">id</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]}).exec(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error){ <span class="hljs-comment"><span class="hljs-comment">//   } else{ //   ,   data Model_1.update(...).exec(function(error, data){ if(error){/*   */} else{ //   Model_2.insert(...).exec(function(error, data){ //  .. }); } }); } });</span></span></code> </pre> <br><p>  Even in the absence of the main code in the above example, it is already very difficult to understand what is written.  And if the database queries still need to be executed in a loop, then when using callback functions, the task in general becomes intractable. </p><br><p>  However, the functions of the Waterline ORM library are able to work with promises, although this is mentioned in the documentation somehow casually.  But the use of promises greatly simplifies life.  It turns out that database query functions return promises.  This means that the last example in the language of promises can be written as: </p><br><pre> <code class="javascript hljs">Model.find(...).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,   data return Model_1.update(...); }).then(function(data){ //   return Model_2.insert(...); }).then(function(data){ //  . . }).catch(function(error){ //       });</span></span></code> </pre> <br><p>  I think that there is no need to say which solution is better.  Particularly pleased that the processing of all errors is now done in one place.  Although it cannot be said that it is always good.  Sometimes it happens that it is not clear from the context of the error in which particular block it occurred, respectively, debugging becomes more complicated.  In this case, no one forbids putting a catch () call into each promise: </p><br><pre> <code class="javascript hljs">Model.find(...).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,   data return Model_1.update(...).catch(function(error){...}); }).then(function(data){ //   return Model_2.insert(...).catch(function(error){...}); }).then(function(data){ //  . . }).catch(function(error){ ... });</span></span></code> </pre> <br><p>  Even in this case, the code is more comprehensible than when using callback functions. </p><br><h3 id="biblioteka-dlya-raboty-s-mongodb-bazovaya-biblioteka-dlya-nodejs">  Library for working with MongoDB (base library for node.js) </h3><br><p>  As in the previous case, examples from the <a href="http://mongodb.github.io/node-mongodb-native/">documentation</a> use callback functions: </p><br><pre> <code class="javascript hljs">MongoClient.connect(url, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, db</span></span></span><span class="hljs-function">) </span></span>{ assert.equal(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, err); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Connected succesfully to server"</span></span>); db.close(); });</code> </pre> <br><p>  We have already seen in the previous example that using callbacks makes life very difficult when you need to make many consecutive asynchronous calls.  Fortunately, with a careful study of the documentation, you can find out that if the function of this library does not pass a callback function as an argument, it will return the promise.  So, the previous example can be written as: </p><br><pre> <code class="javascript hljs">MongoClient.connect(url).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">db</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Connected succesfully to server"</span></span>); db.close(); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><p>  The peculiarity of working with this library is that the database descriptor object db returned from an asynchronous call to connect () is used to make any database request.  That is, if in the course of our work we need to perform many queries to the database, then it becomes necessary to receive this descriptor every time.  And here the use of promises beautifully solves this problem.  To do this, simply save the promise of connecting to the database in a variable: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbConnect = MongoClient.connect(url); <span class="hljs-comment"><span class="hljs-comment">//   //        dbConnect.then(function(db){ return db.collection('collection_name').find(...); }).then(function(data){ //     //   db   ,  //      return dbConnect.then(function(db){ return db.collection('collection_name').update(...); }); }).then(function(result){ //     update //  .. ... }).catch(function(error){ //   }); //        //      ,    //      dbConnect.then(function(db){ ... }).catch(function(error){ ... });</span></span></code> </pre> <br><p>  What is good with such an organization of code is that the connection to the database is established once (I remind you that the promise is resolved only once, then the saved result is simply returned).  However, in the example above, there is one problem.  After completion of all requests to the database, we need to close the connection to the database.  Closing the connection to the base could be inserted at the end of the promise chain.  However, we do not know which of the two chains we started will end earlier, which means it is not clear which of the two chains should insert the closure of the connection with the base.  The Promise.all () call helps to solve this problem.  We will talk about it a bit later. </p><br><p>  Also, for the time being, we will postpone the discussion of how using promises to organize the cyclical execution of asynchronous calls.  After all, as mentioned above, the use of callbacks does not allow to solve this problem in general. </p><br><p>  We now turn to the question of how to independently create promises if the library does not support them. </p><br><h2 id="sozdanie-obeschaniy-promisifikaciya">  Making promises (promisification) </h2><br><p>  It often happens that the library does not keep promises.  And offers to use only callbacks.  In the case of a small script and simple logic, you can be content with this.  But if the logic is complicated, then promises cannot be done.  So, you need to be able to wrap asynchronous calls into promises. </p><br><p>  As an example, consider wrapping the promise of an asynchronous function to retrieve an attribute value from the redis repository.  The redis library functions do not keep promises and only work with callback functions.  That is, the standard call of the asynchronous function will look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redis'</span></span>).createClient(); redis.get(<span class="hljs-string"><span class="hljs-string">'attr_name'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, reply</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error){ <span class="hljs-comment"><span class="hljs-comment">//  } else{ //   } });</span></span></code> </pre> <br><p>  Now we wrap this feature into a promise.  JavaScript provides a Promise object for this.  That is, to create a new promise you need to do this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br><p>  As an argument, the Promise constructor is passed a function, within which an asynchronous call occurs.  The arguments of this function are the function resolve and reject.  The resolve function must be called if the asynchronous call completes successfully.  The result of the asynchronous call is transferred to the function input resolve.  The reject function should be called in case of an error.  An error is passed to the reject function. </p><br><p>  Putting it all together we get the function get (attr), which returns a promise to get a parameter from the redis repository: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> redis = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'redis'</span></span>).createClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">attr</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ redis.get(attr, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, reply</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(error){ reject(error); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ resolve(reply); } }); }); }</code> </pre> <br><p>  That's all.  Now you can safely use our get () function in the usual way for promises: </p><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">'attr_name'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reply</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    }).catch(function(error){ //   });</span></span></code> </pre> <br><h1 id="zachem-vse-eti-mucheniya">  Why all this torment </h1><br><p>  Any sane person will definitely have this question.  What are we doing now?  We clarified how to sequentially execute (asynchronous) function calls.  In any "normal" (not working with asynchronous calls) programming language, this is done simply by sequentially writing instructions.  No promises are needed.  And there is so much torment in order to make a simple sequence of calls.  Maybe asynchronous calls are not needed at all?  After all, because of them so many problems! </p><br><p>  But every cloud has a silver lining.  With asynchronous calls, we can choose how to make calls: sequentially or in parallel.  That is, if one action requires for its execution the presence of the result of another action, then we use then () calls in promises.  If the execution of several actions does not depend on each other, then we can run these actions on parallel execution. </p><br><p>  How to start parallel execution of several independent actions?  To do this, use the call: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ promise_1, promise_2, ..., promise_n ]).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">results</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// -    });</span></span></code> </pre> <br><p>  That is, the promise array is passed to the Promise.all function.  In this case, all promises are executed immediately.  The Promise.all function returns a promise to fulfill all promises, so the then () call in this case is triggered after all promises of the array are fulfilled.  The results parameter, which is passed to the input of the function in then (), is an array of the results of the promises in the sequence in which they were passed to the Promise.all input. </p><br><p>  Of course, you can promise and not wrap in Promise.all, but simply sequentially launch it.  However, in this case we lose control over the moment of completion of the fulfillment of all promises. </p><br><h1 id="vypolnenie-obeschaniy-v-cikle">  Keeping promises in a loop </h1><br><p>  Often there is the task of consistently fulfilling promises in a cycle.  Here we will consider the sequential fulfillment of promises, since if promises allow parallel execution, then there is nothing easier to make in the loop (or using map, filter functions, etc.) an array of promises and pass it to the input Promise.all. </p><br><p>  How does the cycle consistently fulfill promises?  The answer is simple - no way.  That is, strictly speaking, promises in a cycle cannot be fulfilled, but in a cycle you can make a chain of promises that are fulfilled one after the other, which is essentially equivalent to the cyclical execution of asynchronous actions. </p><br><p>  Let us now consider the mechanisms for cyclically constructing chains of promises.  Let us build on the types of cycles familiar to all programmers: the for loop and the forEach loop. </p><br><h2 id="vystraivanie-cepochki-obeschaniy-v-cikle-for">  Building a chain of promises in a for loop </h2><br><p>  Suppose that a certain function doSomething () returns a promise to perform some kind of asynchronous action, and we need to perform this action successively n times.  Let the promise itself return a certain string result, result, which is used in the next asynchronous call.  Also assume that the first call is made with an empty string.  In this case, building a chain of promises is done like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      var actionsChain = Promise.resolve(""); //      for(var i=0; i&lt;n; i++){ actionsChain = actionsChain.then(function(result){ return doSomething(result); }); } // ,      //       actionsChain.then(function(result){ // ,       }).catch(function(error){ //   });</span></span></code> </pre> <br><p>  In this sample template, only the first line requires an explanation.  The rest should be clear from the above material.  The Promise.resolve () function returns a successfully resolved promise whose result is the argument of this function.  That is, Promise.resolve ("") is equivalent to the following: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ resolve(<span class="hljs-string"><span class="hljs-string">""</span></span>); });</code> </pre> <br><h2 id="vystraivanie-cepochki-obeschaniy-v-cikle-foreach">  Building a chain of promises in a forEach loop </h2><br><p>  Suppose we need to perform some asynchronous action for each element of the array array.  Let this asynchronous action be wrapped in a certain function doSomething (), which returns a promise to perform this asynchronous action.  The pattern of how, in this case, to build a chain of promises, oddly enough, is not based on the use of the function forEach, but on the use of the function reduce. </p><br><p>  First, let's look at how the reduce function works.  This function is designed to process the elements of an array while maintaining an intermediate result.  Thus, in the end, we can get some integral result for a given array.  For example, using the reduce function, you can calculate the sum of the elements of an array: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = array.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, current</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum+current; }, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  The reduce function arguments are: </p><br><blockquote>  <i>The function that is called for each element of the array.</i>  <i>The following arguments are passed as arguments to this function: the result of the previous call, the current element of the array, the index of this element, and the array itself (in the example above, the last two arguments are omitted due to the lack of necessity).</i> </blockquote><p>  The initial value that is passed as the result of the previous action when processing the first element of the array. </p><br><p>  Now let's see how to use the reduce function to build a chain of promises for the task: </p><br><pre> <code class="javascript hljs">array.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">actionsChain, value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> actionsChain.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSomething(value); }); }, <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve());</code> </pre> <br><p>  In this example, the actions of the previous action is the promise of actionsChain, after the resolution of which a new promise is created to execute the doSomething action, which in turn is returned as a result.  So the chain is built for each element of the array.  Promise.resolve () is used as the initial promise of actionsChain. </p><br><h1 id="bolee-slozhnyy-primer-ispolzovaniya-obeschaniy">  A more sophisticated example of using promises </h1><br><p>              .     :    GET         . ,  ,          ,        ()    . </p><br><p>     : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  HTTP- var server = http.createServer(processRequest); //       redis server.on('close', function(){ storage.quit(); }); //   server.listen(config.port, config.host); console.log('Service is listening '+config.host+':'+config.port);</span></span></code> </pre> <br><p>    http-,   node.js.  processRequest ‚Äî  http-.         redis.     redis       ,    .           redis,      .   :      processRequest.      requestQueue.    : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestQueue = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(); <span class="hljs-comment"><span class="hljs-comment">/** *    *      * @param {Object} req  * @param {Object} res  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">)</span></span>{ requestQueue = requestQueue .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  GET-, ... if(req.method == 'GET'){ //  UUID  return calcUUID() //     .then(function(uuid){ res.writeHead(200, { 'Content-Type': 'text/plain', 'Cache-Control': 'no-cache' }); res.end(uuid); }) //   .catch(function(error){ console.log(error); res.writeHead(500, { 'Content-Type': 'text/plain', 'Cache-Control': 'no-cache' }); res.end(error); }); } //   GET-,   Bad Request else{ res.statusCode = 400; res.statusMessage = 'Bad Request'; res.end(); } }); }</span></span></code> </pre> <br><p>       calcUUID(),      .      ,         .           .  ,       ,         . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  ,       ,         .            . </p><br><p> ,    .       -   . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/311804/">https://habr.com/ru/post/311804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311792/index.html">JUG.ru Group's internal kitchen: how is the conference for 1000 programmers done</a></li>
<li><a href="../311794/index.html">Gamification aka gamification in business</a></li>
<li><a href="../311796/index.html">Banking Trojan Qadars returned and attacks banks in the UK</a></li>
<li><a href="../311800/index.html">Design as a coder</a></li>
<li><a href="../311802/index.html">Service Desk - quick start. 3 part. Creating a single entry point</a></li>
<li><a href="../311806/index.html">How the use of redundancy codes in SDS helps Yandex keep data cheaply and securely</a></li>
<li><a href="../311808/index.html">learnopengl. Lesson 1.4 - Hello Triangle</a></li>
<li><a href="../311812/index.html">Deep Learning Course Overview</a></li>
<li><a href="../311816/index.html">How to stop being afraid and fall in love with mbed [Part 5]</a></li>
<li><a href="../311818/index.html">Barrier control with Arduino UNO and 433 MHz radio transmitter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>