<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Uploading .3DS files to Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a prequel to my last post on the Glow effect. I promised to tell you how to load .3ds files to draw them using the shaders used there....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Uploading .3DS files to Android</h1><div class="post__text post__text-html js-mediator-article">  This article is a prequel to my <a href="http://habrahabr.ru/post/144831/">last post</a> on the Glow effect.  I promised to tell you how to load .3ds files to draw them using the shaders used there. <br><br>  Some general information about the file format can be read, for example, in <a href="http://en.wikipedia.org/wiki/.3ds">Wikipedia</a> or in the <a href="http://www.enlight.ru/faq3d/articles/75.htm">demo.design 3D programming FAQ</a> , but this is all theory (and not written without errors), and here we will talk about practice, and with reference to Java and Android. <br><br>  What will be here: <br><ul><li>  Pretty quick reading of the entire file (on the phone a 2MB file loads in a couple of seconds); </li><li>  loading the entire model, calculating normals, loading texture coordinates; </li><li>  all information about materials, light sources; </li><li>  loading animation and object hierarchy. </li></ul><br>  What will <i>not</i> be here: <br><ul><li>  loading the textures themselves (I haven't needed it yet, although it is easy to implement); </li><li>  uploading camera information (again, easy to add, but not useful); </li><li>  <s>use of smoothing groups to calculate normals (not sure if it is needed at all)</s> (it will still be); </li><li>  using <a href="http://www.enlight.ru/faq3d/articles/76.htm">splines</a> for animation. </li></ul><br>  I will not begin to chew the whole source in detail, as I did last time (this is more than a thousand lines), I‚Äôll just focus on the main points and provide links to the full source code (at the end of the article).  Still interesting?  Then we continue. <br><a name="habracut"></a><br><h4>  Reading file </h4><br>  Strangely enough, the simplest reading of numbers from a file was one of the most difficult tasks that one had to face in the first place.  There are two rakes: speed and correctness.  We will provide speed using BufferedInputStream and exclusively sequential reading, but with correctness everything is a bit more complicated: Java considers that all data in the file should be big-endian, whereas in .3ds little-endian is used.  Well ... We use a simple wrapper: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BufferedInputStream file; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> filePos = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Skip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ file.skip(count); filePos += count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filePos &lt; end) { Skip(end - filePos); filePos = end; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ file.read(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); filePos++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadUnsignedByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ file.read(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); filePos++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>]&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadUnsignedShort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ file.read(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); filePos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((bytes[<span class="hljs-number"><span class="hljs-number">1</span></span>]&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | (bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>]&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ file.read(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); filePos += <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (bytes[<span class="hljs-number"><span class="hljs-number">3</span></span>]) &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span> | (bytes[<span class="hljs-number"><span class="hljs-number">2</span></span>]&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span> | (bytes[<span class="hljs-number"><span class="hljs-number">1</span></span>]&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> | (bytes[<span class="hljs-number"><span class="hljs-number">0</span></span>]&amp;<span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFloat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Float.intBitsToFloat(ReadInt()); }</code> </pre> <br><br>  In an amicable way, this should have been a separate class inherited from BufferedInputStream, but in this case it was more convenient for me to do just that. <br><br>  Now you can start reading chunks.  To begin with - the main one: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Scene3D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileLen)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ Scene3D scene = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (filePos &lt; fileLen) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkID = ReadUnsignedShort(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkLen = ReadInt() - <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (chunkID) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHUNK_MAIN: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scene == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) scene = ChunkMain(chunkLen); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Skip(chunkLen); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Skip(chunkLen); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scene; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Scene3D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChunkMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ Scene3D scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Scene3D(); scene.materials = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Material3D&gt;(); scene.objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Object3D&gt;(); scene.lights = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Light3D&gt;(); scene.animations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Animation&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end = filePos + len; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (filePos &lt; end) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkID = ReadUnsignedShort(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkLen = ReadInt() - <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (chunkID) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHUNK_OBJMESH: Chunk3DEditor(scene, chunkLen); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHUNK_KEYFRAMER: ChunkKeyframer(scene, chunkLen); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHUNK_BACKCOL: scene.background = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; ChunkColor(chunkLen, scene.background); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHUNK_AMB: scene.ambient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; ChunkColor(chunkLen, scene.ambient); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Skip(chunkLen); } } Seek(end); scene.Compute(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scene; }</code> </pre><br><br>  The structure of the loader as a whole is quite homogeneous: for each chunk there is its own function containing information about those sub chunks that may occur.  All the information we need we will upload, not needed - jump, moving immediately to the next chunk.  Protection against incorrect files here is minimal. <br><br><h4>  Materials </h4><br>  The block of materials usually goes first, because the block of triangles then refers to it. <br><br>  The material consists of several colors (ambient, diffuse, specular), material name, flare parameters, texture name.  As noted above, textures are not loaded here, but this is easy to add if necessary. <br><br><h4>  3D models </h4><br>  Each 3D model (see the ChunkTrimesh function) is defined by the following data: <br><ul><li>  vertex coordinate list; </li><li>  triangle list; </li><li>  texture coordinates; </li><li>  local coordinate system. </li></ul><br>  If everything is clear with the first three points, the last one looks somewhat mysterious.  Looking ahead, I will say that for me it has remained a rather incomprehensible entity, although I still learned how to correctly apply this data. <br><br>  We dump all the information about the vertices into one float [] array, storing eight real numbers for each vertex (three for coordinates and a normal, plus two texture coordinates).  A couple of lines from the last article will need to be changed: <br><br><pre> <code class="java hljs"> GLES20.glVertexAttribPointer(maPosition, <span class="hljs-number"><span class="hljs-number">3</span></span>, GLES20.GL_FLOAT, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glVertexAttribPointer(maNormal, <span class="hljs-number"><span class="hljs-number">3</span></span>, GLES20.GL_FLOAT, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre><br>  Here, the number 24 has changed to 32, since there were no texture coordinates before, but now there is. <br><br>  All coordinates are loaded by the ChunkVector function, which at the same time swaps the Y and Z axes: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChunkVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] vec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ vec[offset + <span class="hljs-number"><span class="hljs-number">0</span></span>] = ReadFloat(); vec[offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] = ReadFloat(); vec[offset + <span class="hljs-number"><span class="hljs-number">1</span></span>] = ReadFloat(); }</code> </pre><br><br>  Well, in general, for some standard types, such as colors or percentages, their functions are used. <br><br>  The list of triangles should be processed in a special way: first, materials are applied to the edges (and not to the vertices), and secondly, it is by the edges that the normals to the vertices can be determined.  To do this, we calculate the normal to each face, add it to each of the three vertices, and then (at the end, after loading all the triangles) we normalize.  A bundle of functions, a little math - and that's it. <br><br>  Another feature of the list of faces is that after a chunk with the names of materials there may remain faces to which the material was not applied.  For them, you need to use the default material when drawing, like this: <br><br><pre> <code class="java hljs"> mAmbient[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0.587f</span></span>; mAmbient[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.587f</span></span>; mAmbient[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.587f</span></span>; mAmbient[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; mDiffuse[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0.587f</span></span>; mDiffuse[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.587f</span></span>; mDiffuse[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.587f</span></span>; mDiffuse[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; mSpecular[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0.896f</span></span>; mSpecular[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.896f</span></span>; mSpecular[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.896f</span></span>; mSpecular[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mats = obj.faceMats.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; mats; j++) { FaceMat mat = obj.faceMats.get(j); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mat.material != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mat.material.ambient != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; scene.ambient != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; k++) mAmbient[k] = mat.material.ambient[k] * scene.ambient[k]; GLES20.glUniform4fv(muAmbient, <span class="hljs-number"><span class="hljs-number">1</span></span>, mAmbient, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> GLES20.glUniform4f(muAmbient, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mat.material.diffuse != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) GLES20.glUniform4fv(muDiffuse, <span class="hljs-number"><span class="hljs-number">1</span></span>, mat.material.diffuse, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> GLES20.glUniform4fv(muDiffuse, <span class="hljs-number"><span class="hljs-number">1</span></span>, mDiffuse, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mat.material.specular != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) GLES20.glUniform4fv(muSpecular, <span class="hljs-number"><span class="hljs-number">1</span></span>, mat.material.specular, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> GLES20.glUniform4fv(muSpecular, <span class="hljs-number"><span class="hljs-number">1</span></span>, mSpecular, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glUniform1f(muShininess, mat.material.shininess); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GLES20.glUniform4f(muAmbient, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); GLES20.glUniform4fv(muDiffuse, <span class="hljs-number"><span class="hljs-number">1</span></span>, mDiffuse, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glUniform4fv(muSpecular, <span class="hljs-number"><span class="hljs-number">1</span></span>, mSpecular, <span class="hljs-number"><span class="hljs-number">0</span></span>); GLES20.glUniform1f(muShininess, <span class="hljs-number"><span class="hljs-number">0</span></span>); } GLES20.glDrawElements(GLES20.GL_TRIANGLES, mat.indexBuffer.length, GLES20.GL_UNSIGNED_SHORT, mat.bufOffset * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br><br>  Voila <br><br><h4>  Sources of light </h4><br>  There are omnidirectional and directional.  About directional light sources, again, until we talk (although it is not difficult to write a shader that takes into account the directionality), I‚Äôll say a few words about highlights.  Consider the shader for the model from the previous article, and add to it a few lines: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String vertexShaderCode = <span class="hljs-string"><span class="hljs-string">"precision mediump float;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform mat4 uMVPMatrix;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform mat4 uMVMatrix;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform mat3 uNMatrix;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uAmbient;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uDiffuse;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform vec4 uSpecular;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"uniform float uShininess;\n"</span></span> + ... <span class="hljs-string"><span class="hljs-string">"vec4 light_point_view_local(vec3 epos, vec3 normal, int idx) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vert2light = uLight[idx].position - epos;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 ldir = normalize(vert2light);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 vdir = vec3(0.0, 0.0, 1.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec3 halfv = normalize(ldir + vdir);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float NdotL = dot(normal, ldir);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" float NdotH = dot(normal, halfv);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" vec4 outCol = vec4(0.0, 0.0, 0.0, 1.0);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" if (NdotL &gt; 0.0) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" outCol = uLight[idx].color * uDiffuse * NdotL;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" if (NdotH &gt; 0.0 &amp;&amp; uShininess &gt; 0) {\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" outCol += uSpecular * pow(NdotH, uShininess);\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" }\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" return outCol;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"}\n"</span></span>;</code> </pre><br><br>  Actually, the calculation and application of NdotH was added.  Sininess here and shininess in Material3D have different dimensions, I did not select the exact match between them (again, if someone needs it, this is easy to do). <br><br><h4>  Animation </h4><br>  One of the most complex and interesting themes in the .3ds format.  The fact is that without the use of animated tracks, some objects may not be displayed correctly at all.  And if objects are clones of each other, then even more so will not be displayed. <br><br>  All objects in the .3ds file are combined into a hierarchical tree, and transformations of each ‚Äúancestor‚Äù should be applied to the ‚Äúdescendant‚Äù.  The vertices of the tree are written in the order ‚Äúfrom top to bottom‚Äù, therefore the application of transformations can be carried out in the same order.  Curiously, from the point of view of the .3ds file, 3D models, light sources and cameras are peer objects that can be linked to each other by a hierarchy and apply animation in the same way.  However, for the time being, we are only interested in 3D models, and in particular, tracks of movement, turns and scaling in them. <br><br>  For each object is stored: <br><ul><li>  object name; </li><li>  the identifier of the object itself and its ancestor; </li><li>  a pivot point (pivot, the conditional center of the object around which the turn takes place); </li><li>  lists of keyframes for shift, rotation, scaling, and camera parameters (I ignore them, just like the cameras themselves). </li></ul><br><br>  Loading tracks is boring, so let's talk about how to use them.  So, we have: <br><ul><li>  ancestor transformation matrix (inductive hypothesis); </li><li>  shift; </li><li>  a pack of turns; </li><li>  scaling; </li><li>  center of the object; </li><li>  local coordinate system (see chunk of 3D-model). </li></ul><br>  It remains to collect all this into one ready-made transformation matrix.  With shift and scaling, everything is relatively simple: linear interpolation is simply applied between two frames, the values ‚Äã‚Äãare given in absolute form.  But turns must be applied all consistently!  And between keyframes, we just apply the rotation of the next frame to the corresponding number of degrees, interpolating it linearly. <br><br>  Another interesting point is that you need to keep in mind two matrices: a transformation for the child (result) and a transformation for the model (world).  The first is used in the chain of hierarchy, the second - when drawing the model.  In what order is it all going? <br><br><pre> <code class="java hljs">result = parent.result * move * rotate * scale; world = result * Move(-pivot) * trmatrix;</code> </pre><br>  It is assumed that the transformations are applied to the top in the order of "right to left" (as is customary in OpenGL).  Here trmatrix is ‚Äã‚Äãthe matrix <i>inverse of the</i> one that was in the chunk of the 3D model.  Total, conversion calculation code for a given point in time (when loading all frame numbers were converted to real numbers from 0 to 1): <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lerp3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] to, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) out[i] = from[i] + (to[i] - from[i]) * t; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> AnimKey </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findVec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AnimKey[] keys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span><span class="hljs-function"> </span></span>{ AnimKey key = keys[keys.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// We'll use either first, or last, or interpolated key for (int j = 0; j &lt; keys.length; j++) { if (keys[j].time &gt;= time) { if (j &gt; 0) { float local = (time - keys[j - 1].time) / (keys[j].time - keys[j - 1].time); key = new AnimKey(); key.time = time; key.data = new float[3]; lerp3(key.data, keys[j - 1].data, keys[j].data, local); } else key = keys[j]; break; } } return key; } private void applyRot(float[] result, float[] data, float t) { if (Math.abs(data[3]) &gt; 1.0e-7 &amp;&amp; Math.hypot(Math.hypot(data[0], data[1]), data[2]) &gt; 1.0e-7) Matrix.rotateM(result, 0, (float) (data[3] * t * 180 / Math.PI), data[0], data[1], data[2]); } public void Compute(float time) { int i, n = animations.size(); for (i = 0; i &lt; n; i++) { Animation anim = animations.get(i); Object3D obj = anim.object; float[] result = new float[16]; Matrix.setIdentityM(result, 0); if (anim.position != null &amp;&amp; anim.position.length &gt; 0) { AnimKey key = findVec(anim.position, time); float[] pos = key.data; Matrix.translateM(result, 0, pos[0], pos[1], pos[2]); } if (anim.rotation != null &amp;&amp; anim.rotation.length &gt; 0) { // All rotations that are prior to the target time should be applied sequentially for (int j = anim.rotation.length - 1; j &gt; 0; j--) { if (time &gt;= anim.rotation[j].time) // rotation in the past, apply as is applyRot(result, anim.rotation[j].data, 1); else if (time &gt; anim.rotation[j - 1].time) { // rotation between key frames, apply part of it float local = (time - anim.rotation[j - 1].time) / (anim.rotation[j].time - anim.rotation[j - 1].time); applyRot(result, anim.rotation[j].data, local); } // otherwise, it's a rotation in the future, skip it } // Always apply the first rotation applyRot(result, anim.rotation[0].data, 1); } if (anim.scaling != null &amp;&amp; anim.scaling.length &gt; 0) { AnimKey key = findVec(anim.scaling, time); float[] scale = key.data; Matrix.scaleM(result, 0, scale[0], scale[1], scale[2]); } if (anim.parent != null) Matrix.multiplyMM(anim.result, 0, anim.parent.result, 0, result, 0); else Matrix.translateM(anim.result, 0, result, 0, 0, 0, 0); if (obj != null &amp;&amp; obj.trMatrix != null) { float[] pivot = new float[16]; Matrix.setIdentityM(pivot, 0); Matrix.translateM(pivot, 0, -anim.pivot[0], -anim.pivot[1], -anim.pivot[2]); Matrix.multiplyMM(result, 0, pivot, 0, obj.trMatrix, 0); } else { Matrix.setIdentityM(result, 0); Matrix.translateM(result, 0, -anim.pivot[0], -anim.pivot[1], -anim.pivot[2]); } Matrix.multiplyMM(anim.world, 0, anim.result, 0, result, 0); } }</span></span></code> </pre><br><br>  All this was obtained by trial and error on particularly sophisticated examples, but I‚Äôm still afraid to vouch for absolute accuracy and correctness, it‚Äôs all too powerful.  And this is without using splines! <br><br>  In addition, the cycle on models from the previous article now looks a little different: <br><br><pre> <code class="java hljs"> num = scene.animations.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num; i++) { Animation anim = scene.animations.get(i); Object3D obj = anim.object; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; Matrix.multiplyMM(mMVMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mVMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, anim.world, <span class="hljs-number"><span class="hljs-number">0</span></span>); Matrix.multiplyMM(mMVPMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mProjMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>, mMVMatrix, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Apply a ModelView Projection transformation GLES20.glUniformMatrix4fv(muMVPMatrix, 1, false, mMVPMatrix, 0); GLES20.glUniformMatrix4fv(muMVMatrix, 1, false, mMVMatrix, 0); for (j = 0; j &lt; 3; j++) for (k = 0; k &lt; 3; k++) mNMatrix[k*3 + j] = mMVMatrix[k*4 + j]; GLES20.glUniformMatrix3fv(muNMatrix, 1, false, mNMatrix, 0); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, obj.glVertices); GLES20.glVertexAttribPointer(maPosition, 3, GLES20.GL_FLOAT, false, 32, 0); GLES20.glVertexAttribPointer(maNormal, 3, GLES20.GL_FLOAT, false, 32, 12); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); ...</span></span></code> </pre><br><br>  Further, everything is the same as before. <br><br><h4>  Conclusion </h4><br>  That's all, for the overwhelming majority of cases this knowledge is quite enough, well, and I mentioned the most painful rake here and bypassed as best I could.  If you add a texture download, then everything will be quite good, but I will leave it as a homework. <br><br>  Well and, actually, the promised ready source codes: <a href="http://pastebin.com/ntB85Jtw">Scene3D</a> (data structures) and <a href="http://pastebin.com/A4vhNTuC">Load3DS</a> (loader).  Please note that the files are loaded from the root of the memory card ("/ sdcard /"), I strongly recommend changing it to something more reasonable. <br><br>  <b>Update:</b> Since there are so many copies broken about normals, the code for working with smoothing groups has been added to the sources.  Index buffers remain 2-byte, so be careful not to overflow! </div><p>Source: <a href="https://habr.com/ru/post/144955/">https://habr.com/ru/post/144955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144946/index.html">Some subtleties of installation on the site of buttons "Share" (share) of social networks</a></li>
<li><a href="../144948/index.html">HP EVA Disk Array - simple!</a></li>
<li><a href="../144951/index.html">HTML5 maps for mobile platforms</a></li>
<li><a href="../144952/index.html">Mobile technology: developing the world</a></li>
<li><a href="../144954/index.html">5 years to satellites on Yandex.Maps</a></li>
<li><a href="../144956/index.html">Opera Mini 7 for J2ME, BlackBerry and S60</a></li>
<li><a href="../144957/index.html">There is no reception against scrap: OpenJDK hack vs. Class Encryption</a></li>
<li><a href="../144958/index.html">Google program for women entrepreneurs for the first time in Russia!</a></li>
<li><a href="../144959/index.html">Date Modification Problem via strtotime</a></li>
<li><a href="../144960/index.html">Introduction to Windows Server AppFabric. Hosting Services, hosting and scaling WCF and WF services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>