<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with C ++ tuples (std :: tuple). Functions foreach, map and call</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Here I will talk about working with C ++ tuples ( tuple ), give some useful functions that can make life much easier when using tuples, and also give ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with C ++ tuples (std :: tuple). Functions foreach, map and call</h1><div class="post__text post__text-html js-mediator-article">  Here I will talk about working with C ++ tuples ( <a href="http://ru.cppreference.com/w/cpp/utility/tuple"><i>tuple</i></a> ), give some useful functions that can make life much easier when using tuples, and also give examples of using these functions.  All from personal experience. <br><a name="habracut"></a><br><h2>  Foreach </h2><br>  To iterate over all the elements of a tuple, calling for each one the same function - probably the first task faced by the developer when using tuples.  The implementation is very straightforward: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tuple_utils { <span class="hljs-comment"><span class="hljs-comment">//  'callback'     /* struct callback { template&lt;std::size_t, class T&gt; void operator()( T&amp;&amp; element ) { // do something } }; tupleForeach( callback(), myTuple ); */ template&lt;class TCallback, class ...TParams&gt; void tupleForeach( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ); namespace { template&lt;std::size_t Index, class TCallback, class ...TParams&gt; struct _foreach_ { static void tupleForeach_( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ) { //      callback'a       const std::size_t idx = sizeof...( TParams ) - Index; callback.operator()&lt;idx&gt;( std::get&lt;idx&gt;( tuple ) ); _foreach_&lt;Index - 1, TCallback, TParams...&gt;::tupleForeach_( callback, tuple ); } }; template&lt;class TCallback, class ...TParams&gt; struct _foreach_&lt;0, TCallback, TParams...&gt; { static void tupleForeach_( TCallback&amp; /*callback*/, const std::tuple&lt;TParams...&gt;&amp; /*tuple*/ ) {} }; } // template&lt;class TCallback, class ...TParams&gt; void tupleForeach( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ) { _foreach_&lt;sizeof...( TParams ), TCallback, TParams...&gt;::tupleForeach_( callback, tuple ); } } // tuple_utils</span></span></code> </pre> <br>  Here, the auxiliary structure of <i>_foreach_ is used</i> , having the next tuple index as an additional template parameter.  Its only static method <i>tupleForeach_</i> calls the function specified by the <i>callback</i> for the element with this index, after which it is called recursively.  Partial specialization of this structure for an index equal to zero is degenerate and is the completion of recursion. <br><br><div class="spoiler">  <b class="spoiler_title">Example 1. Banal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForeachCallback</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"( "</span></span> &lt;&lt; Index &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; element &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ) "</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myTyple = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple( <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-string"><span class="hljs-string">"boo"</span></span> ); tuple_utils::tupleForeach( ForeachCallback(), myTyple ); }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Example 2. Checking getters</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   getter'      template&lt;class TResult, class TOwner&gt; using TGetter = TResult( TOwner::* )() const; // ,  getter'   template&lt;class TGetterOwner, class ...TParams&gt; class MyGetterContainer { //   getter'     template&lt;class TResult&gt; using TMyGetter = TGetter&lt;TResult, TGetterOwner&gt;; ..... private: ..... // ,    getter'  ( nullptr) void checkGetters(); //  getter'   (..    ) std::tuple&lt;TMyGetter&lt;TParams&gt;...&gt; m_getters; }; namespace { // callback,    getter' template&lt;class TGetterOwner&gt; struct GetterCheckCallback { //   ,      getter' //     'Index'       template&lt;std::size_t Index, class T&gt; void operator()( const TGetter&lt;T, TGetterOwner&gt;&amp; element ) { assert( element != nullptr ); } }; } // template&lt;class TGetterOwner, class ...TParams&gt; void MyGetterContainer&lt;TGetterOwner, TParams...&gt;::checkGetters() { //  callback    getter' tuple_utils::tupleForeach( GetterCheckCallback&lt;TGetterOwner&gt;(), m_getters ); }</span></span></code> </pre></div></div><br><h2>  Map </h2><br>  Another task that comes to mind for the convenience of working with tuples is a function that builds a new tuple sequentially from the results of performing a given function on the elements of a given tuple.  A very common task in functional languages.  Its implementation is perhaps even simpler: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tuple_utils { <span class="hljs-comment"><span class="hljs-comment">//    (  )    'callback'      'sourceTuple' /* struct callback { template&lt;std::size_t, class R, class T&gt; R operator()( T&amp;&amp; element ) { // do something } }; mapTuple( callback(), myTuple ); */ template&lt;class TCallback, class TSourceTuple&gt; auto mapTuple( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple ); namespace { template&lt;class TCallback, class TSourceTuple, std::size_t... Indices&gt; auto mapTuple_( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple, std::index_sequence&lt;Indices...&gt; ) { return std::make_tuple( callback.operator()&lt;Indices&gt;( std::get&lt;Indices&gt;( sourceTuple ) )... ); } } // template&lt;class TCallback, class TSourceTuple&gt; auto mapTuple( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple ) { return mapTuple_( callback, sourceTuple, std::make_index_sequence&lt;std::tuple_size&lt;TSourceTuple&gt;::value&gt;() ); } } // tuple_utils</span></span></code> </pre><br>  Here we use the auxiliary function <i>mapTuple_</i> , which takes an additional parameter, a set of all indexes of the tuple, through <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><i>index_sequence</i></a> .  The resulting tuple is formed from the results of the execution of the function specified through <i>callback</i> over the elements for each of the indices. <br><br><div class="spoiler">  <b class="spoiler_title">Example 1. Banal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapCallback</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Index, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T&amp;&amp; element )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"( "</span></span> &lt;&lt; Index &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; element &lt;&lt; <span class="hljs-string"><span class="hljs-string">" )"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> result; result &lt;&lt; ss; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sourceTyple = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple( <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-string"><span class="hljs-string">"boo"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> strTuple = tuple_utils::mapTuple( MapCallback(), sourceTyple ); }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Example 2. Forming a tuple of getter values</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   getter'      template&lt;class TResult, class TOwner&gt; using TGetter = TResult( TOwner::* )() const; // ,  getter'   template&lt;class TGetterOwner, class ...TParams&gt; class MyGetterContainer { //   getter'     template&lt;class TResult&gt; using TMyGetter = TGetter&lt;TResult, TGetterOwner&gt;; ..... protected: ..... //    getter' std::tuple&lt;TParams...&gt; getterValues() const; private: ..... //  ,     getter' TGetterOwner&amp; m_getterOwner; //  getter'   (..    ) std::tuple&lt;TMyGetter&lt;TParams&gt;...&gt; m_getters; }; namespace { // callback,   getter' template&lt;class TGetterOwner&gt; struct GetterValuesCallback { public: //  GetterValuer( const TGetterOwner&amp; getterOwner ) : m_getterOwner( getterOwner ) { } //  ,   getter';      getter' //     'Index'       template&lt;std::size_t Index, class T&gt; T operator()( const TGetter&lt;T, TGetterOwner&gt;&amp; oneGetter ) { return ( m_getterOwner.*oneGetter )(); } private: const TGetterOwner&amp; m_getterOwner; }; } // template&lt;class TGetterOwner, class ...TParams&gt; std::tuple&lt;TParams...&gt; MyGetterContainer&lt;TGetterOwner, TParams...&gt;::getterValues() const { //  callback         getter' return tuple_utils::mapTuple( GetterValuesCallback&lt;TGetterOwner&gt;( m_getterOwner ), m_getters ); }</span></span></code> </pre></div></div><br><h2>  Call </h2><br>  What else would like to ‚Äúbe able to do‚Äù with tuples is to use their contents as parameters for calling a function (of course, the order and type of arguments corresponds to the order and type of elements of the tuple).  The implementation of this function is very similar to the implementation of the <b>map</b> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tuple_utils { <span class="hljs-comment"><span class="hljs-comment">//  'callback',       'tuple' /* struct callback { template&lt;class TResult, class ...TParams&gt; TResult operator()( TParams... ) { // do something } }; callTuple( callback(), myTuple ); */ template&lt;class TCallback, class ...TParams&gt; auto callTuple( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ); namespace { template&lt;class TCallback, class TTuple, std::size_t... Indices&gt; auto callTuple_( TCallback&amp; callback, const TTuple&amp; tuple, std::index_sequence&lt;Indices...&gt; ) { return callback( std::get&lt;Indices&gt;( tuple )... ); } } // template&lt;class TCallback, class ...TParams&gt; auto callTuple( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ) { return callTuple_( callback, tuple, std::index_sequence_for&lt;TParams...&gt;() ); } } // tuple_utils</span></span></code> </pre><br>  Here, as in the case of <b>map</b> , the auxiliary function <i>callTuple_</i> is <i>used</i> , which takes an additional parameter, a set of all indexes of the tuple, via the <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><i>index_sequence</i></a> .  It calls the function specified via <i>callback</i> , passing to it all elements of the tuple corresponding to the indices.  The result of its execution is the result of the execution of the transferred function. <br><br><div class="spoiler">  <b class="spoiler_title">Example 1. Banal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; txt )</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallCallback</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">()( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> checkSomething( params... ); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; paramsTyple = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple( <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-string"><span class="hljs-string">"boo"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isParamsValid = tuple_utils::callTuple( CallCallback(), paramsTyple ); }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Example 2. Calling setter with getter value parameters</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  getter'   template&lt;class TGetterOwner, class ...TParams&gt; class MyGetterContainer { ..... protected: ..... //    getter' std::tuple&lt;TParams...&gt; getterValues() const; ..... }; //   setter'   void- c  template&lt;class TOwner, class ...TParams&gt; using TSetter = void( TOwner::* )( TParams... ); // ,  setter     getter'  template&lt;class TSetterOwner, class TGetterOwner, class ...TParams&gt; class MySetterCaller : public MyGetterContainer&lt;TGetterOwner, TParams...&gt; { //   getter'        using TMySetter = TSetter&lt;TSetterOwner, TParams...&gt;; ..... public: ..... //  setter   getter' void callSetter(); private: ..... //  ,     setter TSetterOwner&amp; m_setterOwner; //  setter TMySetter m_setter; }; namespace { // callback,   setter' template&lt;class TSetterOwner, class ...TParams&gt; struct CallSetterCallback { public: //  GetterPasser( TSetterOwner&amp; setterOwner, TSetter&lt;TSetterOwner, TParams...&gt; setter ) : m_setterOwner( setterOwner ), m_setter( setter ) { } //  ,   setter' void operator()( TParams... params ) { return ( m_setterOwner.*m_setter )( params... ); } private: TSetterOwner&amp; m_setterOwner; TSetter&lt;TSetterOwner, TParams...&gt; m_setter; }; } // template&lt;class TSetterOwner, class TGetterOwner, class ...TParams&gt; void MySetterCaller&lt;TSetterOwner, TGetterOwner, TParams...&gt;::callSetter() { //     getter' std::tuple&lt;TParams...&gt; _getterValues = getterValues(); //  callback   setter'    tuple_utils::callTuple( CallSetterCallback( m_setterOwner, m_setter ), _getterValues ); }</span></span></code> </pre></div></div><br>  <b>PS</b> In C ++ 17, <a href="http://en.cppreference.com/w/cpp/utility/apply"><i>std :: apply</i></a> will be available, which performs the same functionality. <br><br><h2>  General remarks </h2><br><ul><li>  Passing an index to <i>callback</i> <br>  In the implementations above, the index of the element to be processed by the <i>callback was</i> passed to the <i>callback</i> .  And it was passed not as an argument, but as a parameter of the <i>callback</i> itself.  It is done this way to expand the scope of functions, since  such a transfer allows you to call inside template <i>callback</i> functions (using an index as a parameter) and generally use the index as a parameter to instantiate anything that would be impossible if you pass the index as a function argument. </li><li>  Transfer <i>callback</i> <br>  In all implementations above, <i>callback</i> transmission is carried out by reference (and not by value).  This is done so that the caller <i>controls the</i> lifetime of the particular <i>callback</i> used (and not its copies). </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">One more example.</b>  <b class="spoiler_title">Converting Method Handlers to Functor Handlers</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   -  void-    template&lt;class TObject, class TValue&gt; using TMethodHandler = void( TObject::* )( const TValue&amp; ); // ,  - template&lt;class ...TValues&gt; class MyHandlerContainer { public: // ;     - MyHandlerContainer( const std::function&lt;void( const TValues&amp; )&gt;... handlers ); ..... //       - template&lt;class TMethodOwner&gt; static MyHandlerContainer&lt;TValues...&gt;* createFrom( TMethodOwner&amp; methodOwner, TMethodHandler&lt;TMethodOwner, TValues&gt;... handlers ); ..... }; namespace { // callback    - template&lt;class TMethodOwner&gt; struct CheckCallback { //  CheckCallback() : IsValid( true ) { } //     - template&lt;std::size_t Index, class TValue&gt; void operator()( const TMethodHandler&lt;TMethodOwner, TValue&gt;&amp; oneMethodHandler ) { if( oneMethodHandler == nullptr ) IsValid = false; } bool IsValid; } // callback    -   - template&lt;class TMethodOwner&gt; struct FunctorHandlerCallback { public: //  FunctorHandlerCallback( TMethodOwner&amp; methodOwner ) : m_methodOwner( methodOwner ) { } //   -  - template&lt;std::size_t Index, class TValue&gt; std::function&lt;void( const TValue&amp; )&gt; operator()( const TMethodHandler&lt;TMethodOwner, TValue&gt;&amp; oneHandlers ) { return [ this, oneHandlers ]( const TValue&amp; tValue ) { ( m_methodOwner.*oneHandlers )( tValue ); }; } private: TMethodOwner&amp; m_methodOwner; }; // callback     'MyHandlerContainer'   - template&lt;class ...TValues&gt; struct CreateCallback { //     'MyHandlerContainer'   - auto operator()( std::function&lt;void( const TValues&amp; )&gt;... handlers ) { return new MyHandlerContainer&lt;TValues...&gt;( handlers... ); } }; } // template&lt;class ...TValues&gt; template&lt;class TMethodOwner&gt; MyHandlerContainer&lt;TValues...&gt;* MyHandlerContainer&lt;TValues...&gt;::createFrom( TMethodOwner&amp; methodOwner, TMethodHandler&lt;TMethodOwner, TValues&gt;... handlers ) { //  - auto methodsTuple = std::make_tuple( handlers... ); // ,     CheckCallback checkCallback; tuple_utils::tupleForeach( checkCallback, methodsTuple ); //     if( checkCallback.IsValid ) { // (,        ) FunctorHandlerCallback&lt;TMethodOwner&gt;* functorHandlerCallback = new FunctorHandlerCallback&lt;TMethodOwner&gt;( methodHolder ); //  - auto handlersTuple = tuple_utils::mapTuple( *functorHandlerCallback, methodsTuple ); //    -   'MyHandlerContainer' MyHandlerContainer&lt;TValues...&gt;* result = tuple_utils::callTuple( CreateCallback&lt;TValues...&gt;( multiProperty ), handlersTuple ); return result; } //      assert( false ); return nullptr; }</span></span></code> </pre></div></div><br><br><h2>  Implementation without <i>index_sequence</i> </h2><br>  <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><i>index_sequence</i></a> appears only in C ++ 14.  If you want to use these functions in C ++ 11 (in which the tuple appeared), either for some other reason you do not want to use <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><i>index_sequence</i></a> , or it‚Äôs just interesting to see the implementation of the <b>map</b> and <b>call</b> functions without them, here‚Äôs the implementation: <br><br><div class="spoiler">  <b class="spoiler_title">Map</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tuple_utils { <span class="hljs-comment"><span class="hljs-comment">//   tuple (tuple  )    'callback'    tuple' /* struct callback { template&lt;std::size_t, class R, class T&gt; R operator()( T&amp;&amp; element ) { // do something } }; mapTuple( callback(), myTuple ); */ template&lt;class TCallback, class TSourceTuple&gt; auto mapTuple( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple ); namespace { template&lt;std::size_t Index, class TCallback, class TSourceTuple, std::size_t... Indices&gt; struct _map_ { auto static mapTuple_( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple ) { const std::size_t idx = std::tuple_size&lt;TSourceTuple&gt;::value - Index; return _map_&lt;Index - 1, TCallback, TSourceTuple, Indices..., idx&gt;::mapTuple_( callback, sourceTuple ); } }; template&lt;class TCallback, class TSourceTuple, std::size_t... Indices&gt; struct _map_&lt;0, TCallback, TSourceTuple, Indices...&gt; { auto static mapTuple_( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple ) { return std::make_tuple( callback.operator()&lt;Indices&gt;( std::get&lt;Indices&gt;( sourceTuple ) )... ); } }; } // template&lt;class TCallback, class TSourceTuple&gt; auto mapTuple( TCallback&amp; callback, const TSourceTuple&amp; sourceTuple ) { return _map_&lt;std::tuple_size&lt;TSourceTuple&gt;::value, TCallback, TSourceTuple&gt;::mapTuple_( callback, sourceTuple ); } } // tuple_utils</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Call</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tuple_utils { <span class="hljs-comment"><span class="hljs-comment">//  'callback',      tuple /* struct callback { template&lt;class TResult, class ...TParams&gt; TResult operator()( TParams... params ) { // do something } }; callTuple( callback(), myTuple ); */ template&lt;class TCallback, class TResult, class ...TParams&gt; TResult callTuple( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ); namespace { template&lt;std::size_t Index, class TCallback, class TResult, class TTuple, class ...TParams&gt; struct _call_ { static TResult callTuple_( TCallback&amp; callback, const TTuple&amp; tuple, TParams... params ) { const std::size_t idx = std::tuple_size&lt;TTuple&gt;::value - Index; return _call_&lt;Index - 1, TCallback, TResult, TTuple, TParams..., typename std::tuple_element&lt;idx, TTuple&gt;::type&gt;::callTuple_( callback, tuple, params..., std::get&lt;idx&gt;( tuple ) ); } }; template&lt;class TCallback, class TResult, class TTuple, class ...TParams&gt; struct _call_&lt;0, TCallback, TResult, TTuple, TParams...&gt; { static TResult callTuple_( TCallback&amp; callback, const TTuple&amp; tuple, TParams... params ) { return callback( params... ); } }; } // template&lt;class TCallback, class TResult, class ...TParams&gt; TResult callTuple( TCallback&amp; callback, const std::tuple&lt;TParams...&gt;&amp; tuple ) { return _call_&lt;sizeof...( TParams ), TCallback, TResult, std::tuple&lt;TParams...&gt;&gt;::callTuple_( callback, tuple ); } } // tuple_utils</span></span></code> </pre></div></div><br>  The approach to implementing these functions is the same: we manually ‚Äúaccumulate‚Äù indices (instead of <a href="http://en.cppreference.com/w/cpp/utility/integer_sequence"><i>index_sequence</i></a> ) or parameters, and then, at the end of the recursion, perform the necessary actions with the already obtained set of indices / parameters.  Although I personally approach with the index seems more universal. <br><br>  Thank you for your time! </div><p>Source: <a href="https://habr.com/ru/post/318236/">https://habr.com/ru/post/318236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318226/index.html">NetApp SnapLock ‚Ñ¢ - Licensed Data Protection Feature (WORM)</a></li>
<li><a href="../318228/index.html">Hacking on board the aircraft</a></li>
<li><a href="../318230/index.html">Information hygiene in a country with non-free Internet</a></li>
<li><a href="../318232/index.html">What is enterprise architecture, and why was Zachman wrong?</a></li>
<li><a href="../318234/index.html">Oracle Database History ‚Äî First Commercially Successful Relational DBMS</a></li>
<li><a href="../318238/index.html">VulnHub: Exploiting the buffer overflow vulnerability in Lord Of The Root</a></li>
<li><a href="../318240/index.html">"Distribution in request" or "we get rid of search"</a></li>
<li><a href="../318242/index.html">Yii2 RESTful API for AngularJS</a></li>
<li><a href="../318244/index.html">10 new tales of lost time</a></li>
<li><a href="../318246/index.html">IBM Watson will help NASA to surf the universe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>