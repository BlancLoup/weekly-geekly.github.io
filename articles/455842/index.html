<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Double-page list rotation. Swift Edition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's no secret that one of the favorite fun for a software developer is interviewing employers. We all do this from time to time and for completely di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Double-page list rotation. Swift Edition</h1><div class="post__text post__text-html js-mediator-article">  It's no secret that one of the favorite fun for a software developer is interviewing employers.  We all do this from time to time and for completely different reasons.  And the most obvious of them - the search for work - I think, not the most common.  Attending an interview is a good way to keep yourself in shape, repeat forgotten basics and learn something new.  And if successful, also increase self-reliance.  We get bored, we expose ourselves to the status of "open to suggestions" in some "business" social network like <a href="http://linkedin.com/">"LinkedIn"</a> - and the army of human resources managers are already attacking our inboxes. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/bw/9r/mc/bw9rmcigk0k9beg-50tdq74sadw.jpeg" alt="image"><br><br>  In the process, while all this bedlam is created, we are faced with a lot of questions that, as they say on the other side of the implicitly-collapsed curtain, ‚Äúring a bell‚Äù, and their details disappeared behind the <a href="https://en.wikipedia.org/wiki/Fog_of_war">fog of war</a> .  They are often remembered only in the tests for algorithms and data structures (I personally did not have such) and the interviews themselves. <br><br>  One of the most common questions at the interview for the post of programmer of any specialization is the lists.  For example, single-linked lists.  And the associated basic algorithms.  For example, turn.  And usually it happens something like this: ‚ÄúWell, how would you expand a simply linked list?‚Äù The main thing is to catch the applicant by surprise. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Actually, all this led me to write this short review for constant reminder and edification.  So, joking aside, behold! <br><br><h2>  Singly linked list </h2><br>  <a href="https://en.wikipedia.org/wiki/Linked_list">A linked list</a> is one of the basic <a href="https://en.wikipedia.org/wiki/Data_structure">data structures</a> .  Each element (or node) of it consists of, in fact, stored data and references to neighboring elements.  A singly linked list stores only the link to the next element in the structure, and a <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly linked</a> list to the next and previous one.  Such an organization of data allows them to be located in any area of ‚Äã‚Äãmemory (unlike, for example, an <a href="https://en.wikipedia.org/wiki/Array_data_structure">array</a> , all the elements of which should be located in memory one after the other). <br><br>  You can say a lot more about lists, of course: they can be circular (that is, the last element stores a link to the first one) or not (that is, there is no link to the last element).  Lists can be typed, i.e.  contain data of one type or not.  And so on and so forth. <br><br>  Better try to write some code.  For example, somehow you can imagine a list node: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(payload: <span class="hljs-type"><span class="hljs-type">T</span></span>, nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload = payload <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.nextNode = nextNode } }</code> </pre> <br>  <a href="https://en.wikipedia.org/wiki/Generic_programming">‚ÄúGeneric‚Äù is a</a> type that is capable of storing any type of <code>payload</code> in the <code>payload</code> field. <br><br>  The list itself is exhaustively identified only by the first node: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.firstNode = firstNode } }</code> </pre><br>  The first node is declared optional, because the list may well be empty. <br><br>  <i>The idea is, of course, that in the class it is necessary to implement all the necessary methods - insertion, deletion, access to nodes, etc., but we will deal with this some other time.</i>  <i>At the same time, we will check whether the use of a <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html"><code>struct</code></a> (to which <a href="https://apple.com/">Apple is</a> actively encouraged <a href="https://apple.com/">by</a> our example) is a more advantageous choice, and recall the <a href="https://en.wikipedia.org/wiki/Copy-on-write">‚ÄúCopy-on-write‚Äù</a> approach.</i> <br><br><h2>  Spreading a single linked list </h2><br><h3>  The first way.  Cycle </h3><br>  It's time to do business for which we are here today!  And the most effective they can do in two ways.  The first is a simple loop, from the first to the last node. <br><br>  The cycle works with three variables, which before the beginning is assigned the value of the previous, current and next node.  (At this point, the value of the previous node is, of course, empty.) The cycle begins by checking that the next node is not empty, and, if so, the body of the loop is executed.  There is no magic in the loop: the current node referring to the next element is assigned a reference to the previous one (on the first iteration, the reference value is reset to zero, which corresponds to the state of affairs in the last node).  Well, then the variables corresponding to the previous, current and next node are assigned new values.  After exiting the loop, the current (ie, generally the last iterated) node is assigned a new value of the reference to the next node, since  the exit from the cycle occurs just at the moment when the last node in the list becomes current. <br><br>  In words, of course, it all sounds strange and incomprehensible, so it's better to see the code: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previousNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentNode = firstNode <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode = firstNode?.nextNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nextNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { currentNode?.nextNode = previousNode previousNode = currentNode currentNode = nextNode nextNode = currentNode?.nextNode } currentNode?.nextNode = previousNode firstNode = currentNode } }</code> </pre><br>  For verification, we will use the list of nodes whose payloads are simple <a href="https://developer.apple.com/documentation/swift/int">integer</a> identifiers.  Create a list of ten items: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(payload: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// T == Int let list = SinglyLinkedList(firstNode: node) var currentNode = node var nextNode: Node&lt;Int&gt; for id in 1..&lt;10 { nextNode = Node(payload: id) currentNode.nextNode = nextNode currentNode = nextNode }</span></span></code> </pre><br>  Everything seems to be fine, but you and I are people, not computers, and it would be good for us to get a visual proof of the correctness of the list created and the algorithm described above.  Perhaps simple printing will be enough.  To make the output readable, add the implementation of the <a href="https://developer.apple.com/documentation/swift/customstringconvertible"><code>CustomStringConvertible</code></a> protocol <a href="https://developer.apple.com/documentation/swift/customstringconvertible"><code>CustomStringConvertible</code></a> node with a numeric identifier: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstPart = <span class="hljs-string"><span class="hljs-string">""" Node \(Unmanaged.passUnretained(self).toOpaque()) has id \(payload) and """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextNode = nextNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" next node \(nextNode.payload)."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" no next node."</span></span> } } }</code> </pre><br>  ... And the corresponding list to display all nodes in order: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description = <span class="hljs-string"><span class="hljs-string">""" List \(Unmanaged.passUnretained(self).toOpaque()) """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += <span class="hljs-string"><span class="hljs-string">" has nodes:\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += (node!.description + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) node = node!.nextNode } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description + <span class="hljs-string"><span class="hljs-string">" has no nodes."</span></span> } } }</code> </pre><br>  The string representation of our types will contain an address in memory and an integer identifier.  With the help of such assistance, we organize the printing of the generated list of ten nodes: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Expand this list and print it again: <br><br><pre> <code class="swift hljs">list.<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e8820 has id 9 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 6. Node 0x00006000012e8900 has id 6 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 0. Node 0x00006000012e2380 has id 0 and no next node. */</span></span></code> </pre><br>  In the output you can see that the addresses in the memory of the list and the nodes have not changed, and the nodes of the list are printed in the reverse order.  References to the next element of the node now point to the previous one (i.e., for example, the next element of the node ‚Äú5‚Äù is no longer ‚Äú6‚Äù, but ‚Äú4‚Äù).  And that means we did it! <br><br><h3>  The second way.  Recursion </h3><br>  The second known way to do this is based on <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursion</a> .  To implement it, we will declare a function that accepts the first node of the list, and returns the ‚Äúnew‚Äù first node (which was the last before). <br><br>  The parameter and the return value are optional, because inside this function it is called again and again on each subsequent node until it is empty (that is, until the end of the list is reached).  Accordingly, it is necessary to check in the function body whether the node on which the function is called and whether the node has the following is empty.  If not, the function returns the same that was passed to the argument. <br><br>  Actually, I honestly tried to describe the full algorithm in words, but in the end I erased almost everything I wrote, because the result would be impossible to understand.  To draw flowcharts and formally describe the steps of the algorithm - also in this case, I think, it does not make sense, because it will be more convenient for us to just read and interpret the code in <a href="https://swift.org/">‚ÄúSwift‚Äù</a> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverseRecursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node&lt;T&gt;?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = node <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> head.nextNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reversedHead = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(head.nextNode) head.nextNode?.nextNode = head head.nextNode = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversedHead } firstNode = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(firstNode) } }</code> </pre><br>  The algorithm itself is "wrapped" by the type of the list itself, for convenience of the call. <br><br>  It looks shorter, but, in my opinion, more difficult to understand. <br><br>  Let's call this method on the result of the previous reversal and print the new result: <br><br><pre> <code class="swift hljs">list.reverseRecursively() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  From the output, it is clear that all the addresses in memory have not changed again, and the nodes now follow the original order (that is, they ‚Äúunfolded‚Äù one more time).  And that means we did it again! <br><br><h3>  findings </h3><br>  If you look at the reversal methods carefully (or conduct an experiment with counting calls), you will notice that the cycle in the first case and the internal (recursive) method call in the second case occur one time less than the number of nodes in the list (in our case, nine time).  You can also pay attention to what is happening around the loop in the first case - the same chain of assignments - and on the first, non-recursive, method call in the second case.  It turns out that in both cases the ‚Äúcircle‚Äù is repeated exactly ten times for a list of ten nodes.  Thus, we have linear <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">complexity</a> for both algorithms - O (n). <br><br>  Generally speaking, the two described algorithms are considered the most effective for solving this problem.  With regard to computational complexity, the ability to come up with an algorithm with a lower value is not possible: one way or another, it is necessary to ‚Äúvisit‚Äù each node to assign a new value for the link stored inside. <br><br>  Another characteristic worth mentioning is ‚Äúmemory complexity‚Äù.  Both proposed algorithms create a fixed number of new variables (three in the first case and one in the second).  This means that the amount of allocated memory does not depend on the quantitative characteristics of the input data and is described by the constant function - O (1). <br><br>  But, in fact, in the second case it is not.  The danger of recursion is that additional memory is allocated for each recursive call on the <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a> .  In our case, the recursion depth corresponds to the amount of input data. <br><br>  And finally, I decided to experiment a little more: in a simple and primitive way, I measured the absolute execution time of the two methods for different amounts of input data.  Like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startDate = <span class="hljs-type"><span class="hljs-type">Date</span></span>().timeIntervalSince1970 <span class="hljs-comment"><span class="hljs-comment">// list.reverse() / list.reverseRecursively() let finishDate = Date().timeIntervalSince1970 let runningTime = finishDate ‚Äì startDate // Seconds</span></span></code> </pre><br>  And that's what I got (this is the "raw" data from the <a href="https://apple.com/swift/playgrounds/">"Playground"</a> ): <br><br><img src="https://habrastorage.org/webt/kf/at/bf/kfatbfsxar9clyyokzu6beu3ios.png" alt="image"><br><br>  (Unfortunately, my computer has not mastered the larger values.) <br><br>  What can be seen from the table?  So far, nothing special.  Although it is already noticeable that the recursive method behaves slightly worse with a relatively small number of nodes, but somewhere between 100 and 1000 starts to show itself better. <br><br>  I also tried the same simple test inside a full-fledged <a href="https://developer.apple.com/xcode">‚ÄúXcode‚Äù</a> project.  The results were as follows: <br><br><img src="https://habrastorage.org/webt/sr/vj/0d/srvj0dqmtgtse2wfuqq6llutte4.png" alt="image"><br><br>  Firstly, it is worth mentioning that the results were obtained after the activation of the ‚Äúaggressive‚Äù optimization mode aimed at execution speed ( <code>-Ofast</code> ), which is partly why the numbers are so small.  It is also interesting that in this case the recursive method showed itself a little better, on the contrary, only on very small sizes of input data, and already on the list of 100 nodes, the method loses.  Out of 100,000, he made the program crash at all. <br><br><h2>  Conclusion </h2><br>  I tried to highlight a rather classical topic from the point of view of my currently favorite programming language and, I hope, you were curious to follow the progress as well as myself.  And I am very glad if you managed to learn something new - then I definitely did not waste time on this article (instead of sitting and watching TV shows). <br><br>  If someone has a desire to track my social activity, here is a link to <a href="https://twitter.com/lazarevzubov">my Twitter</a> , where links to my new posts appear first and a little more. </div><p>Source: <a href="https://habr.com/ru/post/455842/">https://habr.com/ru/post/455842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455830/index.html">A look at Go through the eyes of a .NET developer. Week # 1</a></li>
<li><a href="../455832/index.html">The story of a single SQL investigation</a></li>
<li><a href="../455834/index.html">Benchmarks for Linux servers: 5 open tools</a></li>
<li><a href="../45584/index.html">Amarok 2 RC1 came out and is in the repositories.</a></li>
<li><a href="../455840/index.html">How to work with multiple queries. Composition, Reducer, OP</a></li>
<li><a href="../455844/index.html">Creating a Roslyn analyzer using the encapsulation test as an example</a></li>
<li><a href="../455846/index.html">Distributed computing in Julia</a></li>
<li><a href="../455852/index.html">Sinus lifting and simultaneous implantation</a></li>
<li><a href="../455854/index.html">How to implement context menus (Context Menu) in iOS 13</a></li>
<li><a href="../455856/index.html">Wireless temperature, humidity and atmospheric pressure sensor on the nRF52832</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>