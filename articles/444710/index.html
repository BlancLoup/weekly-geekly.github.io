<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We understand the protocol of consensus Stellar</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The consensus protocol Stellar was first described in a scientific article by David Mazier in 2015. It is a ‚Äúfederal Byzantine agreement system‚Äù that ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We understand the protocol of consensus Stellar</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d61/191/bb6/d61191bb66df2fb90fda24b86afb49b2.gif"><br><br>  The consensus protocol Stellar was first described in a <a href="https://www.stellar.org/papers/stellar-consensus-protocol.pdf">scientific article by</a> David Mazier in 2015.  It is a ‚Äúfederal Byzantine agreement system‚Äù that allows decentralized computing networks without leaders to effectively reach consensus on any decision.  The Stellar payment network uses the Stellar Consensus Protocol (SCP) to maintain a consistent transaction history that all participants see. <br><br>  Consensus protocols are considered difficult to understand.  SCP is simpler than most of them, but still shares this reputation ‚Äî partly because of the erroneous idea that the ‚Äúfederal vote‚Äù to which the first half of a research article is dedicated is SCP.  But it is not so!  This is only an important building block, which in the second half of the article is used to create the <i>actual</i> Stellar consensus protocol. <br><a name="habracut"></a><br>  In this article we will briefly describe what the ‚Äúsystem of agreements‚Äù is, what can make it ‚ÄúByzantine‚Äù, and why make the Byzantine system ‚Äúfederal‚Äù.  Then we will explain the federal voting procedure described in the SCP article, and, finally, we will explain the SCP protocol itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Agreement Systems </h1><br>  The system of agreements allows a group of participants to come to a consensus on some topic, for example, what to order for lunch. <br><br>  At Interstellar, we have implemented our own dining agreement system: ordering what our operations manager, John, says.  This is a simple and effective system of agreements.  We all trust John and believe that every day he will find something interesting and nutritious. <br><br>  But what if John misuses our trust?  He can single-handedly decide that we all have to become vegans.  In a week or two, we will probably overthrow him and transfer the powers to Elizabeth.  But suddenly she loves avocados with anchovies and thinks that everyone should become like that.  Power corrupts.  Therefore, it is better to find some more democratic method: some way to make sure that different preferences are taken into account, while providing a timely and unambiguous result so that it does not happen that no one orders lunch or five people place different orders, or the discussion drags on until evening. <br><br>  It would seem that the solution is simple: take a vote!  But this is a deceptive impression.  Who will collect the newsletters and report the results?  And why should the rest believe what he says?  Perhaps we can <i>first</i> vote for a leader whom we trust to lead the vote - but who will lead this <i>first</i> vote?  What if we can't agree on a leader?  Or if we agree, does this leader get stuck in a meeting or go to the hospital? <br><br>  Similar problems are found in distributed computer networks.  All participants or nodes must agree on a solution, for example, whose turn it is to update a common file or to take a task from the processing queue.  In a cryptocurrency network, nodes repeatedly have to choose what the full story looks like from several possible versions that sometimes conflict.  This network agreement gives a guarantee to the recipient that the coin is (a) valid (not fake) and (b) not yet spent elsewhere.  It also guarantees that he will be able to spend coins in the future, because the new recipient will have the same guarantees for the same reasons. <br><br>  Any matching system in a distributed computer network must be fault tolerant: it must produce consistent results, despite errors such as slow links, unresponsive nodes, and the wrong message order.  <i>The Byzantine</i> system of agreements is additionally resistant to ‚ÄúByzantine‚Äù errors: nodes that give false information, either because of an error or in a deliberate attempt to undermine the system or gain some advantage.  ‚ÄúByzantine‚Äù resiliency ‚Äî the ability to trust a group decision, even when some members of the group may lie or otherwise not follow the rules of decision making ‚Äî was named after the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25B2%25D0%25B8%25D0%25B7%25D0%25B0%25D0%25BD%25D1%2582%25D0%25B8%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B8%25D1%2585_%25D0%25B3%25D0%25B5%25D0%25BD%25D0%25B5%25D1%2580%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B2">parable of the generals of the Byzantine Empire</a> who tried to coordinate the attack.  Anthony Stevens has a <a href="https://medium.com/coinmonks/a-note-from-anthony-if-you-havent-already-please-read-the-article-gaining-clarity-on-key-787989107969">good description</a> . <br><br>  Consider the owner of a cryptomonet, Alice, who must choose between buying delicious ice cream from Bob and paying Carol debt.  Perhaps Alice wants to pay both at once, fraudulently spending the same coin.  To do this, she must convince Bob‚Äôs computer that the coin was never paid to Carol, and convince Carol‚Äôs computer that the coin was never paid to Bob.  The Byzantine system of agreements makes it virtually impossible using the form of a majority rule, called a <i>quorum</i> .  A node in such a network refuses to switch to a certain version of the story until it sees that a sufficient number of peer nodes - a quorum - agree to such a switch.  Once this happens, they will form a sufficiently large electoral bloc to force the remaining network nodes to agree with their decision.  Alice can make some nodes lie on her behalf, but if the network is big enough, then her attempt will be suppressed by the voices of honest nodes. <br><br>  How many nodes are required for a quorum?  At a minimum, the majority, or more precisely, the qualified majority to deal with errors and fraud.  But in order to calculate the majority, you need to know the total number of participants.  In the Interstellar office or district elections, these numbers are easy to recognize.  But if your group is a weakly defined network, into which nodes can enter and exit at will without agreement with the center, then a <i>federal</i> Byzantine agreement system is needed that can determine quorums not from a predetermined list of nodes, but dynamically, from constantly changing and inevitably incomplete snapshot of nodes at a specific point in time. <br><br>  It may seem impossible to create a quorum from the point of view of a single node on a vast network, but it is possible.  Such a quorum can even guarantee the results of a decentralized vote.  The SCP white paper shows how to do this using a procedure called <i>federal voting</i> . <br><br><h1>  For impatient </h1><br>  The rest of the article describes in more detail the federal vote and the Stellar consensus protocol.  If you are not interested in the details, here is a general overview of the process. <br><br><ol><li>  Nodes conduct rounds of federal voting on "nominees".  A round of federal voting means: <br><ul><li>  A node votes for a statement, for example, ‚ÄúI propose a V value‚Äù; <br></li><li>  A node listens to the voices of peers until it finds one that can ‚Äúaccept‚Äù; <br></li><li>  The site is looking for a ‚Äúquorum‚Äù for this statement.  The quorum "confirms" the nominee. </li></ul></li><li>  As soon as a node can confirm one or more nominees, it tries to ‚Äúprepare‚Äù a ‚Äúbulletin‚Äù through several rounds of federal voting. <br></li><li>  As soon as the node is able to verify the readiness of the ballot, it tries to commit it using even more rounds of federal voting. <br></li><li>  Once the node can confirm the commit of the newsletter, it can ‚Äúexternalize‚Äù the value of this newsletter, using it as a result of consensus. </li></ol><br>  These steps include several rounds of federated voting, which together form a single SCP round.  We will understand in more detail what happens at each step. <br><br><h1>  Federated vote </h1><br>  Federated voting is the procedure for determining whether a network can agree on a proposal.  In a voting round, each node must choose one of potentially many possible values.  He cannot do this until he is sure that other nodes in the network will not choose a different result.  To be sure of this, nodes exchange a flurry of messages back and forth, so that everyone <i>confirms</i> that the <i>quorum of</i> nodes <i>makes</i> the same <i>decision</i> .  The rest of this section explains the terms in this sentence and how the whole procedure happens. <br><br><h1>  Quorums and Quorum Slices </h1><br>  Let's start by defining the quorum.  As we discussed above, in a decentralized network with dynamic membership it is impossible to know in advance the number of nodes and, therefore, how much is needed for most.  Federated voting solves this problem by introducing a new quorum slice idea: a small set of peers that the node trusts to transmit information about the state of the vote in the rest of the network.  Each node determines its own quorum slice (of which it becomes a member after the fact). <br><br>  The formation of a quorum begins with a cut of the quorum.  For each node, the nodes of its slice are added.  Then the members of the slices of <i>these nodes</i> are added <i>,</i> and so on.  As you continue, more and more nodes appear that you cannot add because they are already included in the slice.  When there are no more new nodes to add, the process stops: we have formed a quorum by ‚Äútransitive closure‚Äù (transitive closure) of the cut-off quorum of the initial node. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24f/13f/a42/24f13fa423c0f748a8a18a6451a50815.png"><br>  <i><font color="gray">To find the quorum from this node ...</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/746/820/ead/746820ead5d2d898a333851fef565965.png"><br>  <i><font color="gray">... we add members of its cutoff ...</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ad/198/03f/2ad19803ff449504de13bb60f6e14212.png"><br>  <i><font color="gray">... then add members to the slices of these nodes.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/709/d25/521/709d2552176aa897f933421ca4410661.png"><br>  <i><font color="gray">We continue until there are nodes to add.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b1/8b0/662/4b18b0662787f3a6d8420c2992113afa.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/138/d6c/11d/138d6c11deb2d32589eee523663d2682.png"><br>  <i><font color="gray">No nodes to add left.</font></i>  <i><font color="gray">This is a quorum.</font></i> <br><br>  In fact, each node can go into more than one slice.  To form a quorum, select only one of the slices and add members;  then select any slice for each member and add members to <i>that</i> slice, and so on.  This means that each node is a member of a set of possible quorums. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e7/f3d/e1a/8e7f3de1a529c59cb486ebd67f3bf8ec.png"><br>  <i><font color="gray">Select only one quorum slice at each step.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e34/14f/370/e3414f370b9ae824bf894069b547bf36.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4a/cb6/6e7/e4acb66e79e18c72db3c0839c1e76e25.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cb/cca/c69/0cbccac69b859093788ea2a37e6c3aed.png"><br>  <i><font color="gray">One possible quorum.</font></i>  <i><font color="gray">Or an alternative ...</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c26/7cc/911/c267cc911e0b6bbb6f1729c5a5003704.png"><br>  <i><font color="gray">... choose other sections ...</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f35/0a5/8fb/f350a58fba9d8b9c640edd7d273d6f15.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf4/73c/3fe/bf473c3fedaa8c8d98820485b24f3034.png"><br>  <i><font color="gray">...(when it's possible)‚Ä¶</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0b/b61/fc1/c0bb61fc1ed34f0ad6fb57711820dc83.png"><br>  <i><font color="gray">... creates another quorum.</font></i> <br><br>  How does the node know which slices the other nodes are in?  In the same way as other information about other nodes: from the transmissions that each node broadcasts to the network when its voting status changes.  Each broadcast includes information about the slicing of the sending node.  The SCP technical document does not specify a communication mechanism.  Implementations typically use <a href="https://en.wikipedia.org/wiki/Gossip_protocol">the gossip protocol</a> to ensure message translation across the entire network. <br><br>  Recall that in a non-federal Byzantine system of agreements, a quorum is defined as the majority of all nodes.  The Byzantine system of agreements is designed from the point of view of the question: how many dishonest nodes can the system carry?  In a system of N nodes designed for survival with f failures (deceptions), the node must be able to make progress after receiving a response from N ‚Äì f peers, since f of them may not function.  But having received a response from N ‚àí f peers, it can be assumed that all f peers (from which the node received no response) are in fact honest.  Thus, fs from N ‚àí f peers (from which the answer is received) are malicious.  In order for the nodes to arrive at one consensus, most of the remaining nodes must be honest, that is, we need N ‚àí f to be greater than 2f or N&gt; 3f.  So usually, a system designed for survival with f failures will have a total of N = 3f + 1 nodes and a quorum size of 2f + 1.  As soon as the proposal passes the quorum threshold, the rest of the network is convinced that any competing offers will fail.  So the network converges to the result. <br><br>  But in the federal Byzantine system of agreements, not only cannot there be a majority (because no one knows the overall size of the network), but the concept of the majority is generally useless!  If the membership in the system is open, then someone can get the majority, simply by conducting the so-called attack of the Sibyl: repeatedly joining the network through several nodes.  So why the transitive closure of the slice can be called a <i>quorum</i> , and how is it able to suppress competing offers? <br><br>  Technically, no way!  Imagine a network of six nodes where two triples are isolated in each other's quorum slices.  The first subgroup can make a decision about which the second will never hear, and vice versa.  There is no way for this network to reach consensus (except by chance). <br><br>  Therefore, the SCP requires that for federated voting (and for the application of the important theorems of the article) the network must have a property called <i>quorum intersection</i> .  In a network with this property, any two quorums that can be built always overlap in at least one node.  To determine the prevailing mood of the network is as good as having the majority.  Intuitively, this means that if a quorum agrees with statement X, no other quorum can ever agree with something else, because it will necessarily include some node from the first quorum that has already voted for X. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/399/d79/c47/399d79c473bba703f30e370d8dbd3832.png"><br>  <i><font color="gray">If the network has an intersection of quorums ...</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56b/04f/e6d/56b04fe6de47463d12959711a1c02de0.png"><br>  <i><font color="gray">... then any two quorum you can build ...</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e65/090/30b/e6509030b1532429b806b521c3009d2b.png"><br>  <i><font color="gray">... will always intersect.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e25/a00/b4f/e25a00b4fe739f7930dccd184be76302.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/06c/13b/e5e/06c13be5e94fc380e2b49f17de2e33e1.png"><br><br>  (Of course, overlapping nodes can be Byzantine false or bad in other ways. In this case, the intersection of quorums does not help the network to agree at all. For this reason, many of the results in the SCP technical document are based on explicit assumptions, such as what remains in the network intersection of quorums <i>even after the removal of bad nodes</i> . For simplicity, we leave these assumptions <i>implicit</i> in the rest of the article). <br><br>  It may seem unreasonable to expect that in a network of independent nodes it is possible to reliably intersect quorums.  But there are two reasons why this is so. <br><br>  The first reason is the existence of the Internet itself.  The Internet is an ideal example of a network of independent nodes with quorum intersection.  Most of the nodes on the Internet connect to only a few other local nodes, but these small sets overlap enough for each node to be accessible from every other node along a particular route. <br><br>  The second reason is specific to the Stellar payment network (the most common use of SCP).  Each asset in the Stellar network has an issuer, and Stellar recommendations require that each issuer designate one or more nodes in the network to process redemption requests.  It is in your interest to directly or indirectly include these nodes in quorum sections for each asset of interest.  Then the quorums for all nodes interested in this asset will overlap at least in these nodes of maturity.  The nodes interested in several assets will include all the redemption nodes of the respective issuers in their quorum sections, and they will strive to consolidate all the assets together.  In addition, any assets that are not connected in this way with others on the network, and <i>should not be linked</i> - so conceived that for this network there is no crossing of quorums (for example, banks from the dollar zone sometimes want to trade with banks from the euro zone and banks from the peso zone, so they are on the same network, but none of them care about a separate network of children selling baseball cards). <br><br>  Of course, <i>waiting for</i> quorum crossing is not a <i>guarantee</i> .  Other Byzantine agreement systems owe their complexity to the guarantee of quorums.  An important innovation of SCP is that it removes the responsibility for creating quorums from the consensus algorithm itself and brings it to the application level.  Thus, although federal voting is fairly general for voting on any issues, in fact, its reliability critically depends on the wider meaning of these values.  Some hypothetical uses may not be as convenient for creating well-connected networks as others. <br><br><h1>  Voting, acceptance and confirmation </h1><br>  In the round of federal voting, the node optionally begins to vote for some value V. This means broadcasting a message to the network: ‚ÄúI am node N, my slices of quorums Q, and I vote for V.‚Äù  When a node votes in this way, it promises that it never voted against V and never will. <br><br>  In peer-to-peer broadcasts, each node sees how the others vote.  As soon as the node collects a sufficient number of such messages, it can track the quorum slices and try to find quorums.  If he sees a quorum of peers who also vote for V, he can proceed to <i>adopt</i> V and broadcast this new message to the network: "I am node N, my sections of quorum Q, and I accept V".  Adoption provides a stronger guarantee than simple voting.  When a node votes for V, it can never vote for other options.  But if a node accepts V, no other node on the Web will ever accept another option (Theorem 8 in the SCP technical paper proves this). <br><br>  Of course, there is a high probability that there will not immediately be a quorum of nodes that will agree with V. Other nodes can vote for other values.  But for a node there is another way to move from simple voting to adoption.  N can take a different value of W, even if it did not vote for it, and even if it does not see a quorum for it.  To decide to change your voice, it is enough to see the <i>blocking set of</i> nodes that have accepted W. The blocking set is one node of each of the slices of quorums N. As the name implies, it is able to <i>block</i> any other value.  If all nodes in such a set accept W, then (by Theorem 8) it will never be possible to form a quorum that takes a different value, and therefore it is also safe for N to accept W. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc2/b0f/6db/dc2b0f6db96bc646f9c13eed191934d9.png"><br>  <i><font color="gray">Node N with three slices of quorums.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b12/544/25a/b1254425aec3dde64f6c0025ea6e7c41.png"><br>  <i><font color="gray">BDF is the blocking set for N: it includes one node of each of the slices N.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/051/c90/ee2051c903689ee5ad2f0c4239e6c574.png"><br>  <i><font color="gray">BE is also a blocking set for N, because E appears in two slices N.</font></i> <br><br>  But the blocking set is not a quorum.  It would be too easy to deceive node N to assume the desired value if it is enough to crack just one node in each of the slices N. Therefore, accepting the value is not the end of the vote.  Instead, N must confirm the value, that is, see the quorum of the nodes receiving it.  If he goes this far, then, as the SCP technical document proves (in Theorem 11), the rest of the network will also ultimately confirm the same value, so N will complete the federative vote with a certain value as a result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6eb/682/405/6eb682405d056f88c1eb2b272875e269.png"><br>  <i><font color="gray">Federated voting.</font></i> <br><br>  The voting, acceptance and confirmation process constitutes one full round of federal voting.  The Stellar Consensus Protocol combines many such rounds to create a complete consensus system. <br><br><h1>  Consensus protocol Stellar </h1><br>  The two most important properties of the consensus system are <i>security</i> and <i>survivability</i> .  A consensus algorithm is ‚Äúsafe‚Äù if it can never give different results to different participants (a copy of Bob‚Äôs story will never contradict Carol).  ‚ÄúVitality‚Äù means that the algorithm will always produce a result, that is, it will not get stuck. <br><br>  The federated voting procedure described is <i>safe</i> in the sense that if a node confirms the value of V, no other node will confirm another value.  But "will not confirm another meaning" - this does not mean that he will confirm something.  Participants can vote for such a large number of different values ‚Äã‚Äãthat nothing reaches the acceptance threshold.  This means that there is no <i>survivability</i> in federative voting. <br><br>  The consensus protocol Stellar uses federated voting in such a way as to guarantee both security and survivability.  (The security guarantees and survivability of the SCP have a theoretical limit. The design chooses a very strong guarantee of safety, sacrificing a slight weakening of survivability, but given sufficient time, consensus is very likely to be reached).  In a nutshell, the idea is to run several federated polls on several values, until one of them passes completely through all the SCP voting phases described below. <br><br>  The values ‚Äã‚Äãby which the SCP seeks consensus may be a transaction history or a lunch order, or something else, but it is important to note that these are not values ‚Äã‚Äãthat are accepted or confirmed.  Instead, a federal vote occurs on <i>claims about these values</i> . <br><br>  The first rounds of federative voting take place at <i>the</i> nomination phase, on a set of ‚ÄúI nominate V‚Äù statements, possibly for many different values ‚Äã‚Äãof V. The goal of the nomination is to find one or more statements that go through acceptance and confirmation. <br><br>  After finding the confirmed candidates, the SCP proceeds to the voting stage, where the goal is to find some <i>bulletin</i> (that is, a container for the proposed value) and a quorum that can declare a <i>commit</i> for it (commit).  If a quorum commits a ballot, its value is accepted as a consensus.  But before the node can vote for a commit ballot, it must first confirm the <i>cancellation of</i> all ballots with a lower counter value.  These steps ‚Äî the abolition of ballots to find one for which you can confirm a commit ‚Äî include several rounds of federal voting on several bulletin statements. <br><br>  The following sections describe promotion and voting in more detail. <br><br><h1>  Advancement </h1><br>  At the beginning of the nomination stage, each node can spontaneously choose the value of V and vote for the statement ‚ÄúI put forward V‚Äù.  The goal at this stage is to confirm the nomination of a certain value by means of federal voting. <br><br>  It is possible that a sufficient number of nodes vote for quite different statements, and no nomination can reach the acceptance threshold.  Therefore, in addition to broadcasting their own nomination votes, the nodes ‚Äúreflect‚Äù the nominations of their peers.  Reflection (echo) means that if a node votes for nomination V, but sees a message from a neighbor voting for nomination W, it will now vote for nomination of both V and W. (Not all peer voices are reflected during the nomination, because this can lead to an explosion of different nominees.The SCP includes a mechanism for regulating these voices. In short, there is a formula for determining the ‚Äúpriority‚Äù of a peer from the point of view of a node, and only the votes of high-priority nodes are reflected.  the set of peers whose voices it will reflect.The priority formula as one of the input data includes the slot number, therefore the high priority peer for one slot may be low priority for another, and vice versa). <br><br>  Conceptually, the nomination of both V and W in parallel is separate federal voices, each individually capable of attaining acceptance or confirmation.  In practice, SCP messages pack these individual voices together. <br><br>  Although voting for nomination V is a promise never to vote against nomination V, at the application level ‚Äî in this case SCP ‚Äî it is defined what means ‚Äúagainst‚Äù.  The SCP does not see a statement that contradicts the ‚ÄúI nominate X‚Äù vote, that is, there is no ‚ÄúI am against X nomination‚Äù message, so the node can vote to nominate any values.  Many of these nominations will lead nowhere, but ultimately the node will be able to accept or confirm one or more values.  As soon as the nominee is confirmed, he becomes a <i>candidate</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/65e/c7d/c03/65ec7dc03a79b55877355e653fed6829.png"><br>  <i><font color="gray">Nomination of SCP using federated voting.</font></i>  <i><font color="gray">There may be many ‚ÄúB‚Äù values ‚Äã‚Äãpushed by peers and ‚Äúmirrored‚Äù by a node.</font></i> <br><br>  Nomination of candidates may result in several confirmed candidates.  Therefore, the SCP requires the application layer to provide some method of combining candidates into a single <i>composite</i> (composite).  The merge method can be any.  The main thing is that if this method is deterministic, then each node will combine the same candidates.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the voting system for the lunch "union" can simply mean the rejection of one of the two candidates. (But in a deterministic way: each node must choose the same value to reset. For example, an earlier selection in alphabetical order). In the Stellar payment network, where voting for transaction history takes place, combining the two proposed nominees involves combining the transactions they contain and the last of their two timestamps. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The technical description of the SCP proves (Theorem 12) that by the end of the extension phase, the network eventually converges to a single composite. But there is a problem: federated voting is an asynchronous protocol (like SCP). In other words, nodes are not coordinated by time, but only by messages that are sent. From a node's point of view, it is unclear when it </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ended.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extension phase. </font><font style="vertical-align: inherit;">And although all nodes will eventually come to the same composite, they can choose different routes along the way, creating different composite candidates on the way, and can never tell which one is final.</font></font><br><br>  But it normal.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nomination - only preparation. </font><font style="vertical-align: inherit;">The main thing to limit the number of candidates to reach a consensus, which occurs in the process of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balloting</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (balloting).</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ballot </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A bulletin is a pair of &lt;counter, value&gt;, where counter is an integer that starts with 1, and value is a candidate from the nomination stage. This can be a node‚Äôs own candidate or a neighbor‚Äôs candidate accepted by that node. Roughly speaking, when running for balloting, repeated attempts are being made to force the network to reach consensus on some candidate in a certain ballot by holding potentially many federal votes on statements about ballots. Bulletin counters track attempts made, and higher-counted ballots take precedence over lower-counted ballots. If the bulletin &lt;counter, value&gt; is stuck, a new vote begins, now on the bulletin &lt;counter + 1, value&gt;. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is </font><i><font style="vertical-align: inherit;">important</font></i><font style="vertical-align: inherit;"> to distinguish between </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">values.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(for example, what should be the order for lunch: pizza or salads), </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bulletins</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (counter-value pair) and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statements</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about bulletins. </font><font style="vertical-align: inherit;">The SCP round includes several rounds of federal voting, in particular, on such statements:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúI am ready to commit to bulletin B‚Äù and </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúI announce the committ of bulletin B‚Äù </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the point of view of this node, consensus is reached when it finds bulletin B, for which it can confirm (that is, find the quorum accepting) the statement ‚ÄúI announce the committ of bulletin B‚Äù. From this point on, you can safely act on the value specified in B ‚Äî for example, place this order for lunch. This is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">externalization of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> meaning. Once the acceptance of the bulletin is confirmed, the node can be sure that any other node has externalized the same value or necessarily will make it future.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although conceptually many federated ballots are held on statements of many different ballots, they do not exchange as many messages, because each message encapsulates a number of ballots. One message thus promotes the state of many federated polls at once, for example: ‚ÄúI accept a commit of ballots ranging from &lt;min, V&gt; to &lt;max, V&gt;‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does the term ‚Äúprepared‚Äù (prepared) and ‚Äúcommit‚Äù mean?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A node votes for a newsletter commit when it is convinced that other nodes will not commit newsletters with different values. The conviction is the purpose of the preparation of the application. A vote that says: ‚ÄúI am ready to commit newsletter B‚Äù is a promise to never commit a newsletter less than B, i.e. with a smaller counter (the SCP requires that the values ‚Äã‚Äãin the ballots have a certain order. bulletin &lt;N1, V1&gt; is less than &lt;N2, V2&gt; if N1 &lt;N2, and also if N1 = N2 and V1 &lt;V2). These smaller ballots are ‚Äúrejected‚Äù (aborted) during the preparatory voting, while B is considered ‚Äúprepared‚Äù.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why "I am ready to commit a bulletin B" means "I promise never to allow commits of ballots less than B"? Because SCP defines abort as the opposite of commit. Voting on the preparation of a ballot paper also implies voting on the cancellation of some other ballots, and, as we discussed earlier, voting for one thing is a promise to never vote against it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before broadcasting a commit, a node must first find a newsletter, which it can confirm as prepared. In other words, he conducts a federal vote on the topic ‚ÄúI am ready to commit newsletter B‚Äù, perhaps for many different ballots, until he finds one that accepts a quorum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where do the voting ballots come from? First, the node translates the preparation for voting for &lt;1, ‚Äã‚ÄãC&gt;, where C is the composite candidate made at the nomination stage. However, even after the start of preparation for voting, the nomination may lead to the appearance of additional candidates who will become new ballots. Meanwhile, peers may have different candidates, and they can form a blocking set that accepts ‚ÄúI am ready for the commit of bulletin B2‚Äù, which will convince the node to accept it too. Finally, there is a timeout mechanism that generates new rounds of federated voting on new ballots with higher counters if current ballots are stuck.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as the node finds the bulletin B, which can confirm as prepared, it transmits a new message ‚ÄúCommit of bulletin B‚Äù. This vote tells the feasts that the node will never give up on B. In fact, if B is a bulletin &lt;N, C&gt;, then ‚ÄúCommit &lt;N, C&gt;‚Äù means unconditional consent to vote for the readiness of each bulletin from &lt;N, C&gt; to &lt;‚àû, c&gt;. This additional value helps other nodes catch up with the commit peer if they are still at earlier stages of the protocol.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage it is worth emphasizing once again that these are asynchronous protocols. Just because a single node sends votes for a commit does not mean that its peers do it too. Some of them can still vote on statements to prepare for the vote, others may have already externalized significance. The SCP explains how a node should process each type of peer message, regardless of its phase.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the message ‚ÄúI declare a commit &lt;N, C&gt;‚Äù cannot be accepted or confirmed, then there is a probability of accepting or confirming the message &lt;N + 1, &gt; or &lt;N + 2, &gt; - or, in any case, any newsletter with a value of C, and not any other, since the node has already promised never to cancel &lt;N, C&gt;. By the time the node broadcasts voices for a commit, it will be C or nothing, depending on how far the consensus goes. However, this is not enough for the node to externalize C. Some Byzantine feasts (constituting less than a quorum, based on our assumptions about security) may lie to the node. Accepting and then confirming some kind of bulletin (or a range of bulletins) is what gives the node the confidence to finally externalize C.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a6/882/059/0a6882059dac957e22a9059c79d1d710.png"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCP balloting through federated vote. </font><font style="vertical-align: inherit;">Not shown: at any time a timer may work by increasing the count in the bulletin (and, possibly, to produce a new composite of additional candidates nominated). </font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And it's all! </font><font style="vertical-align: inherit;">Once the network has reached a consensus, it is ready to do it again and again. </font><font style="vertical-align: inherit;">In the Stellar payment network, this happens about once every 5 seconds: a feat that requires both security and survivability, guaranteed by SCP.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The SCP can do this by relying on several rounds of federal voting. </font><font style="vertical-align: inherit;">Federal voting was made possible thanks to the concept of quorum slices: sets of peers, which each node decided to trust as part of its (subjective) quorum. </font><font style="vertical-align: inherit;">This configuration means that it is possible to come to a consensus even in a network with open membership and Byzantine deceptions.</font></font><br><br><h1>   </h1><br><ul><li>    SCP   <a href="https://www.stellar.org/papers/stellar-consensus-protocol.pdf"></a> ,  <a href="https://datatracker.ietf.org/doc/draft-mazieres-dinrg-scp/"></a>     . <br></li><li>    SCP    (   )   <a href="http://www.scs.stanford.edu/~dm/blog/simplified-scp.html"></a> . <br></li><li> ,   ,       ¬´¬ª  ¬´ ¬ª. SCP    ,      .     <a href="https://hackernoon.com/a-hitchhikers-guide-to-consensus-algorithms-d81aae3eb0e3">  </a> . <br></li><li> <a href=""> </a>  ,        SCP. <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For readers interested in SCP implementations: see the </font></font><a href="https://github.com/stellar/stellar-core/tree/master/src/scp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used by the Stellar payment network, or </font></font><a href="https://github.com/bobg/scp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Go code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which I wrote for a better understanding of SCP.</font></font></li></ul></div><p>Source: <a href="https://habr.com/ru/post/444710/">https://habr.com/ru/post/444710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444694/index.html">As we predicted an outflow, approaching it as a natural disaster.</a></li>
<li><a href="../444696/index.html">Increasing the density of containers on a node using PFCACHE technology</a></li>
<li><a href="../444700/index.html">Random databases. Oracle Enterprise Data Quality Quality - Corporate Vault Shield and Sword</a></li>
<li><a href="../444702/index.html">New vulnerabilities have been discovered in Android and Google Photos, allowing users to steal data</a></li>
<li><a href="../444704/index.html">Opportunities nanoCAD SPDS Construction site in construction and reconstruction projects in cramped conditions</a></li>
<li><a href="../444712/index.html">‚ÄúAtypical attitude to finance‚Äù - that if employees themselves will manage income. Conversation with the flan</a></li>
<li><a href="../444716/index.html">A foldable screen appears on the Samsung $ 2000 foldable screen</a></li>
<li><a href="../444718/index.html">Amateur holography - the beginning of the journey</a></li>
<li><a href="../444724/index.html">RuNet architecture</a></li>
<li><a href="../444726/index.html">OBD2 reader - car diagnostics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>