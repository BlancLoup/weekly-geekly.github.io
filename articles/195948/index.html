<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Basics: Atomicity and atomic primitives</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The construction of a lock-free data structure is based on two pillars ‚Äî atomic operations and ways to streamline memory access. This article focuses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Basics: Atomicity and atomic primitives</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/312/d18/59f/312d1859faa5e26e0d7e08d162a796dc.jpg" align="right"><br>  The construction of a lock-free data structure is based on two pillars ‚Äî atomic operations and ways to streamline memory access.  This article focuses on atomicity and atomic primitives. <br><br>  <b>Announcement</b> .  Thank you for the warm welcome. <a href="http://habrahabr.ru/company/ifree/blog/195770/">Beginning</a> !  I see that the lock-free theme is interesting for the habrasoobschestvu, it makes me happy.  I planned to build a cycle according to the academic principle, smoothly moving from fundamentals to algorithms, simultaneously illustrating the text with the code from libcds.  But some readers require <s>spectacles</s> without delay to show how to use the library, especially not rassusolivaya.  I agree, there is a reason for this.  Ultimately, and I'm not so interested in what's inside the <a href="http://www.boost.org/">boost</a> , - describe how to use it!  Therefore, I will divide my epic cycle into three parts: <i>Basics</i> , <i>Inside</i> and <i>Outside</i> .  Each article of the epic will be related to one of the parts.  The <i>Basics</i> will talk about low-level things, up to the structure of modern processors;  This is the part for how many people like me.  <i>Inside it</i> will highlight interesting algorithms and approaches in the world of lock-free, it‚Äôs rather a theory about how to implement a lock-free data structure, libcds will be an inexhaustible source of C ++ code.  In <i>Outside there</i> will be articles on the practice of using libcds, - software solutions, tips and FAQ.  <i>From the outside</i> will eat your questions / comments / suggestions, dear habrazhiteli. <br><br>  In the meantime, I frantically prepare the beginning of the <i>Outside</i> - the first part of the <i>Basics</i> .  The article is largely not about C ++ (although about it too) and not even about lock-free (although algorithms are not functional without atomic lock-free), but about the implementation of atomic primitives in modern processors and the basic problems encountered when using such primitives. <br>  Atomicity is the first <s>circle of hell, a</s> low level of two. <br><a name="habracut"></a><br>  Atomic operations are divided into simple - read and write - and atomic change operations (read-modify-write, RMW).  An atomic operation can be defined as an indivisible operation: it has either already taken place or not yet;  we can not see any intermediate stages of its implementation, no partial effects.  In this sense, even simple read / write operations, in principle, can be non-atomic;  for example, reading unaligned data is non-atomic: in the x86 architecture, such reading will result in an internal exception that causes the processor to read the data in parts, in other architectures (Sparc, Intel Itanium) - in a fatal error (segmentation fault), which, in principle, can be intercepted and process, but about the atomicity of speech here can not be.  In modern processors, atomicity of reading / writing of only <b>aligned</b> simple (integral) types - integers and pointers is guaranteed.  A modern compiler ensures correct alignment of variables of base types, although it is not difficult to write an example of unaligned conversion, for example, to the whole.  If you want to work atomically with a structure (4-4 byte size), then you should take care of proper alignment using compiler directives (attributes) (each compiler supports its own unique way of specifying data / type alignment).  By the way, the library <a href="http://libcds.sourceforge.net/">libcds</a> contains a set of auxiliary types and macros that hide the compiler-dependent part when declaring aligned data. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Compare-and-swap </h2><br>  It is rather difficult, if at all possible, to invent an algorithm for a lock-free container using only read / write (I don‚Äôt know such data structures for an arbitrary number of threads).  Therefore, the developers of processor architectures have implemented RMW operations that can atomically read a aligned memory cell and write to it: compare-and-swap (CAS), fetch-and-add (FAA), test-and-set (TAS), etc. In the academic environment, the compare-and-swap operation (CAS) is considered as the base operation;  her pseudocode is simple: <br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CAS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * pAddr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nExpected, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNew ) atomically { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *pAddr == nExpected ) { *pAddr = nNew ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> ; }</code> </pre> <br>  In words: if the current value of the variable at the address <code>pAddr</code> is equal to the expected <code>nExpected</code> , then assign the variable the value <code>nNew</code> and return <code>true</code> , otherwise return <code>false</code> , the value of the variable does not change.  All this is done atomically, that is, indivisibly and without visible partial effects.  Through CAS, you can express all other RMW operations, for example, fetch-and-add will look like this: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FAA( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * pAddr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nIncr ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ncur ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ncur = *pAddr ; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !<span class="hljs-built_in"><span class="hljs-built_in">CAS</span></span>( pAddr, ncur, ncur + nIncr ) ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ncur ; }</code> </pre><br><br>  The ‚Äúacademic‚Äù version of the CAS operation is not always convenient in practice, because often when CAS fails, we wonder what the value is in the cell now.  Therefore, such a CAS variant is often considered (the so-called <i>valued CAS</i> , also performed atomically): <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CAS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * pAddr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nExpected, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNew ) atomically { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *pAddr == nExpected ) { *pAddr = nNew ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nExpected ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *pAddr }</code> </pre><br>  In C ++ 11, the <code>compare_exchange</code> function (strictly speaking, in C ++ 11 there is no such function, there are its variants <code>compare_exchange_strong</code> and <code>compare_exchange_weak</code> , but I will tell about them later) covers both of these options: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_exchange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pAddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; nExpected, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNew </span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The <code>nExpected</code> argument <code>nExpected</code> passed by reference, and the input contains the expected value of the variable at <code>pAddr</code> , and the output is the value before the change.  Returns the function success sign: <code>true</code> if the address is <code>nExpected</code> (in this case it changes to <code>nNew</code> ), <code>false</code> if it fails (then <code>nExpected</code> will contain the current value of the variable at <code>pAddr</code> ).  Such a universal construction of the CAS operation covers both variants of the ‚Äúacademic‚Äù definition of CAS, but in practice the application of <code>compare_exchange</code> fraught with errors, since it must be remembered that the <code>nExpected</code> argument <code>nExpected</code> passed by reference and can be changed, which is not always acceptable. <br>  Using <code>compare_exchange</code> fetch-and-add primitive shown above can be written like this: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FAA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pAddr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nIncr </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ncur = *pAddr; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !compare_exchange( pAddr, ncur, ncur + nIncr ) ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ncur ; }</code> </pre><br><br><h2>  ABA problem </h2><br>  Primitive CAS is good for everyone, but its application can <i>cause a</i> serious problem, called the <i>ABA-problem</i> .  To describe it, consider the typical pattern of using the CAS operation: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nCur = *pAddr ; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNew =    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( compare_exchange( pAddr, nCur, nNew )) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  In fact, we are ‚Äúdug‚Äù in the cycle until the CAS works;  the cycle is necessary because between reading the current value of a variable at <code>pAddr</code> and calculating the new value of <code>nNew</code> variable at address <code>pAddr</code> can be changed by another thread. <br><br><img src="https://habrastorage.org/storage3/2f7/80e/462/2f780e462dac593e5d79109139bce2fb.jpeg" align="right"><br>  The ABA problem is described as follows: for example, a stream X reads the value A from some shared cell containing a pointer to some data.  Then another thread, Y, changes the value of this cell to B and again to A, but now the pointer A points to other data.  When flow X using the CAS primitive tries to change the cell value, the pointer is compared with the previous (read) value of A successfully, and the CAS result is successful, but A now points to completely different data!  As a result, the flow can break the internal connections of the object (which, in turn, can lead to a crash). <br><br>  Here is the implementation of a lock-free stack subject to the ABA problem [Mic04]: <br><pre> <code class="hljs pgsql">// Shared variables static NodeType * Top = <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">Initially</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> Push(NodeType * node) { <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*Push1*/</span></span> NodeType * t = Top; <span class="hljs-comment"><span class="hljs-comment">/*Push2*/</span></span> node-&gt;Next = t; <span class="hljs-comment"><span class="hljs-comment">/*Push3*/</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !CAS(&amp;Top,t,node) ); } NodeType * Pop() { Node * next ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*Pop1*/</span></span> NodeType * t = Top; <span class="hljs-comment"><span class="hljs-comment">/*Pop2*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( t == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) <span class="hljs-comment"><span class="hljs-comment">/*Pop3*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*Pop4*/</span></span> next = t-&gt;Next; <span class="hljs-comment"><span class="hljs-comment">/*Pop5*/</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !CAS(&amp;Top,t,next) ); <span class="hljs-comment"><span class="hljs-comment">/*Pop6*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre><br><br>  The following sequence of actions leads to a violation of the stack structure (note that this sequence is not the only one illustrating the ABA problem): <br><table><tbody><tr><td>  <b>Thread x</b> </td><td>  <b>Thread y</b> </td></tr><tr><td>  Causes <code>Pop()</code> . <br>  <code>Pop4</code> string <code>Pop4</code> , <br>  variable values: <code>t == A</code> <br> <code>next == A-&gt;next</code> <br> </td><td></td></tr><tr><td></td><td><br> <code>NodeType * pTop = Pop()</code> <br>  <code>pTop</code> == top of stack, i.e. A <br> <code>Pop()</code> <br> <code>Push( pTop )</code> <br>  Now top of the stack - again a <br>  Note that <code>A-&gt;next</code> has changed. <br></td></tr><tr><td>  The string <code>Pop5</code> is <code>Pop5</code> . <br>  CAS is successful, but the field <code>Top-&gt;next</code> <br>  is assigned a value <br>  nonexistent in the stack <br>  since stream y pushed out <br>  from stack A and <code>A-&gt;next</code> , <br>  and local variable <code>next</code> <br>  stores the <i>old</i> value of <code>A-&gt;next</code> <br></td><td></td></tr></tbody></table><br>  The ABA problem is the scourge of all lock-free containers based on the CAS primitive.  It can occur only in a multi-threaded code due to the removal of element A from the container and replacing it with another (B), and then again with A (hence the name ‚Äú <i>ABA</i> Problem‚Äù), while another thread holds a pointer to the element to be deleted.  Even if the thread physically deletes A ( <code>delete A</code> ) and then calls <code>new</code> to create a new element, there is no guarantee that the allocator will not return Address A (good allocators will do just that).  Often it manifests itself in a more sophisticated way than described above, it affects not two, but more streams (in this sense we can talk about the ABCBA problem, the ABABA problem, etc., how much fantasy is enough), and its identification is always a non-trivial task. .  The ABA problem control tool is deferred <i>physical</i> removal ( <i>deferred deallocation</i> , or <i>safe memory reclamation</i> ) of an element at the moment when there is a complete guarantee that no one (none of the competing streams) has any local or global references to the element to be deleted. <br>  Thus, deleting an element from the lock-free structure is two-phase: <br><ul><li>  The first phase is the exclusion of an element from the lock-free container; </li><li>  The second phase (deferred) - the physical removal of the element when there is no reference to it. </li></ul><br>  I will discuss in detail the various pending removal schemes in one of the following articles. <br><br><h2>  Load-Linked / Store-Conditional </h2><br>  Probably, the presence of an ABA-problem when using CAS prompted the processor designers to search for other RMW-operations that are not subject to the ABA-problem.  And such operations were found - a pair of <i>load-linked / store-conditional</i> (LL / SC).  These operations are very simple - here is their pseudocode: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">word </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> word * pAddr </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *pAddr ; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> word * pAddr, word New </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   pAddr      LL) { *pAddr = New ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> ; }</code> </pre><br>  A pair of LL / SC works as operator brackets.  The <i>load-linked</i> (LL) operation simply returns the current value of the variable to the address <code>pAddr</code> .  The <i>store conditional</i> (SC) operation saves to the address previously read by the LL operation <code>pAddr</code> only if the data in <code>pAddr</code> <i>not changed</i> since it was read.  In this case, a change is <i>any modification of the cache line</i> to which the address <code>pAddr</code> .  To implement the LL / SC pair, the processor developers had to change the cache structure: roughly speaking, each cache line must have an extra status bit.  When reading by the LL operation, this bit is set (link), during any write to the cache line (or it is preempted from the cache), the bit is cleared, and the SC operation checks before storing whether the bit is set to the cache line: if the bit = 1, then there is no one changed the cache line, the value at the address <code>pAddr</code> changes to a new one and the operation SC is successful, otherwise the operation fails, the value at the address <code>pAddr</code> does not change. <br><br>  The CAS primitive can be implemented using the LL / SC pair like this: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CAS</span></span>( word * pAddr, word nExpected, word nNew ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LL( pAddr ) == nExpected ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SC( pAddr, nNew ) ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> ; }</code> </pre><br>  Note that, despite the multistepness of this code, it executes an atomic CAS: the contents of the target memory cell either do not change or change <i>atomically</i> .  The implementation of the LL / SC pair on architectures that support only the CAS primitive is possible, but not so primitive;  I will not consider it here, referring to those interested in the article [Mic04]. <br><br>  Modern processor architectures are divided into two large camps - some support the CAS primitive in their command system, while others support the LL / SC pair.  CAS is implemented in x86, Intel Itanium, Sparc;  the primitive first appeared in the IBM System 370 architecture. The LL / SC pair is PowerPC, MIPS, Alpha, ARM;  first proposed by the DEC.  It is worth noting that the LL / SC primitive is implemented in modern architectures not in the most ideal way: for example, you cannot make nested LL / SC calls with different addresses, false flag resets are possible (so called false sharing, see below), there is no flag validation primitive linked inside a pair of LL / SC. <br><br>  From the point of view of C ++, the C ++ 11 standard does not consider a pair of LL / SC, but describes only the atomic primitive <code>compare_exchange</code> (CAS) and atomic primitives derived from it - <code>fetch_add</code> , <code>fetch_sub</code> , <code>exchange</code> , etc. The standard implies that you implement CAS using LL / SC is quite simple, but the reverse implementation - LL / SC via CAS - is very nontrivial.  Therefore, in order not to complicate the lives of the developers of the standard C ++ library, the standardization committee has introduced only <code>compare_exchange</code> in C ++, which, in principle, is sufficient to implement lock-free algorithms. <br><br><h2>  False sharing </h2><br>  In modern processors, the cache line length L (cache line) is 64 - 128 bytes and tends to increase in new models.  Data is exchanged between the main memory and the cache in L byte blocks (usually L is a power of 2).  When changing at least one byte in the cache line, the entire line is considered invalid and requires synchronization with the main memory.  This is governed by the cache coherence support protocol in the multiprocessor / multi-core architecture. <br><div class="spoiler">  <b class="spoiler_title">MESI cache cache support protocol</b> <div class="spoiler_text">  For example ([Cha05]), the MESI (Modified - Exclusive - Shared - Invalid) protocol for supporting the coherence of Intel processor caches marks the cache line as invalid for <i>each</i> write to a shared line, which results in an intensive exchange with the memory.  When data is first loaded into the cache line, MESI marks this line as E (Exclusive), which allows the processor to produce an unlimited number of reads / writes of data into the cache line.  If another processor requires access to the same data that is located in the cache of that other processor, MESI marks the cache line as S (Shared).  Now, any instruction to write to such a line in any cache leads to marking the line as M (Modified), which, in turn, results in marking this line as I (Invalidate) in the caches of other processors and, as a result, loading data from the main memory .  Now I will not dwell on the MESI protocol, as I plan in one of the following notes to translate a remarkable article on the internal organization of modern processors, where MESI will also be considered. <br></div></div><br><img src="https://habrastorage.org/storage3/a05/952/418/a0595241819d89c1e65cc2497c74bf80.jpeg" align="right"><br>  If different shared data falls into one cache line (that is, located in adjacent addresses), then changing one data leads, from the point of view of the processor, to the invalidation of others that are on the same cache line.  This situation is called <i>false sharing</i> .  For LL / SC primitives, false sharing is destructive, since the implementation of these primitives is performed in terms of cache lines: the Load-Linked operation marks (link) the cache line, and the Store-Conditional operation checks whether the link flag is not reset for this line ;  if the flag is cleared, no entry is performed and the SC returns false.  Since the length of the L line is quite large, the false <b>non-</b> triggering of the SC primitive (that is, the reset of the link flag) happens with any change in the cache line that is not associated with the target data.  As a result, we can get <i>livelock</i> : a situation where the processors / cores are 100% occupied, but there is no progress. <br><br>  The fight against false sharing is fairly simple (but wasteful): each shared variable must occupy the entire cache line;  for this, padding is usually used: <br><pre> <code class="hljs pgsql">struct Foo { <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> nShared1; <span class="hljs-type"><span class="hljs-type">char</span></span> _padding1[<span class="hljs-number"><span class="hljs-number">64</span></span>]; // padding <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> line=<span class="hljs-number"><span class="hljs-number">64</span></span> byte <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> nShared2; <span class="hljs-type"><span class="hljs-type">char</span></span> _padding2[<span class="hljs-number"><span class="hljs-number">64</span></span>]; // padding <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> line=<span class="hljs-number"><span class="hljs-number">64</span></span> byte };</code> </pre><br><br>  It should be noted that the physical structure of the cache affects all operations (including CAS), and not just the LL / SC primitives.  In some papers, data structures that are specially constructed taking into account the cache structure (mainly taking into account the length of the cache line) are investigated;  with proper (‚Äúunder the cache‚Äù) data structure, performance can increase by an order of magnitude. <br><br><h2>  CAS Varieties </h2><br>  I will briefly dwell on two more useful atomic primitives - <i>double-width CAS</i> (double-word CAS, dwCAS) and <i>double CAS</i> (DCAS). <br><br>  <i>Double-width CAS is</i> similar to the usual CAS, but it operates with a double-sized memory cell: 64-bit for 32-bit architectures and 128-bit (more precisely, at least 96-bit) for 64-bit.  For architectures that provide a pair of LL / SC instead of CAS, LL / SC should also operate with words of double length.  Of all the architectures I know, only x86 supports dwCAS.  Why is this primitive so useful?  It allows you to organize one of the first schemes for solving ABA-problems - <i>tagged pointers</i> .  This scheme was proposed by IBM just to solve an ABA-problem and consists in comparing each divided pointer tag - an integer number;  The tagged pointer can be described by the following structure: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tagged_pointer</span></span></span><span class="hljs-class"> {</span></span> T * ptr ; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> tag ; tagged_pointer() : ptr( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T ) , tag( <span class="hljs-number"><span class="hljs-number">1</span></span> ) {} };</code> </pre><br>  To ensure atomicity, this type must be double-aligned: 8 bytes for 32-bit architectures and 16 bytes for 64-bit architectures.  The tag contains the ‚Äúversion number‚Äù of the data pointed to by <code>ptr</code> .  I will talk in detail about tagged pointers in one of the following articles on safe memory management (safe memory reclamation, SMR), but here I‚Äôll just note the fact that tagged pointers implies that the memory once allocated for data of type T (and the corresponding <code>tagged_pointer</code> ) should not be physically deleted ( <code>delete</code> ), but should be placed in the free-list (separate for each type T), from which further data will be re-distributed with the increment of the tag.  This is exactly what the ABA problem gives a solution: in fact, our pointer is composite and contains the version number in the tag (the ordinal number of the distribution);  in this case, dwCAS will not succeed if in its arguments of the <code>tagged_pointer</code> type <code>tagged_pointer</code> pointers are equal and the tag values ‚Äã‚Äãare different. <br><br>  The second atomic primitive - <i>dual CAS</i> (DCAS) - is currently purely hypothetical and is not implemented in any of the modern processor architectures.  The pseudocode of DCAS is: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DCAS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pAddr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nExpected1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNew1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pAddr2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nExpected2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNew2 </span></span></span><span class="hljs-function">) atomically</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *pAddr1 == nExpected1 &amp;&amp; *pAddr2 == nExpected2 ) { *pAddr1 = nNew1 ; *pAddr2 = nNew2 ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  DCAS operates on two arbitrary aligned memory cells and changes the values ‚Äã‚Äãin both if the current values ‚Äã‚Äãcoincide with the expected ones. <br><br>  Why is this primitive so interesting?  The fact is that with its help it is quite easy to build a lock-free doubly linked list (deque, double-linked list), and such a data structure is the basis of many interesting algorithms.  There are a large number of academic papers dedicated to DCAS-based data structures.  Although this primitive is not implemented ‚Äúin hardware‚Äù, there are works (for example, [Fra03] is the most famous of them) describing the DCAS generation algorithm (and multi-CAS in general for any number of addresses <code>pAddr1</code> ... <code>pAddrN</code> ) based on the usual CAS. <br><br><h2>  Performance </h2><br><img src="https://habrastorage.org/storage3/6bb/58d/2b5/6bb58d2b519b6e14bedc48aa6edfff9b.jpeg" align="right"><br>  And what about the performance of atomic primitives? <br>  Modern processors are so complex and unpredictable that manufacturers do not give any unequivocal guarantees of the duration of certain instructions, especially atomic ones, which involve internal synchronization, signaling of processor buses, etc. There are quite a large number of works in which the authors try measure the duration of the processor instructions.  I will give the measurements from [McKen05].  In this paper, the authors, among other things, compare the duration of the atomic increment and the CAS primitive with the duration of the operation <code>nop</code> (no-operation).  So, for Intel Xeon 3.06 GHz (sample of 2005), the atomic increment has a duration of 400 nop, CAS - 850 - 1000 nop.  IBM Power4 1.45 GHz processor: 180 nop for atomic increment and 250 nop for CAS.  The measurements are quite old (2005). Since then, the processor architecture has taken a few more steps forward, but the order of numbers, I think, has remained the same. <br><br>  As you can see, atomic primitives are pretty heavy.  Therefore, it is quite expensive to apply them everywhere: for example, if a binary tree search algorithm uses CAS to read the current tree node, I do not expect anything good from such an algorithm (I have seen such algorithms).  In fairness it should be noted that, according to my feelings, with each new generation of the Intel Core architecture, the CAS primitive is becoming faster, apparently, Intel engineers put a lot of effort into improving the micro-architecture. <br><br><h2>  Volatile and atomicity </h2><br>  C ++ has a mysterious <code>volatile</code> keyword.  Sometimes <code>volatile</code> associated with atomicity and ordering - this is wrong, but has some historical basis. <br>  In fact, <code>volatile</code> guarantees only that the compiler will not cache the value in the register (optimizing compilers love to do this: the more registers - the more caches).  That is, reading a volatile variable <i>always</i> means reading from memory, writing a volatile variable is <i>always</i> writing to memory.  Therefore, if someone simultaneously changes volatile data, we will immediately see it. <br>  In fact, we will not see.  Because of the lack of memory barriers.  In some languages ‚Äã‚Äã(Java, C #), <code>volatile</code> assigned a magic status that provides ordering, but not in C ++ 11.  And no special alignment of <code>volatile</code> does not guarantee, and we now know that a necessary condition for atomicity is just the correct alignment of data. <br>  Thus, for a C ++ 11-compatible compiler, the indication <code>volatile</code> for an atomic variable is redundant.  But for the old compiler it is necessary if you implement <code>atomic</code> yourself.  In this ad: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">atomic_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_nAtomic; <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶. };</span></span></code> </pre><br>  the compiler has the full right to ‚Äúoptimize‚Äù the calls to <code>m_nAtomic</code> (despite the fact that the call goes indirectly through <code>this</code> ).  Therefore, it is <code>int volatile m_nAtomic</code> to specify <code>int volatile m_nAtomic</code> . <br><div class="spoiler">  <b class="spoiler_title">volatile methods in C ++</b> <div class="spoiler_text">  Studying the <code>atomic</code> interface, you will surely notice that many of its methods have the <code>volatile</code> specifier: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  What is it?  Is the <code>this</code> pointer <code>volatile</code> (that is, of type <code>T * volatile</code> )?  In general, this is not possible - <code>this</code> often passed in the register, and it is specified in some ABIs.  In fact, this is type <code>T volatile *</code> . <br>  By analogy with <code>const</code> methods, this specifier says that <code>this</code> points to volatile data, that is, all data members of an object are <code>volatile</code> in such a method.  That, in turn, forbids the compiler to optimize calls to data members.  Basically, the same as if we declared this data as <code>volatile</code> . <br>  Well, let me remind you that the <code>const</code> and <code>volatile</code> specifiers are not opposites, they can exist together.      <code>atomic&lt;T&gt;</code> : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span></span> ;</code> </pre><br>    : <br><ul><li> <code>const</code> ‚Äî     -  </li><li> <code>volatile</code> ‚Äî  -     - ,      </li></ul><br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> libcds </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, what do we have in the </font></font><a href="http://libcds.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libcds</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">And we have </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another bike</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementation of atomic primitives in the spirit of C ++ 11 for x86 / amd64, Intel Itanium and Sparc architectures. </font><font style="vertical-align: inherit;">If the compiler does not support C ++ 11 (and only the newest versions of compilers support it - GCC 4.7+, MS Visual C ++ 2012, Clang 3.0+ available to me), then </font></font><code>libcds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use its implementation of atomic primitives. </font><font style="vertical-align: inherit;">In this case, the main atomic primitive for constructing lock-free data structures, in addition to the usual atomic read / write, is CAS, very rarely where CAS is used over a double word (dwCAS). </font><font style="vertical-align: inherit;">DCAS implementations (and multi-CAS in general) in</font></font><code>libcds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[not yet], but it is quite possible that it will appear in the future - very interesting data structures can be built on it. It stops only that, according to many studies, the implementation of DCAS using the [Fra03] algorithm is rather inefficient. But I already noted that the criterion of efficiency is a purely individual thing in the world of lock-free: what is ineffective now on this gland and for this task can be extremely effective then either on another gland or for another task! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next article on </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basics,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we‚Äôll talk about ordering memory access (memory ordering) - about memory barriers (memory fence, memory barrier).</font></font><br><br>  Links: <br><br> [Cha05] Dean Chandler <a href="http://software.intel.com/sites/default/files/m/3/4/d/7/e/29393-218129_218129.pdf">Reduce False Sharing in .NET</a> , 2005, Intel Corporation <br><br> [Fra03] Keir Fraser <a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Practical Lock Freedom</a> , 2004; technical report is based on a dissertation submitted September 2003 by K.Fraser for the degree of Doctor of Philosophy to the University of Cambridge, King's College <br><br> [McKen05] Paul McKenney, Thomas Hart, Jonathan Walpole <a href="http://web.cecs.pdx.edu/~walpole/class/cs533/papers/sosp2005.pdf">Practical Concerns for Scalable Synchronization</a> <br><br> [Mic04] Maged Michael <a href="http://www.research.ibm.com/people/m/michael/RC23089.pdf">ABA Prevention using single-word instruction</a> , IBM Research Report, 2004 <br><br><div class="spoiler"> <b class="spoiler_title">Lock-free  </b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/195948/">   </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/196548/">    </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/197520/"> </a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/202190/">  </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/216013/"> </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/219201/"> </a> </li><li> <a href="http://habrahabr.ru/post/230349/"> </a> </li><li> <a href="http://habrahabr.ru/post/250383/">Concurrent maps: </a> </li><li> <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li> <a href="https://habrahabr.ru/post/251267/">Concurent maps: </a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li> <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/196834/">  libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/195948/">https://habr.com/ru/post/195948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195932/index.html">How to arrange a festival?</a></li>
<li><a href="../195934/index.html">Migrating to Chef Server 11</a></li>
<li><a href="../195938/index.html">KINS client part leaked</a></li>
<li><a href="../195942/index.html">Impressions of forty days of open source daily work on GitHub.</a></li>
<li><a href="../195944/index.html">We do not need your coffee</a></li>
<li><a href="../195950/index.html">Fast tracks on google maps</a></li>
<li><a href="../195954/index.html">New configuration of dedicated servers</a></li>
<li><a href="../195956/index.html">Old typewriter with Arduino and Raspberry Pi as a printer</a></li>
<li><a href="../195958/index.html">Digest of news of the Windows Azure platform, October 1, 2013</a></li>
<li><a href="../195960/index.html">Another way to record working time in Redmine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>