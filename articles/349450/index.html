<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microsoft Office Security: Document Formats</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 In this article, we open the cycle dedicated to the study of security components of Microsoft Office. This article will focus on data formats...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microsoft Office Security: Document Formats</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  In this article, we open the cycle dedicated to the study of security components of Microsoft Office.  This article will focus on data formats, encryption and receiving characters. <br>  When Microsoft thought and developed a large-scale office suite for Microsoft Office, the creators probably hoped for success.  It is difficult to say whether they could count on his triumphal march around the world afterwards, that the product would become a de facto standard, and its existence would last for decades.  However, one can confidently assert that the massiveness of applications, the number of man-hours spent on creating, developing, supporting the backward compatibility of product components contributed to the emergence of a ‚Äúheavy legacy‚Äù in the form of outdated software code that was a core of applications even in recent versions.  The requirements for the code twenty years ago have changed.  Today, cross-platform, scalability and security are at the forefront.  At the same time, the costs of significant changes in the product are such that Microsoft prefers the ‚Äúnot broken - do not touch‚Äù approach, and diligently ensures backward compatibility with the most ancient document formats.  It does not do without certain pressure from commercial and state structures, which also slowly and reluctantly update their technological parks, preferring usual means to the detriment of development and security. <br><img src="https://habrastorage.org/webt/zy/ar/5t/zyar5tvhczkffkd1ypmayy8y01a.jpeg"><br>  Rummaging through the wilds of the Microsoft Office file handlers, we are ready to present you this little research. <a name="habracut"></a><br><br><h4>  Component Object Model and Data Storage </h4><br>  It is worth starting from afar, namely from the Object Model of Components.  As you must know, Microsoft loves to make its products based on this technology, and Microsoft Office is no exception. <br>  The object model of COM components is a standard that allows software to use services provided by other software, regardless of where the software is located (within the same process, in different processes or on different computers) and what is represented (executable files, managed code, or even scripting languages).  At the same time, the client program, called a container, does not need to go into the details of the implementation of the service (or component), it is enough to know its class identifier, and, if such is registered, an ingenious marshaling system will provide a transparent, seamless and fairly reliable interaction. <br><br><img src="https://habrastorage.org/webt/l6/5v/gy/l65vgylqejqynhgbxtffkatowx0.png"><br>  <i><font color="#999999">This is how a container application can look like heterogeneous components regardless of their location.</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In practice, it usually means not so much the standard itself, as its implementation in the OS of the Windows family.  The first versions of COM were developed for 16-bit Windows as the basis for OLE (it is now ActiveX).  The original purpose of developing these subsystems was the ability to create (!) Composite Word and Excel documents for Windows 3.x, and they were released around 1991 (dates differ on various sources). <br><br>  Imagine a C # application that uses several ActiveX controls (ActiveX controls are COM components designed to interact with the user; the definition is inaccurate, but it seems that there is no exact definition).  The container application loads an in-process component written on flat C to draw an image, a component inside another process on the same computer to load a web page and a form for entering string data that the component running on another computer draws. <br><br><img src="https://habrastorage.org/webt/ir/t0/hz/irt0hzowsf63oft5ljm5b5p8soy.png"><br><br>  Working with the application, the user changes the image, the contents of the browser window and the lines in the input fields.  The application itself interacts with the components, invoking their <i>methods</i> and setting their <i>properties</i> , in other words, changing the internal state of objects whose internal structure has no idea. <br><br>  At one point, the user decides to save the work done and presses the "Save" button.  Our application is faced with a daunting task - to write a dataset to a disk in completely different formats, most of which (both data and formats) are unknown to the application, and they are out of reach for it!  To solve this problem, Microsoft specialists simultaneously developed the file format <b>Compound File Binary Format</b> for COM and the native Component Object Model, and with it a system of interfaces for interacting with this format and their implementations combined under the name <b>Structured Storage</b> . <br><br><h4>  Structured COM Storage </h4><br>  For universal access of applications and components to the complex, besides closed, CFBF format, for transparent for both the container and components for replacing one format with another, library interfaces IStorage and IStream and corresponding APIs were developed.  The virtual data structure accessed by the application through these interfaces is represented by a system of nested directories ‚Äî Storages, each of which may contain a number of sequences of bytes ‚Äî Streams, in which the data is stored. <br><br><img src="https://habrastorage.org/webt/v7/v5/v_/v7v5v_puh2x2sfq0mejbqjhkscu.png"><br>  <i><font color="#999999">CFBF (StructuredStorage) Virtual Representation</font></i> <br><br>  Information in streams can be stored in any convenient form, including text, image in any format, encrypted or compressed data, or even other CFBF files.  It is easy to put in the stream and executable code (including malicious). <br>  Using the appropriate APIs (see the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380365.aspx">Structured Storage Reference in MSDN</a> ), an application can create a file storage and provide each component with a storage of a second (third, etc.) level or stream (several streams) to save state in any format.  The container does not need to know in what form the component will write its data, and the standard library will take care of the placement of information in the file.  When a saved state needs to be loaded, the container opens the vault and provides the loaded components with the ability to read the streams as needed. <br><br>  The creation of Structured Storage technology was pursuing the following tasks: <br><ul><li>  eliminating the need for applications to save numerous separate files for different types of data, including to save disk space </li><li>  creation of a unified interface for working with data, facilitating the creation of applications, and, in particular, COM components working with composite documents </li><li>  the ability to save the current state of the data item at any time </li><li>  data access acceleration </li></ul><br><br>  The last point requires separate consideration.  The development of Structured Storage was carried out at the dawn of COM (early 90s), when existing hardware resources placed high demands on the speed of complex systems, including reading and writing disk files.  Therefore, the storage system should be as optimized as possible for speed.  This precluded the use of, for example, text formats that require significant preprocessing.  In contrast, binary formats that allow data to be copied to memory with minimal modifications took precedence. <br><br>  The result was the disk implementation of Structured Storage - the Microsoft Compound File Binary Format.  For a long time the format remained closed, the specifications were published by the manufacturer in 2006. <br><br>  The CFBF format is a ‚Äúfile system within a file‚Äù and has a file allocation table (FAT), a sector table, directories, and ‚Äústreams‚Äù - an analogue of disk files. <br><br><img src="https://habrastorage.org/webt/ra/0i/bz/ra0ibz1l5qaiaqotolzhi9recd0.png"><br>  <i><font color="#999999">Technical representation of the CFBF format</font></i> <br><br>  There are several versions of the CFBF format, all of which must be supported by the latest versions of the OS as part of backward compatibility.  Despite the fact that Structured Storage is largely ‚Äúinherited‚Äù and obsolete technology, they represent the natural built-in data storage system COM, and COM technology penetrates through the ‚Äúuser-defined‚Äù part of Windows.  A significant amount of application programs, including Microsoft Office and many built-in Windows applications, were developed quite a long time ago and contain a large amount of code that requires backward compatibility, which makes it difficult to switch to modern universal open formats.  As a result, the technology occupies a solid place and is actively used in modern versions of Microsoft products. <br>  Examples include: <br><ul><li>  Shortcuts and shortcuts </li><li>  Image and Result Cache </li><li>  Installation files (msi and msp) </li><li>  Windows Notes </li></ul><br><br><h4>  Compound Binary File format in Microsoft Office applications </h4><br>  The document format used by Microsoft Office was also originally CFBF. <br><br><img src="https://habrastorage.org/webt/oe/hp/qc/oehpqcoaxzgzxi1jyxl6dxcu1t4.png"><br>  <i><font color="#999999">Word document opened by the utility to view Structured Storage</font></i> <br><br>  Modern versions of the package use the open, XML-based OfficeOpen XML format as the main one, but CFBF support is not being discontinued in order to maintain compatibility.  It should be noted that a significant amount of code responsible for working with old document formats was developed a long time ago (about 20 years ago). <br><table border="1"><tbody><tr><td>  Word </td><td>  .doc </td><td>  Legacy Word document; <br>  Microsoft Office refers to Microsoft Word 97 2003 Document </td></tr><tr><td></td><td>  .dot </td><td>  Legacy Word templates; <br>  officially announced "Microsoft Word 97 2003 Template" </td></tr><tr><td></td><td>  .wbk </td><td>  Legacy Word document backup; <br>  referred as "Microsoft Word Backup Document" </td></tr><tr><td>  Excel </td><td>  .xls </td><td>  Legacy Excel worksheets; <br>  officially declared "Microsoft Excel 97-2003 Worksheet" </td></tr><tr><td></td><td>  .xlt </td><td>  Legacy Excel templates; <br>  officially declared "Microsoft Excel 97-2003 Template" </td></tr><tr><td></td><td>  .xlm </td><td>  Legacy excel macro </td></tr><tr><td>  Powerpoint </td><td>  .ppt </td><td>  Legacy PowerPoint presentation </td></tr><tr><td></td><td>  .pot </td><td>  Legacy PowerPoint template </td></tr><tr><td></td><td>  .pps </td><td>  Legacy powerpoint slideshow </td></tr><tr><td>  Publisher </td><td>  .pub </td><td>  Microsoft Publisher publication </td></tr>
</tbody></table><br>  <i><font color="#999999">Examples of obsolete, still supported Office formats</font></i> <br><br>  A simple search on the websites of state structures and enterprises of the Russian Federation (government procurement, websites of administrative units) reveals a discouragingly large amount of official documentation laid out in CFBF, often created in ancient versions of Office, for example, in 2003.  Let the reader carry out this experience on their own. <br><br>  The use of CFBF in Microsoft Office applications is not limited to support for legacy document formats that have modern XML equivalents.  Microsoft Publisher still uses only CFBF documents.  CFBF includes the .msg format of Outlook messages. <br>  If an Office Open XML format document includes OLE elements, their current state can be saved in CFBF files.  In this case, the document will contain inclusions in the form of binary Compound files. <br><br><img src="https://habrastorage.org/webt/fe/b3/7c/feb37c9rddrto1wvmhmfhrmfe_e.png"><br>  <i><font color="#999999">binary CFBF file inside an OfficeOpenXML document</font></i> <br><br>  Although documents from various Office applications are based on CFBF, each state storage of OLE / ActiveX elements will have its own additional format.  It must be borne in mind that they are largely formed historically and have been optimized for maximum performance on weak computers. <br><br><table border="1"><tbody><tr><td>  [MS-DOC] </td><td>  Word (.doc) Binary File Format </td><td>  <a href="https://msdn.microsoft.com/en-us/library/office/cc313153.aspx">https://msdn.microsoft.com/en-us/library/office/cc313153.aspx</a> </td></tr><tr><td>  [MS-XLS] </td><td>  Excel Binary File Format (.xls) </td><td>  <a href="https://msdn.microsoft.com/en-us/library/office/cc313154.aspx">https://msdn.microsoft.com/en-us/library/office/cc313154.aspx</a> </td></tr><tr><td>  [MS-OXMSG] </td><td>  Outlook Item (.msg) File Format </td><td>  <a href="https://msdn.microsoft.com/en-us/library/cc463912(v%3Dexchg.80).aspx">https://msdn.microsoft.com/en-us/library/cc463912(v=exchg.80 ).aspx</a> </td></tr><tr><td>  [MS-OFORMS] </td><td>  Office Forms (ActiveX) Binary File Formats </td><td>  <a href="https://msdn.microsoft.com/en-us/library/cc313125.aspx">https://msdn.microsoft.com/en-us/library/cc313125.aspx</a> </td></tr></tbody></table><br>  <i><font color="#999999">Some published specifications of Office formats based on Structured Storage</font></i> <br><br><h4>  OLE RTF Storage Support </h4><br>  Rich Text Format is generally considered a fairly safe XML-like format.  However, Microsoft experts could not fail to include support for OLE / ActiveX in their implementation.  RTF documents in Microsoft applications can contain and display embedded OLE elements and should be able to save their current state.  To do this, such control words as '\ obj', '\ objclass', '\ objdata' were added to the format.  This allows you to supplement RTF documents with ActiveX controls registered in the system.  The format for the component is provided by the OLE subsystem, the ActiveX executable code transparently uses standard IStorage and IStream interfaces.  Ensuring document security rests on a container application that can use legacy legacy code and fail to take into account all the modern nuances of working with ActiveX. <br><br><h4>  Microsoft EQUATION formula display OLE component </h4><br>  An example of a COM Structured Storage vulnerability is CVE-2017-11882. <br><br><img src="https://habrastorage.org/webt/xz/9z/cm/xz9zcmentukhgauj-ibcyfucg2m.png"><br><br>  The vulnerability was discovered in the Microsoft Office component so ancient that the source codes of the component were lost by the manufacturer. <br>  To save the state, the elements of the Formula Editor (Microsoft Equation Editor) used structured storage streams.  Violation of data integrity in streams resulted in numerous vulnerabilities, the first of which was detected by CVE-2017-11882, found by Embedi. <br><br><img src="https://habrastorage.org/webt/yh/sr/aq/yhsraqr_cxpoj_p7kcgeckmocxe.png"><br>  <i><font color="#999999">EquationEditor structured storage stream</font></i> <br><br>  Despite the fact that by default the component is denied to download for .doc and .docx documents, the element was loaded successfully from the .rtf, allowing the attacker to execute the malicious code. <br>  After unsuccessful attempts to manually fix vulnerabilities in executable code in the absence of source code, Microsoft was forced to remove the Formula Editor component from the Office suite. <br><br><h3>  Some other legacy binary formats used in Microsoft Office </h3><br><br><h4>  EPS graphic filter </h4><br>  The EPS graphic filter is an Office component that is responsible for editing EPS images.  They are vector-based and are constructed using the interpretation of the internal language Encapsulated PostScript (a version of regular PostScript with some restrictions). <br><br>  By virtue of its features, this language supports a wide variety of constructions and possibilities.  Due to this, the memory damage vulnerabilities in the EPS graphic filter are exploited fairly easily.  The richness of the language makes it possible to use the techniques of HeapSpray (for example, the possibility of using cycles) and HeapFengShui (predictability of memory allocation by the interpreter).  Even despite the fact that the image is rendered on a virtual printer, and the execution of the EPS program takes place within an isolated interpreter, the presence of favorable exploitation opportunities for vulnerabilities and the old code base made EPS the most common attack vector of office applications. <br><br>  Due to the fact that the module was originally developed by Access Softek, and then transferred to Microsoft, a significant number of ‚Äúunknown‚Äù vulnerabilities were found and successfully exploited in this component.  For example, in April 2017 by FireEye Inc.  vulnerabilities CVE-2017-0261 and CVE-2017-0262 were found.  These two memory corruption vulnerabilities allowed attackers to build READ / WRITE primitives, with which they achieved the execution of their code outside of the isolated process (sandbox) of the PostScript interpreter.  Attackers can read and write arbitrary chunks of memory in the address space of the vulnerable process, and can also perform, for example, search for the necessary ROP gadgets to build a ROP chain that makes the rest of the shell code executable. <br><br>  In both cases, the attackers achieved the execution of arbitrary code in a similar way: they created an object in memory with controlled content (it was possible to do this using R / W primitives) and called one of its methods using the PostScript function. <br><br>  These vulnerabilities in the EPS graphic filter have become a popular attack vector.  And so much so that Microsoft in April 2017 developed an update that completely disables the graphics filter.  However, the patch is applicable only for the version of MsOffice 2010 SP2 and higher. <br><br><h4>  Access databases </h4><br>  The Microsoft Access database management system is a powerful tool for managing a relatively small amount of data, for example, the inventory of an organization.  Access allows you to easily create reports based on information in the database.  The application can also be used as a front-end for managing other DBMS, including Microsoft SQL Server (using ODBC drivers). <br>  The application and database format was developed a long time ago and have a number of architectural flaws: <br><ul><li>  using VBA macros as some triggers and stored procedures; </li><li>  the ability to use links to other databases; </li><li>  closeness of the database format prevents the use of existing databases in other environments. </li></ul><br><br>  The first drawback is very serious, since VBA-macros are equivalent in their capabilities to ordinary executable files.  For this reason, using Access can be a security issue. <br>  The user must trust the database with which he works, and be sure that it does not contain malicious code contributed by the attacker.  Otherwise, the ban on the execution of macros significantly reduces the functionality of the application for working with data in tables and views. <br><br><h4>  Outlook Personal Folder Files </h4><br>  The Microsoft Office mail client uses its own storage file format for messages, a custom folder structure, attachments, address book, and so on.  This is a multi-level format, closely related to the MAPI subsystem, which provides access to personal folder files through its own interfaces. <br><br>  The Outlook Personal Folders (.pst) specification was published by the manufacturer: <a href="https://msdn.microsoft.com/en-us/library/ff385210.aspx">https://msdn.microsoft.com/en-us/library/ff385210.aspx</a> . <br><br>  The .ost specification has not been published, and formally accessing the Offline Storage Table file can only be done through MAPI.  In fact, these formats are very similar and editing .ost is also possible.  It must be borne in mind that synchronization of the edited content of the Offline Storage Table file with the data on the Exchange server may lead to irreversible data corruption and loss of significant information. <br><br><h4>  OwnerFile File </h4><br>  The problem of collaborating on Office documents located in network storages was once solved with the help of temporary files of a simple format, the so-called OwnerFile.  If the file is currently locked for editing, the application searches the same directory for a file with a short format name ‚Äú~ $ name.doc‚Äù.  The file contains the name of the user who opened the document in ASCII and Unicode formats, in both cases the fixed size of the array is reserved for the name.  When creating a file, unused bytes of the array are filled with garbage values ‚Äã‚Äãfrom the application's memory, which can potentially lead to the disclosure of sensitive information (in general, due to the file size, the likelihood of this is small).  The username in the owner file is also easily forged. <br><br><img src="https://habrastorage.org/webt/4s/yp/kh/4sypkhpcuhu6xqx1dgaln-a9f-o.png"><br>  <i><font color="#999999">MicrosoftWord message when trying to open a locked document</font></i> <br><br><h4>  Office document encryption mechanism </h4><br>  The mechanism of password protection of documents first appeared in Office 95. At that time, little attention was paid to the strength of the encryption algorithms used, as a result, algorithms were applied to which practically applicable attacks existed.  This fact was the impetus for changing the mechanism in future versions of office suites. <br>  The table shows in chronological order the most common office packages currently available and the default encryption algorithms used in them. <br><br><table border="1"><tbody><tr><td>  Version </td><td>  Hashing </td><td>  Encryption </td></tr><tr><td>  Office 2003 </td><td>  None </td><td>  RC4 </td></tr><tr><td>  Office 2007 </td><td>  SHA-1 x 50.000 </td><td>  AES-128 </td></tr><tr><td>  Office 2010 </td><td>  SHA-1 x 100,000 </td><td>  AES-128 </td></tr><tr><td>  Office 2013 </td><td>  SHA-512 x 100.000 </td><td>  AES-128 </td></tr><tr><td>  Office 2016 </td><td>  SHA-512 x 100.000 </td><td>  AES-128 </td></tr></tbody></table><br>  Despite the use of strong encryption algorithms, the document itself is not encrypted immediately after setting the password on the document, but only after the next document is saved.  Given the number of attacks based on the negligence of users of the office suite, this is quite an important nuance. <br>  Also, we must not forget that the implementation of cryptographic algorithms is a laborious task, even for highly skilled developers, so the presence of errors in them cannot be ruled out.  A striking example of such an error affecting the protection of Excel documents is a key generation vulnerability fixed by patch MS15-110. <br><br><h4>  A few words about the sources of information for the researcher </h4><br>  If you decide to seriously look under the hood of Office, any additional information that helps you understand the purpose of data structures will be useful. <br><ol><li>  The already mentioned <b>format specifications</b> are very useful in this regard, courtesy (albeit under some pressure) laid out by Microsoft.  They can be found on the MSDN website: <br>  <a href="https://msdn.microsoft.com/en-us/library/cc313105.aspx">https://msdn.microsoft.com/en-us/library/cc313105.aspx</a> <br>  It should be noted that this documentation contains gaps and inaccuracies, so that focusing solely on it to write a parser of documents is quite difficult.  But from it you can gather information about many mysterious structures and identifiers, find out their name. </li><li>  <b>VisualStudio 2010 SDK</b> <br>  Among the set of header files there is a kit for Microsoft Office, containing information about the interfaces, types, enumerations and formats of the procedure call: <a href="https://www.microsoft.com/en-us/download/details.aspx%3Fid%3D2680">https://www.microsoft.com/en-us/download/details.aspx?id=2680</a> (the installed VS2010 is required ). <br>  You can see (for example) <a href="https://github.com/mulesoft-labs/raml-dotnet-tools/tree/master/vssdk_tools/Inc/office10">here.</a> </li><li>  <b>Office 97</b> <br>  In executable files of modern versions of the package, shared library procedures are imported by ordinals.  In earlier versions of Office, they have distinct names by which you can get an idea of ‚Äã‚Äãtheir purpose.  The numbers of ordinals mostly correspond to modern ones (there are differences!). </li><li>  <b>Office 2010</b> <br>  Office 2010 executables contain Dynamic Class Identification (RTTI) information that allows you to set class names and virtual interface tables.  To do this, you can use tools like Class Informer.  Beginning with Office 2013, this information is encrypted. </li><li>  <b>offparser.dll</b> <br>  A 64-bit Server 2003 component that contains simplified implementations of classes and interfaces.  Unlike Office, symbolic information (.pdb) for this module is available for download from the Microsoft server.  Allows you to get the names of the methods, the internal structure of instances of classes and the names CLSID and GUID </li><li>  <b>OutlookExpress / Microsoft Mail</b> <br>  The mail client and the mail subsystem included in the operating system.  They contain a simplified version of MAPI (Outlook mail subsystem).  As with other Windows components, symbolic information is available for download.  Some of the code for these components is contained in the published Windows source codes. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/349450/">https://habr.com/ru/post/349450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349440/index.html">Creating a game on Lua and L√ñVE - 2</a></li>
<li><a href="../349442/index.html">JBreak 2018 Java Conference Program Overview: Absolute Balance</a></li>
<li><a href="../349444/index.html">"Do not fit, kill!" Or the whole truth about the security of automated process control systems</a></li>
<li><a href="../349446/index.html">DevDay about .NET: lazy authorization & DSL and C # union</a></li>
<li><a href="../349448/index.html">Key transparency & Coniks to protect data structures</a></li>
<li><a href="../349452/index.html">[bookmark] Tools for testing javascript projects</a></li>
<li><a href="../349454/index.html">Ring bar graphs in stock</a></li>
<li><a href="../349456/index.html">Digital events in Moscow from February 19 to 25</a></li>
<li><a href="../349458/index.html">Interesting facts about Python or "Happy Birthday, Python!"</a></li>
<li><a href="../349462/index.html">Html page through the eyes of an application developer. Part 1: "Preparation"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>