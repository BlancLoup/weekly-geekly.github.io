<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about the architecture of network demons</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many articles, including those in Habr√©, mention and even describe various ways of building the architecture of network services (daemons). Moreover, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about the architecture of network demons</h1><div class="post__text post__text-html js-mediator-article">  Many articles, including those in Habr√©, mention and even describe various ways of building the architecture of network services (daemons).  Moreover, few of the authors have real experience in creating and optimizing demons working with tens of thousands of simultaneous connections and / or gigabit traffic. <br><br>  Since most authors do not bother to even get into the documentation, usually in such articles all information is based on certain rumors and retellings of rumors.  These rumors roam the network and hit Wikipedia, habrahabr and other respected resources.  The result is an opus like " <a href="http://habrahabr.ru/blogs/webdev/108241/">You must be joking, Mr. Dahl, or why Node.js</a> " (author's punctuation is preserved): it is basically correct in essence, but it is replete with inaccuracies, contains a number of factual errors, and depicts an object from some incomprehensible view angle. <br><br>  It was difficult for me to pass by an article replete with phrases like "effective polling implementations for today exist only in * nix-systems" (as if poll () is somewhere other than some * nix).  This post began as a comment explaining the esteemed <a href="http://inikulin.habrahabr.ru/">inikulin</a> errors in his article.  In the process of writing it turned out that it is easier to state the subject from the very beginning, which I actually do as a separate post. <br>  In my essay there is no disruption of covers or any unknown tricks, here the advantages and disadvantages of different approaches are simply described by the person who tested how it all works in practice in different operating systems. <br>  For those who want to clarify - welcome under cat. <br><a name="habracut"></a><br><h3>  TK for network daemon </h3><br>  First you need to understand exactly what network services should do and what, in general, is the problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Any daemon must accept and process network connections.  Since the TCP / IP protocol stack grew from UNIX, and this OS confesses the dogma ‚Äúeverything is a file‚Äù, network connections are special type of files that can be opened, closed, read and written with standard OS functions for working with files.  Pay attention to the modal verb "can", in conjunction with the word "theoretically", he very accurately describes reality. <br><br>  So, first of all, any daemon calls the system functions socket (), then bind (), then listen (), and eventually it gets a file of a special type ‚Äúlistening socket‚Äù.  The parameters of these functions and further actions of the daemon are very dependent on the transport protocol used (TCP, UDP, ICMP, RPD ...), however, in most OSs you can only bind the first two.  In this article, as an example, we consider the most popular TCP protocol. <br><br>  Although a listening socket is a file, all that can happen to it is periodically occurring events like "incoming connection request".  The daemon can accept such a connection with the accept () function, which will create a new file, this time already of the ‚Äúopen TCP / IP network socket‚Äù type.  Supposedly, the daemon should read the request from this connection, process it and send the result back. <br><br>  At the same time, a network socket is already a more or less normal file: although it was not created in a very standard way, at least you can try to read and write data from it.  But there are significant differences from the usual files located on the file system: <br>  * All events happen really asynchronously and with an unknown duration in time.  Any operation at worst can take tens of minutes.  Generally any. <br>  * Connections, unlike files, can be closed "by themselves" at any, most unexpected moment. <br>  * The OS does not always report a closed connection, "dead" sockets can hang for half an hour. <br>  * Connections on the client and on the server are closed at different times.  If a client tries to create a new connection and ‚Äúsend back‚Äù data, duplication of data is possible, and if the client is incorrectly written, they can be lost.  It is also possible for the server to have several open connections from one client. <br>  * Data is regarded as a stream of bytes and can literally come in portions of 1 byte.  Therefore, it is impossible to count them, for example, as UTF-8 strings. <br>  * There are no buffers other than those provided by the daemon itself on the network.  Therefore, writing to the socket even 1 byte can block the daemon for tens of minutes (see above).  In addition, the memory on the non-rubber server, the daemon should be able to limit the speed with which the results are generated. <br>  * Any errors can happen anywhere; the daemon must correctly handle them all. <br><br>  If you write a cycle for all open connections "in the forehead", then the very same "suspended" connection will block all the others.  Yes, for tens of minutes.  And here there are various options for organizing the interaction of various modules of the demon.  See the picture: <br><img src="https://habrastorage.org/storage/habraeffect/f1/ef/f1ef8d2164dbde9801bb81915e3111ed.gif"><br>  <i>Disclaimer</i> : The figure shows a pseudo-language code that does not correspond to reality.  Many important system calls and all error handling code are omitted for clarity. <br><br><h3>  2. Multi-process architecture </h3><br>  The simplest way to prevent connections from affecting each other is to run a separate process for each of them (that is, a separate copy of your program).  The disadvantages of this method are obvious - the launch of a separate process is a very resource-intensive operation.  But most articles do not explain why exactly this method is used in the same Apache. <br><br>  And the thing is that the process in all operating systems is a unit of accounting for system resources - memory, open files, access rights, quotas, and so on.  If you create a remote access daemon to an operating system like Shell or FTP, you simply have to start a separate process on behalf of each logged in user in order to properly consider file permissions.  Similarly, on the shared-hosting server at the same time, hundreds of different user sites are spinning on the same ‚Äúphysical‚Äù port - and apache is needed for processes so that the websites of some hosting users cannot get into the data of other users.  The use of processes does not really affect the performance of Apache: <br><img src="https://habrastorage.org/getpro/habr/post_images/e68/813/1f2/e688131f287c4937bba93a22a207e8f6.png" alt="image"><br>  On the chart - the number of requests processed to a static file per second, depending on the version of the Linux kernel.  More is better. <br>  Testbed: Core i7 970, 3Gb DDR3, Nvidia GTX 460, 64GB OCZ Vertex SSD. <br>  <a href="http://www.phoronix.com/scan.php%3Fpage%3Darticle%26item%3Dlinux_2612_2637%26num%3D1">Source: Phoronix.</a> <br>  I wish your demons to give 17k files per second. <br><br>  Even if the users of your daemon are not registered in the operating system, but your service is subject to increased security requirements, there is a very reasonable architectural solution to allocate a separate process for each user.  This will not allow bad users to get or block access to other users' data, even if they find a bug in your daemon that allows you to read other people's data or simply destroying the daemon process. <br><br>  Finally, each process has its own address space, and different processes do not interfere with each other's use of memory.  Why this advantage is explained in part <br><br><h3>  3. Multi-threaded architecture </h3><br>  Threads are the easiest ‚Äúprocesses‚Äù with shared memory, system resources and access rights, but different stacks.  This means that the threads have common dynamic, global and static variables, but different local ones.  In multiprocessor and / or multi-core systems, different threads of the same process can run physically at the same time. <br><br>  A multi-threaded architecture is similar to a multi-process, in which security and stability are sacrificed for performance and reduced memory consumption. <br><br>  The main advantage of a multi-threaded architecture after performance is the consistency and synchronicity of the open connection processing algorithm.  This means that the algorithm looks and executes exactly as shown in the illustration in the first part.  First, data is read from the socket, as much time as is needed for this, then they are processed - again, as much time as this processing will require, then the results are sent to the client.  At the same time, if you start sending results too quickly, the stream will automatically be blocked on the write () function.  The processing algorithm is simple and clear at least at the topmost level.  This is a very, very big plus. <br><br>  For a relatively small number of simultaneous connections, a multi-threaded architecture is an excellent choice.  But if there are really many connections, say ten thousand, switching between threads starts to take too much time.  But even this is not the main drawback of a multi-threaded architecture. <br><br>  And the main thing is that the threads are not independent and can (and will) block each other.  To understand how this happens, consider an example. <br><br>  Suppose we need to calculate the value of an expression <br> <code>a = b + c;</code> <br>  where a, b and c are global variables. <br><br>  In a normal, single-threaded situation, the compiler will generate something like this machine code: <br> <code>a = b; // MOV A, B <br> a += c; // ADD A, C <br></code> <br><br>  In the multi-threaded version, you cannot use this code.  Another thread can change the value of b between the first and second instructions, with the result that we get the wrong value of a.  If somewhere else it is considered that a is always equal to b + c, a very difficult to reproduce floating error will arise. <br><br>  Therefore, in a multithreaded version, a code like this is used: <br> <code>lock a; <br> lock b; <br> lock c; <br> a = b; <br> a += c; <br> unlock c; <br> unlock b; <br> unlock a; <br></code> <br>  where lock and unlock are <i>atomic</i> blocking and unlocking operations for a variable.  They are arranged in such a way that if a variable is already blocked by another thread, the lock () operation will wait for it to be released. <br><br>  Thus, if two threads start simultaneously performing operations a = b + c and b = c + a, they will block each other forever.  Such a situation is called a clinch; the search and resolution of clinches is a separate ‚Äúsore subject‚Äù of parallel programming.  But even without clinches, the flows, if they do not relieve blocking quickly, can stop each other for quite long periods of time. <br><br>  In addition, atomic operations are physically implemented with the help of exclusive trapping of the RAM bus and the RAM itself.  Working directly with the memory, and not with the cache, is very slow by itself, and in this case also causes the invalidation (reset) of the corresponding cache lines of all the cores of all the other server processors.  That is, even in the best case, in the absence of locks, each atomic operation takes quite a long time and degrades the performance of the other threads. <br><br>  But it would seem, since the connections in the demons are almost independent, where can they get common variables from? <br>  But from where: <br>  * Common queue of new connections; <br>  * Shared queue access to a database or similar resources; <br>  * Common queue of requests for memory allocation (yes, malloc () and new () can cause blocking); <br>  * General log (log file) and general statistics calculation objects. <br>  These are only the most obvious. <br><br>  In some cases, there are ways to do without common variables.  For example, locks on the queue of new connections can be abandoned if one is to be given a function of a ‚Äúdispatcher‚Äù, which will distribute tasks in some clever way in advance.  Sometimes it is possible to apply special "non-blocking" data structures.  But in general, the problem of deadlocks in a multi-threaded architecture has not been solved. <br><br><h3>  4. Non-blocking architecture </h3><br>  Ideally, the number of threads in an application should be approximately equal to the number of processor cores in order of magnitude.  One of the mechanisms to achieve this is non-blocking I / O. <br><br>  Non-blocking I / O is simply a file access mode that can be installed on most modern operating systems.  If in the normal, ‚Äúblocking‚Äù mode, the read function reads from the file as many bytes as the programmer ordered, and while this reading takes place ‚Äî ‚Äúputs to sleep‚Äù the stream that caused it, then in the nonblocking mode, the same read function reads not from the file, but from its cache, as many bytes as there are in this cache, and after that it returns immediately, no threads are lulling or blocking.  If the cache was empty, non-blocking read () reads 0 bytes, sets the system error code to EWOULDBLOCK, and returns immediately.  But still it is a normal synchronous call to a normal synchronous function. <br><br><blockquote>  Some confusion, in particular, in the English-language Wikipedia, in which non-blocking synchronous I / O is called "asynchronous", caused, apparently, not very curious apologists of Linux.  In this operating system, for quite a long time, right up to kernels 2.6.22-2.6.29, there simply were no asynchronous I / O functions at all (and even now there is not the entire required set, in particular, there is no asynchronous fnctl), and some programmers who wrote only under this OS, non-blocking synchronous functions were mistakenly called ‚Äúasynchronous‚Äù, which can be traced in a number of old Linux manuals. </blockquote><br>  Asynchronous I / O is discussed in detail in the next section, and here we focus on the use of non-blocking read and write functions. <br><br>  In real conditions, 95% of non-blocking read () calls will read 0 bytes each.  To avoid these ‚Äúidle‚Äù calls to the OS kernel, there is a select () function that allows you to ask the operating system to select from your list of connections those from which you can already read and / or write.  Some * nix OSs have a variant of this function called poll (). <br><blockquote>  More on poll (): this feature appeared as a requirement for the next version of the POSIX standard.  In the case of Linux, poll () was first implemented as a function of the C standard library (libc&gt; = 5.4.28) in the form of a wrapper over the usual select (), and only after some time ‚Äúmoved‚Äù to the kernel.  In Windows, for example, there is still no normal poll () function, but since Vista there is some kind of <a href="http://blogs.msdn.com/b/wndp/archive/2006/10/26/wsapoll.aspx">palliative to simplify the migration of applications</a> , also implemented as a wrapper around select () in C. <br>  I can not share the schedule, showing what all these innovations lead to.  On the graph - the time of pumping 10 GB of data through the interface loop, depending on the version of the kernel.  Less is better.  The source is the same, the test bench is the same. <br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/eab/3f6/d2ceab3f635a102bb90b0ac748e907ca.png" alt="image"><br><br></blockquote><br><br>  In any case, although select () has certain limitations (in particular, on the number of files in one request), using this function and non-blocking I / O mode is a way to transfer all the work to the operating system and simply process your data.  In most cases, the non-blocking I / O thread will consume only a couple of percent of the computational power of a single core.  Performing all the calculations, the internal threads of the operating system kernel will be ‚Äúeaten‚Äù ten times more. <br><br>  Let's go back to reducing the number of threads. <br>  So, in the daemon there are a large number of objects of the "connection" class, and there is a set of operations that need to be applied to each connection object, and in the necessary order. <br><br>  In a multi-threaded architecture, a separate thread is created for each connection object, and operations are naturally performed in blocking mode in the correct sequence. <br><br>  In a non-blocking I / O architecture, a stream is created for each operation, which is sequentially applied to different objects.  It is a bit like SIMD instructions like MMX and SSE: one instruction applies to several objects at once.  To withstand the necessary sequence of operations (that is, first calculate the result, and then send it), job queues are created between threads in the shared memory of the process.  Queues are usually created on the basis of ring buffers, which in this case can be implemented in a ‚Äúnon-blocking‚Äù manner. <br><br>  In a real network service, between reading a request and sending a result, there will be a rather complex branched processing algorithm, possibly involving a call to an application server, a DBMS or other ‚Äúheavy‚Äù operations, as well as a full set of branching, loops, error handling at each step, etc.  To break it all down into an unknown number of threads running at the same time, and even so that the load on the processor cores is about the same - this is the highest level of developer skills that requires virtuosity in all aspects of system programming.  In most cases, they make it much simpler: they enclose everything between read () and write () in a separate thread, and run N = the number of kernels of copies of this thread.  And then they invent crutches for the clinch, competing for resources, ‚Äúkilling‚Äù the DBMS, etc.  parallel threads. <br><br><h3>  5. Asynchronous I / O </h3><br>  If you do not understand the difference between asynchronous functions and synchronous functions, then for simplicity you can assume that the asynchronous function runs in parallel and simultaneously with the program that called it, for example, on the neighboring core.  On the one hand, the calling program does not need to wait for the completion of the calculations and it can do something useful.  On the other hand, when the results of the asynchronous function are ready, you need to somehow inform the customer program.  The way this message happens is implemented in different operating systems in very different ways. <br><br>  Historically, Windows 2000 was one of the first OSs that support asynchronous I / O. <br>  A typical use case was this: a single-threaded application (there were no multicore processors at that time) loads, for example, a large file for tens of seconds.  Instead of freezing the interface and the ‚Äúwatch‚Äù that would be observed when synchronously calling read (), in the asynchronous version, the main program thread does not ‚Äúhang‚Äù, you can make a beautiful progress bar displaying the boot process and the ‚Äúcancel‚Äù button. <br>  To implement the progress bar, a special OVERLAPPED structure is passed to the asynchronous I / O functions of Windows, in which the OS marks the current number of bytes transferred.  The programmer can read the contents of this structure at any convenient time - in the main message processing loop, by timer, etc.  In the same structure, at the end of the operation, its final result will be recorded (total number of bytes transferred, error code if it is, etc.). <br><br>  In addition to this structure, you can pass your own callback functions to the asynchronous I / O functions that take a pointer to OVERLAPPED, which will be called by the operating system at the end of the operation. <br>  A real, honest asynchronous start of a callback function, through program interruption in any place wherever it is, is not distinguishable from the launch of the second program execution thread on the same core.  Accordingly, it is necessary either to write callback functions very carefully, or to apply all ‚Äúmulti-threaded‚Äù rules regarding access locks to shared data, which, you see, is very strange in a single-threaded application.  To avoid potential errors in single-threaded applications, Windows puts unprocessed callbacks in the queue, and the programmer must explicitly indicate the places in his program where it can be interrupted to execute these callbacks (the WaitFor * Object family of functions). <br><br>  The asynchronous I / O scheme described above is native for the WindowsNT kernel, that is, all other operations are implemented through it one way or another.  Full name - IOCP (Input / Output Completion Port).  It is believed that this scheme allows to theoretically achieve maximum performance from iron.  Any daemons designed for serious work under Windows should be developed on the basis of IOCP.  For details, see the <a href="http://support.microsoft.com/kb/181611/en-us/">introduction to IOCP in MSDN</a> . <br><br>  In Linux, instead of the normal OVERLAPPED structure, there is some weak similarity to aiocb, which allows to determine only the fact of completion of the operation, but not its current progress.  Instead of user-defined callbacks, the kernel uses UNIX signals (yes, those that are kill).  Signals come completely asynchronously, with all the consequences, but if you don‚Äôt feel like a guru in writing reentrant functions, you can create a special type of file (signalfd) and read information about incoming signals from it using regular synchronous I / O functions, including non-blocking .  For details, see <a href="">man aio.h.</a> <br><br>  The use of asynchronous I / O does not impose any restrictions on the architecture of the daemon, in theory it can be any.  But, as a rule, several workflows are used (according to the number of processor cores), between which the serviced connections are evenly distributed.  For each connection, a finite state machine is built and programmed (Finite State Machine, FSM), the occurrence of events (calls to callback functions and / or errors) transfers this automaton from one state to another. <br><br><h3>  Summary </h3><br>  As we see, each method has its advantages, disadvantages and areas of application.  If you need security, use processes, if speed is important for high loads ‚Äî non-blocking I / O, and if development speed and code is important, then a multi-threaded architecture will do.  Asynchronous I / O is the primary method in Windows.  In any case, do not try to write the code for working with input-output independently.  The network has free ready-made libraries for all architectures and operating systems, licked for decades almost to shine.  Almost - because in your case, you still have to twist something, file and adjust to your conditions.  The Internet is a complicated thing, there are no universal solutions for all occasions. <br><br>  Be that as it may, the demons do not get by with just I / O, and much more complicated ‚Äúgags‚Äù occur during the processing of requests.  But this is a topic for another article, if it is interesting to anyone. <br><br><h3>  Links </h3><br>  1. The <a href="http://www.kegel.com/c10k.html">C10K problem</a> (English), thanks for the tip <a href="https://habrahabr.ru/users/o_o_tync/" class="user_link">o_O_Tync</a> <br>  2. <a href="http://pod.tst.eu/">Help to the library libev</a> , the tasty part with a description of the various mechanisms of mass input-output (eng), thanks for the tip <a href="https://habrahabr.ru/users/saterenko/" class="user_link">saterenko</a> <br>  3. <a href="https://groups.google.com/group/fido7.ru.unix.prog/browse_thread/thread/e8f8edf4f2f2447b/%3Fhl%3Dru">FAQ ehi ru.unix.prog</a> <br>  4. Introduction to the unix library <a href="http://www.morphisms.net/~wkj/software/libaio/intro.html">libaio</a> (eng.) <br>  5. <a href="http://www.phoronix.com/scan.php%3Fpage%3Darticle%26item%3Dlinux_2612_2637%26num%3D1">Testing the performance of kernels from 2.6.12 to 2.6.37</a> (eng). </div><p>Source: <a href="https://habr.com/ru/post/108294/">https://habr.com/ru/post/108294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108284/index.html">Collective lawsuits against Google and AT & T</a></li>
<li><a href="../108288/index.html">Google Voice is now for iPhone</a></li>
<li><a href="../108289/index.html">Quick search for terminal errors in Google</a></li>
<li><a href="../108290/index.html">Case "Designing a web service for booking tickets." Business analysis. Domain Description</a></li>
<li><a href="../108293/index.html">Is Google Chrome the most leaky program?</a></li>
<li><a href="../108295/index.html">Getters and Setters in Javascript</a></li>
<li><a href="../108297/index.html">MeeGo 2010: Free Transformers, Upstream 1st, the upcoming MeeGo-smartphones and the inevitable competition</a></li>
<li><a href="../108298/index.html">After all asynchronous calls</a></li>
<li><a href="../108300/index.html">Microblog about English words on Twitter: three months development</a></li>
<li><a href="../108302/index.html">Large traffic flows and interrupt management in Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>