<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Background removal using deep learning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation Background removal with deep learning . 

 For the last several years of work in the field of machine learning, we have wanted to create r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Background removal using deep learning</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/mp/mc/_l/mpmc_l8gbzljvkqq6kwnghzzals.jpeg"><br><br>  <i>Translation <a href="https://towardsdatascience.com/background-removal-with-deep-learning-c4f2104b3157">Background removal with deep learning</a> .</i> <br><br>  For the last several years of work in the field of machine learning, we have wanted to create real products based on machine learning. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A few months ago, after passing the excellent course <a href="http://www.fast.ai/">Fast.AI</a> , the stars coincided, and we had the opportunity.  Modern advances in technology of deep learning have made it possible to accomplish much of what previously seemed impossible, new tools appeared that made the implementation process more accessible than ever. <br><br>  We set the following goals: <br><br><ol><li>  Improve our skills with deep learning. </li><li>  Improve our skills in introducing products based on AI. </li><li>  Create a useful product with market prospects. </li><li>  Have fun (and help our users have fun). </li><li>  Exchange experience. </li></ol><a name="habracut"></a><br>  Given the above, we studied ideas that: <br><br><ol><li>  No one has yet been able to implement (or implement properly). </li><li>  They will not be too complicated in planning and implementation - we spent 2-3 months working on a project with a workload of 1 working day per week. </li><li>  They will have a simple and attractive user interface - we wanted to make a product that people will use, and not just for demonstration purposes. </li><li>  They will have available data for training - as any machine learning specialist knows, sometimes data is more expensive than an algorithm. </li><li>  They will use advanced deep learning methods (which have not yet been marketed by Google, Amazon or their friends on cloud platforms), but not too advanced (so that we can find a few examples on the Internet). </li><li>  Will have the potential to achieve a result sufficient to bring the product to market. </li></ol><br>  Our early assumptions were to take on some kind of medical project, since this area is very close to us, and we felt (and still feel) that there are a huge number of topics suitable for deep learning.  However, we realized that we would encounter problems in collecting data and, possibly, legality and regulation, which contradicted our desire not to complicate the task ourselves.  Therefore, we decided to stick with plan B - to make a product for removing background in images. <br><br>  Background removal is a task that is easy to perform manually, or almost manually (Photoshop, and even Power Point have such tools) if you use some kind of ‚Äúmarker‚Äù and border detection technology, <a href="https://clippingmagic.com/">see an example</a> .  However, fully automated background removal is a rather difficult task, and, as far as we know, there is still no product that has achieved acceptable results (although there are those who are <a href="http://www.logitech.com/en-us/product/c922-pro-stream-webcam">trying</a> ). <br><br>  What background will we delete?  This question turned out to be important, because the more specific the model is in terms of objects, angles, etc., the higher the quality of the background and foreground separation will be.  When we started our work, we thought broadly: a comprehensive background removal tool that automatically identifies the foreground and background in each type of image.  But after learning our first model, we realized that it was better to focus our efforts on a specific set of images.  Therefore, we decided to focus on selfies and portraits of people. <br><br><img src="https://habrastorage.org/webt/3r/c7/fu/3rc7fuchesslgzgg8koti6vcg6c.png"><br>  <i>Removing the background on a photo (almost) of a person.</i> <br><br>  Selfie is an image: <br><br><ul><li>  with a characteristic and foreground oriented (one or more ‚Äúpeople‚Äù), which guarantees us a good separation between the object (face + upper body) and the background, </li><li>  and also with a constant angle and always the same object (person). </li></ul><br>  Considering these statements, we started research and implementation, having spent many hours on training in order to create an easy-to-use background removal service with one click. <br><br>  The main part of our work was to train the model, but we could not afford to underestimate the importance of proper implementation.  Good segmentation models are still not as compact as image classification models (for example, <a href="https://arxiv.org/abs/1602.07360">SqueezeNet</a> ), and we actively explored deployment options on both the server side and the browser side. <br><br>  If you want to read more about the implementation process of our product, you can read our posts about the implementation on the <a href="https://medium.com/%40burgalon/35648f9dc5fb">server</a> side and on the <a href="https://medium.com/%40burgalon/2e5a29589ad8">client</a> side. <br><br>  If you want to learn about the model and its learning process, continue to read here. <br><br><h2>  Semantic segmentation </h2><br>  When studying the tasks of deep learning and computer vision, resembling the tasks before us, it is easy to understand that the best option for us is the task of <b>semantic segmentation</b> . <br><br>  There are other strategies, such as <a href="https://arxiv.org/pdf/1507.06821.pdf">dividing by depth</a> , but they seemed not mature enough for our purposes. <br><br>  Semantic segmentation is a well-known computer vision task, one of the three most important, along with the classification and detection of objects.  Segmentation, in fact, is the task of classification, in the sense of the distribution of each pixel into classes.  Unlike image classification or image detection models, the segmentation model does demonstrate some ‚Äúunderstanding‚Äù of images, that is, not only says ‚Äúthere is a cat in this image‚Äù, but also indicates at the pixel level where this cat is. <br><br>  So how does segmentation work?  To better understand, we will need to explore some of the early work in this area. <br><br>  The very first idea was to adapt some of the early classification networks, such as VGG and Alexnet.  VGG (Visual Geometry Group) was an advanced model for image classification in 2014, and even today it is very useful due to its simple and clear architecture.  When studying the early layers of VGG, it can be noted that high activation is inherent in the categorization.  Deeper layers have even stronger activation, however, they are terrible in nature due to repeated pooling action.  With all this in mind, it has been suggested that the method of classification can also be used to search / segmentation of an object, with some changes. <br><br>  Early results of semantic segmentation appeared along with classification algorithms.  In <a href="http://warmspringwinds.github.io/tensorflow/tf-slim/2016/11/22/upsampling-and-image-segmentation-with-tensorflow-and-tf-slim/">this post</a> you can see some rough segmentation results obtained using VGG: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dg/4h/k6/dg4hk6bm3vkfojq-j06vojv9ptc.png"></div><br><br>  The results of the deeper layers: <br><br><img src="https://habrastorage.org/webt/4p/s_/ba/4ps_bay6xfoqynoerq4v9on9hie.png"><br>  <i>The segmentation of the bus image, light purple (29) - is the class of the school bus.</i> <br><br>  After bilinear resampling: <br><br><img src="https://habrastorage.org/webt/nt/hb/i6/nthbi6_xel0pfu__9rt6063e5sc.png"><br><br>  These results are obtained from a simple transformation (or maintenance) of a fully connected layer into its original form, retaining its spatial characteristics and obtaining a complete convolutional neural network.  In the example above, we load the image 768 * 1024 into VGG and get the layer 24 * 32 * 1000. 24 * 32 is the image after pooling (32 each), and 1000 is the number of image-net classes from which we can get the above segmentation <br><br>  To improve prediction, researchers simply used a bilinear resampling layer. <br><br>  In the work of <a href="">FCN, the</a> authors improved the above idea.  They put together several layers to produce more intense interpretations, which they called FCN-32, FCN-16 and FCN-8, according to the frequency of resampling: <br><br><img src="https://habrastorage.org/webt/je/v-/zx/jev-zxh-zm5cgm-feu2xdlvtzps.png"><br><br>  Adding some bandwidth connections (skip connections) between layers made it possible to predict with encoding more fine details of the original image.  Further training further improved results. <br><br>  This method proved to be not as bad as one might think, and proved that semantic segmentation with deep learning really does have potential. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/hj/g1/-nhjg1hgdi08a3kqnp0kiwh4ndw.png"></div><br>  <i>FCN results.</i> <br><br>  FCN uncovered the concept of segmentation, and researchers were able to test different architectures for this task.  The basic idea remained unchanged: the use of well-known architectures, resampling and throughput connections are still present in more recent models. <br><br>  You can read about achievements in this area in several good posts: <a href="http://blog.qure.ai/notes/semantic-segmentation-deep-learning-review">here</a> , <a href="https://blog.athelas.com/a-brief-history-of-cnns-in-image-segmentation-from-r-cnn-to-mask-r-cnn-34ea83205de4">here</a> and <a href="https://meetshah1995.github.io/semantic-segmentation/deep-learning/pytorch/visdom/2017/06/01/semantic-segmentation-over-the-years.html">here</a> .  You may also notice that most architectures have an ‚Äúencoder-decoder‚Äù scheme. <br><br><h2>  Returning to our project </h2><br>  After some research, we stopped at three models available to us: FCN, <a href="https://arxiv.org/pdf/1505.04597.pdf">Unet</a> and <a href="https://arxiv.org/abs/1611.09326">Tiramisu</a> - these are very deep architectures of the "encoder-decoder" type.  We also had some thoughts on the mask-RCNN method, but its implementation was outside the scope of our project. <br><br>  FCN did not seem relevant, since its results were not as good as we wanted (even as a starting point), but the other two models showed good results: the main advantages of Unet and Tiramisu with <a href="http://mi.eng.cam.ac.uk/research/projects/VideoRec/CamVid/">CamVid</a> were their compactness and speed.  Unet was pretty easy to implement (we used keras), but Tiramisu was also quite realizable.  To start somewhere, we used the good Tiramisu <a href="http://files.fast.ai/part2/lesson14/">implementation</a> described in the last lesson <a href="https://www.usfca.edu/data-institute/certificates/deep-learning-part-two">of the</a> Jeremy Howard <a href="https://www.usfca.edu/data-institute/certificates/deep-learning-part-two">in-</a> depth training <a href="https://www.usfca.edu/data-institute/certificates/deep-learning-part-two">course</a> . <br><br>  We started to teach these two models on some datasets.  It must be said that after we first tried Tiramisu, its results had much greater potential for us, since the model could capture the sharp edges of the image.  Unet, in turn, was not good enough, and the results looked a bit blurry. <br><br><img src="https://habrastorage.org/webt/ef/cz/3y/efcz3ynoc2lbelz8yogwotftc2i.png"><br>  <i>Blur Unet results.</i> <br><br><h2>  Data </h2><br>  Having defined the model, we began to look for suitable datasets.  Data for segmentation is not as common as data for classification, or even for detection.  In addition, we could not index images manually.  The most popular datasets for segmentation were: <a href="http://mscoco.org/">COCO</a> , which includes about 80 thousand images in 90 categories, <a href="http://host.robots.ox.ac.uk/pascal/VOC/">VOC pascal</a> with 11 thousand images in 20 classes, and more recent <a href="http://groups.csail.mit.edu/vision/datasets/ADE20K/">ADE20K</a> . <br><br>  We decided to work with COCO because it includes many more images of the ‚Äúperson‚Äù class that interested us. <br><br>  Considering our task, we have thought about whether we will use only relevant for us images or more ‚Äúcommon‚Äù data.  On the one hand, using a more general dataset with a large number of images and classes will allow the model to cope with more scenarios and tasks.  On the other hand, training for one night allowed us to process ~ 150 thousand images.  If we provide the entire COCO dataset to the model, then it will see each image twice (on average), so it‚Äôs better to cut it a little.  In addition, our model will be better sharpened by our task. <br><br>  Another point worth mentioning is that the Tiramisu model was originally trained in the CamVid dataset, which has some flaws, the main one of which is a strong monotony of images: photos of roads taken from cars.  As you can understand, training on such a dataset (even if it contains people) did not benefit us, so after some trials we moved on. <br><br><img src="https://habrastorage.org/webt/w7/sn/my/w7snmyko9pidpdf4qlnobmxhquu.png"><br>  <i>Images from CamVid.</i> <br><br>  Dataset COCO comes with a fairly simple API that allows us to know exactly which objects are on which image (according to 90 predefined classes). <br><br>  After some experiments, we decided to dilute the dataset: at first, only the images with the person were filtered out, leaving 40 thousand pictures.  Then they discarded all the images with several people, leaving only photos with 1-2 people, because our product is intended for such situations.  Finally, we left only the images in which a person occupies 20% - 70% of the area, deleting images with too small a person or with some strange monsters (unfortunately, we were not able to remove all of them).  Our final dataset consisted of 11,000 images, which we felt were sufficient at this stage. <br><br><img src="https://habrastorage.org/webt/n-/kh/5f/n-kh5frbncplicujqzspd1yjuym.png"><br>  <i>Left: the right image.</i>  <i>Center: Too many participants.</i>  <i>Right: The object is too small.</i> <br><br><h2>  Tiramisu model </h2><br>  Although the full name of the Tiramisu model ("100 layers of Tiramisu") implies a giant model, in fact it is quite economical and uses only 9 million parameters.  For comparison, the VGG16 uses over 130 million parameters. <br><br>  The Tiramisu model is based on DenseNet, a fresh image classification model in which all layers are interconnected.  In addition, throughput connections are added to the oversampling layers in Tiramisu, as in Unet. <br><br>  If you remember, this architecture is consistent with the idea presented in FCN: using the classification architecture, resampling, and adding bandwidth connections for optimization. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5f/qj/un/5fqjunfogqno37kkz69sxxtzuvs.png"></div><br>  <i>This is the architecture of Tiramisu.</i> <br><br>  The <a href="https://arxiv.org/pdf/1608.06993.pdf">DenseNet</a> model can be viewed as a natural evolution of the Resnet model, but instead of ‚Äúmemorizing‚Äù each layer only up to the next layer, Densenet remembers all layers in the entire model.  Such connections are called highway connections.  This leads to an increase in the number of filters, called the ‚Äúgrowth rate‚Äù.  Tiramisu has a growth rate of 16, that is, with each layer we add 16 new filters until we reach layers of 1072 filters.  You could expect 1600 layers, because this is a 100-layer Tiramisu model, however, the resampled layers discard some filters. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/1j/9y/cr1j9yzjbxb8ub52ukd0iaqt1ae.png"></div><br>  <i>Densenet's model schema ‚Äî early filters are going on the stack throughout the entire model.</i> <br><br><h2>  Training </h2><br>  We trained our model according to the schedule described in the original document: standard cross-entropy loss, RMSProp optimizer with a 1E-3 learning coefficient and a slight weakening.  We divided our 11 thousand images into three parts: 70% for training, 20% for testing and 10% for testing.  All images below are taken from our test dataset. <br><br>  In order for our training schedule to coincide with that given in the original document, we set the sampling period at a level of 500 images.  This also allowed us with each improvement of the results to periodically save the model, since we trained it on much more data than in the document (the CamVid datas used in this article contained less than 1,000 images). <br><br>  In addition, we trained our model using only two classes: background and person, and there were 12 classes in the source document.  At first we tried to teach COCO dataset on some classes, however, we noticed that this does not lead to an improvement in the results. <br><br><h2>  Data problems </h2><br>  Some disadvantages of dataset lowered our assessment: <br><br><ul><li>  <b>Animals</b>  Our model sometimes segmented animals.  This, of course, leads to a low IoU (intersection over union, the ratio of the intersection to the union).  Adding animals to the main class or to a separate one would probably affect our results. </li><li>  <b>Body parts</b>  Since we programmatically filtered our dataset, we were unable to determine whether a person‚Äôs class is really a person, not a part of the body, for example, a hand or a foot.  These images were not of interest to us, but still appeared here and there. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/kd/vt/kskdvtexzpm6to-mvw7etd3da5y.png"></div><br>  <i>Animal, body part, portable object.</i> </li><li>  <b>Portable objects</b> .  Many images in dataset are related to sports.  Baseball bats, tennis rackets and snowboards were everywhere.  Our model was somehow ‚Äúconfused‚Äù, not understanding how to segment it.  As in the case of animals, in our opinion, adding them as part of the main class (or as a separate class) would help improve the performance of the model. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e4/xw/qn/e4xwqnxbrqklj9hvjjre94_rn_y.png"></div><br>  <i>Sports image with object.</i> </li><li>  <b>Rough control data (ground truth)</b> .  COCO dataset was annotated not pixel-by-pixel, but with the help of polygons.  Sometimes this is enough, but in some cases the control data is too ‚Äúrough‚Äù, which may prevent the model from learning the finer points. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/8h/6z/aj8h6z2goplsfoufzkmv418a8xw.png"></div><br>  <i>The image itself and (very) rough control data.</i> </li></ul><br><h2>  results </h2><br>  Our results were satisfactory, although not perfect: we achieved an IoU of 84.6 on our test dataset, while the current achievement is a value of 85 IoU.  However, the specific value varies depending on dataset and class.  There are classes that are inherently easier to segment, for example, houses or roads, where most models easily achieve results in 90 IoU.  More difficult classes are trees and people, on which most models achieve results around 60 IoU.  Therefore, we helped our network focus on one class and limited types of photos. <br><br>  We still do not feel that our work is ‚Äúready for release,‚Äù as we would like, but we believe that it‚Äôs time to stop and discuss our achievements, since about 50% of the photos will give good results. <br><br>  Here are some good examples that will help you to feel the possibilities of the application: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/5j/l7/pg5jl7u4s34ywcldtzgy1jtmmpq.png"></div><br>  <i>Image - control data - our results (from our test dataset).</i> <br><br><h2>  Debugging and Logging </h2><br>  Debugging is a very important part of learning neural networks.  At the beginning of our work it was very tempting to get down to business right away - take data and a network, start learning and see what happens.  However, we found that it is extremely important to track each step, exploring the results at each stage. <br><br>  Here are the frequently encountered difficulties and our solutions: <br><br><ol><li>  <b>Early problems</b> .  Model can not begin to learn.  This may be due to an internal problem or a preprocessing error, for example, if you forget to normalize some pieces of data.  In any case, a simple visualization of the results can be very useful.  Here is a good <a href="https://blog.slavv.com/37-reasons-why-your-neural-network-is-not-working-4020854bd607">post</a> on this topic. </li><li>  <b>Debugging the network itself</b> .  In the absence of serious problems, learning begins with predetermined losses and metrics.  In segmentation, the main criterion is IoU - the ratio of the intersection to the union.  It took us several sessions to start using <a href="http://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection/">IoU</a> as the main criterion for our models (and not the loss of cross-entropy).  Another useful practice has been to display the prediction of our model at each sampling period.  <a href="https://hackernoon.com/how-to-debug-neural-networks-manual-dc2a200f10f2">Here is a</a> good article on debugging machine learning models.  Please note that IoU is not a standard metric / loss in keras, but you can easily find it on the Internet, for example, <a href="">here</a> .  We also used this <a href="https://gist.github.com/shgidi/7c3fcf69b1eb3eaf4bac1112d10967ca">gist</a> for scheduling losses and some prediction in each sampling period. </li><li>  <b>Control of machine learning versions</b> .  There are many parameters in teaching a model, and some of them are quite complex.  I must say that we still have not found the ideal method, except that we enthusiastically fixed all our configurations (and automatically saved the best models with the callback call, see below). </li><li>  <b>Debug tool</b>  After doing all of the above, we were able to analyze our work at every step, but not without difficulty.  Therefore, the most important step was to combine the above steps and upload the data to Jupyter Notebook (a tool for creating analytical reports), which allowed us to easily load each model and each image, and then quickly study the results.  Thus, we were able to see the differences between the models and detect pitfalls and other problems. </li></ol><br>  Here are examples of improving our model, achieved through parameter settings and additional training: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/at/uf/hpatufaqrgehvmhxm-zqxie3swc.png"></div><br><br>  To save the model with the best IoU result (to simplify the work, Keras allows you to make very good <a href="https://keras.io/callbacks/">callbacks</a> ): <br><br> <code>callbacks = [keras.callbacks.ModelCheckpoint(hist_model, verbose=1,save_best_only =True, monitor= 'val_IOU_calc_loss'), plot_losses]</code> <br> <br>  In addition to the usual debugging of code errors, we noticed that model errors are ‚Äúpredictable.‚Äù  For example, ‚Äúcutting off‚Äù body parts that are not counted as a body, ‚Äúgaps‚Äù in large segments, excessive continuations of body parts, poor lighting, poor quality and many details.  Some of these errors were avoided by adding specific images from different datasets, and for some we still could not find a solution.  To improve the results in the next version of the model, we will use augmentation for the ‚Äúcomplex‚Äù images for our model. <br><br>  We have already mentioned this above (in the section on dataset problems), but now let's look at some of the difficulties in more detail: <br><br><ol><li>  <b>Clothes</b>  Very dark or very light clothing is sometimes interpreted as a background. </li><li>  <b>"Clearances"</b> .  Results, good in everything else, sometimes had gaps in them. <br><br><img src="https://habrastorage.org/webt/wv/hk/w-/wvhkw-woznnresuigiy8w6qfrlo.png"><br>  <i>Clothing and clearances.</i> </li><li>  <b>Lighting</b>  Images often have poor lighting and darkness, but not in COCO data.  It is generally difficult for models to work with such pictures, and our model was in no way prepared for such complicated images.  You can try to solve this by adding more data, as well as using data augmentation.  For now, it‚Äôs better not to test our app at night :) <br><br><img src="https://habrastorage.org/webt/nv/x5/lc/nvx5lckcaglg4uaqjiilamv5sfu.png"><br>  <i>An example of poor lighting.</i> </li></ol><br><h2>  Options for further improvement </h2><br><h4>  Continuing education </h4><br>  Our results were obtained after approximately 300 sampling cycles on our test data.  After this, over-fitting began.  We achieved such results very close to the release, so we did not have the opportunity to apply the standard practice of augmentation data. <br><br>  We trained the model after resizing the images to 224x224.  Further learning should also improve results with more data and larger images (the original size of COCO images is about 600x1000). <br><br><h4>  CRF and other improvements </h4><br>  At some stages, we noticed that our results are a bit "noisy" around the edges.  The model that can handle this is CRF (Conditional random fields).  In this <a href="http://warmspringwinds.github.io/tensorflow/tf-slim/2016/12/18/image-segmentation-with-tensorflow-using-cnns-and-conditional-random-fields/">post, the</a> author gives a simplified example of using CRF. <br><br>  However, we were of little use to her, perhaps because this model is usually useful when the results are rougher. <br><br><h4>  Matting </h4><br>  Even with our current results, segmentation is not perfect.  Hair, thin clothing, tree branches and other small items will never be perfectly segmented, if only because the segmentation of control data does not contain these nuances.  The task of separating such delicate segmentation is called matting, and it also reveals other difficulties.  Here is an example of modern matting <a href="https://news.developer.nvidia.com/ai-software-automatically-removes-the-background-from-images/">published</a> at the beginning of this year at the NVIDIA conference. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/l4/yw/n7l4ywblczs-ekcyyymeprlgqhy.png"></div><br>  <i>An example of matting - input data includes trimap.</i> <br><br>  The matting task is different from other image processing tasks, since the input data includes not only the image, but also trimap, the outline of the edges of the images, which makes matting the problem of "semi-controlled" learning. <br><br>  We experimented a bit with matting using our segmentation as a trimap, but did not achieve significant results. <br><br>  Another problem was the lack of dataset suitable for learning. <br><br><h2>  Results </h2><br>  As stated at the beginning, our goal was to create a meaningful product through deep learning.  As you can see in <a href="https://medium.com/%40burgalon">Alon's</a> posts, implementation is getting easier and faster.  On the other hand, with the training model things are worse - training, especially when it is held overnight, requires careful planning, debugging and recording of results. <br><br>  It is not easy to balance between research and attempts to do something new, as well as routine training and improvement.  Since we use deep learning, we always have the feeling that a more advanced model is just around the corner, or just the model we need, and another Google search, or another read article will lead us to the desired.  But in practice, our actual improvements were due to the fact that we ‚Äúsqueezed‚Äù more and more of our original model.  And we still feel that we can squeeze so much more. <br><br>  We had a lot of fun doing this work, which a few months ago seemed like science fiction. <br><br>  <a href="https://greenscreen-ai.boorgle.com/">greenScreen.AI</a> </div><p>Source: <a href="https://habr.com/ru/post/350576/">https://habr.com/ru/post/350576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350564/index.html">The preliminary program DUMP-2018 is ready. Speakers from Microsoft, VKontakte, Rambler, Tinkoff, HTML Academy</a></li>
<li><a href="../350566/index.html">Schi, or Recognition of 330 million people at a speed of 400 photos / sec</a></li>
<li><a href="../350570/index.html">Backend on CodeFest: bigdate, machine and blockchain</a></li>
<li><a href="../350572/index.html">Backlog in product management: what to do when ideas grow ‚Äúlike a snowball‚Äù</a></li>
<li><a href="../350574/index.html">You can not just take and edit subtitles</a></li>
<li><a href="../350578/index.html">UX-design in Russia and the CIS "under the microscope"</a></li>
<li><a href="../350580/index.html">Kali Linux is now available in the Microsoft Store</a></li>
<li><a href="../350582/index.html">Excel instead of PowerShell: queries to AD and system reports "on the knee"</a></li>
<li><a href="../350584/index.html">An overview of the new UMAP dimension reduction algorithm. Is it really better and faster than t-sne?</a></li>
<li><a href="../350588/index.html">We wrote the code together for one computer for five months. This is what I learned</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>