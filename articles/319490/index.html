<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dijkstra's algorithm and development through testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello dear readers. Some potential authors with whom we communicate think that there is a shortage of books on TDD in our assortment. We think how to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dijkstra's algorithm and development through testing</h1><div class="post__text post__text-html js-mediator-article">  Hello dear readers.  Some potential authors with whom we communicate think that there is a shortage of books on TDD in our assortment.  We think how to approach it.  But we are no less interested in what you think about her.  Therefore, we offer translation of the article by the legendary Robert Martin, the author of the chic book ‚ÄúClean Code‚Äù, under the cut.  In an article (October 2016), Mr. Martin demonstrates the art of TDD using the example of Dijkstra‚Äôs algorithm. <br><a name="habracut"></a><br>  Not so long ago, I was at a <a href="http://scna.softwarecraftsmanship.org/">SCNA</a> conference, and one of my colleagues turned to me about test development (TDD) and Dijkstra's algorithm.  He asked if it would be possible to find a series of tests that would lead us to this algorithm.  It seemed to me that this would be an interesting exercise, so I decided to perform it here. <br><br>  As usual, I started with a degenerate test case. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MinPathTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nothing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ } }</code> </pre> <br>  Dijkstra's algorithm is a simple technique that allows you to find the shortest path along a graph with edges of arbitrary length.  Having initial and final nodes, the algorithm will give you the shortest path and the length of this path. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, from the very beginning, some interesting solutions are seen.  How to submit an input graph?  And how - the result of the algorithm?  Perhaps most of these issues can be solved later.  For now, let's focus on the maximally degenerate case: an empty graph. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noGraph_NoPathZeroLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Assert.assertEquals(<span class="hljs-string"><span class="hljs-string">"{}0"</span></span>, minPath(<span class="hljs-string"><span class="hljs-string">""</span></span>)); }</code> </pre> <br>  Already at the stage of the very first test I began to look for the output format.  I decided to present the final path as a set of nodes in curly brackets.  The length of the path is expressed as an integer following the parentheses. <br><br>  This notation is for my tests only.  I called this technique ‚Äúcombined statements‚Äù (composed asserts).  I like to put statements in readable instructions. <br><br>  Often, this means that the test requires you to write a simple translator that turns combined statements into a real API of the system under test. <br><br>  Of course, to pass this test, just write the following: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{}0"</span></span>; }</code> </pre> <br>  Let's take a closer look at this test case.  The <code>minPath</code> call is incorrect.  Dijkstra's algorithm allows you to find the shortest path between two given nodes.  So, if we assume that the nodes are named, the test should actually look like this: <br><br><pre> <code class="java hljs">Assert.assertEquals(<span class="hljs-string"><span class="hljs-string">"{}0"</span></span>, minPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>));</code> </pre> <br>  But he is ugly.  You can do refactoring to comb it a bit: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, String expected)</span></span></span><span class="hljs-function"> </span></span>{ assertEquals(expected, minPath(graph, <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noGraph_NoPathZeroLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"{}0"</span></span>); }</code> </pre> <br>  Note that the assertPath method simply assumes that in all test cases we will use ‚ÄúA‚Äù and ‚ÄúZ‚Äù as the starting and ending point. <br><br>  Last change: I think the path and length should be divided. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertMinPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length, String path)</span></span></span><span class="hljs-function"> </span></span>{ assertEquals(length, minLength(graph, <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); assertEquals(path, minPath(graph, <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noGraph_NoPathZeroLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>); } privateintminLength(String graph, String begin, String end) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{}"</span></span>; }</code> </pre> <br>  Since I check the statement with the help of two methods, I think it is logical to assume that these should be methods of a certain class that performs the Dijkstra algorithm.  So let's refactor the delegate to get a new class. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MinPathTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertMinPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length, String path)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathFinder(graph); assertEquals(length, pf.minLength(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); assertEquals(path, pf.minPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noGraph_NoPathZeroLength</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>); } } classPathFinder { publicPathFinder(String graph) { } publicintminLength(String begin, String end) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{}"</span></span>; } }</code> </pre> <br>  I think it is interesting to note how much thought and effort was put into structuring this problem;  this is just the first degenerate test.  And now add a few more degenerate cases: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degenerateCases</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  assertMinPath("A", 0, "{}"); //  assertMinPath("B1C", 0, "{}");//     assertMinPath("A1C", 0, "{}");//   assertMinPath("B1Z", 0, "{}");//   }</span></span></code> </pre> <br>  These tests forced me to solve the situation with a combined statement differently.  In our tests, the edge of the graph will have the structure length.  So, B1C is an edge of unit length connecting node B with node C. <br><br>  I think this is all with degenerate cases.  So let's give a little heat and discuss the first test case, for which it would take at least a symbolic brains movement. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oneEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">"A1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"{AZ}"</span></span>); }</code> </pre> <br>  The test, of course, fails.  I am also uncomfortable with the fact that here I check two things at once - the path and the length, although they could be checked separately.  It's a shame because I killed so much time, making up this combined statement, and now I want to make out again. <br><br>  But I think this situation can be ‚Äútricky‚Äù to get around. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String ANY = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertMinPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, Integer length, String path)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathFinder(graph); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)length, pf.minLength(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals(path, pf.minPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); } ... <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oneEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">"A1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, ANY); }</code> </pre><br>  So the combined statement remains intact, and I can, if desired, ignore either of the two components.  Now let's get to the test. <br><br>  Obviously, now I have to do something like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minLength</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (graph.equals(<span class="hljs-string"><span class="hljs-string">"A1Z"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  But here I am breaking a few rules.  First, the rule of universality, which says: the more specific the tests, the more generalized the code.  In other words, the combat code should become more universal - only this way it will pass the falling test.  Expressions that are specific to a falling test cannot be added to the combat code (in more detail about this I tell in <a href="https://cleancoders.com/episode/clean-code-episode-19-p1/show">Episode 19: Advanced TDD</a> , on cleancoders.com). <br><br>  The second rule violated is the connectedness of tests.  We can not allow a strong connection between the tests in the combat code.  The stronger the binding, the more fragile the tests.  I do not want to promote solutions in which the only change in the combat code will break dozens or hundreds of tests.  In this particular case, the combined statement should not be allowed to leak into the combat code API. <br><br>  Thus, you should not pass a <code>String graph</code> into the <code>PathFinder</code> constructor.  This also means that the <code>minPath</code> function <code>minPath</code> not return the <code>String</code> used by the combined statement. <br><br>  So, we start to unleash the tests.  The makePathFinder function below shows how this is done. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MinPathTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String ANY = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertMinPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, Integer length, String path)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = makePathFinder(graph); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) length, pf.minLength(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals(path, pf.minPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>)); } privatePathFindermakePathFinder(String graph) { PathFinder pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathFinder(); Pattern edgePattern = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"(\\D+)(\\d+)(\\D+)"</span></span>); Matcher matcher = edgePattern.matcher(graph); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (matcher.matches()) { String start = matcher.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = Integer.parseInt(matcher.group(<span class="hljs-number"><span class="hljs-number">2</span></span>)); String end = matcher.group(<span class="hljs-number"><span class="hljs-number">3</span></span>); pf.addEdge(start, end, length); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pf; } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degenerateCases</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   assertMinPath("A", 0, "{}"); //   assertMinPath("B1C", 0, "{}");//     assertMinPath("A1C", 0, "{}");//   assertMinPath("B1Z", 0, "{}");//   } @Test public void oneEdge() throws Exception { assertMinPath("A1Z", 1, ANY); } } classPathFinder { private List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); publicPathFinder() { } publicintminLength(String begin, String end) { int length = 0; for (Edge edge : edges) { if (edge.begin.equals(begin) &amp;&amp;edge.end.equals(end)) length += edge.length; } return length; } public String minPath(String begin, String end) { return "{}"; } public void addEdge(String start, String end, int length) { edges.add(new Edge(start, end, length)); } private static class Edge { public final String begin; public final String end; public final int length; public Edge(String begin, String end, int length) { this.begin = begin; this.end = end; this.length = length; } } }</span></span></code> </pre> <br>  Note: parsing of the combined assertion remains in the test class.  The PathFinder class is not aware of the amusing syntax of my tests.  Also, I emphasize that in order for tests to be performed, the combat code must assume that the graph has only one edge.  I mean, we have to get rid of this <code>ANY</code> . <br><br><pre> <code class="java hljs">assertMinPath(<span class="hljs-string"><span class="hljs-string">"A1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"{AZ}"</span></span>);</code> </pre> <br>  So, let's compile a list of nodes available on the way.  List?  Oh yes, there is syntax <br>  <code>toString</code> for lists.  This test, as well as all subsequent ones will have to be changed as follows: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degenerateCases</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"[]"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   assertMinPath("A", 0, "[]"); //   assertMinPath("B1C", 0, "[]"); //     assertMinPath("A1C", 0, "[]"); //   assertMinPath("B1Z", 0, "[]"); //   } @Test public void oneEdge() throws Exception { assertMinPath("A1Z", 1, "[A, Z]"); }</span></span></code> </pre> <br>  Now, in order to pass this test, you need to change the auxiliary test function <code>assertMinPath</code> , by adding the <code>toString</code> call. <br><br>  ... <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals(path, pf.minPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>).toString()); ...</code> </pre> <br>  Add the <code>path</code> list to the <code>PathFinder</code> and simply load it into the <code>minLength</code> function. <br><br><pre> <code class="java hljs">classPathFinder { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Edge&gt; edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); ... publicintminLength(String begin, String end) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge edge : edges) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge.begin.equals(begin) &amp;&amp;edge.end.equals(end)) { length += edge.length; path.add(edge.begin); path.add(edge.end); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;String&gt;minPath(String begin, String end) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; } ...</code> </pre> <br>  Works.  But I do not like that minLength also calculates the path.  I think calculations and reporting should be divided. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertMinPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, Integer length, String path)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = makePathFinder(graph); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) length, pf.getLength()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals(path, pf.getPath().toString()); } privatePathFindermakePathFinder(String graph) { PathFinder pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathFinder(); ... pf.findPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pf; } classPathFinder { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Edge&gt; edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;String&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); privateint length; ... publicintgetLength() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;String&gt;getPath() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; } ...</code> </pre> <br>  Already better.  Now make sure that we get the correct length. <br><br><pre> <code class="java hljs">assertMinPath(<span class="hljs-string"><span class="hljs-string">"A2Z"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, Z]"</span></span>);</code> </pre> <br>  Yeah, everything works fine.  Let's try with two consecutive edges <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoEdges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">"A1B,B1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ANY); }</code> </pre> <br>  As expected, the test failed, we get a zero length.  To go through it, you need to parse the set of edges in the auxiliary function makePathFinder.  It is quite simple.  Just cut the graph in comma and set the regular expression matcher in a loop. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">privatePathFinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePathFinder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathFinder(); Pattern edgePattern = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"(\\D+)(\\d+)(\\D+)"</span></span>); String[] edges = graph.split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String edge : edges) { Matcher matcher = edgePattern.matcher(edge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (matcher.matches()) { String start = matcher.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = Integer.parseInt(matcher.group(<span class="hljs-number"><span class="hljs-number">2</span></span>)); String end = matcher.group(<span class="hljs-number"><span class="hljs-number">3</span></span>); pf.addEdge(start, end, length); } } pf.findPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pf; }</code> </pre> <br>  Of course, the test still falls, so now we need to connect two edges.  Suppose that the edges are specified in a certain order, so that the first edge begins with node A, and the second ends with node Z. In this case, we will provide the entire connection by replacing <code>&amp;&amp;</code> with <code>||</code>  in the <code>findPath</code> function: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge edge : edges) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge.begin.equals(begin) || edge.end.equals(end)) { length += edge.length; path.add(edge.begin); path.add(edge.end); } } }</code> </pre> <br>  Like this replacement?  <code>&amp;&amp;</code> to <code>||</code>  .  Yes, stupid.  This solution will work only with two consecutive edges.  We are already building Napoleonic plans.  But, after all, it is not suitable. <br><br>  Oh, we cope with the <code>twoEdges</code> test, and with the <code>oneEdge</code> tests, but we fail the <code>degenerateCases</code> tests. <br><br>  To pass all these tests, I need an implementation that gives zero length and an empty path if the path from A to Z does not exist.  Now, since I don't know how many edges there are (there can be zero, one, or two), I can't just take two.  Instead, I separately analyze all three cases: if there are no edges, there is one edge or two edges.  It turns out the following code: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edges.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edges.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { Edge edge = edges.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge.begin.equals(begin) &amp;&amp;edge.end.equals(end)) { path.add(edge.begin); path.add(edge.end); length += edge.length; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge edge : edges) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edge.begin.equals(begin) || edge.end.equals(end)) { path.add(edge.begin); path.add(edge.end); length += edge.length; } } } }</code> </pre><br>  Yeah, it works, but it looks awful.  The decision not only violates the rule of universality;  it is simply disgusting.  Moreover, the code incorrectly collects the path.  For example, <code>assertMinPath ("A1B, B1Z", 2, "[A, B, Z]");</code>  fails because it gives <code>[A, B, B, Z]</code> .  This could be fixed by adding another horrible <code>if</code> ;  but there is a better idea.  Let's go through the graph again from beginning to end. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; p.add(begin); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge e = findEdge(begin); e != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; e = findEdge(e.end)) { p.add(e.end); l += e.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.end.equals(end)) { length = l; path = p; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Edge </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge e : edges) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.begin.equals(begin)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  OK, it works.  It is strange that one has to use temporary variable lengths and paths;  but I see no other way to ignore nonexistent paths.  I also believe that this solution eliminates the dependence on the order of nodes. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoEdges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath (<span class="hljs-string"><span class="hljs-string">"A1B,B1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, B, Z]"</span></span>); assertMinPath (<span class="hljs-string"><span class="hljs-string">"B1Z,A1B"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, B, Z]"</span></span>); assertMinPath (<span class="hljs-string"><span class="hljs-string">"A1X,Y1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"[]"</span></span>); }</code> </pre> <br>  Yes.  Everything passes.  I think it will work with three, and with a large number of edges.  The same applies to graphs, in which there is only one complete path, and the remaining paths are hanging. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threeEdges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath (<span class="hljs-string"><span class="hljs-string">"A2B,B3C,C4Z"</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, B, C, Z]"</span></span>); assertMinPath (<span class="hljs-string"><span class="hljs-string">"B3C,C4Z,A2B"</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, B, C, Z]"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnlyOnePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath (<span class="hljs-string"><span class="hljs-string">"A1B,B2C,C3Z,B4D,D6E"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, B, C, Z]"</span></span>); }</code> </pre> <br>  But this one fails because we do not find the edges of C3Z when traversing the graph. <br><br><pre> <code class="java hljs">assertMinPath (<span class="hljs-string"><span class="hljs-string">"A1B,B2C,C3D,C3Z"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, B, C, Z]"</span></span>);</code> </pre> <br>  Okay.  So, we can not just go around the graph in order.  Instead, we will have to check all possible paths from the starting node;  in the process, temporary variables will have to be written, and so on until we get to the end. <br><br>  Then you can make sure that this requires pretty tricky: track all nodes, as well as the paths associated with these nodes, and the length of the paths.  But the rest of the algorithm has not changed. <br><br>  The iteration of the cycle is different.  The cycle starts from the starting node, and then bypasses all unvisited neighboring nodes, and stores the total lengths and paths on these neighboring nodes. <br><br>  Note: I use <code>Integer.MAX_VALUE</code> as a signal value: "unreachable from the visited node".  The search is limited to only those nodes that have been achieved, since we are still going from beginning to end.  Any node that could not be reached, obviously, is not the next on the way. <br><br><pre> <code class="java hljs">classPathFinder { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Edge&gt; edges = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;String&gt;nodeNames = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Node endNode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; unvisited = initializeSearch(begin, end); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String node = begin; node != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; node = getNext(unvisited)) { unvisited.remove(node); visit(node); } setupEndNode(end); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;String&gt;initializeSearch(String begin, String end) { nodeNames.add(begin); nodeNames.add(end); List&lt;String&gt; unvisited = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(nodeNames); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String node : unvisited) nodes.put(node, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(Integer.MAX_VALUE)); nodes.get(begin).length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unvisited; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String node)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Edge&gt; neighbors = findEdges(node); Node curNode = nodes.get(node); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge e : neighbors) { Node nbr = nodes.get(e.end); nbr.length = curNode.length + e.length; nbr.path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); nbr.path.addAll(curNode.path); nbr.path.add(node); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupEndNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String end)</span></span></span><span class="hljs-function"> </span></span>{ endNode = nodes.get(end); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endNode.length != Integer.MAX_VALUE) endNode.path.add(end); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> endNode.length = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; unvisited)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : unvisited) { Node candidate = nodes.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.length != Integer.MAX_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Edge&gt;findEdges(String begin) { List&lt;Edge&gt; found = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge e : edges) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.begin.equals(begin)) found.add(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found; } publicintgetLength() { returnendNode.length; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;String&gt;getPath() { returnendNode.path; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEdge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String start, String end, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ edges.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Edge(start, end, length)); nodeNames.add(start); nodeNames.add(end); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Edge</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String begin; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String end; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Edge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String begin, String end, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.begin = begin; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.end = end; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length = length; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ publicint length; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;String&gt; path; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length = l; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); } } }</code> </pre> <br>  Passes by  Now we need to add a test in which there are parallel paths.  Here is a simple, clearly failed test: <br><br><pre> <code class="java hljs">assertMinPath (<span class="hljs-string"><span class="hljs-string">"A1B,B2Z,A1Z"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"[A, Z]"</span></span>);</code> </pre> <br>  Indeed, falls. <br><br>  To pass this test, it is necessary to determine when the two paths converge.  It's simple.  If the length to the target node is not <code>Integer.MAX_VALUE</code> , then this node is reached via a different path.  Since we are interested in the minimum, you can simply set the length value on this node as the minimum for converging paths.  It turns out that the <code>Integer.MAX_VALUE</code> value <code>Integer.MAX_VALUE</code> very convenient as a signal label, since it replaces the ‚Äúinfinite‚Äù length. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String node)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Edge&gt; neighbors = findEdges(node); Node curNode = nodes.get(node); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Edge e : neighbors) { Node nbr = nodes.get(e.end); intnewLength = curNode.length + e.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbr.length&gt;newLength) { nbr.length = newLength; nbr.path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); nbr.path.addAll(curNode.path); nbr.path.add(node); } } }</code> </pre> <br>  Perhaps, you can speed up the algorithm a bit if you stop the search immediately after the end node is visited. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String node = begin; node != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !node.equals(end); node = getNext(unvisited)) { unvisited.remove(node); visit(node); }</code> </pre> <br>  And in order to accelerate it even more, one can give priority to the search for unvisited nodes that can be reached via the shortest paths. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; unvisited)</span></span></span><span class="hljs-function"> </span></span>{ String minNodeName = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; intminLength = Integer.MAX_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : unvisited) { Node candidate = nodes.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidate.length&lt;minLength) { minLength = candidate.length; minNodeName = name; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> minNodeName; }</code> </pre> <br>  By all measures, this algorithm is a Dijkstra algorithm.  The implementation is not very fast, since I used lists and sets, as well as a bunch of inefficient structures.  To further overclock it, you will need to work hard.  Moreover, some assumptions are woven into the algorithm, which should be eliminated.  In particular, it is assumed that the input graph is directed, whereas in the universal algorithm such an assumption is not made.  In the end, all the code needs some refactoring. <br><br>  But I was keen to check whether TDD allows a step-by-step check of the Dijkstra algorithm.  I think so, but I must say that this approach turned out to be rather awkward.  Performing these first few tests, I had to resort to several hypothetical algorithms, between which there are no smooth transitions.  However, each subsequent test revealed flaws of the previous solution, which could be corrected without much difficulty. <br><br>  Will there be a higher-quality test sequence that will allow us to come to the Dijkstra algorithm in a not so roundabout way?  Perhaps, but if so, then I did not find it. <br><br>  In any case, it was interesting.  Thanks to the listener who suggested this task to me. <br>  Here is the ready code, which still needs to be brushed a little (dear reader, I leave this task to you as homework;)) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> dijkstrasAlg; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.junit.Test; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.regex.Matcher; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.regex.Pattern; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> org.junit.Assert.assertEquals; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MinPathTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String ANY = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertMinPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph, Integer length, String path)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = makePathFinder(graph); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) length, pf.getLength()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) assertEquals(path, pf.getPath().toString()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PathFinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePathFinder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String graph)</span></span></span><span class="hljs-function"> </span></span>{ PathFinder pf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathFinder(); Pattern edgePattern = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"(\\D+)(\\d+)(\\D+)"</span></span>); String[] edges = graph.split(<span class="hljs-string"><span class="hljs-string">","</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String edge : edges) { Matcher matcher = edgePattern.matcher(edge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (matcher.matches()) { String start = matcher.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = Integer.parseInt(matcher.group(<span class="hljs-number"><span class="hljs-number">2</span></span>)); String end = matcher.group(<span class="hljs-number"><span class="hljs-number">3</span></span>); pf.addEdge(start, end, length); } } pf.findPath(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pf; } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degenerateCases</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ assertMinPath(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"[]"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   assertMinPath("A", 0, "[]"); //   assertMinPath("B1C", 0, "[]");//     assertMinPath("A1C", 0, "[]");//   assertMinPath("B1Z", 0, "[]");//   } @Test public void oneEdge() throws Exception { assertMinPath("A1Z", 1, "[A, Z]"); assertMinPath("A2Z", 2, "[A, Z]"); } @Test public void twoEdges() throws Exception { assertMinPath("A1B,B1Z", 2, "[A, B, Z]"); assertMinPath("B1Z,A1B", 2, "[A, B, Z]"); assertMinPath("A1X,Y1Z", 0, "[]"); } @Test public void threeEdges() throws Exception { assertMinPath("A2B,B3C,C4Z", 9, "[A, B, C, Z]"); assertMinPath("B3C,C4Z,A2B", 9, "[A, B, C, Z]"); } @Test public void OnlyOnePath() throws Exception { assertMinPath("A1B,B2C,C3Z,B4D,D6E", 6, "[A, B, C, Z]"); assertMinPath("A1B,B2C,C3D,C3Z", 6, "[A, B, C, Z]"); } @Test public void parallelPaths() throws Exception { assertMinPath("A1B,B2Z,A1Z", 1, "[A, Z]"); assertMinPath("A1B,A1C,A2D,C5E,B8E,C1F,D3F,F2G,G3Z,E2G", 7,"[A, C, F, G, Z]"); } } class PathFinder { private List&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); private Set&lt;String&gt; nodeNames = new HashSet&lt;&gt;(); private Map&lt;String, Node&gt; nodes = new HashMap&lt;&gt;(); private Node endNode; public void findPath(String begin, String end) { List&lt;String&gt; unvisited = initializeSearch(begin, end); for (String node = begin; node != null &amp;&amp; !node.equals(end); node = getNext(unvisited)) { unvisited.remove(node); visit(node); } setupEndNode(end); } private List&lt;String&gt; initializeSearch(String begin, String end) { nodeNames.add(begin); nodeNames.add(end); List&lt;String&gt; unvisited = new ArrayList&lt;&gt;(nodeNames); for (String node : unvisited) nodes.put(node, new Node(Integer.MAX_VALUE)); nodes.get(begin).length = 0; return unvisited; } private void visit(String node) { List&lt;Edge&gt; neighbors = findEdges(node); Node curNode = nodes.get(node); for (Edge e : neighbors) { Node nbr = nodes.get(e.end); int newLength = curNode.length + e.length; if (nbr.length &gt; newLength) { nbr.length = newLength; nbr.path = new ArrayList&lt;String&gt;(); nbr.path.addAll(curNode.path); nbr.path.add(node); } } } private void setupEndNode(String end) { endNode = nodes.get(end); if (endNode.length != Integer.MAX_VALUE) endNode.path.add(end); else endNode.length = 0; } private String getNext(List&lt;String&gt; unvisited) { String minNodeName = null; int minLength = Integer.MAX_VALUE; for (String name : unvisited) { Node candidate = nodes.get(name); if (candidate.length &lt; minLength) { minLength = candidate.length; minNodeName = name; } } return minNodeName; } private List&lt;Edge&gt; findEdges(String begin) { List&lt;Edge&gt; found = new ArrayList&lt;&gt;(); for (Edge e : edges) { if (e.begin.equals(begin)) found.add(e); } return found; } public int getLength() { return endNode.length; } public List&lt;String&gt; getPath() { return endNode.path; } public void addEdge(String start, String end, int length) { edges.add(new Edge(start, end, length)); nodeNames.add(start); nodeNames.add(end); } private static class Edge { public final String begin; public final String end; public final int length; public Edge(String begin, String end, int length) { this.begin = begin; this.end = end; this.length = length; } } private static class Node { public int length; public List&lt;String&gt; path; public Node(int l) { this.length = l; this.path = new ArrayList&lt;&gt;(); } } }</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/319490/">https://habr.com/ru/post/319490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319478/index.html">No, being a game designer is no easier than a producer.</a></li>
<li><a href="../319480/index.html">Pure javascript. Functions</a></li>
<li><a href="../319482/index.html">ASP.NET Core: Creating Server Services for Mobile Applications</a></li>
<li><a href="../319484/index.html">DOCSIS 3.1 - How to achieve maximum throughput</a></li>
<li><a href="../319486/index.html">Subscription form: how to effectively collect the address database</a></li>
<li><a href="../319492/index.html">A simple and terrifying story about encryption</a></li>
<li><a href="../319496/index.html">100th edition of Digest MBLTdev - fresh for iOS developers</a></li>
<li><a href="../319498/index.html">IHS Markit study: 145 companies control 40% of the global data center market</a></li>
<li><a href="../319500/index.html">Redmine on MySQL with RocksDB is faster than with InnoDB, from 20% to 3 times</a></li>
<li><a href="../319502/index.html">Security Week 01-02: vulnerability in box.com, password phishing in PDF, attacks on MongoDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>