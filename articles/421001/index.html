<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RPC is a reason to try something new in C ++ 14/17</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A few years ago, C ++ developers got the long-awaited C ++ 11 standard, which brought a lot of new things. And I had an interest to move quickly to it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RPC is a reason to try something new in C ++ 14/17</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/r5/fg/-w/r5fg-wsld9ujbwxghq54s-kpaso.jpeg" width="250" height="180" align="left">  A few years ago, C ++ developers got the long-awaited C ++ 11 standard, which brought a lot of new things.  And I had an interest to move quickly to its use in everyday tasks.  Go to C ++ 14 and 17 was not like this.  It seemed that there is no feature set that would interest.  In the spring, I decided to look at the innovations of the language and try something.  To experiment with innovations, you had to invent a task for yourself.  I did not have to think long.  It was decided to write my own RPC with user data structures as parameters and without using macros and code generation - all in C ++.  This was possible thanks to the new features of the language. <br><br>  The idea, the implementation, feedback with Reddit, improvements - everything appeared in the spring, early summer.  By the end it was possible to add a post on Habr. <br><br>  Are you thinking about your own RPC?  Perhaps, the material of the post will help you to decide on the purpose, methods, means and decide for the benefit of the finished one or to realize something yourself ... <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  RPC (remote procedure call) is not a new topic.  There are many implementations in different programming languages.  Implementations use different data formats and modes of transport.  All this can be reflected in several points: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Serialization / deserialization </li><li>  Transport </li><li>  Run remote method </li><li>  Return result </li></ul><br>  Implementation is determined by the desired goal.  For example, you can set a goal to provide a high speed call to a remote method and sacrifice usability, or vice versa, to ensure maximum comfort in writing code, perhaps a little lost in performance.  The goals and tools are different ... I wanted comfort and acceptable performance. <br><br><h1>  Implementation </h1><br>  Below are a few steps of implementing RPC in C ++ 14/17, and emphasis has been placed on some of the language innovations that have caused this material to appear. <br><br>  The material is designed for those who for some reason are interested in their RPC, and, perhaps for now, need additional information.  In the comments it would be interesting to see a description of the experience of other developers who are faced with similar tasks. <br><br><h2>  Serialization </h2><br>  Before you start writing code, form the task: <br><br><ul><li>  All method parameters and the returned result are passed through a tuple. </li><li>  Called methods themselves are not required to accept and return tuples. </li><li>  The result of packing a tuple must be a buffer whose format is not fixed. </li></ul><br>  Below is the simplified string serializer code. <br><br><div class="spoiler">  <b class="spoiler_title">string_serializer</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer</span></span></code> </pre> </div></div><br>  And the main function code, which demonstrates the work of the serializer. <br><br><div class="spoiler">  <b class="spoiler_title">Main function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple args{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"Test string !!!"</span></span>}, <span class="hljs-number"><span class="hljs-number">3.14</span></span>}; rpc::packer::string_serializer serializer; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = serializer.save(args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Pack data: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{begin(pack), end(pack)} &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args) params; serializer.load(pack, params); <span class="hljs-comment"><span class="hljs-comment">// For test { auto pack = serializer.save(params); std::cout &lt;&lt; "Deserialized pack: " &lt;&lt; std::string{begin(pack), end(pack)} &lt;&lt; std::endl; } } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></code> </pre></div></div><br>  <b>Placement of promised accents</b> <br><br>  The first step is to determine the buffer with which all data exchange will be performed: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type</span></span></code> </pre><br>  The serializer has methods for saving a tuple to the buffer (save) and loading it from the buffer (load) <br><br>  The save method takes a tuple and returns a buffer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T ... &gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = to_string(tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (T)&gt;{}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {begin(str), end(str)}; }</code> </pre><br>  A tuple is a template with a variable number of parameters.  Such templates appeared in C ++ 11 and have proven themselves well.  Here you need to somehow go through all the elements of such a template.  There may be several options.  I will use one of the features of C ++ 14 - a sequence of integers (indices).  The standard library has the type make_index_sequence, which allows to get the following sequence: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ints</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integer_sequence</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_integer_sequence</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:integer_sequence&lt;T, <span class="hljs-comment"><span class="hljs-comment">/* a sequence 0, 1, 2, ..., N-1 */</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> make_index_sequence = make_integer_sequence&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, N&gt;;</code> </pre><br>  Similar can be implemented in C ++ 11, and then carried along from project to project. <br><br>  Such a sequence of indices makes it possible to ‚Äúpass‚Äù through a tuple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... I&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;I ... &gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> put_item = [&amp;stream] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i)&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;) stream &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::quoted(i) &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stream &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; }; (put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(stream.str()); }</code> </pre><br>  The to_string method uses several features of the latest C ++ standards. <br><br>  <b>Placement of promised accents</b> <br><br>  In C ++ 14, it became possible to use auto as parameters for lambda functions.  This was often lacking, for example, when working with standard library algorithms. <br><br>  In C ++ 17, <b>‚Äúconvolution‚Äù appeared</b> , which allows you to write code such as: <br><br><pre> <code class="cpp hljs">(put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... );</code> </pre><br>  In the given fragment, the lambda put_item function is called for each of the elements of the passed tuple.  At the same time, a sequence independent of the platform and the compiler is guaranteed.  Something similar could be written in C ++ 11. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ‚Ä¶ T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp; ‚Ä¶ )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// ... unused(put_item(std::get&lt;I&gt;(tuple)) ... );</span></span></code> </pre><br>  But in what order the elements would be stored would depend on the compiler. <br><br>  In the standard library C ++ 17, many aliases appeared, for example, decay_t, which reduced the entries like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> decay&lt;T&gt;::type</code> </pre><br>  The desire to write shorter constructions takes place.  The template construction, where in one line there is a couple of typename and template, separated by colons and angle brackets, looks scary.  What can scare some of their colleagues.  In the future they promise to reduce the number of places where you need to write a template, typename. <br><br>  The desire for conciseness gave another interesting construction of the language ‚Äúif constexpr‚Äù, allows you to avoid writing a lot of private specializations of templates. <br><br>  There is an interesting point.  Many have learned that switch and similar constructions are not very good in terms of code scalability.  It is preferable to use compile time / compile time polymorphism and overload with arguments in favor of the ‚Äúright choice‚Äù.  And then ‚Äúif constexpr‚Äù ... The possibility of compactness does not leave everyone indifferent to it.  The possibility of language does not mean the need to use it <br><br>  It was necessary to write a separate serialization for the string type.  For convenient work with strings, for example, std :: quoted. Has appeared in the stream while reading and reading from it.  It allows you to escape lines and allows saving to the stream and loading dates from it, without thinking about the delimiter. <br><br>  With a description of serialization, you can stop.  Deserialization (load) is implemented similarly. <br><br><h2>  Transport </h2><br>  Transportation is simple.  This is the function that receives and returns the buffer. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-comment"><span class="hljs-comment">// ... using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type</span></span></code> </pre><br>  Forming a similar ‚Äúexecutor‚Äù object using std :: bind, lambda functions, etc., you can use any of your transport implementations.  Details of the implementation of transport in this post will not be considered.  You can take a look at the completed RPC implementation, which will be referenced at the end. <br><br><h2>  Customer </h2><br>  Below is the client test code.  The client creates requests and sends them to the server based on the selected transport.  In the following test code, all client requests are displayed on the console.  And in the next step of the implementation, the client will communicate directly with the server. <br><br><div class="spoiler">  <b class="spoiler_title">Customer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TPacker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: client(type::executor executor) : executor_{executor} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-function">result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;func_name, TArgs &amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(func_name, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args) ... ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = packer_.save(request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> responce = executor_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {responce}; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = TPacker; packer_type packer_; type::executor executor_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: result(type::buffer buffer) : buffer_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(tuple)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: packer_type packer_; type::buffer buffer_; }; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc</span></span></code> </pre></div></div><br>  The client is implemented as a template class.  The template parameter is a serializer.  If necessary, the class can be converted into a non-template and the implementation of the serializer is passed to the constructor. <br><br>  In the current implementation, the class constructor accepts the executable object.  The executor hides the transport implementation underneath, and in this place of the code makes it possible not to think about the methods of data exchange between processes.  In the test case, the implementation of the transport displays requests to the console. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [] (rpc::type::buffer buffer) { <span class="hljs-comment"><span class="hljs-comment">// Print request data std::cout &lt;&lt; "Request pack: " &lt;&lt; std::string{begin(buffer), end(buffer)} &lt;&lt; std::endl; return buffer; };</span></span></code> </pre><br>  The user code is not trying to use the result of the client‚Äôs work yet, as it‚Äôs not from where to get it. <br><br>  <b>Client call method:</b> <br><br><ul><li>  using the serializer packs the name of the called method and its parameters </li><li>  using an executing object, sends a request to the server and accepts the response </li><li>  sends the received response to the class that retrieves the result </li></ul><br>  The basic client implementation is ready.  Something else remains.  More on that later. <br><br><h2>  Server </h2><br>  Before proceeding to the consideration of the details of the implementation of the server part, I propose a quick, diagonal look at the completed example of client-server interaction. <br><br>  For ease of demonstration all in one process.  Transport implementation is a lambda function that transfers a buffer between the client and the server. <br><br><div class="spoiler">  <b class="spoiler_title">Client-server interaction.</b>  <b class="spoiler_title">Test case</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; #include &lt;utility&gt; namespace rpc::type { using buffer = std::vector&lt;char&gt;; using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type namespace rpc::detail { template &lt;typename&gt; struct function_meta; template &lt;typename TRes, typename ... TArgs&gt; struct function_meta&lt;std::function&lt;TRes (TArgs ... )&gt;&gt; { using result_type = std::decay_t&lt;TRes&gt;; using args_type = std::tuple&lt;std::decay_t&lt;TArgs&gt; ... &gt;; using request_type = std::tuple&lt;std::string, std::decay_t&lt;TArgs&gt; ... &gt;; }; } // namespace rpc::detail namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer namespace rpc { template &lt;typename TPacker&gt; class client final { private: class result; public: client(type::executor executor) : executor_{executor} { } template &lt;typename ... TArgs&gt; result call(std::string const &amp;func_name, TArgs &amp;&amp; ... args) { auto request = std::make_tuple(func_name, std::forward&lt;TArgs&gt;(args) ... ); auto pack = packer_.save(request); auto responce = executor_(std::move(pack)); return {responce}; } private: using packer_type = TPacker; packer_type packer_; type::executor executor_; class result final { public: result(type::buffer buffer) : buffer_{std::move(buffer)} { } template &lt;typename T&gt; auto as() const { std::tuple&lt;std::decay_t&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); return std::move(std::get&lt;0&gt;(tuple)); } private: packer_type packer_; type::buffer buffer_; }; }; template &lt;typename TPacker&gt; class server final { public: template &lt;typename ... THandler&gt; server(std::pair&lt;char const *, THandler&gt; const &amp; ... handlers) { auto make_executor = [&amp;packer = packer_] (auto const &amp;handler) { auto executor = [&amp;packer, function = std::function{handler}] (type::buffer buffer) { using meta = detail::function_meta&lt;std::decay_t&lt;decltype(function)&gt;&gt;; typename meta::request_type request; packer.load(buffer, request); auto response = std::apply([&amp;function] (std::string const &amp;, auto &amp;&amp; ... args) { return function(std::forward&lt;decltype(args)&gt;(args) ... ); }, std::move(request) ); return packer.save(std::make_tuple(std::move(response))); }; return executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); } type::buffer execute(type::buffer buffer) { std::tuple&lt;std::string&gt; pack; packer_.load(buffer, pack); auto func_name = std::move(std::get&lt;0&gt;(pack)); auto const iter = handlers_.find(func_name); if (iter == end(handlers_)) throw std::runtime_error{"Function \"" + func_name + "\" not found."}; return iter-&gt;second(std::move(buffer)); } private: using packer_type = TPacker; packer_type packer_; using handlers_type = std::map&lt;std::string, type::executor&gt;; handlers_type handlers_; }; } // namespace rpc int main() { try { using packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ std::pair{"hello", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"hello\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return "Hello " + s + "!"; }}, std::pair{"to_int", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"to_int\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return std::stoi(s); }} }; auto executor = [&amp;server] (rpc::type::buffer buffer) { return server.execute(std::move(buffer)); }; rpc::client&lt;packer_type&gt; client{std::move(executor)}; std::cout &lt;&lt; client.call("hello", std::string{"world"}).as&lt;std::string&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; "Convert to int: " &lt;&lt; client.call("to_int", std::string{"100500"}).as&lt;int&gt;() &lt;&lt; std::endl; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre></div></div><br>  In the above implementation of the class, the most interesting thing about the server is its constructor and the execute method. <br><br>  <b>Constructor class server</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> make_executor = [&amp;packer = packer_] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;handler) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;packer, function = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function{handler}] (type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> meta = detail::function_meta&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(function)&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> meta::request_type request; packer.load(buffer, request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([&amp;function] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; ... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args)&gt;(args) ... ); }, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packer.save(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response))); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</code> </pre><br>  The class constructor is template.  At the entrance takes a list of pairs.  Each pair is a method name and a handler.  And since the constructor is a template with a variable number of parameters, when a server object is created, all the handlers available on the server are immediately registered.  This will make it possible not to make additional registration methods for handlers called on the server.  And in turn, it frees you from thinking about whether the object of the class server will be used in a multi-threaded environment and whether synchronization is necessary. <br><br>  <b>Fragment of the server class constructor</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</span></span></code> </pre><br>  Places a lot of passed handlers of different types in the map of functions of the same type.  For this, a convolution is also used, which makes it easy to put into std :: map the entire set of passed handlers in one line without cycles and algorithms. <br><br><pre> <code class="cpp hljs">(handlers_.emplace(handlers.first, make_executor(handlers.second)), ... );</code> </pre><br>  Lambda functions that allow the use of auto as parameters have made it possible to easily implement wraps of the same type over handlers.  Wrappers of the same type are registered in the methods available on the server (std :: map).  When processing requests, a search is performed on such a map, and a similar call to the found handler, regardless of the parameters received and the returned result.  The std :: apply function that appeared in the standard library calls the function passed to it with the parameters passed as a tuple.  The std :: apply function can also be implemented in C ++ 11.  Now it is available ‚Äúout of the box‚Äù and it is not necessary to transfer it from project to project. <br><br>  <b>Execute method</b> <br><br><pre> <code class="cpp hljs">type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type::buffer buffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; pack; packer_.load(buffer, pack); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func_name = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(pack)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = handlers_.find(func_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter == end(handlers_)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error{<span class="hljs-string"><span class="hljs-string">"Function \""</span></span> + func_name + <span class="hljs-string"><span class="hljs-string">"\" not found."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter-&gt;second(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }</code> </pre><br>  Retrieves the name of the function being called, searches the method in the map of the registered handlers, calls the handler and returns the result.  Everything is interesting in wrappers prepared in the constructor of the server class.  Someone may have noticed an exception, and perhaps the question arose: ‚ÄúAre exceptions somehow processed?‚Äù.  Yes, in full implementation, which will be given by reference at the end, marshalling of exceptions is provided.  Immediately to simplify the material, exceptions are not passed between the client and the server. <br><br>  Take another look at the function. <br><br><div class="spoiler">  <b class="spoiler_title">main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"hello\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + s + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"to_int\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi(s); }} }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;server] (rpc::type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.execute(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }; rpc::client&lt;packer_type&gt; client{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(executor)}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"world"</span></span>}).as&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Convert to int: "</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"100500"</span></span>}).as&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_FAILURE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; }</code> </pre></div></div><br>  It implements a full-fledged client-server interaction.  In order not to complicate the material, the client and server work in one process.  Replacing the implementation executor, you can use the desired transport. <br><br>  In the standard C ++ 17, it is sometimes possible not to specify template parameters when instantiating.  In the main function above, this is used when registering server handlers (std :: pair without template parameters) and makes the code easier. <br><br>  The basic RPC implementation is ready.  It remains to add the promised ability to pass custom data structures as parameters and returned results. <br><br><h2>  Custom data structures </h2><br>  To transfer data across the process boundary, they need to be serialized into something.  For example, everything can be output to the standard stream.  Much will be supported out of the box.  For user data structures, you will have to implement output operators yourself.  Each structure needs its own output operator.  Sometimes you want not to do it.  To iterate through all the fields of a structure and output each field to a stream, we need some generalized method.  This could well help reflexion.  It is not yet in C ++.  You can resort to code generation and use a mixture of macros and templates.  But the idea was to make the library interface in pure C ++. <br><br>  There is no complete reflection in C ++ yet.  Therefore, the solution below can be used with some limitations. <br><br>  The solution is based on the use of the new C ++ 17 ‚Äústructured bindings‚Äù feature.  Often in conversations you can find a lot of jargon, so I refused any options for naming this feature in Russian. <br><br>  Below is a solution that allows you to transfer the fields of the transferred data structure to a tuple. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_braces_constructible_v&lt;type, dummy_type, dummy_type, dummy_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2, f3] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2, f3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(); } }</code> </pre><br>  On the Internet, you can find many similar solutions. <br><br>  Much of what was used here was mentioned above, except for the structured bindings.  The to_tuple function accepts a user-defined type, determines the number of fields, and with the help of structured bindings ‚Äúshifts‚Äù the structure fields into a tuple.  And ‚Äúif constexpr‚Äù allows you to select the desired implementation branch.  Since there is no reflection in C ++, it is impossible to build a complete solution that takes into account all aspects of the type.  There are restrictions on the types used.  One of them is the type must be without custom constructors. <br><br>  The to_tuple uses is_braces_constructible_v.  This type allows you to determine the ability to initialize the passed structure using curly brackets and determine the number of fields. <br><br><div class="spoiler">  <b class="spoiler_title">is_braces_constructible_v</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T{</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TArgs&gt;() ... }), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::true_type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_braces_constructible_v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(is_braces_constructible&lt;T, TArgs ... &gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>))&gt;::value;</code> </pre></div></div><br>  The to_tuple function above can convert custom data structures containing up to three fields to tuples.  To increase the possible number of ‚Äúshifted‚Äù structure fields, you can either copy the ‚Äúif constexpr‚Äù branches with a small turn on of the mind, or resort to using the not so simple library boost.preprocessor.  If the second option is chosen, the code will become difficult to read and will provide an opportunity to use structures with a large number of fields. <br><br><div class="spoiler">  <b class="spoiler_title">Implementing to_tuple with boost.preprocessor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NANORPC_TO_TUPLE_LIMIT_FIELDS 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// you can try to use BOOST_PP_LIMIT_REPEAT #define NANORPC_TO_TUPLE_DUMMY_TYPE_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data #define NANORPC_TO_TUPLE_PARAM_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data ## n #define NANORPC_TO_TUPLE_ITEM_N(_, n, __) \ if constexpr (is_braces_constructible_v&lt;type, \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_DUMMY_TYPE_N, dummy_type) \ &gt;) { auto &amp;&amp;[ \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ] = value; return std::make_tuple( \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ); } else #define NANORPC_TO_TUPLE_ITEMS(n) \ BOOST_PP_REPEAT_FROM_TO(0, n, NANORPC_TO_TUPLE_ITEM_N, nil) NANORPC_TO_TUPLE_ITEMS(NANORPC_TO_TUPLE_LIMIT_FIELDS) { return std::make_tuple(); } #undef NANORPC_TO_TUPLE_ITEMS #undef NANORPC_TO_TUPLE_ITEM_N #undef NANORPC_TO_TUPLE_PARAM_N #undef NANORPC_TO_TUPLE_DUMMY_TYPE_N #undef NANORPC_TO_TUPLE_LIMIT_FIELDS }</span></span></span></span></code> </pre></div></div><br>  If you have ever tried to do something like boost.bind for C ++ 03, where you had to do a lot of implementations with a different number of parameters, then implementing to_tuple using boost.preprocessor does not seem strange or difficult. <br><br>  And if you add support for tuples to the serializer, then the function to_tuple will give the opportunity to serialize user data structures.  And it becomes possible to betray them as parameters and return results in your RPC. <br><br>  In addition to user data structures, C ++ has other built-in types for which output to the standard stream is not implemented.  The desire to reduce the number of overloaded output statements to a stream leads to generalized code, which allows one method to handle most of the C ++ containers such as std :: list, std :: vector, std :: map.  Not forgetting SFINAE and std :: enable_if_t, you can continue to expand the serializer.  In this case, it will be necessary to somehow indirectly determine the properties of types, just as is done in the implementation of is_braces_constructible_v. <br><br><h1>  Conclusion </h1><br>  Outside the post was marshaling the exception, transport, serialization of stl-containers and much more.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order not to complicate the post, only the general principles were presented, on which I managed to build my RPC library and solve the task originally posed for myself - try new C ++ 14/17 features. contains fairly detailed usage examples. </font><a href="https://github.com/tdv/nanorpc"><font style="vertical-align: inherit;">NanoRPC</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font></font><a href="https://github.com/tdv/nanorpc"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code on github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Thanks for attention! <br></div><p>Source: <a href="https://habr.com/ru/post/421001/">https://habr.com/ru/post/421001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420991/index.html">Pursuit race</a></li>
<li><a href="../420993/index.html">5 easy steps to create a server for testing android REST requests</a></li>
<li><a href="../420995/index.html">We select the password to the Indian TIN for two seconds, or why brute force math</a></li>
<li><a href="../420997/index.html">KDD 2018, fourth day, stands Nobel laureate</a></li>
<li><a href="../420999/index.html">Kivy. Xamarin. React Native. Three frameworks - one experiment (part 2)</a></li>
<li><a href="../421005/index.html">REST-assured: useful tips</a></li>
<li><a href="../421007/index.html">Tape recorder - a tool for recording autotests</a></li>
<li><a href="../421009/index.html">August 25 and 26: Online Operational Management Conference</a></li>
<li><a href="../421011/index.html">The interview questions you think are stupid. But really not</a></li>
<li><a href="../421015/index.html">Study of the sustainability of national segments of the Internet for 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>