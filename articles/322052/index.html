<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lambda calculus on javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In this article I want to once again look at the lambda calculus. The theoretical side of the question has already been discussed many times in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lambda calculus on javascript</h1><div class="post__text post__text-html js-mediator-article"> Hello!  In this article I want to once again look at the lambda calculus.  The theoretical side of the question has already been discussed many times in Habr√©, so let's take a look at how lambda calculus can look in practice, for example, in JavaScript (so that examples can be performed directly in the browser). <br><br>  So, the basic idea: everything is a function.  Therefore, we limit ourselves to a very narrow range of language possibilities: any expression will be either an anonymous function with one argument ( <code>x =&gt; expr</code> ), or a function call ( <code>f (x)</code> ).  That is, the whole code will look similar: <br><br><pre> <code class="javascript hljs">id = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x double = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; f (f (x))</code> </pre><br>  Since the result of the functions will be other functions, we will need a way to interpret the result.  This is the only place where the non-trivial JavaScript features come in handy. <br><a name="habracut"></a><br><h3>  Basic things </h3><br>  We begin, as is customary, with conditional branching.  We introduce two constants: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs">True = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function"> =&gt;</span></span> f =&gt; t False = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function"> =&gt;</span></span> f =&gt; f</code> </pre><br>  These are functions of ‚Äútwo arguments‚Äù, <code>True</code> returns the first argument, <code>False</code> returns the second argument.  That is, the following statements are true: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">1</span></span> == True (<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">2</span></span> == False (<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre><br>  These constants represent logical truth and false, and allow you to write an <code>If</code> function: <br><br><pre> <code class="javascript hljs">If = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function"> =&gt;</span></span> t =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> b (t) (f) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">1</span></span> == If (True) (<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">2</span></span> == If (False) (<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>))</code> </pre><br>  This already looks like a traditional <code>if</code> , just syntactically looks a little different.  With conditional branching, standard boolean operators can be easily implemented: <br><br><pre> <code class="javascript hljs">Not = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> If (x) (False) (True) And = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; If (x) (y) (False) Or = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; If (x) (True) (y)</code> </pre><br>  Next, we introduce the first "data structure" - a pair.  The definition is as follows: <br><br><pre> <code class="javascript hljs">Pair = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> f (x) (y)) Fst = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function"> =&gt;</span></span> p (True) Snd = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function"> =&gt;</span></span> p (False) p = Pair (<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">1</span></span> == Fst (p)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">2</span></span> == Snd (p))</code> </pre><br>  It looks a little weirder, but it makes sense.  A pair in this case is a function that encapsulates 2 values ‚Äã‚Äãinside itself and is able to transfer them to its parameter when it is called.  Similarly, a tuple of any length can be described: <br><br><pre> <code class="javascript hljs">Triplet = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> f (x) (y) (z)) Pentuplet = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function"> =&gt;</span></span> u =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> f (x) (y) (z) (u) (v))</code> </pre><br>  Generally speaking, with a similar arsenal, we could already define <code>Byte</code> as a tuple of 8 logical values, <code>Int</code> as a tuple of 4 <code>Byte</code> and implement machine arithmetic on them, but this is a routine matter and will not bring any pleasure.  There is a more beautiful way to describe natural numbers - <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D1%2591%25D1%2580%25D1%2587,_%25D0%2590%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25B7%25D0%25BE">Church</a> arithmetic. <br><br><h3>  Arithmetic </h3><br>  Church arithmetic describes a set of natural numbers with zero as functions of two arguments: <br><br><pre> <code class="javascript hljs">Zero = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; z One = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; s (z) Two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; s (s (z)) Three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; s (s (s (z)))</code> </pre><br>  The first argument is a function, the second argument is something to which the function is applied <code>n</code> times.  For their construction, in essence, only zero and the function <code>+1</code> are needed: <br><br><pre> <code class="javascript hljs">Succ = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; s (n (s) (z)))</code> </pre><br>  <code>Succ</code> throws another call <code>s</code> on the left of the existing call chain, thereby returning to us the next in order natural number.  If this function seems complicated, there is an alternative option.  The result of his work will be exactly the same, but the <code>s</code> sling here takes place on the right: <br><br><pre> <code class="javascript hljs">Succ = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; n (s) (s (z)))</code> </pre><br>  Here it is also worth describing the way to convert Church numbers in all of us familiar <code>int</code> is exactly the application of the function <code>x =&gt; x + 1</code> to zero <code>n</code> times: <br><br><pre> <code class="javascript hljs">toInt = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">0</span></span> == toInt (Zero)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">1</span></span> == toInt (One)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">2</span></span> == toInt (Two))</code> </pre><br>  The operations of addition, multiplication, etc are defined similarly: <br><br><pre> <code class="javascript hljs">Add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; m (Succ) (n) Mul = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; m (Add (n)) (Zero) Pow = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> p =&gt; p (Mul (n)) (One) <span class="hljs-comment"><span class="hljs-comment">//‚áà = n =&gt; m =&gt; m (Pow (n)) (One)</span></span></code> </pre><br>  In this way, you can continue to implement the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B5%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%259A%25D0%25BD%25D1%2583%25D1%2582%25D0%25B0">switch notation</a> , but there is no point in this: at this point, the principle of working with numbers should be clear. <br><br>  The next step is subtraction.  Following the tradition that has just appeared, its implementation will be like this: <br><br><pre> <code class="javascript hljs">Sub = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; m (Pred) (n)</code> </pre><br>  but the implementation of the Pred function remains a problem.  Fortunately, <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B8,_%25D0%25A1%25D1%2582%25D0%25B8%25D0%25B2%25D0%25B5%25D0%25BD_%25D0%259A%25D0%25BE%25D1%2583%25D0%25BB">Wedge</a> invented it for us. <br><br><pre> <code class="javascript hljs">Pred = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> Fst (n (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function"> =&gt;</span></span> Pair (Snd (p)) (Succ (Snd (p)))) (Pair (Zero) (Zero)))</code> </pre><br>  History says that this idea came to him during a dentist appointment, and anesthesia was then stronger than it is now.  I will not argue with that, but I will explain what is going on here.  To obtain the previous number, we construct the pair <code>(n-1, n)</code> as follows: apply the function <code>(x, y) -&gt; (y, y+1)</code> to the pair <code>(0, 0)</code> <code>n</code> times and extract the left component from the result.  As a consequence, it is easy to see that the number previous to zero will also be zero.  It saves from uncertainty and gives many other advantages. <br><br>  For completeness, here is the implementation of comparison operations: <br><br><pre> <code class="javascript hljs">IsZero = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> False) (True) Lte = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; IsZero (Sub (n) (m)) Lt = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; Lte (Succ (n)) (m) Eq = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; And (Lte (n) (m)) (Lte (m) (n)) Max = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; If (Lte (n) (m)) (m) (n) Min = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> m =&gt; If (Lte (n) (m)) (n) (m)</code> </pre><br><h3>  Lists </h3><br>  Lists are encoded in almost the same way as natural numbers - these are also functions of two arguments. <br><br><pre> <code class="javascript hljs">Nil = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; x L1 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; f (a0) (x) L2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; f (a0) (f (a1) (x)) L3 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; f (a0) (f (a1) (f (a2) (x))) <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre><br>  It is interesting to note that <code>False</code> , <code>Zero</code> and <code>Nil</code> are the same functions. <br><br>  If you are familiar with the functional operations on lists, then you probably already noticed that this structure describes the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%2591%25D1%2580%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">right convolution</a> .  Therefore, it is implemented trivially: <br><br><pre> <code class="javascript hljs">Foldr = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> z =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> l (f) (z)</code> </pre><br>  Now we implement standard operations for persistent lists ‚Äî adding to the beginning, getting the head and tail of the list. <br><br><pre> <code class="javascript hljs">Append = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> l =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; f (a) (l (f) (x))) Head = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> l (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> _ =&gt; a) () list = Append (<span class="hljs-number"><span class="hljs-number">1</span></span>) (Append (<span class="hljs-number"><span class="hljs-number">2</span></span>) (Nil)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">1</span></span> == Head (list))</code> </pre><br>  The empty brackets at the end of the description. <code>Head</code> is the head of an empty list.  In the correct program, this value should never be used, so I chose the syntactically smallest value.  Generally speaking, within these brackets you can write anything.  Later in the article there will be another place where I will use empty brackets for the exact same reason. <br><br>  The function of receiving the tail of the list almost completely repeats the function of obtaining the previous natural number.  For the same reason, the tail of an empty list will be an empty list. <br><br><pre> <code class="javascript hljs">Tail = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> Fst ( l (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> p =&gt; Pair (Snd (p)) (Append (a) (Snd (p)))) (Pair (Nil) (Nil)) ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">2</span></span> == Head (Tail (list)))</code> </pre><br>  As an example of use, I will give an implementation of the <code>map</code> function and some more others: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Map</span></span> = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> l =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> x =&gt; l (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> f (m (a))) (x)) Length = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> Foldr (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> Succ) (Zero) (l) IsEmpty = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> IsZero (Length (l)) <span class="hljs-comment"><span class="hljs-comment">//      JavaScript toList = l =&gt; Foldr (x =&gt; y =&gt; [x].concat(y)) ([]) (l) toIntList = l =&gt; toList (Map (toInt) (l)) function arraysEqual(a,b) { return !(a &lt; b) &amp;&amp; !(b &lt; a); } //   </span></span></code> </pre><br>  <code>Map</code> replaces each list item with the result of calling function <code>f</code> on it. <br>  <code>Length</code> and <code>IsEmpty</code> speak for themselves.  <code>toList</code> and <code>toIntList</code> will be useful for testing and for displaying lists in the console. <br><br><h3>  Recursion </h3><br>  By this time, working exclusively with functions has become suspiciously similar to ‚Äúnormal‚Äù programming.  It's time to spoil everything.  Since we have limited ourselves only to declare and call functions, we completely lack any syntactic sugar, which means that we will have to write down many simple things in a complex way. <br><br>  For example, I want to write the <code>OnNonEmpty : fun =&gt; list =&gt; result</code> function <code>OnNonEmpty : fun =&gt; list =&gt; result</code> , which will call the <code>fun</code> function on the <code>list</code> only if it is not empty.  Let's try: <br><br><pre> <code class="javascript hljs">OnNonEmpty = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> l =&gt; If (IsEmpty (l)) (Nil) (f (l))</code> </pre><br>  See a mistake?  If <code>f</code> does not stop on an empty list, then <code>OnNonEmpty</code> will not stop, although it should.  The fact is that JavaScript provides us with an <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25B8%25D1%258F_%25D0%25B2%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">applicative order of</a> calculations, that is, all the arguments of a function are evaluated before it is called, no laziness.  And the <code>If</code> statement should calculate only one branch, depending on the condition.  Therefore, the function must be rewritten, and it will not become more beautiful from it. <br><br><pre> <code class="javascript hljs">OnNonEmpty = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> l =&gt; (If (IsEmpty (l)) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> Nil) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> f (l))) ()</code> </pre><br>  Now <code>If</code> , depending on the condition, returns the function to be evaluated.  And only after that the calculation is made, only in this way can we guarantee laziness. <br><br>  The second problem is recursion.  Inside a function, we can refer only to its formal arguments.  This means that the function cannot refer to itself by name. <br><br>  But there is a solution, this is the notorious "Fixed Point Combinator."  Usually, after these words, the description of the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%25D0%25BD%25D0%25B5%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2582%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B8">combinator Y is given</a> , but it is not suitable for the applicative order.  Instead, we will use the combinator <code>Z</code> , shamelessly peeped in <a href="https://habrahabr.ru/post/218341/">this wonderful article</a> . <br><br><pre> <code class="javascript hljs">Z = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> f (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function"> =&gt;</span></span> x (x) (y))) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> f (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function"> =&gt;</span></span> x (x) (y)))</code> </pre><br>  A combinator is a function selected on the basis of exactly one property: <code>Z (f) == f (Z (f))</code> , that is, <code>Z(f)</code> is such a value of <code>x</code> that <code>x == f (x)</code> .  Hence the term "fixed point".  But one should not think that by some miracle the combinator is capable of solving equations, instead it represents an infinite recursive call <code>Z(f) = f (f (f (f ( ... ))))</code> . <br><br>  The ‚Äúmain property‚Äù of the combinator gives an excellent ‚Äúside effect‚Äù: the possibility of recursion.  For example, the entry: <br><br><pre> <code class="javascript hljs">MyFun = Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myFun</span></span></span><span class="hljs-function"> =&gt;</span></span> ...)</code> </pre><br>  is equivalent to writing: <br><br><pre> <code class="javascript hljs">MyFun = (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">myFun</span></span></span><span class="hljs-function"> =&gt;</span></span> ...) MyFun <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  which means that the first formal parameter of the anonymous function actually coincides with the <code>MyFun</code> function <code>MyFun</code> , and we can make real recursive calls in it.  Let's try on the example of finding the remainder of the division: <br><br><pre> <code class="javascript hljs">Rem = Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rem</span></span></span><span class="hljs-function"> =&gt;</span></span> n =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> ( If (Lt (n) (m)) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> n) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> rem (Sub (n) (m)) (m)) ) ()) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">1</span></span> == toInt (Rem (Three) (Two))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(<span class="hljs-number"><span class="hljs-number">0</span></span> == toInt (Rem (Three) (One)))</code> </pre><br>  After that, you can implement our first useful algorithm - <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2595%25D0%25B2%25D0%25BA%25D0%25BB%25D0%25B8%25D0%25B4%25D0%25B0">the Euclidean algorithm</a> .  It's funny, but it came out just as easy as finding the remainder of the division. <br><br><pre> <code class="javascript hljs">Gcd = Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gcd</span></span></span><span class="hljs-function"> =&gt;</span></span> n =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> ( If (IsZero (m)) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> n) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> gcd (m) (Rem (n) (m))) ) ())</code> </pre><br><h3>  Sequences </h3><br>  The last data structure I‚Äôm going to touch is ‚Äúendless lists,‚Äù or sequences.  Functional programming is famous for the opportunity to work with such objects, and I just can not get around them. <br><br>  The sequences are declared as follows: <br><br><pre> <code class="javascript hljs">Seq = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">head</span></span></span><span class="hljs-function"> =&gt;</span></span> tail =&gt; Pair (head) (tail) SeqHead = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">seq</span></span></span><span class="hljs-function"> =&gt;</span></span> Fst (seq) SeqTail = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">seq</span></span></span><span class="hljs-function"> =&gt;</span></span> (Snd (seq)) ()</code> </pre><br>  The tail of the sequence in the constructor is a function to calculate the new sequence, and not the finished result.  This approach provides the ability to generate a tail of infinite length. <br><br>  To be able to test, we will write a function for getting the first <code>n</code> elements: <br><br><pre> <code class="javascript hljs">SeqTake = Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">take</span></span></span><span class="hljs-function"> =&gt;</span></span> n =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">seq</span></span></span><span class="hljs-function"> =&gt;</span></span> ( If (IsZero (n)) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> Nil) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> Append (SeqHead (seq)) (take (Pred (n)) (SeqTail (seq)))) ) ())</code> </pre><br>  If you want to exercise, implement <code>SeqTake</code> without recursion.  It is possible, I guarantee. <br><br>  Now it is worth giving an example of some sequence.  Let it be natural numbers - you still have to work only with what has already been implemented: <br><br><pre> <code class="javascript hljs">Nat = (Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">natFrom</span></span></span><span class="hljs-function"> =&gt;</span></span> n =&gt; Seq (n) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> natFrom (Succ (n))))) (Zero) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.assert(arraysEqual([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], toIntList (SeqTake (Three) (Nat))))</code> </pre><br>  It uses the auxiliary function <code>natFrom (n)</code> , which returns a sequence of natural numbers starting with <code>n</code> .  <code>Nat</code> is just the result of <code>natFrom (Zero)</code> . <br><br>  There are very few, the last 2 functions, and they are the most cumbersome of those in this text.  The first is the sequence filtering function.  It finds in the transmitted sequence all elements that satisfy the transmitted predicate: <br><br><pre> <code class="javascript hljs">SeqFilter = Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function"> =&gt;</span></span> cond =&gt; <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">seq</span></span></span><span class="hljs-function"> =&gt;</span></span> ( If (cond (SeqHead (seq))) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> Seq (SeqHead (seq)) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> filter (cond) (SeqTail (seq)))) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> filter (cond) (SeqTail (seq))) ) ())</code> </pre><br>  In case the head element does not execute the predicate, the <code>SeqFilter</code> returns the filtered tail.  Otherwise, it will be a sequence of the current head and the same filtered tail. <br><br>  The second is a sequence of prime numbers.  Another version of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D1%2588%25D0%25B5%25D1%2582%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2581%25D1%2584%25D0%25B5%25D0%25BD%25D0%25B0">Sieve of Eratosthenes</a> in my performance: <br><br><pre> <code class="javascript hljs">Primes = (Z (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sieve</span></span></span><span class="hljs-function"> =&gt;</span></span> nums =&gt; Seq (SeqHead (nums)) (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> sieve (SeqFilter (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function"> =&gt;</span></span> Not (IsZero (Rem (p) (SeqHead (nums))))) (SeqTail (nums))) ))) (SeqTail (SeqTail (Nat)))</code> </pre><br>  This function can be called the culmination of the article.  The principle of its operation will be easier to understand in pseudocode: <br><br><pre> <code class="javascript hljs">sieve (nums) { p = head (nums) rest = tail (nums) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> append (p, sieve (filter (n -&gt; n % p != <span class="hljs-number"><span class="hljs-number">0</span></span>, rest))) } primes = sieve [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, ...]</code> </pre><br>  Here is the test: <br><br><pre> <code class="javascript hljs">Ten = Mul (Two) (Add (Two) (Three)) <span class="hljs-comment"><span class="hljs-comment">// s =&gt; z =&gt; s (s (s (s (s (s (s (s (s (s (z)))))))))) console.assert(arraysEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29], toIntList (SeqTake (Ten) (Primes))))</span></span></code> </pre><br>  I do not know about you, but it still surprises me that it is possible to write such things using only pure functions! <br><br><h3>  Conclusion </h3><br>  As a result, I got this strange introduction to LISP using the example of JavaScript.  Hopefully, I was able to show that abstract mathematical ideas are actually very close to the reality of programming.  And after such a look, the lambda calculus will no longer look too academic. <br><br>  And, of course, here is a <a href="">link to Github</a> with all the code from the article. <br><br>  Thank! </div><p>Source: <a href="https://habr.com/ru/post/322052/">https://habr.com/ru/post/322052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322040/index.html">Five things that mobile application developers need to know about cross-marketing</a></li>
<li><a href="../322042/index.html">Wiring diagrams in Autocad using .NET</a></li>
<li><a href="../322044/index.html">How IT professionals work. Boris Tikhomirov, Director of PROMT Mobile and Internet Projects</a></li>
<li><a href="../322046/index.html">Containers and safety: seccomp</a></li>
<li><a href="../322048/index.html">MOOC ‚ÄúProgramming and development of web applications‚Äù: announcement and interview with the author of the course of ITMO University</a></li>
<li><a href="../322054/index.html">Generators lie, or the battle of advertising and morality in the network</a></li>
<li><a href="../322056/index.html">As I wrote skad. Part Eight ...</a></li>
<li><a href="../322060/index.html">Azure Managed Disks Release</a></li>
<li><a href="../322062/index.html">Stress management in a burning tank</a></li>
<li><a href="../322064/index.html">We accept weather images with NOAA - easy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>