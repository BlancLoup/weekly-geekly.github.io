<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Declarative C ++ programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Friday, I had a free evening, such when there is no urgent business, and non-urgent to do laziness and want something for the soul. For the soul, I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Declarative C ++ programming</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ef3/519/7e2/ef35197e24db482dbb90df084b1ca883.png" align="left">  On Friday, I had a free evening, such when there is no urgent business, and non-urgent to do laziness and want something for the soul.  For the soul, I decided to see some report of <a href="https://github.com/CppCon/CppCon2015">CppCon 2015</a> which took place just over a month ago.  As a rule, I never have enough time for video reports live, but it all happened that way - a month went by, C ++ - 17 was already on the nose and the conference was supposed to be interesting, but no one had written anything about it, and then evening free. In general, I quickly poked my mouse at the first headline that attracted my attention: <a href="https://www.youtube.com/watch%3Fv%3DWjTrfoiB0MQ">Andrei Alexandrescu ‚ÄúDeclarative Control Flow"</a> and had a nice evening. Then I decided to share a free retelling with the community. <a name="habracut"></a><br>  Let's remember what is usual for C ++ Explicit Flow Control, write a transactionally stable function for copying a file, stable in the sense that it has only two outcomes: either it completes successfully or fails for some reason, but it has no side effects. (beautiful expression - successful failure).  The task looks trivial, especially if you use the boost :: filesystem: <pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> copy_file_tr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; to) { path tmp=to+<span class="hljs-string"><span class="hljs-string">".deleteme"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { copy_file(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, tmp); rename(tmp, to); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) { ::remove(tmp.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre>  Whatever happens during copying, the temporary file will be deleted, which is what we needed.  However, if you look at just three lines of meaningful code, all the rest is a check of the success of a function call via try / catch, that is, manual control of execution.  The program structure here does not reflect the real logic of the task.  Another unpleasant moment is that this code strongly depends on the obviously undescribed properties of the called functions, so the rename () function is assumed to be atomic (transactionally stable), and remove () should not throw exceptions (why here it is used :: remove () instead of boost: : filesystem :: remove ()). Let's make it even worse and write the move_file_tr pair function: <pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> move_file_tr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; to) { copy_file_tr(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { remove(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) { ::remove(to.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre>  We see all the same problems here, in such a tiny piece of code we had to add another try / catch block.  Moreover, even here you can already see how badly this code is scaled, each block enters its own scope, the intersection of blocks is impossible, etc.  If you are not convinced yet, the <a href="">standard recommends</a> minimizing the manual use of try / catch, for ‚Äúverbose and non-trivial uses error-prone.‚Äù Let's say directly and honestly that direct control of performance details does not suit us anymore, we want more . <br>  The declarative style instead focuses on the description of the goals, with detailed instructions for achieving them being kept to the necessary minimum, the code is executed in the right way without direct control over the execution of each step.  It might sound like a fantasy, but such languages ‚Äã‚Äãare around us and we use them every day without thinking.  Look - SQL, make, regex, they are all declarative in nature.  What can we use in C ++ to achieve this effect? <br>  RAII and destructors are declarative because they are called implicitly, as well as the close idiom ScopeGuard.  Let's see how the SCOPE_EXIT macro is organized using ScopeGuard, this is actually a rather old trick, suffice it to say that the macro of the same name is present in boost starting from version 1.38.  And yet, the repetition is the mother of learning: <pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopeGuardOnExit</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&lt;Fun&gt; ScopeGuard&lt;Fun&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+ (ScopeGuardOnExit, Fun&amp;&amp; fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ScopeGuard&lt;Fun&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Fun&gt;(fn)); } } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SCOPE_EXIT \ auto ANONIMOUS_VARIABLE(SCOPE_EXIT_STATE) \ = ::detail::ScopeGuardOnExit + (&amp;)[] }</span></span></code> </pre>  In fact, this is half the definition of a lambda function, the body must be added when calling. <br>  Here, everything is quite straightforward, an anonymous variable is created containing ScopeGuard, which contains a lambda function defined immediately after the macro call and which function will be called in the destructor of this variable, which sooner or later but when it goes out of scope will be called.  (The air ran out of the lungs, otherwise I would add a couple of additional ones) <br>  For completeness, the auxiliary macros look like this: <pre> <code class="hljs lisp">#define CONACTENATE_IMPL(<span class="hljs-name"><span class="hljs-name">s1</span></span>,s2) s1##s2 #define CONCATENATE(<span class="hljs-name"><span class="hljs-name">s1</span></span>,s2) CONCATENATE_IMPL(<span class="hljs-name"><span class="hljs-name">s1</span></span>,s2) #define ANONYMOUS_VARIABLE(<span class="hljs-name"><span class="hljs-name">str</span></span>) CONCATENATE(<span class="hljs-name"><span class="hljs-name">str</span></span>,__COUNTER__)</code> </pre>  With the use of such a construction, the usual C ++ code at once acquires the features unseen at once: <pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[] = <span class="hljs-string"><span class="hljs-string">"/tmp/deleteme.XXXXXX"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fd = mkstemp(name); SCOPE_EXIT { fclose(fd); unlink(name); }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buf = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>); SCOPE_EXIT { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buf); }; ... }</code> </pre>  So, it is argued that for a full transition to the declarative style, it is enough for us to define two more similar macros - SCOPE_FAIL and SCOPE_SUCCESS; using this triple, you can separate the logically significant code and detailed control instructions.  For this we need and it is enough to know whether the destructor is called, normally or as a result of unwinding the stack.  And such a function is in C ++ - <i>bool uncaught_exception ()</i> , it returns <i>true</i> if it was called from inside a catch block.  However, there is one unpleasant nuance - this function is broken in the current version of C ++ and does not always return the correct value.  The fact is that it does not distinguish whether the call to the destructor is part of unwinding the stack or whether it is a regular object on the stack created inside the catch block, you can read more about it from the <a href="https://isocpp.org/files/papers/N4152.pdf">original source</a> .  Anyway, in C ++ - 17 this function will be officially declared <i>deprecated</i> and another entered instead - <i>int uncaught_exceptions ()</i> (find the two differences yourself), which returns the number of nested handlers from which it was called.  We can now create a helper class that shows exactly, call SCOPE_SUCCESS or SCOPE_FAIL: <pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UncaughtExceptionCounter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUncaughtExceptionCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> exceptionCount_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UncaughtExceptionCounter() : exceptionCount_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uncaught_exceptions()) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newUncaughtException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uncaught_exceptions() &gt; exceptionCount_; } };</code> </pre>  It's funny that this class itself also uses RAII to capture the state in the constructor. <br>  Now you can draw a full-fledged template that will be called in case of success or failure: <pre> <code class="hljs rust">template &lt;typename FunctionType, <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> executeOnException&gt; class ScopeGuardForNewException { FunctionType function_; UncaughtExceptionCounter ec_; public: explicit ScopeGuardForNewException(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FunctionType&amp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_</span></span></span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">) {} </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeGuardForNewException</span></span></span></span>(FunctionType&amp;&amp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_</span></span></span></span>(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">)) {} ~</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScopeGuardForNewException</span></span></span></span>() noexcept(executeOnException) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (executeOnException == ec_.isNewUncaughtException()) { function_(); } } };</code> </pre>  Actually, all the interesting is concentrated in the destructor, it is there that the state of the exception counter is compared with the template parameter and the decision is made to call or not the internal functor.  Pay attention as the same template parameter delicately defines the destructor signature: <i>noexcept (executeOnException)</i> , since SCOPE_FAIL should be exception safe, and SCOPE_SUCCESS can completely exclude itself, finally, from harm.  In my opinion, it is precisely such minor architectural details that make C ++ the very language I like. <br>  Then everything becomes trivial, like SCOPE_EXIT we define a new macro: <pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopeGuardOnFail</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FunctionType&gt; ScopeGuardForNewException&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;FunctionType&gt;::type, <span class="hljs-literal"><span class="hljs-literal">true</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(detail::ScopeGuardOnFail, FunctionType&amp;&amp; fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ScopeGuardForNewException&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;FunctionType&gt;::type, <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;FunctionType&gt;(fn)); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SCOPE_FAIL \ auto ANONYMOUS_VARIABLE(SCOPE_FAIL_STATE) \ = ::detail::ScopeGuardOnFail() + [&amp;]() noexcept</span></span></code> </pre>  And similarly for SCOPE_EXIT <br>  Let's see how the source examples will now look: <pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> copy_file_tr(const <span class="hljs-type"><span class="hljs-type">path</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, const <span class="hljs-type"><span class="hljs-type">path</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) { bf::<span class="hljs-type"><span class="hljs-type">path</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.native() + ".deleteme"; SCOPE_FAIL { ::remove(t.c_str()); }; bf::copy_file(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, t); bf::<span class="hljs-keyword"><span class="hljs-keyword">rename</span></span>(t, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>); } <span class="hljs-type"><span class="hljs-type">void</span></span> move_file_tr(const <span class="hljs-type"><span class="hljs-type">path</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, const <span class="hljs-type"><span class="hljs-type">path</span></span>&amp; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) { bf::copy_file_transact(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>); SCOPE_FAIL { ::remove(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.c_str()); }; bf::remove(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>); }</code> </pre>  The code looks more transparent, moreover, each line means something.  Here is an example of using SCOPE_SUCCESS, along with a demonstration of why this macro can throw exceptions: <pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string2int</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; SCOPE_SUCCESS { assert(int2string(r) == s); }; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre>  Thus, a very small syntactic barrier prevents us from adding another declarative style to C ++. <h3>  Conclusion from the first person </h3>  All this leads to certain thoughts about what can wait for us in the near future.  First of all, it struck me that all the references in the report are far from new.  For example, SCOPE_EXIT is present in boost.1.38, that is, for almost ten years, and the article about Alexandrescu himself about ScopeGuard appeared in Dr.Dobbs already in the 2000th year.  I would like to remind you that Alexandrescu has a reputation as a visionary and prophet, so he created Loki as a demonstration of the concept of the library which formed the basis of boost :: mpl, and then almost completely entered the new standard and long before that actually set the idioms of metaprogramming.  On the other hand, Aleksandrescu himself has recently been mainly engaged in the development of the D language, where all three of the above constructions are <i>scope exit, scope success and scope failure</i> are part of the syntax of the language and have long occupied a strong place in it. <br>  Another interesting point is that the report of Eric Niebler at the same conference is called the <a href="https://github.com/CppCon/CppCon2015/tree/master/Keynotes/Ranges%2520for%2520the%2520Standard%2520Library">Ranges for the Standard Library</a> .  I want to remind that ranges are another standard concept of the D language, further development of the concept of iterators.  Moreover, the report itself is in fact a translation (from D to C ++) of the remarkable article HSTeoh <a href="http://wiki.dlang.org/Component_programming_with_ranges">Component programming with ranges</a> . <br>  Thus, it seems that C ++ began to actively include the concepts of other languages, which however he himself initiated.  In any case, the upcoming C ++ - 17 does not seem to be a routine update.  Considering the lessons of history, the seventeenth year is not boring, we stock up on popcorn, pineapples and grouse. <h3>  Literature </h3>  Here, the links already included in the post are simply collected in one place. <ol><li>  <a href="https://www.youtube.com/watch%3Fv%3DWjTrfoiB0MQ">Original audio report</a> </li><li>  <a href="https://github.com/CppCon/CppCon2015">Link to CppCon 2015 materials</a> </li><li>  <a href="https://github.com/CppCon/CppCon2015/blob/master/Presentations/Declarative%2520Control%2520Flow/Declarative%2520Control%2520Flow%2520-%2520Andrei%2520Alexandrescu%2520-%2520CppCon%25202015.pdf">Slides to the report Alexandrescu</a> </li><li>  <a href="http://www.drdobbs.com/cpp/generic-change-the-way-you-write-excepti/184403758%3Fpgno%3D2">Link to the original article about ScopeGuard 2000</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_38_0/libs/scope_exit/doc/html/index.html">Documentation on boost :: ScopeExit</a> </li><li>  <a href="https://isocpp.org/files/papers/N4152.pdf">Herb Sutter's suggestion for changing uncaught_exception ()</a> </li><li>  <a href="http://wiki.dlang.org/Component_programming_with_ranges">The original article on ranges in D</a> , who cares, is a good informal introduction to one of the aspects of this language. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/270545/">https://habr.com/ru/post/270545/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270529/index.html">As we wrote AI for the Jackal, and why he has schizophrenia</a></li>
<li><a href="../270531/index.html">About Parboiled (Part 2)</a></li>
<li><a href="../270537/index.html">How I became an android developer without a core education, simultaneously hindering concrete</a></li>
<li><a href="../270541/index.html">How to calculate the range of communication equipment Ubiquiti. New version of the calculator AirLink</a></li>
<li><a href="../270543/index.html">TensorFlow: Google's machine learning, now smarter for everyone</a></li>
<li><a href="../270547/index.html">Hidden dependencies as a design ‚Äúsmell‚Äù</a></li>
<li><a href="../270549/index.html">How we moved the disk space of hundreds of bank branches to a single storage system in Moscow without losing LAN speeds in the field</a></li>
<li><a href="../270551/index.html">Use VTune Amplifier 2016 to analyze the HelloOpenCL application for GPU</a></li>
<li><a href="../270555/index.html">Veeam Cloud Connect in Microsoft Azure</a></li>
<li><a href="../270557/index.html">What is useful you can extract from the report on the clouds in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>