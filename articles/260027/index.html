<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Passing Stored Arguments to a Function</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An acquaintance of mine threw an interesting puzzle to me: you need to call a function through a pointer and pass previously saved arguments to it. A ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Passing Stored Arguments to a Function</h1><div class="post__text post__text-html js-mediator-article">  An acquaintance of mine threw an interesting puzzle to me: you need to call a function through a pointer and pass previously saved arguments to it.  A prerequisite was not to use std :: function.  I want to share with you my solution to this problem.  Do not judge strictly given implementation.  She does not in any way claim to be complete and comprehensive.  I wanted to make everything as simple as possible, minimal, but sufficient.  In addition, there will be two solutions.  One of them, in my opinion, is better than the other. <br><a name="habracut"></a><br>  The first solution is based on the fact that C ++ already provides us with a mechanism for capturing variables.  It's about lambdas.  Naturally, the most obvious and simple would be to use such a wonderful mechanism.  For those who are not familiar with C ++ 14 and higher, I will provide the appropriate code: <br><br><pre><code class="hljs markdown">auto Variable = 1; auto Lambda = [<span class="hljs-string"><span class="hljs-string">Variable</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) { someFunction(Variable); };</code> </pre> <br>  This code creates a lambda function that captures a variable named Variable.  The object itself of the lambda function is copied into a variable named Lambda.  It is through this variable that in the future it will be possible to call the lambda function itself.  And such a call will look like a normal function call: <br><br><pre> <code class="hljs lisp">Lambda()<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  It would seem that the task has already been solved, but in reality it is not.  A lambda function can be returned from a function, method or other lambda, but then it is difficult to transfer it somewhere without using templates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs markdown">auto makeLambda(int Variable) { return [<span class="hljs-string"><span class="hljs-string">Variable</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) { someFunction(Variable); }; } auto Lambda = makeLambda(3); //     ,   ? someOtherFunction(Lambda);</code> </pre><br>  Lambda functions are objects of some anonymous type, they have an internal structure known only to the compiler.  And pure C ++ (I mean a language without libraries) provides the programmer with not so many lambda operations: <br><br><ul><li>  lambda can be called; </li><li>  A lambda can be cast to a function pointer if this lambda does not capture variables; </li><li>  lambda can be copied. </li></ul><br><br>  In principle, these basic operations are quite enough, because using them and other mechanisms of the language can be done very, very much.  That's what I got in the end. <br><br><pre> <code class="hljs rust">#include &lt;utility&gt; #include &lt;cstdint&gt; #include &lt;vector&gt; template &lt;typename Function&gt; class SignalTraits; template &lt;typename R, typename... A&gt; class SignalTraits&lt;R(A...)&gt; { public: using <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> = R; }; template &lt;typename Function&gt; class Signal { public: using <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> = typename SignalTraits&lt;Function&gt;::<span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>; template &lt;typename Callable&gt; Signal(Callable <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>) : Storage(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>)) { new (Storage.data()) Callable(std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>)); Trampoline = [](Signal *S) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> { auto CB = static_cast&lt;Callable *&gt;(static_cast&lt;void *&gt;(S-&gt;Storage.data())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*CB)(); }; } <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> invoke() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Trampoline(this); } private: <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span> (*Trampoline)(Signal *<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>); std::vector&lt;std::uint8_t&gt; Storage; };</code> </pre><br>  In this example: thanks to the template constructor, the lambda created inside this constructor will have information about the type of Callable, which means it can bring the data in the Storage to the desired type.  In fact, that‚Äôs the whole trick.  All the hard work of capturing variables and calling functions and lambdas is on the compiler‚Äôs shoulders.  In my opinion, such a solution is extremely simple and elegant. <br><br>  As for the second solution, I like it less, because  there is a lot of self-written code in it that essentially solves what has already been decided for us by the compiler.  Namely: capture variables.  I will not go into long discussions and discussions, but I will give the code of the entire solution right away.  Since  it is very big and it does not impaniate me, then I will hide it under the cat: <br><br><div class="spoiler">  <b class="spoiler_title">not a beautiful code.</b> <div class="spoiler_text"><pre> <code class="hljs xml">#include <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cstdarg</span></span></span><span class="hljs-tag">&gt;</span></span> #include <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cstdint</span></span></span><span class="hljs-tag">&gt;</span></span> #include <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vector</span></span></span><span class="hljs-tag">&gt;</span></span> template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">&gt;</span></span> struct PromotedTraits { using Type = T; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> struct PromotedTraits<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">char</span></span></span><span class="hljs-tag">&gt;</span></span> { using Type = int; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> struct PromotedTraits<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">unsigned</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">char</span></span></span><span class="hljs-tag">&gt;</span></span> { using Type = unsigned; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> struct PromotedTraits<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">short</span></span></span><span class="hljs-tag">&gt;</span></span> { using Type = int; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> struct PromotedTraits<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">unsigned</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">short</span></span></span><span class="hljs-tag">&gt;</span></span> { using Type = unsigned; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> struct PromotedTraits<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">float</span></span></span><span class="hljs-tag">&gt;</span></span> { using Type = double; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments</span></span></span><span class="hljs-tag">&gt;</span></span> class StorageHelper; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments</span></span></span><span class="hljs-tag">&gt;</span></span> class StorageHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span> { public: static void store(va_list &amp;List, std::vector<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std::uint8_t</span></span></span><span class="hljs-tag">&gt;</span></span> &amp;Storage) { using Type = typename PromotedTraits<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>::Type; union { T Value; std::uint8_t Bytes[sizeof(void *)]; }; Value = va_arg(List, Type); for (auto B : Bytes) { Storage.push_back(B); } StorageHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::store(List, Storage); } }; template <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> class StorageHelper<span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span> { public: static void store(...) {} }; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bool,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span><span class="hljs-tag">&gt;</span></span> class InvokeHelper; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments</span></span></span><span class="hljs-tag">&gt;</span></span> class InvokeHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">true,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span> { public: template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Result</span></span></span><span class="hljs-tag">&gt;</span></span> static Result invoke(Result (*Fn)(Arguments...), Arguments... Args) { return Fn(Args...); } }; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments</span></span></span><span class="hljs-tag">&gt;</span></span> class InvokeHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">false,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span> { public: template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Result</span></span></span><span class="hljs-tag">&gt;</span></span> static Result invoke(...) { return {}; } }; struct Dummy; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std::size_t</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Index</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Types</span></span></span><span class="hljs-tag">&gt;</span></span> class TypeAt { public: using Type = Dummy *; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std::size_t</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Index</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Types</span></span></span><span class="hljs-tag">&gt;</span></span> class TypeAt<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Index,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Types...</span></span></span><span class="hljs-tag">&gt;</span></span> { public: using Type = typename TypeAt<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(Index</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1u</span></span></span><span class="hljs-tag">), </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Types...</span></span></span><span class="hljs-tag">&gt;</span></span>::Type; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Types</span></span></span><span class="hljs-tag">&gt;</span></span> class TypeAt<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">0u,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Types...</span></span></span><span class="hljs-tag">&gt;</span></span> { public: using Type = T; }; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Function</span></span></span><span class="hljs-tag">&gt;</span></span> class Signal; template <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">typename</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Result</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">typename...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments</span></span></span><span class="hljs-tag">&gt;</span></span> class Signal<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Result(Arguments...)</span></span></span><span class="hljs-tag">&gt;</span></span> { public: using CFunction = Result(Arguments...); Signal(CFunction *Delegate, Arguments... Values) : Delegate(Delegate) { initialize(Delegate, Values...); } Result invoke() { std::uintptr_t *Args = reinterpret_cast<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std::uintptr_t</span></span></span><span class="hljs-tag"> *&gt;</span></span>(Storage.data()); Result R = {}; using T0 = typename TypeAt<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">0u,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::Type; using T1 = typename TypeAt<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">0u,</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::Type; // ... and so on. switch (sizeof...(Arguments)) { case 0u: return InvokeHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(0u</span></span></span><span class="hljs-tag"> == </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">sizeof...(Arguments)),</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::template invoke<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Result</span></span></span><span class="hljs-tag">&gt;</span></span>(Delegate); case 1u: return InvokeHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(1u</span></span></span><span class="hljs-tag"> == </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">sizeof...(Arguments)),</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::template invoke<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Result</span></span></span><span class="hljs-tag">&gt;</span></span>(Delegate, (T0 &amp;)Args[0]); case 2u: return InvokeHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(2u</span></span></span><span class="hljs-tag"> == </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">sizeof...(Arguments)),</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::template invoke<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Result</span></span></span><span class="hljs-tag">&gt;</span></span>(Delegate, (T0 &amp;)Args[0], (T1 &amp;)Args[1]); // ... and so on. } return R; } private: void initialize(CFunction *Delegate, ...) { va_list List; va_start(List, Delegate); StorageHelper<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Arguments...</span></span></span><span class="hljs-tag">&gt;</span></span>::store(List, Storage); va_end(List); } CFunction *Delegate; std::vector<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">std::uint8_t</span></span></span><span class="hljs-tag">&gt;</span></span> Storage; };</code> </pre></div></div><br>  Here all the interestingness, in my opinion, lies in two auxiliary classes: StorageHelper and InvokeHelper.  The first combines ellipse and recursive passage through the type list in order to fill the argument store.  The second provides a type-safe way to extract arguments from this repository.  In addition, there is another small trick: the ellipse will promote one type to another.  Those.  the float passed through ... will be cast to double, char to int, short to int, etc. <br><br>  I want to summarize all of the above.  In my opinion, both solutions are not perfect: they do not know how much and are trying to invent a wheel.  If I were asked how to properly capture the arguments and pass them into a certain function, I would not hesitate to say that you need to use std :: function + lambda.  Although as an exercise for the mind, the task set is very good. <br><br>  I hope that everything you read will be useful.  Thank you for reading this far! </div><p>Source: <a href="https://habr.com/ru/post/260027/">https://habr.com/ru/post/260027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260017/index.html">Automated xkcd-style diagram creation: from serious to funny</a></li>
<li><a href="../260019/index.html">Mobile App Distribution Services for iOS. Part 4 (final): Fabric (Crashlytics)</a></li>
<li><a href="../260021/index.html">How to check your sites for getting into the Blacklist or why the newsletter gets into spam</a></li>
<li><a href="../260023/index.html">Application Migration - Code Examples</a></li>
<li><a href="../260025/index.html">Fun starts or C ++ and STL: who is faster?</a></li>
<li><a href="../260029/index.html">Detector of UI locks in WPF with notification</a></li>
<li><a href="../260031/index.html">Windows and Mac OS Integration with Acronis Access Connect</a></li>
<li><a href="../260033/index.html">Is it true that Go is faster than Ruby?</a></li>
<li><a href="../260045/index.html">Material Design and Search by the example of a reference application</a></li>
<li><a href="../260047/index.html">Interesting notes on C # and CLR (v2.0)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>