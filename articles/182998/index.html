<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Spatial hashing for the smallest</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spatial hashing is a simple technique that is used in databases, physical and graphic engines, particle simulations and, in general, everywhere where ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Spatial hashing for the smallest</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/82e/bcc/eb3/82ebcceb3c6c5b34749292078fbf09ad.png"><br><br>  Spatial hashing is a simple technique that is used in databases, physical and graphic engines, particle simulations and, in general, everywhere where you need to quickly find something.  If in short, the point is that we divide the space with objects into cells and add objects into them.  Then, instead of searching by value, we very quickly search by hash. <br><br>  Suppose you have several objects and you need to know if there are any collisions between them.  The simplest solution is to calculate the distance from each object to all other objects.  However, with this approach, the number of required calculations grows too fast.  If you have to do hundreds of checks on a dozen of objects, then already tens of thousands of checks go on a hundred of objects.  This is the infamous quadratic complexity of the algorithm. <br><a name="habracut"></a><br>  <b>Hereinafter, pseudocode is used, suspiciously very similar to C #, but this is only an illusion.</b>  <b>This code is given at the end of the article.</b> <br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    foreach (var obj in objects) { if (Distance(this.position, obj.position) &lt; t) { //    } }</span></span></code> </pre> <br>  You can improve the situation by dividing the space with a grid.  Then each object will fall into some grid cell and it will be quite easy to find the neighboring cells to check their fullness.  For example, we can be sure that two objects do not collide if at least one cell separates them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="http://habrastorage.org/storage2/891/e85/690/891e85690723002b43949590efdc96f9.png"><br><br>  The grid is already good, but there is a problem with updating the grid.  Permanent sifting of coordinates into cells can work well in two dimensions, but in three it is already starting to slow down.  We can step further and reduce the multidimensional search space to one-dimensional by using hashing.  Hashing will allow us to fill cells faster and search them.  How does this work? <br><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Hashing</a> is the process of converting a large amount of data to a fixed one, with a slight difference in the original data resulting in a big difference in the fixed one.  In essence, this is lossy compression.  We can assign each cell its own identifier, and when we compress the coordinates of the objects, drawing an analogy with the pictures, lower their resolution, we automatically obtain the coordinates of the desired cell.  Having filled all the cells in this way, we can then easily reach objects in the vicinity of any coordinates.  We simply hash the coordinates and get the ID of the cell with the objects. <br><br>  What might a hash function look like for a two-dimensional fixed-size grid?  For example as follows: <br><br><pre> <code class="cs hljs">hashId = (Math.Floor(position.x / ellSize)) + (Math.Floor(position.y / ellSize)) * width;</code> </pre><br>  We divide the x coordinate by the cell size and cut off the fractional part, then do the same with the coordinate of the game and multiply it by the width of the grid.  It turns out one-dimensional array as in the picture below. <br><br><img src="http://habrastorage.org/storage2/8fc/89e/9a1/8fc89e9a11f2ef5fbc013c004b2303ce.png"><br><br>  In fact, we have the same grid as before, but the search is faster due to simplified computations.  True, they are simplified due to the appearance of collisions, when the hash of the coordinates of a very distant object can coincide with the hash of the coordinates of the close one.  Therefore, it is important to choose a hash function with a good distribution and an acceptable collision rate.  Read more in Wikipedia.  I'd better show you how to implement a three-dimensional spatial hash in practice. <br><br>  <i><b>I will add a little about hashes</b></i> <br>  <i>What is faster to calculate 2 * 3.14 or 2 * 3.1415926535897932384626433832795028841971 ...?</i>  <i>Of course the first.</i>  <i>We will get a less accurate result, but who cares?</i>  <i>Similarly with hashes.</i>  <i>We simplify the calculations, lose accuracy, but with high probability we still get the result that suits us.</i>  <i>This hash chip and the source of their power.</i> <br><br>  Let's start with the most important thing - hash functions for three-dimensional coordinates.  In a very rich <a href="http.developer.nvidia.com/GPUGems3/gpugems3_ch32.html">article on the site Nvidia</a> offer the following option: <br><br><pre> <code class="cs hljs">GLuint hash = ((GLuint)(pos.x / CELLSIZE) &lt;&lt; XSHIFT) | ((GLuint)(pos.y / CELLSIZE) &lt;&lt; YSHIFT) | ((GLuint)(pos.z / CELLSIZE) &lt;&lt; ZSHIFT);</code> </pre><br>  We take the coordinate along each axis, divide by the cell size, apply the bitwise shift, and OR'im the results between each other.  The authors of the article do not specify what value the shift should be, moreover, bit math is not quite ‚Äúfor the smallest‚Äù.  There is a little simpler function described in <a href="http://www.beosil.com/download/CollisionDetectionHashing_VMV03.pdf">this publication</a> .  If you translate it into code, you get something like this: <br><br><pre> <code class="cs hljs">hash = (Floor(pos.x / cellSize) * <span class="hljs-number"><span class="hljs-number">73856093</span></span>) ^ (Floor(pos.y / cellSize) * <span class="hljs-number"><span class="hljs-number">19349663</span></span>) ^ (Floor(pos.z / cellSize) * <span class="hljs-number"><span class="hljs-number">83492791</span></span>);</code> </pre><br>  Find the coordinates of the cell on each axis, multiply by a large prime number and XOR'im.  To be honest, it is not much easier, but at least without any unknown changes. <br><br>  To work with a spatial hash, it is convenient to have two containers: one for storing objects in cells, the other for storing numbers of object cells.  The main containers are the fastest working hash tables, they are dictionaries, they are also hashmaps or as they are called in your favorite language.  In one of them, we obtain a stored object by the key-hash, in the other, by the object-key, the cell number.  Together, these two containers allow you to quickly find neighbors and check the fullness of the cells. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;T&gt;&gt; dict; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; objects;</code> </pre><br>  What does working with these containers look like?  We insert objects using two parameters: the coordinates and the object itself. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vector, T obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = Key(vector); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.ContainsKey(key)) { dict[key].Add(obj); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dict[key] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt; { obj }; } objects[obj] = key; }</code> </pre><br>  Hash the coordinates, check the presence of the key in the dictionary, push the object by the key and the key by the object.  When we need to update the coordinates, we delete the object from the old cell and insert it into the new one. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vector, T obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objects.ContainsKey(obj)) { dict[objects[obj]].Remove(obj); } Insert(vector, obj); }</code> </pre><br>  If too many objects are updated at once, it is easier to clear all dictionaries and refill each time. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keys = dict.Keys.ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; keys.Length; i++) dict[keys[i]].Clear(); objects.Clear(); }</code> </pre><br><br>  That's it, the full class code is presented below.  It uses <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html">Vector3</a> from the Unity engine, but the code can easily be adapted for XNA or another framework.  The hash function uses some kind of ‚Äúfast rounding‚Äù, I cannot vouch for its work. <br><br><div class="spoiler">  <b class="spoiler_title">SpatialHash.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SpatialHash</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;T&gt;&gt; dict; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; objects; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpatialHash</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cellSize = cellSize; dict = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;T&gt;&gt;(); objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Insert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vector, T obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = Key(vector); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.ContainsKey(key)) { dict[key].Add(obj); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dict[key] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt; { obj }; } objects[obj] = key; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vector, T obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (objects.ContainsKey(obj)) { dict[objects[obj]].Remove(obj); } Insert(vector, obj); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryPosition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vector</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = Key(vector); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dict.ContainsKey(key) ? dict[key] : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsKey</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vector</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dict.ContainsKey(Key(vector)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keys = dict.Keys.ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; keys.Length; i++) dict[keys[i]].Clear(); objects.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { dict.Clear(); objects.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BIG_ENOUGH_INT = <span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> BIG_ENOUGH_FLOOR = BIG_ENOUGH_INT + <span class="hljs-number"><span class="hljs-number">0.0000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FastFloor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(f + BIG_ENOUGH_FLOOR) - BIG_ENOUGH_INT; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Key</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((FastFloor(vx / cellSize) * <span class="hljs-number"><span class="hljs-number">73856093</span></span>) ^ (FastFloor(vy / cellSize) * <span class="hljs-number"><span class="hljs-number">19349663</span></span>) ^ (FastFloor(vz / cellSize) * <span class="hljs-number"><span class="hljs-number">83492791</span></span>)); } }</code> </pre><br></div></div><br>  In the interactive demonstration <a href="http://basmanovdaniil.github.io/SpatialHash/">of this link</a> you can see how the hash space is distributed.  The coordinates of the yellow ball are hashed by a timer, after which it moves to a random point inside the sphere.  Yellow cubes denote coordinates that fall into the same cell.  The keys that have already been created are marked in blue so that you can look at the process of filling the memory.  Mouse can be rotated. <br><br>  <a href="https://github.com/BasmanovDaniil/SpatialHash">Sources on GitHub</a> |  <a href="http://basmanovdaniil.github.io/SpatialHash/">Online version for owners of Unity Web Player</a> <br><br><h4>  Interesting related links </h4><br>  <a href="http://www.cs.ucf.edu/~jmesit/publications/scsc%25202005.pdf">http://www.cs.ucf.edu/~jmesit/publications/scsc%202005.pdf</a> <br>  <a href="http://www.beosil.com/download/CollisionDetectionHashing_VMV03.pdf">http://www.beosil.com/download/CollisionDetectionHashing_VMV03.pdf</a> <br>  <a href="http.developer.nvidia.com/GPUGems3/gpugems3_ch32.html">http://http.developer.nvidia.com/GPUGems3/gpugems3_ch32.html</a> </div><p>Source: <a href="https://habr.com/ru/post/182998/">https://habr.com/ru/post/182998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182988/index.html">Netherlands intelligence had access to PRISM data and implemented agents in IT companies</a></li>
<li><a href="../182990/index.html">Belarus is no longer a white spot on HERE maps</a></li>
<li><a href="../182992/index.html">Metric # 10 - Podcast on technologies and design of interfaces and services</a></li>
<li><a href="../182994/index.html">Cyber ‚Äã‚ÄãSecurity. Weekly Review May 27 - June 2, 2013</a></li>
<li><a href="../182996/index.html">And again about video surveillance</a></li>
<li><a href="../183004/index.html">XQuery enhancements in MarkLogic Server</a></li>
<li><a href="../183006/index.html">Electricity Lessons - Transmission Lines</a></li>
<li><a href="../183008/index.html">Deferred objects in AngularJS</a></li>
<li><a href="../183010/index.html">PHPUnit: a simple syntax for creating mock objects</a></li>
<li><a href="../183012/index.html">Windows Server 2012 - life without GUI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>