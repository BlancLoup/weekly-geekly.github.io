<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ruby building blocks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Showing off Ruby's cool features to the uninitiated ( or to the language sparring partner ), an excited rubyist often grabs the ‚Äúpowerful block syntax...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ruby building blocks</h1><div class="post__text post__text-html js-mediator-article">  Showing off Ruby's cool features to the uninitiated ( <a href="http://stackoverflow.com/questions/1099305/why-is-ruby-more-suitable-for-rails-than-python/1099367">or to the language sparring partner</a> ), an excited rubyist often grabs the ‚Äúpowerful block syntax‚Äù in Ruby.  Unfortunately, for the Pythonist or Javist, the possibilities of the notorious ‚Äúpowerful block syntax‚Äù remain unclear because of the lack of corresponding mechanisms in their languages. <br><br>  To begin with, <a href="http://news.ycombinator.com/item%3Fid%3D1097901">we usually refer to Rake, RSpec, or Sinatra</a> as examples of the amazing use of block syntax: <br><a name="habracut"></a><br><blockquote><code><a href="http://s-c.me/5809/s"></a> <a href="http://s-c.me/5809/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt;get <font color="#008000">"/hello"</font> <font color="#0000ff">do</font> &lt;br/&gt; <font color="#008000">"Hello World"</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote>  (see <a href="http://www.sinatrarb.com/intro.html">www.sinatrarb.com/intro.html</a> - <i>approx.</i> <a href="http://www.sinatrarb.com/intro.html">transl</a> <i>.</i> ) <br><br>  Pythonists usually indicate equivalent syntax <a href="http://news.ycombinator.com/item%3Fid%3D1097928">in response</a> : <br><blockquote> <code><a href="http://s-c.me/5810/s"></a> <a href="http://s-c.me/5810/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt;@get( <font color="#008000">'/hi'</font> )&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">hello</font> ():&lt;br/&gt; <font color="#0000ff">return</font> <font color="#008000">"Hello World"</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">hello</font> () -&gt; <font color="#008000">"/hi"</font> :&lt;br/&gt; <font color="#0000ff">return</font> <font color="#008000">"Hello World"</font> &lt;br/&gt;</font></code> </blockquote> <br>  Although the Python version may be inferior in beauty to the Ruby version, but saying ‚ÄúRuby has more features‚Äù is quite difficult.  Rubists on the contrary level the argument of great semantic power, reducing it to external beauty when using this example from Sinatra. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Rubists, pythonists and other developers working in the field of web development, use a common language JavaScript.  Describing blocks to "external" people who own <a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Functions_and_function_scope">JavaScript</a> 'om, we as an example try to bring its functions.  Unfortunately, this only reinforces misunderstanding. <br><br>  A similar situation is observed by Ruby, when <a href="http://php.net/manual/en/functions.anonymous.php">PHP</a> or <a href="http://www.javac.info/consensus-closures-jsr.html">Java</a> declares ‚Äúadding closures‚Äù, many of us continue to ask ‚Äúwhat type of closures?‚Äù <br><br><h4>  Let's get to the point </h4><br>  Let's get to the point and show you the best example of the usefulness of Ruby blocks. <br><blockquote> <code><a href="http://s-c.me/5808/s"></a> <a href="http://s-c.me/5808/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">append</font> (location, data)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"a"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return</font> data&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  Method <code><a href="http://ruby-doc.org/core/classes/IO.html"></a> File.open</code>  <code><a href="http://ruby-doc.org/core/classes/IO.html"></a> File.open</code> takes a block as a parameter.  It opens a new file (in the ‚Äúappend‚Äù mode) and transfers the open file to the block.  When he finishes, Ruby closes the file.  In addition, Ruby does not just close the file, it <b>guarantees</b> that the File will be closed, even if block execution ends with an exception.  Let's look at <a href="">the File implementation in Rubinius</a> : <br><blockquote> <code><a href="http://s-c.me/5812/s"></a> <a href="http://s-c.me/5812/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def self</font> . <font color="#0000ff">open</font> (*args)&lt;br/&gt;  io = new *args&lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return</font> io <font color="#0000ff">unless</font> block_given?&lt;br/&gt; &lt;br/&gt; <font color="#0000ff">begin</font> &lt;br/&gt; <font color="#0000ff">yield</font> io&lt;br/&gt; <font color="#0000ff">ensure</font> &lt;br/&gt; <font color="#0000ff">begin</font> &lt;br/&gt;      io.close <font color="#0000ff">unless</font> io.closed?&lt;br/&gt; <font color="#0000ff">rescue</font> <font color="#cc6633">StandardError</font> &lt;br/&gt; <font color="#696969"># nothing, just swallow them.</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  This means that you can wrap the ubiquitous idioms like try / catch / finally inside methods. <br><blockquote> <code><a href="http://s-c.me/5813/s"></a> <a href="http://s-c.me/5813/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#696969">#  </font> &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">append</font> (location, data)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt; <font color="#0000ff">begin</font> &lt;br/&gt;    file = <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"a"</font> )&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">ensure</font> &lt;br/&gt;    file.close&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return</font> data&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  Because Ruby calls <code>ensure</code> even when an exception occurs inside a block, the programmer can be sure that Ruby will execute the terminating logic hidden inside the method. <br>  This example demonstrates the good quality of the implementation of lambda functions.  However, blocks in Ruby turn into something completely different due to one little additional feature. <br><blockquote> <code><a href="http://s-c.me/5814/s"></a> <a href="http://s-c.me/5814/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (location, data)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"w"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt; <font color="#0000ff">return false if</font> Digest::MD5.hexdigest(file.read) == data.hash&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  Imagine that writing data to a disk requires quite a lot of resources, and you can skip writing if the MD5 hash of the file content matches the value of the hash function of the data object.  We will return false if the method did not write to the disk and true otherwise. <br><br>  Ruby blocks support non-local-return ( <a href="http://docs.selflanguage.org/langref.html">multiple</a> <a href="http://gafter.blogspot.com/2006/08/tennents-correspondence-principle-and.html">links</a> ), which means that return from within a block behaves identically to return from the original block context.  In this case, a return from inside the block returns from the <code>write</code> method, but Ruby still calls <code>ensure</code> to close the file. <br><br>  You can think of non-local-return as something like this: <br><blockquote> <code><a href="http://s-c.me/5815/s"></a> <a href="http://s-c.me/5815/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (location, data)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"w"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt; <font color="#0000ff">raise</font> Return. <b>new</b> ( <font color="#0000ff">false</font> ) <font color="#0000ff">if</font> Digest::MD5.hexdigest(file.read) == data.hash&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">rescue</font> Return =&gt; e&lt;br/&gt; <font color="#0000ff">return</font> e.object&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote>  where Return is <code>Return = Struct.new(:object)</code> . <br><br>  Of course, this should be supported by any reasonable implementation of lambda functions, but the Ruby version has the advantage that returning from inside the block looks the same as returning from the usual method, and at the same time it requires much less ‚Äúbrilliance‚Äù to achieve the effect.  This feature also helps in cases where <code>rescue</code> or <code>ensure</code> already being used, avoiding puzzling combinations. <br><br>  Ruby supports calling <code>super</code> inside a block.  Imagine that the <code>write</code> method was overridden in a subclass, and the same parent class method simply takes the raw data from the file and writes it to the log. <br><blockquote> <code><a href="http://s-c.me/5816/s"></a> <a href="http://s-c.me/5816/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (location, data)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"w"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt;    file_data = file.read&lt;br/&gt; <font color="#0000ff">super</font> (location, file_data)&lt;br/&gt; <font color="#0000ff">return false if</font> Digest::MD5.hexdigest(file_data) == data.hash&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  In a pure lambda function script, we would need to store a reference to self, so that we can use it inside the lambda later: <br><blockquote> <code><a href="http://s-c.me/5817/s"></a> <a href="http://s-c.me/5817/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (location, data)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt;  this = <font color="#0000ff">self</font> &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"w"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt;    file_data = file.read&lt;br/&gt; &lt;br/&gt; <font color="#696969">#   Ruby  </font> &lt;br/&gt; <font color="#696969"># non-local-super</font> &lt;br/&gt;    this. <font color="#0000ff">super</font> . <font color="#cc6633">write</font> (location, file_data)&lt;br/&gt; <font color="#0000ff">raise</font> Return. <b>new</b> ( <font color="#0000ff">false</font> ) <font color="#0000ff">if</font> Digest::MD5.hexdigest(file_data) == data.hash&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">rescue</font> Return =&gt; e&lt;br/&gt; <font color="#0000ff">return</font> e.object&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  In Ruby, you can also call <code>yield</code> on a block obtained by a method inside another block.  Imagine that the <code>write</code> method is invoked with a block that chooses which data to use depending on whether the file is executable: <br><blockquote> <code><a href="http://s-c.me/5818/s"></a> <a href="http://s-c.me/5818/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (location)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"w"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt;    file_data = file.read&lt;br/&gt; <font color="#0000ff">super</font> (location)&lt;br/&gt;    data = <font color="#0000ff">yield</font> file&lt;br/&gt; <font color="#0000ff">return false if</font> Digest::MD5.hexdigest(file_data) == data.hash&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  This can be called via: <br><blockquote> <code><a href="http://s-c.me/5819/s"></a> <a href="http://s-c.me/5819/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt;write( <font color="#008000">"/path/to/file"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt; <font color="#0000ff">if</font> file.executable?&lt;br/&gt; <font color="#008000">"#!/usr/bin/env ruby\nputs 'Hello World!'"</font> &lt;br/&gt; <font color="#0000ff">else</font> &lt;br/&gt; <font color="#008000">"Hello World!"</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  In a pure lambda language, we would take a block as a normal function argument and call it inside a closure: <br><blockquote> <code><a href="http://s-c.me/5820/s"></a> <a href="http://s-c.me/5820/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (location, block)&lt;br/&gt;  path = <font color="#cc6633">Pathname</font> . <b>new</b> (location)&lt;br/&gt; <font color="#0000ff">raise</font> <font color="#008000">"Location does not exist"</font> <font color="#0000ff">unless</font> path.exist?&lt;br/&gt; &lt;br/&gt;  this = <font color="#0000ff">self</font> &lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, <font color="#008000">"w"</font> ) <font color="#0000ff">do</font> |file|&lt;br/&gt;    file_data = file.read&lt;br/&gt; &lt;br/&gt; <font color="#696969">#   Ruby,  </font> &lt;br/&gt; <font color="#696969"># non-local-super</font> &lt;br/&gt;    this. <font color="#0000ff">super</font> . <font color="#cc6633">write</font> (location, file_data)&lt;br/&gt;    data = block. <b>call</b> (file)&lt;br/&gt; <font color="#0000ff">raise</font> Return. <b>new</b> ( <font color="#0000ff">false</font> ) <font color="#0000ff">if</font> Digest::MD5.hexdigest(file_data) == data.hash&lt;br/&gt;    file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">rescue</font> Return =&gt; e&lt;br/&gt; <font color="#0000ff">return</font> e.object&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  The real advantage of the Ruby approach is that the code inside the block would be identical if the method did not accept the block.  Consider the same method, taking File instead of location: <br><blockquote> <code><a href="http://s-c.me/5822/s"></a> <a href="http://s-c.me/5822/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">write</font> (file)&lt;br/&gt;  file_data = file.read&lt;br/&gt; <font color="#0000ff">super</font> (file)&lt;br/&gt;  data = <font color="#0000ff">yield</font> file&lt;br/&gt; <font color="#0000ff">return false if</font> Digest::MD5.hexdigest(file_data) == data.hash&lt;br/&gt;  file. <font color="#0000ff">puts</font> <font color="#cc6633">YAML</font> .dump(data)&lt;br/&gt; <font color="#0000ff">return true</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  Without a block, Ruby code looks exactly the same.  This means that Ruby programmers can more easily transfer repeating code to methods that take blocks without rewriting a large amount of code.  It also means that using a block does not interrupt normal logic, and you can create new ‚Äúcontrol logic‚Äù constructs that behave almost identically to built-in logic constructions such as if and while. <br><br>  Rails makes good use of this in <a href="http://api.rubyonrails.org/classes/ActionController/MimeResponds/InstanceMethods.html">respond_to</a> , offering a convenient syntax for content negotiation: <br><blockquote> <code><a href="http://s-c.me/5823/s"></a> <a href="http://s-c.me/5823/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">index</font> &lt;br/&gt;  @people = Person.find(:all)&lt;br/&gt; &lt;br/&gt;  respond_to <font color="#0000ff">do</font> | <font color="#0000ff">format</font> |&lt;br/&gt; <font color="#0000ff">format</font> .html <font color="#696969"># default action is render</font> &lt;br/&gt; <font color="#0000ff">format</font> .xml { render :xml =&gt; @people.xml }&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  Due to the way blocks work in Ruby, you can also return from any of the format blocks: <br><blockquote> <code><a href="http://s-c.me/5825/s"></a> <a href="http://s-c.me/5825/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">index</font> &lt;br/&gt;  @people = Person.find(:all)&lt;br/&gt; &lt;br/&gt;  respond_to <font color="#0000ff">do</font> | <font color="#0000ff">format</font> |&lt;br/&gt; <font color="#0000ff">format</font> .html { <b>redirect_to</b> (person_path(@people.first)) <font color="#0000ff">and return</font> }&lt;br/&gt; <font color="#0000ff">format</font> .xml { render :xml =&gt; @people.xml }&lt;br/&gt; <font color="#0000ff">format</font> .json { render :json =&gt; @people.json }&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt;  session[:web_service] = <font color="#0000ff">true</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  We returned from HTML format after the redirect, which allowed us to perform an additional action (set: web_service in session) for other cases (XML and JSON MIME types). <br><br>  Above, we have demonstrated several features of blocks in Ruby.  <code>return</code> , <code>yield</code> and <code>super</code> together can be seen extremely rarely.  Ruby programmers typically use one or more of these constructs inside blocks, simply because their use seems natural. <br><br><h4>  So why are blocks in ruby ‚Äã‚Äãbetter? </h4><br>  If you‚Äôve gotten this far, let's look at another use of blocks in Ruby: synchronization of mutexes. <br><br>  <a href="http://java.sun.com/docs/books/tutorial/essential/concurrency/locksync.html">Java supports synchronization</a> through a special <code>synchronized</code> : <br><blockquote> <code><a href="http://s-c.me/5826/s"></a> <a href="http://s-c.me/5826/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">class</font> Example {&lt;br/&gt;  final Lock <font color="#0000ff">lock</font> = <font color="#0000ff">new</font> Lock();&lt;br/&gt; &lt;br/&gt; <font color="#0000ff">void</font> example() {&lt;br/&gt;    synchronized( <font color="#0000ff">lock</font> ) {&lt;br/&gt; <font color="#008000">//   </font> &lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;} &lt;br/&gt;</font></code> </blockquote> <br>  In essence, Java provides a special construct to implement the idea that a certain piece of code should be executed only once for a given instance of a synchronization object.  Since Java offers a special construct, you can return synchronization code from within and runtime Java will perform the appropriate processing. <br><br>  Similarly, Python required the use of <code>try/finally</code> prior to Python version 2.5, when <a href="http://www.python.org/dev/peps/pep-0343/">a special language function was added</a> to handle the <code>try/finally</code> idiom: <br><blockquote> <code><a href="http://s-c.me/5827/s"></a> <a href="http://s-c.me/5827/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">class</font> <font color="#cc6633">Example</font> :&lt;br/&gt; <font color="#696969">#  </font> &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">example</font> (self):&lt;br/&gt;    lock.acquire()&lt;br/&gt; <font color="#0000ff">try</font> :&lt;br/&gt;      ... access shared resource&lt;br/&gt; <font color="#0000ff">finally</font> :&lt;br/&gt;      lock.release() <font color="#696969"># ,   </font> &lt;br/&gt; &lt;br/&gt; <font color="#696969">#  </font> &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">example</font> (self):&lt;br/&gt; <font color="#0000ff">with</font> lock:&lt;br/&gt;      ... access shared resource &lt;br/&gt;</font></code> </blockquote> <br>  In case 2.5, the object passed to <code>with</code> must implement a special protocol (including the <code>__enter__</code> and <code>__exit__</code> methods), so the <code>with</code> expression cannot be used as general purpose and lightweight Ruby blocks. <br>  Ruby <a href="http://ruby-doc.org/core/classes/Mutex.html">represents the same concept of</a> using a block-accepting method: <br><blockquote> <code><a href="http://s-c.me/5828/s"></a> <a href="http://s-c.me/5828/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">class</font> <font color="#cc6633">Example</font> &lt;br/&gt;  @@lock = <font color="#cc6633">Mutex</font> .new&lt;br/&gt; &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">example</font> &lt;br/&gt;    @@lock.synchronize <font color="#0000ff">do</font> &lt;br/&gt; <font color="#696969">#   </font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  It is important to note that <code>synchronize</code> is a normal Ruby method.  The original version, written in pure Ruby, <a href="http://ruby-doc.org/core/classes/Mutex.src/M000916.html">looks like this</a> : <br><blockquote> <code><a href="http://s-c.me/5829/s"></a> <a href="http://s-c.me/5829/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">synchronize</font> &lt;br/&gt;  lock&lt;br/&gt; <font color="#0000ff">begin</font> &lt;br/&gt; <font color="#0000ff">yield</font> &lt;br/&gt; <font color="#0000ff">ensure</font> &lt;br/&gt;    unlock&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br>  There are all signs that we had discussed above.  It locks the object, calls the block and then makes sure that the lock is released.  This means that if the Ruby programmer returns the result from within the block, <code>synchronize</code> will work correctly. <br><br>  This example demonstrates the key power of Ruby blocks: they can easily replace language constructs.  That is, a Ruby programmer can take unsafe code, paste it into a sync block, and the code will then work safely. <br><br><h5>  Postscript </h5><br><br>  Historically, I wrote my posts without a large number of links, primarily fearing their obsolescence.  I receive more and more requests for annotations in my posts, so I will start doing this.  Let me know if you think that my annotations in this post were useful and freely offer what you find useful in this area. <br><br><h4>  Some helpful comments after the article. </h4><br><br>  <i>James Edward Gray II</i> : <br>  When using the pathname, you can translate: <br><br><blockquote> <code><a href="http://s-c.me/5830/s"></a> <a href="http://s-c.me/5830/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#cc6633">File</font> . <font color="#0000ff">open</font> (path, ‚Äúa‚Äù) <font color="#0000ff">do</font> |file|&lt;br/&gt; <font color="#696969"># ‚Ä¶</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote>  at: <br><blockquote> <code><a href="http://s-c.me/5831/s"></a> <a href="http://s-c.me/5831/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt;path. <font color="#0000ff">open</font> (‚Äúa‚Äù) <font color="#0000ff">do</font> |file|&lt;br/&gt; <font color="#696969"># ‚Ä¶</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt;</font></code> </blockquote> <br><br>  <i>Colin Curtin</i> : <br>  Something to keep in mind about non-local-return: a block must have access to the context from which you want to return. <br><br><blockquote> <code><a href="http://s-c.me/5832/s"></a> <a href="http://s-c.me/5832/h"></a> <font color="black">Copy Source | Copy HTML&lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">a</font> &lt;br/&gt; <font color="#0000ff">yield</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#cc6633">a</font> { <font color="#0000ff">return</font> <font color="#008000">0</font> } <font color="#696969"># =&gt; LocalJumpError: unexpected return</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">c</font> &lt;br/&gt; <font color="#0000ff">yield</font> &lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">b</font> &lt;br/&gt; <font color="#cc6633">c</font> { <font color="#0000ff">return</font> <font color="#008000">1</font> }&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#cc6633">b</font> <font color="#696969"># =&gt; 1</font> &lt;br/&gt; &lt;br/&gt; <font color="#0000ff">def</font> <font color="#cc6633">d</font> &lt;br/&gt; <font color="#0000ff">lambda</font> { <font color="#0000ff">return</font> <font color="#008000">2</font> }.call&lt;br/&gt; <font color="#0000ff">end</font> &lt;br/&gt; <font color="#cc6633">d</font> <font color="#696969"># =&gt; 2</font> &lt;br/&gt;</font></code> </blockquote> <br><br>  <i>ecin</i> : <br>  Remember that different ways of creating closures (Proc.new, proc, lambda) are not always equivalent to each other: <br><br>  <a href="">innig.net/software/ruby/closures-in-ruby.rb</a> <br><br>  ... <br><br>  <i>Rit Li</i> : <br>  I love ruby ‚Äã‚Äãblocks.  Thank you for the article. <br><br>  Regarding ‚ÄúRails vs Django‚Äù, there are three things that Rails wins: <br><br>  1) Convention over Configuration. <br>  Django has no large configuration files, only one settings.py file.  So Django is a framework with ‚ÄúEasy Configuration,‚Äù not ‚ÄúConvention over Configuration.‚Äù <br><br>  2) REST <br>  Rails really covers REST.  Seven action controller is great.  Django does not have an integrated resource / route mechanism for REST.  Once you start REST, you will not go back. <br><br>  3) Eco system in Rails <br>  Rails plugins are there for everything.  Plus, there is commercial support, books, blogs, screencasts and hosting for Rails.  Django really lacks this. <br><br><h5>  Translator postscript </h5><br>  PS I can post it only to my blog, because I don‚Äôt have enough specialized karma, but I hope it will be useful and I will move it, for example, to Ruby :) <br>  PPS If necessary - add timestamps for comments and comments about python (I don't know him very well) <br>  PPPS Please do not scold me for the content of the article - scold only for the translation :) </div><p>Source: <a href="https://habr.com/ru/post/86882/">https://habr.com/ru/post/86882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../86872/index.html">Hide unused labels at an ATM?</a></li>
<li><a href="../86875/index.html">"Three Bananas" or notes on the go in Android</a></li>
<li><a href="../86876/index.html">Automatic planting stoton iron or who do you work with?</a></li>
<li><a href="../86877/index.html">T9 do it yourself</a></li>
<li><a href="../86880/index.html">Who is smarter is right? Hacker's Notes Part 1 of 5</a></li>
<li><a href="../86887/index.html">Who is smarter is right? Hacker's Notes Part 2 of 5</a></li>
<li><a href="../86890/index.html">HDD Watch "Strobe"</a></li>
<li><a href="../86891/index.html">The fourth attempt to conquer the iPhone or four of my applications</a></li>
<li><a href="../86892/index.html">Skype Outside celebrated March 8</a></li>
<li><a href="../86897/index.html">Free business analysis for regional startups (at #StartupPoint meetings)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>