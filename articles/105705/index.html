<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic programming method for counting the number of cycles on a rectangular lattice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is addressed to those readers who are engaged in programming algorithms, and is particularly interested in intractable problems. Those ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic programming method for counting the number of cycles on a rectangular lattice</h1><div class="post__text post__text-html js-mediator-article">  This article is addressed to those readers who are engaged in programming algorithms, and is particularly interested in intractable problems.  Those habrulyam who oppose the placement of algorithms on Habr√© should immediately stop reading this work. <br><br>  In the article I will show how to use the dynamic profile programming method for solving the problem of counting the number of Hamiltonian cycles on a rectangular grid of size m by n.  On Habr√© there are several articles on the topic of dynamic programming (for example, <a href="http://habrahabr.ru/blogs/personal/22514/">this one</a> ), but nowhere is this a more complex application of the method.  This approach can also be called the transfer matrix method, as you like. <br><br>  I warn you that the article contains about 2000 words (8 A4 pages), but the road will be by walking. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Summary </h4><br><br><ol><li>  A bit about intractable tasks </li><li>  Definitions and problem statement </li><li>  Cuts and State Machine </li><li>  Matrix transfer method </li><li>  Solution without a matrix </li><li>  Algorithm complexity </li><li>  Modular arithmetic </li><li>  Discussions and results </li><li>  List of used sources </li></ol><br><br><h4>  1. A bit about intractable tasks </h4><br><br>  What is intractable problem?  This is a task that does not have an effective solution algorithm.  Moreover, this is not necessarily a problem with an exponential complexity of the solution, the complexity can be polynomial, but with a sufficiently large degree of polynomial (for example, the problem of k queens, which I already wrote about <a href="http://habrahabr.ru/blogs/personal/91988/">here</a> ).  You can learn more about such tasks and their classification in the classic book by M. Gary, D. Johnson ‚ÄúComputing Machines and Intractable Problems‚Äù. <br><br>  Such problems are usually solved by brute force, dynamic programming and combinatorial analysis methods.  Often, an acceptable solution is obtained by using these three components at the same time, but this also requires the experience of writing a sufficiently optimal code.  It‚Äôs very good if you have a cluster of at least several thousand cores and at least a couple of hundred gigabytes of RAM.  Unfortunately, I'm not kidding, many tasks can be solved only on such a machine ... <br><br>  I like to solve intractable problems and I even organize contests for programmers-mathematicians on this topic from time to time.  This article is partially confined to the ‚Äú <a href="http://zealint.ru/prehamilton-cycles-lattice-comp.html">Pre-Hamilton cycles</a> ‚Äù competition, which began on October 1 and ends on October 31, 2010. The problem proposed in the conditions of the competition is solved by me using the same method (with minor changes), which will be described here. <br><br>  In the section with the conclusion of the complexity of the algorithm, it is assumed that the reader knows the elements of combinatorics (what is the number of combinations, for example), and in the section about the finite state machine the reader will be forced to recall elements of graph theory (for example, what is the adjacency matrix of the graph, and what does power). <br><br><br><h4>  2. Definitions and problem statement </h4><br><br>  In the work there is a graph, called a rectangular lattice P <sub>m</sub> √ó P <sub>n</sub> .  A rectangular lattice is an integer point of the coordinate plane, connected by the principle of the nearest neighborhood.  The designation P <sub>m</sub> √ó P <sub>n</sub> is related to the fact that the integer rectangle is the direct product of two chains, the first of which has m links (denoted by P <sub>m</sub> ), and the second one - n (denoted by P <sub>n</sub> ).  The number m is the width of the lattice (length from left to right), and n is its length (length from bottom to top). <br><br>  A Hamiltonian cycle in a graph is a cycle that passes through each of its vertices exactly once.  In fig.  Figure 1 shows an example of a Hamiltonian cycle on a P <sub>6</sub> √ó P <sub>8</sub> lattice. <br><br><img src="https://habrastorage.org/storage/f922ac7c/8582ca71/43060b38/850a5bf7.gif"><br>  <em>Figure 1 - Example of a Hamiltonian cycle on a 6 √ó 8 grid</em> <br><br>  The task is to find the number of Hamiltonian cycles on the lattice P <sub>m</sub> √ó P <sub>n</sub> for given m, n ‚â• 2.  For example, the following figure shows all 6 Hamiltonian cycles on a 4 √ó 4 grid. <br><br><img src="https://habrastorage.org/storage/e490b6df/5a828baf/6672e663/5357747d.gif"><br>  <em>Figure 2 - All 6 Hamiltonian cycles on a 4 √ó 4 grid</em> <br><br><br><h4>  3. Cuts and State Machine </h4><br><br>  Any cycle in the P <sub>m</sub> √ó P <sub>n</sub> graph can be built sequentially along the ‚Äúlayers‚Äù of P <sub>m</sub> √ó P <sub>k</sub> (k = 0,1,2, ..., n).  For clarity, in Fig.  3 shows a line cutting the graph into two parts.  Below it, the graph P <sub>6</sub> √ó P <sub>5</sub> , on which the still unfinished ‚Äúcycle‚Äù is a set of disjoint simple chains.  This constructed part of the cycle will be called the "past."  At the top of the line, one of the possible options for the completion of an unfinished ‚Äúcycle‚Äù (this is the ‚Äúfuture‚Äù) is depicted.  The cycle is closed and does not touch the cut line at its points of inflection.  And since, bypassing the cycle in any direction, we will return to the starting point, the cut line will be intersected by the cycle an even number of times. <br><br><img src="https://habrastorage.org/storage/33774ab7/c72423e1/7542f6d6/02d24190.gif"><br>  <em>Figure 3 - Cycle section</em> <br><br>  The intersection of the cycle by the cut line itself can be represented as a regular bracket sequence, discharged with zeros.  For example, in fig.  3 such a sequence has the form <strong>(0000)</strong> .  In this sequence, a pair of matching opening and closing brackets correspond to the two ends of the same chain through the ‚Äúpast‚Äù, and the zeros mean that at these points there is no intersection of the cut line with the cycle.  Thus, <strong>any</strong> section can be encrypted with the correct bracket sequence discharged with zeros.  Since the initial and final cuts must be zero (consisting entirely of zeros), we must distinguish them, denoting one with a line below, and the second with a line above. <br><br>  In the process of building a cycle, we do not need to know either the "past" or the "future", but it is enough to store only information about which section at a given time has turned out, and how the rest can be obtained from this section.  Indeed, how to move from the current cut to the next?  For example, as in fig.  3 is the transition from the cut <strong>(0000)</strong> to the next cut <strong>00 () 00</strong> ?  This will be shown in the examples. <br><br><img src="https://habrastorage.org/storage/ceb7ee0a/2b49f81e/b0329a35/8851fddb.gif"><br>  <em>Figure 4 - Examples of the transition from one section to another</em> <br><br>  In fig.  4 shows 3 examples of transitions from one section to another.  The arcuate lines show that the ends of the corresponding vertical arcs are connected through the ‚Äúpast‚Äù.  The first case shows the transition to fig.  3 The remaining two cases are slightly more complex, but they clearly demonstrate what new cuts can be obtained by adding different combinations of horizontal arcs. <br><br>  However, not all combinations of horizontal arcs can lead to a new cut.  Some combinations may be unacceptable for three reasons, indicated in Figure 5. <br><br><img src="https://habrastorage.org/storage/7f330f9a/43123a0c/10d7ff3b/c20c5997.gif"><br>  <em>Figure 5 - Examples of invalid transitions.</em>  <em>Three possible cases</em> <br><br>  In the first case, one of the three chains closes ahead of time, so the Hamiltonian cycle cannot turn out.  In the second case, three arcs meet at the same vertex.  Finally, the third case is impossible due to the fact that some vertices were unused (and the Hamiltonian cycle must go through <strong>all the</strong> vertices). <br><br>  So, suppose that we have information about all possible sections of our lattice and which sections from which can be obtained by including horizontal arcs.  All this information can be represented in the form of a finite automaton whose nodes will be cuts, and the arcs will show the possibility of a transition.  In fig.  6 shows an example of such a finite automaton constructed for a 3 √ó n lattice. <br><br><img src="https://habrastorage.org/storage/fa0c2ce8/276b7b48/7674ea3b/21ce851c.gif"><br>  <em>Figure 6 - State machine for the 3 √ó n grid</em> <br><br>  The answer to the question of how many cycles exist on the P <sub>3</sub> √ó P <sub>n</sub> grid will be the number of ways to go from the initial state of the automaton to the final state in n steps.  How to do it?  I know two ways: bad and better.  I'll start with the bad. <br><br><br><h4>  4. The matrix transfer method </h4><br><br>  One of the ways to solve the problem is called the transfer matrix method, which consists in the following.  Let us enumerate all possible cuts from 1 to N in any way, but so that the initial state is number 1 and the final state is number N. We construct a matrix T in which the numbers T <sub>ij</sub> will be equal to the number of ways to get from the cut i number cut j .  The solution of the problem for the lattice P <sub>m</sub> √ó P <sub>n</sub> is the number (T <sup>n</sup> ) <sub>1, N.</sub> <br>  For example, for the P <sub>3</sub> √ó P <sub>n</sub> lattice, we have already constructed an automaton (Fig. 6), so we can write out the transfer matrix. <br><br><img src="https://habrastorage.org/storage/11a58c9f/a2653fd4/d95f55bb/84124bc2.gif"><br>  <em>Figure 7 - Transfer matrix, or adjacency matrix of the finite automaton of fig.</em>  <em>6 and her sixth degree</em> <br><br>  In fig.  7 shows the transfer matrix T for Hamiltonian cycles on the P <sub>3</sub> √ó P <sub>n</sub> lattice.  The solution will be the number (T <sup>n</sup> ) <sub>15</sub> .  For example, (T <sup>6</sup> ) <sub>15</sub> = 4, so is the number of Hamiltonian cycles on the P <sub>3</sub> √ó P <sub>6</sub> lattice. <br><br>  However, in practice this method of solving the problem is applicable, at most, for m = 12, when the transfer matrix for Hamiltonian cycles on the lattice has a size of 3774 √ó 3774 (see Table 1 in the discussion section) and fits in the RAM of a personal computer.  Long numbers are stored in the matrix itself, since, for example, the answer for the P <sub>12</sub> √ó P <sub>20</sub> grid contains 33 digits, and for the P <sub>12</sub> √ó P <sub>100</sub> grid, the number of digits reaches 174. <br><br>  In the section ‚ÄúModular arithmetic‚Äù it will be shown how to get rid of long numbers, sacrificing the speed of calculations, but it still will not save from the monstrous growth of the transfer matrix.  Therefore, I called this method of solving the problem bad. <br><br><br><h4>  5. Solution without a matrix </h4><br><br>  This solution, as it is not strange, is also called the transfer matrix method, but the matrix clearly does not appear in it, therefore, this method is called in the Russian-language literature a method of dynamic programming [on a finite state machine]. <br><br>  The meaning of the method is to store the number of ways to get to each vertex of the finite state machine in k steps.  At step k = 0, this number is 0 in all vertices except the starting one.  The number of ways to be at the starting vertex at step k = 0 is, by definition, set to 1. Let at some step k at vertex i you can be P ways, then going to step k + 1 we add the number P to the number of ways it is at all vertices j, which can be reached from i.  But for this you need to know which vertices you can get from i, that is, to store the matrix again!  In fact, it is not necessary: ‚Äã‚Äãgetting to vertex i, and knowing what section it denotes, we <strong>re-</strong> build all such cuts that can come out of it. <br><br>  How this is implemented in the program is an individual matter.  I will explain my approach.  Suppose there is a queue Q in which cuts are stored (as a bracket sequence) and the number of ways to be in them.  At the beginning of the algorithm, a section consisting of zeros and a number of methods equal to 1 is stored in the queue. Along with the queue, there is a hash table that also stores sections and the number of ways to be in them.  At the beginning of the algorithm, the table is empty. <br><br>  At step k, we get another section i from the queue, and the number of ways P can be in it.  We build the set J of all possible cuts obtained from i.  For each j of j, we check if it is in the hash table.  If not, add j to the table along with the number of methods P. If yes, then from the table we take the number of ways Q that can come in j and write the number P + Q in its place.  The exception is the case when j is equal to the zero cut, which means that we got to the final state and have to add the number P to the answer, but not add the zero cut to the hash. <br><br>  At the end of step k, the queue is empty, so move the data from the hash table to the queue, clear the hash, and go to step k + 1. <br><br>  I am using a hash with open addressing and double hashing.  The number of collisions is 0.6 per call.  That is, in 60% of cases, one step is taken on the table, and in other cases it falls right away.  I think this is a good hash for such a task. <br><br><br><br><br><h4>  6. The complexity of the algorithm </h4><br><br>  First, I will point out the upper limit of complexity, and then I will show what actually happens in practice. <br><br>  The set of all regular bracket sequences discharged with zeros and having length m are Motzkin words of length m over the alphabet { <b>0</b> , <b>(</b> , <b>)</b> }, generated by context-free grammar <br><br>  Z ‚Üí Y |  Y <strong>(</strong> Z <strong>)</strong> Z, <br>  Y ‚Üí Œµ |  <strong>0</strong> Y, <br><br>  where Œµ denotes an empty word.  The number of such words can be calculated from combinatorial considerations: <br><br><img src="https://habrastorage.org/storage/e49d9f59/387fa7a3/658e97d4/2e8b02a4.gif"><br><br>  In this formula, k is the number of pairs of brackets.  The first expression under the sum sign (the fraction and the very first binomial coefficient) is the <a href="http://www.genfunc.ru/theory/catalan/">Catalan number</a> , which shows the number of regular bracket sequences, and the second binomial coefficient is the number of ways to put 2k brackets in m positions (filling the remaining positions with zeros). <br><br>  Thus, the number of all possible cuts for Hamiltonian cycles on the lattice, at least, does not exceed the number of Motzkin words, and Motzkin words grow at a speed of almost 3 <sup>m</sup> .  In fact, such cuts are much smaller, since some may be unacceptable.  For example, cuts such as <strong>(0) 000</strong> or <strong>(() 0) 0</strong> will be unacceptable for a lattice of width 6, since they cannot be obtained when constructing a Hamiltonian cycle.  The discussion section will show the table.  1, which indicates the total number of cuts for some m.  In reality, it turns out that only a third of Motzkin's words are permissible, and taking into account symmetry, it is enough to store only one fifth of them. <br><br>  I will explain.  Some cuts are palindromes and coincide with themselves with symmetric reflection, but those that are symmetrical to each other can be stored as one section.  For example, the cut <b>(()) ()</b> and <b>() (())</b> can be considered one and the same.  With this in mind, it turns out that, on average, only one-fifth of Motzkin's words should be stored in the program. <br><br>  For each section, we have to go through 2 <sup>m-1</sup> ways to put horizontal arcs.  And all this together we have to do n times. <br><br>  Total, the algorithm has complexity O (6 <sup>m</sup> ¬∑ m <sup>-1/2</sup> ¬∑ n).  And in fact, due to the fact that many cuts are unacceptable, in practice the complexity of the algorithm is O (5 <sup>m</sup> ¬∑ n).  This happened during my observation of the algorithm. <br><br>  As for the memory used, the main part of the resources is occupied by the queue and the hash table.  Each section for m‚â§32 can be stored in a 64-bit integer, since 2 bits are required for storing brackets and the number 0. Plus a long arithmetic that eats up all the resources completely.  But there is one technique that allows you to slow down the calculations, giving up long arithmetic. <br><br><br><h4>  7. Modular arithmetic </h4><br><br>  Let's calculate the answer modulo various primes: 2 <sup>31</sup> -1 = 2147483647, 2147483629, 2147483587, ... To do this, the program must be run as many times as we can choose different modules (although, of course, you can count on 2-3 modules at once, in memory).  According to the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B8%25D1%2582%25D0%25B0%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D0%25B1_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B0%25D1%2585">Chinese remainder theorem,</a> it is possible to recover the answer up to the product of all primes used.  If the product of all primes is greater than the answer to the problem, then the answer is uniquely restored.  How to choose the required number of modules? <br><br>  For example, let's count the number of cycles on a 16-n grid on two modules.  Let n = 1,2, ..., 16.  Then get the answers <br><br>  [0, 1, 128, 405688, 24980352, 776813457, 729683652, 1087605227, 2000673777, 456710131, 1550214608, 568568229, 2047094091, 1175631455, 380271385, 1536681549] (mod 2147483647). <br><br>  [0, 1, 128, 405688, 24980352, 776813727, 729709644, 1107434405, 301217473, 1373982040, 103268356, 218837622, ‚Äã‚Äã1185113726, 2085126539, 1315887233, 2008046410] (mod 2147483629). <br><br>  According to the Chinese theorem on residues, we have: <br><br>  [0, 1, 128, 405,688, 24,980,352, 32,989,068,162, 3101696069920, 2365714170297014, 309656520296472068, 2415277789552788286, 3926649012293853406, 726889843182193849, 153366515247378747, 1645735649663585962, 3698490188721496226, 1337259901989820598] (mod ¬∑ 2147483647 2147483629). <br><br>  How to check if we have enough 2 modules?  In this problem, it is clear that numbers must grow exponentially, which means their logarithms must grow linearly.  Take logarithms (for example, natural): <br><br>  [-INF, 0, 4.852, 12.91, 17.03, 24.22, 28.76, 35.40, 40.27, 42.33, 42.81, 41.13, 39.57, 41.94, 42.75, 41.74]. <br><br>  The logarithm of the product of our two modules is 42.98.  We see that the difference between the numbers monotonously grows by about the same amount, and, starting with n = 9, for some reason they stop growing.  Moreover, in this place the limit was reached, beyond which the numbers can no longer be.  This means that two modules were not enough.  Let's take 4 modules and restore the answer: <br><br>  [0, 1, 128, 405,688, 24,980,352, 32,989,068,162, 3101696069920, 2365714170297014, 309656520296472068, 168435972906750526954, 27738606105535271640888, 12142048779807437697982030, 2344813362310160031818110686, 888511465584607682074513271223, 191678405883294971709423926242394, 65882516522625836326159786165530572] (mod 2147483647 2147483629 ¬∑ ¬∑ ¬∑ 2147483587 2147483579). <br><br>  Logarithms are: <br><br>  [-IFN., 0, 4.852, 12.91, 17.03, 24.22, 28.76, 35.40, 40.27, 46.57, 51.68, 57.76, 63.02, 68.96, 74.33, 80.17]. <br><br>  The numbers strictly increase, increasing by about the same amount.  The logarithm of the product of 4 selected modules is 85.95, which is noticeably more than the last number in the sequence.  That means the answer is correct.  You can verify this by typing the query "65882516522625836326159786165530572" in Google. <br><br><br><h4>  8. Discussions and results </h4><br><br>  With this algorithm, I was able to calculate the number of cycles on a 22 √ó 100 grid.  Calculations on a single module lasted about 30 hours on 32 cores of the cluster.  In total, it took about 50 modules.  Memory required less than 1 GB per core.  In the course of calculations, I collected some information about the quantitative characteristics of the solution.  In tab.  1 below presents this information. <br><br><table><tbody><tr><th>  m </th><th>  The real number of cuts </th><th>  The number of words Motzkin </th></tr><tr><td>  3 </td><td>  3 </td><td>  four </td></tr><tr><td>  four </td><td>  6 </td><td>  9 </td></tr><tr><td>  five </td><td>  12 </td><td>  21 </td></tr><tr><td>  6 </td><td>  23 </td><td>  51 </td></tr><tr><td>  7 </td><td>  62 </td><td>  127 </td></tr><tr><td>  eight </td><td>  109 </td><td>  323 </td></tr><tr><td>  9 </td><td>  365 </td><td>  835 </td></tr><tr><td>  ten </td><td>  607 </td><td>  2188 </td></tr><tr><td>  eleven </td><td>  2355 </td><td>  5798 </td></tr><tr><td>  12 </td><td>  3774 </td><td>  15511 </td></tr><tr><td>  13 </td><td>  16020 </td><td>  41835 </td></tr><tr><td>  14 </td><td>  25188 </td><td>  113634 </td></tr><tr><td>  15 </td><td>  113198 </td><td>  310572 </td></tr><tr><td>  sixteen </td><td>  176061 </td><td>  853467 </td></tr><tr><td>  17 </td><td>  821923 </td><td>  2356779 </td></tr><tr><td>  18 </td><td>  1270562 </td><td>  6536382 </td></tr><tr><td>  nineteen </td><td>  6097041 </td><td>  18199284 </td></tr><tr><td>  ten </td><td>  9387784 </td><td>  50852019 </td></tr><tr><td>  21 </td><td>  46013564 </td><td>  142547559 </td></tr><tr><td>  22 </td><td>  70652188 </td><td>  400763223 </td></tr></tbody></table><br>  <em>Table 1 - Comparison of the numbers of Motzkin and the actual number of cuts required for storage in memory</em> <br><br>  In the first column, the lattice width is m.  In the third - the number of words Motzkin length m.  The middle column indicates the actual number of cuts, which turn out to be permissible (symmetry is taken into account and the final state is not counted). <br><br>  If you wish to see the number of Hamiltonian cycles on a square lattice P <sub>2n</sub> √ó P <sub>2n</sub> , then the link to this sequence is in the list of sources. <br><br><br><h4>  9. List of sources used </h4><br><ol><li>  M. Gary, D. Johnson.  Computers and inaccessible tasks. </li><li>  <a href="http://www.research.att.com/~njas/sequences/A003763">A003763</a> - Number of Hamiltonian cycles on 2n X 2n square grid of points. </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B8%25D1%2582%25D0%25B0%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D0%25B1_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B0%25D1%2585">The Chinese remainder theorem</a> . </li><li>  <a href="http://www.genfunc.ru/theory/catalan/">Catalan numbers</a> , derivation of formulas and asymptotics. </li></ol><br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/105705/">https://habr.com/ru/post/105705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../105696/index.html">Unit testing and CodeCoverage for Javascript code</a></li>
<li><a href="../105699/index.html">Official survey: do you completely load the Habrahabr pages while surfing?</a></li>
<li><a href="../105701/index.html">New version of Mono 2.8 released</a></li>
<li><a href="../105702/index.html">Solar tree for contactless charging</a></li>
<li><a href="../105703/index.html">Bicycle Liquidator: Part 1</a></li>
<li><a href="../105706/index.html">On the issue of ‚Äútheft‚Äù and ‚Äúlicense stickers‚Äù</a></li>
<li><a href="../105707/index.html">Beta testing of ABBYY Lingvo.Pro linguistic portal</a></li>
<li><a href="../105708/index.html">Publication of found vulnerabilities: pros and cons</a></li>
<li><a href="../105709/index.html">Habrafootball this sunday</a></li>
<li><a href="../105710/index.html">Twitter: 1 billion queries per day and a new search engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>