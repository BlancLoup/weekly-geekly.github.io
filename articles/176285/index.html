<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Language in language or embed XPath in Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scala is a great language. You can fall in love with him. The code may be concise, but understandable; flexible but strongly typed. Well-thought-out t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Language in language or embed XPath in Scala</h1><div class="post__text post__text-html js-mediator-article">  Scala is a great language.  You can fall in love with him.  The code may be concise, but understandable;  flexible but strongly typed.  Well-thought-out tools allow you not to struggle with the language, but to express your ideas on it. <br><br>  But the same tools allow you to write extremely complex code. <br>  Using intellectual equilibristism in the style of scalaz or calculations on a shapeless type system is a guarantee that your code will be understood by units. <br><br>  In this article I will talk about what to do, most likely, not worth it. <br>  I will tell you how to embed another language into scala. <br><a name="habracut"></a><br>  And although we will build XPath with you, the described method is suitable for any language for which you can build a syntax tree. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The reasons </h4><br>  In scala, it is possible to use all the tools for working with xml, which is in Java (and there are not a few of them).  But the code will also resemble good old Java code.  Not too joyful prospect. <br><br>  There is a custom xml embedded in the syntax of the language: <br><br><pre><code class="scala hljs">scala&gt; &lt;root&gt; | &lt;node attr=<span class="hljs-string"><span class="hljs-string">"aaa"</span></span>/&gt; | &lt;node attr=<span class="hljs-string"><span class="hljs-string">"111"</span></span>&gt; text&lt;/node&gt; | &lt;/root&gt; res0: scala.xml.<span class="hljs-type"><span class="hljs-type">Elem</span></span> = &lt;root&gt; &lt;node attr=<span class="hljs-string"><span class="hljs-string">"aaa"</span></span>/&gt; &lt;node attr=<span class="hljs-string"><span class="hljs-string">"111"</span></span>&gt; text&lt;/node&gt; &lt;/root&gt; scala&gt; res0 \\ <span class="hljs-string"><span class="hljs-string">"node"</span></span> res1: scala.xml.<span class="hljs-type"><span class="hljs-type">NodeSeq</span></span> = <span class="hljs-type"><span class="hljs-type">NodeSeq</span></span>(&lt;node attr=<span class="hljs-string"><span class="hljs-string">"aaa"</span></span>/&gt;, &lt;node attr=<span class="hljs-string"><span class="hljs-string">"111"</span></span>&gt; text&lt;/node&gt;) scala&gt; res1 \\ <span class="hljs-string"><span class="hljs-string">"@attr"</span></span> res2: scala.xml.<span class="hljs-type"><span class="hljs-type">NodeSeq</span></span> = <span class="hljs-type"><span class="hljs-type">NodeSeq</span></span>(aaa, <span class="hljs-number"><span class="hljs-number">111</span></span>)</code> </pre> <br>  It seems that here it is happiness, but no.  This only vaguely resembles XPath.  At least a little complex queries become cumbersome and unreadable. <br><br>  But after some acquaintance with scala it becomes clear that the creators are not unfoundedly called scala extensible (scalable) language.  And if something is missing, then this can be added. <br><br>  The task I set myself the maximum proximity to XPath with easy integration into the language. <br><br><h4>  Result </h4><br>  All developments here: <a href="">https://github.com/senia-psm/scala-xpath.git</a> <br><div class="spoiler">  <b class="spoiler_title">How to look.</b> <div class="spoiler_text">  If you do not have git and sbt yet, then you will have to install them ( <a href="http://git-scm.com/downloads">git</a> , <a href="http://www.scala-sbt.org/release/docs/Getting-Started/Setup.html">sbt</a> ) and, if necessary, set up a proxy ( <a href="http://stackoverflow.com/a/3406766/406435">git</a> , <a href="http://stackoverflow.com/questions/13803459/how-to-use-sbt-from-behind-a-proxy">sbt</a> - in Program Files (x86) \ SBT \ there is a special txt for such options). <br><br>  Clone repository: <br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/senia-psm/scala-xpath.git</code> </pre><br>  Go to the repository folder (scala-xpath) and open the REPL in the project: <br><pre> <code class="bash hljs">sbt console</code> </pre><br>  Also in many examples, it is assumed that the following imports are performed: <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> senia.scala_xpath.macros._, senia.scala_xpath.model._</code> </pre><br><br></div></div><br><br><h4>  What and how </h4><br>  The way to achieve the goal is uniquely determined by the goal itself. <br>  Embed XPath in the form of DSL, obviously, will not work.  Otherwise, it will not be quite XPath.  An XPath scala expression can only be placed as a string. <br>  And that means: <br><br><ol><li>  <a href="http://www.artima.com/pins1ed/combinator-parsing.html">Parser combinators</a> .  We have to parse the string for validation. </li><li>  <a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">String interpolation</a> .  To embed variables and functions in XPath. </li><li>  <a href="http://docs.scala-lang.org/overviews/macros/overview.html">Macros</a> .  To check at compile time. </li></ol><br><br><h4>  Prepare the object model. </h4><br>  We take <a href="http://www.w3.org/TR/xpath/">the</a> XPath 1.0 specification and <a href="https://github.com/senia-psm/scala-xpath/blob/de4e36c19fa1584b82267aebaa44c970481b7290/model/src/main/scala/senia.scala_xpath.model/Model.scala">rewrite</a> it on scala. <br>  Almost all logic is expressed through the type system and the scala inheritance mechanism.  Exceptions - in a couple of places of restriction through require. <br>  Here it is worth noting the keyword "sealed", prohibiting the inheritance of a class (or implement the interface) outside this file.  In particular, when compared with the ‚Äúsealed‚Äù pattern, the compiler can be checked that all possible options are taken into account. <br><br><h4>  XPath parsim </h4><br><div class="spoiler">  <b class="spoiler_title">Introduction to Parsers</b> <div class="spoiler_text">  <a href="http://www.scala-lang.org/api/current/index.html">Parsers</a> are functions that take a sequence of elements and return, if successful, the result of processing and the rest of the sequence. <br>  Unsuccessful results come in two kinds of ‚Äúfailure‚Äù (Failure) and ‚Äúerror‚Äù (Error). <br>  Figuratively speaking, the parser bites off part of the sequence from the beginning and converts the bitten bit into an object of a certain type. <br><br>  The simplest parser is a parser that verifies that the first element in the sequence is equal to the previously specified one and returns the element as a successful result.  As a remainder, there will be a sequence without this element. <br><br>  To create such a parser from an element, the method accept is used.  This method is defined as implicit, and if the compiler encounters an element where it expects to encounter a parser, it will add the application of this method to the element. <br>  Suppose we parse a sequence of characters: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elementParser</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">Char</span></span>] = 'c' <span class="hljs-comment"><span class="hljs-comment">//  def elementParser: Parser[Char] = accept('c') //  </span></span></code> </pre> <br>  Thus, if you see an element when combining parsers where a parser is to be, then you know what that elementary parser is meant for. <br><br>  In general, this is the only parser that is defined explicitly. <br>  All other parsers are obtained by combining others and transforming the results. <br><br><h6>  We combine parsers </h6><br><div class="spoiler">  <b class="spoiler_title">Lie for good</b> <div class="spoiler_text">  In fact, there are no operators in scala, but if you know this, then most likely you don‚Äôt need to tell you about parsers. </div></div><br>  Binary operator "~".  Combines 2 parsers according to the ‚Äúand‚Äù principle.  It is successful only if the first parser is successful first, and then the second on the remainder, which the first one gave. <br>  Figuratively speaking, first the first parser bites off what suits it, and then the second feasts on the leftovers. <br>  A container containing the results of both parsers is returned as a result. <br><pre> <code class="scala hljs">parser1 ~ parser2</code> </pre> <br>  This way you can combine any set of parsers. <br>  This combinator has 2 related: "~&gt;" and "&lt;~".  They work the same way, but return the result of only one of the combined parsers. <br><br>  Binary operator "|".  Combining on the principle of "or".  Successful if at least one of the results is successful at the initial input.  If the first parser returned ‚Äúfailure‚Äù (but not an error), then we try to feed the same input to the second one. <br><br>  rep.  Sequence.  If you have a myParser parser, then a parser formed with the help of ‚Äúrep (myParser)‚Äù will ‚Äúbite off‚Äù with the help of myParser from the input to the first unsuccessful application.  The results of all the "bites" are combined into a collection. <br>  There are related transformations, for a non-empty collection of results (rep1) and for a sequence with delimiters (repsep) <br><br><h6>  Convert the result </h6><br>  If you want to transform over the result of parsing, then come to the aid of operators such as ^^^ and ^^ <br>  ^^^ changes the result to the specified constant, and ^^ transforms the result using the specified function. <br></div></div><br><br>  Combining parsers (and literacy w3c specifications) allows you to write a parser without thinking. <br>  In fact, we rewrite the specification for the second time.  The only significant difference is that I replaced the recursive definitions with ‚Äúcyclic‚Äù (rep and repsep). <br><br>  For example: <br><br>  Specification: <br><pre>  [15] PrimaryExpr :: = VariableReference	
                                       |  '(' Expr ')'	
                                       |  Literal	
                                       |  Number	
                                       |  Functioncall </pre><br>  <a href="https://github.com/senia-psm/scala-xpath/blob/master/parser/src/main/scala/senia.scala_xpath.parser/XPathParsers.scala">Parser</a> : <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primaryExpr</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Parser</span></span>[<span class="hljs-type"><span class="hljs-type">PrimaryExpr</span></span>] = variableReference | `(` ~&gt; expr &lt;~ `)` ^^ { <span class="hljs-type"><span class="hljs-type">GroupedExpr</span></span> } | functionCall | number | literal</code> </pre> <br>  The only condition is that you need to make sure that the most "strict" parsers go in the union through "|"  before the rest.  In this example, literal will obviously succeed wherever functionCall succeeds simply because it successfully parses the name of the function, so if you put the literal earlier, then it just won't get to functionCall. <br>  <a href="https://github.com/senia-psm/scala-xpath/blob/master/parser/src/main/scala/senia.scala_xpath.parser/XPathParsers.scala">The entire set of parsers was</a> packed in a hundred and fifty lines, which is significantly shorter than the definition of the object model. <br><br><h4>  Mixing Variables </h4><br>  To add variables to the expression, we will use the string interpolation mechanism, introduced in version 2.10. <br>  The mechanism is quite simple: by encountering a line in front of which (without a space) there is a valid method name, the compiler produces a simple conversion: <br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">t"strinf </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$x</span></span></span><span class="hljs-string"> interpolation </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ obj.name.toString }</span></span></span><span class="hljs-string"> "</span></span> <span class="hljs-type"><span class="hljs-type">StringContext</span></span>(<span class="hljs-string"><span class="hljs-string">"strinf "</span></span>, <span class="hljs-string"><span class="hljs-string">" interpolation "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>).t(x, { obj.name.toString })</code> </pre> <br>  The string is broken into pieces by the occurrences of variables and expressions and passed to the factory StringContext method.  The name preceding the string is used as the name of the method, and all variables and expressions are passed to this method as parameters. <br>  If this ends with methods like ‚Äús‚Äù and ‚Äúf‚Äù, then for methods that are not in StringContext, the compiler looks for an implicit class wrapper over StringContext containing the desired method.  Such a search is a general mechanism for scala and is not directly related to string interpolation. <br>  Summary Code: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MyStringContextHelper</span></span>(<span class="hljs-type"><span class="hljs-type">StringContext</span></span>(<span class="hljs-string"><span class="hljs-string">"strinf "</span></span>, <span class="hljs-string"><span class="hljs-string">" interpolation "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>)).t(x, { obj.name.toString })</code> </pre> <br><br>  But what about our parser?  We no longer have a continuous sequence of characters.  And there is a sequence of characters and something else. <br>  Is all the work a cat under the tail? <br>  This is where the usefulness of the possibility of parsing is not only a sequence of characters. <br>  We have a sequence of characters and something else (more on that later).  This is described by the Either concept.  On Habr√© a <a href="http://habrahabr.ru/post/146042/">couple of</a> <a href="http://habrahabr.ru/post/155477/">articles</a> about Either translated <a href="http://habrahabr.ru/users/sigrlami/" class="user_link">Sigrlami</a> . <br>  To regain all the power of parsers, you just need to write a couple of auxiliary tools.  In particular, the conversion from Char, String and Regex to the corresponding parsers. <br>  Here are all the necessary tools: <a href="https://github.com/senia-psm/scala-xpath/blob/master/parser/src/main/scala/senia.scala_xpath.parser/EitherParsers.scala">EitherParsers</a> .  It is worth paying attention to the abstract type R. No assumptions have been made about it, so the toolkit is suitable for a previously unknown method of representing variables. <br><br><h4>  We interfere in compilation </h4><br>  Documentation and reasonable examples of macros in my opinion a little.  But this does not mean that I am going to write a comprehensive explanation of what macros are and what they eat with. <br>  First of all, you should know that the macro is called when the compiler encounters a method implemented using the macro keyword and the macro implementation must output the newly created syntax tree. <br>  Let's see what kind of tree we have to give on the simplest example: <br><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.reflect.runtime.universe._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.reflect.runtime.universe._ scala&gt; showRaw(reify( <span class="hljs-string"><span class="hljs-string">"str"</span></span> -&gt; <span class="hljs-symbol"><span class="hljs-symbol">'symb</span></span> )) res0: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Apply</span></span>(<span class="hljs-type"><span class="hljs-type">Select</span></span>(<span class="hljs-type"><span class="hljs-type">Apply</span></span>(<span class="hljs-type"><span class="hljs-type">Select</span></span>(<span class="hljs-type"><span class="hljs-type">Ident</span></span>(scala.<span class="hljs-type"><span class="hljs-type">Predef</span></span>), newTermName(<span class="hljs-string"><span class="hljs-string">"any2ArrowAssoc"</span></span>)), <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Literal</span></span>(<span class="hljs-type"><span class="hljs-type">Constant</span></span>(<span class="hljs-string"><span class="hljs-string">"str"</span></span>)))), newTermName(<span class="hljs-string"><span class="hljs-string">"$minus$greater"</span></span>)), <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Apply</span></span>(<span class="hljs-type"><span class="hljs-type">Select</span></span>(<span class="hljs-type"><span class="hljs-type">Ident</span></span>(scala.<span class="hljs-type"><span class="hljs-type">Symbol</span></span>), newTermName(<span class="hljs-string"><span class="hljs-string">"apply"</span></span>)), <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Literal</span></span>(<span class="hljs-type"><span class="hljs-type">Constant</span></span>(<span class="hljs-string"><span class="hljs-string">"symb"</span></span>)))))))</code> </pre><br><br>  There is no desire to build this on your own. <br>  Let's see what scala offers us with the preservation of typing and without manual work. <br>  On the one hand, there are not many: the literal method, which allows you to convert a certain limited set of ‚Äúbasic types‚Äù to syntactic trees, and reify, which does all the manual work for you, but only if you introduce any variables to the outside as the same tree. , then use the splice method of this tree, designed specifically to inform reify about your desire to embed Expt [T] type expressions as part of a new tree with the resulting type T. <br>  On the other hand, these methods are quite enough.  Additional can be written based on available. <br><br>  The addition of <a href="https://github.com/senia-psm/scala-xpath/blob/master/macros/src/main/scala/senia.scala_xpath.macros/package.scala">interpolation</a> processed by a macro itself is extremely concise: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XPathContext</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">sc: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">StringContext</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xp</span></span></span></span>(as: <span class="hljs-type"><span class="hljs-type">Any</span></span>*): <span class="hljs-type"><span class="hljs-type">LocationPath</span></span> = macro xpathImpl }</code> </pre> <br><br>  The macro processing function is declared as follows: <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xpathImpl</span></span></span></span>(c: <span class="hljs-type"><span class="hljs-type">Context</span></span>)(as: c.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>]*): c.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">LocationPath</span></span>]</code> </pre> <br>  It is clear where to get the variables, but how to get the string? <br>  To do this, you can use the context to ‚Äúlook out‚Äù of the function.  So say look around. <br>  Or rather look at the expression in which the target method xp is called. <br>  This can be done using c.prefix. <br>  But what will we find there?  Earlier it was mentioned that there should be a StringContext expression ("strinf", "interpolation", ""). <br>  Let's look at the corresponding tree: <br><pre> <code class="scala hljs">scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.reflect.runtime.universe._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.reflect.runtime.universe._ scala&gt; showRaw(reify(<span class="hljs-type"><span class="hljs-type">StringContext</span></span>(<span class="hljs-string"><span class="hljs-string">"strinf "</span></span>, <span class="hljs-string"><span class="hljs-string">" interpolation "</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>))) res0: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">Expr</span></span>(<span class="hljs-type"><span class="hljs-type">Apply</span></span>(<span class="hljs-type"><span class="hljs-type">Select</span></span>(<span class="hljs-type"><span class="hljs-type">Ident</span></span>(scala.<span class="hljs-type"><span class="hljs-type">StringContext</span></span>), newTermName(<span class="hljs-string"><span class="hljs-string">"apply"</span></span>)), <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Literal</span></span>(<span class="hljs-type"><span class="hljs-type">Constant</span></span>(<span class="hljs-string"><span class="hljs-string">"strinf "</span></span>)), <span class="hljs-type"><span class="hljs-type">Literal</span></span>(<span class="hljs-type"><span class="hljs-type">Constant</span></span>(<span class="hljs-string"><span class="hljs-string">" interpolation "</span></span>)), <span class="hljs-type"><span class="hljs-type">Literal</span></span>(<span class="hljs-type"><span class="hljs-type">Constant</span></span>(<span class="hljs-string"><span class="hljs-string">" "</span></span>)))))</code> </pre> <br>  As we can see from here you can get all the lines in an explicit form, which we will do: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strings = c.prefix.tree <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Apply</span></span>(_, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Apply</span></span>(_, ss))) =&gt; ss <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; c.abort(c.enclosingPosition, <span class="hljs-string"><span class="hljs-string">"not a interpolation of XPath. Cannot extract parts."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chars = strings.map{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> c.universe.<span class="hljs-type"><span class="hljs-type">Literal</span></span>(<span class="hljs-type"><span class="hljs-type">Constant</span></span>(source: <span class="hljs-type"><span class="hljs-type">String</span></span>)) =&gt; source.map{ <span class="hljs-type"><span class="hljs-type">Left</span></span>(_) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; c.abort(c.enclosingPosition, <span class="hljs-string"><span class="hljs-string">"not a interpolation of XPath. Cannot extract string."</span></span>) }</code> </pre> <br><br>  But not only the entrance has changed.  The result of the parser can no longer be an object from our object model - it is simply not to build it based not on a value, but on a parameter of the type c.Expr [Any]. <br><br>  Change our parser accordingly.  If an external variable can somehow appear as a result, the parser can no longer return T, but should return c.Expr [T].  For conversions of non-elementary types to the corresponding Expr, we write literal <a href="https://github.com/senia-psm/scala-xpath/blob/master/macros/src/main/scala/senia.scala_xpath.macros/Literals.scala">helper methods</a> based on the available ones, for example: <br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">literal</span></span></span></span>(name: <span class="hljs-type"><span class="hljs-type">QName</span></span>): lc.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">QName</span></span>] = reify{ <span class="hljs-type"><span class="hljs-type">QName</span></span>(literal(name.prefix).splice, literal(name.localPart).splice) }</code> </pre> <br>  The principle of all such functions is very simple: we parse the argument into quite elementary parts and assemble it again within reify. <br><br>  This will require some mechanical work, but our parser will not change much. <br><br>  The final step is the implementation of several parsers that can parse a variable at the input. <br>  Here is the <a href="https://github.com/senia-psm/scala-xpath/blob/master/macros/src/main/scala/senia.scala_xpath.macros/XPathParsers.scala">parser</a> for embedding the variable: <br><pre> <code class="scala hljs"> accept(<span class="hljs-string"><span class="hljs-string">"xc.Expr[Any]"</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Right</span></span>(e) =&gt; e } ) ^? ({ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: xc.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">BigInt</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> confirmType(e, tagOfBigInt.tpe) =&gt; reify{ <span class="hljs-type"><span class="hljs-type">CustomIntVariableExpr</span></span>(<span class="hljs-type"><span class="hljs-type">VariableReference</span></span>(<span class="hljs-type"><span class="hljs-type">QName</span></span>(<span class="hljs-type"><span class="hljs-type">None</span></span>, <span class="hljs-type"><span class="hljs-type">NCName</span></span>(xc.literal(nextVarName).splice))), e.splice) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: xc.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">Double</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> confirmType(e, xc.universe.definitions.<span class="hljs-type"><span class="hljs-type">DoubleClass</span></span>.toType) =&gt; reify{ <span class="hljs-type"><span class="hljs-type">CustomDoubleVariableExpr</span></span>(<span class="hljs-type"><span class="hljs-type">VariableReference</span></span>(<span class="hljs-type"><span class="hljs-type">QName</span></span>(<span class="hljs-type"><span class="hljs-type">None</span></span>, <span class="hljs-type"><span class="hljs-type">NCName</span></span>(xc.literal(nextVarName).splice))), e.splice) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e: xc.<span class="hljs-type"><span class="hljs-type">Expr</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> confirmType(e, xc.universe.definitions.<span class="hljs-type"><span class="hljs-type">StringClass</span></span>.toType) =&gt; reify{ <span class="hljs-type"><span class="hljs-type">CustomStringVariableExpr</span></span>(<span class="hljs-type"><span class="hljs-type">VariableReference</span></span>(<span class="hljs-type"><span class="hljs-type">QName</span></span>(<span class="hljs-type"><span class="hljs-type">None</span></span>, <span class="hljs-type"><span class="hljs-type">NCName</span></span>(xc.literal(nextVarName).splice))), e.splice) } }, e =&gt; <span class="hljs-string"><span class="hljs-string">s"Int, Long, BigInt, Double or String expression expected, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$e</span></span></span><span class="hljs-string"> found."</span></span> )</code> </pre><br>  The initial accept ("xc.Expr [Any]", {case Right (e) =&gt; e}) parser is very simple - it accepts any Right container with a tree and returns this tree. <br>  Further conversion determines whether this variable can be used as one of the three desired types and then converted to that use. <br><br>  As a result, we get the following behavior: <br><pre> <code class="scala hljs">scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> xml = &lt;book attr=<span class="hljs-string"><span class="hljs-string">"111"</span></span>/&gt; xml: scala.xml.<span class="hljs-type"><span class="hljs-type">Elem</span></span> = &lt;book attr=<span class="hljs-string"><span class="hljs-string">"111"</span></span>/&gt; scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> os = <span class="hljs-type"><span class="hljs-type">Option</span></span>(<span class="hljs-string"><span class="hljs-string">"111"</span></span>) os: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-number"><span class="hljs-number">111</span></span>) scala&gt; xml \\ <span class="hljs-string"><span class="hljs-string">xp"*[@attr = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$os</span></span></span><span class="hljs-string">]"</span></span> <span class="hljs-comment"><span class="hljs-comment">// Option[String]    &lt;console&gt;:16: error: Int, Long, BigInt, Double or String expression expected, Expr[Nothing](os) found. xml \\ xp"*[@attr = $os]" ^ scala&gt; xml \\ xp"*[@attr = ${ os.getOrElse("") } ]" //   String   res1: scala.xml.NodeSeq = NodeSeq(&lt;book attr="111"/&gt;)</span></span></code> </pre><br><br>  And if the error messages still need some work, the variables are already built in quite conveniently. <br><br>  Embedding functions required quite a lot of code (23 options, one for options from 0 to 22 parameters) and does not work very conveniently, since you only need to take Any, but comes mainly with a NodeList (but the string can come or Double): <br><br><pre> <code class="scala hljs">scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.w3c.dom.<span class="hljs-type"><span class="hljs-type">NodeList</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.w3c.dom.<span class="hljs-type"><span class="hljs-type">NodeList</span></span> scala&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isAllowedAttributeOrText = (_: <span class="hljs-type"><span class="hljs-type">Any</span></span>, _: <span class="hljs-type"><span class="hljs-type">Any</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-comment"><span class="hljs-comment">// - ,       | case (a: NodeList, t: NodeList) if a.getLength == 1 &amp;&amp; t.getLength == 1 =&gt; | a.head.getTextContent == "aaa" || | t.head.getTextContent.length &gt; 4 | case _ =&gt; false | } isAllowedAttributeOrText: (Any, Any) =&gt; Boolean = &lt;function2&gt; scala&gt; val xml = &lt;root attr="11111" &gt;&lt;inner attr="111" /&gt;&lt;inner attr="aaa" &gt;inner text&lt;/inner&gt; text &lt;/root&gt; xml: scala.xml.Elem = &lt;root attr="11111"&gt;&lt;inner attr="111"/&gt;&lt;inner attr="aaa"&gt;inner text&lt;/inner&gt; text &lt;/root&gt; scala&gt; xml \\ xp"*[$isAllowedAttributeOrText(@attr, text())]" res0: scala.xml.NodeSeq = NodeSeq(&lt;root attr="11111"&gt;&lt;inner attr="111"/&gt;&lt;inner attr="aaa"&gt;inner text&lt;/inner&gt; text &lt;/root&gt;, &lt;inner attr="aaa"&gt;inner text&lt;/inner&gt;)</span></span></code> </pre> <br><br>  Here we received the first copying of the XPath syntax (except for the possibility of writing expressions like $ {arbitrary code} instead of variables) - the function being injected must be preceded by a dollar. <br><br><h4>  Method implementation </h4><br>  Naturally, the methods "\" and "\\" of scala.xml.NodeSeq did not appear by magic, they are added using the implicit class in the <a href="https://github.com/senia-psm/scala-xpath/blob/master/model/src/main/scala/senia.scala_xpath.model/package.scala">package object of the</a> model. <br><br>  Similar methods are built into <a href="https://github.com/senia-psm/scala-xpath/blob/master/model/src/main/scala/senia.scala_xpath.model/package.scala">org.w3c.dom.Node</a> and <a href="https://github.com/senia-psm/scala-xpath/blob/master/model/src/main/scala/senia.scala_xpath.model/package.scala">NodeList</a> . <br><br>  And with the use of XPath, certain problems arise. <br><br><h4>  Unresolved problems </h4><br>  <a href="https://github.com/senia-psm/scala-xpath/blob/master/model/src/main/scala/senia.scala_xpath.model/package.scala">Get rid</a> of java.lang.System.setSecurityManager (null).  Judging by the implementation of com.sun.org.apache.xpath.internal.jaxp.XPathFactoryImpl, one should not add one‚Äôs own function handler. <br><br>  Errors at compile time need some work. <br>  If, if the function is not correct, the error message is ideal (a separate compliment in the direction of compiler prudence): <br><pre> <code class="scala hljs">scala&gt; xml \\ <span class="hljs-string"><span class="hljs-string">xp"*[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$isAllowedAttributeOrText</span></span></span><span class="hljs-string">(@attr)]"</span></span> &lt;console&gt;:<span class="hljs-number"><span class="hljs-number">1</span></span>: error: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mismatch</span></span></span></span>; found : (<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> required: <span class="hljs-type"><span class="hljs-type">Any</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Any</span></span> xml \\ <span class="hljs-string"><span class="hljs-string">xp"*[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$isAllowedAttributeOrText</span></span></span><span class="hljs-string">(@attr)]"</span></span> ^</code> </pre><br>  then for all other errors the standard message format is not observed and the position indicates the beginning of the line. <br>  Unlike the previous one, this problem can be solved. <br><br>  Performance when working with scala.xml leaves much to be desired.  In fact, the first conversion from scala.xml to w3c.dom takes place through a string, and then the opposite. <br>  The only possible solution is to handle XPath yourself. <br>  At the same time it will allow to get rid of not too convenient typing of functions. <br><br>  Performance when working with w3c.dom can be slightly improved.  XPath is currently compiled from a string, although there is a ready-made object model.  Conversion between object models can speed up XPath creation somewhat. <br><br><h4>  Conclusion </h4><br>  We built XPath into scala without serious problems and limitations. <br>  Variables and functions from the current scope are valid wherever the specification allows them. <br>  When used with w3c.dom and with some modifications, even a minor acceleration is possible due to parsing the expression during compilation. <br><br>  Everything is much simpler.  what it seems at first glance. <br>  At the beginning, the very idea of ‚Äã‚Äãembedding in a compilation is shocking.  The result is achieved with minimal effort. <br>  Yes, the compiler API is documented much worse than the main library, but it is logical and understandable. <br>  Yes, IDEA poorly understands path-dependent types, but it provides very convenient navigation, including the compiler API and takes into account implicit conversions. </div><p>Source: <a href="https://habr.com/ru/post/176285/">https://habr.com/ru/post/176285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176273/index.html">'Clean' javascript: "Continuation"</a></li>
<li><a href="../176277/index.html">Advice on the placement of style markup for individual CMS pages in Magento</a></li>
<li><a href="../176279/index.html">I give the idea of ‚Äã‚Äãa lulz-project</a></li>
<li><a href="../176281/index.html">Checklist of questions to the project: start, implementation, final - and 10 tips "flying"</a></li>
<li><a href="../176283/index.html">HTC 8S - new sensations</a></li>
<li><a href="../176287/index.html">Beta version of Nvidia 319.12 drivers for Linux, FreeBSD and Solaris with Optimus initial support</a></li>
<li><a href="../176291/index.html">Russian Dropbox localization appeared</a></li>
<li><a href="../176295/index.html">How to get a master‚Äôs degree from Carnegie Mellon University for Software Engineering almost free of charge</a></li>
<li><a href="../176297/index.html">Restaurant of the Future: Instant Service Technology</a></li>
<li><a href="../176305/index.html">Globals MUMPS: Extreme Database Programming. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>