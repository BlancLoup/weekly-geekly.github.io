<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2-3-tree. Naive implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I needed to write a 2-3-tree and I began to look for information on the Russian-language Internet. Unfortunately, neither on Habr√©, nor on o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2-3-tree. Naive implementation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/dc2/be5/aebdc2be5f33668dd18eab5dabda6209.png" align="right" width="595">  Recently, I needed to write a 2-3-tree and I began to look for information on the Russian-language Internet.  Unfortunately, neither on Habr√©, nor on other resources, I could not find enough complete information in Russian.  All resources had the same thing: tree properties, how keys are inserted into a tree, search in a tree and sometimes a simple example of how a key is removed from a tree;  there was no implementation. <br><br>  Therefore, after I did what I needed, I decided to write this article.  I think someone will be useful for educational purposes, since in practice they usually implement the equivalent of 2-3- and 2-3-4-trees - <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BD%25D0%25BE-%25D1%2587%25D1%2591%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">red-ebony</a> . <br><a name="habracut"></a><br><h3>  Prologue </h3><br>  Those who know what a <i>binary search tree</i> and its shortcomings can go further are nothing new here. <br><br>  Most programmers (and not only) know such a tree as a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">binary search tree</a> .  This tree has very simple properties: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Both subtrees ‚Äî left and right ‚Äî are binary search trees. </li><li>  All nodes of the left subtree of an arbitrary node X have data key values ‚Äã‚Äãless than the data key value of the node X itself. </li><li>  At the same time, the data key values ‚Äã‚Äãof all nodes of the right subtree (of the same node X) are equal to or larger than the data key value of the node X. </li></ul><br>  Search trees are used when you need to perform a search operation very often.  In the usual search tree there is a very big drawback: when we get sorted data as input, our tree becomes a regular array: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a17/935/9f0/a179359f008bf4d4663344b0deed2588.png" alt="image"><br><br>  And then the <i>search</i> operation will be carried out for the same complexity as in the array, - for O (n), where n is the number of elements in the array. <br><br>  There are several ways to make a normal tree balanced (search has O (log n) complexity).  This is very well written in two articles from the nickme <a href="https://habrahabr.ru/users/nickme/" class="user_link">habrauser</a> : <a href="https://habrahabr.ru/post/145388/">randomized search trees</a> and <a href="https://habrahabr.ru/post/150732/">AVL-trees</a> . <br><br><h3>  General properties of 2-3 trees </h3><br>  Definition from wiki: <br><br>  2-3-tree is a data structure, which is a <a href="https://ru.wikipedia.org/wiki/B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">B-tree of</a> Degree 1, whose pages can contain only 2 vertices (vertices with one field and 2 children) and 3 vertices (vertices with 2 fields and 3 children).  Leaf vertices are an exception - they have no children (but there can be one or two fields).  The 2-3 trees are balanced, that is, each left, right, and central subtree has the same height, and thus contains equal (or almost equal) amounts of data. <br><br>  Properties: <br><br><ul><li>  All non-leaf vertices contain one field and 2 subtrees or 2 fields and 3 subtrees. </li><li>  All leaf vertices are at the same level (at the lower level) and contain 1 or 2 fields. </li><li>  All data is sorted (according to the binary search tree principle). </li><li>  Leafy vertices contain one or two fields indicating the range of values ‚Äã‚Äãin their subtrees.  The value of the first field is strictly greater than the largest value in the left subtree and less than or equal to the smallest value in the right subtree (or in the central subtree if it is 3-vertex);  similarly, the value of the second field (if any) is strictly greater than the largest value in the central subtree and less than or equal to the smallest value in the right subtree.  These non-leaf vertices are used to direct the search function to the desired subtree and, ultimately, to the desired sheet.  <i>This property will not be executed if we have the same keys. Therefore, it is possible that equal keys are in the left and right subtrees at the same time, then the key in the non-leaf vertex will coincide with these keys. This does not affect the correctness of the work and algorithm performance.</i> ). </li></ul><br>  <b>2-3 tree example:</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/702/3e7/ff0/7023e7ff074e25d1c799612dd37b5f94.png" alt="image"><br>  <i>For simplicity, we will use different keys.</i> <br><br><h3>  Tree view in code </h3><br>  I will write on the so-called ‚ÄúC with classes‚Äù, as I myself am a C programmer, but I am madly in love with such things in C ++ as constructors, the presence of class member methods and friendly functions. <br><br>  The vertices of our tree will be represented as 4-vertices (this is when a vertex can have 3 keys and 4 sons).  This solution was chosen for several reasons: firstly, it is easier to make a naive (direct) implementation, and secondly, the code is so strongly framed with if and this solution has reduced the number of checks and simplified code. <br><br>  This is how the vertex view looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Class for a 2-3 tree vertex</b> <div class="spoiler_text"><pre><code class="hljs ruby">struct node { <span class="hljs-symbol"><span class="hljs-symbol">private:</span></span> int size; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    int key[<span class="hljs-number"><span class="hljs-number">3</span></span>]; node *first; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> *first &lt;= key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; node *second; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> key[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= *second &lt; key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; node *third; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> key[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= *third &lt; key[<span class="hljs-number"><span class="hljs-number">2</span></span>]; node *fourth; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> kye[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= *fourth. node *parent; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,         bool find(int k) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   k   ,  <span class="hljs-literal"><span class="hljs-literal">false</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key[i] == k) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } void swap(int &amp;x, int &amp;y) { int r = x; x = y; y = r; } void sort2(int &amp;x, int &amp;y) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) swap(x, y); } void sort3(int &amp;x, int &amp;y, int &amp;z) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) swap(x, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; z) swap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; z) swap(y, z); } void sort() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size == <span class="hljs-number"><span class="hljs-number">2</span></span>) sort2(key[<span class="hljs-number"><span class="hljs-number">0</span></span>], key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size == <span class="hljs-number"><span class="hljs-number">3</span></span>) sort3(key[<span class="hljs-number"><span class="hljs-number">0</span></span>], key[<span class="hljs-number"><span class="hljs-number">1</span></span>], key[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } void insert_to_node(int k) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   k   (  ) key[size] = k; size++; sort(); } void remove_from_node(int k) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   k   (  ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key[<span class="hljs-number"><span class="hljs-number">0</span></span>] == k) { key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; key[<span class="hljs-number"><span class="hljs-number">1</span></span>] = key[<span class="hljs-number"><span class="hljs-number">2</span></span>]; size--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; key[<span class="hljs-number"><span class="hljs-number">1</span></span>] == k) { key[<span class="hljs-number"><span class="hljs-number">1</span></span>] = key[<span class="hljs-number"><span class="hljs-number">2</span></span>]; size--; } } void become_node2(int k, node *first<span class="hljs-number"><span class="hljs-number">_</span></span>, node *second<span class="hljs-number"><span class="hljs-number">_</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>-. key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = k; first = first<span class="hljs-number"><span class="hljs-number">_</span></span>; second = second<span class="hljs-number"><span class="hljs-number">_</span></span>; third = nullptr; fourth = nullptr; parent = nullptr; size = <span class="hljs-number"><span class="hljs-number">1</span></span>; } bool is_leaf() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ;      . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (first == nullptr) &amp;&amp; (second == nullptr) &amp;&amp; (third == nullptr); } <span class="hljs-symbol"><span class="hljs-symbol">public:</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/         node(int k): size(1), key{k, 0, 0}, first(nullptr), second(nullptr), third(nullptr), fourth(nullptr), parent(nullptr) {} node (int k, node *first_, node *second_, node *third_, node *fourth_, node *parent_): size(1), key{k, 0, 0}, first(first_), second(second_), third(third_), fourth(fourth_), parent(parent_) {} friend node *split(node *item); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ; friend node *insert(node *p, int k); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ; friend node *search(node *p, int k); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ; friend node *search_min(node *p); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ; friend node *merge(node *leaf); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ; friend node *redistribute(node *leaf); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ; friend node *fix(node *leaf); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        ( merge  redistribute) friend node *remove(node *p, int k); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   ; };</span></span></code> </pre> <br></div></div><br><h3>  Insert </h3><br>  In order to insert an element with the key key into the tree, you need to act according to the algorithm: <br><br><ol><li>  If the tree is empty, then create a new vertex, insert the key and return this vertex as the root, otherwise </li><li>  If the vertex is a leaf, then we insert the key into this vertex and if we have received 3 keys at the vertex, then we divide it, otherwise </li><li>  Compare the key key with the first key at the top, and if the key is less than the given key, then go to the first subtree and go to step 2, otherwise </li><li>  We look, if a vertex contains only 1 key (is a 2-vertex), then go to the right subtree and go to step 2, otherwise </li><li>  Compare the key key with the second key at the vertex, and if the key is less than the second key, then go to the middle subtree and go to step 2, otherwise </li><li>  Go to the right subtree and go to step 2. </li></ol><br>  For example, insert keys = {1, 2, 3, 4, 5, 6, 7}: <br><br>  When inserting key = 1, we have an empty tree, and then we get a single vertex with a single key, key = 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/44c/971/f9144c97188ac332835f731772617278.png" alt="image"><br><br>  Next, insert key = 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96c/f37/388/96cf37388b7aeedd5665b33359c52659.png" alt="image"><br><br>  Now insert key = 3 and get a vertex containing 3 keys: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec8/5de/353/ec85de35311b190dccca58a5b37f5cee.png" alt="image"><br><br>  Since this vertex violates the properties of 2-3-trees, we must deal with this.  But let's deal with this division: the key that is in the middle (in our case, key = 2), we move it to the parent node to the appropriate place, or if we have a single node in the tree, then it is the root of the tree, which means we create a new vertex and transfer the middle key key = 2 there, and sort the rest of the keys and make them the sons of the new root: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ba/76e/3b4/3ba76e3b4d30c3158ee557f7b6815377.png" alt="image"><br><br>  Then we insert the key = 4 according to the algorithm: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd6/3d8/eaa/bd63d8eaaca9ae4905b5c22986a3284e.png" alt="image"><br><br>  Key = 5: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/821/ab1/2e4/821ab12e4c35e8943991c12914778217.png" alt="image"><br><br>  The properties of 2-3 trees are again broken, we make the separation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f8/858/202/4f88582025b7ed3e530a71677a4bb28e.png" alt="image"><br><br>  Key = 6: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/702/3e7/ff0/7023e7ff074e25d1c799612dd37b5f94.png" alt="image"><br><br>  Key = 7: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fb/43e/672/6fb43e6722823a872a4a802a8ca6d748.png" alt="image"><br><br>  Now we have to make two divisions, because  the vertex into which the new key was inserted now has 3 keys (first we divide it): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c28/1aa/ba5/c281aaba53ca6bc348b59b0db32aa8e9.png" alt="image"><br><br>  And now the root has 3 vertices - divide it and get a balanced tree, which, with such input data with the usual binary search tree, we could not get: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/72a/efc/f5472aefc0821f29f097bf265975ae00.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Key insert</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span> *insert(node *p, int k) { //   k     p;    , ..    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) return new node(k); //   ,    <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span>- () <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p-&gt;is_leaf()) p-&gt;insert_to_node(k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k &lt;= p-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]) insert(p-&gt;first, k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;size == <span class="hljs-number"><span class="hljs-number">1</span></span>) || ((p-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; k &lt;= p-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>])) insert(p-&gt;second, k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> insert(p-&gt;third, k); return split(p); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Split top</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span> *split(node *item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;size &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) return item; node *x = new node(item-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>], item-&gt;first, item-&gt;second, nullptr, nullptr, item-&gt;parent); //    , node *y = new node(item-&gt;key[<span class="hljs-number"><span class="hljs-number">2</span></span>], item-&gt;third, item-&gt;fourth, nullptr, nullptr, item-&gt;parent); //     ,    . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x-&gt;first) x-&gt;first-&gt;parent = x; //   <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x-&gt;second) x-&gt;second-&gt;parent = x; //  , <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>  <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y-&gt;first) y-&gt;first-&gt;parent = y; //     . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y-&gt;second) y-&gt;second-&gt;parent = y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;parent) { item-&gt;parent-&gt;insert_to_node(item-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;parent-&gt;first == item) item-&gt;parent-&gt;first = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;parent-&gt;second == item) item-&gt;parent-&gt;second = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;parent-&gt;third == item) item-&gt;parent-&gt;third = nullptr; //       . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;parent-&gt;first == nullptr) { item-&gt;parent-&gt;fourth = item-&gt;parent-&gt;third; item-&gt;parent-&gt;third = item-&gt;parent-&gt;second; item-&gt;parent-&gt;second = y; item-&gt;parent-&gt;first = x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;parent-&gt;second == nullptr) { item-&gt;parent-&gt;fourth = item-&gt;parent-&gt;third; item-&gt;parent-&gt;third = y; item-&gt;parent-&gt;second = x; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { item-&gt;parent-&gt;fourth = y; item-&gt;parent-&gt;third = x; } node *tmp = item-&gt;parent; delete item; return tmp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x-&gt;parent = item; //        , y-&gt;parent = item; //   <span class="hljs-string"><span class="hljs-string">""</span></span>     . item-&gt;become_node2(item-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>], x, y); return item; } }</code> </pre><br></div></div><br><h3>  Search </h3><br>  The search is as simple as in a binary search tree: <br><br><ol><li>  We are looking for the desired key key in the current vertex; if we find it, we return the vertex, otherwise </li><li>  If key is less than the first key of the vertex, then go to the left subtree and go to step 1, otherwise </li><li>  If there is 1 key in the tree, then we go to the right subtree (average if we are guided by our class) and go to step 1, otherwise </li><li>  If key is less than the second key of the vertex, then go to the middle subtree and go to step 1, otherwise </li><li>  Go to the right subtree and go to step 1. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Key search</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">node *<span class="hljs-keyword"><span class="hljs-keyword">search</span></span>(node *p, <span class="hljs-type"><span class="hljs-type">int</span></span> k) { //   k  <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span>    p. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nullptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p-&gt;find(k)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k &lt; p-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>(p-&gt;first, k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (k &lt; p-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]) || (p-&gt;size == <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>(p-&gt;second, k); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">search</span></span>(p-&gt;third, k); }</code> </pre><br></div></div><br><h3>  Deletion </h3><br>  Deletion in a 2‚Äì3 tree, as in any other tree, occurs only from a leaf (from the lowest top).  Therefore, when we have found the key to be deleted, we first need to check whether this key is in a leaf or non-leaf vertex.  If the key is in a non-leaf vertex, then you need to find an equivalent key for the key being removed from the leaf vertex and swap them.  There are two options for finding the equivalent key: either find the maximum element in the left subtree, or find the minimum element in the right subtree.  Let's choose the second option, as I like it more.  For example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/72a/efc/f5472aefc0821f29f097bf265975ae00.png" alt="image"><br><br>  To remove the key = 4 from the tree, first we need to find the equivalent emu element and swap them: this is either key = 3 or key = 5.  Since I selected the second method, I change the keys key = 4 and key = 5 in places and delete key = 4 from the sheet (‚Äúdash‚Äù will indicate the location of the key that we deleted): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/564/b0c/74c/564b0c74cc5d132d0b015569ac9fdc13.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Minimum Key Search</b> <div class="spoiler_text"><pre> <code class="hljs ruby">node *search_min(node *p) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">3</span></span>-   p. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(p-&gt;first)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> search_min(p-&gt;first); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Key removal</b> <div class="spoiler_text"><pre> <code class="hljs lua">node *<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(node *p, int k) { //   k  <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span>-   p. node *item = search(p, k); //  ,    k <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!item) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; node *<span class="hljs-built_in"><span class="hljs-built_in">min</span></span> = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] == k) <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> = search_min(item-&gt;second); //    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> = search_min(item-&gt;third); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>) { //    int &amp;z = (k == item-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] ? item-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] : item-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); item-&gt;swap(z, <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); item = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>; //    , .. <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> -   } item-&gt;remove_from_node(k); //       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fix(item); //      . }</code> </pre><br></div></div><br>  After the key has been removed, we can get 4 different situations conceptually: 3 of them violate the properties of the tree, and one does not.  Therefore, for the vertex from which the key was deleted, you need to call the fix () fix function, which will return the properties of 2-3 trees.  The cases that are described in the function are discussed below. <br><br><div class="spoiler">  <b class="spoiler_title">Repair the tree after removing the key</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">node</span></span> *fix(node *leaf) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;size == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; leaf-&gt;parent == nullptr) { //  <span class="hljs-number"><span class="hljs-number">0</span></span>,       delete leaf; return nullptr; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;size != <span class="hljs-number"><span class="hljs-number">0</span></span>) { //  <span class="hljs-number"><span class="hljs-number">1</span></span>,  ,    ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;parent) return fix(leaf-&gt;parent); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> return leaf; } node *parent = leaf-&gt;parent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent-&gt;first-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span> || parent-&gt;second-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span> || parent-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) leaf = redistribute(leaf); //  <span class="hljs-number"><span class="hljs-number">2</span></span>,       <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; parent-&gt;third-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) leaf = redistribute(leaf); //  <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> leaf = merge(leaf); //  <span class="hljs-number"><span class="hljs-number">3</span></span>,                return fix(leaf); }</code> </pre><br></div></div><br>  We now turn to possible options that may appear after removing the key.  For simplicity, we will consider cases where the depth of the tree is 2. The general case is a tree with a depth of three.  Then it will be clear how to cope with the removal of the key in the tree with any depth.  What we will do in the final example for most situations.  In the meantime, proceed to the special cases. <br><br>  <i>Case 0:</i> <br><br>  The simplest case, as well as the following, for which one sentence is enough to understand: if a tree consists of one vertex (root), which has 1 key, then simply delete this vertex.  The end. <br><br>  <i>Case 1:</i> <br><br>  If you want to remove the key from the sheet where the two keys are located, then we simply delete the key and this completes the delete function. <br>  Remove key = 4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/7ba/993/3a87ba9939a33049c2d147c65a6a94ac.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/a91/d45/7e1/a91d457e1072b1f8c6af86b19abdf4c8.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/cef/2d8/27c/cef2d827c6083898d1a11c8fd2973bc6.png" alt="image"><br><br>  <i>Case 2 (distribution or <b>redistribute</b> ):</i> <br><br>  We remove the key from the vertex and the vertex becomes empty.  If at least one of the brothers has 2 keys, then we make a simple <u>correct</u> distribution and the work is completed.  By the correct distribution, I mean that when cycling the keys between the parent and the sons, the <b>grandchildren of the</b> parent will also need to be moved.  You can redistribute the keys from any brother, but it is most convenient from the neighbor, which has 2 keys, while we cyclically shift all the keys, for example, from the example below, remove key = 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a8/7ba/993/3a87ba9939a33049c2d147c65a6a94ac.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/b77/e46/59a/b77e4659a1f7eccdabe2afd54ef2d835.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/b37/dc6/bed/b37dc6bedac299ae40c492f8e6cad559.png" alt="image"><br><br>  Or here's a second example: our parent has 2 keys, respectively, 3 sons, and we will delete key = 4.  Redistribution in our example can be done both from the left brother and from the right one;  I chose from the left: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e27/d55/e26/e27d55e260503733c84723844cb8e4b7.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/6ec/c8b/64b/6ecc8b64b236495468a8624c6febbf78.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/4ca/97f/30c/4ca97f30cbb9220e849e4cb4c262ae9c.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/5d7/163/919/5d71639195082a2e66bfb6c0ef0373a3.png" alt="image">  -&gt; <br><br>  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/701/b96/9a8/701b969a80d993ed6c11fb951caacc11.png" alt="image"><br><br>  As you can see, the properties of the tree saved. <br><br><div class="spoiler">  <b class="spoiler_title">Redistribution</b> <div class="spoiler_text"><pre> <code class="hljs php">node *redistribute(node *leaf) { node *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = leaf-&gt;parent; node *first = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first; node *second = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second; node *third = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;third; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (first-&gt;size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (second-&gt;size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (third-&gt;size &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first == leaf) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;third; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;third = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;third = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;second = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;first = leaf-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;first = leaf-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;first != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;first-&gt;parent = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;remove_from_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); delete first; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second == leaf) { first-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;remove_from_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) first-&gt;third = leaf-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second != nullptr) first-&gt;third = leaf-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;third != nullptr) first-&gt;third-&gt;parent = first; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;third; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;third = nullptr; delete second; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (third == leaf) { second-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;third = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;remove_from_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) second-&gt;third = leaf-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second != nullptr) second-&gt;third = leaf-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;third != nullptr) second-&gt;third-&gt;parent = second; delete third; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; ((first-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) || (second-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) || (third-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (third == leaf) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) { leaf-&gt;second = leaf-&gt;first; leaf-&gt;first = nullptr; } leaf-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>] = second-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; second-&gt;remove_from_node(second-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); leaf-&gt;first = second-&gt;third; second-&gt;third = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) leaf-&gt;first-&gt;parent = leaf; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>] = second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; leaf-&gt;first = second-&gt;second; second-&gt;second = second-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) leaf-&gt;first-&gt;parent = leaf; second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = first-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; first-&gt;remove_from_node(first-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); second-&gt;first = first-&gt;third; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;first != nullptr) second-&gt;first-&gt;parent = second; first-&gt;third = nullptr; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second == leaf) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (third-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first == nullptr) { leaf-&gt;first = leaf-&gt;second; leaf-&gt;second = nullptr; } second-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>] = third-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; third-&gt;remove_from_node(third-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); second-&gt;second = third-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;second != nullptr) second-&gt;second-&gt;parent = second; third-&gt;first = third-&gt;second; third-&gt;second = third-&gt;third; third-&gt;third = nullptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second == nullptr) { leaf-&gt;second = leaf-&gt;first; leaf-&gt;first = nullptr; } second-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = first-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; first-&gt;remove_from_node(first-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); second-&gt;first = first-&gt;third; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;first != nullptr) second-&gt;first-&gt;parent = second; first-&gt;third = nullptr; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first == leaf) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first == nullptr) { leaf-&gt;first = leaf-&gt;second; leaf-&gt;second = nullptr; } first-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; second-&gt;remove_from_node(second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); first-&gt;second = second-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;second != nullptr) first-&gt;second-&gt;parent = first; second-&gt;first = second-&gt;second; second-&gt;second = second-&gt;third; second-&gt;third = nullptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (third-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>] = third-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; third-&gt;remove_from_node(third-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); first-&gt;second = second-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first-&gt;second != nullptr) first-&gt;second-&gt;parent = first; second-&gt;first = second-&gt;second; second-&gt;second = third-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second-&gt;second != nullptr) second-&gt;second-&gt;parent = second; third-&gt;first = third-&gt;second; third-&gt;second = third-&gt;third; third-&gt;third = nullptr; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;size == <span class="hljs-number"><span class="hljs-number">1</span></span>) { leaf-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first == leaf &amp;&amp; second-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]; second-&gt;remove_from_node(second-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first == nullptr) leaf-&gt;first = leaf-&gt;second; leaf-&gt;second = second-&gt;first; second-&gt;first = second-&gt;second; second-&gt;second = second-&gt;third; second-&gt;third = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second != nullptr) leaf-&gt;second-&gt;parent = leaf; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (second == leaf &amp;&amp; first-&gt;size == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>] = first-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]; first-&gt;remove_from_node(first-&gt;key[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second == nullptr) leaf-&gt;second = leaf-&gt;first; leaf-&gt;first = first-&gt;third; first-&gt;third = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) leaf-&gt;first-&gt;parent = leaf; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>; }</code> </pre><br></div></div><br>  <i>Case 3 (bonding or <b>merge</b> ):</i> <br><br>  Perhaps the most difficult case, since after gluing it is always necessary to go up the tree and again apply operations either <i>merge</i> or <i>redistribute</i> .  After redistribute, the algorithm for restoring 2-3-tree properties after deleting a key can be terminated, since the vertices in this operation are not deleted. <br><br>  First, let's see how to remove key = 3 from a node whose parent has only two sons (~ 1 key): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ba/76e/3b4/3ba76e3b4d30c3158ee557f7b6815377.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/fad/5e9/5dc/fad5e95dc82f9bf30d7dc13835faba20.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/e1e/bb3/4a4/e1ebb34a46b0a73f322d2d16914a7e99.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/afb/6d3/c00/afb6d3c00330341c1e0040babc8679b6.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/d2a/181/70d/d2a18170d28c1c17dc5aef9c6580f9e1.png" alt="image"><br><br>  What have we done?  We removed the key key = 3.  Then we need to transfer the key from the parent to the son where the key is: in this case, the left son.  Then you need to remove the vertex from which the key was removed.  And the last step is to check if the parent was the root of the tree, then delete this root and assign the new root to the vertex where we transferred the key, otherwise you will have to call the fix () fix function for the parent.  It looks easy. <br><br>  Now consider two options when the parent has 2 keys.  In the first variant, remove key = 3 (from the middle son): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/496/f27/840/496f278406aa02202a16daa292936a87.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/0a6/10f/0a6/0a610f0a6bb58358b27fbcbe65020e0f.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/e4c/30a/cf4/e4c30acf420b556f699d90d33fc82dfd.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/1f0/ba5/70b/1f0ba570b50df31de22ce0cf1c9ed596.png" alt="image"><br><br>  What have we done this time?  We again transferred the key of the parent (already one of the two) to the son and removed the son who does not have the keys.  Since the parent had 2 keys, it is not necessary to check whether the parent was a root.  In the case described above, the correction algorithm is as follows: you need to transfer a smaller parent key to a subtree with smaller keys or a larger key to a subtree with larger keys, and delete the top without keys.  Another example, remove key = 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1b/ad5/166/f1bad5166566ce884ee9a2005606bd09.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/387/879/a56/387879a56e8e723a4f57ab7cf530bffe.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/359/c60/fd1/359c60fd168b029f982d94d8ade2e9c8.png" alt="image">  -&gt; <img src="https://habrastorage.org/getpro/habr/post_images/8ac/c9d/78d/8acc9d78dd110538d73dff9331044a0c.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Gluing</b> <div class="spoiler_text"><pre> <code class="hljs php">node *merge(node *leaf) { node *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = leaf-&gt;parent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first == leaf) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;third = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;second = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;first = leaf-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;first = leaf-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;first != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second-&gt;first-&gt;parent = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;remove_from_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); delete <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first = nullptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second == leaf) { <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;insert_to_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;first != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;third = leaf-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leaf-&gt;second != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;third = leaf-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;third != nullptr) <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first-&gt;third-&gt;parent = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;remove_from_node(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;key[<span class="hljs-number"><span class="hljs-number">0</span></span>]); delete <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second = nullptr; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;parent == nullptr) { node *tmp = nullptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first != nullptr) tmp = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;first; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tmp = <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>-&gt;second; tmp-&gt;parent = nullptr; delete <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>; }</code> </pre><br></div></div><br>  <b>!</b>  <b>Important!</b>  <b>When gluing or redistributing a non-leaf top, you will also need to glue and / or redistribute the sons of the brothers.</b> <br><br>  <i>Final example of deleting keys:</i> <br><br>  I picked an example so that you can see all the main cases (except for <i>case 0</i> ).  First, insert the keys keys = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 5, 15, 25, 8} into an empty tree and get : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bf/124/cd7/4bf124cd708ac95eb430c7d464a4bfed.png" alt="image"><br><br>  Now we will delete in order the keys keys = {5, 8, 10, 30, 15}. <br><br>  After removing key = 5, we get: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f55/a58/d33/f55a58d338cdf3edc0665827fb90d341.png" alt="image"><br><br>  Delete key = 8: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/547/761/ad6/547761ad62f90e4ee1d256be4d32012b.png" alt="image"><br><br>  Now key = 10: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7fa/d5c/666/7fad5c666df31f87f3d09d91faa86f91.png" alt="image"><br><br>  Key = 30: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0f/ca7/e2c/e0fca7e2c64e5f3258f6c963faa98f8d.png" alt="image"><br><br>  And finally, key = 15.  Since this is where the merge operation occurs when the tree is corrected, we will look at all the steps. <br><br>  Step 1. View the tree immediately after the first call to fix (): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/462/747/beb/462747beb2d0c9f598f9c8ff065136f0.png" alt="image"><br><br>  Step 2. Second fix () call: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e74/b44/551/e74b445510d61bfc3b3c0e9ac98baa1a.png" alt="image"><br><br>  Step 3. Third fix () call: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/819/a3a/0e3/819a3a0e3118817a70cb4f0f32ee5a3e.png" alt="image"><br><br>  Step 4. Last fix () call: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/280/6cf/b47/2806cfb470129319bf910651c98606bb.png" alt="image"><br><br>  This is how we removed the key key = 15 and the tree was left with the properties it should be with. <br><br>  <b>That's all, thank you for your attention.</b> </div><p>Source: <a href="https://habr.com/ru/post/303374/">https://habr.com/ru/post/303374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303364/index.html">As an sql query, retrieve information from the database that is not there.</a></li>
<li><a href="../303366/index.html">REST API on Symfony, FOSRestBundle + GlavwebDatagridBundle</a></li>
<li><a href="../303368/index.html">We write a serializer for a network game in C ++ 11</a></li>
<li><a href="../303370/index.html">Tony Robbins seminar review ‚ÄúFree your inner strength‚Äù. Day 4. The power of clean energy (part 2)</a></li>
<li><a href="../303372/index.html">Connect MATLAB to Wolfram Mathematica</a></li>
<li><a href="../303376/index.html">CodeRush for Roslyn: Part 2 - feature overview for better code</a></li>
<li><a href="../303378/index.html">Determine the Phantom bots</a></li>
<li><a href="../303380/index.html">Not Pascal alone: ‚Äã‚Äãwhat did the winner of the computer "Nobel Prize" Niklaus Wirth do for the modern world?</a></li>
<li><a href="../303382/index.html">From blacklists to intelligent call management</a></li>
<li><a href="../303386/index.html">inter-AS Option AB (D)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>