<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Running SSH commands on hundreds of servers using Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the article about 
 In this article, we will write a simple Go program (100 lines long) that can execute commands via the SSH protocol on hund...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Running SSH commands on hundreds of servers using Go</h1><div class="post__text post__text-html js-mediator-article"><h4>  What is the article about </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/6bd/5cb/38a6bd5cb2e1446c3921f92f32e5541d.jpg" align="right">  In this article, we will write a simple Go program (100 lines long) that can execute commands via the SSH protocol on hundreds of servers, making it quite effective.  The program will be implemented using <a href="https://godoc.org/code.google.com/p/go.crypto/ssh">go.crypto / ssh</a> , an implementation of the SSH protocol by the authors of Go. <br><br>  A more ‚Äúadvanced‚Äù version of the program written in this article is available on the githab called <a href="https://github.com/YuriyNasretdinov/GoSSHa">GoSSHa</a> (Go SSH agent). <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  In the company in which I work, a little more than 1 server, and to work effectively with our number of servers using the SSH protocol, the library <a href="https://github.com/badoo/libpssh">libpssh</a> was written based on libssh2.  This library was written in C using libevent many years ago, and still copes well with its responsibilities, but is very difficult to maintain.  Also, Google‚Äôs Go language began to gain popularity, including within our company, so I decided to try writing a replacement for libpssh with Go, and fix some of its flaws, while at the same time greatly simplifying the code and the complexity of support. <br><br>  To get started, we will need the Go compiler (available at <a href="http://golang.org/">golang.org</a> ) and the working hg command to download go.crypto / ssh using ‚Äúgo get‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Beginning of work </h4><br>  Create a file "main.go" in some directory, preferably empty.  Let's now write the ‚Äúframework‚Äù of our program, and then implement the missing functions in the course of the article: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"code.google.com/p/go.crypto/ssh"</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... ) // ... func main() { cmd := os.Args[1] //   - ,       hosts := os.Args[2:] //   (  ) -   results := make(chan string, 10) //        timeout := time.After(5 * time.Second) //  5    timeout   //       ssh.  makeKeyring()   config := &amp;ssh.ClientConfig{ User: os.Getenv("LOGNAME"), Auth: []ssh.ClientAuth{makeKeyring()}, } //    goroutine (  OS thread)  ,  executeCmd()   for _, hostname := range hosts { go func(hostname string) { results &lt;- executeCmd(cmd, hostname, config) }(hostname) } //     ,   "Timed out",      for i := 0; i &lt; len(hosts); i++ { select { case res := &lt;-results: fmt.Print(res) case &lt;-timeout: fmt.Println("Timed out!") return } } }</span></span></code> </pre> <br><br>  Apart from the fact that we need to write the functions makeKeyring () and executeCmd (), our program is ready!  Thanks to the ‚Äúmagic of Go‚Äù we will establish a connection to all servers in parallel and execute the specified command on them, and in any case we will finish in 5 seconds by printing the results from all the servers that have managed to execute.  Such a simple way of implementing a common timeout for all concurrently executing operations is possible thanks to the concept of channels and the presence of a select construct that allows you to communicate simultaneously between several channels: as soon as at least one of the structures in the case can be executed, the corresponding block of code will be executed. <br><br><h4>  Initializing data structures for go.crypto / ssh </h4><br>  We have not yet written makeKeyring () and executeCmd (), but most likely you will not see anything much interesting here.  We will only log in using SSH keys and assume that the keys are located in .ssh / id_rsa or .ssh / id_dsa: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> SignerContainer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { signers []ssh.Signer } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SignerContainer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key ssh.PublicKey, err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(t.signers) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } key = t.signers[i].PublicKey() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SignerContainer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rand io.Reader, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sig []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(t.signers) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } sig, err = t.signers[i].Sign(rand, data) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSigner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(keyname </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signer ssh.Signer, err error)</span></span></span></span> { fp, err := os.Open(keyname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fp.Close() buf, _ := ioutil.ReadAll(fp) signer, _ = ssh.ParsePrivateKey(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeKeyring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssh</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClientAuth</span></span></span></span> { signers := []ssh.Signer{} keys := []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) + <span class="hljs-string"><span class="hljs-string">"/.ssh/id_rsa"</span></span>, os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) + <span class="hljs-string"><span class="hljs-string">"/.ssh/id_dsa"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, keyname := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> keys { signer, err := makeSigner(keyname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { signers = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(signers, signer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ssh.ClientAuthKeyring(&amp;SignerContainer{signers}) }</code> </pre><br><br>  As you can see, we are returning the ssh.ClientAuth interface, which has the necessary methods for authorization on the server.  For brevity, error handling is almost completely absent; in production-mode, the amount of code will be 1.5 times larger. <br><br>  To execute the command on the server, the code is also quite trivial (error handling is dropped for brevity): <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeCmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmd, hostname </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, config *ssh.ClientConfig)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { conn, _ := ssh.Dial(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, hostname+<span class="hljs-string"><span class="hljs-string">":22"</span></span>, config) session, _ := conn.NewSession() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> session.Close() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stdoutBuf bytes.Buffer session.Stdout = &amp;stdoutBuf session.Run(cmd) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hostname + <span class="hljs-string"><span class="hljs-string">": "</span></span> + stdoutBuf.String() }</code> </pre><br><br>  For simplicity and brevity, we always use the current username for authorization on servers, as well as port 22 by default. <br><br>  Our program is ready!  The full source code of the program is under the spoiler: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"code.google.com/p/go.crypto/ssh"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> SignerContainer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { signers []ssh.Signer } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SignerContainer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Key</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key ssh.PublicKey, err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(t.signers) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } key = t.signers[i].PublicKey() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SignerContainer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rand io.Reader, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sig []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(t.signers) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } sig, err = t.signers[i].Sign(rand, data) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSigner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(keyname </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(signer ssh.Signer, err error)</span></span></span></span> { fp, err := os.Open(keyname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fp.Close() buf, _ := ioutil.ReadAll(fp) signer, _ = ssh.ParsePrivateKey(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeKeyring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ssh</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClientAuth</span></span></span></span> { signers := []ssh.Signer{} keys := []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) + <span class="hljs-string"><span class="hljs-string">"/.ssh/id_rsa"</span></span>, os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) + <span class="hljs-string"><span class="hljs-string">"/.ssh/id_dsa"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, keyname := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> keys { signer, err := makeSigner(keyname) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { signers = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(signers, signer) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ssh.ClientAuthKeyring(&amp;SignerContainer{signers}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeCmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmd, hostname </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, config *ssh.ClientConfig)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { conn, _ := ssh.Dial(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, hostname+<span class="hljs-string"><span class="hljs-string">":22"</span></span>, config) session, _ := conn.NewSession() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> session.Close() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stdoutBuf bytes.Buffer session.Stdout = &amp;stdoutBuf session.Run(cmd) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hostname + <span class="hljs-string"><span class="hljs-string">": "</span></span> + stdoutBuf.String() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cmd := os.Args[<span class="hljs-number"><span class="hljs-number">1</span></span>] hosts := os.Args[<span class="hljs-number"><span class="hljs-number">2</span></span>:] results := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) timeout := time.After(<span class="hljs-number"><span class="hljs-number">5</span></span> * time.Second) config := &amp;ssh.ClientConfig{ User: os.Getenv(<span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>), Auth: []ssh.ClientAuth{makeKeyring()}, } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, hostname := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> hosts { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hostname </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { results &lt;- executeCmd(cmd, hostname, config) }(hostname) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(hosts); i++ { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> res := &lt;-results: fmt.Print(res) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-timeout: fmt.Println(<span class="hljs-string"><span class="hljs-string">"Timed out!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } }</code> </pre><br></div></div><br>  Run our application: <br><br><pre> <code class="bash hljs">$ vim main.go <span class="hljs-comment"><span class="hljs-comment">#   :) $ go get #    $ time go run main.go 'hostname -f; sleep 4.7' localhost srv1 srv2 localhost: localhost srv1: srv1 Timed out! real 0m5.543s</span></span></code> </pre><br><br>  Works!  The localhost, srv1 and srv2 servers had only 0.3 seconds to execute all the commands, and the slow srv2 did not have time.  Together with the compilation of the program on the fly from source, the execution of the program took 5.5 seconds, of which 5 seconds is our default timeout for executing the command. <br><br><h4>  Conclusion </h4><br>  The article turned out to be short, but at the same time we wrote a very useful application that you can safely use in production.  We tested the more advanced version of this application in the production environment and it showed excellent results. <br><br><h4>  References: </h4><br>  1. Go language: <a href="http://golang.org/">golang.org</a> <br>  2. <a href="https://godoc.org/code.google.com/p/go.crypto/ssh">go.crypto</a> library: <a href="https://code.google.com/p/go/source/checkout%3Frepo%3Dcrypto">code.google.com/p/go/source/checkout?repo=crypto</a> <br>  3. GoSSHa (SSH-proxy with communication with the outside world via JSON): <a href="https://github.com/YuriyNasretdinov/GoSSHa">github.com/YuriyNasretdinov/GoSSHa</a> </div><p>Source: <a href="https://habr.com/ru/post/215111/">https://habr.com/ru/post/215111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215101/index.html">On the features of the implementation of prefix entropy coding for large alphabets</a></li>
<li><a href="../215103/index.html">How to make friends LO and MSO. Part 2: Automatic test generation for docx and odt</a></li>
<li><a href="../215105/index.html">Games with UEFI</a></li>
<li><a href="../215107/index.html">A plugin that adds tabs to QtCreator</a></li>
<li><a href="../215109/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ99 (March 2 - 8, 2014)</a></li>
<li><a href="../215115/index.html">The tale of the lost Moscow time, or what were the wrong guys from Microsoft</a></li>
<li><a href="../215117/index.html">Simple language about HTTP</a></li>
<li><a href="../215119/index.html">Things everyone should do: Code Review</a></li>
<li><a href="../215121/index.html">Information and technological tools for the practical survival of social communities in the context of the Internet shutdown in 2014</a></li>
<li><a href="../215123/index.html">Two Bit Idiot Threatens Bitcoin Foundation Board of Directors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>