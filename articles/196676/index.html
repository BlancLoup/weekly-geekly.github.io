<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our JSON parser (with polka dots and pearl buttons)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was written by Aaron Patterson, a Ruby developer from Seattle, WA. He has been passionate about developing in Ruby for 7 years now and wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our JSON parser (with polka dots and pearl buttons)</h1><div class="post__text post__text-html js-mediator-article">  <i>This article was written by Aaron Patterson, a Ruby developer from Seattle, WA.</i>  <i>He has been passionate about developing in Ruby for 7 years now and will be happy to share his love for this wonderful language.</i> <br><br>  Salute to all!  Hope you have a great mood.  Today, the sun briefly peeped out from behind the clouds, so that for me everything is just fine! <br><br>  In this article, we will look at a series of compilation tools for use in conjunction with Ruby.  And to dive into the subject, we write a JSON parser.  Already I hear disgruntled exclamations like: ‚Äúwell, Aaron, well, why?  Are not 1,234,567 pieces already written? ‚ÄùThat's it!  We already have 1,234,567 JSON parsers written in Ruby!  And we will also analyze JSON, because its grammar is simple enough to complete the work at a time, and because it is nevertheless difficult enough to use the compilation tools developed for Ruby wisely. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before you continue reading, I want to draw attention to the fact that this is not an article on how to analyze JSON, but on how to use analysis and compilation tools in Ruby. <br><a name="habracut"></a><br><h2>  What we need </h2><br>  I will test on Ruby 1.9.3, but it should work on any implementation you choose.  Mostly we will use tools like <code>Racc</code> and <code>StringScanner</code> . <br><br><h5>  Racc: </h5><br>  Racc will be needed for us to automatically generate the analyzer.  This LALR analyzer generator is much like YACC.  The last abbreviation stands for ‚ÄúYet Another Compiler Compiler‚Äù (another compiler compiler), but since this is a version for Ruby, it turned out Racc.  Racc is committed to converting a set of grammar rules (a file with a <code>.y</code> extension) into a Ruby file that describes transition rules for a finite state machine.  The latter are interpreted by the state machine (runtime environment) Racc.  The runtime comes with Ruby, but it doesn‚Äôt have the tool that converts files with the extension ".y" into automaton state tables.  Install it by running <code>gem install racc</code> . <br><br>  Hereinafter we will be engaged in writing ".y" files, however, end users will not be able to run them.  To do this, you first need to convert them into Ruby executable code, and then package this code into our gem.  In essence, this means that only we will install gem Racc, and end users will not need it. <br><br>  Do not worry if all this does not fit in your head.  Everything will become clear when we move from theory to practice and start writing code. <br><br><h5>  StringScanner: </h5><br>  <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html">StringScanner</a> is a class that (as the name implies) allows you to process strings sequentially, according to the scanner principle.  It stores information about where we are in the line and allows us to move from beginning to end using regular expressions and direct reading of characters. <br><br>  Let's get started!  First, create a <code>StringScanner</code> object and process several characters with it: <br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">irb(main):001:0&gt;</span></span> require <span class="hljs-string"><span class="hljs-string">'strscan'</span></span> =&gt; true irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">002</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss = StringScanner.new <span class="hljs-string"><span class="hljs-string">'aabbbbb'</span></span> =&gt; #&lt;StringScanner 0/7 @ "aabbb..."&gt; irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">003</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss.scan /a/ =&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">004</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss.scan /a/ =&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">005</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss.scan /a/ =&gt; nil irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">006</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss =&gt; #&lt;StringScanner 2/7 "aa" @ "bbbbb"&gt; irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">007</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt;</code> </pre><br>  Notice that the third call to <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html">StringScanner # scan</a> returned <code>nil</code> , since the regular expression in this position no longer suits.  As well as the fact that when <code>inspect</code> is called for an instance of <code>StringScanner</code> , you can see the current position of the handler in the string (in this case, <code>2/7</code> ). <br><br>  The handler can also be moved character by character using <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/strscan/rdoc/StringScanner.html">StringScanner # getch</a> : <br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">irb(main):006:0&gt;</span></span> ss =&gt; #&lt;StringScanner 2/7 "aa" @ "bbbbb"&gt; irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">007</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss.getch =&gt; <span class="hljs-string"><span class="hljs-string">"b"</span></span> irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">00</span></span>8<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; ss =&gt; #&lt;StringScanner 3/7 "aab" @ "bbbb"&gt; irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">00</span></span>9<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt;</code> </pre><br>  The <code>getch</code> method returns the next character and shifts the pointer one forward. <br><br>  Now that we have dealt with the basics of sequential processing, let's see how Racc is used. <br><br><h2>  Racc Basics </h2><br>  As I said, the Racc is a LALR analyzer generator.  We can assume that this is a mechanism that allows you to create a limited set of regular expressions, which in turn can execute arbitrary code in different positions in the process of how they are matched. <br><br>  Let's take an example.  Suppose we want to check the substitutions of a regular expression of the form: <code>(a|c)*abb</code> .  In other words, register cases where an arbitrary number of 'a' or 'c' characters is followed by 'abb'.  To translate this into a Racc grammar, we will try to break this regular expression into its constituent parts, and then we will put it together again.  Each individual grammar element is called a generating rule or product.  So, we break this expression into pieces to see what the products look like and what is the format of the Racc grammar. <br><br>  First, create a grammar file.  At the beginning of the file comes the declaration of the Ruby class that we want to receive, followed by the keyword <code>rule</code> meaning that we are going to declare the products, followed by the <code>end</code> keyword, indicating their end: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Now add products for ‚Äúa | c‚Äù.  Let's call it <code>a_or_c</code> : <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> a_or_c : <span class="hljs-string"><span class="hljs-string">'a'</span></span> | <span class="hljs-string"><span class="hljs-string">'c'</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  As a result, we have a rule <code>a_or_c</code> , which performs a comparison with the symbol 'a' or 'c'.  In order to perform the mapping one or more times, we will create recursive output, which we call <code>a_or_cs</code> : <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> a_or_cs : a_or_cs a_or_c | a_or_c ; a_or_c : <span class="hljs-string"><span class="hljs-string">'a'</span></span> | <span class="hljs-string"><span class="hljs-string">'c'</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  As I said, <code>a_or_cs</code> output is recursive, being equivalent to the regular expression <code>(a|c)+</code> .  Next, add products for 'abb': <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> a_or_cs : a_or_cs a_or_c | a_or_c ; a_or_c : <span class="hljs-string"><span class="hljs-string">'a'</span></span> | <span class="hljs-string"><span class="hljs-string">'c'</span></span> ; abb : <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  And complete all the string output: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> string : a_or_cs abb | abb ; a_or_cs : a_or_cs a_or_c | a_or_c ; a_or_c : <span class="hljs-string"><span class="hljs-string">'a'</span></span> | <span class="hljs-string"><span class="hljs-string">'c'</span></span> ; abb : <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  This final output performs pattern matching, in which one or more characters 'a' or 'c' are followed by 'abb' or else there is a free-standing line 'abb'.  All of this is equivalent to our original regular expression of the form <code>(a|c)*abb</code> . <br><br><h5>  Aaron, but it is so tedious! </h5><br>  I know this is much longer than a regular regular expression.  But there is one plus: we can add and execute arbitrary Ruby code in any part of the matching process.  For example, each time we get a freestanding line 'abb' we can output something like this: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> string : a_or_cs abb | abb { puts " abb, !" } ; a_or_cs : a_or_cs a_or_c | a_or_c ; a_or_c : <span class="hljs-string"><span class="hljs-string">'a'</span></span> | <span class="hljs-string"><span class="hljs-string">'c'</span></span> ; abb : <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The code that we want to execute must be enclosed in curly brackets and located immediately after the rule that will be responsible for its launch.  Now we are ready to arm our knowledge with creating our own JSON analyzer, which in our case will be event-based. <br><br><h2>  We create an analyzer </h2><br>  Our analyzer will consist of three component parts: the parser, the lexical analyzer, and the document processor.  The parser based on the Racc grammar will refer to the lexical analyzer for data from the input stream.  Every time when the parser manages to isolate the JSON element from the general data stream, it sends the corresponding event to the document handler.  The document processor is responsible for collecting data from JSON and translating it into a data structure in Ruby.  In the process of analyzing the source data in JSON format, calls will be made as shown in the graph below: <br><img src="https://habrastorage.org/getpro/habr/post_images/627/fe6/5a4/627fe65a48779e9c3b754e599cf55bfb.png"><br>  However, let's get down to business.  First we will focus on the lexical analyzer, then we will do the grammar of the parser and finally complete the process by creating a document handler. <br><br><h2>  Lexical analyzer </h2><br>  Our lexical analyzer is built on an IO object.  It is from it that we will read the source data.  For each <code>next_token</code> call <code>next_token</code> lexical analyzer reads one token from the input data stream and returns it.  It will work with the following list of tokens, which we borrowed from the <a href="http://www.json.org/">JSON</a> specifications: <br><br><ul><li>  Strings </li><li>  Numbers </li><li>  True </li><li>  False (False) </li><li>  Null (No value) </li></ul><br>  For complex types like arrays and objects, the parser will be responsible. <br><br><h5>  Values ‚Äã‚Äãreturned by <code>next_token</code> : </h5><br>  When the parser calls the <code>next_token</code> lexical analyzer, it expects to result in an array of two elements or <code>nil</code> .  The first element of the array must contain the name of the lexeme, and the second can be anything (usually it is just mapped text).  Returning <code>nil</code> lexical analyzer reports that there are no more tokens. <br><br><h5>  <code>Tokenizer</code> lexical analyzer <code>Tokenizer</code> : </h5><br>  Let's look at the code of the class and analyze what it does: <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tokenizer</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">STRING</span></span></span><span class="hljs-class"> = /"(?:[^"\\]|\\(?:["\\\/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bfnrt</span></span></span><span class="hljs-class">]|</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class">[0-9</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fA</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">]{4}))*"/ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NUMBER</span></span></span><span class="hljs-class"> = /-?(?:0|[1-9]\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d</span></span></span><span class="hljs-class">*)(?:\.\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d</span></span></span><span class="hljs-class">+)?(?:[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eE</span></span></span><span class="hljs-class">][+-]?\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d</span></span></span><span class="hljs-class">+)?/ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRUE</span></span></span><span class="hljs-class"> = /</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class">/ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FALSE</span></span></span><span class="hljs-class"> = /</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">false</span></span></span><span class="hljs-class">/ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class"> = /</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">/ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringScanner</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">read</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_token</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eos?</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">when</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> = @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">STRING</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">then</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">STRING</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">when</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> = @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NUMBER</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">then</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NUMBER</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">when</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> = @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRUE</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">then</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRUE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">when</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> = @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FALSE</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">then</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FALSE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">when</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class"> = @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">then</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">text</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> = @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ss</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getch</span></span></span><span class="hljs-class"> [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  First come the declarations of several regular expressions, which we will use in conjunction with the StringScanner string handler.  They are built on the basis of definitions taken from <a href="http://www.json.org/">json.org</a> .  An instance of StringScanner is created in the constructor.  Since it requires a string when it is created, we call the read object IO.  This, however, does not exclude an alternative implementation, in which the lexical analyzer reads data from an IO object not entirely, but as needed. <br><br>  The main work is done in the <code>next_token</code> method.  It returns <code>nil</code> if there is no more data in the line processor, otherwise it will check every regular expression until it finds a suitable one.  If a match was found, it will return the name of the token (for example <code>:STRING</code> ) along with the text that matched the pattern.  If none of the regular expressions matches, one character will be read from the handler, and the read value will be returned at the same time as the name of the token and its value. <br><br>  Let's give the lexical analyzer an example of a string in JSON format and see what lexemes we get at the output: <br><pre> <code class="ruby hljs"><span class="hljs-meta"><span class="hljs-meta">irb(main):003:0&gt;</span></span> tok = RJSON::Tokenizer.new StringIO.new <span class="hljs-string"><span class="hljs-string">'{"foo":null}'</span></span> =&gt; #&lt;RJSON::Tokenizer:0x007fa8529fbeb8 @ss=#&lt;StringScanner 0/12 @ "{\"foo..."&gt;&gt; irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">004</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; tok.next_token =&gt; [<span class="hljs-string"><span class="hljs-string">"{"</span></span>, <span class="hljs-string"><span class="hljs-string">"{"</span></span>] irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">005</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; tok.next_token =&gt; [<span class="hljs-symbol"><span class="hljs-symbol">:STRING</span></span>, <span class="hljs-string"><span class="hljs-string">"\"foo\""</span></span>] irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">006</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; tok.next_token =&gt; [<span class="hljs-string"><span class="hljs-string">":"</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>] irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">007</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; tok.next_token =&gt; [<span class="hljs-symbol"><span class="hljs-symbol">:NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"null"</span></span>] irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">00</span></span>8<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; tok.next_token =&gt; [<span class="hljs-string"><span class="hljs-string">"}"</span></span>, <span class="hljs-string"><span class="hljs-string">"}"</span></span>] irb(main)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">00</span></span>9<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>&gt; tok.next_token =&gt; nil</code> </pre><br>  In this example, we wrapped a JSON string in a <code>StringIO</code> object in order to achieve duck typing with IO.  Then try to read a few lexemes.  Each token familiar to the analyzer consists of a name that comes with the first element of the array, whereas in unknown tokens this place is taken by one character.  For example, the string token will look like <code>[:STRING, "foo"]</code> , and the unknown token, in the particular case, as <code>['(', '(']</code> . Finally, when the input data is exhausted, we get <code>nil</code> on the output. <br><br>  This completes the work with the lexical analyzer.  During initialization, it receives an <code>IO</code> object at the input and implements a single method <code>next_token</code> .  Everything, it is possible to pass to the parser. <br><br><h2>  Syntactical analyzer </h2><br>  It's time to do some syntax.  First, let's work a little bit with a rake.  We need to implement generating a file in Ruby based on a <code>.y</code> file.  Just work for <code>rake</code> <a name="back-from-footnote1"></a>  <sup><a href="https://habr.com/ru/post/196676/">1</a></sup> . <br><br><h5>  We describe the compilation task: </h5><br>  First, we add a rule to the rake file that says <i>"convert <code>.y</code> files to <code>.rb</code> files using the following command"</i> : <br><pre> <code class="ruby hljs">rule <span class="hljs-string"><span class="hljs-string">'.rb'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'.y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|t|</span></span> sh <span class="hljs-string"><span class="hljs-string">"racc -l -o </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{t.name}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{t.source}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Then add the ‚Äúcompile‚Äù task, depending on the generated <code>parser.rb</code> file. <br><pre> <code class="ruby hljs">task <span class="hljs-symbol"><span class="hljs-symbol">:compile</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'lib/rjson/parser.rb'</span></span></code> </pre><br>  Since the grammar file is stored in <code>lib/rjson/parser.y</code> , now that we run <code>rake compile</code> , rake automatically converts the <code>.y</code> file to a file with a <code>.rb</code> extension using Racc. <br><br>  And finally, we set the ‚Äútest‚Äù task dependent on the ‚Äúcompile‚Äù task, so that when we run <code>rake test</code> , the compiled version is automatically generated: <br><pre> <code class="ruby hljs">task <span class="hljs-symbol"><span class="hljs-symbol">:test</span></span> =&gt; <span class="hljs-symbol"><span class="hljs-symbol">:compile</span></span></code> </pre><br>  Now you can go directly to the compilation and verification of the <code>.y</code> file. <br><br><h5>  Parse the JSON.org specification: </h5><br>  Now we are going to translate diagrams from <a href="http://www.json.org/">json.org</a> to the Racc grammar format.  At the root of the source document there must be either an object or an array, so we will create a <code>document</code> output that matches the object ‚Äî <code>object</code> or the array ‚Äî <code>array</code> : <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> document : <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> ;</code> </pre><br>  Next we define the output <code>array</code> .  Products for an array can either be empty or contain one or more values: <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> : <span class="hljs-string"><span class="hljs-string">'['</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span> | <span class="hljs-string"><span class="hljs-string">'['</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span> ;</code> </pre><br>  The output for values ‚Äã‚Äã( <code>values</code> ) is defined recursively, as one value, or several values ‚Äã‚Äãseparated by comma: <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ;</code> </pre><br>  In the JSON specification, the <code>value</code> defined as a string, number, object, array, true (true), false (false) or null (no value).  Our definition will be similar, the only difference is that for immediate values ‚Äã‚Äãlike NUMBER (number), TRUE (true) and FALSE (false), we use the corresponding names of the tokens defined in the lexical analyzer: <br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : string | NUMBER | <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ;</code> </pre><br>  Go to the definition of products for the object ( <code>object</code> ).  Objects can be empty, or consisting of pairs ( <code>pairs</code> ): <br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span> | <span class="hljs-string"><span class="hljs-string">'{'</span></span> pairs <span class="hljs-string"><span class="hljs-string">'}'</span></span> ;</code> </pre><br>  The steam may be one or more and between them they must be separated by commas.  Again we use the recursive definition: <br><pre> <code class="hljs lua"> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span> pair | pair ;</code> </pre><br>  Finally, we define a pair (pair), which is a string and a number, separated by a colon: <br><pre> <code class="hljs cs"> pair : <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">':'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ;</code> </pre><br>  Now let us inform Racc about our lexemes from the lexical analyzer, adding the definition at the very beginning, and our parser is ready: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RJSON::<span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> token STRING NUMBER <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rule</span></span> document : <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span> | <span class="hljs-string"><span class="hljs-string">'{'</span></span> pairs <span class="hljs-string"><span class="hljs-string">'}'</span></span> ; pairs : pairs <span class="hljs-string"><span class="hljs-string">','</span></span> pair | pair ; pair : string <span class="hljs-string"><span class="hljs-string">':'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> : <span class="hljs-string"><span class="hljs-string">'['</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span> | <span class="hljs-string"><span class="hljs-string">'['</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : string | NUMBER | <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ; string : STRING ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><h2>  Document Handler </h2><br>  The document handler will receive events from our parser.  He will build our incomparable Ruby object from delightful pieces of JSON!  I leave the number of events to your discretion, and I will limit myself to 5: <br><br><ul><li>  <code>start_object</code> - called at the beginning of the object </li><li>  <code>end_object</code> - called at the end of the object </li><li>  <code>start_array</code> - called at the beginning of the array </li><li>  <code>end_array</code> - called at the end of the array </li><li>  <code>scalar</code> - called in terminal cases such as strings, true, false, etc. </li></ul><br>  With these five events, we will assemble an object reflecting the original JSON structure. <br><br><h5>  We follow the events </h5><br>  Our handler will simply keep track of events coming from the parser.  The result is a tree structure, on the basis of which, we build the final Ruby object. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> = [[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">root</span></span></span><span class="hljs-class">]] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start_object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">push</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hash</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start_array</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">push</span></span></span><span class="hljs-class"> [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end_array</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pop</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alias</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end_object</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end_array</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scalar</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class"> &lt;&lt; [:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scalar</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">push</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">o</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class"> &lt;&lt; o @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> &lt;&lt; o </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Each time the parser detects the beginning of an object, the handler adds a list with the hash symbol to the top of the stack to mark the beginning of the associative array.  Events that are children will be added to the parent, and when the end of the object is detected, the parent will be pushed out of the stack. <br><br>  I do not exclude that it is difficult to understand from the first time, therefore we will consider several examples.  Passing a JSON string like <code>{"foo":{"bar":null}}</code> as input, we get the following in the stack variable <code>@stack</code> : <br><pre> <code class="ruby hljs">[[<span class="hljs-symbol"><span class="hljs-symbol">:root</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span>, <span class="hljs-string"><span class="hljs-string">"bar"</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>]]]]]</code> </pre><br>  Taking, for example, an array of the form <code>["foo",null,true]</code> , in <code>@stack</code> we get the following: <br><pre> <code class="ruby hljs">[[<span class="hljs-symbol"><span class="hljs-symbol">:root</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:array</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>], [<span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]]]]</code> </pre><br><br><h5>  Convert to Ruby: </h5><br>  Having thus obtained an intermediate presentation of the JSON document, we proceed to convert it into a data structure in Ruby.  To do this, we write the recursive function of processing the resulting tree: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function"> = @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stack</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> private <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rest</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rest</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x.first, x.drop(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:hash</span></span> Hash[rest.map { <span class="hljs-params"><span class="hljs-params">|x|</span></span> process(x.first, x.drop(<span class="hljs-number"><span class="hljs-number">1</span></span>)) }.each_slice(<span class="hljs-number"><span class="hljs-number">2</span></span>).to_a] <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:scalar</span></span> rest.first <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The <code>result</code> method deletes the <code>root</code> node and passes what is left to the <code>process</code> method.  When <code>process</code> detects the <code>hash</code> character, it forms an associative array using the child elements resulting from the recursive <code>process</code> call.  By analogy with this, a recursive call on the child elements builds an array when the character <code>array</code> is encountered.  Scalar values ‚Äã‚Äã- <code>scalar</code> returned without processing (which prevents endless recursion).  Now, if we call <code>result</code> from our handler, then we will get a Ruby object at the output. <br>  Let's see how it works in practice: <br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'rjson'</span></span> input = StringIO.new <span class="hljs-string"><span class="hljs-string">'{"foo":"bar"}'</span></span> tok = RJSON::Tokenizer.new input parser = RJSON::Parser.new tok handler = parser.parse handler.result <span class="hljs-comment"><span class="hljs-comment"># =&gt; {"foo"=&gt;"bar"}</span></span></code> </pre><br><br><h5>  Software interface refinement: </h5><br>  We have a fully functional JSON analyzer.  True, with one drawback - it does not have a very convenient software interface.  Let's use the previous example to improve it: <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">load</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringIO</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tok</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON::Tokenizer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parser</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON::Parser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tok</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Since our analyzer was originally built for an IO object, we can add a method for those who would like to send a socket or a file descriptor as input: <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">load_io</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tok</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON::Tokenizer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parser</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RJSON::Parser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tok</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">load</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">load_io</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringIO</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">json</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  We are convinced that the interface has become a bit more convenient: <br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'rjson'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'open-uri'</span></span> RJSON.load <span class="hljs-string"><span class="hljs-string">'{"foo":"bar"}'</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; {"foo"=&gt;"bar"} RJSON.load_io open('http://example.org/some_endpoint.json')</span></span></code> </pre><br><h2>  Thinking out loud </h2><br>  So, the work on the analyzer is completed.  In the process, we became familiar with the compilation technology, including the basics of syntax and lexical analysis, and even touched on interpreters (that's it, in fact, we were engaged in JSON interpretation).  You have something to be proud of! <br><br>  The analyzer we wrote was quite flexible.  We can: <br><br><ul><li>  Use it in the event paradigm, implementing the Handler handler object. </li><li>  Use a simplified interface and just input strings. </li><li>  Pass a stream in JSON format to an input through an IO object </li></ul><br>  I hope this article will give you confidence, and you will begin to experiment on your own with the analysis and compilation technologies implemented in Ruby.  If you still have questions for me, you are welcome in the <a href="https://practicingruby.com/">comments</a> . <br><br><h2>  PS </h2><br>  In conclusion, I want to clarify some details that I omitted in the process of presentation, so as not to introduce additional ambiguity: <br><br><ul><li>  <a href="">Here</a> is the final grammar of our analyzer.  Notice the <a href="">- inner section of the .y file</a> .  Everything that is presented in this section will be added to the class of the parser, which is obtained as a result of automatic generation.  In this way, we pass the handler object to the parser. </li><li>  Our parser actually <a href="">translates</a> JSON terminal nodes into Ruby.  Therefore, we convert JSON to Ruby twice: in the parser and in the document handler.  The latter is responsible for the structure, while the first is for the immediate values ‚Äã‚Äã(true, false, etc.).  I note that it is quite reasonable to note that all transformations must be carried out by the parser or, on the contrary, be completely excluded from it. </li><li>  Finally, the <a href="">lexical analyzer</a> uses buffering.  I made a sketch version without buffering, which can be taken <a href="">from here</a> .  It is pretty raw, but it can be brought to mind using the logic of the finite state machine. </li></ul><br>  That's all.  Thanks for attention! <br><hr><br><a name="footnote1"></a>  <a href="https://habr.com/ru/post/196676/"><sup>1</sup></a> eng  rake - rake <br><br>  Comments on the translation, please send in a personal. </div><p>Source: <a href="https://habr.com/ru/post/196676/">https://habr.com/ru/post/196676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196664/index.html">Java School: Overview</a></li>
<li><a href="../196666/index.html">The arbitration court ruled that the Federal Drug Control Service may deprive a domain name of anyone for posting drug information on the site. ‚Ññ139-–§–ó (on protection of children) - not a hindrance</a></li>
<li><a href="../196668/index.html">Creating cross-browser visualization of audio</a></li>
<li><a href="../196670/index.html">Google Maps doubled Rybinsk Reservoir</a></li>
<li><a href="../196672/index.html">Steal-kill, write-swing</a></li>
<li><a href="../196682/index.html">We attach the spatial index to the unsuspecting OpenSource database.</a></li>
<li><a href="../196684/index.html">Samsung is the most active advertiser on the "pirated" sites of Ukraine</a></li>
<li><a href="../196688/index.html">Instead of a review IBM ThinkPad 755CD - restorer notes</a></li>
<li><a href="../196690/index.html">Google has to delete eight ‚Äúpirated‚Äù links per second</a></li>
<li><a href="../196692/index.html">Tips & tricks for MySQL Developers. Work with SQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>