<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity Hexagon Maps: Path Search, Player Squads, Animation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts 1-3: mesh, cell colors and heights 

 Parts 4-7: bumps, rivers and roads 

 Parts 8-11: water, landforms and walls 

 Parts 12-15: saving and lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity Hexagon Maps: Path Search, Player Squads, Animation</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habr.com/post/424257/">Parts 1-3: mesh, cell colors and heights</a> <br><br>  <a href="https://habr.com/post/424491/">Parts 4-7: bumps, rivers and roads</a> <br><br>  <a href="https://habr.com/post/425463/">Parts 8-11: water, landforms and walls</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habr.com/post/425919/">Parts 12-15: saving and loading, textures, distances</a> <br><br>  <a href="https://habr.com/post/426481/">Parts 16-19: Pathfinding, Player Squads, Animations</a> <br><br>  <a href="https://habr.com/post/427003/">Parts 20-23: fog of war, map exploration, procedural generation</a> <br><br>  <a href="https://habr.com/post/427567/">Parts 24-27: water cycle, erosion, biomes, cylindrical map</a> <br><br><h1>  Part 16: finding the way </h1><br><ul><li>  Highlight cells </li><li>  Selecting the target search point </li><li>  Find the shortest path </li><li>  Create a priority queue </li></ul><br>  Calculating the distance between the cells, we went to finding the paths between them. <br><br>  Starting from this part, tutorials on hexagon maps will be created in Unity 5.6.0.  It should be noted that in 5.6 there is a bug destroying texture arrays in assemblies for several platforms.  You can bypass it by turning on the <em>Is Readable</em> in the texture array inspector. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/165/c4e/1d9165c4e1862b050015df3c9dcc48cd.jpg"></div><br>  <i>Planning a trip</i> <br><a name="habracut"></a><br><h2>  Highlighted cells </h2><br>  To search for a path between two cells, we need to first select these cells.  It is no longer just a choice of a single cell and the observation of the search on the map.  For example, first we select the starting cell, and then the final one.  It would be convenient for them to become illuminated.  So let's add this functionality.  As long as we do not create a complex or effective method of selection, simply create something that helps us in our development. <br><br><h3>  Texture contour </h3><br>  One of the easiest ways to select cells is to add an outline to them.  The easiest way to do this is with a texture containing a hexagonal outline.  <a href="">Here</a> you can download this texture.  It is transparent, except for the white contour of the hexagon.  By making it white, we will be able to paint it in the future as we need. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0j/4u/vs/0j4uvsbyjtxiavcwaajn73csp68.png"></div><br>  <i>The contour of the cell on a black background</i> <br><br>  Import the texture and set its <em>Texture Type</em> to the <em>Sprite</em> value.  Her <em>Sprite Mode</em> will be <em>Single</em> with the default settings.  Since this is an exceptionally white texture, we do not need to convert to <em>sRGB</em> .  The alpha channel stands for transparency, so we turn on <em>Alpha is Transparency</em> .  I also set the <em>Filter Mode</em> textures to <em>Trilinear</em> , because otherwise the mip transitions for the contours may become too noticeable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebb/e4a/a88/ebbe4aa88f93b71cf5946c4c011339dc.png"></div><br>  <i>Texture Import Options</i> <br><br><h3>  One sprite per cell </h3><br>  The quickest way to add to the cells is a possible contour, adding each one its own sprite.  Let's create a new game object, add the Image component ( <em>Component / UI / Image</em> ) to it and assign it our sprite contour.  Then we insert an instance of the <em>Hex Cell Label</em> prefab into the scene, make the sprite object its child, apply the changes to the prefab, and then get rid of the prefab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/7f6/7f4/5c27f67f4596673f5b2e73b2db5073cd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/f7c/ea8/5daf7cea84e2ff46829460e0523bfa91.png"></div><br>  <i>Child element prefab selection</i> <br><br>  Now each cell has a sprite, but it will be too big.  To make the contours correspond to the centers of the cells, change the <em>Width</em> and <em>Height</em> of the transform component of the sprite to 17. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc1/069/e42/bc1069e4216435f1a30af953af5b948a.png"></div><br>  <i>Selection sprites partially hidden by relief</i> <br><br><h3>  Draw over everything </h3><br>  Since the contour overlaps the areas of the edges of the cells, it often falls under the geometry of the relief.  Because of this, part of the contour disappears.  This can be avoided by slightly raising the sprites vertically, but not in the case of cliffs.  Instead, we can do the following: always draw sprites on top of everything else.  To do this, create your own sprite shader.  It will be enough for us to copy the standard Unity sprite shader and make a couple of changes to it. <br><br><pre><code class="hljs smalltalk"><span class="hljs-type"><span class="hljs-type">Shader</span></span> <span class="hljs-comment"><span class="hljs-comment">"Custom/Highlight"</span></span> { <span class="hljs-type"><span class="hljs-type">Properties</span></span> { [<span class="hljs-type"><span class="hljs-type">PerRendererData</span></span>] _MainTex (<span class="hljs-comment"><span class="hljs-comment">"Sprite Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-comment"><span class="hljs-comment">"white"</span></span> {} _Color (<span class="hljs-comment"><span class="hljs-comment">"Tint"</span></span>, <span class="hljs-type"><span class="hljs-type">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [<span class="hljs-type"><span class="hljs-type">MaterialToggle</span></span>] <span class="hljs-type"><span class="hljs-type">PixelSnap</span></span> (<span class="hljs-comment"><span class="hljs-comment">"Pixel snap"</span></span>, <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> [<span class="hljs-type"><span class="hljs-type">HideInInspector</span></span>] _RendererColor (<span class="hljs-comment"><span class="hljs-comment">"RendererColor"</span></span>, <span class="hljs-type"><span class="hljs-type">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [<span class="hljs-type"><span class="hljs-type">HideInInspector</span></span>] _Flip (<span class="hljs-comment"><span class="hljs-comment">"Flip"</span></span>, <span class="hljs-type"><span class="hljs-type">Vector</span></span>) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [<span class="hljs-type"><span class="hljs-type">PerRendererData</span></span>] _AlphaTex (<span class="hljs-comment"><span class="hljs-comment">"External Alpha"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-comment"><span class="hljs-comment">"white"</span></span> {} [<span class="hljs-type"><span class="hljs-type">PerRendererData</span></span>] _EnableExternalAlpha (<span class="hljs-comment"><span class="hljs-comment">"Enable External Alpha"</span></span>, <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-type"><span class="hljs-type">SubShader</span></span> { <span class="hljs-type"><span class="hljs-type">Tags</span></span> { <span class="hljs-comment"><span class="hljs-comment">"Queue"</span></span>=<span class="hljs-comment"><span class="hljs-comment">"Transparent"</span></span> <span class="hljs-comment"><span class="hljs-comment">"IgnoreProjector"</span></span>=<span class="hljs-comment"><span class="hljs-comment">"True"</span></span> <span class="hljs-comment"><span class="hljs-comment">"RenderType"</span></span>=<span class="hljs-comment"><span class="hljs-comment">"Transparent"</span></span> <span class="hljs-comment"><span class="hljs-comment">"PreviewType"</span></span>=<span class="hljs-comment"><span class="hljs-comment">"Plane"</span></span> <span class="hljs-comment"><span class="hljs-comment">"CanUseSpriteAtlas"</span></span>=<span class="hljs-comment"><span class="hljs-comment">"True"</span></span> } <span class="hljs-type"><span class="hljs-type">Cull</span></span> <span class="hljs-type"><span class="hljs-type">Off</span></span> <span class="hljs-type"><span class="hljs-type">ZWrite</span></span> <span class="hljs-type"><span class="hljs-type">Off</span></span> <span class="hljs-type"><span class="hljs-type">Blend</span></span> <span class="hljs-type"><span class="hljs-type">One</span></span> <span class="hljs-type"><span class="hljs-type">OneMinusSrcAlpha</span></span> <span class="hljs-type"><span class="hljs-type">Pass</span></span> { <span class="hljs-type"><span class="hljs-type">CGPROGRAM</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> vertex <span class="hljs-type"><span class="hljs-type">SpriteVert</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> fragment <span class="hljs-type"><span class="hljs-type">SpriteFrag</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> target <span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> multi_compile_instancing <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> multi_compile _ <span class="hljs-type"><span class="hljs-type">PIXELSNAP_ON</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#pragma</span></span> multi_compile _ <span class="hljs-type"><span class="hljs-type">ETC1_EXTERNAL_ALPHA</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"UnitySprites.cginc"</span></span> <span class="hljs-type"><span class="hljs-type">ENDCG</span></span> } } }</code> </pre> <br>  The first change is that we ignore the depth buffer, making it so that the Z test always ends in luck. <br><br><pre> <code class="hljs pgsql"> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZTest <span class="hljs-keyword"><span class="hljs-keyword">Always</span></span></code> </pre> <br>  The second change is that we render after all the rest of the transparent geometry.  It will be enough to add 10 to the queue of transparency. <br><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+10"</span></span></code> </pre> <br>  Create a new material that will be used by this shader.  We can ignore all its properties, adhering to default values.  Then make the sprite prefab use this material. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/d01/812/15bd01812d94f52ced67308dd000c430.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/393/e24/ef5393e241252d81513a0ff5f8972b50.png"></div><br>  <i>Use your own sprite material</i> <br><br>  Now the contours of the selection are always visible.  Even if the cell is hidden under a higher terrain, its outline will still be drawn on top of everything else.  It may not look beautiful, but the selected cells will always be visible, which is useful for us. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/8bc/418/ce28bc418dc0ec116cff1bcbaddf0363.png"></div><br>  <i>Ignore the depth buffer</i> <br><br><h3>  Allocation control </h3><br>  We do not want all cells to be highlighted at the same time.  In fact, initially they should all be unallocated.  We can accomplish this by disabling the Image component of the <em>Highlight</em> prefab object. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82f/00e/164/82f00e164316900fb9d9694030298bcc.png"></div><br>  <i>Image component disabled</i> <br><br>  To enable cell selection, add the <code>HexCell</code> method to <code>EnableHighlight</code> .  It must take the only child of its <code>uiRect</code> and include its Image component.  Let's also create the <code>DisableHighlight</code> method. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Finally, we can specify the color so that when turned on, it gives the backlight a tint. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableHighlight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { Image highlight = uiRect.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Image&gt;(); highlight.color = color; highlight.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-16/highlighting-cells/highlighting-cells.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Finding the way </h2><br>  Now, when we can select cells, we need to move on and select two cells, and then find a path between them.  First we need to select the cells, then limit the search to finding the path between them, and finally show this path. <br><br><h3>  Start search </h3><br>  We need to select two different cells, the starting and ending points of the search.  Suppose that in order to select the initial search cell, hold down the left Shift key when clicking the mouse.  At the same time, the cell will be highlighted in blue.  We need to save the link to this cell for further search.  In addition, when selecting a new starting cell, the selection of the old one must be disabled.  Therefore, add the <code>HexMapEditor</code> field to the <code>searchFromCell</code> . <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell;</code> </pre> <br>  Inside <code>HandleInput</code> we can use <code>Input.GetKey(KeyCode.LeftShift)</code> to test the Shift key <code>Input.GetKey(KeyCode.LeftShift)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d50/a63/1c3/d50a631c3f4701e414b2e9a9078a57a2.png"></div><br>  <i>Where to look</i> <br><br><h3>  End point search </h3><br>  Instead of looking for all the distances to the cell, we are now looking for a path between two specific cells.  Therefore, rename <code>HexGrid.FindDistancesTo</code> to <code>HexGrid.FindPath</code> and give it the second <code>HexCell</code> parameter. Also, change the <code>Search</code> method. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(fromCell); ‚Ä¶ }</code> </pre> <br>  Now <code>HexMapEditor.HandleInput</code> should call the modified method using <code>searchFromCell</code> and <code>currentCell</code> as arguments.  In addition, we can search only when we know which cell to search for.  And we don‚Äôt have to bother searching if the start and end points are the same. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { hexGrid.FindPath(searchFromCell, currentCell); }</code> </pre> <br>  Turning to the search, we first need to get rid of all previous selections.  Therefore, let the <code>HexGrid.Search</code> disable the selection when the distances are reset.  Since this also turns off the backlight of the initial cell, then turn it on again.  At this stage, we can also highlight the end point.  Let's make it red. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].DisableHighlight(); } fromCell.EnableHighlight(Color.blue); toCell.EnableHighlight(Color.red); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/01c/5e5/18101c5e578322ea99598cbca70f60a9.png"></div><br>  <i>End points of a potential path</i> <br><br><h3>  We limit the search </h3><br>  At this stage, our search algorithm still calculates the distances to all the cells that are reachable from the initial cell.  But we do not need this anymore.  We can stop as soon as we find the final distance to the final cell.  That is, when the current cell is finite, we can exit the loop of the algorithm. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/424/6e0/d49/4246e0d491a1938dfb1e9b3a00080e42.png"></div><br>  <i>Stop at the end point</i> <br><br><div class="spoiler">  <b class="spoiler_title">What happens if the end point cannot be reached?</b> <div class="spoiler_text">  Then the algorithm will continue to work until it finds all reachable cells.  Without the possibility of a premature exit, it will work as the old <code>FindDistancesTo</code> method. </div></div><br><h3>  Path mapping </h3><br>  We can find the distance between the beginning and the end of the path, but do not yet know what the real path will be.  To find it, you need to track how each cell is reached.  But how to do that? <br><br>  When adding a cell to the border, we do this because it is a neighbor of the current cell.  The only exception is the starting cell.  All other cells were reached through the current cell.  If we keep track of which cell each cell was reached from, we will end up with a network of cells.  More specifically, a tree network whose root is the starting point.  We can use it to build a path after reaching the end point. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a71/331/153/a713311534e05f46c6fd22a632100494.png"></div><br>  <i>Tree network describing the way to the center</i> <br><br>  We can save this information by adding a link to another cell in <code>HexCell</code> .  We do not need to serialize this data, so we use a standard property for this. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell PathFrom { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  In <code>HexGrid.Search</code> we set the current cell as the neighbor's <code>PathFrom</code> value when it is added to the border.  In addition, we need to change this link when we find a shorter path to the neighbor. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; neighbor.PathFrom = current; }</code> </pre> <br>  Having reached the end point, we can visualize the path, following these links back to the starting cell, and select them. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/9cc/8de/f899cc8de04e0c5666a2a05558b28042.png"></div><br>  <i>Path found</i> <br><br>  It is worth considering that there are often several shortest paths.  Found depends on the order of processing cells.  Some paths may look good, others are bad, but there is never a shorter path.  We will come back to this later. <br><br><h3>  Change the start of the search </h3><br>  After selecting the starting point, changing the end point will trigger a new search.  The same should happen when choosing a new starting cell.  To make this possible, <code>HexMapEditor</code> must also remember the end point. <br><br><pre> <code class="cs hljs"> HexCell previousCell, searchFromCell, searchToCell;</code> </pre> <br>  Using this field we can also initiate a new search when selecting a new beginning. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell); }</code> </pre> <br>  In addition, we need to avoid the equality of the starting and ending points. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { ‚Ä¶ }</code> </pre> <br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-16/finding-a-path/finding-a-path.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Smarter search </h2><br>  Although our algorithm finds the shortest path, it spends a lot of time researching points that obviously will not become part of this path.  At least obvious to us.  The algorithm can not look at the map "down", he can not see that the search in some directions will be meaningless.  He prefers to drive along roads, despite the fact that they are heading in the opposite direction from the end point.  Is it possible to make the search smarter? <br><br>  At the moment, when choosing a cell to be processed next, we consider only the distance from the cell to the beginning.  If we want to act smarter, then we must also consider the distance to the end point.  Unfortunately, we do not know him yet.  But we can create an estimate of the remaining distance.  Adding this estimate to the distance to the cell gives us an understanding of the total length of the path that passes through this cell.  Then we can use it to prioritize cell search. <br><br><h3>  Search heuristics </h3><br>  When we use estimates or guesses instead of well-known data, this is called using search heuristics.  This heuristic represents the best guess of the remaining distance.  We have to define this value for each cell by which we perform the search, so we add an <code>HexCell</code> integer property for it.  We do not need to serialize it, so one more standard property will suffice. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchHeuristic { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  How do we make a guess about the remaining distance?  In the most ideal case, we will have a road leading straight to the end point.  If so, then the distance is equal to the unchanged distance between the coordinates of this cell and the final cell.  Let's use this in our heuristics. <br><br>  Since heuristics do not depend on a previously traveled path, it is constant in the search process.  Therefore, we only need to calculate it once the <code>HexGrid.Search</code> adds a cell to the border. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); frontier.Add(neighbor); }</code> </pre> <br><h3>  Search priority </h3><br>  From now on, we will determine the search priority based on the distance to the cell plus its heuristics.  Let's add for this value in the <code>HexCell</code> property. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance + SearchHeuristic; } }</code> </pre> <br>  To make it work, we <code>HexGrid.Search</code> so that it uses this property to sort the border. <br><br><pre> <code class="cs hljs"> frontier.Sort( (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/a22/c9a/b58a22c9a65a2088309a46c6cbc2d102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br>  <i>Search without and with heuristics</i> <br><br><h3>  Acceptable Heuristics </h3><br>  Thanks to the new search priorities, we will actually visit fewer cells.  However, on a flat map, the algorithm still processes cells that are in the wrong direction.  This is because, by default, the cost of each move step is 5, and a heuristic adds only 1 to a step. That is, the influence of heuristics is not very strong. <br><br>  If the costs of moving on all maps are the same, then we can use the same costs when determining heuristics.  In our case, this will be the current heuristic multiplied by 5. This will significantly reduce the number of cells being processed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a4/6c7/ac3/9a46c7ac3c0df63797bfda1f143f9409.png"></div><br>  <i>We use heuristics √ó 5</i> <br><br>  However, if there are roads on the map, then we can overestimate the remaining distance.  As a result, the algorithm may make mistakes and create a path that is actually not the shortest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/7bb/dc7/cd27bbdc7043804a8d2a21ac096a6409.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0af/017/2a2/0af0172a264285358f99b0ece93833a3.png"></div><br>  <i>Overvalued and allowable heuristics</i> <br><br>  To ensure that the shortest path is found, we need to ensure that we never overestimate the remaining distance.  Such an approach is called admissible heuristics.  Since the minimum costs for moving are 1, we have no choice but to use the same costs when defining a heuristic. <br><br>  Strictly speaking, it is quite normal to use even lower costs, but this will only make heuristics weaker.  The minimum possible heuristics is zero, which gives us just the Dijkstra algorithm.  When a non-zero heuristic, the algorithm is called A <sup>*</sup> (pronounced "A star"). <br><br><div class="spoiler">  <b class="spoiler_title">Why is it called A *?</b> <div class="spoiler_text">  The idea of ‚Äã‚Äãadding heuristics to Dijkstra's algorithm was first proposed by Niels Nilsson.  He called his version A1.  Later, Bertram Raphael came up with the best version, which he called A2.  Then Peter Hart proved that with good heuristics, A2 is optimal, that is, there cannot be a better version.  This made him call the algorithm A <sup>*</sup> to show that it would not be possible to improve, that is, A3 or A4 would not appear.  So yes, the A <sup>*</sup> algorithm is the best we can get, but it is only as good as its heuristics. </div></div><br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-16/smarter-searching/smarter-searching.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Priority queue </h2><br>  Although A <sup>* is a</sup> good algorithm, our implementation is not so efficient, because to store the border we use a list that needs to be sorted at each iteration.  As mentioned in the previous section, we need a priority queue, but its standard implementation does not exist.  So let's create it yourself. <br><br>  Our queue must support staging and de-queuing based on priority.  It should also support changing the priority of a cell already in the queue.  Ideally, we implement it by minimizing the search sorting and allocated memory.  In addition, it should remain simple. <br><br><h3>  Create your own queue </h3><br>  Create a new <code>HexCellPriorityQueue</code> class with the required general methods.  To track the contents of the queue, we use a simple list.  In addition, we will add the <code>Clear</code> method to it to reset the queue so that it can be used repeatedly. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellPriorityQueue</span></span> { List&lt;HexCell&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); } }</code> </pre> <br>  We store cell priorities in the cells themselves.  That is, before adding a cell to the queue, its priority must be set.  But if the priority changes, it will probably be useful to know what the old priority was.  So let's add this to <code>Change</code> as a parameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  It is also useful to know how many cells are in the queue, so let's add the <code>Count</code> property for this.  Simply use the field for which we will perform the corresponding increment and decrement. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h3>  Adding to the queue </h3><br>  When a cell is added to a queue, let's first use its priority as an index, treating the list as a simple array. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; list[priority] = cell; }</code> </pre> <br>  However, this only works if the list is long enough, otherwise we will go beyond the boundaries.  You can avoid this by adding empty items to the list until it reaches the desired length.  These empty elements do not refer to the cell, so you can create them by adding <code>null</code> to the list. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priority &gt;= list.Count) { list.Add(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e77/000/fec/e77000feca5c0bfdb769062356ca9935.png"></div><br>  <i>List with holes</i> <br><br>  But so we store only one cell per priority, and there will most likely be several of them.  To track all the cells with the same priority, we need to use another list.  Although we can use this list for each priority, we can also add a property to <code>HexCell</code> to link them together.  This allows us to create a chain of cells called a linked list. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell NextWithSamePriority { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  To create a chain, we make <code>HexCellPriorityQueue.Enqueue</code> force the newly added cell to refer to the current value with the same priority before deleting it. <br><br><pre> <code class="cs hljs"> cell.NextWithSamePriority = list[priority]; list[priority] = cell;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45b/082/87c/45b08287cf76c4636d7a673869aa39b5.png"></div><br>  <i>List of related lists</i> <br><br><h3>  Remove from queue </h3><br>  To get a cell from the priority queue, we need to access the linked list at the smallest non-empty index.  Therefore, bypass the list in the loop until we find it.  If not found, the queue is empty and we return <code>null</code> . <br><br>  From the found chain, we can return any cell, because they all have the same priority.  The easiest way is to return a cell from the beginning of the chain. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.Count; i++) { HexCell cell = list[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  To keep the link to the remaining chain, use the next cell with the same priority as the new beginning.  If at this priority level there was only one cell, then the element becomes <code>null</code> and will be skipped in the future. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[i] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; }</code> </pre> <br><h3>  Minimum tracking </h3><br>  This approach works, but requires iteration through the list each time a cell is received.  We cannot avoid searching for the smallest non-empty index, but we do not have to start from scratch every time.  Instead, we can track the minimum priority and start the search with it.  Initially, the minimum is essentially equal to infinity. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { list.Clear(); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; minimum = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; }</code> </pre> <br>  When adding a cell to the queue, we change the minimum if necessary. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enqueue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { count += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = cell.SearchPriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority &lt; minimum) { minimum = priority; } ‚Ä¶ }</code> </pre> <br>  And when withdrawing from the queue, we use for the iterations at least the list, and do not start from scratch. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dequeue</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { count -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; minimum &lt; list.Count; minimum++) { HexCell cell = list[minimum]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { list[minimum] = cell.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  This significantly reduces the amount of time to crawl in the priority list cycle. <br><br><h3>  Changing priorities </h3><br>  When the priority of a cell changes, it must be removed from the linked list of which it is a part.  To do this, we need to follow the chain until we find it. <br><br>  Let's start with the announcement that the head of the old list of priorities will be the current cell, and we will also track the next cell.  We can immediately take the next cell, because we know that there is at least one cell in this index. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; }</code> </pre> <br>  If the current cell is a changed cell, then this is the head cell and we can cut it off, as if we were removed from the queue. <br><br><pre> <code class="cs hljs"> HexCell current = list[oldPriority]; HexCell next = current.NextWithSamePriority; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; }</code> </pre> <br>  If this is not the case, then we need to follow the chain until we are in the cell in front of the changed cell.  It contains a link to the cell that has been modified. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == cell) { list[oldPriority] = next; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } }</code> </pre> <br>  At this stage, we can remove the changed cell from the linked list by skipping it. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (next != cell) { current = next; next = current.NextWithSamePriority; } current.NextWithSamePriority = cell.NextWithSamePriority;</code> </pre> <br>  After deleting a cell, you need to add it again so that it appears in the list of its new priority. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Change</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldPriority</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Enqueue(cell); }</code> </pre> <br>  The <code>Enqueue</code> method increases the counter, but in fact we are not adding a new cell.  Therefore, to compensate for this, we will have to execute the decrement of the counter. <br><br><pre> <code class="cs hljs"> Enqueue(cell); count -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h3>  Use queue </h3><br>  Now we can use our priority <code>HexGrid</code> .  This can be done with a single instance, reusable for all searches. <br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the cycle begins, the method </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must first be added to the queue </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and each iteration begins with the cell being removed from the queue. </font><font style="vertical-align: inherit;">This will replace the old border code.</font></font><br><br><pre> <code class="cs hljs"> WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// List&lt;HexCell&gt; frontier = new List&lt;HexCell&gt;(); fromCell.Distance = 0; // frontier.Add(fromCell); searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { yield return delay; HexCell current = searchFrontier.Dequeue(); // frontier.RemoveAt(0); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's change the code so that it adds and changes the neighbor. </font><font style="vertical-align: inherit;">Before the change we will remember the old priority.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); <span class="hljs-comment"><span class="hljs-comment">// frontier.Add(neighbor); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, we no longer need to sort the border. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// frontier.Sort( // (x, y) =&gt; x.SearchPriority.CompareTo(y.SearchPriority) // );</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Search using the priority queue</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As mentioned earlier, the shortest path found depends on the cell processing order. </font><font style="vertical-align: inherit;">Our queue creates an order different from the sorted list order, so we can receive other paths. </font><font style="vertical-align: inherit;">As we add and remove from the head of the linked list for each priority, they are more like stacks than queues. </font><font style="vertical-align: inherit;">The cells added last are processed first. </font><font style="vertical-align: inherit;">A side effect of this approach is that the algorithm is prone to zigzags. </font><font style="vertical-align: inherit;">Therefore, the likelihood of zigzag paths also increases. </font><font style="vertical-align: inherit;">Fortunately, such paths usually look better, so this side effect is to our advantage.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/0a3/c0a/b440a3c0aa42dc771ba3a7a0948c835f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/1e9/cc5/9081e9cc5b0ea1d6f4309b6221eab1ac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sorted list and </font></font></i> <font style="vertical-align: inherit;"><a href="https://catlikecoding.com/unity/tutorials/hex-map/part-16/priority-queue/priority-queue.unitypackage" rel="nofollow"><font style="vertical-align: inherit;">unitypackage </font></a><i><font style="vertical-align: inherit;">priority </font></i></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-16/priority-queue/priority-queue.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 17: limited movement </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We find ways for step-by-step movement. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Immediately display the path. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a more efficient search. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We visualize only the way. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this part, we will divide the movement into moves and speed up the search as much as possible. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/572/9cc/c4d5729ccbf9cc994b7c8328950e6f5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey from several moves</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step Motion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strategy games that use hexagonal grids are almost always turn-based. </font><font style="vertical-align: inherit;">The units moving on the map have a limited speed, which limits the distance traveled in one turn.</font></font><br><br><h3>  Speed </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To support limited motion, add to </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and to the </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">integer parameter </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It determines the stock of movements for one turn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(fromCell, toCell, speed)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different types of units in the game use different speeds. </font><font style="vertical-align: inherit;">Cavalry is fast, infantry is slow, and so on. </font><font style="vertical-align: inherit;">We still do not have units, so for now we will use a constant speed. </font><font style="vertical-align: inherit;">Let's take the value 24. This is a fairly large value, not divisible by 5 (the cost of moving by default). </font><font style="vertical-align: inherit;">Add an argument for </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a constant speed.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moves </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to tracking the total cost of moving along the way, we also need to now know how many moves it will take to move through it. But we do not need to store this information in each cell. It can be obtained by dividing the distance traveled by speed. Since these are integers, we use integer division. That is, the total distance of no more than 24 corresponds to the move 0. This means that the entire path can be passed in the current course. If the end point is at a distance of 30, then it must be turn 1. To get to the end point, the detachment will have to spend all its movement in the current turn and in the part of the next turn. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's determine the course of the current cell and all its neighbors inside</font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The course of the current cell can be calculated only once, just before going around in the cycle of neighbors. </font><font style="vertical-align: inherit;">The progress of the neighbor can be determined as soon as we find the distance to it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = current.Distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lost motion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the move of the neighbor is greater than the current move, then we have crossed the turn boundary. </font><font style="vertical-align: inherit;">If the movement required to reach a neighbor was 1, then everything is fine. </font><font style="vertical-align: inherit;">But if moving to the next cell is more expensive, then everything becomes more complicated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose that we move on a uniform map, that is, to get into each cell you need 5 movement units. </font><font style="vertical-align: inherit;">Our speed is equal to 24. After four steps, we spent 20 units from our stock of movement, and there are 4 left. In the next step, we need 5 units again, that is, one more than the existing ones. </font><font style="vertical-align: inherit;">What do we need to do at this stage?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two approaches to this situation. The first is to allow the squad to enter the fifth cell on the current turn, even if we do not have enough movement. The second is to prohibit movement during the current turn, that is, the remaining movement points cannot be used and they will be lost. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The choice of option depends on the game. In general, the first approach is more appropriate for games in which units can move only a few steps per turn, for example, for the games of the Civilization series. This ensures that units can always move at least one cell per turn. If units can move on many cells per turn, as in Age of Wonders or in Battle for Wesnoth, then the second option is better.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we use speed 24, let's choose the second approach. </font><font style="vertical-align: inherit;">In order for it to start working, we need to isolate the costs of entering the neighboring cell before adding it to the current distance.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int distance = current.Distance; int moveCost; if (current.HasRoadThroughEdge(d)) { moveCost = 1; } else if (current.Walled != neighbor.Walled) { continue; } else { moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; } int distance = current.Distance + moveCost; int turn = distance / speed;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If, as a result, we cross the turn boundary, we first use all movement points of the current turn. </font><font style="vertical-align: inherit;">We can do this by simply multiplying the move by the speed. </font><font style="vertical-align: inherit;">After that we add the cost of moving.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = distance / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of this, we will finish the first move in the fourth cell with 4 unused movement points. </font><font style="vertical-align: inherit;">These lost points are added to the costs of the fifth cell, so its distance becomes 29, not 25. As a result, the distances are greater than before. </font><font style="vertical-align: inherit;">For example, the tenth cell had a distance of 50. But now to get to it, we need to cross the boundaries of two moves, losing 8 movement points, that is, the distance to it now becomes equal to 58.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/7f4/1f1/ff37f41f11c85f7f759367fd2b33334d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longer than expected</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since unused movement points are added to the distances to the cells, they are taken into account when determining the shortest path. </font><font style="vertical-align: inherit;">The most effective way is wasting as little points as possible. </font><font style="vertical-align: inherit;">Therefore, at different speeds, we can get different ways.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Displays moves instead of distances </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we play a game, we are not very interested in the distance values ‚Äã‚Äãused to find the shortest path. </font><font style="vertical-align: inherit;">We are interested in the number of moves required to reach the end point. </font><font style="vertical-align: inherit;">Therefore, let us, instead of distances, will display the moves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, get rid of </font></font><code>UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and call it in </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// UpdateDistanceLabel(); } } ‚Ä¶ // void UpdateDistanceLabel () { // UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); // label.text = distance == int.MaxValue ? "" : distance.ToString(); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead, we add to the </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generic method </font></font><code>SetLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that gets an arbitrary string.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { UnityEngine.UI.Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = text; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use this new method to </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean the cells. </font><font style="vertical-align: inherit;">To hide the cells, simply assign them </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; cells[i].SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); cells[i].DisableHighlight(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we assign the value of its progress to the neighbor's label. </font><font style="vertical-align: inherit;">After this, we will be able to see how many extra moves are required to go all the way.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d4/6d6/97d/0d46d697d7c08be6d3381ce030541e4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of moves required to move along the </font></font></i> <font style="vertical-align: inherit;"><a href="https://catlikecoding.com/unity/tutorials/hex-map/part-17/turn-based-movement/turn-based-movement.unitypackage" rel="nofollow"><font style="vertical-align: inherit;">unitypackage </font></a><i><font style="vertical-align: inherit;">path</font></i></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-17/turn-based-movement/turn-based-movement.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instant Ways </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, when we play a game, we do not care how the pathfinding algorithm finds the path. </font><font style="vertical-align: inherit;">We want to immediately see the requested path. </font><font style="vertical-align: inherit;">At the moment we can be sure that the algorithm is working, so let's get rid of the search visualization.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Without korutin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the slow passage of the algorithm, we used korutinu. </font><font style="vertical-align: inherit;">We don‚Äôt need to do this anymore, so we‚Äôll get rid of calls </font></font><code>StartCoroutine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>StopAllCoroutines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, we just call </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as usual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// StopAllCoroutines(); ‚Ä¶ } public void FindPath (HexCell fromCell, HexCell toCell, int speed) { // StopAllCoroutines(); // StartCoroutine(Search(fromCell, toCell, speed)); Search(fromCell, toCell, speed); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we no longer use </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as a corutin, he does not need a yield, so we‚Äôll get rid of this operator. </font><font style="vertical-align: inherit;">This means that we will also delete the declaration </font></font><code>WaitForSeconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and change the returned type of the method to </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// WaitForSeconds delay = new WaitForSeconds(1 / 60f); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { // yield return delay; HexCell current = searchFrontier.Dequeue(); ‚Ä¶ } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instant results</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Determination of search time </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can get the paths instantly, but how fast are they calculated? Short cuts appear almost immediately, but long paths on large maps may seem a bit slow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's measure how long it takes to search and display the path. We can use a profiler to determine the search time, but this is a bit too much and creates additional costs. Let's use instead </font></font><code>Stopwatch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is in namespace </font></font><code>System.Diagnostics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Since we only use it temporarily, I will not add a construct </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the beginning of the script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Right before performing the search, create a new stopwatch and launch it. After the search is completed, stopwatch will be stopped and the elapsed time will be output to the console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's choose the worst case for our algorithm - a search from the bottom left to the top right corner of the large map. The worst is the monotonous map, because the algorithm will have to process all 4,800 cells of the map.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce1/c03/524/ce1c0352479d7d8cddcff0b014291662.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Search for the worst case The time</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spent on the search may be different, because the Unity editor is not the only process running on your machine. Therefore, test it several times to get an understanding of the average duration. In my case, the search takes about 45 milliseconds. This is not very much and corresponds to 22.22 paths per second; denote this as 22 pps (paths per second). This means that the frame rate of the game will also decrease by a maximum of 22 fps in that frame when this path is calculated. And this is without taking into account all the other work, for example, rendering the frame itself. That is, we get a fairly large reduction in the frame rate, it will drop to 20 fps.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When performing such performance testing, you need to consider that the performance of the Unity editor will not be as high as the performance of the finished application. </font><font style="vertical-align: inherit;">If I perform the same test with the assembly, then on average it will take only 15 ms. </font><font style="vertical-align: inherit;">That is 66 pps, which is much better. </font><font style="vertical-align: inherit;">However, this is still a large part of the resources allocated to a frame, so the frame rate will be below 60 fps.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where can I see the debug log for the build?</font></font></b> <div class="spoiler_text">  Unity     ,    .     .  ,       ,   Unity  <a href="https://docs.unity3d.com/Manual/LogFiles.html">Log Files</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search only when needed </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can make a simple optimization - perform a search only when it is needed. </font><font style="vertical-align: inherit;">While we initiate a new search in each frame in which the mouse button is held down. </font><font style="vertical-align: inherit;">Therefore, the frame rate will constantly be underestimated while dragging. </font><font style="vertical-align: inherit;">We can avoid this by initiating a new search </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only when we are actually dealing with a new end point. </font><font style="vertical-align: inherit;">If not, then the current visible path is still valid.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell) { searchFromCell.DisableHighlight(); } searchFromCell = currentCell; searchFromCell.EnableHighlight(Color.blue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell) { hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFromCell &amp;&amp; searchFromCell != currentCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchToCell != currentCell) { searchToCell = currentCell; hexGrid.FindPath(searchFromCell, searchToCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Show tags for path only </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Showing progress marks is quite a costly operation, especially because we use a non-optimized approach. </font><font style="vertical-align: inherit;">Performing this operation for all cells will definitely slow down the execution. </font><font style="vertical-align: inherit;">So let's skip tagging c </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; <span class="hljs-comment"><span class="hljs-comment">// neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.SetLabel(turn.ToString()); neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to see this information only for the path found. </font><font style="vertical-align: inherit;">Therefore, after reaching the end point, we will calculate the course and set labels only for those cells that are on the way.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { current = current.PathFrom; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != fromCell) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/090/f8f/2f1/090f8f2f121b6fafdb7b95d48fb41c8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We display labels only for path cells.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we include only labels of cells that are between the initial and final. </font><font style="vertical-align: inherit;">But the end point is the most important, we should also give it a label. </font><font style="vertical-align: inherit;">You can do this by starting the path loop from the end cell, not the cell in front of it. </font><font style="vertical-align: inherit;">At the same time, the end point light from the red one will change to white, therefore we will remove its illumination under the cycle.</font></font><br><br><pre> <code class="cs hljs"> fromCell.EnableHighlight(Color.blue); <span class="hljs-comment"><span class="hljs-comment">// toCell.EnableHighlight(Color.red); fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); if (current == toCell) { // current = current.PathFrom; while (current != fromCell) { int turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } toCell.EnableHighlight(Color.red); break; } ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/273/ea9/dda273ea9b4aa1767db16c19abf512cd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The progress information is most important for the end point.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After these changes, the worst case time was reduced to 23 milliseconds in the editor and to 6 milliseconds in the finished assembly. </font><font style="vertical-align: inherit;">These are 43 pps and 166 pps - much better. </font></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-17/instant-paths/instant-paths.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The smartest search </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous section, we made the search procedure smarter by implementing the A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, in reality, we still do not perform the search in the most optimal way. </font><font style="vertical-align: inherit;">In each iteration, we calculate the distances from the current cell to all its neighbors. </font><font style="vertical-align: inherit;">This is true for cells that are not yet or are currently part of the search boundary. </font><font style="vertical-align: inherit;">But cells that are already removed from the border, no longer need to be considered, because we have already found the shortest path to these cells. </font><font style="vertical-align: inherit;">The correct implementation of A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> skips these cells, so we can do the same.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cell Search Phase </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How do we know that the cell has already left the border? </font><font style="vertical-align: inherit;">While we can not determine this. </font><font style="vertical-align: inherit;">Therefore, you need to keep track of what phase of the search is a cell. </font><font style="vertical-align: inherit;">She has not yet been in the border or is in it now, or is abroad. </font><font style="vertical-align: inherit;">We can track this by adding to a </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple integer property.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SearchPhase { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, 0 means that the cells have not yet reached, 1 - that the cell is in the border now, and 2 - that it has already been removed from the border. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hitting the border </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can reset all cells to 0 and always use 1 for the border. </font><font style="vertical-align: inherit;">Or we can increase the number of borders with each new search. </font><font style="vertical-align: inherit;">Due to this, we will not have to deal with the discharge of cells, if we each time increase the number of the border by two.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to set the cell search phase when adding them to the border. </font><font style="vertical-align: inherit;">The process begins with the initial cell, which is added to the border.</font></font><br><br><pre> <code class="cs hljs"> fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And also every time we add a neighbor to the border. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Border check </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, to verify that the cell has not yet been added to the border, we used a distance equal to </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now we can compare the cell search phase with the current border.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// if (neighbor.Distance == int.MaxValue) { if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; neighbor.PathFrom = current; neighbor.SearchHeuristic = neighbor.coordinates.DistanceTo(toCell.coordinates); searchFrontier.Enqueue(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This means that we no longer need to reset the distance of the cells before the search, that is, we have to do less work, which is good. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// cells[i].Distance = int.MaxValue; cells[i].SetLabel(null); cells[i].DisableHighlight(); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leaving the border </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a cell is removed from the border, we denote this by increasing its search phase. </font><font style="vertical-align: inherit;">This puts it beyond the current boundary and before the next one.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we can skip cells that are removed from the border, avoiding meaningless calculation and comparison of distances. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, our algorithm still produces the same results, but more efficiently. </font><font style="vertical-align: inherit;">On my machine, the worst case search takes 20 ms in the editor and 5 ms in the assembly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also calculate how many times the cell has been processed by the algorithm, increasing the counter when calculating the distance to the cell. </font><font style="vertical-align: inherit;">In the past, in the worst case, our algorithm calculated 28,239 distances. </font><font style="vertical-align: inherit;">In the finished algorithm A </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*,</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we calculate 14,220 distances. </font><font style="vertical-align: inherit;">The amount decreased by 50%. </font><font style="vertical-align: inherit;">The degree of influence of these indicators on performance depends on the cost of calculating the cost of moving. </font><font style="vertical-align: inherit;">In our case there is not so much work here, so the improvement in the assembly is not very large, but it is very noticeable in the editor. </font></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-17/smartest-search/smartest-search.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clearing the way </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When initiating a new search, we first need to clear the visualization of the previous path. </font><font style="vertical-align: inherit;">While we are doing this, turning off the selection and removing the labels from each cell of the grid. </font><font style="vertical-align: inherit;">This is a very heavy approach. </font><font style="vertical-align: inherit;">Ideally, we only need to reset the cells that were part of the previous path.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search only </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start by completely removing the visualization code from </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He only needs to search for the path and not necessarily know what we will do with this information.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // cells[i].SetLabel(null); // cells[i].DisableHighlight(); // } // fromCell.EnableHighlight(Color.blue); fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = 0; searchFrontier.Enqueue(fromCell); while (searchFrontier.Count &gt; 0) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += 1; if (current == toCell) { // while (current != fromCell) { // int turn = current.Distance / speed; // current.SetLabel(turn.ToString()); // current.EnableHighlight(Color.white); // current = current.PathFrom; // } // toCell.EnableHighlight(Color.red); // break; } ‚Ä¶ } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To report that </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">found the path, we will return boolean.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == toCell) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remember the way </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the path is found, we need to remember it. </font><font style="vertical-align: inherit;">Due to this we will be able to clean it in the future. </font><font style="vertical-align: inherit;">Therefore, we will track the end points and whether there is a path between them.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentPathFrom, currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> currentPathExists; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { System.Diagnostics.Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.Diagnostics.Stopwatch(); sw.Start(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); sw.Stop(); Debug.Log(sw.ElapsedMilliseconds); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display the path again. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use the search data we recorded to visualize the path again. </font><font style="vertical-align: inherit;">Create a new method for this </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will cycle through the end to the beginning of the path, highlighting the cells and assigning them a turn value. </font><font style="vertical-align: inherit;">To do this, we need to know the speed, so we will make it a parameter. </font><font style="vertical-align: inherit;">If we do not have a path, then the method will simply select the end points.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = current.Distance / speed; current.SetLabel(turn.ToString()); current.EnableHighlight(Color.white); current = current.PathFrom; } } currentPathFrom.EnableHighlight(Color.blue); currentPathTo.EnableHighlight(Color.red); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call this method in </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after the search.</font></font><br><br><pre> <code class="cs hljs"> currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cleaning up </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We see the path again, but now it is not removed. </font><font style="vertical-align: inherit;">To clear it, create a method </font></font><code>ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In essence, it is a copy </font></font><code>ShowPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, except that it turns off selections and labels, and does not include them. </font><font style="vertical-align: inherit;">Having done this, he must clear the recorded path data that is no longer valid.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { current.SetLabel(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); current.DisableHighlight(); current = current.PathFrom; } current.DisableHighlight(); currentPathExists = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } currentPathFrom = currentPathTo = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this method we can clear the visualization of the old path, visiting only the necessary cells, the size of the map is no longer important. </font><font style="vertical-align: inherit;">Call it </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">before starting a new search.</font></font><br><br><pre> <code class="cs hljs"> sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { ShowPath(speed); } sw.Stop();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, we will clear the path when creating a new map. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And also before loading another card. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The path visualization is cleared again, as before this change. </font><font style="vertical-align: inherit;">But now we use a more efficient approach, and in the worst case, the search time has decreased to 14 milliseconds. </font><font style="vertical-align: inherit;">Rather serious improvement only thanks to cleverer clearing. </font><font style="vertical-align: inherit;">The build time was reduced to 3 ms, which is 333 pps. </font><font style="vertical-align: inherit;">Thanks to this, the search for paths is perfectly applicable in real time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have achieved a quick search for paths, we can remove the temporary debugging code.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch(); // sw.Start(); ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, speed); ShowPath(speed); // sw.Stop(); // Debug.Log(sw.ElapsedMilliseconds); }</span></span></code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-17/cleaning-the-path/cleaning-the-path.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 18: troops </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We place the detachments on the map. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Save and load teams. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We find the way for the troops. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move the troops. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now that we‚Äôve figured out how to search for a path, let's place troops on the map. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/881/316/9bb/8813169bb32795f4ea1d0c4696fddde2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reinforcements arrived</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create squads </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far we have dealt only with cells and their fixed objects. </font><font style="vertical-align: inherit;">Troops differ from them in that they are mobile. </font><font style="vertical-align: inherit;">A detachment can denote anything of any scale, from one person or vehicle to an entire army. </font><font style="vertical-align: inherit;">In this tutorial we restrict ourselves to a simple generalized type of detachment. </font><font style="vertical-align: inherit;">After this, we will move on to supporting combinations of several types of units.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prefab squad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To work with units we will create a new type of component </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For now, let's start with an empty one </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and later add functionality to it.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create an empty game object with this component, which should become a prefab. </font><font style="vertical-align: inherit;">This will be the root object of the squad.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8de/c85/2f2/8dec852f21d7aaa2c3002dc119d890ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefab squad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a 3D model symbolizing the squad as a child. </font><font style="vertical-align: inherit;">I used a simple scaled cube to which I created the blue material. </font><font style="vertical-align: inherit;">The root object determines the level of the squad's land, so we will displace the child element accordingly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be6/157/db2/be6157db233e9e6fc0a40eae6747c731.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Child element-cube</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add a collider to the squad to make it easier to choose later. </font><font style="vertical-align: inherit;">The standard cube collider is fine for us, just make sure that the collider fits in one cell.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creation of squad instances </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we have no gameplay yet, the creation of units takes place in edit mode. </font><font style="vertical-align: inherit;">Therefore, this should deal with </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For this, he needs a prefab, so we will add a field </font></font><code>HexUnit unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and connect it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b00/4bd/85cb004bd7bae06a6feaa8c93f144de9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connecting the prefab</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When creating squads, we will place them on the cell under the cursor. </font><font style="vertical-align: inherit;">In </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is a code for finding this cell when editing relief. </font><font style="vertical-align: inherit;">Now we need it for the troops, so move the corresponding code to a separate method.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can use this method in </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, simplifying it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); // RaycastHit hit; // if (Physics.Raycast(inputRay, out hit)) { // HexCell currentCell = hexGrid.GetCell(hit.point); HexCell currentCell = GetCellUnderCursor(); if (currentCell) { ‚Ä¶ } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, add a new method </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that also uses </font></font><code>GetCellUnderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If there is a cell, we will create a new squad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { Instantiate(unitPrefab); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To keep the hierarchy clear, let's use the grid as a parent element for all game objects of units. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The easiest way to add </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">support for the creation of units through keystrokes. </font><font style="vertical-align: inherit;">Change the method </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it calls </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when you press the U key. As in the case of c </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this should occur if the cursor is not over the GUI element. </font><font style="vertical-align: inherit;">First we‚Äôll check to see if we should edit the map, and if not, then we‚Äôll check whether we should add a squad. </font><font style="vertical-align: inherit;">If yes, then we call </font></font><code>CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// if ( // Input.GetMouseButton(0) &amp;&amp; // !EventSystem.current.IsPointerOverGameObject() // ) { // HandleInput(); // } // else { // previousCell = null; // } if (!EventSystem.current.IsPointerOverGameObject()) { if (Input.GetMouseButton(0)) { HandleInput(); return; } if (Input.GetKeyDown(KeyCode.U)) { CreateUnit(); return; } } previousCell = null; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55e/b48/c86/55eb48c8601711d74720f29cfba7a4f3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Created instance of the squad</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Detachment placement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can create units, but they appear at the origin of the map. </font><font style="vertical-align: inherit;">We need to put them in the right place. </font><font style="vertical-align: inherit;">For this it is necessary that the detachments know about their position. </font><font style="vertical-align: inherit;">Therefore, we add to the </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denoting the cell they occupy. </font><font style="vertical-align: inherit;">When setting the property, we change the position of the squad so that it corresponds to the position of the cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } } HexCell location;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must assign the position of the squad cell under the cursor. </font><font style="vertical-align: inherit;">Then the troops will be where they should be.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf6/71f/92d/bf671f92d2e587bebec2bf08efafadbc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detachments on the map</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Troop orientation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far all units have the same orientation, which looks rather unnatural. </font><font style="vertical-align: inherit;">To revive them, add to the </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This value is a float, denoting the unit's rotation along the Y axis in degrees. </font><font style="vertical-align: inherit;">When it is assigned, we will appropriately change the rotation of the game object itself.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Orientation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { orientation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assign a random rotation from 0 to 360 degrees.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { HexUnit unit = Instantiate(unitPrefab); unit.transform.SetParent(hexGrid.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/c4a/8c9/74fc4a8c943830b4abd6049889b41843.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different orientation of units</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One squad per cell </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troops look good, if not created in a single cell. </font><font style="vertical-align: inherit;">In this case, we get a cluster of strange looking cubes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/a68/4b6/9f8a684b6425be20e23ac65901bf5888.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superimposed squads</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Some games allow several squads to be placed in one place, others are not. </font><font style="vertical-align: inherit;">Since it is easier to work with one unit per cell, I will choose this option. </font><font style="vertical-align: inherit;">This means that we must create a new squad only when the current cell is not busy. </font><font style="vertical-align: inherit;">That it was possible to learn, we will add in </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standard property </font></font><code>Unit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit Unit { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use this property in </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to let the cell know if a squad is standing on it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it </font></font><code>HexMapEditor.CreateUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can check if the current cell is free.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { HexUnit unit = Instantiate(unitPrefab); unit.Location = cell; unit.Orientation = Random.Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editing occupied cells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initially, units are placed correctly, but this may change if their cells are further edited. </font><font style="vertical-align: inherit;">If the height of the cell changes, the detachment occupying it will either hang over it or sink into it.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/b7d/1c1/27bb7d1c120bc1546dfa0fd42823d66c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanging and drowned troops.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The solution is to check the position of the squad after making changes. </font><font style="vertical-align: inherit;">To do this, add a method to </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">While we are only interested in the position of the squad, so just set it again.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateLocation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition = location.Position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We must coordinate the position of the squad when the cell is updated, which happens when methods </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objects are </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">called. </font><font style="vertical-align: inherit;">Of course, this is only necessary when there really is a detachment in the cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Unit) { Unit.ValidateLocation(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Detachment removal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to creating units, it would be useful to destroy them. </font><font style="vertical-align: inherit;">Therefore, we add to the </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He must check whether there is a squad in the cell under the cursor, and if so, destroy the squad's game object.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { Destroy(cell.Unit.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider, to get to the squad, we go through the cell. </font><font style="vertical-align: inherit;">To interact with the squad it is enough to hover the mouse on its cell. </font><font style="vertical-align: inherit;">Therefore, for this to work, the detachment does not need to have a collider. </font><font style="vertical-align: inherit;">However, adding a collider simplifies their selection, because it blocks the rays that would otherwise collide with the cell behind the squad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use a combination of left Shift + U </font><font style="vertical-align: inherit;">to destroy a squadron </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { DestroyUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CreateUnit(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case when we create and destroy several units, let's be careful and clear the property when removing a unit. </font><font style="vertical-align: inherit;">That is, we explicitly clear the cell reference to the squad. </font><font style="vertical-align: inherit;">Add to the </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>Die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will do this, as well as the destruction of its own game object.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will call this method in </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not destroy the squad directly.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// Destroy(cell.Unit.gameObject); cell.Unit.Die(); } }</span></span></code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-18/creating-units/creating-units.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saving and loading units </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we can have troops on the map, we need to include them in the process of saving and loading. </font><font style="vertical-align: inherit;">We can approach this task in two ways. </font><font style="vertical-align: inherit;">The first is to record squad data when recording a cell so that the data of the cell and the squad are mixed. </font><font style="vertical-align: inherit;">The second way is to save the data of cells and units separately. </font><font style="vertical-align: inherit;">Although it may seem that the first approach is easier to implement, the second gives us more structured data. </font><font style="vertical-align: inherit;">If we share the data, it will be easier to work with them in the future.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit tracking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To keep all the troops together, we need to track them. </font><font style="vertical-align: inherit;">We will do this by adding to </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the squad list. </font><font style="vertical-align: inherit;">This list should contain all units on the map.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexUnit&gt; units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexUnit&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating or loading a new map, we need to get rid of all the units that are on the map. </font><font style="vertical-align: inherit;">To simplify this process, create a method </font></font><code>ClearUnits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that kills everyone in the list and clears it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearUnits</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Die(); } units.Clear(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call this method in </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and in </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's do it after clearing the way.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ClearPath(); ClearUnits(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adding squads to the grid </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when creating new units, we need to add them to the list. </font><font style="vertical-align: inherit;">Let's set a method for this </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will also deal with the location of the detachment and the setting of the parameters of its parent object.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it </font></font><code>HexMapEditor.CreatUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be enough to call </font></font><code>AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a new instance of the detachment, its location and random orientation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; !cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// HexUnit unit = Instantiate(unitPrefab); // unit.transform.SetParent(hexGrid.transform, false); // unit.Location = cell; // unit.Orientation = Random.Range(0f, 360f); hexGrid.AddUnit( Instantiate(unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Removing units from the grid </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a method to remove a detachment and in </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Just remove the squad from the list and order him to die.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { units.Remove(unit); unit.Die(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call this method in </font></font><code>HexMapEditor.DestroyUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, instead of destroying a squad directly.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = GetCellUnderCursor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell &amp;&amp; cell.Unit) { <span class="hljs-comment"><span class="hljs-comment">// cell.Unit.Die(); hexGrid.RemoveUnit(cell.Unit); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saving troops </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we are going to keep all the units together, we need to remember which cells they occupy. </font><font style="vertical-align: inherit;">The most reliable way is to save the coordinates of their location. </font><font style="vertical-align: inherit;">To make this possible, add to the </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that writes its fields X and Z.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(x); writer.Write(z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can now record the coordinates and orientation of the squad. </font><font style="vertical-align: inherit;">This is all data detachments that we have at the moment.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { location.coordinates.Save(writer); writer.Write(orientation); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As it </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tracks troops, its method </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will record the data of the troops. </font><font style="vertical-align: inherit;">First we write down the total number of units, and then we go round them all in a cycle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } writer.Write(units.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { units[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have changed the saved data, so we will increase the version number </font></font><code>SaveLoadMenu.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to 2. The old download code will still work, because it simply will not read the detachment data. </font><font style="vertical-align: inherit;">However, it is necessary to increase the version number in order to report that there are detachment data in the file.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">2</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loading troops </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since it </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a structure, it does not make much sense to add the usual method to it </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We make it a static method that reads and returns the saved coordinates.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates c; cx = reader.ReadInt32(); cz = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the number of units is variable, we do not have pre-existing units into which data can be loaded. </font><font style="vertical-align: inherit;">We can create new squad instances before loading their data, but this will require </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creating instances of new squads at boot time. </font><font style="vertical-align: inherit;">So it is better to leave it </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We also use the static method </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's start with a simple readout of these units. </font><font style="vertical-align: inherit;">To read the value of the float orientation, we use the method </font></font><code>BinaryReader.ReadSingle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why Single?</font></font></b> <div class="spoiler_text">  <code>float</code>        ,     .     ,   <code>double</code> ,     .  Unity   . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next step is to create an instance of a new squad. </font><font style="vertical-align: inherit;">However, for this we need a link to the prefab of the detachment. </font><font style="vertical-align: inherit;">So as not to complicate, let's add to this </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static method.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexUnit unitPrefab;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To set this link, let's use it again </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as we did with the noise texture. </font><font style="vertical-align: inherit;">When we need to support many types of units, we will move on to a better solution.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexUnit unitPrefab; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/251/e2e/9c0/251e2e9c0e0f9ec8c6da0a0a7bce6f85.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passing the unit's prefab.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After connecting the field, we no longer need a direct link to </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, he can use </font></font><code>HexUnit.unitPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public HexUnit unitPrefab; ‚Ä¶ void CreateUnit () { HexCell cell = GetCellUnderCursor(); if (cell &amp;&amp; !cell.Unit) { hexGrid.AddUnit( Instantiate(HexUnit.unitPrefab), cell, Random.Range(0f, 360f) ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can create a copy of the new squad in </font></font><code>HexUnit.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead of returning it, we can use the loaded coordinates and orientation to add it to the grid. </font><font style="vertical-align: inherit;">To make this possible, add a parameter </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, HexGrid grid</span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = HexCoordinates.Load(reader); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> orientation = reader.ReadSingle(); grid.AddUnit( Instantiate(unitPrefab), grid.GetCell(coordinates), orientation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we count the number of units and use it to load all the saved units, passing ourselves as an additional argument.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of course, this will only work for save files with a version of at least 2, in the younger versions there are no download teams. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unitCount = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; unitCount; i++) { HexUnit.Load(reader, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can correctly load version 2 files, therefore </font></font><code>SaveLoadMenu.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will increase the supported version number to 2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-18/saving-and-loading-units/saving-and-loading-units.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moving units </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The troops are mobile, so we should be able to move them around the map. </font><font style="vertical-align: inherit;">We already have the path search code, but for now we have tested it only for arbitrary locations. </font><font style="vertical-align: inherit;">Now we need to remove the old test UI and create a new UI to control the units.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cleaning up the map editor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving units along paths is part of the actual gameplay, it does not apply to the map editor. </font><font style="vertical-align: inherit;">Therefore, let's get rid </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of all the code associated with finding the path.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// HexCell previousCell, searchFromCell, searchToCell; HexCell previousCell; ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } if (editMode) { EditCells(currentCell); } // else if ( // Input.GetKey(KeyCode.LeftShift) &amp;&amp; searchToCell != currentCell // ) { // if (searchFromCell != currentCell) { // if (searchFromCell) { // searchFromCell.DisableHighlight(); // } // searchFromCell = currentCell; // searchFromCell.EnableHighlight(Color.blue); // if (searchToCell) { // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } // } // else if (searchFromCell &amp;&amp; searchFromCell != currentCell) { // if (searchToCell != currentCell) { // searchToCell = currentCell; // hexGrid.FindPath(searchFromCell, searchToCell, 24); // } // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After removing this code, it no longer makes sense to keep the editor active when we are not in edit mode. </font><font style="vertical-align: inherit;">Therefore, instead of a field for tracking mode, we can simply enable or disable the component </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In addition, now the editor should not deal with UI tags.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// bool editMode; ‚Ä¶ public void SetEditMode (bool toggle) { // editMode = toggle; // hexGrid.ShowUI(!toggle); enabled = toggle; } ‚Ä¶ void HandleInput () { HexCell currentCell = GetCellUnderCursor(); if (currentCell) { if (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } else { isDrag = false; } // if (editMode) { EditCells(currentCell); // } previousCell = currentCell; } else { previousCell = null; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since by default we are not in map editing mode, in Awake we will disable the editor. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is necessary to use raycast to search for the current cell under the cursor when editing the map and to control the troops. </font><font style="vertical-align: inherit;">Perhaps in the future it will be useful to us and for something else. </font><font style="vertical-align: inherit;">Let's move the raycasting logic out </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to a new method </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a parameter-ray.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetCell(hit.point); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> <code>HexMapEditor.GetCellUniderCursor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> may simply call this method with the cursor ray. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellUnderCursor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexGrid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game UI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To control the game mode UI, we will use the new component. </font><font style="vertical-align: inherit;">While he will be engaged only in the selection and movement of troops. </font><font style="vertical-align: inherit;">Create a new component type for it </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To do his job he has enough links to the grid.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGameUI</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add this component to the new game object in the UI hierarchy. </font><font style="vertical-align: inherit;">It does not have to have its own object, but it will be obvious to us that there is a separate UI for the game.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/515/769/bdd/515769bdd0b6fbee9cb8451348595a57.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b3/b7c/0d7/9b3b7c0d719d05862a76ba8e70409970.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Object Game UI</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add a </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as in </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The game UI should be enabled when we are not in edit mode. </font><font style="vertical-align: inherit;">In addition, you need to include tags here, because the game UI works with paths.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a game UI method to the event list of the edit mode switch. </font><font style="vertical-align: inherit;">This will mean that when a player changes the mode, both methods are invoked.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92b/dde/778/92bdde778bfc97ae4b5bdc1d49a2bb6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multiple event methods. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tracking the current cell </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the situation, </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you need to know which cell is currently under the cursor. </font><font style="vertical-align: inherit;">Therefore we will add to it a field </font></font><code>currentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell currentCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a method </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that uses </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the cursor ray to update this field.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { currentCell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When updating the current cell, we may need to know if it has changed. </font><font style="vertical-align: inherit;">Make it </font></font><code>UpdateCurrentCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return this information.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCurrentCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexCell cell = grid.GetCell(Camera.main.ScreenPointToRay(Input.mousePosition)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell != currentCell) { currentCell = cell; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squad selection </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before you move a squad, you need to select and track it. </font><font style="vertical-align: inherit;">Therefore, we add a field </font></font><code>selectedUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexUnit selectedUnit;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we try to make a selection, we need to start by updating the current cell. </font><font style="vertical-align: inherit;">If the current cell is, then the unit occupying this cell becomes the selected unit. </font><font style="vertical-align: inherit;">If there is no squad in the cell, then no squad is selected. </font><font style="vertical-align: inherit;">Let's create a method for this </font></font><code>DoSelection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implement the selection of units with a simple click of the mouse. </font><font style="vertical-align: inherit;">Therefore, we will add a method </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that performs the selection when the mouse button 0 is activated. Of course, we need to execute it only when the cursor is not over the GUI element.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, we learned to select one squad at a time by clicking the mouse. </font><font style="vertical-align: inherit;">When you click on an empty cell, the choice of any unit is removed. </font><font style="vertical-align: inherit;">But while we do not receive any visual confirmation of this.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search path squad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a squad is selected, we can use its location as a starting point for finding the way. </font><font style="vertical-align: inherit;">To activate this, we will not require another mouse click. </font><font style="vertical-align: inherit;">Instead, we will automatically find and show the path between the squad position and the current cell. </font><font style="vertical-align: inherit;">We will always do this in </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, except when the selection is made. </font><font style="vertical-align: inherit;">For this, when we have a squad, we call the method </font></font><code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { DoPathfinding(); } } }</code> </pre> <br> <code>DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simply updates the current cell and calls </font></font><code>HexGrid.FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if there is an end point. </font><font style="vertical-align: inherit;">We again use a constant speed of 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UpdateCurrentCell(); grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider that we should not find a new path with every update, but only when changing the current cell. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/8d1/ce9/39f8d1ce9040ae5370fd12f447ecd8e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finding the path for the squad</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we see the path that appears when you move the cursor after selecting a squad. </font><font style="vertical-align: inherit;">Because of this, it is obvious which unit is selected. </font><font style="vertical-align: inherit;">However, paths are not always cleared correctly. </font><font style="vertical-align: inherit;">To begin, let's clear the old path if the cursor is outside the map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, for this to happen, it needs to </font></font><code>HexGrid.ClearPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be general, so we will make such a change.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secondly, we will clear the old way when choosing a detachment. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSelection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { grid.ClearPath(); UpdateCurrentCell(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell) { selectedUnit = currentCell.Unit; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, let's clear the path when changing the edit mode. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search only for valid endpoints </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can not always find a way, because sometimes it is impossible to reach the final cell. </font><font style="vertical-align: inherit;">This is normal. </font><font style="vertical-align: inherit;">But sometimes the final cell itself is not valid. </font><font style="vertical-align: inherit;">For example, we decided that paths could not include underwater cells. </font><font style="vertical-align: inherit;">But this may depend on the detachment. </font><font style="vertical-align: inherit;">Let's add to the </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method that tells us whether the cell is a valid endpoint. </font><font style="vertical-align: inherit;">Underwater cells are not.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we allowed only one detachment to stand in the cell. </font><font style="vertical-align: inherit;">Therefore, the final cell will not be valid if it is busy.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use this method </font></font><code>HexGameUI.DoPathfinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to ignore invalid endpoints.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, <span class="hljs-number"><span class="hljs-number">24</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move to end point </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have a valid path, then we can move the squad to the end point. </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">knows when it can be done. </font><font style="vertical-align: inherit;">Let's make it so that it passes this information in a read-only new property </font></font><code>HasPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentPathExists; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To move a squad, add to the </font></font><code>HexGameUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This method will be called when the command is given and if the unit is selected. </font><font style="vertical-align: inherit;">Therefore, he must check whether there is a path and, if so, change the position of the squad. </font><font style="vertical-align: inherit;">While we immediately teleport the detachment to the end point. </font><font style="vertical-align: inherit;">In one of the following tutorials, we will make the squad actually go all the way.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { selectedUnit.Location = currentCell; grid.ClearPath(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's use the mouse button 1 to issue a command (right click). </font><font style="vertical-align: inherit;">We will check this if a squad is selected. </font><font style="vertical-align: inherit;">If the button is not pressed, then we perform the search path.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventSystem.current.IsPointerOverGameObject()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { DoSelection(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedUnit) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { DoMove(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DoPathfinding(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can move troops! </font><font style="vertical-align: inherit;">But sometimes they refuse to find the path to some cells. </font><font style="vertical-align: inherit;">In particular, to those cells in which there was a detachment before. </font><font style="vertical-align: inherit;">This happens because it </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not update the old location when setting a new one. </font><font style="vertical-align: inherit;">To fix this, we will clear the link to the squad in its old location.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoid squads </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The search for the path now works correctly, and the troops can teleport along the map. </font><font style="vertical-align: inherit;">Although they can not move into the cells in which there is already a detachment, as long as the detachments standing in the way are ignored.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/3d8/7dd/5193d87dd25bfa2fbc9e0ba26529b926.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troops on the way are ignored.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Troops of the same faction can usually move through each other, but so far we have no factions. </font><font style="vertical-align: inherit;">Therefore, let's consider all units unrelated to each other and blocking the way. </font><font style="vertical-align: inherit;">This can be done by skipping busy cells in </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater || neighbor.Unit) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3c/f3b/698/f3cf3b698191010f55c0c994d3e324d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid detachments </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-18/moving-units/moving-units.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 19: Tween Motion </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move the units between the cells. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualize the path traveled. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move the troops on the curves. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We force troops to look in the direction of movement. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this part, we will force the units to move along paths instead of teleportation. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a08/e41/a4f/a08e41a4fd0e90ea26dc11f16ff518f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troops on the way</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Driving on the way </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous part, we added troops and the ability to move them. </font><font style="vertical-align: inherit;">Although we used the search for a path to determine the acceptable endpoints, after the command was sent, the detachments simply teleported to the final cell. </font><font style="vertical-align: inherit;">In order for them to actually follow the path found, we need to track this path and create an animation process that forces the squad to move from cell to cell. </font><font style="vertical-align: inherit;">Since looking at the animation is difficult to see how the squad moved, we also visualize the path traveled with the help of gizmos. </font><font style="vertical-align: inherit;">But before moving on, we need to correct the error.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bug with turns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to an oversight, we incorrectly calculate the course on which the cell will be reached. </font><font style="vertical-align: inherit;">Now we determine the course by dividing the total distance by the detachment speed.</font></font><math></math><script type="math/tex">t = d / s</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and discarding residue. </font><font style="vertical-align: inherit;">An error occurs when you need to spend exactly any remaining movement points on the course to enter the cell. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, when each step is 1, and the speed is 3, then we can move three cells per turn. </font><font style="vertical-align: inherit;">However, with the existing calculations, we can take only two steps in the first move, because for the third step</font></font><math></math><script type="math/tex">t = d / s = 3 / 3 = 1</script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d80/9ec/098/d809ec098cac1850cf16d47ce45ed030.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total costs for moving with incorrectly determined moves, speed 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In order to calculate moves correctly, we need to move the boundary one step from the initial cell. </font><font style="vertical-align: inherit;">We can do this by calculating the move by reducing the distance by 1. Then the move for the third step will be</font></font><math></math><script type="math/tex">t = 2 / 3 = 0</script><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/291/37e/65629137e3267e033d1f5f6d3fd1f724.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correct moves.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We can do this by changing the calculation formula to</font></font><math></math><script type="math/tex">t = (d - 1) / s</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make this change to </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentTurn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + moveCost; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (turn &gt; currentTurn) { distance = turn * speed + moveCost; } ‚Ä¶ } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the move labels as well. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentPathExists) { HexCell current = currentPathTo; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != currentPathFrom) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turn = (current.Distance - <span class="hljs-number"><span class="hljs-number">1</span></span>) / speed; ‚Ä¶ } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that with this approach, the stroke of the initial cell is ‚àí1. </font><font style="vertical-align: inherit;">This is normal, because we do not display it, and the search algorithm remains intact.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Getting a way </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving along the path is the task of the squad. </font><font style="vertical-align: inherit;">To do this, he needs to know the way. </font><font style="vertical-align: inherit;">This information is in y </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so add to it a method to get the current path in the form of a list of cells. </font><font style="vertical-align: inherit;">He can take it from the pool of lists and return if there really is a path.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentPathExists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The list is filled by following the path reference from the destination cell to the initial one, as is done when visualizing the path. </font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; path = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case, we need the entire path, which includes the starting cell. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexCell c = currentPathTo; c != currentPathFrom; c = c.PathFrom) { path.Add(c); } path.Add(currentPathFrom); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have a way in reverse order. </font><font style="vertical-align: inherit;">We can work with him, but it will not be very intuitive. </font><font style="vertical-align: inherit;">Let's reverse the list so that it goes from the beginning to the end.</font></font><br><br><pre> <code class="cs hljs"> path.Add(currentPathFrom); path.Reverse(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motion request </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can add to the </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method that orders it to follow the path. </font><font style="vertical-align: inherit;">Initially, we simply let him teleport to the destination cell. </font><font style="vertical-align: inherit;">We will not immediately return the list to the pool, because it will be useful to us for a while.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To request movement, we change it </font></font><code>HexGameUI.DoMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it calls the new method with the current path, and not just specifies the location of the squad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMove</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.HasPath) { <span class="hljs-comment"><span class="hljs-comment">// selectedUnit.Location = currentCell; selectedUnit.Travel(grid.GetPath()); grid.ClearPath(); } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualization of the way </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we begin to animate the squad, let's check that the paths are correct. </font><font style="vertical-align: inherit;">We will do this by ordering us to </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remember the path that it must travel in order to be able to visualize it using gizmos.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; pathToTravel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a method </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to show the last path to be taken (if it exists). </font><font style="vertical-align: inherit;">If the squad has not moved yet, the path must be equal </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But due to Unity's serialization during editing after recompilation in Play mode, it can also be an empty list.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The easiest way to show the path is to draw a gizmo sphere for each cell in the path. </font><font style="vertical-align: inherit;">We have a sphere with a radius of 2 units.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pathToTravel.Count; i++) { Gizmos.DrawSphere(pathToTravel[i].Position, <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since we will show the way for the squad, we will be able to see all his last ways at the same time. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/907/a7d/dac907a7da12a75436c7ae26956884bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gizmos display the last traversed paths.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To better show the connections of the cells, we draw in a cycle several spheres on a straight line between the previous and the current cells. </font><font style="vertical-align: inherit;">To do this, we need to start the process from the second cell. </font><font style="vertical-align: inherit;">Spheres can be positioned using linear interpolation with an increment of 0.1 units, so we will have ten spheres per segment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/46a/11c/5c246a11c0753d03b2572de5bfc297a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">More obvious ways</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sliding along the path </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same method can be used to move units. </font><font style="vertical-align: inherit;">Let's create a corutin for this. </font><font style="vertical-align: inherit;">Instead of drawing a gizmo, we will set the squad's position. </font><font style="vertical-align: inherit;">Instead of incrementing, we use 0.1 delta time, and we will yield for each iteration. </font><font style="vertical-align: inherit;">In this case, the detachment will move from one cell to the next in one second.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexUnit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We'll start the corute at the end of the method </font></font><code>Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But before we stop all existing korutiny. </font><font style="vertical-align: inherit;">So we guarantee that two Korutins will not start at the same time, otherwise it would lead to very strange results.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { Location = path[path.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving one cell in a second is pretty slow. </font><font style="vertical-align: inherit;">The player in the game does not want to wait that long. </font><font style="vertical-align: inherit;">You can make the detachment speed the configuration option, but for now let's use a constant. </font><font style="vertical-align: inherit;">I assigned it a value of 4 cells per second; </font><font style="vertical-align: inherit;">it's pretty quick, but lets notice what's going on.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> travelSpeed = <span class="hljs-number"><span class="hljs-number">4f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { Vector3 a = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; Vector3 b = pathToTravel[i].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just as we can visualize several paths at the same time, several teams can be made to travel simultaneously. </font><font style="vertical-align: inherit;">From the point of view of the game state, the movement is still teleportation, the animations are purely visual. </font><font style="vertical-align: inherit;">Troops instantly occupy the final cell. </font><font style="vertical-align: inherit;">You can even find ways and start a new move before they have arrived. </font><font style="vertical-align: inherit;">In this case, they are visually teleported to the beginning of a new path. </font><font style="vertical-align: inherit;">This can be avoided by blocking troops or even the entire UI while they are moving, but this quick response is quite handy when developing and testing movements.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moving troops. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What about the difference in heights?</font></font></b> <div class="spoiler_text">        ,      .       ,           .        ,    .   ,      .      ,  Endless Legend,   ,         .     ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position after compilation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the disadvantages of Corutin is that they do not ‚Äúsurvive‚Äù when recompiling in Play mode. </font><font style="vertical-align: inherit;">Although the game state is always true, this can lead to the fact that the units are stuck somewhere in their last path, if you start recompilation when they are still moving. </font><font style="vertical-align: inherit;">To mitigate the consequences, let's make sure that after recompilation the detachments are always in the correct position. </font><font style="vertical-align: inherit;">This can be done by updating their position in </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; } }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-19/traveling-a-path/traveling-a-path.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Smooth movement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The movement from the center to the center of the cell looks too mechanistic and creates sharp changes of direction. </font><font style="vertical-align: inherit;">For many games this will be normal, but unacceptable if you need at least a little realistic movement. </font><font style="vertical-align: inherit;">So let's change the movement to make it look a bit more organic.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moving from edge to edge </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The squad begins its journey from the center of the cell. </font><font style="vertical-align: inherit;">He goes to the middle of the edge of the cell, and then enters the next cell. </font><font style="vertical-align: inherit;">Instead of moving to the center, he can go straight to the next edge, which he must cross. </font><font style="vertical-align: inherit;">In fact, the squad will cut the path when it needs to change direction. </font><font style="vertical-align: inherit;">This is possible for all cells except the end points of the path.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/8f0/1b9/2bc8f01b93b55b7acab8d9f56dd6f4be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three ways to move from edge to edge.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's adapt </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the mapping of paths generated in this way. </font><font style="vertical-align: inherit;">It must interpolate between the edges of the cells, which can be found by averaging the positions of neighboring cells. </font><font style="vertical-align: inherit;">We only need to calculate one edge per iteration, reusing the value from the previous iteration. </font><font style="vertical-align: inherit;">Thus, we can make the method work for the initial cell, but instead of the edge, we take its position.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += 0.1f) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), 2f); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To reach the center of the target cell, we need to use the position of the cell as the last point, not the edge. </font><font style="vertical-align: inherit;">You can add a check of this case to the loop, but this is such a simple code that it would be clearer to just duplicate the code and modify it a little.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ } a = b; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Vector3.Lerp(a, b, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/466/4d4/deb4664d4f8bcffcc3839dddfaa0d792.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edge based</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> paths The resulting paths are less like zigzags, and the maximum angle of rotation decreases from 120 ¬∞ to 90 ¬∞. </font><font style="vertical-align: inherit;">This can be considered an improvement, so apply the same changes to corutin </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to see what it looks like in the animation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 a = pathToTravel[i - 1].Position; // Vector3 b = pathToTravel[i].Position; a = b; b = (pathToTravel[i - 1].Position + pathToTravel[i].Position) * 0.5f; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } } a = b; b = pathToTravel[pathToTravel.Count - 1].Position; for (float t = 0f; t &lt; 1f; t += Time.deltaTime * travelSpeed) { transform.localPosition = Vector3.Lerp(a, b, t); yield return null; } }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving with variable speed</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After cutting corners, the length of the path segments became dependent on the change of direction. </font><font style="vertical-align: inherit;">But we set the speed in cells per second. </font><font style="vertical-align: inherit;">As a result, the detachment's speed changes randomly.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Following curves </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instant change of direction and speed when crossing the borders of the cells looks ugly. </font><font style="vertical-align: inherit;">It is better to use a gradual change in direction. </font><font style="vertical-align: inherit;">We can add support for this by forcing troops to follow curves, rather than straight lines. </font><font style="vertical-align: inherit;">To do this, you can use Bezier curves. </font><font style="vertical-align: inherit;">In particular, one can take quadratic Bezier curves in which the average control points are cell centers. </font><font style="vertical-align: inherit;">In this case, the tangents of adjacent curves will be mirror reflections of each other, that is, the whole path will turn into a continuous smooth curve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/c46/0b8/a94c460b8e7b3fd2ecc3b4ea4e3225a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curves from edge to edge</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's create an auxiliary class </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a method to get a point on a quadratic Bezier curve. </font><font style="vertical-align: inherit;">As explained in the </font></font><a href="https://catlikecoding.com/unity/tutorials/curves-and-splines/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curves and Splines tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the formula is used for this.</font></font><math></math><script type="math/tex">(1 - t)^2 A + 2(1 - t) t B + t^2 C</script>  where <math></math><script type="math/tex"> A </script>  , <math></math><script type="math/tex"> B </script>  and <math></math><script type="math/tex"> C </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Are control points and t is an interpolator. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bezier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = <span class="hljs-number"><span class="hljs-number">1f</span></span> - t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r * r * a + <span class="hljs-number"><span class="hljs-number">2f</span></span> * r * t * b + t * t * c; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shouldn't getpoint be limited to a range of 0-1?</font></font></b> <div class="spoiler_text">         0-1,    .          .  ,    <code>GetPointClamped</code> ,    <code>t</code> .      ,      <code>GetPointUnclamped</code> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To show the curve path in </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we need to track not two, but three points. </font><font style="vertical-align: inherit;">An additional point is the center of the cell with which we are working on the current iteration, having an index </font></font><code>i - 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because the cycle starts from 1. After receiving all the points, we can replace it </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>Bezier.GetPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the starting and ending cells, instead of the ending and midpoint, we can simply use the center of the cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTravel == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || pathToTravel.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += <span class="hljs-number"><span class="hljs-number">0.1f</span></span>) { Gizmos.DrawSphere(Bezier.GetPoint(a, b, c, t), <span class="hljs-number"><span class="hljs-number">2f</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/79d/cae/14079dcae70b7b2522c137e0af848883.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paths created using Bezier curves The</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> curve path looks much better. </font><font style="vertical-align: inherit;">Apply the same changes in </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and see how the units are animated with this approach.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moving along curves The</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> animation also became smooth, even when the detachment‚Äôs speed is not constant. </font><font style="vertical-align: inherit;">Since the tangent curves of adjacent segments coincide, the speed is continuous. </font><font style="vertical-align: inherit;">The change in speed occurs gradually and happens when a detachment passes through a cell, slowing down when changing direction. </font><font style="vertical-align: inherit;">If it goes straight, then the speed remains constant. </font><font style="vertical-align: inherit;">In addition, the squad starts and ends its way at zero speed. </font><font style="vertical-align: inherit;">This mimics the natural movement, so leave it that way.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Time tracking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, we started an iteration over each of the segments from 0, continuing until we reach 1. This works fine when we increase by a constant value, but our iteration depends on the time delta. When the iteration over one segment is completed, we are likely to surpass 1 by some amount depending on the time delta. This is not noticeable at a high frame rate, but can lead to jerks at a low frame rate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To avoid wasting time, we need to transfer the remaining time from one segment to the next. This can be done by tracking </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">throughout the journey, and not just in each segment. Then at the end of each segment we will subtract 1 from it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + pathToTravel[i].Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } a = c; b = pathToTravel[pathToTravel.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = b; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * traveSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we are already engaged in this, let's make sure that the time delta is taken into account at the beginning of the journey. </font><font style="vertical-align: inherit;">This means that we will start moving right away, and we will not stand idle for one frame.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we end not exactly at the moment of time when the path should end, but moments before. </font><font style="vertical-align: inherit;">Here the difference may also depend on the frame rate. </font><font style="vertical-align: inherit;">Therefore, let's make the squad complete the path at the end point.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = location.Position; }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-19/flowing-movement/flowing-movement.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Orientation animation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The troops began to move in a smooth curve, but they do not change orientation in accordance with the direction of movement. </font><font style="vertical-align: inherit;">As a result, they seem to slide. </font><font style="vertical-align: inherit;">To make the movement look like a real movement, we need to rotate them.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look forward </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As in the tutorial </font></font><a href="https://catlikecoding.com/unity/tutorials/curves-and-splines/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curves and Splines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can use the derivative of a curve to determine the orientation of a squad. </font><font style="vertical-align: inherit;">The formula for the derivative of a quadratic Bezier curve:</font></font><math></math><script type="math/tex">2 ((1 - t) (B - A) + t (C - B))</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add to the </font></font><code>Bezier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method to calculate it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDerivative</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 a, Vector3 b, Vector3 c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2f</span></span> * ((<span class="hljs-number"><span class="hljs-number">1f</span></span> - t) * (b - a) + t * (c - b)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The derivative vector is located on the same straight line with the direction of motion. </font><font style="vertical-align: inherit;">We can use the method </font></font><code>Quaternion.LookRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to convert it into a detachment's turn. </font><font style="vertical-align: inherit;">We will do this every step of the way </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ‚Ä¶ transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is there no error at the beginning of the path?</font></font></b> <div class="spoiler_text">    ,        .    <math></math><script type="math/tex"> A </script>  and <math></math><script type="math/tex"> B </script>  ,    .   ,   <math></math><script type="math/tex">t = 0</script> ,     ,      <code>Quaternion.LookRotation</code> .  ,    ,     <math></math><script type="math/tex">t = 0</script>   .     .       ,  <math></math><script type="math/tex">t > 0</script>    . <br>         ,     <math></math><script type="math/tex">t < 1</script>  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In contrast to the position of the detachment, the non-ideality of its orientation at the end of the path is not important. </font><font style="vertical-align: inherit;">however, we need to ensure that its orientation corresponds to the final turn. </font><font style="vertical-align: inherit;">To do this, after completing we equate its orientation to its rotation in Y.</font></font><br><br><pre> <code class="cs hljs"> transform.localPosition = location.Position; orientation = transform.localRotation.eulerAngles.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the troops are looking exactly in the direction of movement, both horizontally and vertically. </font><font style="vertical-align: inherit;">This means that they will be bending forward and backward, descending from the slopes and climbing them. </font><font style="vertical-align: inherit;">So that they always stand erect, forcibly null the component Y of the direction vector before using it to determine the rotation of the unit.</font></font><br><br><pre> <code class="cs hljs"> Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); ‚Ä¶ Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looking forward while driving</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We look at the point </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All along the way, the detachments are looking forward, but before the start of the movement they can look in a different direction. In this case, they instantly change their orientation. It will be better if they turn in the direction of the path before the start of the movement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looking in the right direction may be useful in other situations, so let's create a method </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that forces a detachment to change its orientation in order to look at a certain point. The required rotation can be set using the method </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, first making it so that the point is in the same vertical position as the squad. After that we can extract the orientation of the squad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for the squad to actually turn, we will turn the method into another coruntine, which will rotate it at a constant speed. The speed of rotation can also be adjustable, but we will use the constant again. Turn should be fast, about 180 ¬∞ per second.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed = <span class="hljs-number"><span class="hljs-number">180f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiddling with the acceleration of the turn is optional, because it is unnoticeable. It is enough for us to simply perform the interpolation between the two orientations. Unfortunately, this is not as easy to do as in the case of two numbers, because the angles are circular. For example, a transition from 350 ¬∞ to 10 ¬∞ should turn clockwise by 20 ¬∞, but a simple interpolation will force you to turn 340 ¬∞ counterclockwise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The easiest way to create the correct rotation is by performing an interpolation between two quaternions using spherical interpolation. This will lead to the shortest turn. To do this, we obtain the beginning and the end quaternions, and then we perform the transition between them using </font></font><code>Quaternion.Slerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { point.y = transform.localPosition.y; Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } transform.LookAt(point); orientation = transform.localRotation.eulerAngles.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This works, but interpolation always goes from 0 to 1, regardless of the angle of rotation. </font><font style="vertical-align: inherit;">To ensure a uniform angular velocity, we need to slow down the interpolation as the angle of rotation increases.</font></font><br><br><pre> <code class="cs hljs"> Quaternion fromRotation = transform.localRotation; Quaternion toRotation = Quaternion.LookRotation(point - transform.localPosition); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * speed; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * speed ) { transform.localRotation = Quaternion.Slerp(fromRotation, toRotation, t); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knowing the angle, we can completely skip the turn if it turns out to be zero. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Quaternion.Angle(fromRotation, toRotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (angle &gt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = rotationSpeed / angle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ‚Ä¶ ) { ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can add a detachment's turn in </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by simply performing a yield </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the position of the second cell </font><font style="vertical-align: inherit;">before moving </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unity will automatically launch a quorutine </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait for it to complete.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you check the code, the unit teleports to the destination cell, turns there, then teleports back to the beginning of the path and starts moving from there. </font><font style="vertical-align: inherit;">This happens because we assign a value to the property </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">before the start of the cortina </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To get rid of teleportation, we can </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">return the detachment's position to the initial cell at the beginning.</font></font><br><br><pre> <code class="cs hljs"> Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; transform.localPosition = c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn before moving</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cleaning up </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having received the movement we need, we can get rid of the method </font></font><code>OnDrawGizmos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Delete it or comment it out in case we need to see ways in the future.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void OnDrawGizmos () { // ‚Ä¶ // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we no longer need to memorize the path we took, at the end </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you can free up the list of cells.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ ListPool&lt;HexCell&gt;.Add(pathToTravel); pathToTravel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What about real squad animations?</font></font></b> <div class="spoiler_text">         ,   .    3D-       .      .        ,     .       Mecanim,     <code>TravelPath</code> . </div></div><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-19/animating-orientation/animating-orientation.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/426481/">https://habr.com/ru/post/426481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426471/index.html">How data flows from spyware applications</a></li>
<li><a href="../426473/index.html">Redux architecture. Yes or no?</a></li>
<li><a href="../426475/index.html">Miya - helper from the smartphone</a></li>
<li><a href="../426477/index.html">The whole truth about the RTOS. Article # 15. Memory sections: services and data structures</a></li>
<li><a href="../426479/index.html">Homemade test bench for motherboards</a></li>
<li><a href="../426483/index.html">The one who overtakes Tesla. For more profitable</a></li>
<li><a href="../426485/index.html">Third check of Qt 5 with PVS-Studio</a></li>
<li><a href="../426487/index.html">Test automation from scratch. Part 1</a></li>
<li><a href="../426489/index.html">On the relationship of prime and irrational numbers</a></li>
<li><a href="../426491/index.html">Security Week 39: on the death of Google+</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>