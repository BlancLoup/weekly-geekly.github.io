<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RabbitMQ vs. Kafka: Kafka application in event-oriented applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we looked at patterns and topologies used in RabbitMQ. In this section, we turn to Kafka and compare it with RabbitMQ to get ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: Kafka application in event-oriented applications</h1><div class="post__text post__text-html js-mediator-article"><p>  In the <a href="https://habr.com/company/itsumma/blog/416629/">previous article,</a> we looked at patterns and topologies used in RabbitMQ.  In this section, we turn to Kafka and compare it with RabbitMQ to get some insight into their differences.  It should be borne in mind that the architecture of event-oriented applications will be compared rather than the data processing pipelines, although the line between these two concepts will be rather blurred in this case.  In general, this is more of a spectrum than a clear separation.  Simply, our comparison will focus on the part of this spectrum associated with event-driven applications. </p><br><p><img src="https://habrastorage.org/webt/fu/xp/vw/fuxpvw1pzsm4miouvpbwo7qxq-m.png"></p><a name="habracut"></a><br><p>  The first difference that comes to mind is that the replay and snooze mechanisms used in RabbitMQ to work with undelivered messages in Kafka do not make sense.  In RabbitMQ messages are temporary, they are transmitted and disappear.  Therefore, their re-addition is absolutely real juz-case.  And in Kafka the magazine takes the central place.  Solving problems of delivery through re-sending a message to the queue does not make sense and only hurts the magazine.  One of the advantages lies in the guaranteed clear distribution of messages by the log partitions, repeated messages confuse a coherent scheme.  In RabbitMQ, you can send already sent messages to a queue with which one recipient works, and on the Kafka platform there is one journal for all recipients.  Delay in delivery and problems with the delivery of messages do not represent a great harm to the work of the magazine, but Kafka does not contain any built-in delay mechanisms. </p><br><p>  How to re-deliver messages on the Kafka platform will be discussed in the section on messaging schemes. </p><br><p>  The second big difference affecting possible messaging schemes is that messages are stored in RabbitMQ significantly less than in Kafka.  When a message has already been delivered to the recipient in RabbitMQ, it is deleted, leaving no trace of its existence.  In Kafka, every message is kept in a log until it is cleared.  The frequency of cleanings depends on the amount of data available, the amount of disk space that is planned for them to allocate, and the messaging schemes that need to be provided. You can use the time window in which we store messages for a specified period of time: the last few days / weeks / months. </p><br><p>  Thus, Kafka allows the recipient to review or re-receive the old messages again.  It looks like a technology of re-sending messages, although it does not work quite like in RabbitMQ. </p><br><p>  If RabbitMQ moves messages and gives powerful elements to create complex routing schemes, Kafka retains the current and previous state of the system.  This platform can be used as a source of reliable historical data because RabbitMQ cannot. </p><br><h3>  Sample messaging scheme on the Kafka platform <br></h3><br><p>  The simplest example of the use of both RabbitMQ and Kafka is the dissemination of information under the publisher-subscriber scheme.  One or several publishers add messages to a partinged log, and these messages are received by the subscriber of one or several groups of subscribers. </p><br><p><img src="https://habrastorage.org/webt/rx/lw/56/rxlw56hzrjigugjyiiu01avpxho.png"><br>  <em>Figure 1. Several publishers send messages to a partitioned log, and they are received by several groups of recipients.</em> </p><br><p>  If you don‚Äôt go into details about how the publisher sends messages to the right sections of the journal, and how the recipient groups are coordinated among themselves, this scheme does not differ from the fanout topology (branching exchange), which is used in RabbitMQ. <br>  In the previous article, all RabbitMQ messaging topologies and messaging topologies were reviewed.  Perhaps at some point you thought ‚ÄúI don‚Äôt need all these difficulties, I just want to send and receive messages in the queue,‚Äù and the fact that it was possible to rewind the magazine to previous positions spoke about the obvious advantages of Kafka. </p><br><p>  People who are accustomed to the traditional features of the queue systems, the fact that it is possible to turn the clock back and wind the event log into the past is shocking.  This property (made available by using the log instead of the queue) is very useful for recovering from failures.  I (the author of the English article) started working for my current client 4 years ago as a technical leader of the server system support group.  We had more than 50 applications that received information about business events in real time via MSMQ, and the usual thing was that when an error occurred in the application, the system only detected it the next day.  Unfortunately, the messages often disappeared as a result, but usually we managed to get the source data from a third-party system and send messages only to the ‚Äúsubscriber‚Äù who had a problem.  This required us to create a messaging infrastructure for recipients.  And if we had the Kafka platform, it would have been no more difficult to do this work than to change the link to the location of the last message received for the application in which the error occurred. </p><br><h3 id="integraciya-dannyh-v-sobytiyno-orientirovannyh-prilozheniyah-i-sistemah">  Data Integration in Event-Oriented Applications and Systems </h3><br><p>  This scheme is largely a means of generating events, although not related to one application.  There are two levels of event generation: software and system.  This scheme is associated with the latter. </p><br><h4 id="programmnyy-uroven-porozhdeniya-sobytiy">  Program level of event generation </h4><br><p>  The application manages its own state through an immutable sequence of change events that are stored in the event store.  In order to get the current state of the application, you must play or combine its events in the correct sequence.  Usually in such a model, <a href="https://martinfowler.com/bliki/CQRS.html">the CQRS</a> Kafka <a href="https://martinfowler.com/bliki/CQRS.html">model</a> can be used as this system. </p><br><h4 id="vzaimodeystvie-mezhdu-prilozheniyami-na-urovne-sistemy">  Interaction between applications at the system level. </h4><br><p>  Applications or services can manage their state in any way that their developer wishes to manage, for example, in a regular relational database. </p><br><p>  But applications often need data about each other, which leads to non-optimal architectures, for example, common databases, blurred entity boundaries or inconvenient REST APIs. </p><br><p>  I (the author of the English article) listened to the podcast ‚Äú <a href="https://softwareengineeringdaily.com/2016/10/14/kafka-event-sourcing-with-neha-narkhede/">Software Engineering Daily</a> ‚Äù, which describes an event-oriented script for a social media profile service.  There are a number of related services in the system, such as a search, a system of social graphs, a recommendation engine, etc., all of them need to know about the change in the status of a user profile.  When I (the author of the English articles) worked as an architect for the air transport system, we had two large software systems with a myriad of associated small services.  Auxiliary services required data on orders and flights.  Every time an order was created or changed, when a flight was delayed or canceled, these services had to be activated. </p><br><p>  Here the technique of generating events was required.  But first we will look at some common problems that arise in large software systems, and see how event generation can solve them. </p><br><p>  A large integrated corporate system usually develops organically;  there are migrations to new technologies and new architectures that may not affect 100% of the system.  Data is distributed across different parts of an institution, applications open databases for public use so that integration happens as quickly as possible, and no one can predict with certainty how all elements of the system will interact. </p><br><h4 id="neuporyadochennoe-rasprostranenie-dannyh">  Out of order data distribution </h4><br><p>  Data is distributed in different places and managed in different places, so it is difficult to understand: </p><br><ul><li>  how data moves in business processes; </li><li>  how changes in one part of the system may affect other parts; </li><li>  what to do with data conflicts, which arise from the fact that there are many copies of data that spread slowly. </li></ul><br><p>  If there are no clear boundaries of domain entities, the changes will be expensive and risky, since they affect many systems at once. </p><br><h4 id="centralizovannaya-raspredelennaya-baza-dannyh">  Centralized Distributed Database </h4><br><p>  An open database can cause several problems: </p><br><ul><li>  It is not optimized enough for each application separately. Most likely, this database stores an unnecessarily complete data set for the application, moreover, it is normalized in such a way that applications will have to run very complex queries to get them. </li><li>  Using a common database application can affect each other's work. </li><li>  Changes in the logical structure of the database require large-scale approvals and work on data migration, and the development of individual services will be stopped for the entire process. </li><li>  No one wants to change the storage structure.  The changes that everyone is waiting for are too painful. </li></ul><br><h4 id="ispolzovanie-neudobnogo-rest-api">  Using inconvenient REST API </h4><br><p>  Getting data from other systems through the REST API on the one hand adds convenience and isolation, but still may not always be successful.  Each such interface can have its own particular style and its own conventions.  Obtaining the necessary data may require a lot of HTTP requests and be quite complex. </p><br><p>  We are moving more and more towards API centricity, and such architectures offer many advantages, especially when the services themselves are beyond our control.  There are currently so many convenient ways to create an API that we should not write as much code as was required before.  But it‚Äôs still not the only available tool, and there are alternatives to the internal system architecture. </p><br><h4 id="kafka-kak-hranilische-sobytiy">  Kafka as an event store </h4><br><p>  Let's give an example.  There is a system that manages bookings in a relational database.  The system uses all the guarantees of atomicity, consistency, isolation and durability offered by the database in order to effectively manage its characteristics and everyone is satisfied.  The division of responsibility into teams and requests, the generation of events, microservices are absent, in general a traditionally constructed monolith.  But there are a myriad of support services (possibly microservices) associated with the booking: push notifications, e-mail sending, anti-fraud system, loyalty program, billing, reservation cancellation system, etc.  The list goes on and on.  All of these services require booking information, and there are many ways to get it.  These services themselves produce data that may be useful to other applications. </p><br><p><img src="https://habrastorage.org/webt/tk/e6/rc/tke6rcvglscapqo_nbx4yk228si.png"><br>  <em>Figure 2. Different types of data integration.</em> </p><br><p>  Alternative architecture based on Kafka.  With each new reservation or change of previous reservation, the system sends the full data on the current status of this reservation to Kafka.  By compacting the log, you can shorten the messages so that only information on the latest reservation status is left in it.  In this case, the size of the journal will be under control. </p><br><p><img src="https://habrastorage.org/webt/gq/bq/j2/gqbqj2zxxu_zk2sgd-qxrvd17pm.png"><br>  <em>Figure 3. Kafka-based data integration as the basis for event generation.</em> </p><br><p>  For all applications for which this information is necessary, this is the source of truth and the only source of data.  Suddenly, we are moving from a complex network of dependencies and technologies to sending and receiving data to / from Kafka topics. </p><br><p>  Kafka as an event store: </p><br><ul><li>  If there are no problems with disk space, Kafka can store the entire event history, that is, a new application can be deployed and download all the necessary information from the log.  Records of events that fully reflect the characteristics of objects can be compressed by condensing the journal, which will make this approach more justified for many scenarios. </li><li>  What if events need to be played in the correct order?  As long as the event records are properly distributed, you can set the order of their playback and apply filters, conversion tools, etc., so that the data will always end with the necessary information.  Depending on the possibility of data distribution, it is possible to ensure their highly parallel processing in the correct order. </li><li> It may be necessary to change the data model.  When creating a new filter / transforming function, it may be necessary to play back the recordings of all events or events in the last week. </li></ul><br><p>  Messages can come to Kafka not only from applications of your organization that send messages about all changes in their characteristics (or the results of these changes), but also from third-party services integrated with your system.  This happens in the following ways: </p><br><ul><li>  Periodic export, transfer, import of data received from third-party services, and their loading on Kafka. </li><li>  Download data from third-party services in Kafka. </li><li>  Data from CSV and other formats downloaded from third-party services are loaded into Kafka. </li></ul><br><p>  Let us return to the questions that we considered earlier.  Kafka-based architecture simplifies data distribution.  We know where the source of truth is, we know where its data sources are, and all target applications work with copies that are <strong>derived</strong> from this data.  The data goes from the sender to the recipients.  The source data belong only to the sender, but others are free to work with their projections.  They can filter them, transform them, supplement them with data from other sources, and store them in their own databases. </p><br><p><img src="https://habrastorage.org/webt/hw/i7/jw/hwi7jw2n5m5t2hkqb9kx2rqi49c.png"><br>  <em>Figure 4. Source and Output</em> </p><br><p>  Each application that requires booking data and flights will receive it itself, because it is ‚Äúsubscribed‚Äù to those sections of Kafka that contain this data.  For this, applications can use SQL, Cypher, JSON, or any other query language.  The application can then save the data in its system as it is convenient for it.  The data distribution scheme can be changed without affecting the operation of other applications. </p><br><p>  The question may arise: why all this can not be done with the help of RabbitMQ?  The answer is that RabbitMQ can be used to process events in real time, but not as a basis for generating events.  RabbitMQ is a complete solution only to respond to events that are happening now.  When a new application is added that requires its own portion of the reservation data presented in a format optimized for the tasks of this application, RabbitMQ will not be able to help.  With RabbitMQ, we return to shared databases or the REST API. </p><br><p>  Secondly, the order of event handling is important.  If you work with RabbitMQ, if you add a second recipient to the queue, the order of observance of the order is lost.  Thus, the correct order of sending messages is observed only for one recipient, but this, of course, is not enough. </p><br><p>  Kafka, by contrast, can provide all the data that this application requires in order to create its own copy of the data and keep the data up-to-date, and at the same time Kafka respects the order of sending messages. </p><br><p>  Now back to API-centric architectures.  Are these interfaces always the best choice?  When I want to share data read-only, I would prefer an event-generating architecture.  It will prevent cascading failures and a reduction in service life, coupled with an increase in the number of dependencies on other services.  There will be more opportunities for creative and efficient organization of data within systems.  But sometimes it is required to synchronously change the data in one's own, and in another system, and in such a situation API-centric systems will be useful.  Many prefer them to other asynchronous methods.  I think this is a matter of taste. </p><br><h3 id="prilozheniya-chuvstvitelnye-k-vysokomu-trafiku-i-poryadku-obrabotki-sobytiy">  Applications that are sensitive to high traffic and event processing. </h3><br><p>  Not so long ago, a problem arose with one of the recipients of RabbitMQ, who received the files queued up from a third-party service.  The total file size was large, and the application was specifically configured to receive this amount of data.  The problem was that the data were inconsistent, it created many problems. </p><br><p>  In addition, sometimes there was a problem that sometimes two files were meant for one addressee, and their arrival time was different for a few seconds.  Both of them were processed and had to be uploaded to one server.  And after the second message was recorded on the server, the first message following it overwritten the second one.  Thus, it all ended in the preservation of incorrect data.  RabbitMQ performed its role and sent messages in the correct order, but all the same, everything ended in the wrong order in the application itself. </p><br><p>  This problem was solved by reading the timestamp from the existing records and the lack of response in case the message was old.  In addition, during data exchange, consistent hashing was applied, and the queue was split, as with the same partitioning on the Kafka platform. </p><br><p>  As part of the partition, Kafka stores messages in the order in which they were sent to it.  The order of messages exists only within the limits of a partition.      Kafka        id ,    .      ,     ,   .         ,        .  Simple and effective. </p><br><p> Kafka    RabbitMQ   ,       .   RabbitMQ  ,         ,         . RabbitMQ    ,         . Kafka          .     ,          ,      . </p><br><h3 id="lokalnost-dannyh">   </h3><br><p>         Kafka   . ,     id 1001     3.    1001    3,  3     ,     ,              .    ,    ..      .  ‚Äî       -     . </p><br><p>   Kafka   ?    ,  Kafka        .  ,       :   10,    9 . ,   ,    .      1,    , ,      .     Kafka      ,           . </p><br><p>              ,          .     ,             .         ,       .   1001      4 (     1001    ). </p><br><p>            .       ,       . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418389/">https://habr.com/ru/post/418389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418379/index.html">Children's bioelectric prosthesis. Part 2</a></li>
<li><a href="../418381/index.html">What's new in DevTools in Chrome version 68</a></li>
<li><a href="../418383/index.html">Animations in Android based on Kotlin and RxJava</a></li>
<li><a href="../418385/index.html">How I assembled a computer for old games</a></li>
<li><a href="../418387/index.html">The dialogue of physicists about the soul</a></li>
<li><a href="../418391/index.html">OSPF (Part One)</a></li>
<li><a href="../418393/index.html">[Friday] How we sawed the 3d web</a></li>
<li><a href="../418395/index.html">Ilon Musk: local electromagnetic field generators will protect colonists on Mars</a></li>
<li><a href="../418397/index.html">Friday Management: Free Skillbox Webinars</a></li>
<li><a href="../418399/index.html">On the wave of Selectel FM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>