<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You do not know Node: a brief overview of the main features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remark from the author 
 This article is new, but it is not about new features. It is about the core, that is, about the platform and the fact that ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You do not know Node: a brief overview of the main features</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/72e/f98/f40/72ef98f40469475fa1e76bcad042cdd3.jpg"><br><br><blockquote>  <b>Remark from the author</b> <br>  This article is new, but it is not about new features.  It is about the core, that is, about the platform and the fact that many who simply use grunt, or the webpack may be unaware, so skazat about the fundamentals. <br><br>  Read more: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habrahabr.ru/users/rumkin/" class="user_link">rumkin</a> comments: <br>  <a href="https://habrahabr.ru/company/mailru/blog/283228/">habrahabr.ru/company/mailru/blog/283228/#comment_8890604</a> <br><br>  <a href="https://habrahabr.ru/users/aiditz/" class="user_link">Aiditz</a> comments: <br>  <a href="https://habrahabr.ru/company/mailru/blog/283228/">habrahabr.ru/company/mailru/blog/283228/#comment_8890476</a> <br><br>  <a href="https://habrahabr.ru/users/suvitruf/" class="user_link">Suvitruf</a> comments: <br>  <a href="https://habrahabr.ru/company/mailru/blog/283228/">habrahabr.ru/company/mailru/blog/283228/#comment_8890430</a> <br></blockquote><br><br>  The idea of ‚Äã‚Äãthis publication was inspired by the series of Kyle Simpson's books ‚Äú <a href="https://github.com/getify/You-Dont-Know-JS">You don't know JavaScript</a> ‚Äù.  They are a good start to learn the basics of this language.  And Node is almost the same JavaScript, except for small differences, which I will discuss in this article.  All the code below can be downloaded from the <a href="https://github.com/azat-co/you-dont-know-node">repository</a> , from the <code>code</code> folder. <br><br>  Why bother about Node at all?  Node is JavaScript, and JavaScript is used almost everywhere!  The world would be better off if most developers were perfectly fluent in Node.  The better the application, the better the life! <br><br>  This article is a realistic look at the most interesting main features of Node.  Key points of the article: <br><br><ol><li>  <b>Event loop:</b> refresh key concept that allows non-blocking I / O operations. </li><li>  <b>Global object and process:</b> how to get more information. </li><li>  <b>Event emitters: an</b> intensive introduction to the event-based model (event-based pattern) </li><li>  <b>Streaming and buffers: an</b> efficient way to work with data </li><li>  <b>Clusters:</b> Forky processes like a professional </li><li>  <b>Handling asynchronous errors:</b> AsyncWrap, Domain and uncaughtException </li><li>  <b>Addons in C ++:</b> adding your own developments to the kernel and writing your own addons in C ++ </li></ol><a name="habracut"></a><br><h1>  Event cycle </h1><br>  Let's start with the cycle of events that underlies the Node. <br><br><img src="https://habrastorage.org/files/c6e/57f/13e/c6e57f13e52647398ebd7c67520f60ab.png"><br>  <sup><i>Non-blocking I / O operations in Node.js</i></sup> <br><br>  The cycle allows us to work with other tasks in parallel with performing I / O operations.  Compare Nginx and Apache.  Thanks to the event loop, Node works very quickly and efficiently, since blocking I / O operations are expensive! <br><br>  Take a look at this simple example of the Java <code>println</code> deferred function: <br><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"Step: 1"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Step: 2"</span></span>); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Step: 3"</span></span>);</code> </pre><br>  This is comparable (though not quite) with the Node code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 1'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 3'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 2'</span></span>)</code> </pre><br>  This is not the same.  Start thinking in terms of asynchronous work.  Output Node-script - 1, 2, 3;  but if after ‚ÄúStep 2‚Äù we had more expressions, they would first be executed, and only then callback functions <code>setTimeout</code> .  Take a look at this snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 1'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 3'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step 5'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 2'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step 4'</span></span>)</code> </pre><br>  The result of his work will be a sequence of 1, 2, 4, 3, 5. The reason is that <code>setTimeout</code> places its callback in future periods of the event cycle. <br><br>  You can perceive the cycle of events as an infinite loop like <code>for ‚Ä¶ while</code> .  It stops only when there is nothing more to do, either now or in the future. <br><br><img src="https://habrastorage.org/files/c9b/15c/e68/c9b15ce681444eb5b6a00ac34461ed29.png"><br>  <i>Blocking I / O: Multi-threaded Java</i> <br><br>  The event loop allows the system to work more efficiently, the application can do something else while waiting for the completion of expensive I / O operations. <br><br><img src="https://habrastorage.org/files/18e/ff9/7e2/18eff97e2b2c432d8e69042ad211ea4d.png"><br>  <i>Non-blocking I / O operations in Node.js</i> <br><br>  This contrasts with the more common model of parallel processing (concurrency model), which involves the threads of the operating system.  The network flow model (thread-based networking) is rather inefficient and very difficult to use.  Moreover, Node users may not be afraid of complete blocking of processes - there are no lockes here. <br><br>  By the way, you can still write blocking code in Node.js.  Look at this simple snippet: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Step: 1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">1000000000</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">// This will take 100-1000ms depending on your machine } var end = Date.now() console.log('Step: 2') console.log(end-start)</span></span></code> </pre><br>  Of course, there are usually no empty loops in our code.  When using foreign modules, it may be more difficult to detect synchronous, and therefore blocking code.  For example, the main <code>fs</code> module (file system) comes with two sets of methods.  Each pair does the same thing, but in different ways.  The blocking methods in the <code>fs</code> module have the word <code>Sync</code> in their names: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contents = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'accounts.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(contents) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello Ruby\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contents = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'ips.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(contents) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello Node!'</span></span>)</code> </pre><br>  The result of executing this code is completely predictable, even for beginners in Node / JavaScript: <br><br><pre> <code class="javascript hljs">data1-&gt;Hello Ruby-&gt;data2-&gt;Hello NODE!</code> </pre><br>  But everything changes when we switch to asynchronous methods.  Here is an example of non-blocking code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contents = fs.readFile(<span class="hljs-string"><span class="hljs-string">'accounts.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err,contents</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(contents); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello Python\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contents = fs.readFile(<span class="hljs-string"><span class="hljs-string">'ips.txt'</span></span>,<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err,contents</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(contents); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hello Node!"</span></span>);</code> </pre><br>  <code>contents</code> are displayed last, because their execution takes some time, they are also in callbacks.  The event loop will go to them upon completion of reading the file: <br><br><pre> <code class="javascript hljs">Hello Python-&gt;Hello Node-&gt;data1-&gt;data2</code> </pre><br>  In general, the event loop and non-blocking I / O operations are very powerful things, but you have to write asynchronous code, which many people are not used to. <br><br><h1>  Global object </h1><br>  When developers switch from browser-based JavaScript or another language to Node.js, they have the following questions: <br><br><ul><li>  Where to store passwords? </li><li>  How to create global variables (in Node there is no <code>window</code> )? </li><li>  How to access CLI, OS, platform, memory, version, etc. input? </li></ul><br>  For this, there is a global object that has certain properties.  Here are some of them: <br><br><ul><li>  <code>global.process</code> : process, system, environment information (you can access CLI input data, environment variables with passwords, memory, etc.) </li><li>  <code>global.__filename</code> : the file name and the path to the currently running script that contains this expression. </li><li>  <code>global.__dirname</code> : the full path to the currently running script. </li><li>  <code>global.module</code> : an object for exporting code that creates a module from this file. </li><li>  <code>global.require()</code> : method for importing modules, JSON files and folders. </li></ul><br>  There are also common suspects - methods from browser JavaScript: <br><br><ul><li> <code>global.console()</code> </li> <li> <code>global.setInterval()</code> </li> <li> <code>global.setTimeout()</code> </li> </ul><br>  Each of the global properties can be accessed using the <code>GLOBAL</code> name typed in capital letters, or without a name at all, simply by writing <code>process</code> instead of <code>global.process</code> . <br><br><h4>  Process </h4><br>  The process object deserves a separate chapter, because it contains a lot of information.  Here are some of its properties: <br><br><ul><li>  <code>process.pid</code> : The process ID of this Node instance. </li><li>  <code>process.versions</code> : different versions of Node, V8 and other components </li><li>  <code>process.arch</code> : system architecture </li><li>  <code>process.argv</code> : CLI arguments </li><li>  <code>process.env</code> : environment variables </li></ul><br>  Some methods: <br><br><ul><li>  <code>process.uptime()</code> : get running time </li><li>  <code>process.memoryUsage()</code> : gets the amount of memory consumed </li><li>  <code>process.cwd()</code> : get the current working folder.  Not to be confused <code> __dirname</code> , independent of the place from which the process was launched. </li><li>  <code>process.exit()</code> : exits the current process.  For example, you can pass the code 0 or 1. </li><li>  <code>process.on()</code> : attaches to the event, for example,  ªon ('uncaughtException') </li></ul><br>  The hard question is: who likes and who understands the essence of callbacks? <br><br>  Someone is so "in love" with them that he created <a href="http://callbackhell.com/">http://callbackhell.com</a> .  If this term is not familiar to you, here is an illustration: <br><br><pre> <code class="javascript hljs">fs.readdir(source, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, files</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error finding files: '</span></span> + err) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { files.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename, fileIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filename) gm(source + filename).size(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error identifying file size: '</span></span> + err) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filename + <span class="hljs-string"><span class="hljs-string">' : '</span></span> + values) aspect = (values.width / values.height) widths.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, widthIndex</span></span></span><span class="hljs-function">) </span></span>{ height = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(width / aspect) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'resizing '</span></span> + filename + <span class="hljs-string"><span class="hljs-string">'to '</span></span> + height + <span class="hljs-string"><span class="hljs-string">'x'</span></span> + height) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.resize(width, height).write(dest + <span class="hljs-string"><span class="hljs-string">'w'</span></span> + width + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + filename, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error writing file: '</span></span> + err) }) }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } }) }) } })</code> </pre><br>  The ‚Äúhell of callbacks‚Äù is difficult to read, and mistakes can easily be made here.  So how do we divide into modules and organize asynchronous code, if not using callbacks that are not very convenient for scaling from a development point of view. <br><br><h1>  Event emitters </h1><br>  To deal with the hell of callbacks, or the pyramid of doom, <a href="https://nodejs.org/api/events.html">event emitters</a> are used.  With their help, you can implement asynchronous code using events. <br><br>  In short, an event emitter is a trigger for an event that anyone can listen to.  In Node.js, each event is assigned a string name, to which the callback can be hung by the emitter. <br><br>  What are emitters for: <br><br><ul><li>  In the Node, events are processed using the ‚Äúobserver‚Äù pattern. </li><li>  An event (or a subject) keeps track of all related functions. </li><li>  These functions ‚Äî observers ‚Äî are executed when the event is activated. </li></ul><br>  To use emitters, you need to import the module and create an instance of the object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> emitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> events.EventEmitter()</code> </pre><br>  Then you can attach event recipients and activate / send events: <br><br><pre> <code class="javascript hljs">emitter.on(<span class="hljs-string"><span class="hljs-string">'knock'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Who\'s there?'</span></span>) }) emitter.on(<span class="hljs-string"><span class="hljs-string">'knock'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Go away!'</span></span>) }) emitter.emit(<span class="hljs-string"><span class="hljs-string">'knock'</span></span>)</code> </pre><br>  Let's use the <code>EventEmitter</code> do something useful, inheriting it from it.  Suppose you regularly need to implement a class - monthly, weekly, or every day.  This class must be flexible enough for other developers to customize the final result.  In other words, at the end of your work, everyone should be able to put some kind of logic into the class. <br><br>  This diagram shows how we use <code>Job</code> inherit from the event module, and then use the <code>done</code> event receiver to change the behavior of the <code>Job</code> class: <br><br><img src="https://habrastorage.org/files/d4f/fbe/09f/d4ffbe09f0f04e279b5f41351d1225b0.png"><br>  <i>Event emitters in Node.js: ‚Äúobserver‚Äù pattern</i> <br><br>  The <code>Job</code> class will retain its properties, but at the same time will receive events.  At the end of the process, we just need to run the <code>done</code> event: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// job.js var util = require('util') var Job = function Job() { var job = this // ... job.process = function() { // ... job.emit('done', { completedOn: new Date() }) } } util.inherits(Job, require('events').EventEmitter) module.exports = Job</span></span></code> </pre><br>  Finally, change the <code>Job</code> behavior.  Once it sends <code>done</code> , then we can attach the event receiver: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// weekly.js var Job = require('./job.js') var job = new Job() job.on('done', function(details){ console.log('Job was completed at', details.completedOn) job.removeAllListeners() }) job.process()</span></span></code> </pre><br>  Emitters have other options: <br><br><ul><li>  <code>emitter.listeners(eventName)</code> : lists all recipients for this event. </li><li>  <code>emitter.once(eventName, listener)</code> : attaches a one-time event listener. </li><li>  <code>emitter.removeListener(eventName, listener)</code> : deletes the event receiver. </li></ul><br>  Node uses an event pattern everywhere, especially in the core modules.  So if you use events wisely, you will save a lot of time. <br><br><h1>  Streams </h1><br>  There are several problems with working with large amounts of data in Node.  Performance may be low, and the buffer size is limited to about 1 GB.  In addition, how to work in conditions of an infinite resource, which was created on the basis that it will never end?  In these situations, we will help stream'y. <br><br>  Stream'y in Node are an abstraction, denoting the continuous splitting of data into fragments.  In other words, you do not need to wait for the resource to be fully loaded.  The diagram shows the standard approach to buffering: <br><br><img src="https://habrastorage.org/files/3fa/ebd/d76/3faebdd7656b480586a8713a34940591.png"><br>  <i>Node.js buffering approach</i> <br><br>  Before we start processing the data and / or output them, we have to wait for the buffer to load completely.  Now compare this with the work flow scheme.  In this case, we can immediately start processing the data and / or output it as soon as we receive the first chunk: <br><br><img src="https://habrastorage.org/files/aae/8e5/c7d/aae8e5c7d11a45a58274b3b7f107b6a4.png"><br>  <i>Stream approach in Node.js</i> <br><br>  There are four types of streams in Node: <br><br><ul><li>  Readable: you can read from them. </li><li>  Writable (writable): they can be written. </li><li>  Duplex (duplex): you can both write and read. </li><li>  Transform streams: You can use them to transform data. </li></ul><br>  Virtually streams are used everywhere in Node.  Most popular implementations of streams: <br><br><ul><li>  HTTP requests and responses. </li><li>  Standard I / O operations. </li><li>  Reading from files and writing to them. </li></ul><br>  To provide the ‚Äúobserver‚Äù pattern, streams ‚Äî events ‚Äî inherit from the ‚Äúemitter of events‚Äù object.  We can use this to implement streams. <br><br><h1>  An example of readable stream </h1><br>  An example is <code>process.stdin</code> , which is the standard input stream.  It contains data that goes into the application.  This is usually keyboard information used to start the process. <br><br>  The <code>data</code> and <code>end</code> events are used to read data from <code>stdin</code> .  The callback of the <code>data</code> event will have a <code>chunk</code> as an argument: <br><br><pre> <code class="javascript hljs">process.stdin.resume() process.stdin.setEncoding(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) process.stdin.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chunk</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'chunk: '</span></span>, chunk) }) process.stdin.on(<span class="hljs-string"><span class="hljs-string">'end'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'--- END ---'</span></span>) })</code> </pre><br>  Next, the <code>chunk</code> fed to the program as input.  This event can be activated several times, depending on the total amount of incoming information.  The completion of stream must be signaled using the <code>end</code> event. <br><br>  Note: <code>stdin</code> is paused by default, from which it must be output before reading data from it. <br><br>  Readable streams have a synchronous <code>read()</code> interface.  When the stream ends, it returns <code>chunk</code> or <code>null</code> .  We can take advantage of this behavior by putting the construction <code>null !== (chunk = readable.read())</code> in a <code>while</code> condition <code>null !== (chunk = readable.read())</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> readable = getReadableStreamSomehow() readable.on(<span class="hljs-string"><span class="hljs-string">'readable'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chunk <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> !== (chunk = readable.read())) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'got %d bytes of data'</span></span>, chunk.length) } })</code> </pre><br>  Ideally, we would like to write asynchronous code in Node as often as possible in order to avoid blocking thread.  But due to the small size of the chunks, you can not worry about the fact that synchronous <code>readable.read()</code> blocks thread. <br><br><h1>  An example of a recorded stream </h1><br>  An example is <code>process.stdout</code> , which is the standard output stream.  It contains data that leaves the application.  You can write to stream using the <code>write</code> operation. <br><br><pre> <code class="javascript hljs">process.stdout.write(<span class="hljs-string"><span class="hljs-string">'A simple message\n'</span></span>)</code> </pre><br>  The data written to the standard stream is displayed on the command line as if we used <code>console.log()</code> . <br><br><h3>  Pipe </h3><br>  In Node, there is an alternative to the events described above - the <code>pipe()</code> method.  The following example reads data from a file, compresses with GZip and writes the result to a file: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = fs.createReadStream(<span class="hljs-string"><span class="hljs-string">'file.txt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = zlib.createGzip() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w = fs.createWriteStream(<span class="hljs-string"><span class="hljs-string">'file.txt.gz'</span></span>) r.pipe(z).pipe(w)</code> </pre><br>  <code>Readable.pipe()</code> takes the data stream and passes through all the streams, so we can create chains from the <code>pipe()</code> methods. <br><br>  So when using streams, you can use events or pipe. <br><br><h3>  HTTP streaming </h3><br>  Most of us use Node to create web applications: traditional (server) or based on REST API (client).  What about HTTP requests?  Can you stream them?  Definitely! <br><br>  Requests and responses are readable and writable streams inherited from event emitters.  You can attach the recipient of the <code>data</code> event and take a <code>chunk</code> in its callback, which you can immediately convert without waiting for the entire response.  In the following example, we concatenate the <code>body</code> and parse it in the <code>end</code> callback event: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> server = http.createServer( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = <span class="hljs-string"><span class="hljs-string">''</span></span> req.setEncoding(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) req.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (chunk) =&gt; { body += chunk }) req.on(<span class="hljs-string"><span class="hljs-string">'end'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(body) res.write(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> data) res.end() }) }) server.listen(<span class="hljs-number"><span class="hljs-number">1337</span></span>)</code> </pre><br>  Note: according to ES6, <code>()=&gt;{}</code> is a new syntax for anonymous functions, and <code>const</code> is a new operator.  If you are not familiar with the features and syntax of ES6 / ES2015, then you can read the article <i><a href="http://webapplog.com/es6">Top 10 ES6 properties that every busy JavaScript developer should know about</a></i> . <br><br>  Let's use Express.js now to make our server less detached from real life.  Take a huge image (about 8 MB) and two sets of Express routes <code>/stream</code> and <code>/non-stream</code> . <br><br>  server-stream.js: <br><br><pre> <code class="javascript hljs">app.get(<span class="hljs-string"><span class="hljs-string">'/non-stream'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> file = fs.readFile(largeImagePath, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ res.end(data) }) }) app.get(<span class="hljs-string"><span class="hljs-string">'/stream'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = fs.createReadStream(largeImagePath) stream.pipe(res) })</code> </pre><br>  I also have an alternative implementation of <code>/stream2</code> with events, and a synchronous implementation of <code>/non-stream2</code> .  They do the same thing, but they use a different syntax and style.  In this case, synchronous methods work faster because we send only one request, and not several competing ones. <br><br>  You can run this code through the terminal: <br><br><pre> <code class="bash hljs">$ node server-stream</code> </pre><br>  Now open in Chrome <a href="http://localhost:3000/stream">http: // localhost: 3000 / stream</a> and <a href="http://localhost:3000/non-stream">http: // localhost: 3000 / non-stream</a> .  Notice the headers on the Network tab in the developer tools by comparing <code>X-Response-Time</code> .  In my case, <code>/stream</code> and <code>/stream2</code> differed by orders of magnitude: 300 ms.  and 3-5 seconds.  You may have other values, but the idea is clear: in the case of <code>/stream</code> users / clients will start receiving data earlier.  Streaming in Node is a very powerful tool!  You can learn how to manage your streaming resources well by becoming an expert in this field on your team. <br><br>  With npm, you can set your own <a href="https://github.com/substack/stream-handbook">Stream Handbook</a> and <a href="https://github.com/substack/stream-adventure">stream-adventure</a> : <br><br><pre> <code class="bash hljs">$ sudo npm install -g stream-adventure $ stream-adventure</code> </pre><br><h3>  Buffers </h3><br>  What types can we use for binary data?  If you remember, there is no binary data type in JavaScript browser, but there is in Node.  This is called a buffer.  It is a global object, so there is no need to import it as a module. <br><br>  You can use one of these expressions to create a binary type: <br><br><ul><li> <code>new Buffer(size)</code> </li> <li> <code>new Buffer(array)</code> </li> <li> <code>new Buffer(buffer)</code> </li> <li> <code>new Buffer(str[, encoding])</code> </li> </ul><br>  A full list of methods and encodings is available in the <a href="http://bit.ly/1IeAcZ1">buffer documentation</a> .  The most common encoding used is <code>utf8</code> . <br><br>  Usually, the contents of the buffer look like an abracadabra, therefore, in order to be readable by a person, you must first convert it to a string representation with <code>toString()</code> .  Create a buffer with the alphabet using the <code>for</code> loop: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(<span class="hljs-number"><span class="hljs-number">26</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; <span class="hljs-number"><span class="hljs-number">26</span></span> ; i++) { buf[i] = i + <span class="hljs-number"><span class="hljs-number">97</span></span> <span class="hljs-comment"><span class="hljs-comment">// 97 is ASCII a }</span></span></code> </pre><br>  If you do not convert the buffer to a string representation, it will look like an array of numbers: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(buf) <span class="hljs-comment"><span class="hljs-comment">// &lt;Buffer 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a&gt;</span></span></code> </pre><br>  Carry out the conversion: <br><br><pre> <code class="javascript hljs">buf.toString(<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// outputs: abcdefghijklmnopqrstuvwxyz buf.toString('ascii') // outputs: abcdefghijklmnopqrstuvwxyz</span></span></code> </pre><br>  If we need only a part of the string (sub string), then the method takes the initial number and the final position of the desired segment: <br><br><pre> <code class="javascript hljs">buf.toString(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">// outputs: abcde buf.toString('utf8', 0, 5) // outputs: abcde buf.toString(undefined, 0, 5) // encoding defaults to 'utf8', outputs abcde</span></span></code> </pre><br>  Remember <code>fs</code> ?  The default value of <code>data</code> also a buffer: <br><br><pre> <code class="javascript hljs">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/etc/passwd'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) });</code> </pre><br>  <code>data</code> acts as a buffer when working with files. <br><br><h1>  Clusters </h1><br>  Opponents of Node often give the argument that it can scale because it has only one thread.  However, using the main <code>cluster</code> module (you do not need to install it, it is part of the platform) we can use all the processor resources on any machine.  In other words, thanks to clusters, we can vertically scale Node applications. <br><br>  The code is very simple: we import a module, create one master and several workers (worker).  Usually one process is created for each CPU, but this is not an unshakable rule.  You can make as many processes as you want, but from a certain point the productivity gains stop, according to the law of decreasing returns. <br><br>  The master and worker code is in the same file.  The worker can listen to the same port by sending messages to the master through events.  The master can listen to events and, if necessary, restart the clusters.  For the wizard, <code>cluster.isMaster()</code> , for the employee - <code>cluster.isWorker()</code> .  Most of the server code will be located in the worker ( <code>isWorker()</code> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// cluster.js var cluster = require('cluster') if (cluster.isMaster) { for (var i = 0; i &lt; numCPUs; i++) { cluster.fork() } } else if (cluster.isWorker) { //    })</span></span></code> </pre><br>  In this example, my server issues process IDs, so you can observe how different workers process different requests.  It looks like a load balancer, but this is only an impression, because the load will not be evenly distributed.  For example, by the PID, you will see how one of the processes can handle much more requests. <br><br>  ,      ,     <code>loadtest</code>   Node: <br><br><ol><li>  <code>loadtest</code>   <code>npm: $ npm install -g loadtest</code> </li><li>  <code>code/cluster.js</code>   node ( <code>$ node cluster.js</code> );    . </li><li>      : <code>$ loadtest http://localhost:3000 -t 20 -c 10</code> . </li><li>         <code>loadtest</code> . </li><li>        Ctrl+C.    PID. </li></ol><br>   <code>loadtest</code>  <code>-t 20 -c 10</code> ,    10        20 . <br><br>  ‚Äî   ,      .       ,        .    : <br><br><ul><li> <code>strong-cluster-control</code> (https://github.com/strongloop/strong-cluster-control)  <code>$ slc run</code> </li><li> <code>pm2</code> (https://github.com/Unitech/pm2) </li></ul><br><h3> pm2 </h3><br>    <code>pm2</code> ,          Node-.  , <code>pm2</code>     production. <br><br>  <code>pm2</code> : <br><br><ul><li>       . </li><li>    ,     . </li><li>   . </li></ul><br>     <a href="https://github.com/Unitech/pm2">https://github.com/Unitech/pm2</a>  <a href="http://pm2.keymetrics.io/">http://pm2.keymetrics.io</a> . <br><br>     pm2   - <code>server.js</code> . ,      <code>isMaster()</code> ,        ,        <code>cluster</code> .     <code>pid</code>     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> port = <span class="hljs-number"><span class="hljs-number">3000</span></span> global.stats = {} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'worker (%s) is now listening to http://localhost:%s'</span></span>, process.pid, port) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = express() app.get(<span class="hljs-string"><span class="hljs-string">'*'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!global.stats[process.pid]) global.stats[process.pid] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> global.stats[process.pid] += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l =<span class="hljs-string"><span class="hljs-string">'cluser '</span></span> + process.pid + <span class="hljs-string"><span class="hljs-string">' responded \n'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(l, global.stats) res.status(<span class="hljs-number"><span class="hljs-number">200</span></span>).send(l) }) app.listen(port)</code> </pre><br>      <code>pm2 start server.js</code> .   /,    ( <code>-i 0</code> ,      ,  ,     4).        <code>-l log.txt</code> : <br><br><pre> <code class="bash hljs">$ pm2 start server.js -i 0 -l ./log.txt</code> </pre><br>  ,  pm2    .        : <br><br><pre> <code class="bash hljs">$ pm2 list</code> </pre><br>   <code>loadtest</code> ,        <code>cluster</code> .    : <br><br><pre> <code class="bash hljs">$ loadtest http://localhost:3000 -t 20 -c 10</code> </pre><br><br>      ,     <code>log.txt</code>   - : <br><br><pre> <code class="bash hljs">cluser 67415 responded { <span class="hljs-string"><span class="hljs-string">'67415'</span></span>: 4078 } cluser 67430 responded { <span class="hljs-string"><span class="hljs-string">'67430'</span></span>: 4155 } cluser 67404 responded { <span class="hljs-string"><span class="hljs-string">'67404'</span></span>: 4075 } cluser 67403 responded { <span class="hljs-string"><span class="hljs-string">'67403'</span></span>: 4054 }</code> </pre><br><h3>  Spawn, Fork  Exec </h3><br>   <code>cluter.js</code>     Node-   <code>fork()</code> .   ,      Node.js   : <code>spawn()</code> , <code>fork()</code>  <code>exec()</code> .        <code>child_process</code> .        : <br><br><ul><li> <code>require('child_process').spawn()</code> :     ;  stream';     ;     V8. </li><li> <code>require('child_process').fork()</code> :    V8   ;     Node.js ( <code>node</code> ). </li><li> <code>require('child_process').exec()</code> :     ,    ;  ,       callback';     ,   <code>node</code> . </li></ul><br>    :   <code>node program.js</code> ,          ‚Äî bash, Python, Ruby  ..      ,       ,    <code>spawn()</code> .      <code>data</code>   stream': <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> process = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = process.spawn(<span class="hljs-string"><span class="hljs-string">'node'</span></span>, <span class="hljs-string"><span class="hljs-string">'program.js'</span></span>) p.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'stdout: '</span></span> + data) })</code> </pre><br>     <code>node program.js</code> , <code>data</code>    , ,  . <br><br>  <code>fork()</code>     <code>spawn()</code> ,   :    ,   <code>fork()</code> ,      Node.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> process = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = process.fork(<span class="hljs-string"><span class="hljs-string">'program.js'</span></span>) p.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'stdout: '</span></span> + data) })</code> </pre><br> , <code>exec()</code> .      ,     ,   callback.    error, standard output    : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> process = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'child_process'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = process.exec(<span class="hljs-string"><span class="hljs-string">'node program.js'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, stdout, stderr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error.code) })</code> </pre><br>   <code>error</code>  <code>stderr</code>   ,      <code>exec()</code> (, <code>program.js</code>   ),   ‚Äî       (, <code>program.js</code>      ). <br><br><h1>    </h1><br>     Node.js        <code>try/catch</code> .       . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Fail!'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Custom Error: '</span></span> + e.message) }</code> </pre><br>     ,     .   Java  <i></i> Node.   Node.js    <i></i> ,    thread. <br><br>           ,      ,     /.         ,     . <br><br>  , <code>setTimeout()</code>  ,     callback'.      ,  HTTP-,       : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Fail!'</span></span>) }, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()*<span class="hljs-number"><span class="hljs-number">100</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Custom Error: '</span></span> + e.message) }</code> </pre><br>   callback   ,     <code>try/catch</code> . ,    callback   <code>try/catch</code> ,   ,    .         .    <code>try/catch</code>   . <br><br> ,  .     ?   ,    callback'   <code>error</code> .         :   callback'      . <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback(error) <span class="hljs-comment"><span class="hljs-comment">// or if (error) return console.error(error)</span></span></code> </pre><br>         : <br><br><ul><li>      (on error). </li><li>  <code>uncaughtException</code> . </li><li>  <code>domain</code> ( )  <a href="http://blog.trevnorris.com/2015/02/asyncwrap-tutorial-introduction.html">AsyncWrap</a> . </li><li>   . </li><li>  ( ). </li><li>    . </li></ul><br><h3> on('error') </h3><br>   <code>on('error')</code> ,      Node.js,   <code>http</code> .  <code>error</code>  ,      Express.js, LoopBack, Sails, Hapi  ..,      <code>http</code> . <br><br><pre> <code class="javascript hljs">js server.on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) process.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) })</code> </pre><br><h3> uncaughtException </h3><br>   <code>uncaughtException</code>   <code>process</code> ! <code>uncaughtException</code> ‚Äî      .    ,    ‚Äî    Node.js ‚Äî    . <br><br> An unhandled exception means your application ‚Äì and by extension Node.js itself ‚Äì is in an undefined state.    ,     . <br><br><pre> <code class="javascript hljs">process.on(<span class="hljs-string"><span class="hljs-string">'uncaughtException'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'uncaughtException: '</span></span>, err.message) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err.stack) process.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) })</code> </pre><br>  or <br><br><pre> <code class="javascript hljs">process.addListener(<span class="hljs-string"><span class="hljs-string">'uncaughtException'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'uncaughtException: '</span></span>, err.message) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err.stack) process.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><h3> Domain </h3><br>  <code>domain</code>        .    Node.js    .   ,     .  :   <code>domain</code>       callback' <code>run()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> domain = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'domain'</span></span>).create() domain.on(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error) }) domain.run(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Failed!'</span></span>) })</code> </pre><br>    4.0 <code>domain</code>  ,   Node     .       Node   <code>domain</code> .  ,      , <code>domain</code>      npm-,          npm.    <code>domain</code>   . <br><br>         <code>setTimeout()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// domain-async.js: var d = require('domain').create() d.on('error', function(e) { console.log('Custom Error: ' + e) }) d.run(function() { setTimeout(function () { throw new Error('Failed!') }, Math.round(Math.random()*100)) });</span></span></code> </pre><br>   !   <code>domain</code>   <code>error</code>     ‚ÄúCustom Error‚Äù,     Node  . <br><br><h1>   C++ </h1><br>  Node   , IoT, ,       ,          /++.      /++ ? <br><br>        .    Node     ,        ++!   ,        . <br><br>    <code>hello.cc</code> ,       .   ,     . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;node.h&gt; namespace demo { using v8::FunctionCallbackInfo; using v8::HandleScope; using v8::Isolate; using v8::Local; using v8::Object; using v8::String; using v8::Value; void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) { Isolate* isolate = args.GetIsolate(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, "capital one")); // String } void init(Local&lt;Object&gt; exports) { NODE_SET_METHOD(exports, "hello", Method); // Exporting } NODE_MODULE(addon, init) }</span></span></span></span></code> </pre><br>      ,     ,   ,        JavaScript.   <code>capital one</code> : <br><br><pre> <code class="cpp hljs">args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="hljs-string"><span class="hljs-string">"capital one"</span></span>));</code> </pre><br>       <code>hello</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Local&lt;Object&gt; exports)</span></span></span><span class="hljs-function"> </span></span>{ NODE_SET_METHOD(exports, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>, Method); }</code> </pre><br>  <code>hello.cc</code> ,  .  <code>binding.gyp</code> ,         : <br><br><pre> <code class="cpp hljs">{ <span class="hljs-string"><span class="hljs-string">"targets"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"target_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"addon"</span></span>, <span class="hljs-string"><span class="hljs-string">"sources"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"hello.cc"</span></span> ] } ] }</code> </pre><br>  <code>binding.gyp</code>     <code>hello.cc</code> ,    <a href="https://github.com/nodejs/node-gyp">node-gyp</a> : <br><br><pre> <code class="bash hljs">$ npm install -g node-gyp</code> </pre><br>     ,   <code>hello.cc</code>  <code>binding.gyp</code> ,      : <br><br><pre> <code class="bash hljs">$ node-gyp configure $ node-gyp build</code> </pre><br>    <code>build</code> .   <code>build/Release/</code>     <code>.node</code> . ,   Node.js   <code>hello.js</code> ,      C++: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> addon = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./build/Release/addon'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(addon.hello()) <span class="hljs-comment"><span class="hljs-comment">// 'capital one'</span></span></code> </pre><br>         <code>capital one</code> , : <br><br><pre> <code class="bash hljs">$ node hello.js</code> </pre><br>     C++   : <a href="https://github.com/nodejs/node-addon-examples">https://github.com/nodejs/node-addon-examples</a> . <br><br><h1>  Conclusion </h1><br>       <a href="https://github.com/azat-co/you-dont-know-node">GitHub</a> .     Node.js, callback'  Node-,     <a href="http://webapplog.com/node-patterns-from-callbacks-to-observer/"> Node:  callback'  observer'</a> . <br><br>    : <br><br><ol><li> <b> :</b> ,      /  Node. </li><li> <b>  :</b>     . </li><li> <b> :</b>  ‚Äúobserver‚Äù  Node.js. </li><li> <b>:</b>      . </li><li> <b>:</b>   . </li><li> <b>:</b>  . </li><li> <b>Domain:</b>   . </li><li> <b>  C++:</b>  . </li></ol><br>   Node     JavaScript,     ,       ,  ,     .       ,       Node.js. </div><p>Source: <a href="https://habr.com/ru/post/283228/">https://habr.com/ru/post/283228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283218/index.html">Yandex Translate for Visual Studio Code</a></li>
<li><a href="../283220/index.html">Data transfer: fantastic speed and new methods</a></li>
<li><a href="../283222/index.html">Access to the Firebird database from YII2</a></li>
<li><a href="../283224/index.html">An interesting way to deliver malware or how ‚Äúhackers‚Äù break into ‚Äúscammers‚Äù</a></li>
<li><a href="../283226/index.html">Runtime programming industrial robot on RCML</a></li>
<li><a href="../283230/index.html">Material Design: philosophy and practice</a></li>
<li><a href="../283238/index.html">Welcome to the DotNext conference</a></li>
<li><a href="../283242/index.html">Taming the elephant or what is HUE</a></li>
<li><a href="../283244/index.html">F1 2015: a new level of realism on the PC</a></li>
<li><a href="../283248/index.html">9 secrets of online payments. Part 5: Mobile Payments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>