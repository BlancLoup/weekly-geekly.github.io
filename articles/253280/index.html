<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PVS-Studio: 25 suspicious code snippets from CoreCLR</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microsoft has released the open source source code engine CoreCLR, which is a key element of. NET Core. This news, of course, could not fail to attrac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PVS-Studio: 25 suspicious code snippets from CoreCLR</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62c/589/846/62c589846b53c11218ca6ac02056d42d.png"></div><br>  Microsoft has released the open source source code engine CoreCLR, which is a key element of. NET Core.  This news, of course, could not fail to attract our attention.  After all, the larger the audience of the project, the more alarming the suspicious places found will be.  Despite the authorship of Microsoft, as in any large project, there is something to see and think about. <br><br><h2>  Introduction </h2><br>  <a href="https://github.com/dotnet/coreclr">CoreCLR</a> is a .NET Core runtime environment, performing functions such as garbage collection or compiling to final machine code.  .Net Core is a modular implementation of .Net that can be used as a base for a huge number of scenarios. <br><br>  Recently the source code is available on GitHub and has been tested with <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> 5.23.  Like me, anyone can get a full verification log using Microsoft Visual Studio Community Edition, the release of which was also recent <a href="http://www.viva64.com/ru/n/0102/">news</a> from Microsoft. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Typos </h2><br>  Traditionally, I start from typos-like places.  In conditional expressions, variables, constants, macros, or structure / class fields are repeated.  The presence of an error is a subject of discussion; nevertheless, such places were found and look suspicious. <br><br>  <a href="http://www.viva64.com/ru/d/0090/">V501</a> There are identical sub-expressions 'tree-&gt; gtOper == GT_CLS_VAR'  operator.  ClrJit lsra.cpp 3140 <br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// register variable GTNODE(GT_REG_VAR , "regVar" ,0,GTK_LEAF|GTK_LOCAL) // static data member GTNODE(GT_CLS_VAR , "clsVar" ,0,GTK_LEAF) // static data member address GTNODE(GT_CLS_VAR_ADDR , "&amp;clsVar" ,0,GTK_LEAF) .... void LinearScan::buildRefPositionsForNode(GenTree *tree, ....) { .... if ((tree-&gt;gtOper == GT_CLS_VAR || tree-&gt;gtOper == GT_CLS_VAR) &amp;&amp; i == 1) { registerType = TYP_PTR; currCandidates = allRegs(TYP_PTR); } .... }</span></span></code> </pre> <br>  Although the 'GenTree' structure has a similar field "tree-&gt; gtType", it has a different type with "tree-&gt; gtOper".  I think the point here is in the copied constant.  That is, in the expression should be used another constant, in addition to GT_CLS_VAR. <br><br>  <a href="http://www.viva64.com/ru/d/0090/">V501</a> There are identical sub-expressions "DECODE_PSP_SYM"  operator.  daccess 264 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GcInfoDecoderFlags { DECODE_SECURITY_OBJECT = <span class="hljs-number"><span class="hljs-number">0x01</span></span>, DECODE_CODE_LENGTH = <span class="hljs-number"><span class="hljs-number">0x02</span></span>, DECODE_VARARG = <span class="hljs-number"><span class="hljs-number">0x04</span></span>, DECODE_INTERRUPTIBILITY = <span class="hljs-number"><span class="hljs-number">0x08</span></span>, DECODE_GC_LIFETIMES = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, DECODE_NO_VALIDATION = <span class="hljs-number"><span class="hljs-number">0x20</span></span>, DECODE_PSP_SYM = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, DECODE_GENERICS_INST_CONTEXT = <span class="hljs-number"><span class="hljs-number">0x80</span></span>, DECODE_GS_COOKIE = <span class="hljs-number"><span class="hljs-number">0x100</span></span>, DECODE_FOR_RANGES_CALLBACK = <span class="hljs-number"><span class="hljs-number">0x200</span></span>, DECODE_PROLOG_LENGTH = <span class="hljs-number"><span class="hljs-number">0x400</span></span>, DECODE_EDIT_AND_CONTINUE = <span class="hljs-number"><span class="hljs-number">0x800</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GCDump::DumpGCTable(PTR_CBYTE table, ....) { <span class="hljs-function"><span class="hljs-function">GcInfoDecoder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hdrdecoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(table, (GcInfoDecoderFlags)( DECODE_SECURITY_OBJECT | DECODE_GS_COOKIE | DECODE_CODE_LENGTH | DECODE_PSP_SYM </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//&lt;==1 | DECODE_VARARG | DECODE_PSP_SYM //&lt;==1 | DECODE_GENERICS_INST_CONTEXT //&lt;==2 | DECODE_GC_LIFETIMES | DECODE_GENERICS_INST_CONTEXT //&lt;==2 | DECODE_PROLOG_LENGTH), 0); .... }</span></span></span></span></span></span></code> </pre> <br>  There are even two duplicate constants, although there are other constants in the "GcInfoDecoderFlags" enumeration that are not used in the condition. <br><br>  Similar places: <ul><li>  V501 There are identical sub-expressions L varLoc1.vlStk2.vls2BaseReg ‚Äô== 'operator.  cee_wks util.cpp 657 </li><li>  V501 There are identical sub-expressions' varLoc1.vlStk2.vls2Offset '==' operator.  cee_wks util.cpp 658 </li><li>  V501 There are identical sub-expressions 'varLoc1.vlFPstk.vlfReg' operator.  cee_wks util.cpp 661 </li></ul><br>  <a href="http://www.viva64.com/ru/d/0339/">V700</a> Consider inspecting the 'T foo = foo = ...' expression.  It is odd that variable is initialized through itself.  cee_wks zapsig.cpp 172 <br><pre> <code class="cpp hljs">BOOL ZapSig::GetSignatureForTypeHandle(....) { .... CorElementType elemType = elemType = TryEncodeUsingShortcut(pMT); .... }</code> </pre> <br>  It seems to be just an extra assignment, but such errors are often made when copying code and forget to rename something.  In any case, in this form the code is meaningless. <br><br>  <a href="http://www.viva64.com/ru/d/0112/">V523</a> The 'then' statement is equivalent to the 'else' statement.  cee_wks threadsuspend.cpp 2468 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> __MIDL___MIDL_itf_mscoree_0000_0004_0001 { OPR_ThreadAbort = <span class="hljs-number"><span class="hljs-number">0</span></span>, OPR_ThreadRudeAbortInNonCriticalRegion = .... , OPR_ThreadRudeAbortInCriticalRegion = ....) , OPR_AppDomainUnload = .... , OPR_AppDomainRudeUnload = ( OPR_AppDomainUnload + <span class="hljs-number"><span class="hljs-number">1</span></span> ) , OPR_ProcessExit = ( OPR_AppDomainRudeUnload + <span class="hljs-number"><span class="hljs-number">1</span></span> ) , OPR_FinalizerRun = ( OPR_ProcessExit + <span class="hljs-number"><span class="hljs-number">1</span></span> ) , MaxClrOperation = ( OPR_FinalizerRun + <span class="hljs-number"><span class="hljs-number">1</span></span> ) } EClrOperation; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Thread::SetRudeAbortEndTimeFromEEPolicy() { LIMITED_METHOD_CONTRACT; DWORD timeout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HasLockInCurrentDomain()) { timeout = GetEEPolicy()-&gt; GetTimeout(OPR_ThreadRudeAbortInCriticalRegion); <span class="hljs-comment"><span class="hljs-comment">//&lt;== } else { timeout = GetEEPolicy()-&gt; GetTimeout(OPR_ThreadRudeAbortInCriticalRegion); //&lt;== } .... }</span></span></code> </pre> <br>  This diagnostic finds the same blocks in the if / else constructs.  And here, too, there is a suspicion of a typo in the constant.  In the first case, the meaning of the ‚ÄúOPR_ThreadRudeAbortInNonCriticalRegion‚Äù just fits. <br><br>  Similar places: <ul><li>  V523 The 'then' statement is equivalent to the 'else' statement.  ClrJit instr.cpp 3427 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  ClrJit flowgraph.cpp 18815 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  daccess dacdbiimpl.cpp 6374 </li></ul><br><h2>  Constructor initialization list </h2><br>  <a href="http://www.viva64.com/ru/d/0300/">V670</a> The uninitialized class member 'gcInfo' is used to initialize the 'regSet' member.  Remember that members are initialized in the order of declarations inside a class.  ClrJit codegencommon.cpp 92 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CodeGenInterface *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCodeGenerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Compiler *comp)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeGenInterface</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emitter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... RegSet regSet; <span class="hljs-comment"><span class="hljs-comment">//&lt;=== line 91 .... public: GCInfo gcInfo; //&lt;=== line 322 .... }; // CodeGen constructor CodeGenInterface::CodeGenInterface(Compiler* theCompiler) : compiler(theCompiler), gcInfo(theCompiler), regSet(theCompiler, gcInfo) { }</span></span></code> </pre> <br>  According to the standard, the order of initialization of class members in the constructor occurs in the order they are declared in the class.  To correct the error, move the declaration of a member of the class 'gcInfo' above the declaration 'regSet'. <br><br><h2>  False but useful warning </h2><br>  V705 It is possible that ‚Äúelse‚Äù block was forgotten or commented out, thus altering the program's operation logics.  daccess daccess.cpp 2979 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hdr.dwSig == sig) { m_rw = eRO; m_MiniMetaDataBuffSizeMax = hdr.dwTotalSize; hr = S_OK; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">// when the DAC initializes this for the case where the target is // (a) a live process, or (b) a full dump, buff will point to a // zero initialized memory region (allocated w/ VirtualAlloc) if (hdr.dwSig == 0 &amp;&amp; hdr.dwTotalSize == 0 &amp;&amp; hdr.dwCntStreams == 0) { hr = S_OK; } // otherwise we may have some memory corruption. treat this as // a liveprocess/full dump else { hr = S_FALSE; } .... }</span></span></code> </pre> <br>  The analyzer detected a suspicious place in the code.  Here you can see that the code is commented and everything is fine  But this type of error is very common when the code after the 'else' is commented out and the operator following it becomes part of the condition.  In this example, there is no error, but it is quite possible to allow it when editing this place in the future. <br><br><h2>  64-bit error </h2><br>  <a href="http://www.viva64.com/ru/d/0306/">V673</a> The '0xefefefef &lt;&lt; 28' expression evaluates to the 'unsigned' type '32' bits.  cee_dac _dac object.inl 95 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Object::EnumMemoryRegions(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... SIZE_T size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ObjHeader) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Object); .... size |= <span class="hljs-number"><span class="hljs-number">0xefefefef</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">28</span></span>; .... }</code> </pre> <br>  You can read about the term ‚Äú64-bit error‚Äù <a href="http://www.viva64.com/ru/t/0002/">here</a> .  In this example, after the shift, the operation ‚Äúsize | = 0xf0000000‚Äù in a 32-bit program and ‚Äúsize | = 0x00000000f0000000‚Äù in a 64-bit one will be performed.  Most likely, in the 64-bit program they planned to calculate: "size | = 0x0efefefef0000000".  But where is the oldest part of the number? <br><br>  The number ‚Äú0xefefefef‚Äù is of type 'unsigned', because it does not fit into the type of 'int'.  The shift of the 32-bit number is performed and as a result we get 0xf0000000 unsigned type.  Further, this unsigned number will expand to SIZE_T and we will get 0x00000000f0000000. <br><br>  To work correctly, you must first perform an explicit type conversion.  An example of the correct code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Object::EnumMemoryRegions(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... SIZE_T size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ObjHeader) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Object); .... size |= SIZE_T(<span class="hljs-number"><span class="hljs-number">0xefefefef</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">28</span></span>; .... }</code> </pre> <br>  Another place: <ul><li>  V673 The '0xefefefef &lt;&lt; 28' expression evaluates to the 'unsigned' type '32' bits.  cee_dac dynamicmethod.cpp 807 </li></ul><br><h2>  Code "retired" </h2><br>  Sometimes the conditions are written so that they literally contradict each other. <br><br>  <a href="http://www.viva64.com/ru/d/0255/">V637</a> Two opposite conditions were encountered.  The second condition is always false.  Check lines: 31825, 31827. cee_wks gc.cpp 31825 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gc_heap::verify_heap (BOOL begin_gc_p) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (brick_table [curr_brick] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (brick_table [curr_brick] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { dprintf(<span class="hljs-number"><span class="hljs-number">3</span></span>, (<span class="hljs-string"><span class="hljs-string">"curr_brick %Ix for object %Ix set to 0"</span></span>, curr_brick, (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)curr_object)); FATAL_GC_ERROR(); } .... } .... }</code> </pre> <br>  Code that never gets control, but it doesn't look as significant as in the following example: <br><br>  <a href="http://www.viva64.com/ru/d/0106/">V517</a> The use of if (A) {...} else if (A) {...} 'pattern was detected.  There is a possibility of logical error presence.  Check lines: 2353, 2391. utilcode util.cpp 2353 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutIA64Imm22</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT64 * pBundle, UINT32 slot, INT32 imm22)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slot == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UINT64 mask0 = UI64(<span class="hljs-number"><span class="hljs-number">0xFFFFFC000603FFFF</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Clear all bits used as part of the imm22 */</span></span> pBundle[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;= mask0; UINT64 temp0; temp0 = (UINT64) (imm22 &amp; <span class="hljs-number"><span class="hljs-number">0x200000</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 s temp0 |= (UINT64) (imm22 &amp; 0x1F0000) &lt;&lt; 11; // 5 imm5c temp0 |= (UINT64) (imm22 &amp; 0x00FF80) &lt;&lt; 25; // 9 imm9d temp0 |= (UINT64) (imm22 &amp; 0x00007F) &lt;&lt; 18; // 7 imm7b /* Or in the new bits used in the imm22 */ pBundle[0] |= temp0; } else if (slot == 1) { .... } else if (slot == 0) //&lt;== { const UINT64 mask1 = UI64(0xF000180FFFFFFFFF); /* Clear all bits used as part of the imm22 */ pBundle[1] &amp;= mask1; UINT64 temp1; temp1 = (UINT64) (imm22 &amp; 0x200000) &lt;&lt; 37; // 1 s temp1 |= (UINT64) (imm22 &amp; 0x1F0000) &lt;&lt; 32; // 5 imm5c temp1 |= (UINT64) (imm22 &amp; 0x00FF80) &lt;&lt; 43; // 9 imm9d temp1 |= (UINT64) (imm22 &amp; 0x00007F) &lt;&lt; 36; // 7 imm7b /* Or in the new bits used in the imm22 */ pBundle[1] |= temp1; } FlushInstructionCache(GetCurrentProcess(),pBundle,16); }</span></span></code> </pre> <br>  Perhaps a very important code never gets control because of an error in the cascade of conditional statements. <br><br>  More suspicious places: <ul><li>  V637 Two opposite conditions were encountered.  The second condition is always false.  Check lines: 2898, 2900. daccess nidump.cpp 2898 </li><li>  V637 Two opposite conditions were encountered.  The second condition is always false.  Check lines: 337, 339. utilcode prettyprintsig.cpp 337 </li><li>  V637 Two opposite conditions were encountered.  The second condition is always false.  Check lines: 774, 776. utilcode prettyprintsig.cpp 774 </li></ul><br><h2>  Undefined behavior </h2><br>  <a href="http://www.viva64.com/ru/d/0225/">V610</a> Undefined behavior.  Check the shift operator '&lt;&lt;'.  The left operand '-1' is negative.  bcltype metamodel.h 532 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> mdToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decodeToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//&lt;TODO&gt;@FUTURE: make compile-time calculation&lt;/TODO&gt; ULONG32 ix = (ULONG32)(val &amp; ~(-1 &lt;&lt; m_cb[cTokens])); if (ix &gt;= cTokens) return rTokens[0]; return TokenFromRid(val &gt;&gt; m_cb[cTokens], rTokens[ix]); }</span></span></code> </pre> <br>  The analyzer detected a shift operation of a negative number, which leads to undefined behavior. <br><br>  V610 Undefined behavior.  Check the shift operator '&lt;&lt;'.  The left operand '(~ 0)' is negative.  cee_dac decodemd.cpp 456 <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bits_generation 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> generation_mask (~(~0 &lt;&lt; bits_generation)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK(len) (~((~0)&lt;&lt;len)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK64(len) ((~((~((unsigned __int64)0))&lt;&lt;len))) void Encoder::Add(unsigned value, unsigned length) { .... value = (value &amp; MASK(length)); .... }</span></span></code> </pre> <br>  Thanks to the post of the V610 analyzer, I found several incorrect macros.  '~ 0' is reduced to a signed negative integer, followed by a shift.  As in one of the macros, you need to perform an explicit conversion to unsigned: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bits_generation 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> generation_mask (~(~((unsigned int)0) &lt;&lt; bits_generation)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK(len) (~((~((unsigned int)0))&lt;&lt;len)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK64(len) ((~((~((unsigned __int64)0))&lt;&lt;len)))</span></span></code> </pre> <br><h2>  Incorrect sizeof (xx) </h2><br>  The DacReadAll V579  It is possibly a mistake.  Inspect the third argument.  daccess dacimpl.h 1688 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MisalignedRead</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CORDB_ADDRESS</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCEEDED(DacReadAll(TO_TADDR(addr), t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br>  This is such a small function that always takes the size of the pointer.  Most likely, they wanted to write ‚Äúsizeof (* t)‚Äù, well, or ‚Äúsizeof (T)‚Äù. <br><br>  Another illustrative example: <br><br>  <a href="http://www.viva64.com/ru/d/0181/">V579</a> .  It is possibly a mistake.  Inspect the third argument.  util.cpp 4943 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMTOfObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TADDR obj, TADDR *mt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> E_POINTER; HRESULT hr = rvCache-&gt;Read(obj, mt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mt), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SUCCEEDED(hr)) *mt &amp;= ~<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hr; }</code> </pre> <br><br><h2>  Family of functions "memFAIL" </h2><br>  With the use of memXXX-functions can make a variety of errors.  To search for such places in the analyzer there are several diagnostic rules. <br><br>  <a href="http://www.viva64.com/ru/d/0101/">V512</a> A call to the "memset" function will lead to the underflow of the buffer 'pAddExpression'.  sos strike.cpp 11973 <br><pre> <code class="cpp hljs">DECLARE_API(Watch) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(addExpression.data != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || aExpression.data != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { WCHAR pAddExpression[MAX_EXPRESSION]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(pAddExpression, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_EXPRESSION); swprintf_s(pAddExpression, MAX_EXPRESSION, <span class="hljs-string"><span class="hljs-string">L"%S"</span></span>, ....); Status = g_watchCmd.Add(pAddExpression); } .... }</code> </pre> <br>  A common mistake when they forget to make an amendment to the size of a type: <br><pre> <code class="cpp hljs">WCHAR pAddExpression[MAX_EXPRESSION]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(pAddExpression, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(WCHAR)*MAX_EXPRESSION);</code> </pre> <br>  A few more places like this: <ul><li>  V512 A call-out the memset function will lead to the underflow of the buffer pSaveName.  sos strike.cpp 11997 </li><li>  V512 A call-out the memset function will lead to the underflow of the buffer pOldName.  sos strike.cpp 12013 </li><li>  V512 A call of the memset function will lead to the underflow of the buffer pNewName.  sos strike.cpp 12016 </li><li>  V512 A call of the memset function will lead to underflow of the buffer 'pExpression'.  sos strike.cpp 12024 </li><li>  V512 A call of the memset function will lead to underflow of the buffer pFilterName.  sos strike.cpp 12039 </li></ul><br>  <a href="http://www.viva64.com/ru/d/0209/">V598</a> The 'memcpy' function is used to copy the fields of the 'GenTree' class.  Virtual table pointer will be maintained by this.  ClrJit compiler.hpp 1344 <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenTree</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEBUGGABLE_GENTREE virtual void DummyVirt() {} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// DEBUGGABLE_GENTREE .... }; void GenTree::CopyFrom(const GenTree* src, Compiler* comp) { .... memcpy(this, src, src-&gt;GetNodeSize()); .... }</span></span></span></span></code> </pre> <br>  If the preprocessor variable 'DEBUGGABLE_GENTREE' is declared, then a virtual function is defined.  Then the class contains a pointer to a table of virtual methods and it can no longer be copied like this. <br><br>  <a href="http://www.viva64.com/ru/d/0209/">V598</a> The 'memcpy' function is used to copy the fields of the 'GCStatistics' class.  Virtual table pointer will be maintained by this.  cee_wks gc.cpp 287 <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GCStatistics</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StatisticsBase { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplayAndUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; .... }; GCStatistics g_LastGCStatistics; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GCStatistics::DisplayAndUpdate() { .... <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;g_LastGCStatistics, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(g_LastGCStatistics)); .... }</code> </pre> <br>  In this place incorrect copying is performed not only in debug mode. <br><br>  <a href="http://www.viva64.com/ru/d/0337/">V698</a> Expression 'memcmp (....) == -1' is incorrect.  This function can return not only the value '-1', but any negative value.  Consider using 'memcmp (....) &lt;0' instead.  sos util.cpp 142 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GUID&amp; _Key1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GUID&amp; _Key2)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(&amp;_Key1, &amp;_Key2, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GUID)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  It is not correct to compare the result of the function 'memcmp' with the value 1 or -1.  The efficiency of such constructions depends on the libraries, the compiler, its settings, the operating system, its capacity and so on;  in this case, it is necessary to check one of the three states: '&lt;0', '0' or '&gt; 0'. <br><br>  Similar place: <ul><li>  V698 Expression 'wcscmp (....) == -1' is incorrect.  This function can return not only the value '-1', but any negative value.  Consider using 'wcscmp (....) &lt;0' instead.  sos strike.cpp 3855 </li></ul><br><h2>  About pointers </h2><br>  <a href="http://www.viva64.com/ru/d/0111/">V522</a> Dereferencing of the null pointer 'hp' might take place.  cee_wks gc.cpp 4488 <br><pre> <code class="cpp hljs">heap_segment* gc_heap::get_segment_for_loh (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size #ifdef MULTIPLE_HEAPS , gc_heap* hp #endif <span class="hljs-comment"><span class="hljs-comment">//MULTIPLE_HEAPS ) { #ifndef MULTIPLE_HEAPS gc_heap* hp = 0; #endif //MULTIPLE_HEAPS heap_segment* res = hp-&gt;get_segment (size, TRUE); .... }</span></span></code> </pre> <br>  If 'MULTIPLE_HEAPS' is not defined, then trouble.  The pointer will be zero. <br><br>  It was verified against nullptr.  Check lines: 6970, 6976. ClrJit gentree.cpp 6970 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Compiler::gtDispNode(GenTreePtr tree, ....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree-&gt;gtOper &gt;= GT_COUNT) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" **** ILLEGAL NODE ****"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tree &amp;&amp; printFlags) { <span class="hljs-comment"><span class="hljs-comment">/* First print the flags associated with the node */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (tree-&gt;gtOper) { .... } .... } .... }</code> </pre> <br>  In the source code, there are common places when the pointer is checked for validity, but after dereference. <br><br>  The entire list: <a href="http://www.viva64.com/external-pictures/txt/CoreCLR_V595.txt">CoreCLR_V595.txt</a> . <br><br><h2>  Extra checks </h2><br>  Even if the extra code is not harmful, its presence may simply distract the development attention from more important places. <br><br>  <a href="http://www.viva64.com/ru/d/0092/">V503</a> This is a nonsensical comparison: pointer&gt; = 0. cee_wks gc.cpp 21707 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gc_heap::make_free_list_in_brick (BYTE* tree, make_free_args* args) { assert ((tree &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)); .... }</code> </pre> <br>  Here is a check pointer.  More examples: <ul><li>  V503 This is a nonsensical comparison: pointer&gt; = 0. cee_wks gc.cpp 23204 </li><li>  V503 This is a nonsensical comparison: pointer&gt; = 0. cee_wks gc.cpp 27683 </li></ul><br>  <a href="http://www.viva64.com/ru/d/0137/">V547</a> Expression 'maxCpuId&gt; = 0' is always true.  Unsigned type value is always&gt; = 0. cee_wks codeman.cpp 1219 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EEJitManager::SetCpuInfo() { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">16</span></span>]; DWORD maxCpuId = getcpuid(<span class="hljs-number"><span class="hljs-number">0</span></span>, buffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxCpuId &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  A similar example, only with the DWORD type. <br><br>  <a href="http://www.viva64.com/ru/d/0194/">V590</a> Consider inspecting the 'wzPath [0]! = L' \ 0 '&amp;&amp; wzPath [0] == L' \\ '' expression.  The expression is misprint.  cee_wks path.h 62 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasUncPrefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPCWSTR wzPath)</span></span></span><span class="hljs-function"> </span></span>{ _ASSERTE(!clr::str::IsNullOrEmpty(wzPath)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wzPath[<span class="hljs-number"><span class="hljs-number">0</span></span>] != W(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">0</span></span>] == W(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">1</span></span>] != W(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">1</span></span>] == W(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">2</span></span>] != W(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">2</span></span>] != W(<span class="hljs-string"><span class="hljs-string">'?'</span></span>); }</code> </pre> <br>  This function can be simplified to this option: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasUncPrefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPCWSTR wzPath)</span></span></span><span class="hljs-function"> </span></span>{ _ASSERTE(!clr::str::IsNullOrEmpty(wzPath)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wzPath[<span class="hljs-number"><span class="hljs-number">0</span></span>] == W(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">1</span></span>] == W(<span class="hljs-string"><span class="hljs-string">'\\'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">2</span></span>] != W(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &amp;&amp; wzPath[<span class="hljs-number"><span class="hljs-number">2</span></span>] != W(<span class="hljs-string"><span class="hljs-string">'?'</span></span>); }</code> </pre> <br>  Another place: <ul><li>  V590 Consider inspecting this expression.  The expression is misprint.  cee_wks path.h 72 </li></ul><br>  <a href="http://www.viva64.com/ru/d/0169/">V571</a> Recurring check.  The 'if (moduleInfo [MSCORWKS] .baseAddr == 0)' condition was already verified in line 749. sos util.cpp 751 <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleInfo</span></span></span><span class="hljs-class"> {</span></span> ULONG64 baseAddr; ULONG64 size; BOOL hasPdb; }; <span class="hljs-function"><span class="hljs-function">HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckEEDll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Do we have clr.dll if (moduleInfo[MSCORWKS].baseAddr == 0) //&lt;== { if (moduleInfo[MSCORWKS].baseAddr == 0) //&lt;== g_ExtSymbols-&gt;GetModuleByModuleName ( MAIN_CLR_MODULE_NAME_A,0,NULL, &amp;moduleInfo[MSCORWKS].baseAddr); if (moduleInfo[MSCORWKS].baseAddr != 0 &amp;&amp; //&lt;== moduleInfo[MSCORWKS].hasPdb == FALSE) { .... } .... } .... }</span></span></code> </pre> <br>  In the second case, 'baseAddr' can no longer be checked. <br><br>  <a href="http://www.viva64.com/ru/d/0343/">V704</a> 'this == nullptr' expression should be avoided - this expression can always be NULL.  ClrJit gentree.cpp 12731 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FieldSeqNode::IsFirstElemFieldSeq() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_fieldHnd == FieldSeqStore::FirstElemPseudoField; }</code> </pre> <br>  According to the C ++ standard, the this pointer can never be null.  The possible consequences of such a code can be found in detail in the diagnostic description of the <a href="http://www.viva64.com/ru/d/0343/">V704</a> .  The fact that such code can work correctly after compilation by the Visual C ++ compiler is just luck and you honestly cannot rely on it. <br><br>  The entire list: <a href="http://www.viva64.com/external-pictures/txt/CoreCLR_V704.txt">CoreCLR_V704.txt</a> . <br><br>  <a href="http://www.viva64.com/ru/d/0293/">V668 has been</a> defined using the 'new' operator.  The exception will be generated in the case of memory allocation error.  ClrJit stresslog.h 552 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FORCEINLINE BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowChunkList</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... StressLogChunk * newChunk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StressLogChunk (....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newChunk == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } .... }</code> </pre> <br>  If the 'new' operator could not allocate memory, then, according to the C ++ standard of the language, the exception std :: bad_alloc () is generated.  Thus, it does not make sense to check the pointer to equality to zero. <br><br>  It is better to check such places, here is the complete list: <a href="http://www.viva64.com/external-pictures/txt/CoreCLR_V668.txt">CoreCLR_V668.txt</a> . <br><br><h2>  Conclusion </h2><br>  The newly opened project CoreCLR is a good example of what closed source software might look like.  There are constantly discussions on this topic and here you have one more reason for reflection and discussion. <br><br>  For us, it is important that in any large project you can find some mistakes and the best use of the static analyzer is regular checks.  Do not be lazy, <a href="http://www.viva64.com/ru/pvs-studio-download/">download</a> PVS-Studio and check your project. <br><br><h2>  This article is in English. </h2><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Svyatoslav Razmyslov.  <a href="http://www.viva64.com/en/b/0310/">PVS-Studio: 25 Suspicious Code Fragments in CoreCLR</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected the answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio and CppCat, version 2014</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/253280/">https://habr.com/ru/post/253280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253268/index.html">How we spent 1 year and 3 months to develop a browser game</a></li>
<li><a href="../253270/index.html">Using Intel¬Æ C ++ Compiler Advanced Features for Android Applications</a></li>
<li><a href="../253272/index.html">Automate Cisco IOU from console</a></li>
<li><a href="../253274/index.html">Future C: OOP</a></li>
<li><a href="../253278/index.html">Meet Envoyer.io (part 2)</a></li>
<li><a href="../253281/index.html">Unpleasant surprises from Tinypass or not worth chasing a subscription discount</a></li>
<li><a href="../253283/index.html">Microsoft Technology Expedition Starts March 18 in St. Petersburg</a></li>
<li><a href="../253285/index.html">Finding relationships using the Oil Ruble example</a></li>
<li><a href="../253287/index.html">Update Opera Mini servers: Flexbox, ES5, HTML5 parser</a></li>
<li><a href="../253291/index.html">Some pitfalls of IP Cloud technology in Mikrotik routers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>