<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to find and fix memory leaks using the example of Yandex.Mail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At first glance, the words JavaScript and memory leaks cannot stand nearby. Real memory leaks in JS, of course, can not be, because the process of gar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to find and fix memory leaks using the example of Yandex.Mail</h1><div class="post__text post__text-html js-mediator-article">  At first glance, the words JavaScript and memory leaks cannot stand nearby.  Real memory leaks in JS, of course, can not be, because the process of garbage collection occurs automatically and can not be controlled from our code.  It is impossible to allocate memory for an object and forget to free it.  But there may be situations associated with errors in the logic of the application, which lead to memory leaks of a different kind.  For example, zabindili handler, in which we do something with the methods of the common object and forget it anbind.  Or send a letter with a large body and do not clear the body even after sending. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/195198/"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/6a4/d97/1ab6a4d97eb33369673b99dd8f1220c4.jpg" alt="image"></a> <br><br>  We at Yandex.Mail, a complex and massive project, have gained considerable experience in finding and fixing such leaks, and we want to share them. <br><a name="habracut"></a><br><h4>  Little materiel </h4><br>  As we know, in JS there are objects and primitives.  Properties of objects can refer to other objects, or contain primitives.  JSHeap is just a graph of related objects.  The root of this graph is usually a global object (GC Roots).  The nodes in this graph have two types of sizes: shallow size and retained size.  Shallow size - the net amount of memory occupied by the object.  Retained size - this is the total amount of memory that will be released during garbage collection, if you delete the object and all references to it from the root of the graph.  You should look at shallow size only for arrays or primitives (which actually have retained size === shallow size).  The path along which an object can be obtained from the root of a graph is called the retaining path.  Objects for which it is impossible to obtain the retaining path are garbage and are deleted the next time it is assembled. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Instruments </h4><br>  Here the situation is even worse than rendering profiling.  Normal tools are available only in browsers on Chrome Developer Tools and in the future IE 11. I will use <a href="https://developers.google.com/chrome-developer-tools/">Chrome Developer Tools</a> . <br><br><h4>  Profiling conditions </h4><br>  Yet again: <br><ul><li>  you should not run other programs; </li><li>  Chromium should be run with default settings (if you use any experimental features, reset them to default on the chrome page: // flags); </li><li>  only one tab should be left open with the test site (this limitation is due to the fact that Chromium can render several tabs in one process, and, accordingly, there will be extra objects in the profiling results) </li><li> no plugins should be installed (or they should be turned off).  It is best to profile in private mode or launch the Chromium with a separate profile via: <code>&lt;  &gt; --user-data-dir=&lt;  ,     &gt;</code> . </li></ul><br><br><h4>  We define cases in which there can be leaks </h4><br>  In general, for this you can try to poligate information from <code>window.performance.memory</code> (only in Chromium&gt; 22) and see what actions were performed by users for whom <code>usedJSHeapSize</code> (size of used memory) approaches <code>totalJSHeapSize</code> (total size of JS memory allocated to the process) , or just a big number in <code>totalJSHeapSize</code> .  But it seems to me that this thing shows incorrect numbers, because after logging we only have 5% of users, after 7+ hours of using mail, <code>totalJSHeapSize</code> approaches 100 MB. <br><br>  For all the others, these values ‚Äã‚Äãeither do not change with time or are equal to zero.  Therefore, I decided to look for leaks manually.  To determine when there is a possibility of a memory leak, we will use the timeline panel in Chrome Developer Tools, and more specifically the Memory mode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a41/218/7bd/a412187bd9b1b962bd1947b96e43f65d.png" alt="image"><br><br>  Open the test site (in my case, mail.yandex.ru) and start recording (Cmd + E).  Next several times we perform an action that, in our opinion, can lead to a memory leak.  I simply clicked on ‚ÄúCheck‚Äù in the toolbar.  During recording, we get something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/c89/eef/a9dc89eef73bb27c4f42cf71d4a5a3b0.png" alt="image"><br><br>  It is important to pay attention to the graph in the uppermost panel and the graph with statistics in the ‚Äúcounters‚Äù panel.  In the upper graph, we can see how memory is allocated and, in fact, the size of JSHeap at different points in time.  In general, growth with gorochka is normal, because there has not yet been garbage collection.  It will be over time, and then the value of the occupied memory should return to normal (in our case - 8.4 MB).  You can not wait for the GC and force the garbage collection if you click on the bucket in the lower left.  There are three indicators in the ‚Äúcounters‚Äù panel: <br><ul><li>  Document Count - the number of html documents (this includes frames); </li><li>  DOM Node Count - the number of DOM nodes; </li><li>  Event Listener Count - the number of event handlers, </li></ul><br>  And there is a graph of changes in these indicators for the above period of time.  These indicators are important because they are not counted on the memory occupied graph at the top.  So, if after the garbage collection the hill does not fall to the baseline, or the figures in the Counters panel do not return to the previous ones, then we found a case that leads to a leak. <br><br><h4>  Find the cause of the leak </h4><br>  Ok, we found a sequence of actions that leads to a leak.  To find the cause of the leak, use the Profiles panel and the Take Heap Snapshot item in it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d71/272/1ac/d712721ac1148c629d5bd2b691b2e3b3.png" alt="image"><br><br>  By clicking on the Take Snapshot button, you can get the JSHeap snapshot at the moment: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/120/52e/70a/12052e70a3020db95212f572102dfd75.png" alt="image"><br><br>  In the left column, under the name of snapshot (we have Snapshot 1), the total size of the memory occupied by living objects is indicated - those that have a retaining path.  Only alive, because after each click on this button, the first thing is called the garbage collector.  In the panel that occupies the main part of the right part of the screenshot, you can view the objects themselves, the size of the memory they occupy (absolute values ‚Äã‚Äãin bytes or a percentage of the total snapshot size) and other useful information.  By default, objects in this panel are shown in Summary mode, where they are grouped by the name of their constructor.  Distance column - the number of links to this object from the root (GC Roots).  Objects Count - the number of objects with this constructor. <br><br>  If the name of the constructor is in parentheses, then this is an internal type of object or a primitive (with the exception of array).  In principle, most objects with a constructor in brackets can be ignored ("(compiled code)", "(closure)", "(system)"), except, perhaps, "(string)" and "(array) "- and that only if they have a large shallow size.  You can submit snapshot contents in other modes: <br><br><ul><li>  Comparison - compares two snapshots and shows only those objects that have changed. </li><li>  Containment - shows the entire graph as a tree with global objects.  Convenient for detecting unused DOM tree (Detached DOM tree). </li><li>  Dominators - Shows the dominators (objects that are in as many of the retaining paths as possible). </li></ul><br>  In Summary mode, for convenience, you can filter objects by the name of the constructor through the search bar at the top.  If you select an object from the group, below you can see the retaining path in the form of a tree: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0b/5d8/2e7/c0b5d82e714317475b2929203dd2c5ca.png" alt="image"><br><br>  Gray indicates aydishniki objects.  If the object is highlighted in yellow, then somewhere there is a link to it, which keeps it from garbage collection.  If the object is highlighted in red - this is a DOM node that has been tampered with, but a reference from JS remains on it.  You can hover over many objects with the mouse and additional information will appear in the yellow bubble (this is especially useful for functions and DOM nodes, because for them you can find out the function body and attributes of the node). <br><br><h4>  Technique three snapshots </h4><br>  We have a case in which we noticed a leak on the timeline: <br><ul><li>  Go to inbox. </li><li>  Scroll a little scroll so that a fixed toolbar appears. </li><li>  Click on ‚ÄúCheck‚Äù several times. </li></ul><br>  To find objects that are not deleted, we will use the technique of three snapshots.  I will do this on the developer version of mail, in order to have non-focused property names and variables. <br><ul><li>  We make the first snapshot before the actions from the case (it is needed for the baseline).  Sometimes in front of him you also need to perform some warm-up actions.  For example, if we have a case connected with the page of writing a letter, then we must first go to it (so that all the necessary modules are loaded and executed). </li><li>  We repeat the actions from the case several times (it is better to repeat an odd number of times so that it is easier to determine the current objects when analyzing snapshots) and do a second snapshot. </li><li>  We repeat the same actions again the same time and make the third snapshot. </li><li>  Next, select the third snapshot and in the Summary mode in the select below select ‚ÄúObjects allocated between Snapshots 1 and 2‚Äù (or 2 and 3 - whatever you like). </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/52f/1a5/06c/52f1a506c44be45323325b059d1d4bd1.png" alt="image"><br><br>  So we got all the leaked objects.  Sort the results by the Objects Count column: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49a/0ca/a60/49a0caa60ea8dcb82470be425b83efed.png" alt="image"><br><br>  In the top after objects with system constructors and arrays of cached emails, we see some suspicious divs, spans, links and input.  And there are exactly 7 of them - just as many times I clicked on the ‚ÄúCheck‚Äù button.  If we expand the HTMLInputElement, then we will see that all 7 objects are envelopes with the <code>b-mail-dropdown__search__input</code> class, to which there are just links in JS: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/370/888/ca2370888b466b8fd2b9dca8b93176ca.png" alt="image"><br><br>  The screenshot is not visible, but to find out the class, I just hover the cursor on one of the inputs.  By retaining path, you can quickly understand that this is an input from the dropdown (the first HTMLDivElement has the <code>b-mail-dropdown</code> class), which in turn is referenced in the event handler (you can understand by the standard jQuery structure $ - cache - [. .] - handle - elem - our element).  There is still a problem with the loader in the toolbar - the div with the loader is not cleared after garbage collection. <br><br><h4>  Fix leak </h4><br>  To fix this, first we find references to <code>b-mail-dropdown__search__input</code> in the JS code of our project.  We find in two files ‚Äúmail / blocks / folders-actions / folders-actions.js‚Äù and ‚Äúblocks / labels-actions / labels-actions.js‚Äù.  Aha, those popap with filters of folders and tags.  In folders-actions there is a document handler for <code>b-mail-dropdown-disabled</code> , which internally refers to a jquery dropdown object.  There is also a Jane.event <code>action-move-status.change</code> in the handler of which the _toggle method is called, which inside also refers to the jquery-object of the dropdown.  To get rid of the leak, simply enbind these handlers in onhtmldestroy and fill in the references to <code>this.$searchInput</code> and <code>this.$dropdown</code> : <br><br><pre> <code class="hljs kotlin">Block.FoldersActions.prototype.onhtmldestroy = function() { $(document).off(<span class="hljs-string"><span class="hljs-string">'click.newFolderClick'</span></span>) .off(<span class="hljs-string"><span class="hljs-string">'b-mail-dropdown-disabled'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._dropdownHideHandler); Jane.events.unbind(<span class="hljs-string"><span class="hljs-string">'action-move-status.change'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._moveStatusHandler); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$searchInput) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$searchInput.off(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$searchInput = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$dropdown) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$dropdown.off(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$dropdown = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } };</code> </pre> <br><br>  We do the same in labels-actions.  After checking all the divas, links and links from the dropdown disappear.  And with the loader in the toolbar, everything is a little different.  In "neo2 / js / components / loader.js" there is such code: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $toolbarSpinner = $(<span class="hljs-string"><span class="hljs-string">'&lt;div class="b-toolbar__spinner"/&gt;'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toolbarLoaderActive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Jane.Loader.createToolbarLoader = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(actionOpts, toolbarNode)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $spinner = $toolbarSpinner.<span class="hljs-keyword"><span class="hljs-keyword">clone</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> $toolbarBtn = $(actionOpts.event &amp;&amp; actionOpts.event.currentTarget); ... }</code> </pre> <br><br>  It is in a self-invoking function.  When we need to add a loader to the toolbar, we call Jane.Loader.createToolbarLoader.  He clones $ toolbarSpinner and inserts a clone into DOM.  As you can already guess, $ toolbarSpinner itself remains pointed and is never cleared.  This can be corrected if instead of cloning it is just to re-create the spinner element. <br><br>  Similarly, I fixed a few more leaks (on the letter writing page, a couple in the three-pane interface, when viewing the letter, one in the settings).  I also deleted Jane.Page.Log, which saved the parameters for every wound or action call, but didn‚Äôt do anything with them.  And limited the number of entries in the Logger <a href="https://github.com/highpower/xiva">xiva</a> object.  This is all because when sending letters there objects were added with all the parameters of the letter being sent (if a letter with a large body is a potential leak).  I also began to remove the body from the parameters after sending the letter. <br><br><h4>  Record Heap Allocations </h4><br>  To make it easier to find leaks, Chromium, starting from version 29, introduced an additional item in the Profiles panel - ‚ÄúRecord Heap Allocations‚Äù.  When you click on Start, it starts to take snapshots once every N seconds and compare it with the previous one, and in the top panel show the ratio of the cleaned objects to the live ones.  Live - blue, peeled - gray.  After stopping the recording, you can select any time interval and in the bottom panel look at the objects in the usual way (as after Take Snapshot). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c7/cdb/dae/8c7cdbdaef1510b2adef76b19dbeefca.png" alt="image"><br><br><h4>  Useful resources </h4><br><ul><li>  <a href="https://developers.google.com/chrome-developer-tools/docs/memory-analysis-101">developers.google.com/chrome-developer-tools/docs/memory-analysis-101</a> </li><li>  <a href="https://developers.google.com/chrome-developer-tools/docs/heap-profiling">developers.google.com/chrome-developer-tools/docs/heap-profiling</a> </li><li>  <a href="http://addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools/">addyosmani.com/blog/taming-the-unicorn-easing-javascript-memory-profiling-in-devtools</a> </li><li>  <a href="http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/">coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript</a> </li><li>  <a href="http://www.html5rocks.com/en/tutorials/memory/effectivemanagement/">www.html5rocks.com/en/tutorials/memory/effectivemanagement</a> </li><li>  <a href="http://www.html5rocks.com/en/tutorials/speed/static-mem-pools/">www.html5rocks.com/en/tutorials/speed/static-mem-pools</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/195198/">https://habr.com/ru/post/195198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195186/index.html">DEV Labs 2013. Oracle online software conference</a></li>
<li><a href="../195188/index.html">Metric # 23 - Podcast on IT technologies, products, and services</a></li>
<li><a href="../195190/index.html">Codenvy Factories: one-click cloning development environment</a></li>
<li><a href="../195192/index.html">New photocell efficiency record: 44.7%</a></li>
<li><a href="../195196/index.html">Optics for data centers. New trends</a></li>
<li><a href="../195200/index.html">Everything you need to know: 300 words about IDCEE 2013</a></li>
<li><a href="../195202/index.html">Survey: why people quit</a></li>
<li><a href="../195204/index.html">Domestic projects on Kickstarter and Indiegogo</a></li>
<li><a href="../195206/index.html">The walking LS3 robot will be made silent and insensitive to bullets for 10 million dollars</a></li>
<li><a href="../195210/index.html">A passion for programming. Chapter 5. Invest in Your Intellect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>