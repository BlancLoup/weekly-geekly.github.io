<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MySQL: optimized construction between</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Optimization is clearly not a MySQL server ridge. The purpose of this article is to explain to developers who do not work closely with databases and s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MySQL: optimized construction between</h1><div class="post__text post__text-html js-mediator-article">  Optimization is clearly not a MySQL server ridge.  The purpose of this article is to explain to developers who do not work closely with databases and sometimes do not understand why a query that successfully works in other DBMS in MySQL shamelessly slows down how the construction between MySQL is optimized. <br>  MySQL uses the rule based optimizer.  The rudiments of cost based optimization are certainly present in it, but not in the proper way in which I would like to see them.  For this reason, often the powers obtained after applying filters of sets are calculated incorrectly.  This leads to optimizer errors and a wrong execution plan.  Moreover, the obtained optimization between them cannot be changed by explicitly specifying the indices for the execution of the query and the order of joining the tables. <br><a name="habracut"></a><br><br><h5>  To begin, consider the bug: <a href="http://bugs.mysql.com/bug.php%3Fid%3D5982">bugs.mysql.com/bug.php?id=5982</a> and possible ways to resolve it </h5><br><br>  To understand the essence of the bug, we will create a test data set of 125 million records. <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> big_table; <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attributes</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> ( row_number <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> auto_increment, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> pk_pivot (row_number) ) <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">innodb</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span>(row_number) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> information_schema.global_status g1, information_schema.global_status g2 <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attributes</span></span>(attr_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> auto_increment, attribute_name <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, start_date datetime, end_date datetime, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> pk_attributes primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>(attr_id) ) <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">innodb</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> big_table(btbl_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> auto_increment, attr_attr_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, record_date datetime, record_value <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">128</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> pk_big_table primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>(btbl_id) ) <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">innodb</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attributes</span></span>(attribute_name, start_date, end_date) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number, <span class="hljs-keyword"><span class="hljs-keyword">str_to_date</span></span>(<span class="hljs-string"><span class="hljs-string">"20000101"</span></span>, <span class="hljs-string"><span class="hljs-string">"%Y%m%d"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">str_to_date</span></span>(<span class="hljs-string"><span class="hljs-string">"20000201"</span></span>, <span class="hljs-string"><span class="hljs-string">"%Y%m%d"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> big_table(attr_attr_id, record_date, record_value) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p1.row_number, <span class="hljs-keyword"><span class="hljs-keyword">date_add</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">str_to_date</span></span>(<span class="hljs-string"><span class="hljs-string">"20000101"</span></span>, <span class="hljs-string"><span class="hljs-string">"%Y%m%d"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> p2.row_number + p3.row_number <span class="hljs-keyword"><span class="hljs-keyword">day</span></span>), p2.row_number * <span class="hljs-number"><span class="hljs-number">1000</span></span> + p3.row_number <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> p1, <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> p2, <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> p3; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> idx_big_table_attr_date <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> big_table(attr_attr_id, record_date);</code> </pre> <br>  The <b>attributes</b> table is essentially a directory, for <b>big_table</b> as well as it contains two columns limiting the interval of dates to one month. <br><table><tbody><tr><td>  attr_id </td><td>  attribute_name </td><td>  start_date </td><td>  end_date </td></tr><tr><td>  one </td><td>  one </td><td>  1/1/2000 12:00:00 AM </td><td>  2/1/2000 12:00:00 AM </td></tr><tr><td>  2 </td><td>  2 </td><td>  1/1/2000 12:00:00 AM </td><td>  2/1/2000 12:00:00 AM </td></tr><tr><td>  3 </td><td>  3 </td><td>  1/1/2000 12:00:00 AM </td><td>  2/1/2000 12:00:00 AM </td></tr></tbody></table><br>  For each <b>attr_id</b> , a large table contains 250,000 entries.  Let's try to find out how many records are contained in <b>big_table</b> , taking into account the dates given by the <b>attributes</b> table for the attribute one. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attr_attr_id, <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(record_date), <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(record_date), <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(record_value), <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> big_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> attr_attr_id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> record_date <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str_to_date</span></span>(<span class="hljs-string"><span class="hljs-string">"20000101"</span></span>, <span class="hljs-string"><span class="hljs-string">"%Y%m%d"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str_to_date</span></span>(<span class="hljs-string"><span class="hljs-string">"20000201"</span></span>, <span class="hljs-string"><span class="hljs-string">"%Y%m%d"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> attr_attr_id;</code> </pre> <br><table><tbody><tr><td>  attr_attr_id </td><td>  max (record_date) </td><td>  min (record_date) </td><td>  count (1) </td></tr><tr><td>  one </td><td>  2/1/2000 12:00:00 AM </td><td>  1/3/2000 12:00:00 AM </td><td>  465 </td></tr></tbody></table><br>  We get about 500 records (the query execution time is negligible and amounted to 00.050 seconds).  It is logical to assume that since the data is distributed equally for all attribute values, then when connecting to the <b>attributes</b> table, instead of explicitly specifying the bind variables, the query time should increase slightly, and be no more than 25 seconds.  Well check: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.attr_attr_id, <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(b.record_date), <span class="hljs-keyword"><span class="hljs-keyword">min</span></span>(b.record_date), <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(b.record_value), <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attributes</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> big_table b <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> b.attr_attr_id = a.attr_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.record_date <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> a.start_date <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.end_date <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> b.attr_attr_id;</code> </pre> <br>  Execution time: more than 15 minutes (at this point I interrupted the execution of the request).  Why so?  The fact is that MySQL does not support dynamic rankings, which is what we are told about by bug <a href="http://bugs.mysql.com/bug.php%3Fid%3D5982"># 5982, which was</a> created back in 2004.  Let's see the execution plan: <br><table><tbody><tr><td>  id </td><td>  select_type </td><td>  table </td><td>  type </td><td>  possible_keys </td><td>  key </td><td>  key_len </td><td>  ref </td><td>  rows </td><td>  Extra </td></tr><tr><td>  one </td><td>  SIMPLE </td><td>  b </td><td>  ALL </td><td>  idx_big_table_attr_date </td><td></td><td></td><td></td><td>  125443538 </td><td>  Using temporary;  Using filesort </td></tr><tr><td>  one </td><td>  SIMPLE </td><td>  a </td><td>  eq_ref </td><td>  PRIMARY </td><td>  PRIMARY </td><td>  four </td><td>  test.b.attr_attr_id </td><td>  one </td><td>  Using where </td></tr></tbody></table><br>  The plan clearly shows that there is a full table scan of 125 million records.  Strange decision.  Correcting the situation will not help <b>straight_join</b> to change the join order or <b>force index</b> to explicitly specify to use the index.  The thing is that at best we get a plan of the form: <br><table><tbody><tr><td>  PRIMARY </td><td>  b </td><td>  ref </td><td>  idx_big_table_attr_date </td><td>  idx_big_table_attr_date </td><td>  five </td><td>  a.attr_id </td><td>  6949780 </td><td>  Using where </td></tr></tbody></table><br>  Which tells us that the <u><b>big_table</b> table will be scanned by the desired index, but the index will not be fully utilized, that is, only the first column will be used from it</u> .  In some degenerate cases, we can achieve the plan we need and make full use of the index, however, due to the variability of the optimizer and the inability to apply this solution (I will not give here its code, it does not work in 90% of cases) in all 100% of cases, we need different approach. <br>  This campaign offers us MySQL itself.  We will explicitly specify <b>bind</b> variables.  Of course, for a number of tasks this is not always effective, as it happens that a full scan is faster than the index one, but obviously not in our case when you need to select 500 records from 250,000. To solve the problem, we need to create the following procedure. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">drop</font> <font color="#0000ff">procedure</font> <font color="#0000ff">if</font> <font color="#0000ff">exists</font> get_big_table_data; <br> delimiter $$ <br> <font color="#0000ff">create</font> <font color="#0000ff">procedure</font> get_big_table_data(i_attr_from <font color="#0000ff">int</font> (10)) <br> main_sql: <br> <font color="#0000ff">begin</font> <br> <font color="#0000ff">declare</font> v_attr_id <font color="#0000ff">int</font> (10); <br> <font color="#0000ff">declare</font> v_start_date         datetime; <br> <font color="#0000ff">declare</font> v_end_date            datetime; <br> <font color="#0000ff">declare</font> ex_no_records_found <font color="#0000ff">int</font> (10) <font color="#0000ff">default</font> 0; <br> <br> <font color="#0000ff">declare</font> <br> attr <font color="#0000ff">cursor</font> <font color="#0000ff">for</font> <br> <font color="#0000ff">select</font> attr_id, start_date, end_date <br> <font color="#0000ff">from</font> attributes <br> <font color="#0000ff">where</font> attr_id &gt; i_attr_from; <br> <br> <font color="#0000ff">declare</font> <font color="#0000ff">continue</font> handler <font color="#0000ff">for</font> <font color="#0000ff">not</font> <font color="#0000ff">found</font> <font color="#0000ff">set</font> ex_no_records_found = 1; <br> <font color="#0000ff">declare</font> <font color="#0000ff">continue</font> handler <font color="#0000ff">for</font> <font color="#0000ff">sqlstate</font> <font color="#A31515">'42S01'</font> <font color="#0000ff">begin</font> <br> <font color="#0000ff">end</font> ; <br> <br> <font color="#0000ff">create</font> <font color="#0000ff">temporary</font> <font color="#0000ff">table</font> <font color="#0000ff">if</font> <font color="#0000ff">not</font> <font color="#0000ff">exists</font> temp_big_table_results( <br> attr_attr_id <font color="#0000ff">int</font> (10) unsigned, <br> max_record_date    datetime, <br> min_record_date    datetime, <br> max_record_value <font color="#0000ff">varchar</font> (128), <br> cnt <font color="#0000ff">int</font> (10) <br> ) <br> engine = innodb; <br> <font color="#0000ff">truncate</font> <font color="#0000ff">table</font> temp_big_table_results; <br> <br> <font color="#0000ff">open</font> attr; <br> <br> repeat <br> <font color="#0000ff">fetch</font> attr <br> <font color="#0000ff">into</font> v_attr_id, v_start_date, v_end_date; <br> <br> <font color="#0000ff">if</font> <font color="#0000ff">not</font> ex_no_records_found <font color="#0000ff">then</font> <br> <font color="#0000ff">insert</font> <font color="#0000ff">into</font> temp_big_table_results(attr_attr_id, <br> max_record_date, <br> min_record_date, <br> max_record_value, <br> cnt <br> ) <br> <font color="#0000ff">select</font> attr_attr_id, <br> <font color="#0000ff">max</font> (record_date) max_record_date, <br> <font color="#0000ff">min</font> (record_date) min_record_date, <br> <font color="#0000ff">max</font> (record_value) max_record_value, <br> <font color="#0000ff">count</font> (1) cnt <br> <font color="#0000ff">from</font> big_table b <br> <font color="#0000ff">where</font> attr_attr_id = v_attr_id <font color="#0000ff">and</font> record_date <font color="#0000ff">between</font> v_start_date <font color="#0000ff">and</font> v_end_date <br> <font color="#0000ff">group</font> <font color="#0000ff">by</font> attr_attr_id; <br> <font color="#0000ff">end</font> <font color="#0000ff">if</font> ; <br> until ex_no_records_found <br> <font color="#0000ff">end</font> repeat; <br> <br> <font color="#0000ff">close</font> attr; <br> <br> <font color="#0000ff">select</font> attr_attr_id, <br> max_record_date, <br> min_record_date, <br> max_record_value, <br> cnt <br> <font color="#0000ff">from</font> temp_big_table_results; <br> <font color="#0000ff">end</font> <br> $$ <br> delimiter ;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Those.  at the beginning we open the cursor on five hundred entries of the attribute table, and for each row of this table we make a query from <b>big_table</b> .  Let's look at the result: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">call</font> get_big_table_data(0);</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  Runtime: <b>0: 00: 05.017</b> IMHO the result is much better.  Not perfect, but it works. <br>  Now we can consider the opposite example, when the search is performed not in the ‚Äútransactions‚Äù table, but vice versa in the fact table. <br><br><h5>  Now let's look at the <a href="http://bugs.mysql.com/bug.php%3Fid%3D8113">bugs.mysql.com/bug.php?id=8113</a> bug </h5><br><br>  This bug occurs if you: <br>  - working with the base GeoIP <br>  - trying to analyze the schedule <br>  - fix currency rates on Forex <br>  - calculate the city according to the operator's number capacity <br>  etc. <br>  First, create a test data set of 25 million rows. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> big_range_table; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> big_range_table(rtbl_id <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> auto_increment, value_from <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, value_to <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, range_value <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">128</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> pk_big_range_table primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>(rtbl_id) ) <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">innodb</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> big_range_table(value_from, value_to, range_value) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> @row_number := @row_number + <span class="hljs-number"><span class="hljs-number">1</span></span>, @row_number + <span class="hljs-number"><span class="hljs-number">1</span></span>, p1.row_number + p2.row_number + p3.row_number <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> row_number &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>) p1, <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> p2, <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> p3, (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> @row_number := <span class="hljs-number"><span class="hljs-number">0</span></span>) counter; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> idx_big_range_table_from_to <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> big_range_table(value_from, value_to); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> idx_big_range_table_from <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> big_range_table(value_from);</code> </pre> <br>  Get a table of the form <br><table><tbody><tr><td>  rtbl_id </td><td>  value_from </td><td>  value_to </td><td>  range_value </td></tr><tr><td>  one </td><td>  one </td><td>  2 </td><td>  3 </td></tr><tr><td>  2 </td><td>  2 </td><td>  3 </td><td>  four </td></tr><tr><td>  3 </td><td>  3 </td><td>  four </td><td>  five </td></tr></tbody></table><br>  And on the move we will try to execute a query that is successfully optimized by all DBMSs except for MySQL: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> range_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> big_range_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-number"><span class="hljs-number">10000000.5</span></span> &gt;= value_from <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">10000000.5</span></span> &lt; value_to;</code> </pre> <br>  Execution time: <b>0: 00: 22.412</b> .  Generally not an option given the fact that we know that such a request should return one unique string.  And the higher the value of the variable you select - the more records will be scanned, the query runtime grows exponentially. <br>  MySQL itself to solve this problem offers the following workaround: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> range_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> big_range_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> value_from &lt;= <span class="hljs-number"><span class="hljs-number">25000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> value_from <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Execution time: <b>0: 00: 00.350</b> .  Not bad.  But this solution has several drawbacks, in particular, you will not be able to join with other tables.  Those.  This query can only exist atomically.  To enable joins, use the standard RTree index solution (unless, of course, your directory does not need transactions or you ensure its integrity with triggers, since this type of indexes still works only for MyISAM).  For those who do not know what geometric objects in MySQL will give an illustration of what they usually do in such cases: <br><img src="http://habrastorage.org/storage1/eb5b4e23/1fd3e67b/8738daee/ccfc2f40.png"><br>  Imagine a plane.  On the x-axis will be our search values.  The ordinate of your point is equal to zero, since in this particular case, for simplicity, we will search <b>between</b> only for one criterion.  If more criteria are needed, use multidimensional objects.  As the boundaries of the rectangle a and b usually use 1 and -1, respectively.  Thus, the values ‚Äã‚Äãfrom our directory will cover the beam going out from 0. They will also be limited by the set of shaded rectangles.  If the point belongs to the given rectangle, then the identifier of this rectangle gives us the required identifier of the entry in the table.  Run the transformation: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> big_range_table <span class="hljs-keyword"><span class="hljs-keyword">engine</span></span> = myisam, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> polygon_value polygon <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> big_range_table <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> polygon_value = geomfromwkb(polygon(linestring( <span class="hljs-comment"><span class="hljs-comment">/*    ,          */</span></span> point(value_from, <span class="hljs-number"><span class="hljs-number">-1</span></span>), <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> point(value_to, <span class="hljs-number"><span class="hljs-number">-1</span></span>), <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> point(value_to, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> point(value_from, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> point(value_from, <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> )));</code> </pre> <br>  For those who ventured to do this operation with me - monitor the end time <b>update</b> . <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">first_value</span></span> := variable_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> information_schema.global_status <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> variable_name = <span class="hljs-string"><span class="hljs-string">'HANDLER_UPDATE'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) lets_sleep, (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> @second_value := variable_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> information_schema.global_status <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> variable_name = <span class="hljs-string"><span class="hljs-string">'HANDLER_UPDATE'</span></span>) updated_in_a_ten_second, @second_value - @<span class="hljs-keyword"><span class="hljs-keyword">first_value</span></span> myisam_updated_records, <span class="hljs-number"><span class="hljs-number">25000000</span></span> / (@second_value - @<span class="hljs-keyword"><span class="hljs-keyword">first_value</span></span>) / <span class="hljs-number"><span class="hljs-number">6</span></span> estimate_for_update_in_minutes, (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">25000000</span></span> / (@second_value - @<span class="hljs-keyword"><span class="hljs-keyword">first_value</span></span>) / <span class="hljs-number"><span class="hljs-number">6</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> / <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> information_schema.processlist <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'update big_range_table%'</span></span>) estimate_time_left_in_minutes;</code> </pre> <br>  If you have reached this step - I advise you not to do it, because if the database settings are incorrect, the creation of this index can be delayed for a week. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> spatial <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> idx_big_range_table_polygon_value <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> big_range_table(polygon_value);</code> </pre> <br>  Well now you can compare the speed of work.  For a start, let's look at the speed of the initial version of the query and the "geometric" gradually increasing the value of the <b>limit</b> from 10 to 100. <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number * <span class="hljs-number"><span class="hljs-number">5000</span></span> row_number <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> row_number <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>) p, big_range_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> mbrcontains(polygon_value, pointfromwkb(point(row_number, <span class="hljs-number"><span class="hljs-number">0</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> row_number &lt; value_to; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number * <span class="hljs-number"><span class="hljs-number">5000</span></span> row_number <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pivot</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> row_number <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>) p, big_range_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> value_from &lt;= row_number <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> row_number &lt; value_to;</code> </pre><br><img src="http://habrastorage.org/storage1/a7f23d44/c079d513/4f17e36b/12ef626e.png"><br>  On the left - time, below - the limit value.  As can be seen from the figure, the time between (blue) grows exponentially depending on whether we are at the beginning or closer to the end, since for each succeeding value of the variable band we need to scan more and more lines.  The ‚Äúgeometric‚Äù solution (pink) on such small values ‚Äã‚Äãis just a constant. <br>  Let's try to compare <b>order by limit 1</b> and <b>geometry</b> for larger values.  To do this, we use the procedures to create equal conditions and conduct a random sample. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">drop</font> <font color="#0000ff">procedure</font> <font color="#0000ff">if</font> <font color="#0000ff">exists</font> pbenchmark_mbrcontains; <br> delimiter $$ <br> <font color="#0000ff">create</font> <font color="#0000ff">procedure</font> pbenchmark_mbrcontains(i_repeat_count <font color="#0000ff">int</font> (10)) <br> main_sql: <br> <font color="#0000ff">begin</font> <br> <font color="#0000ff">declare</font> v_random <font color="#0000ff">int</font> (10); <br> <font color="#0000ff">declare</font> v_range_value <font color="#0000ff">int</font> (10); <br> <font color="#0000ff">declare</font> v_loop_counter <font color="#0000ff">int</font> (10) unsigned <font color="#0000ff">default</font> 0; <br> <br> begin_loop: <br> loop <br> <font color="#0000ff">set</font> v_loop_counter  = v_loop_counter + 1; <br> <br> <font color="#0000ff">if</font> v_loop_counter &lt; i_repeat_count <font color="#0000ff">then</font> <br> <font color="#0000ff">set</font> v_random = round(2500000 * rand()); <br> <font color="#0000ff">select</font> range_value <br> <font color="#0000ff">into</font> v_range_value <br> <font color="#0000ff">from</font> big_range_table <br> <font color="#0000ff">where</font> mbrcontains(polygon_value, pointfromwkb(point(v_random, 0))) <font color="#0000ff">and</font> v_random &lt; value_to; <br> <font color="#0000ff">iterate</font> begin_loop; <br> <font color="#0000ff">end</font> <font color="#0000ff">if</font> ; <br> <br> leave begin_loop; <br> <font color="#0000ff">end</font> loop begin_loop; <br> <br> <font color="#0000ff">select</font> v_loop_counter; <br> <font color="#0000ff">end</font> <br> $$ <br> delimiter ; <br> <br> <font color="#0000ff">drop</font> <font color="#0000ff">procedure</font> <font color="#0000ff">if</font> <font color="#0000ff">exists</font> pbenchmark_limit; <br> delimiter $$ <br> <font color="#0000ff">create</font> <font color="#0000ff">procedure</font> pbenchmark_limit(i_repeat_count <font color="#0000ff">int</font> (10)) <br> main_sql: <br> <font color="#0000ff">begin</font> <br> <font color="#0000ff">declare</font> v_random <font color="#0000ff">int</font> (10); <br> <font color="#0000ff">declare</font> v_range_value <font color="#0000ff">int</font> (10); <br> <font color="#0000ff">declare</font> v_loop_counter <font color="#0000ff">int</font> (10) unsigned <font color="#0000ff">default</font> 0; <br> <br> begin_loop: <br> loop <br> <font color="#0000ff">set</font> v_loop_counter  = v_loop_counter + 1; <br> <br> <font color="#0000ff">if</font> v_loop_counter &lt; i_repeat_count <font color="#0000ff">then</font> <br> <font color="#0000ff">set</font> v_random = round(2500000 * rand()); <br> <font color="#0000ff">select</font> range_value <br> <font color="#0000ff">into</font> v_range_value <br> <font color="#0000ff">from</font> big_range_table <br> <font color="#0000ff">where</font> value_from &lt;= v_random <font color="#0000ff">order</font> <font color="#0000ff">by</font> value_from <font color="#0000ff">desc</font> <font color="#0000ff">limit</font> 1; <br> <font color="#0000ff">iterate</font> begin_loop; <br> <font color="#0000ff">end</font> <font color="#0000ff">if</font> ; <br> <br> leave begin_loop; <br> <font color="#0000ff">end</font> loop begin_loop; <br> <br> <font color="#0000ff">select</font> v_loop_counter; <br> <font color="#0000ff">end</font> <br> $$ <br> delimiter ;</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><img src="http://habrastorage.org/storage1/38035a83/50a0bf0e/8f6d40cc/d2783ffb.png"><br>  On the graph, we see the result of a consistent increase in the number of runs of procedures from 10,000 to 90,000 and the number of seconds spent on the corresponding operations.  As you can see, the ‚Äúgeometric‚Äù solution (pink) is 2 times faster than the solution using <b>order by limit 1</b> (yellow) and in addition, this solution can be applied in standard SQL. <br><br>  I covered the topic, solely because these shoals are not visible on small amounts of data, but when the database grows and more than 10 users live on it, the performance degradation becomes monstrous, and these types of queries can be found in almost every industrial database. <br>  Successful to you optimizations.  If this article will be interesting next time I will tell about the bugs that not only do not interfere with life, but even vice versa - increase the performance of requests, if used correctly. <br><br>  <i>ZY</i> <i><br></i>  <i>MySQL version 5.5.11</i> <i><br></i>  <i>All queries were performed after restarting MySQL to exclude getting into the cache results.</i> <i><br></i>  <i>MySQL settings are far from standard, but the size of innodb buffers does not exceed 300 Mb, the size of MyISAM buffers (with the exception of the moment the index is created) does not exceed 100Mb.</i> <i><br></i>  <i>sizes of files used:</i> <i><br></i>  <i>big_range_table.ibd 1740M</i> <i><br></i>  <i>big_table.ibd 5520M - without indexes</i> <i><br></i>  <i>big_table.ibd 8268M - with indexes</i> <i><br></i>  <i>those.</i>  <i>hit of objects in a cache of a DB before the beginning of request is completely excluded.</i> </div><p>Source: <a href="https://habr.com/ru/post/125467/">https://habr.com/ru/post/125467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125462/index.html">Problems of the organization of the work process in the IT environment</a></li>
<li><a href="../125463/index.html">Symfony2 Book in pdf format</a></li>
<li><a href="../125464/index.html">Search service for Russian books for Kindle</a></li>
<li><a href="../125465/index.html">Statusboard.me announced beta testing</a></li>
<li><a href="../125466/index.html">REG.RU opens privileged club</a></li>
<li><a href="../125469/index.html">Introduction to symfony 2</a></li>
<li><a href="../125470/index.html">How to save on software</a></li>
<li><a href="../125471/index.html">Free market niche = profitability of a business on it?</a></li>
<li><a href="../125473/index.html">In October, will begin voluntary certification of online stores</a></li>
<li><a href="../125482/index.html">Euclideon software ray tracing technology</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>