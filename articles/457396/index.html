<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic unlocking of the root LUKS container after a hot reboot</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why do people encrypt the disks of their personal computers, and sometimes - the servers? It is clear that no one steals from the disk photos of their...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic unlocking of the root LUKS container after a hot reboot</h1><div class="post__text post__text-html js-mediator-article"><p>  Why do people encrypt the disks of their personal computers, and sometimes - the servers?  It is clear that no one steals from the disk photos of their favorite pet cats!  But that's bad luck: an encrypted disk requires a key phrase to be entered from the keyboard at each boot, and it is long and boring.  Remove it to at least sometimes not have to recruit it.  So much so that the meaning of the encryption is not lost. </p><br><div class="spoiler">  <b class="spoiler_title">Cat to attract attention</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Cat"></p></div></div><br><p>  Well, completely remove it will not work.  You can instead make a key file on a flash drive, and it will also work.  And without a flash drive (and without a second computer on the network) is it possible?  If lucky with the BIOS, almost possible!  Under the cut there will be a guide on how to configure disk encryption via LUKS with such properties: </p><br><ol><li>  The key phrase or key file is not stored anywhere in the open form (or in the form equivalent to the open one) when the computer is turned off. </li><li>  When you first turn on the computer, you must enter a passphrase. </li><li>  On subsequent reboots (before shutdown), the key phrase is not required. </li></ol><br><p>  The instructions were tested on CentOS 7.6, Ubuntu 19.04 and openSUSE Leap 15.1 in virtual machines and on real hardware (desktop, laptop and two servers).  They should work on other distributions that have a workable version of Dracut. </p><br><p>  And yes, in an amicable way, this would have to fall into the "abnormal system administration" hub, but there is no such hub. </p><a name="habracut"></a><br><p>  I propose to use a separate slot of the LUKS container and store the key of it ... in RAM! </p><br><div class="spoiler">  <b class="spoiler_title">What kind of slot?</b> <div class="spoiler_text"><p> LUKS container implements multi-level encryption.  The payload on the disk is encrypted with a symmetric cipher, usually <code>aes-xts-plain64</code> .  The key from this symmetric cipher (master key) is generated during the creation of the container as a random sequence of bytes.  The master key is stored in encrypted form, in general - in multiple copies (slots).  By default, only one of the eight slots is active.  Each active slot has a separate key phrase (or a separate key file) with which you can decrypt the master key.  From the user's point of view, it turns out that you can unlock a disk using any of several different key phrases (or key files).  In our case, using a key phrase (slot 0) or using a memory location used as a key file (slot 6). </p></div></div><br><p>  The BIOS on most motherboards does not clean the memory when rebooting, or you can configure it so that it does not clean (known exception: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 01/30/2019").  Therefore, you can store a key there.  When you turn off the power, the contents of the RAM itself are erased after some time, along with an unprotected copy of the key. </p><br><p>  So let's go. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Step one: install the system on a disk encrypted using LUKS </h3><br><p>  At the same time, the disk partition (for example, <code>/dev/sda1</code> ), mounted in <code>/boot</code> , should remain unencrypted, and another partition, which will contain everything else (for example, <code>/dev/sda2</code> ), should be encrypted.  The file system on the encrypted partition can be any, you can still use LVM, so that in one container were the root file system, the volume for the swap, and everything else except <code>/boot</code> .  This corresponds to the default disk partitioning in CentOS 7 and in Debian when choosing the encryption option.  SUSE does things differently (encrypts <code>/boot</code> ) and therefore requires manual disk partitioning. </p><br><p>  As a result, you should get something like this: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ‚îú‚îÄsda1 8:1 0 1G 0 part /boot ‚îî‚îÄsda2 8:2 0 9G 0 part ‚îî‚îÄluks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ‚îú‚îÄcentos_centos--encrypt2-root 253:1 0 8G 0 lvm / ‚îî‚îÄcentos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  In the case of using UEFI there will be another EFI System Partition section. </p><br><blockquote>  For Debian and Ubuntu users: the <code>initramfs-tools</code> package must be replaced with a <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  The <code>initramfs-tools</code> implemented incorrect in our case the logic applied to the encrypted sections with the key file.  Such sections are either completely ignored, or the contents of the key file are copied to the initramfs (that is, to the disk) in the open form, which we do not need. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Step two: create a key file that will be used to automatically unlock the disk after a hot reboot </h3><br><p>  128 random bits are enough for us, i.e.  16 bytes  The file will be stored on an encrypted disk, so no one who knows the encryption key and does not have root access to the loaded system will not read it. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  In a key file, truly random bits are enough for the slow PBKDF algorithm, which makes a hard-to-choose encryption key out of a potentially weak key phrase, not really needed.  Therefore, when adding a key, you can reduce the number of iterations: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  As you can see, the key file is stored on an encrypted disk and therefore does not pose any security threat if the computer is turned off. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Step three: allocate space in physical memory to store the key </h3><br><p>  Linux has at least three different drivers that allow access to physical memory at a known address.  These are <code>linux/drivers/char/mem.c</code> , which is also responsible for the <code>/dev/mem</code> device, as well as the <code>phram</code> modules (emulates an MTD chip, gives the <code>/dev/mtd0</code> ) and <code>nd_e820</code> (used when working with NVDIMM, gives <code>/dev/pmem0</code> ).  They all have their unpleasant features: </p><br><ul><li>  <code>/dev/mem</code> not writable when using Secure Boot if the distribution has applied the <a href="https://lwn.net/Articles/784674/">LOCKDOWN patch set</a> from Matthew Garrett (and this patch set is required if the distribution is going to support Secure Boot with a Microsoft-signed bootloader); </li><li>  <code>phram</code> not available on CentOS and Fedora - the maintainer simply did not <code>phram</code> on the appropriate option when building the kernel; </li><li>  <code>nd_e820</code> requires you to reserve at least 128 megabytes of memory - this is how NVDIMM works.  But this is the only option that runs on CentOS with Secure Boot. </li></ul><br><p>  Since there is no ideal option, then all three are considered. </p><br><blockquote>  When using any of the methods, utmost care is needed in order not to accidentally touch devices other than the required range.  This is especially true of computers that already have MTD chips or NVDIMM modules.  Namely, <code>/dev/mtd0</code> or <code>/dev/pmem0</code> may not be the device that corresponds to the memory section reserved for key storage.  Also, the numbering of existing devices, on which the configuration files and scripts rely, may be lost.  Accordingly, all services relying on existing devices <code>/dev/mtd*</code> and <code>/dev/pmem*</code> are recommended to be temporarily disabled. </blockquote><p>  Linux <code>memmap</code> physical memory is done by passing the <code>memmap</code> option to the <code>memmap</code> .  We are interested in two types of this option: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> reserves (i.e., marks as reserved so that the kernel itself does not use) 4 kilobytes of memory, starting with the physical address 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> marks 128 megabytes of physical memory, starting at address 0x10000000, as NVDIMM (obviously fake, but we can do that too). </li></ul><br><p>  The version with <code>$</code> is suitable for use with <code>/dev/mem</code> and <code>phram</code> , the option with <code>!</code>  - for <code>nd_e820</code> .  When using <code>$</code> starting address of the reserved memory area must be a multiple of <code>0x1000</code> (i.e. 4 kilobytes), when used <code>!</code>  - multiples of <code>0x8000000</code> (i.e. 128 megabytes). </p><br><p>  Important: the dollar sign ( <code>$</code> ) in the GRUB configuration files is a special character and must be escaped.  And double: once - when generating <code>grub.cfg</code> from <code>/etc/default/grub</code> , a second time - when interpreting the resulting configuration file at boot time.  Those.  In <code>/etc/default/grub</code> following line should appear: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Without double escaping the <code>$</code> sign, the system will simply not load, as it will think that it has only 4 kilobytes of memory.  With an exclamation mark, there are no such difficulties: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  A physical memory card (which is needed to find out which addresses to back up) is available to the <code>root</code> in the <code>/proc/iomem</code> pseudo <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  RAM is marked as "System RAM", we just need to reserve one of its page for storing the key.  Guess what part of the BIOS memory does not touch when rebooting, it will not work reliably in advance.  Is that if there is another computer with the exact same BIOS version and the same memory configuration, on which this manual has already been passed.  Therefore, in general, will have to act by trial and error.  As a rule, the BIOS changes the data only at the beginning and at the end of each memory range upon reboot.  Usually it is enough to retreat 128 megabytes ( <code>0x8000000</code> ) from the edges.  For KVM virtual machines with 1 GB of memory or more, the suggested options ( <code>memmap=4K$0x10000000</code> and <code>memmap=128M!0x10000000</code> ) work. </p><br><p>  When using the <code>phram</code> module, another kernel command line parameter is needed, which, in fact, indicates to the module which piece of physical memory to use ‚Äî ours, reserved.  The parameter is called <code>phram.phram</code> and contains three parts: the name (arbitrary up to 63 characters, will be visible in <code>sysfs</code> ), the starting address and the length.  The starting address and length should be the same as in <code>memmap</code> , but the <code>K</code> and <code>M</code> suffixes are not supported. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  After editing <code>/etc/default/grub</code> you need to regenerate the actual configuration file that GRUB reads on boot.  The correct command for this depends on the distribution. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  After updating the GRUB configuration, the computer should be restarted, but we will do this later when we update the initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Step four: configure LUKS to read the key from memory </h3><br><p>  Disk encryption settings are stored in the <code>/etc/crypttab</code> .  Each line consists of four fields: </p><br><ul><li>  a device that should turn out when unlocking, </li><li>  encrypted device </li><li>  where to get the key file ( <code>none</code> means entering the key phrase from the keyboard), </li><li>  optional field for options. </li></ul><br><p>  If the key file exists, but does not fit, then Dracut asks for a key phrase.  What, in fact, will be required when you first boot. </p><br><p>  An example of the <code>/etc/crypttab</code> from the newly installed distribution: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  The key file in our case is a piece of physical memory.  Those.  <code>/dev/mem</code> , <code>/dev/mtd0</code> or <code>/dev/pmem0</code> , depending on the selected memory access technology.  Options are needed to indicate which piece of the file is the key. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  That's just just because it will not work. </p><br><p>  The point is how systemd determines when to unlock a device.  Namely, it takes the device from the third column and waits for the corresponding device unit to become active.  It seems logical: it makes no sense to try to unlock the LUKS container until a device with a key file appears.  But the device unit is not the same as the device itself.  Systemd defaults to device units only for kernel devices related to block device subsystems and network interfaces.  The devices <code>/dev/mem</code> and <code>/dev/mtd0</code> are character-based, so they are not monitored by default and will never be declared ready. </p><br><p>  We'll have to tell systemd to monitor them by creating udev rules in the <code>/etc/udev/rules.d/99-mem.rules</code> file: </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Step Five: regenerate the initramfs </h3><br><blockquote>  I remind you: the article discusses only distributions using Dracut.  Including those where it is not used by default, but is available and workable. </blockquote><p>  You need to regenerate the initramfs in order to update the <code>/etc/crypttab</code> file there.  And also to include additional kernel modules and udev rules.  Otherwise, the device <code>/dev/mtd0</code> or <code>/dev/pmem0</code> will not be created.  The configuration parameter Dracut <code>force_drivers</code> is responsible for including and loading additional kernel modules, and <code>install_items</code> for additional files.  Create the file <code>/etc/dracut.conf.d/mem.conf</code> with the following contents (a space after the opening quotation mark is required, this is a separator): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Actually initramfs regeneration: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Debian and Ubuntu users have a rake for the maintainer: the resulting file is not named correctly.  You need to rename it so that it will be called in the same way as specified in the GRUB configuration: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  When installing new kernels, the automatic creation of initramfs through Dracut is performed correctly, the bug only affects the manual launch of <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Step Six: Restart Computer </h3><br><p>  A reboot is needed for changes in the GRUB and Dracut configuration to take effect. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  At this stage there is no key in the memory, so you will need to enter a key phrase. </p><br><p>  After the reboot, you need to check whether the memory reservation worked correctly.  At a minimum, in the <code>/proc/iomem</code> pseudo <code>/proc/iomem</code> required memory should be marked as "reserved" (when using <code>/dev/mem</code> or <code>phram</code> ) or as "Persistent Memory (legacy)". </p><br><p>  Even when using <code>phram</code> or <code>nd_e820</code> you need to make sure that the device <code>/dev/mtd0</code> or <code>/dev/pmem0</code> really refers to a previously reserved area of ‚Äã‚Äãmemory, and not to something else. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  If this is not the case, you need to find out which of the <code>/dev/mtd*</code> or <code>/dev/pmem*</code> "ours" devices, then fix / etc / crypttab, regenerate the initramfs and recheck the result after another reboot. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  Step Seven: set up copying key file to memory </h3><br><p>  The key file will be copied to memory before rebooting.  One way to run any command at the system shutdown stage is to write it in the <code>ExecStop</code> directive in the systemd-service.  In order for systemd to understand that this is not a daemon and did not swear at the absence of the <code>ExecStart</code> directive, you need to specify the type of service as <code>oneshot</code> and also suggest that the service is considered to be running, even if no running process is associated with it.  So here‚Äôs the <code>/etc/systemd/system/savekey.service</code> file.  It is necessary to leave only one of the above options for the <code>ExecStop</code> directive. </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  The construct with <code>/bin/sh</code> needed because <code>dd</code> does not understand hexadecimal notation. </p><br><p>  We activate the service, check: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  When the next reboot, you do not have to enter a key phrase from the disk.  And if it is necessary, it usually means that the address of the beginning of the reserved memory area is selected incorrectly.  It's okay to fix and regenerate several files and restart the computer two times. </p><br><p>  When using <code>phram</code> or <code>nd_e820</code> only have to edit the GRUB configuration.  When using <code>/dev/mem</code> starting address is also mentioned in <code>/etc/crypttab</code> (so you need to regenerate the initramfs) and in the systemd-service. </p><br><p>  But that is not all. </p><br><h3 id="voprosy-bezopasnosti">  Security questions </h3><br><p>  Any discussion of security issues is based on the threat model.  Those.  on the targets and means of the attacker.  I am aware that some of the examples below are contrived. </p><br><p>  Situations with physical access to a computer that is turned off are no different from those without configured key storage in memory.  There are the same types of attacks aimed at obtaining a key phrase, including <a href="https://habr.com/ru/post/259781/">Evil Maid</a> , and the same <a href="https://habr.com/ru/post/308032/">defenses</a> .  We don‚Äôt stop at them, because there is nothing new here. </p><br><p>  More interesting are situations when the computer is turned on. </p><br><p>  <strong>Situation 1</strong> .  The attacker does not have physical access to the computer, does not know the key phrase, but has root access via ssh.  The goal is the key to decrypt the disk.  For example, to access old sector-based backups of a disk image of a virtual machine. </p><br><p>  Actually, the key on a saucer is in the file <code>/root/key</code> .  The question is how does this relate to what was before the execution of this instruction.  Answer: for luks1, the threat is not new.  There is a command <code>dmsetup table --target crypt --showkeys</code> , which shows the master key, i.e.  also data allowing access to old backups.  For luks2, security degradation in this scenario does take place: dm-crypt keys are stored in a keychain at the kernel level, and it‚Äôs impossible to look at them from userspace. </p><br><p>  <strong>Situation 2</strong> .  The attacker can use the keyboard and look at the screen, but is not ready to open the case.  For example, I used a leaked IPMI password or intercepted a noVNC session in the cloud.  The key phrase does not know, no other passwords also know.  The goal is root access. </p><br><p>  Please: reboot via <code>Ctrl-Alt-Del</code> , add kernel option <code>init=/bin/sh</code> via GRUB, ready.  The key phrase was not needed because the key was successfully read from memory.  In order to protect against this, it would be necessary to prohibit GRUB from loading something that is not in the menu.  Unfortunately, this functionality is implemented in different distributions in different ways. </p><br><p>  In CentOS, starting with version 7.2, there is the <code>grub2-setpassword</code> , which actually protects GRUB with a password.  Other distributions may have their own utilities for the same task.  If not, then you can directly edit the files in the <code>/etc/grub.d</code> directory and regenerate <code>grub.cfg</code> . </p><br><p>  In the <code>/etc/grub.d/10_linux</code> file, change the CLASS variable, add the <code>--unrestricted</code> option to the end, if it was not there: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  In the <code>/etc/grub.d/40_custom</code> file, add lines that specify the username and password that are needed to edit the kernel command line: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Or, if this functionality needs to be disabled at all, here‚Äôs the line: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situation 3</strong> .  The attacker has access to the computer being turned on, allowing it to boot from untrusted media.  It can be physical access without opening the case or access via IPMI.  The goal is root access. </p><br><p>  It can load your GRUB from a flash drive or CD-ROM and add <code>init=/bin/sh</code> to the parameters of your kernel, as in the previous example.  Accordingly, it is necessary to prohibit the loading of media from any media in the BIOS.  And also protect changing the BIOS settings with a password. </p><br><p>  <strong>Situation 4</strong> .  The attacker has physical access to the computer, including the case can open.  The goal is to find out the key or get root access. </p><br><p>  In general, this is a losing situation in any case.  The attack on the memory modules by cooling them ( <a href="https://ru.wikipedia.org/wiki/Cold_boot_attack">Cold boot attack</a> ) has not been canceled.  Also theoretically (not tested) you can take advantage of the fact that modern SATA drives support hot reconnection.  When you restart your computer, disconnect the disk, change <code>grub.cfg</code> for <code>init=/bin/sh</code> , connect it back, let the system reboot.  It will turn out (if I understand correctly) root access. </p><br><p>  Approximately the same thing can turn a dishonest employee of cloud hosting by making snapshot of a virtual machine with its subsequent modification. </p><br><h3 id="prochie-voprosy">  Other matters </h3><br><p>  <strong>Keeping the key in memory when rebooting is a mockery.</strong>  <strong>Use-after-free in its pure form.</strong>  <strong>A cleaner solution is to use kexec and put the key into dynamically generated initramfs.</strong>  <strong>It also protects against replacing kernel parameters</strong> .  Yes, this is true if kexec works.  Modern distributions have made kexec setup <a href="https://patrakov.blogspot.com/2019/06/kexec-on-modern-distributions.html">too complicated</a> . </p><br><p>  <strong>In data centers and even more so in the cloud, the power never disappears.</strong>  <strong>So, the key phrase is no longer needed?</strong>  Indeed, <em>if</em> you are so sure of it, you can remove it.  A working server will turn out, the key from the disk of which no one knows and therefore will not issue, but the system on which it is possible to update the standard means.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if necessary - quickly destroy all data easily remembered command </font></font><code>sudo poweroff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If I haven‚Äôt looked in </font></font><code>/root/key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- but there is still an abracadabra not typed from the keyboard, which can also be changed by cron.</font></font></p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is all this necessary? </font><font style="vertical-align: inherit;">There is an IPMI where I can enter the password from the disk</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">On older servers, IPMI only works through older versions of Java. </font><font style="vertical-align: inherit;">I would not want to go there for every reboot.</font></font></p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is all this necessary? </font><font style="vertical-align: inherit;">I can unlock the drive </font></font><a href="https://github.com/dracut-crypt-ssh/dracut-crypt-ssh"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via SSH</font></font></a></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Perfectly!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It does not interfere. </font><font style="vertical-align: inherit;">But what if you need to issue rights to a </font></font><code>sudo reboot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user who does not deserve knowledge of the key phrase?</font></font></p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/457396/">https://habr.com/ru/post/457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457380/index.html">Super modern OpenGL. Part 2</a></li>
<li><a href="../457382/index.html">7 habits of highly efficient programmers</a></li>
<li><a href="../457386/index.html">Understanding Linux Virtual Interfaces: Tunnels</a></li>
<li><a href="../45739/index.html">Openit.com.ua [Not] v_kkrita kraina</a></li>
<li><a href="../457392/index.html">Saving on mobile cross-platform development: Skyeng case</a></li>
<li><a href="../457398/index.html">Am I not doing bullshit? Why do developers go to gemba</a></li>
<li><a href="../4574/index.html">SchoolZhizni.ru - social network of journalists and critics</a></li>
<li><a href="../45740/index.html">TeamCity 4.0 released</a></li>
<li><a href="../457400/index.html">The number of victims in Chernobyl-type nuclear disasters is greatly exaggerated for drama.</a></li>
<li><a href="../457402/index.html">How to organize the development and support of a blog on WordPress in 2Q19 and not to fix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>