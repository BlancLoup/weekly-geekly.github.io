<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Differential Cryptanalysis for Dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The FEAL code has the same level of durability as DES. Moreover, the increased key length (64 bits compared to 56 bits in DES) makes it difficult to i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Differential Cryptanalysis for Dummies</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c6/02b/630/6c602b6302ace732f9e3547627384473.jpg" alt="image"></div><br><blockquote>  The FEAL code has the same level of durability as DES.  Moreover, the increased key length (64 bits compared to 56 bits in DES) makes it difficult to iterate.  The code number FEAL has a good distribution of ciphertexts, close to random.  And this also speaks in favor of FEAL compared to DES. </blockquote>  This is a summary of the FEAL encryption algorithm specification published in 1987. <br><br>  Nothing is eternal under the Moon.  In this topic, I will tell you how, with only 40 pairs of open-closed texts, get the full key of FEAL4 in a few minutes. <a name="habracut"></a><br><br><h4>  Differential Cryptanalysis </h4><br>  To begin with, let’s see what is hidden under the name “Differential cryptanalysis” that caresses the Russian ear. <br>  Differential cryptanalysis is an attack with selected plaintext.  This means that in order to use DK, you must be able to encrypt absolutely any text in absolutely any quantity. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The goal of an attacker using DCs is to get some information about the key, which can completely compromise the key (which is very rare) and simply give some advantage when selecting the key. <br><br>  It all works as follows.  For two pre-selected ciphertexts P <sub>1</sub> and P <sub>2, the</sub> attacker calculates the “differential” ΔP = P <sub>1</sub> ⊕P <sub>2</sub> .  And using ΔP, it tries to determine what the “differential” of ciphertexts should be ΔC = C <sub>1</sub> C <sub>2</sub> .  It is often impossible to predict with 100% accuracy what exactly will be the value of ΔC.  The only thing an attacker can do is determine at what frequency the cipher returns different ΔC values, for a predetermined ΔP.  This knowledge allows an attacker to open part of the key or the entire key. <br><br>  As an example, consider the three-round block cipher shown in the figure below. <br><img src="https://habrastorage.org/getpro/habr/post_images/eec/c96/5bc/eecc965bc60dc9636e0f278185eb6255.png"><br>  This cipher has 64 bit block size and 128 bit key. <br>  At each round, the input block is divided into 8 bytes, each of which passes through the <b>Sbox</b> substitution <b>function</b> .  After that, the data is mixed with a Subkey 64-bit subkey.  The mixing function is a regular XOR. <br><br>  Suppose that the attacker decided to check the differential 0x80.  To do this, it generates an arbitrary byte X <sub>1</sub> , and calculates X <sub>2</sub> = X <sub>1</sub> ⊕80. <br>  Next, the attacker drives X <sub>1</sub> and X <sub>2</sub> through the Sbox function and gets the values ​​of Y <sub>1</sub> and Y <sub>2</sub> .  For each such pair of X <sub>1</sub> and X <sub>2</sub> , the differential of which is 80, the attacker is able to get the differential ΔY.  Analyzing the values ​​obtained, the attacker chooses a value of ΔY, which has a greater probability of occurrence. <br><br>  Returning to our example, suppose that of all 256 pairs of X <sub>1</sub> and X <sub>2</sub> , in 192 cases Y <sub>1</sub> ⊕ Y <sub>2</sub> = 02.  Thus, the probability that for a given ΔX = 80, the value of ΔY = 02, is 192/256 = 3/4.  This in turn means that for a given ΔX = 80, with a probability P <sub>1</sub> = 3/4, two values ​​of U <sub>1</sub> and U <sub>2</sub> will fall into the input of the second round, such that ΔU = 02. <br>  Note that the key does not in any way affect the value of the differentials.  Since when encrypting different texts, the key does not change and mixing with the key sequence is performed using XOR, when calculating ΔU, the key bytes are mutually exclusive. <br><br>  To reveal the properties of the second round, the attacker generates new 256 pairs of input bytes X <sub>1</sub> and X <sub>2</sub> , such that X <sub>1</sub> ⊕ X <sub>2</sub> = 02.  Having calculated the Sbox function for each pair of X <sub>1</sub> and X <sub>2</sub> , the attacker notices that in 64 cases out of 256 ΔY = 88.  Those.  the probability that ΔY = 88, for a given ΔX = 02, is P <sub>2</sub> = 64/256 = 1/4. <br><br>  Thus, having performed a simple calculation of probabilities, the attacker understands that for the specified cipher for each pair of bytes X <sub>1</sub> and X <sub>2</sub> , such that ΔX = 80, with probability P = P <sub>1</sub> * P <sub>2</sub> = 3/4 * 1/4 = 3 / 16, the differential of the internal state of the cipher before the last round is ΔY = 88. <br><br>  With this knowledge, the attacker generates several pairs of texts such that ΔP = 808080808080 and proceeds to a byte selection of the subkey of the third round. <br>  Let us show how the first byte of the subkey is opened. <br>  For each of the 256 possible variants of the first byte of Subkey [0] and for each pair of ciphertexts {C <sub>1</sub> , C <sub>2</sub> }, the attacker calculates U <sub>1</sub> = Sbox (C <sub>1</sub> ⊕Subkey [0]) and U <sub>2</sub> = Sbox (C <sub>2</sub> ⊕Subkey [0]). <br>  If Subkey [0] is correctly guessed, then approximately 3 out of every 16 pairs of U <sub>1</sub> and U <sub>2</sub> will be 88 when calculating ΔU. <br>  Having picked up the most probable first byte of the Subkey subkey in this way, an attacker can go to the second byte and, in a similar way, open the entire key of the third round. <br><br>  After the key of the last round is revealed, the attacker can launch an attack on the penultimate round and, acting in this way, will eventually receive information on all the round cipher keys. <br><br><h4>  FEAL cipher description </h4><br>  Now consider the cryptoalgorithm with which we will try to perform the actions described above. <br>  So, FEAL4 is a block cipher, with a block size and key length equal to 64 bits. <br>  There are several equivalent descriptions of the FEAL4 algorithm; we will use the most convenient for demonstrating differential cryptanalysis. <br><img src="https://habrastorage.org/getpro/habr/post_images/851/747/52e/85174752ea9134b45e8ed9500df5aa0a.jpg" align="left"><br>  The cipher consists of 4 rounds and uses six 32-bit subkeys generated from the primary key (hereafter, we assume that each subkey is generated independently, thus increasing the threshold in such a way from 2 <sup>64</sup> to 2 <sup>192</sup> ). <br><br>  At the initial stage, the plaintext is divided into two blocks, 32 bits each.  The left and right blocks are folded modulo two with 32-bit subkeys K [4] and K [5], respectively.  Then the left part remains unchanged, and the right is formed by adding modulo two with the left block. <br><br>  After that, 4 rounds of encryption are performed on each of which the right block is modulo-2 summed up with the subkey of the round K [i], and then the result is run through the permutation function F. The result of the permutation is added to the left part of the text.  After these operations, the left and right blocks are reversed and the result is fed to the input of the next round. <br><br>  The last round is a bit different from everyone else.  Left and right blocks do not change places, as in previous rounds. <br>  Instead, the right block is folded modulo two with the left block and the result is returned as the right side of the ciphertext.  The left part after the 4th round remains unchanged and makes up the first 32 bits of the received ciphertext. <br><br>  The original cipher scheme described by the creators was somewhat different from the one above.  Instead of six 32-bit, the original description uses twelve 16-bit subkeys.  However, both options are identical and, if desired, 32-bit keys can be easily represented as 16-bit keys from the original description. <br><br><br><br>  The only white spot in the cipher description is function F. It can be represented in the figure as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba6/2a5/c81/ba62a5c815b0cac769893f8b5639a19d.png" align="left"><br>  At the input, the F function gets 4 bytes X <sub>1</sub> , X <sub>2</sub> , X <sub>3</sub> , X <sub>4</sub> .  Next, the input bytes are mixed and pass through the functions G <sub>0</sub> or G <sub>1</sub> .  The 4 bytes received after calculating the functions G <sub>x</sub> form the 32-bit output sequence of the function F. <br><br>  The G <sub>0</sub> and G <sub>1</sub> functions convert the 16-bit input sequence to an 8-bit result. <br>  The function G <sub>0</sub> can be expressed as follows: <img src="https://habrastorage.org/getpro/habr/post_images/a97/552/c48/a97552c48ea214777322645d0b00a828.png">  where &lt;&lt; is a cyclical shift to the left. <br>  While the function G <sub>1</sub> has the following definition: <img src="https://habrastorage.org/getpro/habr/post_images/efc/c0b/3f1/efcc0b3f124ded24bf1e79ac604d7992.png">  . <br><br>  Decryption of the algorithm occurs on the same principle.  Actually, the ciphertext is divided into left and right blocks and all encryption operations are performed in the reverse order. <br>  Those.  first decryption of the last round, then the last but one, and so on. <br><br><div class="spoiler">  <b class="spoiler_title">FEAL4 implementation in C #</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FEAL4</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((((a + b) % <span class="hljs-number"><span class="hljs-number">256</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) | (((a + b) % <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((((a + b+<span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) | (((a + b+<span class="hljs-number"><span class="hljs-number">1</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; y[<span class="hljs-number"><span class="hljs-number">1</span></span>] = G1((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(x[<span class="hljs-number"><span class="hljs-number">0</span></span>] ^ x[<span class="hljs-number"><span class="hljs-number">1</span></span>]), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(x[<span class="hljs-number"><span class="hljs-number">2</span></span>] ^ x[<span class="hljs-number"><span class="hljs-number">3</span></span>])); y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = G0(x[<span class="hljs-number"><span class="hljs-number">0</span></span>], y[<span class="hljs-number"><span class="hljs-number">1</span></span>]); y[<span class="hljs-number"><span class="hljs-number">2</span></span>] = G0(y[<span class="hljs-number"><span class="hljs-number">1</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(x[<span class="hljs-number"><span class="hljs-number">2</span></span>] ^ x[<span class="hljs-number"><span class="hljs-number">3</span></span>])); y[<span class="hljs-number"><span class="hljs-number">3</span></span>] = G1(y[<span class="hljs-number"><span class="hljs-number">2</span></span>], x[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddKeyPart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] K</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { P[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(P[i] ^ K[i]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XOR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] c=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[a.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; c.Length; i++) { c[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(a[i] ^ b[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encrypt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] K</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] LeftPart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] RightPart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; Array.Copy(P, <span class="hljs-number"><span class="hljs-number">0</span></span>, LeftPart, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); Array.Copy(P, <span class="hljs-number"><span class="hljs-number">4</span></span>, RightPart, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); AddKeyPart(LeftPart, K[<span class="hljs-number"><span class="hljs-number">4</span></span>]); AddKeyPart(RightPart, K[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round2Left = XOR(LeftPart, RightPart); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round2Right = XOR(LeftPart, F(XOR(Round2Left, K[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round3Left = Round2Right; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round3Right = XOR(Round2Left,F(XOR(Round2Right,K[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round4Left = Round3Right; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round4Right = XOR(Round3Left, F(XOR(Round3Right, K[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CipherTextLeft = XOR(Round4Left,F(XOR(Round4Right,K[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CipherTextRight = XOR(Round4Right, CipherTextLeft); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CipherText = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; Array.Copy(CipherTextLeft, <span class="hljs-number"><span class="hljs-number">0</span></span>, CipherText, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); Array.Copy(CipherTextRight, <span class="hljs-number"><span class="hljs-number">0</span></span>, CipherText, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CipherText; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decrypt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] K</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] LeftPart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] RightPart = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; Array.Copy(P, <span class="hljs-number"><span class="hljs-number">0</span></span>, LeftPart, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); Array.Copy(P, <span class="hljs-number"><span class="hljs-number">4</span></span>, RightPart, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round4Right = XOR(LeftPart, RightPart); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round4Left = XOR(LeftPart, F(XOR(Round4Right, K[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round3Right = Round4Left; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round3Left = XOR(Round4Right, F(XOR(Round3Right, K[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round2Right = Round3Left; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round2Left = XOR(Round3Right, F(XOR(Round2Right, K[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round1Right = Round2Left; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Round1Left = XOR(Round2Right, F(XOR(Round1Right, K[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] TextLeft = Round1Left; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] TextRight = XOR(Round1Left,Round1Right); AddKeyPart(TextLeft, K[<span class="hljs-number"><span class="hljs-number">4</span></span>]); AddKeyPart(TextRight, K[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Text = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; Array.Copy(TextLeft, <span class="hljs-number"><span class="hljs-number">0</span></span>, Text, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); Array.Copy(TextRight, <span class="hljs-number"><span class="hljs-number">0</span></span>, Text, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Text; } }</code> </pre> <br></div></div><br><br><h4>  Differential cryptanalysis of FEAL4 cipher </h4><br>  As in the example above, we begin the cryptoanalysis of the cipher with an examination of the substitution function F. This is where the most significant flaw of the entire FEAL cipher is hidden.  The point is that the function F has one property that is catastrophic from the point of view of safety.  Any two values ​​of X <sub>1</sub> and X <sub>2</sub> , such that their differential X <sub>1</sub> ⊕ X <sub>2</sub> = 0x80800000, are converted to Y <sub>1</sub> and Y <sub>2</sub> .  Moreover, the differential Y <sub>1</sub> ⊕ Y <sub>2</sub> = 0x02000000 in 100% of cases. <br><br>  In order to understand why this happens, take a look at the transformation of the differentials that occurs when calculating the function F. <br><img src="https://habrastorage.org/getpro/habr/post_images/47d/1f5/db3/47d1f5db3ff2c973b2f018760dd01d2f.jpg" align="left"><br>  It is easy to see that a nonzero value is fed to the input of the function G, only at the position of the first byte.  Accordingly, at the output we get <img src="https://habrastorage.org/getpro/habr/post_images/e29/b39/6c6/e29b396c6fc55b68af4ccf1d42c8d1ae.png">  . <br><br>  It is easy to understand that this property makes the cipher completely vulnerable to differential cryptoanalysis.  100% probability of a certain differential ΔY allows you to reduce the number of pairs of open-closed text required for an attack to a minimum. <br><br>  Consider what steps an attacker should take to unlock the key of the last round K [3]. <br>  The attacker generates several pairs of open texts P <sub>1</sub> and P <sub>2</sub> , such that ΔP = 0x8080000080800000.  Knowing the property of the function F described above, an attacker is able to calculate the differentials at almost every encryption round. <br><br>  You can track the behavior of differentials in the following picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/297/376/84c/29737684c95c9de9cf357e1e83cf341f.jpg"><br>  As you can see the differentials are calculated until the last round.  But even without this, the attacker already has enough information to reveal the last round key. <br>  The illustration below shows the last two rounds of the FEAL4 cipher. <br><img src="https://habrastorage.org/getpro/habr/post_images/aa6/d00/d74/aa6d00d743edaf9d4185b720bfbce13b.png"><br>  Possessing a pair of C <sub>1</sub> and C <sub>2</sub> ciphertexts, an attacker can calculate ΔC, thus obtaining the values ​​of L 'and R'. <br>  Based on this, he can calculate Z '= L'⊕02. <br>  On the other hand, for each pair of C <sub>1</sub> and C <sub>2</sub> ciphertexts, an attacker can calculate Y <sub>1</sub> and Y <sub>2</sub> . <br>  Knowing Y <sub>1</sub> and Y <sub>2, the</sub> attacker starts searching the key K [3].  For each possible Kpos key, Z <sub>1</sub> = F (Y <sub>1</sub> ⊕ Kpos) and Z <sub>2</sub> = F (Y <sub>2</sub> ⊕ Kpos) are calculated.  Adding modulo two values ​​Z <sub>1</sub> ⊕Z <sub>2, the</sub> attacker compares the resulting value with the pre-calculated Z '.  If Z '= Z <sub>1</sub> ⊕Z <sub>2</sub> , then Kpos is most likely the required subkey K [3]. <br>  In order to reduce the likelihood of an error, the received Kpos key must be checked with several pairs of ciphertexts (I used 10 pairs in my implementation). <br><br>  It is easy to calculate that the attack described above requires 2 <sup>32</sup> calculations of the function F. This is certainly not 2 <sup>64</sup> , declared by the cipher creators, but still the figure is not very pleasant, especially if we want to calculate all 4 round keys, and we certainly want it. <br>  Fortunately, the attack can be simplified and reduce the number of calculations to a completely comfortable 2 <sup>17</sup> . <br>  To do this, we introduce the definition of the function <img src="https://habrastorage.org/getpro/habr/post_images/aeb/4dc/9ea/aeb4dc9eade10599e2af7014e692f38d.png">  where a is a set of bytes, and z is a zero byte. <br>  For each A = (z, a <sub>0</sub> , a <sub>1</sub> , z), the attacker calculates Q <sub>0</sub> = F (M (Y <sub>0</sub> ) ⊕A) and Q <sub>1</sub> = F (M (Y <sub>1</sub> ) ⊕A). <br>  It is easy to verify that if A = M (K [3]), then the second and third byte of the value Q <sub>0</sub> ⊕Q <sub>1</sub> will coincide with the second and third byte of the value Z '.  Thus, we obtain information on two bytes of the potential key Kpos. <br>  After that, for all values ​​of b <sub>0</sub> and b <sub>1</sub> , the attacker calculates the sequence Kpos = (b <sub>0</sub> , b <sub>0</sub> ⊕ a <sub>0</sub> , b <sub>1</sub> ⊕ a <sub>1</sub> , b <sub>1</sub> ) and checks the resulting sequence in the manner described above. <br><br>  After opening the subkey K [3], the attacker is able to restore the values ​​in which the cipher was located after the third round and this will give him the opportunity to attack the subkey K in the same way [2].  Here, however, it should be noted that in order to attack the key K [2], it will be necessary to use another initial differential, since  the differential ΔP = 0x8080000080800000 in the second round always leads to the value Z '= 0x02000000, for any used key.  And it does not allow to guess the key of the second round. <br>  The following values ​​can be used as differentials for opening each subkey: <br>  Round 4: 0x8080000080800000 <br>  Round 3: 0x0000000080800000 <br>  Round 2: 0x0000000002000000 <br>  Round 1: 0x0200000080000000 <br>  After opening all four keys of each of the rounds, it is easy to calculate the keys K [5] and K [4] for this purpose it is enough to drive out any ciphertext after 4 rounds of decryption and add the resulting value modulo two with known plaintext. <br><br>  If you are interested in downloading the source of the attack, you can <a href="http://ge.tt/1KdeXAQ1">here</a> . <br><br><h4>  useful links </h4><br><ul><li>  <a href="http://www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf">Tutorial on Linear and Differential Cryptanalysis</a> </li><li>  <a href="http://www.theamazingking.com/crypto-feal.php">Differential Cryptanalysis of FEAL</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/215527/">https://habr.com/ru/post/215527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215513/index.html">Developer Tools or Why aren't you using X? Part 1</a></li>
<li><a href="../215519/index.html">Production of LED display pilot batch LaMetric</a></li>
<li><a href="../215521/index.html">Arduino: IR control appliances</a></li>
<li><a href="../215523/index.html">Landfill is not an option. 3 legal ways to get rid of old iron</a></li>
<li><a href="../215525/index.html">PonoMusic - digital music ecosystem</a></li>
<li><a href="../215529/index.html">Come to the jubilee XV International Software Quality Assurance Days International Conference</a></li>
<li><a href="../215531/index.html">How Russian online stores to deal with Amazon</a></li>
<li><a href="../215535/index.html">Bright future of IPv6: when the new world order finally comes</a></li>
<li><a href="../215537/index.html">New MWC and Mobile Trends</a></li>
<li><a href="../215539/index.html">Opera Mini 8 for Java and Blackberry phones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>