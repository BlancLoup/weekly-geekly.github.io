<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Firmware security using the example of industrial switches Hirschmann and Phoenix Contact</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many modern computer systems (motherboards in PCs, smartphones, network equipment ...) run under the control of firmware, which, as a rule, is develop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Firmware security using the example of industrial switches Hirschmann and Phoenix Contact</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/797/9ad/38c/7979ad38c0ec4b45917afedd9957e71b.jpg"><br><br>  Many modern computer systems (motherboards in PCs, smartphones, network equipment ...) run under the control of firmware, which, as a rule, is developed for a specific hardware, can use the full range of available hardware resources and has the highest privileges.  The protection of firmware should be given special attention, otherwise it will be a real Achilles heel in the security of the system. <br>  A small cycle of articles will be devoted to this issue, we will show weak and strong models of firmware security using real examples. <br><br>  By the way, the basis of this article is our study of the security of industrial network switches, which I presented at the information security conference for practitioners of <a href="http://2015.zeronights.ru/">ZeroNights 2015</a> (the report ‚ÄúModification of firmware of industrial switches‚Äù, the presentation is <a href="http://2015.zeronights.ru/assets/files/13-Ermolov.pdf">here</a> ). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h1>  Introduction </h1><br><br>  First, we will tell about the objects of our research - industrial switches. <br><br>  The heart of any modern ICS infrastructure is the data transmission environment.  In most cases, it is an industrial network such as Industrial Ethernet, i.e.  based on the Ethernet technology family.  Such a network differs from the usual one, first of all, by using the real-time protocol (for example, Profinet, EtherCAT, Ethernet / IP and others). <br><br>  An example of an industrial network [picture <a href="http://www.icpdas.com/root/product/solutions/industrial_communication/fieldbus/ethernet_ip/ethernet_ip_intro.html">from here</a> ]: <br><br><img src="https://habrastorage.org/files/4b8/dfa/ac9/4b8dfaac913640aea49d8e63c0bcae74.jpg"><br><br>  Various devices (PLCs, HMI panels, control PCs, field devices and others) are connected to the network via industrial-type network switches (switches).  Unlike conventional switches, they are less demanding of operating conditions (extended operating temperature range, protection against voltage surges, impact resistance, possibility of mounting on a DIN-rail, etc.) and support industrial network protocols. <br><br>  Thus, industrial switches are a critical element in the structure of an industrial network.  It is very important to properly protect them from being compromised by a potential intruder, because it will allow you to get virtually unlimited control over the process: compromising other devices on the network, intervening and changing data inside various connections between the PLC and SCADA, between the gateways and the PLC, forging data, transmitted to the HMI and logging systems, etc.  All this may entail a loss of control by the operator over the real state of the technological process and, as a result, a halt or an accident. <br><br>  To prevent this from happening: <br><ul><li>  first, the location of the switch should minimize the possibility of unauthorized physical access to it; </li><li>  secondly, the software and hardware architecture of the switch must have an information security model that takes into account modern threats. </li></ul><br><br>  On the last and talk. <br><br><h3>  Objects of study </h3><br><br>  For the study, we took one model of managed industrial switches from the two most common manufacturers of industrial network equipment: <br><ul><li>  Hirschmann RS20 </li><li>  Phoenix Contact FL SWITCH MM HS </li></ul><br><br>  You can control the operation of these switches through the COM port (both have an RS-232 connector) or at the network level. <br><br><br>  When working through the COM port, we are dealing with a console for entering commands: <br><br><img src="https://habrastorage.org/files/d30/f87/24a/d30f8724ad9347be85f26af9aff0c8a2.jpg"><br><br>  Access to the console requires a login and password.  However, before the authentication screen, several options are available, for example, displaying information about hardware and firmware, updating firmware, etc. <br><br><br>  When working with a switch over a network, you can reach (by its IP address) the web interface: <br><br><img src="https://habrastorage.org/files/a9e/98c/7d6/a9e98c7d65bf494b8d07bd5b2faa20c0.jpg"><br><br>  Authentication is required to access it. <br><br><br>  Another option for managing the switch at the network level is the Simple Network Management Protocol (SNMP), which also has authentication.  However, SNMP support in the switches studied has several drawbacks: <br><ul><li>  By default (and this is the most favorite configuration of most network devices), the most insecure version of this protocol is used - SNMP v1; </li><li>  in SNMP v1, the default login and password vendor of these devices strongly recommends not to change; </li><li>  SNMP v1 and SNMP v2c do not use encryption, which means the protocol is vulnerable to MITM attacks (man in the middle). </li></ul><br><br>  First, let's talk about the study of the Hirschmann RS20 switch, then we will designate the features of Phoenix Contact FL SWITCH MM HS in comparison with this switch. <br><br><h1>  Hirschmann RS20 Industrial Switch Study </h1><br><br><h3>  Firmware </h3><br><br>  First you need to get the firmware, understand what the processor is doing, and evaluate the possibility of connecting the programmer / debugger.  To do this, we looked inside and saw: <br><ol><li>  CPU Digi NET + ARM NS9360B-0-I155, 32-bit ARM9, without internal memory (therefore, the firmware must be stored in external memory); </li><li>  Micron MT48LC8M16A2 SDRAM RAM at 16 MB; </li><li>  Intel flash memory 28F640JD3D75 8 MB (most likely, the firmware here); </li><li>  CPLD Marvell 88E6095F-LG01, performs the function of an Ethernet switch, has an internal configuration memory. </li></ol><br><br>  Chip flash memory is made in the case of BGA.  If we drop it, it will be very difficult to solder it back without an infrared soldering station.  Therefore, the firmware (version 8.0.07) for this switch has been merged from the <a href="">open Hirschmann ftp server</a> . <br><br>  One of the files in the downloaded archive is the rsL2E.bin binary (about 4 MB), this is the firmware image.  Having rummaged in it, we saw that it consists of two modules.  Each module has a header (their structure is the same), as well as a compressed body. <br><br><img src="https://habrastorage.org/files/97f/c2f/75d/97fc2f75d1f84d76923c4efdca0a65ea.jpg"><br><br><br>  The first module is compressed using the zlib algorithm (RFC 1951).  That is where the executable code is stored.  When unpacked, the module weighs approximately 7 MB. <br><br>  The second module is compressed using the gzip algorithm (RFC 1952), it contains a pack200 archive, after unpacking which you get a JAR (Java Archive) file, which is an implementation of the device‚Äôs web interface.  After unpacking, the module weighs approximately 3 MB.  By the way, this file is transmitted to the host (control PC) when accessing the switch by its IP address (that is, when trying to access the device‚Äôs web interface) and is executed on it (on the host). <br><br>  It can be seen that the total amount of unpacked modules is 10 MB, and the amount of flash memory on the system board of the device is 8 MB.  Therefore, we assumed that the firmware image is stored in a packed form.  So, there must be a bootloader that unpacks and launches this firmware.  But about the loader later. <br><br><br>  The size of each module header is 256 bytes.  The structure of it is not documented anywhere, so I had to disassemble the method of scientific tyke.  Fields that caught our attention: <br><ul><li>  module signature; </li><li>  type of module; </li><li>  module size; </li><li>  module checksum (CRC32); </li><li>  offset to the end of the file (eof offset); </li><li>  module checksum (repeat) (CRC32); </li><li>  header checksum (CRC32). </li></ul><br><br><img src="https://habrastorage.org/files/64a/0c6/eaf/64a0c6eaf7b54add96a5d64b45e040c3.jpg"><br><br><br>  Based on this, it can be concluded that there is a control of the integrity of the firmware.  But the control of authenticity, usually a digital signature (digital signature), is absent. <br><br>  The ability to falsify these firmwares must be checked, for this we wrote a small script that allows you to quickly remove both modules from the firmware image, and, after making changes to them, collect them back into the finished image: <br><br><img src="https://habrastorage.org/files/f42/ded/bad/f42dedbad0ab4208bb759954ac936746.jpg"><br><br><br>  But before you make changes, you need to think.  And messed up. <br><br><br>  It turned out that inside the firmware there is a code of RTOS (real-time operating system) VxWorks, with a rather old version 5.4.2 (around 1998).  At the time of this writing, the latest version is 7. <br><br>  In the <a href="http://en.pudn.com/downloads182/sourcecode/embed/detail848724_en.html">Chinese "Internet"</a> we found the source for VxWorks 5.5, which greatly facilitated the identification of various operating system functions, libc procedures and other things.  Anyone who is faced with the task of analyzing VxWorks code will probably think now: ‚ÄúLook at the end, VxWorks images always have a symbol table!‚Äù.  It is, but in this form it is almost useless: <br><br><img src="https://habrastorage.org/files/da3/8ac/f87/da38acf875a34d05a68a3dcc5e2709a4.jpg"><br><br><br>  VxWorks is a modular product, and the composition of the modules is determined by the customer when they buy source codes.  In this case, in addition to the basic components, we saw the modules of the web server (EmWeb), SnmpOverHttp (yes, in the dropped traffic, we saw SNMP packets inside HTTP requests) and others. <br>  The vendor definitely took care of the filling. <br><br>  But the security is not very.  Here, the linear address space, the execution of the code can be carried out from anywhere in the memory, there is also no protection against overflows on the stack, etc.  Elementary protection mechanisms against exploitation of binary vulnerabilities are completely absent.  Maybe they are not needed?  But after all the registered vulnerabilities for this version of VxWorks are <a href="http://www.cvedetails.com/vulnerability-list/vendor_id-95/product_id-15063/Windriver-Vxworks.html">complete</a> : <br><ol><li>  CVE-2015-3963 spoof TCP sessions; </li><li>  CVE-2010-2968 brute-force; </li><li>  CVE-2010-2967 obtain access; </li><li>  CVE-2010-2966 obtain access; </li><li>  CVE-2010-2965 RCE; </li><li>  CVE-2008-2476 DoS; </li><li>  ... </li></ol><br><br>  Choose for every taste: DoS (Denial of Service), RCE (Remote Code Execution), opportunities for selection (brute-force), opportunities for circumventing authorization.  The list is not complete. <br><br>  But do not be upset!  Indeed, during the analysis of the firmware, very interesting code fragments were found: <br><ul><li>  SNMP request handlers; </li><li>  console command handlers; </li><li>  reading and rewriting flash memory; </li><li>  read and overwrite CPLD Marvell configuration memory! </li></ul><br><br>  Povorevsili, now you can pohahit. <br><br>  To do this, you should correctly choose a place to introduce the code: it should not be allowed to interfere with the normal functioning of the switch, and it is best if it is called up on demand. <br><br>  The obvious choice was one of the handlers of console commands.  More specifically, the ‚Äúlogout‚Äù command handler.  In its place in the firmware, we wrote a code that reads the memory of a given size at a given address (everything is set in variables at the end of the inserted fragment), and outputs the captured dump to the COM port: <br><br><img src="https://habrastorage.org/files/d14/274/1ef/d142741ef3ff47249e321a5700e28592.jpg"><br><br><br>  We made a ready image, updated the switch with it (it is possible to update the firmware through the COM port and through the web interface).  Success!  Indeed, after entering the logout command, instead of logging out, a memory dump was now output: <br><br><img src="https://habrastorage.org/files/c8e/e78/c16/c8ee78c16e8e42d2b768958815361473.jpg"><br><br><br>  Thereby, the possibility of forging firmware was confirmed. <br><br>  But how can an attacker embed his firmware into a switch that is actually used at an industrial facility? <br><br><br>  Consider the possibility of updating via the COM port (i.e., via the console interface).  As already mentioned, to upgrade the firmware of the switch, you do not need to know your login and password, but you must have physical access to the device (to plug into RS-232).  This option is hard to believe if the device is already in use at the facility. <br><br>  However, the switch from the factory does not immediately reach the industrial facility.  In the delivery scheme to the customer there are always intermediate organizations that have the ability, as a free bonus, to download non-original firmware to the switch. <br><br>  Another option (although this is already the distribution vector): you can infect the firmware of the switch from a previously compromised control PC that is already connected to the switches via the COM port. <br><br><br>  Remotely modifying the firmware of the switch is more difficult, but the attack surface is much wider.  Recall that authentication is required to access the switch web interface.  What can be done?  Try: <br><ul><li>  enter default login and password; </li><li>  pick up taking into account known restrictions on the password.  Fortunately, there is no protection against brute-force attacks; </li><li>  exploit binary vulnerabilities (known or honestly find one's own), again, there is no protection against exploitation of binary vulnerabilities. </li></ul><br>  By the way, remotely - this is not only from a PC connected to the switch.  And also from one of the field devices, which happens to be in unguarded territory.  So it must be taken care of! <br><br><br>  The conclusion is the following.  A potential attacker, when introducing his code into the switch firmware, has the ability to: <br><ul><li>  execute its code on the switch CPU (using the whole range of its hardware resources); </li><li>  execute its code on the side of the host (control PC) or any other client PC that accidentally called on the IP address of the switch.  Of course, this code will be executed in a Java machine, but, as you know, it is not a security bulwark. </li></ul><br><br>  Note that a compromised switch can be ‚Äúcured‚Äù by a regular firmware update procedure.  The main thing is that you are sure of the authenticity of the new image. <br><br><br>  In any case, this immediately leads to the question of the possibility of fixing on the device so that the changes made to the firmware would ‚Äúexperience‚Äù any updates.  And then we remembered the bootloader, the dump of which we did not have. <br><br><br><h3>  Loader </h3><br><br>  Hoping that the bootloader left a trace in the RAM, we dumped (using the above code snippet) it in different places, but did not find anything.  And we decided to try to get it from the flash memory of the switch, pulling the previously found procedures for reading flash memory.  And success again. <br><br>  So, the contents of flash memory can be divided into three regions: <br><ol><li>  Bootblock, first 80000h bytes.  This is the boot area, here is stored the bootloader, which consists of three parts: <br><ul><li>  start code; </li><li>  main code (compressed by Huffman algorithm); </li><li>  header (the structure is identical to the previously described structure of the header of the firmware module); </li></ul></li><li>  Application firmware, the largest area, stores the image of the firmware in a packaged form, as expected; </li><li>  Storage, storage area for service information, configurations, logs, etc. </li></ol><br><br><img src="https://habrastorage.org/files/50e/516/5bd/50e5165bd1814167ad89d11a0b9ceb4c.jpg"><br><br><br>  The bootloader code allowed us to reconstruct the early stages of the switch boot process. <br><br>  At the start, the first 4 KB of flash memory (which is just the size of the start code) are projected into the CPU address space at address 0. From this address, execution begins. <br>  The task of the starting part of the bootloader is to configure the memory card, unpack the main part of the bootloader into memory and transfer control to it. <br><br>  The main loader code should: <br><ol><li>  Initialize CPU hardware resources; </li><li>  Configure the interrupt model; </li><li>  Unpack the firmware into memory and transfer control to it. </li></ol><br><br><img src="https://habrastorage.org/files/041/407/989/041407989637465abffbbb3d650203bd.jpg"><br><br><br>  Immediately comes to mind a way to modify the bootloader.  The switch is updated with a modified version of the firmware, which, using standard procedures for working with flash memory, will rewrite the bootblock area. <br><br><img src="https://habrastorage.org/files/7a5/e38/9bf/7a5e389bf4c141f5ac0461f484771b19.jpg"><br><br>  In the future, the modified bootloader will be able to make changes to the unpacked firmware image at each boot.  A switch thus compromised is not so easy to cure. <br><br><img src="https://habrastorage.org/files/5e0/b4d/276/5e0b4d2769ce42f1b7c5284ca9180ae8.jpg"><br><br><br>  Is it possible to ‚Äúcure‚Äù a switch with regular means?  To do this, you need to update on the original and firmware, and bootloader. <br><br>  In the console interface, it is not possible to update the bootloader, although procedures have been found in the firmware code that are designed to update the bootblock area in the same way as the firmware is updated.  But these functions are not called anywhere, so this is an undocumented debugging functionality. <br><br>  But in the web interface of the switch a fully-fledged option was found for updating the bootloader: <br><br><img src="https://habrastorage.org/files/ccb/31f/522/ccb31f522bb4457d8b738e20f53ceb90.jpg"><br><br><br>  The only question is what to update?  And nothing! <br><br>  In the archive with the firmware image for many models of their devices, Hirschmann does not attach the boot image.  And the investigated model among them. <br><br>  Get the image of the bootloader by contacting tech support, too, will not work.  We tried, and got the answer, that the bootloader images are not distributed.  The only thing that was possible to achieve from them was the proposal to send the device to them using the RMA form.  However, they will strongly discourage you from doing this, sincerely considering this process to be useless. <br><br>  Thus, a potential attacker has the opportunity, through a modification of the firmware, to be fixed in the device loader.  And it is almost impossible to get it out of there using regular means. <br><br><br><h3>  Is it possible to dig even deeper? </h3><br><br>  At the moment we have no answer to this question, but the idea will be worth it. <br><br>  Recall that this device has another executable environment, with its own, in some way, firmware.  This is an FPGA (programmable logic integrated circuit), such as CPLD from Marvell with internal non-volatile configuration memory. <br><br>  Programs for them are written in the language of the description of logic (VHDL, Verilog - the most common).  Recall that in the switch firmware code, we found functions for reading and rewriting this configuration memory. <br><br><h1>  Research industrial switch Phoenix Contact FL SWITCH MM HS </h1><br><br>  In the study of this switch, we went the same way, only faster.  What is interesting inside: <br><ol><li>  CPU PMC RM5231A, 32-bit MIPS IV, without internal memory; </li><li>  Micron MT48LC8M16A2 SDRAM 16 MB RAM, two pieces; </li><li>  Intel flash memory of unknown model; </li><li>  Chipset Galileo GT-64115. </li></ol><br><br>  We downloaded the firmware image for this switch from the vendor‚Äôs official website and dismantled its structure in the same way.  It has a header and a zlib compressed body (RFC 1951) body: <br><br><img src="https://habrastorage.org/files/af7/05a/074/af705a074f7d4a58ba510f0a1ac809ee.jpg"><br><br><br>  Primary fields in the header structure: <br><ul><li>  signature; </li><li>  header checksum (ADLER32); </li><li>  checksum of the unpacked body (ADLER32); </li><li>  unpacked body size; </li><li>  packed body checksum (ADLER32); </li><li>  packed body size. </li></ul><br><br><img src="https://habrastorage.org/files/19c/424/fa1/19c424fa1cd94efc80d82048c659256c.jpg"><br><br><br>  Here, too, there is no control over the authenticity of the firmware, we have experimentally verified this. <br><br><img src="https://habrastorage.org/files/7ba/97a/86a/7ba97a86ab5d43aab4e9aaaae44c1d7b.PNG"><br><br><br>  VxWorks is also here, although a slightly newer version 6.1 has the same problems: the lack of protection mechanisms against exploitation of binary vulnerabilities and a pack of registered CVEs. <br><br>  You can update the firmware in the same ways: <br><ul><li>  via COM port, authentication is also not required </li><li>  via web interface.  To access it, you do not need to enter a login and password, but when making changes to the settings (or when updating the firmware) you need to know the password. </li></ul><br><br>  Speaking of password.  According to the documentation, there is an engineering password, in case the current password is lost (well, or never acquired, if you are a hacker).  To do this, you need to contact technical support by providing them with the MAC address and serial number of the switch. <br>  This suggests that there is an algorithm for converting these numbers into an engineering password. <br><br>  This switch also has a bootloader that can be overwritten.  And it is experimentally proven.  There are no regular features for updating the bootloader at all. <br><br><h1>  Conclusion </h1><br><br>  As a result of the study, the following shortcomings in the architecture of industrial switches were revealed: <br><ol><li>  The ability to illegally update the firmware (for some standard procedures, authentication is not required); </li><li>  The ability to fake the image of the device firmware (later the boot loader, the CPLD firmware ...) because  there is no control of the authenticity of the code; </li><li>  There are no mechanisms for exploiting binary vulnerabilities, which opens up additional possibilities for remote execution of code on the switch. </li></ol><br><br>  During the study, we showed the ability to fake firmware switches, as well as the possibility of fixing modifications in the bootloader. <br><br><br>  <b>In short, pahacheno.</b> <br><br>  A real example of the correct, in our opinion, firmware security model will be discussed in the next article. </div><p>Source: <a href="https://habr.com/ru/post/276345/">https://habr.com/ru/post/276345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276333/index.html">Using or Using?</a></li>
<li><a href="../276335/index.html">HPE Aruba - Corporate-grade Wi-Fi</a></li>
<li><a href="../276339/index.html">Taming of the Shrew</a></li>
<li><a href="../276341/index.html">Microsoft Azure Stack TP1</a></li>
<li><a href="../276343/index.html">BlueZ bracelet control</a></li>
<li><a href="../276347/index.html">Does your antivirus catch password-protected archives?</a></li>
<li><a href="../276349/index.html">Foreign hackers hacked the database of the largest US police union</a></li>
<li><a href="../276353/index.html">DevConf 2015: video of PHP section reports</a></li>
<li><a href="../276355/index.html">Bayesian neural network - because why not, damn it (part 1)</a></li>
<li><a href="../276357/index.html">As "Satellite" included "Children's mode"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>