<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explanation http2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The other day, Daniel Stenberg, one of the participants in the HTTPbis IETF group, which is developing the http2 protocol, published an extremely inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explanation http2</h1><div class="post__text post__text-html js-mediator-article">  The other day, Daniel Stenberg, one of the participants in the HTTPbis IETF group, which is developing the http2 protocol, published an extremely interesting document <a href="http2-explained/">‚Äúhttp2 explained‚Äù</a> on his blog.  A small 26-page PDF document in a very accessible language tells about the prerequisites and details for implementing the http2 protocol. <br><br>  It seems to me that today it is one of the best explanations of what the http2 protocol is, why it is needed, how it will affect web development and what future the Internet is facing in connection with its appearance.  I think that all people involved in web development and web building information will be useful, because it is expected that the http2 standard will be adopted as early as June of this year after the final meeting of the HTTPbis group in New York. <br><a name="habracut"></a><br>  Many modern browsers to some extent support the latest version of the draft http2, so you can expect that after a short period of time (weeks) after the adoption of the standard, all customers will support it.  Many large Internet companies such as Google, Facebook and Twitter are already testing their web services to work with http2. <br><br>  Therefore, in order not to one day suddenly find yourself in a world that works on a protocol about which you only heard something with the edge of your ear and have no idea what it is and how it works, I advise you to look at this document.  Personally, I was under the impression that I made a Russian translation ( <i><b>Update: the</b> translation is now available directly in this article</i> ).  Please, if you find inaccuracies in translation or typographical errors, report.  I hope that as a result, the document will be as clear and useful as possible to a large circle of people. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  http2 </h3><br><br>  History, Protocol, Implementation, and Future <br>  <a href="http2/">daniel.haxx.se/http2</a> <br><br><h4>  Story </h4><br>  This is a document that describes http2 from a technical and protocol level.  It originally appeared as a presentation that I presented in Stockholm in April 2014.  I have since received many questions about the content of the presentation from people who could not attend the event, so I decided to convert it into a full document with details and proper explanations. <br>  At the time of writing (April 28, 2014), the final specification of http2 is not complete and not released.  The current version of the draft is called <a href="http2-12">draft-12</a> , but we expect to see at least one more version before http2 is complete.  This document describes the current situation, which may or may not change in the final specification.  All errors in this document - my own, which appeared through my fault.  Please report them to me and I will release an update with corrections. <br><br>  The version of this document is 1.2. <br><br><h5>  Author </h5><br>  My name is Daniel Stenberg and I work at Mozilla.  I have been involved in open source software and networks for more than twenty years in various projects.  I‚Äôm probably best known as the main curl and libcurl developer.  For many years, I was involved in the IETF HTTPbis working group and worked on both HTTP 1.1 support, to meet the latest requirements, and work on http2 standardization. <br><br>  Email: daniel@haxx.se <br>  Twitter: @bagder <br>  Web: daniel.haxx.se <br>  Blog: daniel.haxx.se/blog <br><br><h5>  Help! </h5><br><br>  If you find typos, omissions, errors and obvious lies in this document, please send me a corrected version of the paragraph and I will release a corrected version.  I will properly mark everyone who helped!  I hope that in time it will turn out to make the text better. <br><br>  This document is available at <a href="http2">daniel.haxx.se/http2</a> <br><br><h5>  License </h5><br>  This document is licensed under the Creative Commons Attribution 4.0 license: <a href="http://creativecommons.org/licenses/by/4.0/">creativecommons.org/licenses/by/4.0</a> <br><img src="https://habrastorage.org/getpro/habr/post_images/61e/30c/a21/61e30ca211481b03cace82ec94063446.png"><br><br><h4>  HTTP today </h4><br><br>  HTTP 1.1 has become a protocol that is truly used for everything on the Internet.  Huge investments were made in protocols and infrastructure, which are now deriving profit from this.  It got to the point that today it is often easier to run something on top of HTTP than to create something new in its place. <br><br><h5>  HTTP 1.1 is huge </h5><br><br>  When HTTP was created and released into the world, it was probably perceived rather as a simple and straightforward protocol, but time has shown that this is not the case.  HTTP 1.0 in RFC 1945 is 60 pages of specification, released in 1996. RFC 2616, which described HTTP 1.1, was released only three years later in 1999 and has grown significantly to 176 pages.  In addition, when we at the IETF worked on updating the specification, it was split into <i>six</i> documents with an even greater number of pages in total.  Without a doubt, HTTP 1.1 is large and includes a myriad of details, subtleties and no less an optional section. <br><br><h5>  World of options </h5><br><br>  The nature of HTTP 1.1, enclosed in the presence of a large number of fine details and options available for subsequent change, has grown an ecosystem of programs where there is not a single implementation that embodies everything - and, in fact, it is impossible to say for sure what this is " everything".  What led to a situation where opportunities that were initially little used appeared only in a small number of implementations, and those who realized them after they saw little use of them. <br>  Later, this caused compatibility problems when clients and servers began to make more active use of such features.  <i>HTTP pipelining</i> ( <i>HTTP pipelining</i> ) is one illustrative example of such features. <br><br><h5>  Inadequate use of TCP </h5><br><br>  HTTP 1.1 has come a hard way to really take advantage of all the power and performance that TCP provides.  HTTP clients and browsers need to be truly inventive in order to find ways to reduce page load times. <br><br>  Other experiments that have been conducted in parallel over many years have also confirmed that TCP is not so easy to replace, and therefore we continue to work on improving both TCP and the protocols working on top of it. <br><br>  TCP can be easily started to use fully to avoid pauses or time periods that could be used to send or receive more data.  Subsequent chapters will highlight some of these disadvantages of use. <br><br><h5>  Transfer size and number of objects </h5><br><br>  When you look at the development trends of some of the most popular sites today and compare how long it takes to load their main page, the trends become obvious.  Over the past few years, the amount of data that needs to be transferred has gradually increased to 1.5 MB and higher, but what is most important for us in this context is the number of objects, which is now close to one hundred on average.  One hundred objects must be loaded to display the entire page. <br><br>  As the chart shows, the trend was growing, but later there are no signs that it will continue to change. <br><img src="https://habrastorage.org/getpro/habr/post_images/da8/b23/e65/da8b23e6584457ec459fc9f74505a868.png"><br><br><h5>  Lag kills </h5><br><br>  HTTP 1.1 is very sensitive to latency, partly due to the fact that HTTP pipelining still has problems and is turned off by an overwhelming number of users. <br><br>  While we all have seen a significant increase in user bandwidth over the past few years, we have not seen a similar level of delay reduction.  High-latency channels, like many modern mobile technologies, greatly reduce the feeling of good and fast web navigation, even if you have a really high-speed connection. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd1/a1a/22e/dd1a1a22eec2ae43145246a722833a3b.png"><br><br>  Another example where low latency is really required is certain types of video, such as video conferencing, games, and the like, where not only a previously created stream needs to be transmitted. <br><br><h5>  Block start queue </h5><br><br>  HTTP pipelining is a way to send another request, already waiting for a response to a previous request.  It looks like a queue to the cashier in a supermarket or bank.  You do not know what kind of people are in front of you: fast clients or annoying people who need endless time to complete the service - blocking the beginning of the line. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98f/30f/cec/98f30fceca1178e095764ac4fc391a1a.png"><br><br>  Of course, you can carefully select a queue and eventually choose the one that you think is right, and sometimes you can create your own queue, but in the end, you cannot avoid making a decision and once you choose a queue, you cannot change it. <br><br>  Creating a new queue is associated with performance and paying for resources, and cannot scale beyond a small number of queues.  There is no perfect solution for this task. <br><br>  Even today, in 2014, most web browsers on desktops come with the HTTP pipeline disabled by default. <br><br>  Additional information on this issue can be found in the Firefox bug tracker number <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D264354">264354</a> . <br><br><h4>  Steps taken to overcome the delay </h4><br><br>  As usual, when people encounter errors, they come together to find workarounds.  Some workaround paths are skillful and useful, some simply terrifying crutches. <br><br><h5>  Creating sprites </h5><br><br>  Creating sprites is a term often used to describe an action when you collect many small images into one large one.  Then use javascript or CSS to ‚Äúcut‚Äù parts of a large image to display small images. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/257/bbe/a26/257bbea26fce7d3103428b14cf6cccda.png"><br><br>  The site uses this trick to speed up.  Getting one large request is much faster in HTTP 1.1 than getting one hundred separate small pictures. <br><br>  Of course, this has its drawbacks for those pages of the site that require only one or two small pictures.  It also throws out all the cached pictures at the same time, instead of possibly leaving some of the most used ones. <br><br><h5>  Embedding </h5><br><br>  Embedding is another trick to avoid sending individual images, using data instead ‚Äî the URL embedded in the CSS file.  This has the same advantages and disadvantages as sprites. <br><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.icon1</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(data:image/png;base64,&lt;data&gt;) no-repeat; } <span class="hljs-selector-class"><span class="hljs-selector-class">.icon2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(data:image/png;base64,&lt;data&gt;) no-repeat; }</code> </pre> <br><br><h5>  Union </h5><br><br>  As well as in the two previous cases, today large sites may have a lot of javascript files.  Utilities of developers allow you to combine all these files into one huge com, so that the browser receives one file instead of many small ones.  A large amount of data is sent, then only as a small fragment is actually required.  An excessive amount of data is required to be reloaded when a change is required. <br><br>  Developer irritation and coercion to fulfill these requirements is, of course, ‚Äújust‚Äù pain for the people involved and is not displayed in any performance graphs. <br><br><h5>  Sharding </h5><br><br>  The final trick I‚Äôll mention, used by site owners to improve browsing, is often called "sharding."  This basically means spreading your service across as many different hosts as possible.  At first glance, this sounds crazy, but there is a simple reason for this! <br><br>  Initially, HTTP allowed a client to use a maximum of two TCP connections per host.  Thus, in order not to violate the specification, advanced sites simply came up with new host names and voila, you can get more connections for your site and reduce page load time. <br><br>  Over time, this restriction was removed from the specification and today customers use 6-8 connections per host, but they still have a restriction, so sites continue to increase the number of connections.  As the number of objects has increased, as I showed earlier, a large number of connections have been used just to make sure that HTTP copes well and makes the site faster.  It is not unusual for sites to use more than 50 or even 100 compounds using this technique. <br><br>  Another reason for sharding is placing images and similar resources on individual hosts that do not use cookies, since cookies can be of considerable size today.  Using the cookie-free image hosts, you can increase your productivity just at the expense of significantly smaller HTTP requests! <br><br>  The figure below shows what packet entries look like when browsing one of the top Sweden web sites and how requests are distributed across multiple hosts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e84/d50/0de/e84d500decdc15af5b1f24dc217c0f8c.png"><br><br><h4>  HTTP update </h4><br><br>  Wouldn't it be better to make an improved protocol?  Which would include the following ... <br><ol><li>  Create a protocol that is less sensitive to RTT </li><li>  Fix pipelining and blocking the start of the queue </li><li>  Stop the need and desire to increase the number of connections to each host. </li><li>  Save existing interfaces, all content, URI format and schemas </li><li>  Do it within the IETF HTTPbis working group </li></ol><br><br><h5>  IETF and HTTPbis Working Group </h5><br><br>  The Internet Engineering Council (IETF) is an organization that develops and promotes Internet standards.  Mostly at the protocol level.  They are well known for a series of RFC documents documenting everything from TCP, DNS, FTP to best practices, HTTP, and many protocol options that have not been applied anywhere. <br><br>  Inside the IETF, there are dedicated ‚Äúworking groups‚Äù that are formed around a small circle of tasks to achieve the goal.  They constitute a ‚Äúcharter‚Äù of a set of principles and limitations for achieving the goal.  Anyone and everyone can join the discussion and development.  Everyone who participates and expresses something has equal opportunities and chances to influence the result and everyone is counted as people and individuals, without regard to the company in which the person works. <br><br>  The HTTPbis working group was formed during the summer of 2007 and had to update the HTTP 1.1 specification - hence the ‚Äúbis‚Äù suffix.  The group discussion of the new version of the HTTP protocol really began at the end of 2012.  Work on updating HTTP 1.1 was completed in early 2014. <br><br>  The final meeting for the HTTPbis working group before the expected final release of the http2 specification version will be held in New York in early June 2014. <br><br>  Some big players in the HTTP field were missing in the discussions and meetings of the working group.  I do not want to name any particular company or product name here, but it is clear that today some actors on the Internet appear to be confident that the IETF will do everything well without involving these companies ... <br><br><h5>  ‚ÄúBis‚Äù suffix </h5><br>  The group is named HTTPbis, where the ‚Äúbis‚Äù suffix is ‚Äã‚Äãderived from the Latin dialect, which means ‚Äútwo‚Äù.  Bis is often used as a suffix or part of a name inside the IETF for an update or a second attempt at working on a specification.  Also as in the case of HTTP 1.1. <br><br><h5>  http2 started with SPDY </h5><br><br>  <a href="http://en.wikipedia.org/wiki/SPDY">SPDY</a> is a protocol that was developed and initiated by Google.  They were definitely developing it openly and inviting everyone to participate, but it was obvious that they gained tremendous advantages by having control over two implementations: a popular web browser and a large population of servers with heavily used services. <br><br>  When the HTTPbis group decided to start working on http2, SPDY was already tested as a working concept.  He showed that it could be deployed on the Internet, and there were published figures that showed how he coped.  Work on http2 subsequently began with the SPDY / 3 draft, which by and large became the http2 draft-00 draft after a couple of search and replace operations. <br><br><h4>  Http2 concept </h4><br><br>  So what is http2 made for?  Where are the boundaries that limit the scope of the HTTPbis group? <br>  They are, in fact, quite clear and impose noticeable restrictions on the team‚Äôs ability to innovate. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e12/448/713/e124487134103eb8bed9720f69a9b428.png"><br><br><ul><li>  It must support HTTP paradigms.  This is still the protocol where clients send requests to the server over TCP. </li><li>  Links http: // and https: // can not be changed.  You cannot add a new schema or do something like this.  The amount of content that uses similar addressing is too large to ever expect such a change. </li><li>  HTTP1 servers and clients will exist for decades, we should be able to proxy them to http2 servers. </li><li>  Consequently, proxies must be able to convert one-to-one http2 features into HTTP 1.1 for clients. </li><li>  Remove or reduce the number of optional parts in the protocol.  This is not so much a requirement as a mantra, which came from SPDY and the Google team.  Insisting that all requirements are mandatory, you will not have the opportunity not to do something now, and then fall into the trap. </li><li>  No more minor versions.  It was decided that clients and servers can be either compatible with http2 or not.  If it turns out that you need to expand the protocol or change it, then http3 will appear.  The http2 will no longer be minor versions. </li></ul><br><br><h5>  http2 for existing URI schemes </h5><br><br>  As noted earlier, existing URI schemes cannot be changed, so http2 should only use them.  Since today they are used for HTTP 1.x, we need an explicit way to upgrade the protocol to http2 or otherwise ask the server to use http2 instead of old protocols. <br><br>  HTTP 1.1 already has a predefined method for this, the so-called Upgrade header, which allows the server to send a response using the new protocol when a similar request is received using the old protocol.  At the cost of one iteration of the request-response. <br><br>  Payoff request-response time was not what the SPDY team could agree on, and since they also developed SPDY over TLS, they created a new TLS extension, which was used to significantly reduce coordination.  Using this extension, called NPN from Next Protocol Negotiation (negotiation of the next protocol), the client informs the server on which protocols he would like to communicate and the server can respond to the most preferred one he knows. <br><br><h5>  http2 for https: // </h5><br><br>  Much attention in http2 was paid to ensure that it works correctly on top of TLS.  SPDY worked only on top of TLS and there was a strong desire to make TLS mandatory for http2, but consensus was not reached and http2 would be released with the optional TLS.  However, two well-known specification developers have clearly stated that they will only implement http2 over TLS: the head of Mozilla Firefox and the head of Google Chrome.  These are the two leading browsers for today. <br><br>  The reasons for choosing TLS-only mode are to take care of the user's privacy, and early research has shown a high level of success with new protocols when using TLS.  This is due to the widespread assumption that all that comes to port 80 is HTTP 1.1, and some intermediate network devices interfere and destroy the traffic of other protocols that run on this port. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc1/d1d/5aa/cc1d1d5aaad2821a8f28277a621f0598.png"><br><br>  The subject of compulsory TLS causes many sweep hands and campaign calls on mailing lists and meetings - is it good or evil?  This is a sore point - remember this if you decide to ask this question directly in the face of HTTPbis! <br><br><h5>  http2 negotiation over tls </h5><br>  The following protocol negotiation (NPN) is the protocol that SPDY used to negotiate with the TLS servers.  Since it was not a real standard, it was reworked into the IETF and the ALPN appeared instead: <i>Application Level Protocol Negotiation</i> .  ALPN is promoted for use in http2, while SPDY clients and servers still use NPN. <br>  The fact that NPN appeared first, and it took time for ALPN to go through standardization, led to the fact that early implementations of http2 clients and http2 servers used both of these extensions when negotiating http2. <br><br><h5>  http2 for http: // </h5><br><br>  As was briefly noted earlier, for text-based HTTP 1.1, in order to negotiate http2, you need to send a request to the server with the Upgrade header.  If the server understands http2, it will respond with ‚Äú101 Switching‚Äù status and then start using http2 in the connection.  Of course, you understand that this update procedure is worth the time of one complete network request-response, but on the other hand the http2 connection can be maintained and reused for much longer than the usual HTTP1 connection. <br><br>  Despite the fact that some representatives of browsers insist that they will not implement this method of matching http2, the Internet Explorer team has expressed its willingness to implement it. <br><br><h4>  Http2 protocol </h4><br><br>  Suffice it to say about prerequisites, history and politics, and now we are here.  Let's dive into the specifics of the protocol.  Those parts and concepts that make up http2. <br><br><h5>  Binary protocol </h5><br><br>  http2 is a binary protocol. <br><br>  Let's try to realize this for a moment.  If you were familiar with Internet protocols before, then it is likely that you instinctively strongly oppose this fact and prepare arguments about how useful it is to have protocols that use the / ascii text, and that you wrote HTTP 1.1 requests with your hands hundreds of times. connecting with a telnet to the server. <br><br>  http2 - binary to make the formation of packages easier.  Determining the beginning and end of a packet is one of the most difficult tasks in HTTP 1.1 and in all text protocols in principle.  By moving away from optional spaces and all sorts of ways to write the same things, we make implementation easier. <br><br>  In addition, it makes it much easier to separate the parts associated with the protocol itself and the data packet, which is randomly intermixed in HTTP1. <br><br>  The fact that the protocol allows the use of compression and often works on top of TLS also reduces the value of the text, since in any case you will no longer see plaintext in the wires.  We just have to understand that you need to use Wireshark analyzer or something similar to find out what happens at the protocol level in http2. <br><br>  Debugging of this protocol will most likely be performed by utilities such as curl, or by analyzing the network stream by the http2-dissector Wireshark or something like that. <br><br><h5>  Binary format </h5><br><br>  http2 sends frames.  There are many different frames, but they all have the same structure: <br>  The type, length, flags, flow identifier, and frame payload. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f86/b9e/9ad/f86b9e9ade6f1e8f09342e1039961e26.png"><br><br>  There are twelve different types of frames in the current http2 draft, including two, perhaps the most important, that are associated with HTTP 1.1: DATA (data) and HEADERS (headers).  I will describe some of the frames in more detail later. <br><br><h5>  Multiplexing streams </h5><br><br>  The stream identifier mentioned in the previous section describing the frame format binds each frame transmitted over http2 to a so-called ‚Äústream‚Äù.  A stream is a logical association.  An independent two-way sequence of frames exchanged between the client and the server within the http2 connection. <br><br>  A single http2 connection may contain multiple simultaneous open streams from either side exchanging frames of multiple streams.  Streams can be installed and used unilaterally or shared by both the client and the server, and can be closed by either party.  The order in which frames are sent is important.  The recipient processes the frames in the order they are received. <br><br>  Multiplexing streams means that packets of multiple streams are mixed within a single connection.  Two (or more) separate data trains are collected into one train, and then divided on the other side.  Here are two trains: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/531/7bc/c26/5317bcc26876dd8c2280f384c1d6ec71.png"><br><br>  They come together one at a time in mixed mode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/ba1/fbb/b17ba1fbbc774526df38b8b75172b3f4.png"><br><br>  In http2 we will see dozens and hundreds of simultaneous stream.  The price of creating a thread is very low. <br><br><h5>  Priorities and dependencies </h5><br><br>  Each thread has a priority used to show the other exchange participant which threads to consider as more important. <br><br>  The exact details of the work priorities in the protocol have changed several times and are still being discussed.  The idea is that the client can specify which of the threads is the most important and there is a dependency parameter that allows you to make one thread dependent on another. <br><br>  Priorities can be dynamically changed during the exchange, which allows the browser to be sure that when a user scrolls through a page filled with images, he can specify which images are most important, or when you switch tabs, he can increase the priority for threads that suddenly fall into focus. <br><br><h5>  Header compression </h5><br><br>  HTTP is a stateless protocol.  In short, this means that each request must contain the maximum number of details that are required by the server to execute the request without having to save a lot of metadata from the previous request.  Since http2 does not change any of these paradigms, it has to do the same. <br><br>  This makes HTTP repetitive.  When a client requests multiple resources from a single server, such as images on a web page, this turns into a large series of requests that look almost the same.  For a series of something almost the same, compression is self-evident. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/287/9b6/c4d/2879b6c4d438a06e498d019af2fd3160.png"><br><br>  As I already mentioned, as the number of objects on the page increases, the use of cookies and the size of requests also continue to grow.  Cookies should also be included in all requests that are almost always the same across multiple requests. <br><br>  The size of an HTTP 1.1 request became so large over time that it sometimes became larger than the original TCP window size, which made it extremely slow in sending, requiring a full send-receive cycle to receive an ACK confirmation from the server before the full request is sent .  Another argument for compression. <br><br><h5>  Compression is not an easy topic. </h5><br><br>  HTTPS and SPDY compression were found to be vulnerable to the <a href="http://en.wikipedia.org/wiki/BREACH_%2528security_exploit%2529">BREACH</a> and <a href="http://en.wikipedia.org/wiki/CRIME">CRIME attacks</a> .  By inserting a known text into the stream and observing how the encrypted output changes, the attacker could figure out what was sent. <br><br>  Compression for dynamic content in the protocol without the risk of being exposed to one of the known attacks, requires serious deliberation and attention.  What the HTTPbis team is trying to do. <br><br>  This is how <a href="httpbis-header-compression-07">HPACK</a> appeared, <i>HTTP / 2 Header Compression</i> , which, as the name suggests, is a compression format designed specifically for http2 headers and, strictly speaking, this is a separate Internet draft draft specification.  The new format is shared with other counter-measures, such as special flags, which ask intermediaries not to compress certain headers and optionally add extra empty data to the frames in order to complicate the attack on compression. <br><br><h5>  Data compression </h5><br><br>  Immediately before the release of draft 12, support for gzip compressed DATA frames was added.  Each frame is compressed individually, so there is no common context between them, but this slightly reduces the level of compression.  This feature corresponds to using gzip in Transfer-Encoding in HTTP 1.1.  An opportunity that is seldom used, but often discussed, as a failure in the protocol, at least for browsers. <br><br><h5>  Reset (reset) - changed my mind </h5><br><br>  One of the drawbacks of HTTP 1.1 is that when an HTTP message is sent with a Content-Length header of a certain length, you cannot just stop it.  Of course, you can often (but not always - I‚Äôll skip here a long explanation of why this is so) break the TCP connection, but at the cost of re-negotiating a new TCP connection. <br>  Now you can simply cancel the sending and start a new message.  This can be achieved by sending an http2 frame RST_STREAM, which thus prevents bandwidth waste and the need to break the connection. <br><br><h5>  Server push (server sending) </h5><br><br>  This feature is also known as ‚Äúcache‚Äù.  The idea is that if a client requests a resource X, and the server assumes that the client will probably then ask for resource Z, it sends this resource to the client without a request from him.  This helps the customer to put Z into his cache, and he will be there when needed. <br>  Sending a server is something that the client must explicitly allow the server, and even if it does, it can of its choice quickly cancel the sent stream using RST_STREAM if it was not needed by it. <br><br><h5>  Alternative services </h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After http2 adaptation, there are reasons to expect that TCP connections will be longer and last longer in working condition than it was with HTTP 1.x connections. The client will be able to do a lot of things that he wants within one connection to each host / site and this connection will probably be open for a very long time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will affect the operation of the HTTP balancers, and there may be situations where the site wants to offer the client to connect to another host. This may be for both performance reasons, but also the need for outages for maintenance or similar purposes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The server sends an </font></font><a href="httpbis-alt-svc-01"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alt-Svc header</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (or ALTSVC frame to http2), informing the client about the availability of an alternative service. Additional route to the same content using a different service, host and port number.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is expected that the client will try to asynchronously connect to the service and start using the alternative service if it works normally. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opportunistic TLS </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Alt-Svc header allows a server that provides content on http: // to inform the client about the presence of the same content available over the TLS connection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is partly a controversial opportunity. </font><font style="vertical-align: inherit;">This connection performs unauthenticated TLS and will not be marked ‚Äúsafe‚Äù anywhere: it will not show the lock in the program interface and does not inform the user that this is not the usual old open HTTP. </font><font style="vertical-align: inherit;">But it will be an opportunistic TLS and some people are very confident in opposing this concept.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flow control </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each individual stream in http2 has its own declared stream window, which the other side allowed to transfer data. If you imagine how SSH works, then this is very similar and done in the same spirit and style. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each stream, both ends tell each other that they still have room to accept input data, and the opposite end is allowed to send only a specified amount of data until the window is expanded.</font></font><br><br><h5>  Lock </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the draft draft-12, after a long discussion, a frame was added, called BLOCKED. </font><font style="vertical-align: inherit;">He can be sent once by the http2 member when he has data to send, but the control of the flow prohibits him from sending any data. </font><font style="vertical-align: inherit;">The idea is that if your implementation receives such a frame, you must understand that your implementation has missed something and / or you cannot achieve high data transfer rates because of this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quote from draft-12:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The BLOCKED frame is included in this version of the draft for easy experimentation. </font><font style="vertical-align: inherit;">If the result of the experiment does not give positive results, it will be deleted.</font></font><br></blockquote><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Http2 world </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What will it look like when http2 is accepted? </font><font style="vertical-align: inherit;">Will he be accepted?</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How does http2 affect ordinary people? </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http2 is not yet widely represented and used. We can not say exactly how everything goes. We have seen how SPDY was used and we can make some assumptions and calculations based on this and other past and current experiments. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/749/c2e/359/749c2e3598ce1baadf849b4c735db71f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http2 reduces the number of required network round-trips, completely avoids the turn-start blocking dilemmas at the expense of multiplexing and the rapid rejection of unwanted streams. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It allows you to work multiple parallel streams, the number of which can exceed the number of connections even in the most actively using modern sites sharding ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the priorities correctly used on the streams, the chances of obtaining important data earlier than the less important ones are much higher.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Putting it all together, I‚Äôll say that the chances are very high that this will speed up page loading and increase the responsiveness of websites. </font><font style="vertical-align: inherit;">In short: better feeling from the web surfing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How much faster and how much better we will see. </font><font style="vertical-align: inherit;">I do not think that we are ready to say so far. </font><font style="vertical-align: inherit;">Firstly, the technology is still still young, and secondly, we have not yet seen neat implementations of clients and servers that truly use all the power that the new protocol provides.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How does http2 affect web development? </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Over the years, web developers and web development environments have compiled a complete set of techniques and utilities to work around HTTP 1.1 issues, some of which are noted at the beginning of this document. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of these workarounds, which tools and developers now use without thinking about by default, are likely to hit http2 performance or at least not take advantage of all the benefits of the new http2 superpower. Sprites and embedding should not be used with http2. Sharding is likely to be bad for http2, since http2 benefits from using fewer connections.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem here is of course that web developers will have to develop and implement websites in a world where, at best, for a short period of time, there will be both HTTP 1.1 and http2 clients, and, for maximum performance by all users, It will be costly to offer two different versions of the site. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this reason alone, I suspect it will take some time before we see the full potential of http2.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> http2 implementation </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, trying to document specific implementations in documents like this is completely useless work, which is doomed to failure and will become obsolete in a very short period of time. Instead, I will explain the situation in a broad sense and direct the readers to the </font></font><a href="http2-spec/wiki/Implementations"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list of implementations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the http2 website. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/04e/100/4bc/04e1004bc47e67565ae09f65b0737032.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Already there are a large number of implementations and their number is growing day by day as you work on http2. At the same time, at the time of writing, there are 19 implementations, and some of them implement the latest draft specification. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/4e1/37e/def/4e137edef5b0769d6428d9b6a597eb09.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firefox has always been at the forefront of the latest version of the draft, Twitter continues to provide services on http2. Google launched support for draft-10 on some of its services in April.</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/4fd/8a7/e3a/4fd8a7e3add9adb4fad98309a54d59e6.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Support for curl and libcurl is made on the basis of a separate implementation of the http2 library, called nghttp2, which supports both plain http2 and on top of TLS. </font><font style="vertical-align: inherit;">curl can use TLS for http2 using one of the TLS libraries: OpenSSL, NSS or GnuTLS.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typical http2 criticism </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of developing a protocol, debates arose again and again, and, of course, there are a number of people who believe that the protocol turned out to be completely wrong. </font><font style="vertical-align: inherit;">I would like to point out some of the most typical complaints and arguments against him:</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúThe protocol is designed and made by Google‚Äù </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are also variations implying that the world is even more dependent and controlled by Google. </font></font> It is not true.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The protocol was developed internally by the IETF in the same way that protocols were developed over the last 30 years. </font><font style="vertical-align: inherit;">However, we are all grateful to Google for the unparalleled work on SPDY, which not only proved that it is possible to implement a new protocol in this way, but also helped get estimates of what we can get.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúThe protocol is only useful for browsers and large services‚Äù </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To some extent this is so. </font><font style="vertical-align: inherit;">One of the main reasons behind http2 development is fixing HTTP pipelining. </font><font style="vertical-align: inherit;">If in your case pipelining was not required, then http2 will not be particularly useful for you. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is certainly not the only achievement of the protocol, but the most significant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as services begin to understand all the power and capabilities of multiplexed streams in one connection, I expect that we will see an increase in the number of applications using http2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Small REST APIs and simple HTTP 1.x software applications will not benefit greatly from switching to http2. </font><font style="vertical-align: inherit;">But, nevertheless, there will be very few drawbacks for most users.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúUsing TLS makes it slow.‚Äù </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To some extent this is true. </font><font style="vertical-align: inherit;">TLS negotiation gives little overhead, but efforts are already underway to further reduce the number of request-responses for TLS. </font><font style="vertical-align: inherit;">The cost of performing TLS encryption, compared to plaintext, is not as insignificant and clearly visible, so more processor and time and electricity will be spent on the same traffic as in an insecure protocol. </font><font style="vertical-align: inherit;">How much and what consequences it will have - a topic for statements and measurements. </font><font style="vertical-align: inherit;">See, for example, </font></font><a href="https://istlsfastyet.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">istlsfastyet.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as one of the sources on the topic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http2 does not require the use of TLS, so we should not mix terms.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Most users on the Internet today want TLS to be more widely used, and we must help protect the privacy of users. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúNon-ASCII protocol spoils everything‚Äù </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, we like the idea of ‚Äã‚Äãseeing the protocol openly, as this makes debugging easier. </font><font style="vertical-align: inherit;">But text protocols are much more prone to errors and are prone to problems of proper parsing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you really cannot accept the binary protocol, then you will also not be able to accept both TLS and HTTP 1.x compression, which have been around for quite a long time.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Will http2 become widespread? </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's still quite early to say for sure, but I can guess and appreciate, and that's what I'm going to do here. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skeptics will say ‚Äúlook at how well IPv6 was done,‚Äù as an example of a new protocol that took decades to simply at least begin to be widely used. http2 is not IPv6 at all. This is a TCP-based protocol, using the usual HTTP update mechanism, port number, TLS, etc. It will not require replacing most routers and brandmauers at all.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google has proved to the world through its work on SPDY that such a new protocol can be implemented and used by browsers and services with several implementations in a fairly short period of time. Despite the fact that the number of servers on the Internet that today offer SPDY in the region of 1%, but the amount of data with which they work much more. Some of the most popular websites today offer SPDY. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http2, based on the same basic paradigms as SPDY, I‚Äôm sure it will probably be implemented even more actively, as this is the official IETF protocol. The implementation of SPDY has always been restrained by the stigma of ‚Äúthis is the Google protocol‚Äù. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behind the release are several well-known browsers. At least, the representatives of Firefox, Chrome and Internet Explorer have expressed their readiness to release a browser with support for http2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are several server providers that are likely to offer http2 soon, including Google, Twitter and Facebook, and we expect to see http2 support in popular web server implementations such as Apache HTTP Server and nginx. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> http2 in firefox </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Firefox tracks the draft specification very tightly and has provided support for the test http2 implementation for many months now. </font><font style="vertical-align: inherit;">During the development of the http2 protocol, clients and servers must agree on which version of the draft protocol they implemented, which makes the test run somewhat annoying, just be prepared for this.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turn it on first </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enter "about: config" in the address bar and look for an option called "network.http.spdy.enabled.http2draft". </font><font style="vertical-align: inherit;">Make sure it is set to true.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TLS only </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember that Firefox only implements http2 over TLS. </font><font style="vertical-align: inherit;">You will see http2 work in Firefox only when you go to https: // sites that support http2.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transparent! </font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any element anywhere in the interface will not say that you are working on http2. </font><font style="vertical-align: inherit;">You can't understand it that easily. </font><font style="vertical-align: inherit;">There is only one way to find out by turning on ‚ÄúWeb Development-&gt; Network‚Äù, check the response headers and see what you got from the server ... The response contains something about ‚ÄúHTTP / 2.0‚Äù and Firefox inserts its header with the name ‚ÄúX- Firefox-Spdy ‚Äù, as shown in this already outdated screenshot. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b57/4d6/bec/b574d6becb3bd1d64276473c978c2ac5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The headers that you see in network tools, when communicating over http2, are converted from http2 into similar to the old HTTP1.x headers.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> http2 in curl </font></font></h4><br><br>  curl     http2,    2013 . <br><br>   curl,      http2,  . curl          -,      ,   http2. <br><br><h5>   HTTP 1.x </h5><br><br>  curl    http2-     HTTP 1.x     ,         HTTP.         curl  HTTP .   curl   .  curl    HTTP 1.x      ,     http2-.           ,    HTTP    . <br><br><h5>   </h5><br><br> curl   http2    Upgrade.    HTTP-   HTTP 2, curl      http2,   . <br><br><h5> TLS    </h5><br><br> curl     TLS-    TLS-,   -     http2.   TLS  http2 ‚Äì    APLN ,   ,  NPN. <br><br>  curl    OpenSSL  NSS    ALPN  NPN.   GnuTLS    ALPN,   NPN. <br><br><h5>     </h5><br><br>   curl,     http2,   ,    TLS,     --http2 (¬´  http2¬ª). <br><br><h5>  libcurl </h5><br><br>      https://  http:// URL',       curl_easy_setopt CURLOPT_HTTP_VERSION   CURL_HTTP_VERSION_2,  libcurl   http2.         http2,  ,  -    HTTP 1.1. <br><br><h4>  http2 </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A large number of difficult decisions and compromises were made in http2. </font><font style="vertical-align: inherit;">After deploying http2, there is a way to upgrade to other working versions of the protocol, which makes it possible to create more revisions of the protocol afterwards. </font><font style="vertical-align: inherit;">It also brings a view and infrastructure that can support many different protocol versions at the same time. </font><font style="vertical-align: inherit;">Perhaps we do not need to completely remove the old when we create a new one? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http2 still has a lot of outdated HTTP 1 transferred to it because of the desire to keep the ability to proxy traffic in all directions between HTTP 1 and http2. </font><font style="vertical-align: inherit;">Some of this heritage makes it difficult to further develop and innovate. </font><font style="vertical-align: inherit;">Maybe http3 will be able to drop some of them? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What do you think is still missing in http?</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Further reading </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you think this document is a little simple in content or technical details, then additional resources are given that will satisfy your curiosity: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTPbis mailing list and its archives: </font></font><a href="http-wg/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lists.w3.org/Archives/Public/ietf-http-wg</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The current specification of the http2 draft and related HTTPbis group documents is: </font></font><a href="httpbis/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datatracker.ietf.org/wg/httpbis</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details of network solutions in http2 Firefox: </font></font><a href="http2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki.mozilla.org/Networking/http2</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details of the implementation of http2 in curl: </font></font><a href="http2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curl.haxx.se/dev/readme-http2.html</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website http2: </font></font><a href="http2.github.io/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http2.github.io</font></font></a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/221427/">https://habr.com/ru/post/221427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221417/index.html">It is likely that Google will cease to produce technology under the brand Nexus</a></li>
<li><a href="../221419/index.html">Localization as a ‚Äúred pill‚Äù: recipe and instructions for use</a></li>
<li><a href="../221421/index.html">Overview of memory cards microSD and USB OTG Leef flash drives</a></li>
<li><a href="../221423/index.html">Microsoft, Oracle and a number of other companies join anti-Russian sanctions.</a></li>
<li><a href="../221425/index.html">Samsung Galaxy S5 quick start, Vietnam prospects and Japan's steady growth - the main mobile news of the week</a></li>
<li><a href="../221429/index.html">Announced sales of Xbox One in China, for the first time since 2000</a></li>
<li><a href="../221431/index.html">Digest of materials on Windows Server 2012 / R2</a></li>
<li><a href="../221439/index.html">Everything will be mobile: an overview of the mobile advertising market of the Internet</a></li>
<li><a href="../221443/index.html">According to rumors, Google may submit a Nexus smart phone worth $ 100.</a></li>
<li><a href="../221445/index.html">Development Democracy: How Parallels uses customer voting to create new features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>