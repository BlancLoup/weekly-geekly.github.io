<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FPS and let your code wait</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, dear readers of Habr. This article is about frontend, javascript and fps. And today I would like to share my thoughts on the "blind" code, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FPS and let your code wait</h1><div class="post__text post__text-html js-mediator-article">  Greetings, dear readers of Habr.  This article is about frontend, javascript and fps.  And today I would like to share my thoughts on the "blind" code, which in fact does not take into account the performance of the execution environment.  And, of course, we will write another bike-stand - where without them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e4/39b/6a6/9e439b6a6ad8f674b6d8917ee39637ef.png" alt="image"><br><a name="habracut"></a><br><h3>  Foreword </h3><br>  There was a recent article on Geektimes - <a href="https://geektimes.ru/post/283748/">‚ÄúMozilla released the hardware statistics on client PCs</a> . <a href="https://geektimes.ru/post/283748/">‚Äù</a>  And an excellent comment from <a href="https://geektimes.ru/post/283748/">schetilin</a> expressing the main problem - <blockquote>  Here our statistics writers would see this statistics.  And now they are creating sites for which i7 32Gb is not enough. </blockquote><br>  And there was also an article <a href="https://habrahabr.ru/company/mailru/blog/318282/">‚ÄúThe Truth about Traditional JavaScript Benchmarks</a> . <a href="https://habrahabr.ru/company/mailru/blog/318282/">‚Äù</a>  The essence of which is that parrots are good for comparing parrots, but not for real use. <br><br><h3>  Blah blah blah... </h3><br>  Imagine a situation - Vasya, a super developer, is sitting and writing his cool code, running it on his no less steep "Mac".  And ... the site works great, the animation is beautiful, the scrolling is fast and smooth. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But the user Petya sat down at his laptop and decided to go to the website of the online store for which, by the way, Vasya writes the code.  And ... it started - animated galleries, banners, pop-up windows, and somewhere else in the depths, the parsing of some data from the server is started.  All this is periodically accompanied by a wait icon.  Petya's laptop is in a state of shock, and Petya himself starts cursing Vasya in absentia.  Let's figure out who the "extreme". <br><br>  ‚ÄúPetya is an <s>un-</s> advanced user, let him update the hardware,‚Äù you say.  But the user is not obliged to adjust to each site; this is the business of the site to provide a quality interface. <br><br>  ‚ÄúVasya is a bad developer!‚Äù You say.  And in vain, Vasya does his best to optimize his code, but he cannot test it on all platforms for all hardware configurations.  And here a question arises to browser developers, why not provide the web developer with at least some information about the performance of the system on which the JS code is executed.  Well, is it true that, for example, what knowledge does the browser use?  This gives the developer knowledge of what syntax and API he can use.  And how it will help, for example, in choosing a timeout when splitting a resource-intensive task into parts.  For each version of the browser / engine, for each operating system and hardware configuration, the optimal timeout will be different. <br><br>  Imagine if the web developer had at least an approximate performance index that would take into account the type of OS and the hardware configuration.  Then it would be at index 2 out of 10, it would be possible to disable all animations altogether and vice versa at 10 to use in full.  Well, it would be nice to have statistical tables with typical tasks execution time (for example, inserting 100 rows into a table) for each index.  But as far as I know, there is nothing like that. <br><br><h3>  Counters </h3><br>  Well, we don‚Äôt have direct data on the performance of the system on which our code is executed.  But there is FPS (Frames Per Second) - a great indirect indicator.  High FPS is what the user needs for comfortable navigation, and this is what the developer can measure.  And if we can measure, then we can use this metric in some conditions.  Fine, we go further ... <br><br>  <i>Help:</i> <br><br><blockquote>  FPS is the number of frames per second on the monitor screen.  For browsers, this is the number of times per second when the browser updates the interface. <br><br>  In general, the process of drawing in the browser is not so simple.  The browser tries not to redraw the entire page, splits the page into layers and a whole lot more, God knows what.  Climb into the wilds of this process, now there is no meaning, and the rendering algorithm can vary from version to version.  In principle, it‚Äôs enough to remember one rule - if you often refer to a DOM element, you need to pull it out of the main structure, i.e.  position it fixed or absolutely. </blockquote><br>  So, we need to measure FPS.  It is known that browsers try to update the interface about 60 times per second (i.e., the ideal FPS is 60).  And there is the <a href="https://learn.javascript.ru/js-animation">requestAnimationFrame ()</a> method, which allows you to schedule the execution of our code before the next interface redraw.  This method is strongly recommended to use for all animations, instead of setTimeout / setInterval, which can cause forced redrawing, which increases the load on the system. <br><br>  We write FPS counter: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frameCount = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_fc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timeStart</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> now = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> duration = now - timeStart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duration &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>){ _fc.counter++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _fc.fps = _fc.counter; _fc.counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeStart = now; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(_fc.fps); } requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> frameCount(timeStart)); } frameCount.counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount.fps = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount(performance.now())</code> </pre> <br>  The meter thinks well, you can see this in the console.  But it operates with seconds, and the code is executed much faster - units and fractions of milliseconds.  Let's try to shorten the counting period as much as possible, for example, to 100 ms.  Of course, this will inevitably reduce the accuracy, but the speed increase will be as much as 10 times. <br><br>  FPS fast counter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frameCount = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_fc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timeStart</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> now = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> duration = now - timeStart; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(duration &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>){ _fc.counter++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _fc.fps = _fc.counter * <span class="hljs-number"><span class="hljs-number">10</span></span>; _fc.counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeStart = now; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(_fc.fps); } requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> frameCount(timeStart)); } frameCount.counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount.fps = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount(performance.now())</code> </pre> <br>  And then it dawned on me - why not use both counters.  Get some system of counters - one quick and one accurate.  We'll see‚Ä¶ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frameCount = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_fc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastTimeStart, preciseTimeStart</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> now = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fastDuration = now - <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastTimeStart || _fc.startTime</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">let</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseDuration</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">now</span></span></span><span class="hljs-function"> - (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseTimeStart || _fc.startTime</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastDuration &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">){ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastCounter</span></span></span><span class="hljs-function">++; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">else</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastFPS</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastCounter</span></span></span><span class="hljs-function"> * 10; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastCounter</span></span></span><span class="hljs-function"> = 0; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fastTimeStart</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">now</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc.fastFPS</span></span></span><span class="hljs-function">); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseDuration &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span></span><span class="hljs-function">){ </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseCounter</span></span></span><span class="hljs-function">++; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">else</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseFPS</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseCounter</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseCounter</span></span></span><span class="hljs-function"> = 0; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">preciseTimeStart</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">now</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">console</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_fc.preciseFPS</span></span></span><span class="hljs-function">); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestAnimationFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> frameCount(fastTimeStart, preciseTimeStart)); } frameCount.fastCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount.fastFPS = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount.preciseCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount.preciseFPS = <span class="hljs-number"><span class="hljs-number">0</span></span>; frameCount.startTime = performance.now(); frameCount()</code> </pre> <br>  Now we can at least somehow assess the current state of the execution environment.  But, all the same, I had the feeling that everything was not done.  And again I decided to experiment ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc1/905/b60/dc1905b60de8346d5ab0bf5775830696.png" alt="image"><br><br>  The figure shows that we spend one cycle (frame) to reset the counter, and the real counting begins with the next cycle.  Reduce the counting time, while we will not reset the counter.  It will also give a small gain in FPS counting speed.  The new counting period is defined as <b>(100/6) * 5 = 83</b> for a fast counter and <b>(1000/60) * 59 = 983</b> for an exact. <br><br><h3>  Time-out </h3><br>  The metric that we will focus on is mined.  Now we need a mechanism for managing the time of code execution.  And since we need such parameters as timeout and delta, the value of the timeout change.  But, the question immediately arises, how to determine the optimal value of these parameters?  The answer is simple - immediately, no way.  Need data, need statistics.  Although the timeout control mechanism itself is quite possible to determine.  It will be extremely simple: <br><br><pre> <code class="javascript hljs">timeoutCorrection(){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fastFPS &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; timeout &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>){ timeout += delta; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fastFPS &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; timeout &gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) { timeout -= delta; } }</code> </pre> <br>  From the code it can be seen that the landmark goes by an amount of <b>20 FPS</b> (fastFPS * 10), or rather a slightly larger one - " <b>&lt;=</b> ".  Values ‚Äã‚Äãof <b>16</b> and <b>1000</b> are limits.  The minimum timeout is 16, it is 60 FPS.  And the maximum is chosen as 1000, corresponding to 1 FPS. <br><br>  It is assumed that the timeout correction function will be called each time a new FPS counter is set. <br><br><h3>  Executor </h3><br>  We measure FPS, timeout is manageable.  Now we need an executor - a function that, on the basis of this data, will control the execution of the code, or, more precisely, just slow down calls when necessary.  We write ... <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> requestAdaptiveAnimation = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_raa</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb, priority, timeout, ...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_raa.cbsStore.has(cb) || timeout){ _raa.cbsStore.add(cb); _raa.queue = _raa.queue.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">)=&gt;</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ cb(...args); res(); }); }, timeout || <span class="hljs-number"><span class="hljs-number">0</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(frameCount.fastFPS &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> || priority){ requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>cb(...args)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( frameCount.preciseFPS &lt; <span class="hljs-number"><span class="hljs-number">15</span></span>){ _raa.queue = _raa.queue.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">)=&gt;</span></span>{ requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ cb(...args); res(); }); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>cb(...args)); }, _raa.timeout); } requestAdaptiveAnimation.cbsStore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); requestAdaptiveAnimation.queue = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve();</code> </pre> <br>  This function is intentionally named similar to <b>requestAnimationFrame</b> , since it is this method that underlies it.  Those.  we do any interface updates via requestAnimationFram.  But since using this method you cannot set a timeout, we make wrappers with setTimeout. <br><br>  On the basis of a chain of promises, an asynchronous queue is organized, which firstly allows you to set a timeout, and secondly prevents the "avalanche" execution of the code. <br><br>  The <b>requestAdaptiveAnimation</b> algorithm <b>is</b> as follows: <br><br><ul><li>  If the transferred callback is used for the first time or the timeout is set, then the callback execution is placed in a common queue. </li><li>  If it is an animation and the same callback is called several times, then when the FPS fast counter is high, you can directly call the requestAnimationFram. </li><li>  If the FPS exact counter value fell below the critical threshold of <b>15</b> , then the callback is queued.  Visually, it looks like a temporary freezing animation.  The number 15 is chosen subjectively, in my opinion, the value of the page scroll can still be called acceptable. <br></li><li>  By default, we call requestAnimationFrame, through a corrected timeout. </li></ul><br><h3>  Tests </h3><br>  It is time to put everything together and test it.  And besides, there is still an unsolved problem with timeout and delta.  For testing, I wrote a small <a href="http://priladnykh.ru/articles/adaptation_v1/adaptation.html">stand</a> , and began to look at different ratios of the timeout and the delta. <br><br>  Initially, I decided to correlate the timeout and delta with the number of animated objects.  And I had such considerations - the more elements, the greater the start timeout value, and the delta is correspondingly less, otherwise there will be strong fluctuations in timeout and animation. <br><br>  Thus, the calculation was reduced to: <br><br><pre> <code class="javascript hljs">timeout = numberObjects; delta = <span class="hljs-number"><span class="hljs-number">1</span></span>/numberObjects;</code> </pre> <br>  But it worked poorly, and I decided to introduce a correction factor - <b>ratio</b> .  The calculation came down to: <br><br><pre> <code class="javascript hljs">timeout = numberObjects/ratio; delta = ratio/numberObjects;</code> </pre> <br>  I began to change this coefficient and watch the graphs. <br><br>  100 objects: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02f/65e/50d/02f65e50d718c69502b9ebf9976b0d6b.png"><br><br>  500 objects: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e79/c26/f2e/e79c26f2efa79027cd3216173e873b7e.png"><br><br>  1000 objects: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c36/6ce/f0e/c366cef0ec68756bb157c04a8ddf92cb.png"><br><br>  2000 objects: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8e/46c/739/c8e46c7399310f6af60f7861dfbce38f.png"><br><br>  This chart is interesting because it shows the inclusion of the "saving" queue mechanism with FPS below 15 frames. <br><br>  Comparative plate: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/005/d68/c75/005d68c75b21d0730a6e9bb474e399e7.png"><br><br>  On the plate we select the best options and continue to test. <br><br>  Here it is necessary to explain a little.  Although we specify to animate 1000 elements, in fact, because of the queue of initial calls, at the same time I have animated no more than 300. This is due to the fact that at the beginning of the animation, for example, the 300th element, the animation of the first has already ended. <br><br>  Here is what it looks like (a piece of about 300 elements): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86b/852/c1e/86b852c1e84fa5c55e0242f2fd110e42.png"><br><br>  1000 objects, short animations (comparison of the best from the table): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1a/ac1/f54/f1aac1f54456cb0feeefdd58ab7c80ed.png"><br><br>  Now we will increase the length of the animation (I just did the maximum scaling of the page) and again we will start. <br><br>  How it looks now (all elements - 1000): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/700/b60/427/700b604277e267c9ff0257203a8e7a2a.png"><br><br>  Now you can see that all elements are animated at the same time. <br><br>  1000 objects, long animations (comparison of the best from the table): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/376/56d/cbe/37656dcbee93ac1527f31409e534f191.png"><br><br>  The graph shows that the ‚Äúsaving‚Äù queue mechanism is not activated only when <b>timeout</b> (elements / ratio) and <b>delta</b> (ratio / elements) equal <b>1</b> - the pink line on the graph. <br><br>  So, with the timeout and delta determined.  Now it's time to compare with native methods - <b>setInterval</b> , <b>setTimeout</b> , <b>requestAnimationFrame</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a3/40f/f38/6a340ff38f278fb5dc41c39f0cca38a2.png"><br><br>  From the graph it is clear that with a small number of elements we have a minimal overhead projector.  When the adaptation mechanism is turned on, the duration of the code execution certainly increases, but the FPS remains at level <b>30</b> .  Native methods drain FPS to <b>7-8</b> . <br><br>  It would seem that's all.  But no, I ran all the tests on a laptop, and the original purpose of all this writing is to work on different systems with different configurations.  Therefore, we check all the same, but on the desktop. <br><br>  Comparison with native methods on short animations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a88/6c9/315/a886c9315a8fd339d3b1bcce7a3a4f7f.png" alt="image"><br><br>  Comparison with native methods on long animations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c0/885/f06/0c0885f06dbfb42cb619b881edce0e9d.png" alt="image"><br>  It can be seen that on the laptop (CPU: A8, RAM: 8Gb) and on the desktop (CPU: i5, RAM: 8Gb) the operation is similar - FPS remains at level 30. The only difference is in how much the code execution stretches in time . <br><br><h3>  Results </h3><br>  Good: <br><br><ul><li>  The mechanism works, FPS is saved </li><li>  Saving the FPS level regardless of the browser (Firefox, Chrome) </li><li>  Maintain FPS level regardless of system performance </li></ul><br>  Poorly: <br><br><ul><li>  Independence among themselves of different animations.  Because of this, animations that are started later under certain conditions may end earlier. </li></ul><br>  ‚ÄúWell, now, that's it,‚Äù I thought.  But that strange feeling ... and I decided again ... <br><br><h3>  PS </h3><br>  Good mood to you all.  Comments and criticism are welcome.  The only request, if you put a minus, then drop a few lines for what it is. </div><p>Source: <a href="https://habr.com/ru/post/319302/">https://habr.com/ru/post/319302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319290/index.html">The introduction of social services in non-game application</a></li>
<li><a href="../319294/index.html">Why did Tesla lure away the Swift language creator from Apple</a></li>
<li><a href="../319296/index.html">The structure of the project folder designer</a></li>
<li><a href="../319298/index.html">Draw commits on Github</a></li>
<li><a href="../319300/index.html">Economy of ideas. Composable infrastructure. HPE Synergy</a></li>
<li><a href="../319304/index.html">Iframe injection and self xss on more than 20,000 sites alexarank UA / RU</a></li>
<li><a href="../319310/index.html">Hack the future! PHDays again invites authors to a cyberpunk contest</a></li>
<li><a href="../319314/index.html">The evolution of the process of deployment in the project</a></li>
<li><a href="../319318/index.html">SCADA: in search of the ideal</a></li>
<li><a href="../319320/index.html">Working with DSL: creating your own analyzer using Python libraries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>