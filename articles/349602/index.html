<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flags in function arguments</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever come across this code? 



process(true, false);  
 This function, judging by the name, processes something (process). But what do the p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flags in function arguments</h1><div class="post__text post__text-html js-mediator-article">  Have you ever come across this code? <br><br><pre><code class="cpp hljs">process(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  This function, judging by the name, processes something (process).  But what do the parameters mean?  Which parameter is true and which is false?  This code cannot be judged by the calling code. <br><br>  We will have to look into the function declaration, which gives a hint: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withValidation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withNewEngine)</span></span></span></span>;</code> </pre> <br>  Obviously, the author uses two parameters of bool type as <i>flags</i> (toggles).  The implementation of the function may look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withValidation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withNewEngine)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withValidation) <span class="hljs-comment"><span class="hljs-comment">//  1-  validate(); // %  do_something_toggle_independent_1 if (withNewEngine) //  2-  do_something_new(); else do_something_old(); do_something_toggle_independent_2(); }</span></span></code> </pre> <br>  The purpose of the flags is obvious, since each of them has a meaningful name.  The problem occurs in the calling code. <a name="habracut"></a>  And it's not just that we cannot immediately understand which flags are used.  Even knowing this, we can easily confuse their order.  In fact, my first example should look like this: <br><br><pre> <code class="cpp hljs">process(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  But I confused the order of the arguments. <br><br>  Faced with this bug, the programmer is likely to add comments to the function call to explicitly show his intentions: <br><br><pre> <code class="cpp hljs">process(<span class="hljs-comment"><span class="hljs-comment">/*withValidation=*/</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*withNewEngine=*/</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  And this is too similar to the named parameters of a function ‚Äî a feature not found in C ++.  If she was, she could look something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  C++  : process(withValidation: false, withNewEngine: true);</span></span></code> </pre> <br>  But even if it were in C ++, it would hardly be compatible with direct forwarding (perfect forwarding): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)&gt; callback = &amp;process; callback(???, ???); <span class="hljs-comment"><span class="hljs-comment">//   ?</span></span></code> </pre> <br>  This can be associated with an even more insidious bug that is much harder to track down.  Imagine that the process function is a virtual class method.  And in some other class we redefine it, while placing the flags in the wrong order: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withValidation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withNewEngine)</span></span></span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withNewEngine, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withValidation)</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> <br>  The compiler will not notice the problem, since the parameters differ only by name, and their types are the same (both bool). <br><br>  The bugs arising from the use of logical parameters in the interface do not end there.  Due to the fact that almost all built-in types are converted to bool, the following example compiles without errors, but does not what is expected: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec; process(vec.data(), vec.size());</code> </pre> <br>  A more common problem is using bool in constructors.  Let there is a class with two constructors: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withDefaults, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withChecks)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; };</code> </pre> <br>  At some point you decide to remove the second constructor, and it may be hoped that the compiler will point you to all the places that need fixing.  But this is not happening.  Due to implicit conversions in bool, the first constructor will be used wherever the second one was used. <br><br>  However, there is a reason why people usually use bool to represent flags.  This is the only built-in type available out of the box and intended to represent only two possible values. <br><br><h4>  Transfers </h4><br>  To solve these problems, we must have a type other than bool that would satisfy the following requirements: <br><br>  - a unique type is created for each flag, <br>  - implicit conversions are prohibited. <br><br>  C ++ 11 introduces the concept of enumeration classes that satisfy both requirements.  We can also use the bool type as the base type of the enumeration;  thus, we guarantee that the enumeration contains only two possible values ‚Äã‚Äãand has the size of one bool.  First we define the flag classes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithValidation</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { False, True }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WithNewEngine</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { False, True };</code> </pre> <br>  Now we can declare our function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WithValidation withValidation, WithNewEngine withNewEngine)</span></span></span></span>;</code> </pre> <br>  There is some redundancy in this declaration, but the order of using the function is now what it needs: <br><br><pre> <code class="cpp hljs">process(WithValidation::False, WithNewEngine::True); <span class="hljs-comment"><span class="hljs-comment">// ok</span></span></code> </pre> <br>  And if I put the flags in the wrong order, I get a compilation error due to the type mismatch: <br><br><pre> <code class="cpp hljs">process(WithNewEngine::True, WithValidation::False); <span class="hljs-comment"><span class="hljs-comment">// !</span></span></code> </pre> <br>  Each flag has a unique type that works properly during forwarding (perfect forwarding), and you can‚Äôt put the parameters in the wrong order in the function declarations and virtual method overrides. <br><br>  But using transfers as flags has its price.  Flags are somewhat similar to bool values, but enumeration classes do not imitate this similarity.  Implicit conversions to bool and back do not work (and this is good), but explicit conversions do not work either, and this is a problem.  If we look again at the body of the process function, we will understand that it does not compile: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WithValidation withValidation, WithNewEngine withNewEngine)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withValidation) <span class="hljs-comment"><span class="hljs-comment">// :     bool validate(); // ... }</span></span></code> </pre> <br>  I have to use an explicit conversion: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(withValidation)) <span class="hljs-comment"><span class="hljs-comment">// ok validate();</span></span></code> </pre> <br>  And if I need a logical expression with two flags, it will look even more inadequate: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(withNewEngine) || <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(withValidation)) validate();</code> </pre> <br>  In addition, for an instance of an enumeration class, you cannot do direct initialization from bool: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> WithNewEngine _withNewEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: X() : _withNewEngine(read_bool()) <span class="hljs-comment"><span class="hljs-comment">//  {} };</span></span></code> </pre> <br>  Again you have to do an explicit conversion: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> WithNewEngine _withNewEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: X() : _withNewEngine(WithNewEngine(read_bool())) <span class="hljs-comment"><span class="hljs-comment">// ok {} };</span></span></code> </pre> <br>  This can be considered an additional guarantee of security, but there are too many explicit conversions.  Enumeration classes have more ‚Äúexplicit‚Äù than constructors and transformation operators declared as ‚Äúexplicit‚Äù. <br><br><h4>  tagged_bool </h4><br>  Due to problems with using bool and enumeration classes, I had to make my own tool called tagged_bool.  You can find its implementation <a href="">here</a> .  She is quite small.  With its help, flag classes are declared like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WithValidation = tagged_bool&lt;class WithValidation_tag&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WithNewEngine = tagged_bool&lt;class WithNewEngine_tag&gt;;</code> </pre> <br>  You will have to pre-declare a class tagname, such as WithValidation_tag.  There is no need to write a definition for it.  It is used to create a unique tagging_bool class template specialization.  This specialization can be explicitly converted to bool and back, as well as to other specializations of the tagged_bool template, since, as is usually the case in practice, some bool passed to the lower levels of the application will later become another flag with a different name.  You can use the flags created in this way like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WithValidation withValidation, WithNewEngine withNewEngine)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withNewEngine || withValidation) <span class="hljs-comment"><span class="hljs-comment">// ok validate(); // ... } process(WithValidation{true}, WithNewEngine{false}); // ok process(WithNewEngine{true}, WithValidation{false}); // </span></span></code> </pre> <br>  That's all.  The tagged_bool is part of the <a href="https://github.com/akrzemi1/explicit">Explicit library</a> , which contains several tools that allow you to more explicitly express your intentions when designing interfaces. <br><br><h4>  From translator </h4><br>  Andrzej previously had another article about tags - ‚Äú <a href="https://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/">Intuitive interface - Part I</a> ‚Äù dated July 5, 2013 (Part 2 never came to light, do not search).  In short, there was such a problem: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v1{<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// 2 : {5, 6} std::vector&lt;int&gt; v2(5, 6); // 5 : {6, 6, 6, 6, 6}</span></span></code> </pre> <br>  When the behavior of a constructor depends on the form of parentheses, this in itself is dangerous.  In addition, it makes the calling code incomprehensible: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre> <br>  What are 5 and 6?  Will it be 5 sixes or 6 fives?  If you forgot - go to see the documentation. <br><br>  And I would like to have another constructor that creates an empty vector with a given capacity: std :: vector v (100).  Unfortunately, the constructor that accepts one size_t is already taken ‚Äî it creates a vector with the given size, filled with default-constructed objects. <br><br>  Andrzej mentions that such an order of things does not make it possible to take full advantage of the possibilities of the direct transmission, but explained in the comments that this problem is solved without any tags. <br><br>  Andrzej came to the conclusion that the implementation of the vector in the STL library is not entirely successful.  It would be much easier if tags were used in its constructors: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v1(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::with_size, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::with_value, <span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre> <br>  In relation to this article, it would look like this: <br><br><pre> <code class="cpp hljs">process(withValidation, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, withNewEngine, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok process(withNewEngine, true, withValidation, false); // </span></span></code> </pre> <br>  The difference is that the tag and value are now merged into one object.  In the article ‚Äú <a href="https://akrzemi1.wordpress.com/2016/06/29/competing-constructors/">Competing constructors</a> ‚Äù dated July 29, 2016, Andrzej wrote in passing that he did not like the idea of ‚Äã‚Äãsuch a union. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; w {with_size{<span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// {2, 2, 2, 2} vector&lt;int&gt; x {with_size{4}}; // {0, 0, 0, 0} vector&lt;int&gt; y {with_capacity{4}}; // {}</span></span></code> </pre> <br>  Now it is not tags, but full-fledged objects.  Someone might think of putting them in a container: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;with_size&gt; w {with_size{<span class="hljs-number"><span class="hljs-number">4</span></span>}, with_size{<span class="hljs-number"><span class="hljs-number">2</span></span>}};</code> </pre> <br>  The behavior of this code again depends on the form of the brackets.  What kind of joy was introducing tags if we returned to the same problem again?  At least, simple tags are unlikely to anyone want to store in a container.  After all, they can have only one value. <br><br>  With bool, however, this threat is not so terrible.  STL container constructors do not accept bool, except as part of initializer_list'ov.  Apparently, this is why Andrzej decided this time to merge the tag and meaning. <br><br>  Finally, I will cite the translation of several comments on the article. <br><br><h4>  Comments </h4><br>  <b>kszatan</b> <br>  <i>February 17, 2017 at 11:36 am</i> <br>  I would first of all think about getting rid of all these flags and bring the code for validations and the new / old engine (new / old engine) to separate classes in order to pass them as arguments.  The "process" function is already doing too much. <br><br>  <b>Andrzej Krzemie≈Ñski</b> <br>  <i>February 17, 2017 at 12:03 pm</i> <br>  In simple cases, dropping any flags may indeed be the best choice.  But when the decision to set a flag is made several levels higher in the call stack, such refactoring may not be feasible or impractical. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Revert revert_to_old_functionality {read_from_config()}; Layer1::fun(revert_to_old_functionality) } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Layer1::fun(Revert revert) { <span class="hljs-comment"><span class="hljs-comment">// something else... Layer2::fun(revert); }; void Layer2::fun(Revert revert) { // something else... Layer3::fun(revert); }; void Layer3::fun(Revert revert) { // something else... if (revert) do_poor_validation(); else do_thorough_validation(); };</span></span></code> </pre> <br>  === End of thread === <br><br>  <b>micleowen</b> <br>  <i>February 17, 2017 at 10:41 pm</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withDefaults, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withChecks)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; };</code> </pre> <br>  ‚ÄúExplicit‚Äù is used in constructors with one parameter. <br><br>  <b>Andrzej Krzemie≈Ñski</b> <br>  <i>February 20, 2017 at 8:22 am</i> <br><br>  There is a solid reason to declare almost all constructors as ‚Äúexplicit‚Äù, and not just constructors with 1 argument (especially with the release of the C ++ 11 standard).  Sometimes even the default constructor is better to be declared as ‚Äúexplicit‚Äù.  For those interested, I advise you to refer <a href="https://akrzemi1.wordpress.com/2015/10/22/more-than-you-need/">to this article</a> . <br>  === End of thread === <br><br>  <b>ARNAUD</b> <br>  <i>February 18, 2017 at 6:39 pm</i> <br><br>  ‚ÄúImplicit conversions to bool and back do not work (and this is good), but explicit conversions do not work either, and this is a problem.‚Äù <br><br>  I do not understand what's wrong with that: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(withValidation == WithValidation::True)</code> </pre> <br>  First, you use the well-known possibility of the language, and your code is perfectly readable and understood by all C ++ specialists.  Then you go to use a special template to automatically convert to bool and back?  It does not convince me. <br><br>  And further.  Imagine that after some time one of the parameters will cease to be bool and will be able to take the values ‚Äã‚Äãno_engine, engine_v1, engine_v2 ... The enumeration class allows you to make such an extension in a natural way, unlike your tagged_bool. <br><br>  <b>Andrzej Krzemie≈Ñski</b> <br>  <i>February 20, 2017 at 8:36 am</i> <br><br>  You raised two questions. <br><br>  1. Choose between <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withValidation || withNewEngine)</code> </pre> <br>  and <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withValidation == WithValidation::True || withNewEngine == WithNewEngine::True)</code> </pre> <br>  And, in the case of using namespaces: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withValidation == SomeNamespace::WithValidation::True || withNewEngine == SomeNamespace::WithNewEngine::True)</code> </pre> <br><br>  For me, this is a trade-off between the desired level of security and usability.  My personal choice is something safer than bool, but not as wordy as enumeration classes.  Apparently, your compromise is closer to the classes of transfers. <br><br>  2. The ability to add a third state <br><br>  If you foresee that you may need a third state in the future, then enumeration classes may be preferable.  And may not be.  Because when you add the third state, all your ifs continue to compile properly, although you may want to edit them to add a third state check. <br><br>  In my experience, these flags are used as temporary solutions, and their further development is not to add a third state, but to get rid of two existing ones.  For example, I improve some part of the program, but for a couple of months I want to give users the opportunity to switch back to the old implementation, in case I overlooked something, and improving will only ruin everything.  If after a couple of months all users are satisfied, I remove the support of the old implementation and get rid of the flag. <br><br>  === End of thread === <br><br>  <b>mftdev00</b> <br>  <i>March 13, 2017 at 1:05 pm</i> <br><br>  I don't like flags at all.  They contradict the principle of sole responsibility.  Do something, if true, do something else, if false ... <br><br>  <b>Andrzej Krzemie≈Ñski</b> <br>  <i>March 13, 2017 at 1:10 pm</i> <br><br>  I agree.  Wherever possible, you need to do without flags. <br><br>  === End of thread === <br><br>  <b>Sebb</b> <br>  <i>March 21, 2017 at 6:09 pm</i> <br><br>  Is it possible instead of explicitly removing constructors for each type: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagged_bool</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> : value </span></span>{v} {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagged_bool</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagged_bool</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagged_bool</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br>  ... just delete them for all types (except bool) at once? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagged_bool</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> : value </span></span>{v} {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> SomethingOtherThanBool&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagged_bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SomethingOtherThanBool)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br>  <b>Andrzej Krzemie≈Ñski</b> <br>  <i>March 22, 2017 at 7:32 am</i> <br><br>  I just did not consider this possibility when I developed the interface.  Maybe it would be useful to add it.  But now, when you suggested it, I see one case where it would have a negative effect: someone can use their own (safe) boolean type with an implicit conversion to bool.  In this case, we may need to allow this type to work with tagged_bool. </div><p>Source: <a href="https://habr.com/ru/post/349602/">https://habr.com/ru/post/349602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349590/index.html">Errors in robots: expectation and reality</a></li>
<li><a href="../349592/index.html">"Competition" for the best software implementation, displaying the number of "forty-two"</a></li>
<li><a href="../349594/index.html">How to build a community. Translation of the book ‚ÄúSocial Architecture‚Äù: Chapter 4. Protocol for the C4 Collaboration</a></li>
<li><a href="../349596/index.html">The hierarchy of IT-systems and the choice of software for the organization of work</a></li>
<li><a href="../349598/index.html">The work of a large distributed team: the advantages of remoteness, problem solving, useful tools</a></li>
<li><a href="../349604/index.html">Flask Mega-Tutorial, Part XII: Dates and Times (Edition 2018)</a></li>
<li><a href="../349610/index.html">DevOps was invented by developers so that admins work more</a></li>
<li><a href="../349612/index.html">UX Cinema - Emotions. The senses. Interview</a></li>
<li><a href="../349616/index.html">How-to: change of the main domain in the G Suite for the entire company and with the preservation of all data</a></li>
<li><a href="../349618/index.html">Code Integrity Protection with PGP. Part 1. Basic concepts and tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>