<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing a search engine with Python rankings (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Looking through the news feed, I came across a recommendation from a Typical Programmer on the article ‚ÄúImplementing a Search Engine with Ranking in P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing a search engine with Python rankings (Part 1)</h1><div class="post__text post__text-html js-mediator-article">  <i>Looking through the news feed, I came across a recommendation from a Typical Programmer on the article <a href="http://aakashjapi.com/fuckin-search-engines-how-do-they-work/">‚ÄúImplementing a Search Engine with Ranking in Python‚Äù</a> written by Aakash Japi.</i>  <i>She interested me, there is not a lot of similar material in runet, and I decided to translate it.</i>  <i>Since it is quite large, I will divide it into 2-3 parts.</i>  <i>At this point, I finish my introduction and turn to the translation.</i> <br><br>  Every time I use Quora, I end up with at least a question like <a href="http://www.quora.com/I-am-confident-that-I-am-going-to-build-a-search-engine-that-will-compete-with-Google-at-least-in-the-smallest-scale-possible-first-but-for-now-I-dont-know-any-programming-What-should-I-do">this</a> : someone asks how Google works and how they could beat it in information search.  Most of the questions are not as bold and misleading as this one, but they all express a similar feeling, and in this they convey a significant misunderstanding of how search engines work. <br><br>  But while Google is incredibly complex, the basic concept of a search engine that searches for matches and evaluates (ranks) results relative to a search query is not particularly difficult, and anyone with basic programming experience can understand this.  I don‚Äôt think that at the moment it is possible to surpass Google in the search, but making the search engine is an entirely achievable goal, and in fact this is a rather instructive exercise that I recommend trying. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is what I will describe in this article: how to make a search engine for local text files for which standard queries can be processed (at least one of the words in the query is in the document) and the entire phrase (the whole phrase appears in the text) and can rank using a basic TF-IDF scheme. <br><br>  There are two main stages in the development of a search engine: building an index, and then, using an index, answer the query.  And then we can add a rating result (TF-IDF, PageRank, etc.), request / document classification, and, perhaps, some machine learning to track recent user requests and select results for this to increase search engine performance. <br><br>  So without further ado, let's get started! <br><a name="habracut"></a><br><h4>  Index building </h4><br>  Thus, the first step in building a text search engine is to build an inverted index.  Let me explain what it is.  An inverted index is a data structure that maps markers to documents in which they appear.  In this context, we can simply consider a marker as words, thus an inverted index, basically, this is something that takes a word and returns us a list of documents where it occurs. <br><br>  Firstly, however, we must analyze and mark (mark, word by word) our set of documents.  We do this as follows: for each document we want to add to our index, we will remove all the punctuation and divide it into spaces, create a temporary hash table that relates the names of the documents to the list of markers.  We will transform this hash table several times until we reach the final inverted index, which I described above (but with a little complication, which I will explain later).  Here is the code that will do the initial text filtering: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> file_to_terms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.filenames: pattern = re.compile(<span class="hljs-string"><span class="hljs-string">'[\W_]+'</span></span>) file_to_terms[file] = open(file, <span class="hljs-string"><span class="hljs-string">'r'</span></span>).read().lower(); file_to_terms[file] = pattern.sub(<span class="hljs-string"><span class="hljs-string">' '</span></span>,file_to_terms[file]) re.sub(<span class="hljs-string"><span class="hljs-string">r'[\W_]+'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, file_to_terms[file]) file_to_terms[file] = file_to_terms[file].split() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file_to_terms</code> </pre> <br>  There are two things that I have not done here, but I recommend to do.  Remove all stop words (‚Äúhow‚Äù, ‚Äúand‚Äù, ‚Äúto‚Äù, etc., which do not add relevance of the document) and convert all words (thus ‚Äúrunning‚Äù and ‚Äúrunner‚Äù turn into ‚Äúrun‚Äù), using an external library (although this will slow down indexing). <br><br>  Now I know that the inverted index I mentioned will be a word map to the document name, but we also want to support queries with phrases: queries not only for words but also for words in a certain sequence.  To do this, we need to know where each word appears in the document, so we can check the word order.  I index each word in a bulleted list on a document as a word position in this document, so our final inverted index will look like this: <br><pre> <code class="python hljs">{word: {documentID: [pos1, pos2, ...]}, ...}, ...}</code> </pre><br>  instead of this: <br><pre> <code class="python hljs">{word: [documentID, ...], ...}</code> </pre><br>  So our first task is to create a word mapping for our positions for each document, and then combine them to create our complete inverted index.  It looks like: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#input = [word1, word2, ...] #output = {word1: [pos1, pos2], word2: [pos2, pos434], ...} def index_one_file(termlist): fileIndex = {} for index, word in enumerate(termlist): if word in fileIndex.keys(): fileIndex[word].append(index) else: fileIndex[word] = [index] return fileIndex</span></span></code> </pre><br>  This code is quite understandable: it accepts a list of terms in the document, separated by a space (in which the words are in their original order), and adds each to a hash table, where the value is the list of positions of that word in the document.  We build this list many times, as we go through the list, until we have passed all the words, leaving us with a table, provided with keys along the lines and marked up to the list of positions of these lines. <br><br>  Now we need to combine these hash tables.  I started this by creating an intermediate index format. <br><pre> <code class="python hljs">{documentID: {word: [pos1, pos2, ...]}, ...}</code> </pre><br>  which we then convert to our final index.  This is done here: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#input = {filename: [word1, word2, ...], ...} #res = {filename: {word: [pos1, pos2, ...]}, ...} def make_indices(termlists): total = {} for filename in termlists.keys(): total[filename] = index_one_file(termlists[filename]) return total</span></span></code> </pre><br>  This code is very simple: it simply accepts the results of the file_to_terms function, and creates a new hash table labeled with a key by the file name and with the values ‚Äã‚Äãthat are the result of the previous function, creating a nested hash table. <br><br>  Then, we can actually build our inverted index.  Here is the code: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#input = {filename: {word: [pos1, pos2, ...], ... }} #res = {word: {filename: [pos1, pos2]}, ...}, ...} def fullIndex(regdex): total_index = {} for filename in regdex.keys(): for word in regdex[filename].keys(): if word in total_index.keys(): if filename in total_index[word].keys(): total_index[word][filename].extend(regdex[filename][word][:]) else: total_index[word][filename] = regdex[filename][word] else: total_index[word] = {filename: regdex[filename][word]} return total_index</span></span></code> </pre><br><br>  So let's break it down.  First, we create a simple hash table (Python dictionary), and we use two nested loops to iterate through each word in the input (input) hash.  Then, we first check if this word is present as a key in the output (output) hash table.  If this is not the case, we will add it by setting another hash table as the value, which matches the document (identified, in this case, by the variable <i>filename</i> ) to the list of positions of this word. <br><br>  If it is a key, then we perform another check: if the current document is in each hash table of the word (the one that matches file names with the position of the word).  If this is a key, then we do another check: if the current document is in the hash table of each word (the one that matches the names of the files on the word posts).  If so, we expand the list of current positions with this list of positions (note that this case was left only for completeness: this will never happen, because each word will have only one list of positions for each file (filename)).  If this is not the case, then we set equal positions in the list of positions for this file (filename). <br><br>  And now, we have an index.  We can enter a word, and should receive a list of documents in which it appears.  In the <a href="http://habrahabr.ru/post/263913/">next article</a> I will show how to run a query on this index. <br><br>  <b>All code</b> used in all parts (along with the implementation) is available on <a href="https://github.com/logicx24/Text-Search-Engine">GitHub</a> . <br><br>  <b>PS</b> This part ends.  I hope that everything is translated quite clearly, and most importantly - correctly.  Ready to accept comments and advice on the design and translation. </div><p>Source: <a href="https://habr.com/ru/post/263823/">https://habr.com/ru/post/263823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263811/index.html">The formation of musical preferences in the neural network - an experiment to create a smart player</a></li>
<li><a href="../263813/index.html">Underground carders market. Translation of the book "Kingpin". Chapter 5. ‚ÄúCyberwar!‚Äù</a></li>
<li><a href="../263817/index.html">Video reports from the conference IT NonStop Odessa 2015</a></li>
<li><a href="../263819/index.html">Translation of the book "Kingpin". Chapter 3. ‚ÄúThe Hungry Programmers‚Äù</a></li>
<li><a href="../263821/index.html">Django ORM. Add sugar</a></li>
<li><a href="../263825/index.html">RailsClub Moscow 2015, we start</a></li>
<li><a href="../263827/index.html">How configuration affects the architecture of the application</a></li>
<li><a href="../263831/index.html">How to avoid becoming a bot in Bittorrent DHT and other P2P networks</a></li>
<li><a href="../263833/index.html">CHECK CONSTRAINT in MS SQL - Rakes we walked through</a></li>
<li><a href="../263835/index.html">Viewing statistics on the number of errors in a project, or ‚ÄúWow, graphics have appeared in PVS-Studio!‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>