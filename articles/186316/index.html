<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analysis of the tasks of the World Cup finals about programming ACM ICPC 2013</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the ACM ICPC 2013 World Team Programming Championship a week ago, there were 11 tasks, one of which for a given time could not be solved correctly ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analysis of the tasks of the World Cup finals about programming ACM ICPC 2013</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e1c/4f2/75e/e1c4f275efb76d296c6ae9e305e32910.gif" width="1" height="1">  At <a href="http://habrahabr.ru/company/yandex/blog/185394/">the ACM ICPC 2013 World Team Programming Championship a</a> week ago, there were 11 tasks, one of which for a given time could not be solved correctly by any of the teams. <br><br>  But besides the teams, there are other people who professionally solve problems - the championship analysts.  During the broadcast, they are divided into groups, distribute tasks and then talk about them in the studio.  A lot of viewers are watching the air until these guys sort out the latest task.  In addition, analysts tell the leader what is happening ‚Äúon the field,‚Äù looking for interesting pieces of code, watching the picture from the participants' webcams. <br><br>  This year, 21 analysts from Sweden, the Netherlands, the USA, Slovakia, Belarus and Russia were at ACM ICPC.  And 10 of them were from Yandex.  All of them in different years were ICPC winners.  Especially for Habr, they dismantled all the tasks of the championship. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="http://habrahabr.ru/company/yandex/blog/186316/"><img src="https://habrastorage.org/getpro/habr/post_images/482/240/41c/48224041c6514af166a6ef9ac8778296.jpg" width="600" height="409" alt="Analysis of the &quot;Matryoshka&quot; problem during the ACM ICPC 2013 broadcast"></a> <br><a name="habracut"></a><br><h4>  Task A. Self-Assembly </h4><br>  One highly scientific chemical institution is actively experimenting with the Automatic Molecule Collector.  The molecules, between which the formation of chemical bonds is possible, are mixed and placed in the AFM, where they form complex molecular structures.  However, sometimes a problem arises - molecules form such a large group that the Picker jams. <br><br>  Write a program that will determine whether the provided set of molecules can be assembled into structures of unlimited size.  In this case, 1) the task is limited to flat structures and 2) each molecule has the form of a square, all molecules have the same size.  The four sides of the square denote surfaces by which molecules can combine with compatible molecules. <br><br>  In each test you will be presented with a set of descriptions of molecules.  Each type of molecule is described by four pairs of symbols - labels of bonds, <br>  which means the ability of the corresponding surface of the molecule to connect with other molecules. <br><br>  There are two types of link tags: <br><ul><li>  Capital Latin letter (A..Z) and one of the symbols + or -.  Two surfaces can be connected if their connection marks are marked with the same letters, but with different signs.  For example, A + is compatible with A-, but not compatible with A + and B-. </li><li>  Two zero 00. Link label 00 means that this surface can not form a link (even with the same surface with a label 00). </li></ul><br>  Suppose that in the Collector there is an unlimited number of molecules of each of the described species that can be rotated and turned over.  In the formation of molecular structures, molecules can be nearby only if they are compatible.  Each surface of the molecule can be connected to nothing. <br><br>  The figure shows an example of three types of molecules and a limited size structure assembled from them (this is not the only possible structure for given types of molecules). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a8/b9d/bf9/5a8b9dbf9935c5844c70f750c150b63b.png" width="640" height="326" alt="Task A ACM ICPC 2013"><br><br>  <u>Input data</u>  Input data consists of one test.  Each test consists of two lines.  The first line contains the number <i>n</i> (1 ‚â§ <i>n</i> ‚â§ 40000) - the number of types of molecules.  The second line contains <i>n</i> substrings of 8 characters each - a description of each type of molecule, with the surfaces being described clockwise. <br><br>  <u>Output</u>  Output the word unbounded if the molecules can create an infinite structure and the word bounded otherwise. <br><br>  <b>Problem Solving A</b> <br>  <i>The author of the analysis is Vasily Astakhov, ACM ICPC 2011 bronze medalist in the team of Moscow State University.</i>  <i>Mv</i>  <i>Lomonosov.</i> <br><br><blockquote>  The task requires to understand whether there is an unlimited molecular structure in which the molecules have the form of squares with different bonds on the sides.  Given the availability of rotation and reflection operations, to solve the problem, it was necessary and sufficient to understand whether a cycle of molecules exists.  Then, for example, shifting all the time to the right and down, one would get an unbounded structure on the plane, while no connections, except those adjacent to the cycle, would be involved in the molecule.  To find the cycle, it would be possible to construct a graph in which the vertices are types of compounds, and edges from the type of compound <i>X</i> [+/‚àí] go to all types of compounds <i>Y</i> , for which there exists a molecule containing both <i>Y</i> and <i>X</i> [- / +] (double top).  Then, finding a cycle in such a graph, we obtain the existence of a cycle in the original one.  The task of finding a cycle in a directed graph on 52 vertices ( <i>A</i> +, <i>A</i> -, ..., <i>Z</i> +, <i>Z</i> -) is simple and can be solved, for example, by constructing strong connectivity components (the existence of a component larger than one vertex will mean a cycle). <br></blockquote><br><h4>  Problem B. Hey, Better Bettor </h4><br>  The recent recession hurt entertainment facilities, including the gambling business.  There is fierce competition among casinos, and, in order to attract players, some of them began to hold particularly attractive promotions.  Casino promotions include the following: you can play as much as you want.  And after you finish, whatever amount you lose from the moment you start, the casino returns <i>x% of</i> your losses.  Naturally, if you are the winner, you take it all. <br><br>  In this case, there are no restrictions on the duration of the game, nor on the amount of money with which you come into the game, but you can use this action only once. <br><br>  For simplicity, we assume that all bets are worth $ 1, and the gain is $ 2.  Now suppose <i>x</i> is equal to 20. If you make only 10 bets before you finish the game, and only 3 of them win, then your total loss will be 3.2 dollars.  If 6 bets win, your winnings will be $ 2. <br><br>  Given <i>x</i> and <i>p</i> (the probability of winning a single bet as a percentage), you need to write a program to determine the maximum expected gain that you can receive using any strategy of the game. <br><br>  <u>Input data</u>  The input data consists of one test that contains the return percentage <i>x</i> (0 ‚â§ <i>x</i> &lt;100) and the probability of winning in percents <i>p</i> (0 ‚â§ <i>p</i> ‚â§ 50).  <i>x</i> and <i>p</i> are no more than two digits after the decimal point. <br><br>  <u>Output</u>  Print the maximum expected gain with an absolute error of no more than 10 <sup>-3</sup> . <br><br>  <b>Solution of Problem B</b> <br>  <i>The author of the analysis is <a href="http://codeforces.ru/profile/Michael">Mikhail Levin</a> , bronze medalist of ACM ICPC 2007, silver medalist of ACM ICPC 2008 as part of the team of Moscow State University.</i>  <i>Mv</i>  <i>Lomonosov.</i> <br><br><blockquote> Note that the decision to stop the game now depends only on the current gain or loss of the player - the story does not matter.  It can be shown that the optimal strategy in this case always has the form ‚Äústop, if you have winnings <i>A</i> or lose <i>B</i> ‚Äù, where <i>A</i> and <i>B</i> are some non-negative integers.  With fixed <i>A</i> and <i>B,</i> in order to calculate the expected profit, you need to be able to solve this problem: to find the probability P ( <i>A</i> , <i>B</i> ) that the player at some point reaches win <i>A</i> , while never before having a loss <i>B</i> or more.  If this problem is solved, the expected profit of the strategy is calculated as <img src="https://habrastorage.org/getpro/habr/post_images/bd4/140/986/bd41409860ba3cb74edd6717c8e83efd.gif" width="383" height="40">  where <i>x</i> % is the discount provided by the casino to the player in case of loss. <br><br>  For the numbers P ( <i>A</i> , <i>B</i> ), the recurrence relation holds: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/240/fa6/e71/240fa6e712e7b4f1a12ff2cdab5aca61.gif" width="516" height="20">  , <br><br>  where <i>p</i> is the probability of winning each time a coin is thrown.  Moreover, <nobr>P (0, <i>A</i> + <i>B</i> ) = 1,</nobr> and <nobr>P ( <i>A</i> + <i>B</i> , 0) = 0.</nobr> If we solve this linear recurrent of order 2, we get <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/823/fac/caa823fac36b24031ff443ca4e7dc9e5.gif" width="154" height="45">  , <br><br>  Where <img src="https://habrastorage.org/getpro/habr/post_images/25e/f17/0ad/25ef170ada1002152195079fb9adf397.gif" width="92" height="46">  . <br><br>  If we could go through all the possible pairs ( <i>A</i> , <i>B</i> ) for each input ( <i>x</i> , <i>p</i> ), then we would do it, and then choose the best one.  Par ( <i>A</i> , <i>B</i> ) is an infinite number, but if you conduct several numerical experiments, you can see that as <i>A</i> and <i>B</i> increase, the expected profit first increases, and then begins to fall (you can prove the convexity of the expected profit as a function of <i>A</i> and <i>B</i> ), therefore always enough to check only a finite number of pairs.  In addition, it can be noted that the best values ‚Äã‚Äãfor <i>A</i> and <i>B are</i> the larger, the closer <i>p is</i> to 0.5, and <i>x</i> - to 100. The worst possible case is <i>p</i> = 0.4999, <i>x</i> = 99.99.  It turns out that in this case it is enough to go through <i>A</i> up to 21000, and <i>B</i> - up to 2500, and such a search is enough for the solution to pass through time limits. </blockquote><br><br><h4>  Problem C. Surely You Congest </h4><br>  You are responsible for the intelligent traffic management system for new cars.  Your goal is to avoid traffic jams from drivers commuting from the sleeping areas to the city center during the morning rush hour, using information about the city and the movement of other cars. <br><br>  Unfortunately, due to the fact that drivers are selfish, they will never follow the shortest possible way to the center, even if you ask them about it.  You can only advise them which of the few shortest paths to choose. <br><br>  The city consists of intersections connected by two-way roads that can be reached in a given time.  All drivers begin their movement at intersections (possibly different) and end at the same intersection number 1 designated as the city center. If two drivers simultaneously start driving along the same road in the same direction, a traffic jam will arise and your goal will fail.  However, drivers can drive through the same intersection at the same time or drive along the same road, driving in at different times. <br><br>  Determine the maximum number of drivers who can get to the city center without traffic jams, if all drivers start their movement at the same time and none of them will go the non-optimal way. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/145/ed2/ecf/145ed2ecf6a9e8b06f0394d226c1d7c8.png" width="640" height="580" alt="image"><br><br>  In the picture, the cars are shown in their initial position.  One driver is already in the center, and of the cars at the 4th intersection, one can move along the dotted line through intersection 3, the other along the dotted line through intersection 2, but the remaining two cannot reach the center without traffic jams.  Thus, the answer to this test will be 3. <br><br>  <u>Input data</u>  The input contains one test.  The first line contains three numbers <i>n, m</i> and <i>c</i> , where <nobr><i>n</i> (1‚â§ <i>n</i> ‚â§ 25000)</nobr> is the number of intersections, <nobr><i>m</i> (0 ‚â§ <i>m</i> ‚â§ 50,000)</nobr> is the number of roads in the city and <nobr><i>c</i> (0 ‚â§ <i>c</i> ‚â§ 1000)</nobr> is the number of drivers.  Each of the following <i>m</i> lines contains three numbers <i>x <sub>i</sub></i> , <i>y <sub>i</sub></i> and <i>t <sub>i</sub></i> describing the road, where x <sub>i</sub> and <i>y <sub>i</sub></i> (1‚â§ <i>x <sub>i</sub></i> , <i>y <sub>i</sub></i> ‚â§ n) are the numbers of the different intersections that are connected by the described road and <i>t <sub>i</sub></i> ( 1‚â§ <i>t <sub>i</sub></i> ‚â§ 10000) - the time that the driver must spend to get from the beginning to the end of the road in any direction.  It is guaranteed that you can reach the center from any intersection.  The last line contains c numbers describing the initial intersections where cars are located. <br><br>  <u>Output</u>  Print the maximum number of drivers who can reach the city center without traffic jams. <br><br>  <b>Solution of Problem C</b> <br>  <i>The author of the analysis is Mikhail Levin.</i> <br><br><blockquote>  We calculate the shortest distances <i>d</i> ( <i>u</i> ) from all vertices <i>u</i> to the final vertex <i>e</i> with the help of the Dijkstra algorithm with a bunch of O ( <i>m</i> log <i>n</i> ).  Since everyone wants to go only along the shortest path, cars will only travel along such edges ( <i>u</i> , <i>v</i> ) in the direction from <i>u</i> to <i>v</i> , that <i>d</i> ( <i>u</i> ) = <i>d</i> ( <i>v</i> ) + <i>l</i> ( <i>u</i> , <i>v</i> ), where <i>l</i> ( <i>u</i> , <i>v</i> ) is the length of the edge ( <i>u</i> , <i>v</i> ).  We construct a new directed graph consisting only of such edges. <br><br>  For any two machines that began to move simultaneously and moving from their starting points to the ending point with the same speed, the difference in distances to the final vertex remains always constant.  Therefore, two cars, starting at different distances, can never drive along the same edge at the same time.  Group all machines by distance from the end point.  Then for each group it is necessary to find the largest number of pairwise disjoint path edges from all starting vertices to the final vertex in the new oriented graph. This problem is solved using the algorithm for finding the maximum flow in the graph: add a source to the graph and draw edges from it to all vertices, in which there are machines with a capacity equal to the number of machines at the top.  We make all the edges of the oriented graph throughput 1. If we find in this graph the maximum flow from the source to the final vertex, then we‚Äôll get the maximum number of pairwise non-intersecting paths along the edges. <br><br>  Let us find the maximum flow for each group of vertices at one distance from the final one and add the answers - this will be the answer to the problem.  It takes O ( <i>m</i> ) to find one increasing flow path, and in total such paths will be found not more than <i>c</i> , therefore, in total, all starts to find the maximum flow will be performed in no more than O ( <i>mc</i> ).  Total complexity of the solution is O ( <i>m</i> log <i>n</i> + <i>mc</i> ), which goes into the given constraints. </blockquote><br><br><h4>  Task D. Factors </h4><br>  One of the fundamental theorems of arithmetic says that any number greater than 1 can be uniquely represented as a product of primes.  However, this unique set of prime factors can be ordered in various ways.  For example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b93/c60/f87/b93c60f87484db0ecc54a480b6136d95.png" width="640" height="70"><br><br>  Let <i>f (k)</i> denote the number of different ways to order the prime factors of the number <i>k</i> .  Then <i>f</i> (20) = 3 and <i>f</i> (10) = 2. <br><br>  You are given a positive integer <i>n</i> , and it is guaranteed that for any <i>n</i> there exists <i>k</i> such that <i>f (k)</i> = <i>n</i> .  Determine such minimum <i>k</i> . <br><br>  <u>Input data</u>  The input file contains no more than 1000 tests, each of which is written in a separate line.  Each test consists of a positive integer <i>n</i> &lt;2 <sup>63</sup> . <br><br>  <u>Output</u>  For each test, output the number n and the minimum <i>k</i> &gt; 1 such that <i>f</i> ( <i>k</i> ) = <i>n</i> .  The numbers in the tests are chosen in such a way that <nobr><i>k</i> &lt;2 <sup>63</sup></nobr> . <br><br>  <b>Solution of Problem D</b> <br>  <i>The author of the analysis is <a href="http://codeforces.ru/profile/zeliboba">Renat Gimadeev</a> , ACM ICPC 2012 gold medalist in the Fiztekh team.</i> <br><br><blockquote>  This is a content simple task that has many different solutions.  I will give one of the shortest. <br><br>  Note that if we decompose into simple factors <i>n</i> = <i>p</i> <sub>1</sub> <sup><i>k</i> <sub>1</sub></sup> <i>p</i> <sub>2</sub> <sup><i>k</i> <sub>2</sub></sup> ... <i>p</i> <sub><i>t</i></sub> <sup><i>k</i> <sub><i>t</i></sub></sup> , then the number of ordered representations in the form of a product of simple will be equal to <img src="https://habrastorage.org/getpro/habr/post_images/38c/8a9/3ae/38c8a93ae5fb731d7e7d3ba947c9dc11.png" width="153" height="39">  .  This follows from simple combinatorial arguments: you can order N different prime factors N!  in ways.  If among these factors there are identical, then all orderings, which differ only in the order of identical factors, actually coincide.  Each group of k <sub>i</sub> identical factors can be rearranged k <sub>i</sub> !  in ways.  Therefore, each unique permutation was counted k <sub>1</sub> ! K <sub>2</sub> ! ... k <sub>t</sub> !  times and this number must be divided.  This formula allows us to quickly calculate <i>f</i> ( <i>k</i> ), knowing the decomposition of the number <i>k</i> into prime factors. <br><br>  Further, it should be noted that the number of orderings does not depend on what is equal to <i>p</i> <sub>i</sub> and how <i>k</i> <sub>i</sub> are ordered among themselves.  Therefore, if we are looking for the minimum number, then we should look for it among the numbers of the form <i><i>n</i></i> = 2 <sup>k <sub>1</sub></sup> 3 <sup>k <sub>2</sub></sup> 5 <sup>k <sub>3</sub></sup> ..., and k <sub>1</sub> ‚â•k <sub>2</sub> ‚â•k <sub>3</sub> ‚â• ... It turns out that such numbers among the numbers less than 2 <sup>63</sup> not so much (in the condition they are asked to search for only those solutions that are less than 2 <sup>63</sup> ), there are about 40,000 of them and they are easily generated by recursion.  For each of them, you can find <i>f (k)</i> using the formula described above and store in the associative array the minimum values ‚Äã‚Äãof the number <i>k</i> for each obtained <i>f (k</i> ).  After that, each request from the condition is processed during the access to this associative array. </blockquote><br><br><h4>  Task E. Harvard </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/39b/267/63b39b26711486aac19c0b02a54453e1.jpg" width="330" height="212" align="right" alt="Task E ACM ICPC 2013. Picture - Wikimedia Commons">  The term ‚ÄúHarvard Architecture‚Äù applies to a computer with physically shared memory for instructions and data.  The term comes from the name of the computer <a href="http://en.wikipedia.org/wiki/Harvard_Mark_I">Harvard Mark I</a> , created in 1944.  It used paper tape for instructions, and a relay for data. <br><br>  Some modern microcontrollers use "Harvard architecture", but not paper tapes and relays!  The data is in banks, each of which contains the same number of cells.  Each data access instruction has a byte-offset <i>f</i> within the bank and a bit <i>a</i> , which is used to determine the bank number.  If <i>a</i> is 0, then the call is made to the bank with number 0. If a is equal to 1, then the bank number is stored in the special bank selection register (RMB). <br><br>  For example, suppose we have 4 banks with 8 cells each.  You can access cell number 5 in one of two ways: one instruction with <i>a</i> = 0 and <i>f</i> = 5 or two instructions, setting the value of the RVB to 0 and then using the instruction with <nobr><i>a</i> = 1</nobr> and <nobr><i>f</i> = 5</nobr> .  Obviously, the first method is faster, because you do not need to assign a value to the RVB.  Now suppose we need to access cell 20 in the same memory.  Now we can apply only one way: execute the instruction, setting the value of the RTD 2 (if the desired value is not already stored in it), and then the instruction with <i>a</i> = 1 and <i>f</i> = 4. The program is a sequence of operations.  Each operation is: <br><br><ul><li>  variable reference is written as <i>Vi</i> , where <i>i</i> is a positive integer; </li><li>  repetition is written as <i>Rn <code>E</code> , where <i>n</i> is a positive integer, and <code>‚Äî  ,      <i>n</i> .</code></i> <i><br></i> <br>  The task is to determine the minimum program execution time.  Namely, knowing the number and size of banks, as well as having a program, it is required to determine the minimum number of instructions 1 (accessing the cells and, possibly, setting the value of RTDs) necessary to run the program.  To do this, you need to associate variables with memory cells and, among all the mappings, determine the one that minimizes the number of instructions.  It is necessary to give this number itself.  Please note that the value of the RVB is not defined before the first assignment. <br><br>  <u>Input data</u>  They contain one test consisting of two lines.  In the first <i>b</i> and <i>s</i> - the number and number of variables that can be stored in the bank.  The second line contains a non-empty program with no more than 1000 elements (each of <i>Rn</i> , <i>V i</i> and <i>E</i> is counted as one element). <br><br>  It can be assumed that: <br><ul><li>  in repetition <i>Rn</i> , n satisfies 1‚â§ n ‚â§ 10 <sup>6</sup> ; </li><li>  the body of repetition <code>Rn E  ; <br>     <i>Vi</i> , <i>i</i>  <i>1</i> ‚â§ <i>i</i> ‚â§ <i>min</i> ( <i>bs; 13</i> ); <br>          10 <sup>12</sup> . <br></code> <code>Rn E  ; <br>     <i>Vi</i> , <i>i</i>  <i>1</i> ‚â§ <i>i</i> ‚â§ <i>min</i> ( <i>bs; 13</i> ); <br>          10 <sup>12</sup> . <br></code> <br>  <u>Output</u>  Print one number - the minimum number of instructions required to run the program. <br><br>  <b>Solving Problem E</b> <br>  <i>The author of the analysis is <a href="http://codeforces.ru/profile/stan">Stanislav Pak</a> , a gold medalist of ACM ICPC 2009 as part of a team of Saratov State University.</i> <br><br><blockquote>  You can make the observation that there are quite a few interesting mappings of a set of variables on the cells of the data banks to sort them all out.  Namely (the cells involved in the display will be called filled, similarly to banks, if all their cells are filled): <br><br><ol><li>  We can assume that the zero bank is full, if there is another bank with a filled cell, because access to the zero bank is free. </li><li>  Banks with numbers greater than zero are identical, so we can assume that the minimum numbers of variables displayed in the cells of these banks are ordered, for example, in ascending order. </li><li>  We can assume that the total number of filled cells in any two banks is greater than <i>s</i> . </li></ol><br><br>  Taking into account the cutoffs 1 - 3 and the limitations of the input data of interesting maps about 3 ¬∑ 10 <sup>6</sup> . <br><br>  Since recourse to a zero bank is free, you can remove variables displayed on this bank from the program.  For each pair of remaining variables <i>i</i> and <i>j,</i> we can predict <i>C <sub>ij</sub></i> - the cost of the operation of accessing the variable <i>j</i> after accessing the variable <i>i</i> , and then it remains to simulate the program's work. </blockquote><br><br><h4>  Problem F. Low Power </h4><br>  You design advanced chips for computers.  Chip production is simple and on rails, but the power sources cause a problem, since the available batteries have different output powers. <br><br>  Imagine that we have n machines with two chips each, and each chip is powered by <i>k</i> batteries.  Surprisingly, it does not matter how much energy the chips consume, but it is important that the output powers of the chips differ as little as possible from each other, as in this case the machine works best.  The output power of a chip is the minimum output power among all <i>k</i> batteries in a chip.  You have <i>2nk</i> batteries that you need to distribute on the chips of the machines.  It may be that there is no way to distribute the batteries so that the output powers of the chips are equal for all the machines.  However, you need to minimize the power difference.  In more detail, you want to guarantee your customers that the difference in output power of the chips in all the machines does not exceed <i>d</i> , while trying to minimize <i>d</i> .  To do this, you need to find the optimal battery distribution among the chips. <br><br>  <u>Input data</u>  Consist of one test containing two lines.  The first line <i>contains</i> two numbers <i>n</i> and <i>k</i> ( <i>2nk</i> ‚â§ 10 <sup>6</sup> ), the second <i>line contains 2nk</i> integers p <sub>i</sub> (1 ‚â§ p <sub>i</sub> ‚â§ 10 <sup>9</sup> ). <br><br>  <u>Output</u>  Output the minimum <i>d</i> such that there is a distribution of batteries among the chips so that the difference in output power of the chips in each machine does not exceed <i>d</i> . <br><br>  <b>Solution of Problem F</b> <br>  <i>The author of the analysis is Stanislav Pak.</i> <br><br><blockquote>  This task is one of the easiest.  It is necessary to choose from 2 <i>nk</i> <i>n</i> pairs (let's call them representatives) of the batteries, each of which <br>  It has a minimum power on its chip, so that the maximum difference in output power of the batteries in a pair is minimal.  Suppose that <i>d is</i> fixed, then you can find out whether there are representatives such that the maximum does not exceed <i>d</i> .  We sort the powers <i>p</i> <sub>1</sub> ‚â§ <i>p</i> <sub>2</sub> ... ‚â§ <i>p</i> <sub>2nk</sub> and we will greedily type pairs: the first pair will get the batteries <i>p</i> <sub>1</sub> and <i>p</i> <sub>2</sub> .  If <i>p</i> <sub>2</sub> - <i>p</i> <sub>1</sub> &gt; <i>d</i> , then representatives cannot be selected.  In the second pair, we take batteries ( <i>p</i> <sub>i2</sub> , <i>p</i> <sub>i2 + 1</sub> ) with a difference of no more than <i>d</i> and a minimum index <i>i</i> 2 ‚â§ 2 <i>k</i> + 1, if possible.  Similarly, in the third pair - ( <i>p</i> <sub>i3</sub> , <i>p</i> <sub>i3 + 1</sub> ), i3 ‚â§ 4k + 1. <br><br>  If using this algorithm fails to dial <i>n</i> pairs, then this cannot be done.  The answer will find a binary search. </blockquote><br><br><h4>  Task G. Map Tiles. </h4><br>  <i>This is a task that in the allotted time none of the teams could solve correctly.</i> <br><br>  Printing maps is a difficult task.  First you need to find a suitable transformation to fit the spherical earth map on the plane, then it turns out that you need to use several sheets of paper to print high-quality maps, because they do not fit onto one.  To overcome this difficulty, map publishers split the map into several rectangular parts and print each part separately.  It is in this process that you will take part in this task. <br><br>  The International Association of Card Publishers is trying to reduce the cost of printing cards by minimizing the number of individual sheets used to print cards.  Even with a standard sheet size and map scale, sheet consumption can be optimized by adjusting their position. <br><br>  The left side of the figure shows 14 sheets covering the area.  The right side shows how the same area can be covered with a total of 10 sheets, without changing the orientation of the area, the size of the sheets and scale. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8f/15b/e80/d8f15be80a993fe4bec2b95d1b6a8bf4.png" width="640" height="346" alt="The most difficult task of the final ACM ICPC 2013"><br>  <i>Two different ways to break down Texas sheets</i> <br><br>  Your task is to help the International Association of Card Publishers to find the minimum number of sheets needed to cover a given area.  For simplicity, the domain is a closed polygon with no self-intersections. <br><br>  Note that all sheets must be parts of a continuous grid, with sides parallel to the horizontal and vertical.  Sheets can only touch their sides completely and cannot be rotated.  In addition, although all given coordinates are integer, the sheets can be located in non-integer coordinates. <br><br>  The polygon may touch the sides of the sheets (as in example 2).  However, in order to avoid problems with the machine representation of rational numbers, we can assume that the answer will not change if the vertex of the polygon is located in front of the sheet at a distance of 10 <sup>-6</sup> . <br><br>  <u>Input data</u>  The input consists of one test.  The first line of the test contains three numbers <i>n</i> , x <sub>s</sub> and y <sub>s</sub> .  The number of vertices of the polygon <i>n</i> (3 ‚â§ <i>n</i> ‚â§ 50), <i>x <sub>s</sub></i> and <i>y <sub>s</sub></i> (1 ‚â§ x <sub>s</sub> , y <sub>s</sub> ‚â§ 100) are the sizes of the sheets with which to cover the card.  Each of the next <i>n</i> lines contains two integers <i>x</i> and <i>y</i> (0 ‚â§ x ‚â§ 10 <i>x <sub>s</sub></i> , 0 ‚â§ <i>y</i> ‚â§ 10 <i>y <sub>s</sub></i> ), describing the vertex of the polygon (in the circumferential direction either clockwise or counterclockwise). <br><br>  <u>Output</u>  Print the minimum number of sheets needed to cover the polygon. <br><br>  <b>Solving Problem G</b> <br>  <i>The author of the analysis is <a href="http://codeforces.ru/profile/Jacob">Jacob Dlugach</a> , ACM ICPC 2012 gold medalist in the Fiztekh team.</i> <br><br><blockquote>  The solution to this problem is divided into two parts: the generation of options for the location of the polygon and counting the number of occupied cells for each of the options for the location. <br><br><h6>  Variations generation </h6><br>  Note that if we have found some solution, then it can be ‚Äúmoved‚Äù until the polygon rests on the grid (that is, further movement can change the set of selected cells).  In fact, there are several cases when a polygon rests on a grid: <br><br><ul><li>  one of the vertices of the polygon falls on the grid line; </li><li>  one of the edges of the polygon stumbles onto a grid node. </li></ul><br><br>  When one of these conditions is met, a polygon still has some degree of freedom: <br><br><ul><li>  if the vertex hits the grid line, you can move the polygon along this line; </li><li>  in the case of an edge hitting the grid node, you can move the polygon along the edge. </li></ul><br><br>  We will make a reservation in advance that shifts that differ in each of the coordinates by a number that is a multiple of the grid step will be considered equal. <br><br>  Therefore, in fact, there are three options for selecting the ‚Äústop‚Äù so that the position of the polygon relative to the grid is uniquely defined. <br><br><ol><li>  One of the vertices falls on the vertical line of the grid, and one of the vertices falls on the horizontal line of the grid.  This includes the case when one vertex falls into a grid node.  That is, the emphasis is uniquely defined by a pair of vertices, total options - <i>n</i> <sup>2</sup> . </li><li>  One of the vertices falls on a horizontal or vertical grid line.  Without loss of generality, we assume that this grid line is vertical and is given by the equation <i>x</i> = 0. <br>  Now suppose that one of the edges, which is not vertical, falls on a node.  To select the shift, it is enough to choose the abscissa of this node, and this can be done in no more than <i>m</i> + 1 ways.  For <i>m</i> is the number 10. Total options - <i>n</i> <sup>2</sup> ( <i>m</i> + 1). </li><li>  Two non-parallel edges abut the mesh node.  Here, in order to determine the shift of the polygon, in addition to the edges, it is necessary to fix the ‚Äúdifference‚Äù between those grid nodes against which these edges rest.  Total - <i>n</i> <sup>2</sup> ( <i>m</i> + 1) <sup>2</sup> options. </li></ol><br><br>  As a result, in the worst case, we obtain O ( <i>n</i> <sup>2</sup> <i>m</i> <sup>2</sup> ) polygon shift selection options.  Since for each of the options, then you will need to count the number of occupied cells, you need to generate a list of all the options, clear duplicates from it: they say that it helped to reduce the number of options in the "maximum" tests by 3-5 times. <br><br>  It is worth noting that many teams forgot to consider some of these three cases (most of the teams stopped only before the first one). <br><br><h6>  Calculation of occupied cells </h6><br>  The second difficulty in this task was to effectively calculate the number of cells occupied by a given shift.  The naive method of counting - for ( <i>m</i> + 1) <sup>2</sup> cells, check for the presence of an intersection with a polygon - works in O ( <i>m</i> <sup>2</sup> <i>n</i> ) and does not fit into the time limit.  It turns out that it will be more efficient to count the number of occupied cells in each of the <i>m</i> + 1 columns.  To do this, consider continuous pieces of the polygon border passing through the column: either a piece of the border ‚Äúcrosses‚Äù the column (one end of the piece is on the right edge of the column, <br>  and the other end is on the left), or both ends of the piece are on the same border of the column.  It is possible to prove that the pieces of the first type are divided into pairs, and all the cells between these pieces will be occupied.  After that, the resulting cells need to add cells, through which the pieces of the second type pass.  This method can be implemented for O ( <i>m</i> ( <i>m</i> + <i>n</i> )) = O ( <i>mn</i> ). <br><br>  The total complexity of the algorithm for this problem is O ( <i>n</i> <sup>3</sup> <i>m</i> <sup>3</sup> ). </blockquote><br><br><h4>  Task H. Matryoshka </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/62f/c0d/734/62fc0d7347c18b2b3c3be0aa7959d64b.png" width="339" height="218" align="right" alt="The task about the matryoshka on ACM ICPC 2013">  Matryoshka called a set of traditional Russian wooden dolls of decreasing size, placed inside each other.  The nested doll can be opened to get from within a smaller nested doll, which, in turn, also has a nested doll inside and so on. <br><br>  The National Matryoshechny Museum recently held an exhibition of dolls, which presented similar in style, but differing in the number of dolls in the doll's set.  Unfortunately, one playful (and left unattended) child disassembled all the dolls and put all the dolls in a row. <br><br>  In the series there were <i>n</i> matryoshkas, each is known for its integer size.  You need to re-collect all the dolls in the sets, but you do not know the initial number of sets or the number of dolls in each of the sets.  You only know that each set consists of dolls of all consecutive sizes from 1 to some <i>m</i> , and <i>m</i> can be different for different sets. <br><br>  When assembling sets, you should follow the following rules: <br><ul><li>  you can put the nested doll only inside the larger nested doll; </li><li>  you can combine two nesting dolls only if they stand side by side in a row; </li><li>  after the nested doll is placed inside the set of nested dolls, it cannot be moved to another group of nested dolls or separated from the group of nested dolls.  It is only allowed to temporarily divide it when combining two groups of nesting dolls. </li></ul><br>  Your time is very valuable, so you want to collect all the dolls in groups as quickly as possible.  The only part of the process that takes time is opening and then closing the doll, so you want to minimize the number of such actions.  For example, the minimum number of actions for combining groups [1,2,6] and [4] is two; first, you need to open the nesting dolls of sizes 6 and 4. Combining groups [1,2,5] and [3,4] requires three discoveries. <br><br>  Write a program that calculates the minimum number of discoveries needed to assemble all sets of nesting dolls. <br><br>  <u>Input data</u>  You are given one test consisting of two lines.  The first line contains one number <i>n</i> (1 ‚â§ n ‚â§ 500) - the number of individual dolls in the original row.  The second line contains <i>n</i> numbers describing the size of each doll in the row.  The size of each doll is at least 1 and does not exceed 500. <br><br>  <u>Output</u>  Output the minimum number of nesting dolls necessary to collect all the sets.  If the assembly is impossible (the child could pick up several dolls himself), output the word impossible. <br><br>  <b>Solution of Problem H</b> <br>  <i>The author of the analysis is <a href="http://codeforces.ru/profile/aropan">Alexey Ropan</a> , bronze medalist of ACM ICPC 2012 as part of the team of the Belarusian State University of Informatics and Radioelectronics.</i> <br><br><blockquote>  Let's say that the value of <i>F</i> <sub><i>i</i></sub> is the minimum number of matryoshka openings that must be done in order to break the first <i>i</i> matryoshka into groups.  Then <i>F</i> <sub>0</sub> = 0 and <i>F</i> <sub>i</sub> = min <sub>0‚â§j &lt;i</sub> <i>F</i> <sub><i>j</i></sub> + <i>G</i> <sub><i>j</i> + 1, i</sub> , where the value of <i>G</i> <sub><i>l</i> , <i>r</i></sub> is the minimum number of discoveries that must be made to fold the matryoshka from <i>l</i> to <i>r</i> inclusive in one (numbering of matryoshkas from one), and on the interval from <i>j</i> + 1 to <i>i</i> inclusive, all sizes of matryoshkas are different and do not exceed <i>i</i> - <i>j</i> .  Then the answer to the problem will be <i>F</i> <sub><i>n</i></sub> , and the complexity of the solution without taking into account the calculation of the values ‚Äã‚Äãof <i>G</i> will be O ( <i>n</i> <sup>2</sup> ).  For <i>G</i> <sub><i>i</i> , <i>i, the</i></sub> value is always 0, and for <i>G</i> <sub><i>i</i> , <i>j</i></sub> and i &lt;j, at the last stage, the two groups of matryoshkas are combined.  Let <i>k</i> be the number of the matryoshka on which the left group ends.  Then <i>G</i> <sub><i>i</i> , <i>j</i></sub> = min <sub>i ‚â§ k &lt;j</sub> <i>G</i> <sub><i>i</i> , <i>k</i></sub> + <i>G</i> <sub>k + 1, j</sub> + <i>C</i> <sub><i>i</i> , <i>k</i> , <i>j</i></sub> , where <i>C</i> <sub><i>i</i> , <i>k</i> , <i>j</i></sub> is the minimum number of matryoshka openings that will be required for in order to unite the groups of matryoshkas from the <i>i-</i> th to the <i>k-</i> th and c <i>k</i> + 1-th to the <i>j-</i> th.  Let the value of <i>M</i> <sub><i>i</i> , <i>j</i></sub> be the minimum size of the matryoshka on the interval from <i>i</i> to <i>j</i> and the value of <i>K</i> <sub><i>i</i> , <i>j</i> , <i>s</i></sub> be the number of matryoshka on the interval from <i>i</i> to <i>j</i> , whose dimensions are less than <i>s</i> .  Then <i>C</i> <sub><i>i</i> , <i>k</i> , <i>j</i></sub> can be calculated as <i>j</i> - <i>i</i> + 1 - <i>t</i> , where <i>t</i> is the number of nested dolls that will not be opened when combined, that is, <i>t</i> = <i>K</i> <sub><i>k</i> + 1, j, <i>M</i> <sub><i>i, j</i></sub></sub> + <i>K</i> <sub><i>i</i> , <i>j</i> , <i>M</i> <sub><i>k</i> +1, <i>j</i></sub></sub> (you can see that one of the items will always be zero).  The complexity of calculating <i>K</i> and <i>G</i> is equal to <img src="https://habrastorage.org/getpro/habr/post_images/e81/923/a15/e81923a15365e675be58717140afdea6.png" width="44" height="20">  . </blockquote><br><br><h4>  Problem I. Pirate Chest </h4><br>  Pirate Jack is tired of the battles, looting, theft and oppression of all and all in the open sea.  He decided to retire, and even found the perfect uninhabited island in the ocean, on which he would spend the rest of his life with dignity, if, of course, he did not run out of money.  Now he has a lot of gold coins, which he wants to put in the chest (he's in the end a pirate!).  Jack can build a chest in the form of a rectangular parallelepiped with integer sides and not exceeding a given size of the bottom of the chest.  It remains only to find where to hide the treasure chest. <br><br>  Jack decided to flood the chest in a shady pond.  The surface of the pond is a rectangle with given sides, the pond is surrounded on all sides by vertical stone banks.  Jack investigated the bottom of the pond and knows about each square of a 1x1 pond (in Cartesian coordinate system) the depth of the pond in this place.  When Jack drowns the chest, the latter will sink to the maximum possible depth until it touches the bottom with at least one square.  Because of the recessed chest, the water level in the pond will rise.  The banks of the pond are high enough that the water never spilled over its borders.  Of course, since the chest must be hidden, it must be completely below the water level in the pond.  Your task is to find the maximum volume of the chest that can be hidden in the pond. <br><br>  The figure on the left shows a pond without a chest, in the center - a pond in which there is a chest of volume 3, on the right - a chest of volume 4 (maximum possible) in the pond.  Please note that if the chest from the central pattern were placed on a unit of greater height, then its top would be visible exactly on the surface of the pond. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b1/3f3/03d/4b13f303d866f5b7473988d556b42881.png" height="203" alt="Challenge I ACM ICPC 2013"><br><br>  <u>Input data</u>  The input contains one test.  The test starts with a line containing four integers <i>a</i> , <i>b</i> , <i>m</i> , <i>n</i> (1‚â§ <i>a, b, m, n</i> ‚â§ 500).  The dimensions of the pond surface are <i>m</i> x <i>n</i> , the maximum size of the bottom of the chest is <i>a</i> x <i>b</i> .  In addition, <i>a</i> and <i>b is</i> enough, the chest will never cover the entire pond completely.  Each of the remaining m entry lines contains <i>n</i> numbers d <sub>ij</sub> describing the depth of the pond in the square with coordinates <i>(i, j)</i> , where 0‚â§ d <sub>ij</sub> ‚â§ 10 <sup>9</sup> for any 1‚â§ <i>i</i> ‚â§ <i>m</i> , 1‚â§ <i>j</i> ‚â§ <i>n</i> . <br><br>  <u>Output</u>  Output the maximum volume of the chest with integer sides, which can be hidden in the pond under the surface of the water, and one of the measurements of the bottom should not exceed <i>a</i> , and the other should not exceed <i>b</i> .  If no chest can be hidden under water, output 0. <br><br>  <b>Problem Solving I</b> <br>  <i>The author of the analysis is Vasily Astakhov.</i> <br><br><blockquote>   ,         <i>h</i> ¬∑ <i>w</i> ,    <i>d</i> ,        <img src="https://habrastorage.org/getpro/habr/post_images/b81/ca2/74e/b81ca274e0cf340a5fa5d614dbf2f52b.gif" width="142" height="43"> ,  S ‚Äî   .  ,    h ¬∑ w,       ,   <i>d</i> .     .        (   ( <i>a,b</i> ))      ,       . <br><br>       .   ,    x <sub>0</sub>  x <sub>1</sub>   <nobr>(</nobr> <i>x</i> <sub>0</sub> &lt; <i>x</i> <sub>1</sub> , <i>x</i> <sub>1</sub> - <i>x</i> <sub>0</sub> ‚â§ <i>b</i> ) .  ,     ,   <i>x</i> <sub>0</sub>   <i>x</i> <sub>1</sub> .        (      <i>n</i> <sup>3</sup> ).  ,   <i>w</i> = <i>x</i> <sub>1</sub> - <i>x</i> <sub>0</sub> ‚â§ <i>a</i> ,       <i>yb</i> ,    y    <i>a</i> .     :      (      <i>h</i> ),     .       .       <i>y</i> .        ,    ,       . <br><br>                 (      ),   .  ,       ‚â•  . ,                   .  ,    O( <i>n</i> <sup>2</sup> ¬∑ <i>m</i> ¬∑ log <i>m</i> ),  log   . </blockquote><br><br><h4>  J. Pollution Solution </h4><br>        ,     ,   ( ,  )  ,   .     ‚Äî       ,    ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/674/8f5/b1e/6748f5b1e82410bd615050c87a689751.png" width="640" height="358" alt=" J ACM ICPC 2013"><br><br> ,     ,   .   (   )    <i>x</i> ,       (0, 0). <br>      ,      .     ,   ,    -   . <br><br> <u> </u> .      .   ,     <i>n</i>  <i>r</i> ,  3 ‚â§ <i>n</i> ‚â§ 100 ‚Äî    , 1 ‚â§ <i>r</i> ‚â§ 1000 ‚Äî    .   <i>n</i> ,       <i>x</i> <sub><i>i</i></sub>  <i>y</i> <sub><i>i</i></sub> ‚Äî        ,  ‚àí1500 ‚â§ <i>x</i> <sub><i>i</i></sub> ‚â§ 1500  0 ‚â§ <i>y</i> <sub><i>i</i></sub> ‚â§ 1500.      .      . <br><br> <u> </u> .    ,           <i>r</i> .        10 <sup>‚àí3</sup> . <br><br> <b>  J</b> <br> <i>  ‚Äî <a href="http://codeforces.ru/profile/SobolS"> </a> ,   ACM ICPC 2012      .</i> <br><br><blockquote>      :       ,   . <br><br>          ( ,    ).  <i>O</i> ‚Äî  ,    <i>n</i>  <i>P</i> <sub>1</sub> , <i>P</i> <sub>2</sub> , ‚Ä¶, <i>P</i> <sub><i>n</i></sub>   ,     <i>n</i>  - ( <i>x</i> <sub><i>i</i></sub> , <i>y</i> <sub><i>i</i></sub> ).      ,  <i>P</i> <sub><i>n</i> +1</sub> = <i>P</i> <sub><i>1</i></sub> .      <br><br><img src="https://habrastorage.org/getpro/habr/post_images/445/578/1da/4455781da0cdc76010be575f2c955b56.gif" width="184" height="47">  , <br><br>  <i>S</i> ( <i>O</i> <i>P</i> <sub><i>i</i></sub> <i>P</i> <sub><i>i</i> +1</sub> ) ‚Äî      <i>O</i> , <i>P</i> <sub><i>i</i></sub>  <i>P</i> <sub><i>i</i> +1</sub> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/344/f76/ec9/344f76ec9643c09352ca5e93cb28f342.gif" width="184" height="47">  . <br><br>       ,        : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/034/711/bf4/034711bf4307bf9403e23b5b6574a1b1.png"><br><br>    <i>n</i>  ,  ¬´¬ª  ,   ,        ,         (    ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a5/212/488/7a5212488e2d3fc5faabfcba50dc9637.png"><br><br>    . ,        ,     ,        .    :       <i>O</i> <i>P</i> <sub><i>i</i></sub> <i>P</i> <sub><i>i</i> +1</sub>     ,  ,   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ba/4e4/d39/9ba4e4d39e77b6b3a2f0a3b7c2073796.png"><br><br>          ?       <i>P</i> <sub><i>i</i></sub> <i>P</i> <sub><i>i</i> +1</sub>  .     . <br><br><ul><li>      <i>t P</i> <sub><i>i</i></sub> + (1 ‚àí <i>t</i> ) <i>P</i> <sub><i>i</i> +1</sub>   <i>t</i>  [0, 1] (  ).            <i>t</i> ,         . </li><li>           <a href="http://e-maxx.ru/algo/circle_line_intersection"></a> . </li></ul><br><br>  ,        ( <i>P</i> <sub>1</sub> <i>P</i> <sub>2</sub>  <i>P</i> <sub>3</sub> <i>P</i> <sub>4</sub>  ),    ( <i>P</i> <sub>5</sub> <i>P</i> <sub>1</sub> )      ( <i>P</i> <sub>2</sub> <i>P</i> <sub>3</sub>  <i>P</i> <sub>4</sub> <i>P</i> <sub>5</sub> ). <br><br>        <i>O</i> <i>P</i> <sub><i>i</i></sub> <i>P</i> <sub><i>i</i> +1</sub>        (,   <i>O</i> <i>P</i> <sub>5</sub> <i>P</i> <sub>1</sub>      ).       (      ),    ,     .        . <br><br>  ,     <img src="https://habrastorage.org/getpro/habr/post_images/b3c/5ae/232/b3c5ae232f95acaea5e31597431a5631.png" width="37" height="19">  . </blockquote><br><br><h4>  K. Up a Tree </h4><br>  ‚Äî     .          .      . ,           post, pre  in    pre-      output,    ,   output      .        ,    . <br><br>       . <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> prePrint(TNode t) { output(t.value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.left != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) prePrint(t.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.right != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) prePrint(t.right); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> inPrint(TNode t) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.left != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) prePrint(t.left); output(t.value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.right != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) prePrint(t.right); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> postPrint(TNode t) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.left != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) prePrint(t.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.right != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) prePrint(t.right); output(t.value); }</code> </pre> <br><br>          ‚Äî     !  ,   ,    ,        .             , ,     . <br><br>            .       ,  ,  .   ,  ,   ,       .      : <br><br><ul><li>       , ,     inPrint ; </li><li>   6       inPrint, prePrint  postPrint, ,    . </li></ul><br>   ,                    .          . ,             . <br><br> <u> .</u>    ,    ‚Äî     prePrint, inPrint  postPrint.     <i>n</i> (4 ‚â§ <i>n</i> ‚â§ 26),      . <br><br> <u> .</u>        6    {Pre, In, Post} ‚Äî      prePrint     ,     inPrint , , postPrint. ,        prePrint, inPrint, postPrint    ,      ,    prePrint  ,    , ,    inPrint . <br><br> <b>  K</b> <br> <i>  ‚Äî <a href="http://codeforces.ru/profile/egor"> </a> ,   ACM ICPC 2007      .</i>  <i>Mv</i> <i>.</i> <br><br><blockquote>        .    90.    .       .     <i>S</i> ( <i>f</i> <sub>1</sub> , <i>f</i> <sub>2</sub> , <i>f</i> <sub>3</sub> , <i>s</i> <sub>1</sub> , <i>s</i> <sub>2</sub> , <i>s</i> <sub>3</sub> , <i>l</i> ) ‚Äî   , ,     <i>f</i> <sub><i>i</i></sub> ,   <i>i</i> -   ,    <i>s</i> <sub><i>i</i></sub>    <i>l</i> ,    ‚Äî         ,      ‚Äî     . <br><br>              ,       O( <i>n</i> <sup>2</sup> ). <br><br>   3 <sup>3</sup> n <sup>4</sup>  ,             ,      3 <sup>3</sup> n <sup>2</sup> ,  n ‚â§ 26         . <br><br></blockquote><br><br> ,       ACM ICPC 2013,   . ,    ,        <a href="http://www.csc.kth.se/~austrin/icpc/finals2013solutions.pdf">Per Austrin</a> ( ).        ,   ICPC.      <a href="http://icpc.baylor.edu/download/worldfinals/problems/icpc2013.pdf"></a> . </li></ul></li></ul></div><p>Source: <a href="https://habr.com/ru/post/186316/">https://habr.com/ru/post/186316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186302/index.html">FSO buys typewriters</a></li>
<li><a href="../186306/index.html">LG Optimus G Pro</a></li>
<li><a href="../186308/index.html">Conference E-payments Russia</a></li>
<li><a href="../186310/index.html">PHDays III CTF: An Inside Look (Part 1)</a></li>
<li><a href="../186314/index.html">How to easily lose a domain with a million attendance</a></li>
<li><a href="../186318/index.html">Annual survey of users and developers WordPress</a></li>
<li><a href="../186320/index.html">What does it mean to work in a Nokia research center</a></li>
<li><a href="../186324/index.html">The way to return offline maps in the new version of Google Maps</a></li>
<li><a href="../186326/index.html">Layout of MIR station at a scale of 1: 3 inside a giant pyramid</a></li>
<li><a href="../186328/index.html">Cyber ‚Äã‚ÄãSecurity. Weekly Review July 1 - July 7, 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>