<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make a Public API to be used</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the frontend, OpenSource almost completely reigns, and more recently the component approach is gaining popularity. It seems to be all wonderful. Fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make a Public API to be used</h1><div class="post__text post__text-html js-mediator-article">  In the frontend, OpenSource almost completely reigns, and more recently the component approach is gaining popularity.  It seems to be all wonderful.  For small companies, the component approach helps to reuse the code, and for large companies to align the UX in the entire product line, services and other things.  And here we are all such wonderful cool developers sawing our frameworks, libraries and widgets, happily believing that if they solve our problems, then they solve the problems of the surrounding world.  We post them in public, waiting for grateful users, stars on GitHub, downloads on NPM.  But for some reason some libraries take off, while others go unnoticed and forgotten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/e8/af/59e8affe1f0c2414235007.jpeg"></div><br><a name="habracut"></a><br>  Why is this happening.  Surely it happened that when you were looking for a library with the necessary functionality or the same NPM package, you found something like this: <br><br><img src="https://habrastorage.org/webt/59/e8/8a/59e88a62556e8076127116.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Essentially just a piece of code.  Without any explanation of what it is, what it does, how to use it.  If this is an NPM packet, then you can probably get into his gut, understand how it works, and use it at your own risk.  But if this is a service, then nothing can be done about it - after all, you will not find out what methods he has and what data they expect at the entrance. <br><br>  What do we expect to see when we find some public API?  Probably something like this: <br><br><img src="https://habrastorage.org/webt/59/e8/8a/59e88a8719e99231819005.jpeg"><br><br>  This is NPM from Babel.  It tells you what it is, what it does and how to use it.  That is, when we put something in public access, we have to attach documentation.  Otherwise, it is simply meaningless. <br><br><h3>  Documentation </h3><br>  In the frontend, frameworks and libraries appear almost every day, so now it has become very popular to provide them with a landing page as well. <br><br><img src="https://habrastorage.org/webt/59/e8/ac/59e8ace53edcd058900248.jpeg"><br><br>  In essence, this is advertising, in which they tell us what problem this API solves, than it is cooler than its competitors, why you should definitely use it, even if you don‚Äôt need it and stuff like that.  And already from this landing page there are links to documentation, which usually has sections <i>Getting Started</i> and <i>API Reference</i> . <br><br>  <i>Getting Started</i> is a section for users who see your API for the first time.  This section describes where to download, how to build, how to run and the like.  It is also customary to describe how to use the various functions of the product.  For example, we are in APS, in <i><a href="http://doc.apsstandard.org/7.2/apps/start/">Getting Started</a></i> we take a small application and step by step add various functionality to it, bringing up a full-fledged combat solution by which you can already make some of your own applications. <br><br><img src="https://habrastorage.org/webt/59/e8/8c/59e88c31ea660820484559.jpeg"><br><br>  <i><a href="http://doc.apsstandard.org/7.2/api/ui/js-modules/w/aps-Tile/">API Reference</a></i> is designed for advanced users who know how to use your API and just want to clarify the name of a property or parameters of a method. <br><br>  It may seem that the documentation is difficult and expensive, because it needs to be kept up to date, but this, fortunately, is a bit wrong.  I hope that you all love yourself and write code with comments.  Most likely, you describe your modules and methods in JSDoc format, well, simply because it is the de facto standard in the industry.  And if you use React, then you have data-props.  There are many utilities that can build JSDocs according to your code and issue JSON dictionaries that can be displayed by various viewers as you like, that is, with sorting, searching, highlighting, categorization and everything else.  With TypeScript <a href="https://habrahabr.ru/company/docsvision/blog/341562/">they say</a> everything is fine too. <br><br>  Any documentation should have examples.  And it is very important to ensure that they work.  Nothing spoils the impression of the project, as immediately non-working examples from the documentation.  Surprisingly, this does not happen as rarely as one might think. <br><br><h3>  Sandbox </h3><br>  Well, we have examples, it seems to us that we helped people.  But usually people want to play around with themselves, experiment, that is, they want to understand for themselves whether it is possible to do something from these examples that solves their tasks.  And they want to do it quickly, simply, without downloading or installing anything.  And this is also a solvable task, because we are JavaScript developers, we can almost run everything in the browser, and we have our wonderful sandboxes a long time ago: <a href="https://codepen.io/">codepen</a> , <a href="https://jsfiddle.net/">jsfiddle</a> , <a href="http://jsbin.com/">jsbin</a> .  You can build your small snippet using your API and add a link to the documentation on which people will immediately go and experiment. <br><br>  You may become cramped in the public sandbox and you want to make your own.  This is also not so difficult, because we have two wonderful libraries of code editors in the browser.  The first is <a href="http://codemirror.net/">CodeMirror</a> , it is used, for example, in jsfiddle and Firefox DevTools.  The second is <a href="https://ace.c9.io/">Ace</a> , it is used in Atom, by many loved ones.  We in the APS didn‚Äôt become petty and made <a href="http://doc.apsstandard.org/7.2/apsfiddle/%3Ffile%3D7.2/_static/examples/slider/interval-optional-Slider.html">our own public sandbox</a> , just using CodeMirror. <br><br>  Initially, we expected that the beginner would use the sandbox, so we made it so that any examples from the documentation can be opened in the sandbox, and we also immediately added code completion.  And in this, too, there is no rocket Sains, because we have JSON dictionaries of our API and we can simply feed them to the code editor.  And this can be done not only with browser editors.  For example, I managed to get such code completion in Sublime.  Later we added the choice of API version, simultaneous work of several users with one code fragment and so on, but these are all optional ryushechki.  The main thing is that it is not at all difficult to make a simple sandbox with a code editor and results in an Iframe.  And again, for React there is already a ready generator of such sandboxes. <br><br><img src="https://habrastorage.org/webt/59/e8/b2/59e8b2d05914e913379149.jpeg"><br><br><h3>  User interaction </h3><br>  So we did the documentation, made the sandbox, and it seems that we can stop there.  True, but only if you are going to stop developing your API.  If you want to develop it further, it is better to interact with your users.  And face to face, rather than throwing them new functionality through the wall as high as possible so as not to hear their "grateful" shouts.  The easiest way to do this is with the help of any issues on GitHub or various chats and channels in the messengers.  But there are things that users will not tell you.  For example, a person had a problem, he somehow solved it, even let it go with a crutch, and he lovingly carries ctrl-c / ctrl-v from a project to a project with this crutch.  But it may turn out that you didn‚Äôt foresee such a scenario, and in the worst case, the user could even get into some of your private API.  How to deal with this? <br><br>  The first way is to collect various metrics, that is, to log method calls and send them somewhere.  You can keep track of which modules and widgets were created, with what parameters and the like.  Of course, you also need to track the environment in which your code was executed (browser versions, mobile devices), because statistics on the use of browsers in the world is useful, but your users may be stylish / fashionable / youth who use only modern browsers, and for some reason you are wasting time and effort on supporting IE. <br><br>  The second way of interaction is more suitable for large companies that are interested in using their public API - to set up special training teams.  Remember how Yandex to us all the brain picked with his BEM at various subbotniki and mitapah?  We at Odin also have a team of coaches who ride around the world and train APS people.  In the classroom, coaches see where people have the most difficulty, where they insert crutches, lovingly transferred from project to project, then we carefully pave these paths trodden by people and make them comfortable roads. <br><br><h3>  backward compatibility </h3><br>  Well, we have established user interaction, change the API as they ask, make it better, better ... And here we are in for a mine, which is called backward compatibility.  Imagine you quietly sleeping peacefully at home or basking on a paradise island on vacation, and then the boss calls and shouts that everything is gone, everything is broken, the server is lying, customers are leaving, plaster is being removed, do something. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o4/_2/n3/o4_2n33zx1i7ppxbqxiprrknc8w.jpeg"></div><br><br>  You start to remember and understand that nothing has changed there for a month.  Climbing to understand - it turns out, there is some kind of small library updated the minor version, and the one who supports it, decided that method A does not do what is necessary, and changed his behavior.  But you expected from the method of the old behavior.  And your code was expecting old behavior.  If you behave as the owner of this library, you will very quickly lose all users. <br><br>  How to deal with this? <br><br>  I can not offer anything original here: only tests, tests and tests again.  Moreover, the tests are not just to cover the code, but to cover the public API.  We in Odin, approached this completely totalitarian and check at the stage of a pull-request, firstly, the degradation of the line of coverage, and, secondly, the degradation of the public API.  Since we have JSON dictionaries, we can match them with the coverage report and find out which methods were not covered by the tests.  If such ones appear, then the check is considered not passed and such a pull-request cannot be combined with the master branch. <br><br><h2>  Total </h2><br>  What needs to be done to make the public API enjoyable? <br><br>  First, <b>write the documentation</b> .  To lay out anything in public access without documentation is at least silly, because no one will use it.  And with the documentation there is an interesting life hack.  Ask new colleagues who are not familiar with your API to do something with it in your documentation.  Because when you read the documentation, you ‚Äúimpose‚Äù it on the knowledge of the API device and you understand everything.  And a new person doesn‚Äôt have such knowledge, he does it strictly according to the documentation and, as practice shows, he necessarily finds some shoals.  As a bonus, he joins the work already having some idea what you are doing here and why all this is necessary. <br><br>  Secondly, <b>you need to interact with users</b> in order not to make a spherical horse in a vacuum. <br><br>  And thirdly, you need <b><a href="https://youtu.be/W4Eboykd8XY%3Ft%3D16m47s">to write tests</a></b> .  Moreover, pouring all the three-meter layer of concrete, completely controlling any changes, that is, so that the public API changes <b>only</b> when the major version changes. </div><p>Source: <a href="https://habr.com/ru/post/340524/">https://habr.com/ru/post/340524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340514/index.html">Testing React-Redux Applications</a></li>
<li><a href="../340516/index.html">Search memory leaks in applications on .NET Core under Linux</a></li>
<li><a href="../340518/index.html">Search for documents in network balloons and file dumps</a></li>
<li><a href="../340520/index.html">Five planning observations</a></li>
<li><a href="../340522/index.html">BEM + React: flexible design system architecture</a></li>
<li><a href="../340528/index.html">Implementing Mars IS Service Introduction Process</a></li>
<li><a href="../340530/index.html">Modern Web-platform: how to relax and have fun? A practical guide, part 1</a></li>
<li><a href="../340534/index.html">ROS, ELM and Bug</a></li>
<li><a href="../340536/index.html">Tired of writing PropertyDrawer in Unity? There is a better way</a></li>
<li><a href="../340538/index.html">UFADEVCONF 2017 Conference Overview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>