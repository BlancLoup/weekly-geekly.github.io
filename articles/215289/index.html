<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiple selection in QComboBox</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Picture to attract attention 
 (possibly related to the post) 

 Sometimes, quite convenient is the possibility of multiple selection in the QComboBox...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiple selection in QComboBox</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9a6/ae0/28e/9a6ae028e8c259b38c7229130dcb7271.png"><br>  <i>Picture to attract attention</i> <i><br></i>  <i>(possibly related to the post)</i> <br><br>  Sometimes, quite convenient is the possibility of multiple selection in the QComboBox widget.  This tutorial will show you how to do it. <br><a name="habracut"></a><br>  The basic idea is that the elements of the model used in QComboBox need to raise the <i>Qt :: ItemIsUserCheckable flag</i> , thus making them checked.  It will also take care of displaying the list of selected items on the widget. <br><br>  Let's declare the MultiListWidget class (the property and the corresponding checkedItems methods give access to the list of elements that we have previously installed or that the user has noted, and the collectCheckedItems method stores the marked model elements in mCheckedItems): <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiListWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QComboBox { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_PROPERTY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QStringList checkedItems READ checkedItems WRITE setCheckedItems)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MultiListWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~MultiListWidget(); <span class="hljs-function"><span class="hljs-function">QStringList </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkedItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCheckedItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QStringList &amp;items)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: QStringList mCheckedItems; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collectCheckedItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br>  The QComboBox model has several signals we need: <br><ul><li>  rowsInserted (const QModelIndex &amp; parent, int start, int end) - when adding items to the model (calling the addItem, insertItem, etc. methods) </li><li>  rowsRemoved (const QModelIndex &amp; parent, int start, int end) - when removing items from the model (call the removeItem method) </li></ul><br>  Also useful is the itemChanged (QStandardItem * item), which is emitted when you check and uncheck the box (by the user or programmatically). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's declare slots for these signals: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slotModelRowsInserted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slotModelRowsRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QModelIndex &amp;parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slotModelItemChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QStandardItem *item)</span></span></span></span>;</code> </pre><br>  And link the signals to the slots in the constructor (note that model () returns a pointer to QAbstractItemModel, and the itemChanged signal is emitted in QStandardItemModel, so the cast is needed here): <br><pre> <code class="cpp hljs">MultiListWidget::MultiListWidget() { connect(model(), SIGNAL(rowsInserted(QModelIndex, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(slotModelRowsInserted(QModelIndex,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>))); connect(model(), SIGNAL(rowsRemoved(QModelIndex, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(slotModelRowsRemoved(QModelIndex,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>))); QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); connect(standartModel, SIGNAL(itemChanged(QStandardItem*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(slotModelItemChanged(QStandardItem*))); } MultiListWidget::~MultiListWidget() { }</code> </pre><br>  Now, we implement the checkedItems () and setCheckedItems methods (const QStringList &amp; items): <br><pre> <code class="cpp hljs">QStringList MultiListWidget::checkedItems() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mCheckedItems; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::setCheckedItems(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QStringList &amp;items) { <span class="hljs-comment"><span class="hljs-comment">//   QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); //   ,      disconnect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); for (int i = 0; i &lt; items.count(); ++i) { //    int index = findText(items.at(i)); if (index != -1) { //    standartModel-&gt;item(index)-&gt;setData(Qt::Checked, Qt::CheckStateRole); } } //    connect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); //     collectCheckedItems(); }</span></span></code> </pre><br>  Inside the collectCheckedItems () method, everything is simple - go over the elements of the model, if it is checked, add to the list: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::collectCheckedItems() { QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); mCheckedItems.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count(); ++i) { QStandardItem *currentItem = standartModel-&gt;item(i); Qt::CheckState checkState = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Qt::CheckState&gt;(currentItem-&gt;data(Qt::CheckStateRole).toInt()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkState == Qt::Checked) { mCheckedItems.push_back(currentItem-&gt;text()); } } }</code> </pre><br>  When inserting a new element into the model, we need to specify that it will be marked by the user and initially with the unchecked box: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::slotModelRowsInserted(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> end) { <span class="hljs-comment"><span class="hljs-comment">//     (void)parent; QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); disconnect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); for (int i = start; i &lt;= end; ++i) { standartModel-&gt;item(i)-&gt;setFlags(Qt::ItemIsUserCheckable | Qt::ItemIsEnabled); standartModel-&gt;item(i)-&gt;setData(Qt::Unchecked, Qt::CheckStateRole); } connect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); }</span></span></code> </pre><br>  When removing items from the model, you also need to remove them from mCheckedItems.  We use collectCheckedItems (): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::slotModelRowsRemoved(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QModelIndex &amp;parent, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> end) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)parent; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)start; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)end; collectCheckedItems(); }</code> </pre><br>  In slotModelItemChanged slot (QStandardItem * item) we collect the marked items: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::slotModelItemChanged(QStandardItem *item) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)item; collectCheckedItems(); }</code> </pre><br>  Place the class declaration and its implementation in, respectively, multilist.h and multilist.cpp, and try MultiListWidget in the file (main.cpp file): <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"multilist.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { QApplication app(argc, argv); MultiListWidget *multiList = new MultiListWidget(); multiList-&gt;addItems(QStringList() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "One" &lt;&lt; "Two" &lt;&lt; "Three" &lt;&lt; "Four"); multiList-&gt;setCheckedItems(QStringList() &lt;&lt; "One" &lt;&lt; "Three"); QHBoxLayout *layout = new QHBoxLayout(); layout-&gt;addWidget(new QLabel("Select items:")); layout-&gt;addWidget(multiList, 1); QWidget widget; widget.setWindowTitle("MultiList example"); widget.setLayout(layout); widget.show(); return app.exec(); }</span></span></span></span></code> </pre><br>  Not bad, but it remains to display a list of selected items on the widget.  To do this, we declare (in the closed section) in the class a variable to store the text for the output, a delta for the rectangle (the explanation will be lower), within which this text will be drawn, and a method that updates the text for the output when changing the list of marked elements: <br><pre> <code class="cpp hljs">QString mDisplayText; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect mDisplayRectDelta; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDisplayText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  Add the initialization of mDisplayRectDelta to the constructor: <br><pre> <code class="cpp hljs">MultiListWidget::MultiListWidget() : mDisplayRectDelta(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-25</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre><br>  Now, let's take a closer look at updateDisplayText (): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::updateDisplayText() { <span class="hljs-comment"><span class="hljs-comment">//    , mDisplayRectDelta   ""  //   ,    ,   QRect textRect = rect().adjusted(mDisplayRectDelta.left(), mDisplayRectDelta.top(), mDisplayRectDelta.right(), mDisplayRectDelta.bottom()); QFontMetrics fontMetrics(font()); //   mDisplayText = mCheckedItems.join(", "); //      if (fontMetrics.size(Qt::TextSingleLine, mDisplayText).width() &gt; textRect.width()) { //   ,       while (mDisplayText != "" &amp;&amp; fontMetrics.size(Qt::TextSingleLine, mDisplayText + "...").width() &gt; textRect.width()) { mDisplayText.remove(mDisplayText.length() - 1, 1); } //   mDisplayText += "..."; } }</span></span></code> </pre><br>  To draw text, you must override the paintEvent virtual method (QPaintEvent * event).  You also need to override the resizeEvent (QResizeEvent * event) method, since the text borders will change when the widget is resized.  Here is the declaration of these methods: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QPaintEvent *event)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resizeEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QResizeEvent *event)</span></span></span></span>;</code> </pre><br>  And their implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::paintEvent(QPaintEvent *event) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)event; <span class="hljs-function"><span class="hljs-function">QStylePainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">painter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; painter.setPen(palette().color(QPalette::Text)); QStyleOptionComboBox option; initStyleOption(&amp;option); <span class="hljs-comment"><span class="hljs-comment">//     painter.drawComplexControl(QStyle::CC_ComboBox, option); //     QRect textRect = rect().adjusted(mDisplayRectDelta.left(), mDisplayRectDelta.top(), mDisplayRectDelta.right(), mDisplayRectDelta.bottom()); //   painter.drawText(textRect, Qt::AlignVCenter, mDisplayText); } void MultiListWidget::resizeEvent(QResizeEvent *event) { (void)event; updateDisplayText(); }</span></span></code> </pre><br>  It remains only to update the displayed text after changing the list of model elements.  Add the updateDisplayText () call to the collectCheckedItems () end and redraw the widget: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MultiListWidget::setCheckedItems(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QStringList &amp;items) { ... updateDisplayText(); repaint(); }</code> </pre><br>  There is a <a href="https://bugreports.qt-project.org/browse/QTBUG-3948">bug</a> in GTK and Mac styles that do not display the checkboxes in the expanded list.  To work around this bug, you need to set the combobox-popup values ‚Äã‚Äãin the widget's styleSheet (place this code in the constructor): <br><pre> <code class="cpp hljs">setStyleSheet(<span class="hljs-string"><span class="hljs-string">"QComboBox { combobox-popup: 1px }"</span></span>);</code> </pre><br>  Images: <br><img src="https://habrastorage.org/getpro/habr/post_images/8ef/071/47e/8ef07147ebd93f6b898d54cc37868099.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b0/13e/52a/1b013e52ad697d7a7969ac56b373ab14.png"><br><br>  Source: <br><br><div class="spoiler">  <b class="spoiler_title">multilist.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MULTILIST_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MULTILIST_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QtGui&gt; class MultiListWidget : public QComboBox { Q_OBJECT Q_PROPERTY(QStringList checkedItems READ checkedItems WRITE setCheckedItems) public: MultiListWidget(); virtual ~MultiListWidget(); QStringList checkedItems() const; void setCheckedItems(const QStringList &amp;items); protected: virtual void paintEvent(QPaintEvent *event); virtual void resizeEvent(QResizeEvent *event); private: QStringList mCheckedItems; void collectCheckedItems(); QString mDisplayText; const QRect mDisplayRectDelta; void updateDisplayText(); private slots: void slotModelRowsInserted(const QModelIndex &amp;parent, int start, int end); void slotModelRowsRemoved(const QModelIndex &amp;parent, int start, int end); void slotModelItemChanged(QStandardItem *item); }; #endif // MULTILIST_H</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">multilist.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"multilist.h"</span></span></span><span class="hljs-meta"> MultiListWidget::MultiListWidget() : mDisplayRectDelta(4, 1, -25, 0) { setStyleSheet(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"QComboBox { combobox-popup: 1px }"</span></span></span><span class="hljs-meta">); connect(model(), SIGNAL(rowsInserted(QModelIndex, int, int)), this, SLOT(slotModelRowsInserted(QModelIndex,int,int))); connect(model(), SIGNAL(rowsRemoved(QModelIndex, int, int)), this, SLOT(slotModelRowsRemoved(QModelIndex,int,int))); QStandardItemModel *standartModel = qobject_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QStandardItemModel*&gt;(model()); connect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); } MultiListWidget::~MultiListWidget() { } QStringList MultiListWidget::checkedItems() const { return mCheckedItems; } void MultiListWidget::setCheckedItems(const QStringList &amp;items) { QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); disconnect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); for (int i = 0; i &lt; items.count(); ++i) { int index = findText(items.at(i)); if (index != -1) { standartModel-&gt;item(index)-&gt;setData(Qt::Checked, Qt::CheckStateRole); } } connect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); collectCheckedItems(); } void MultiListWidget::paintEvent(QPaintEvent *event) { (void)event; QStylePainter painter(this); painter.setPen(palette().color(QPalette::Text)); QStyleOptionComboBox option; initStyleOption(&amp;option); painter.drawComplexControl(QStyle::CC_ComboBox, option); QRect textRect = rect().adjusted(mDisplayRectDelta.left(), mDisplayRectDelta.top(), mDisplayRectDelta.right(), mDisplayRectDelta.bottom()); painter.drawText(textRect, Qt::AlignVCenter, mDisplayText); } void MultiListWidget::resizeEvent(QResizeEvent *event) { (void)event; updateDisplayText(); } void MultiListWidget::collectCheckedItems() { QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); mCheckedItems.clear(); for (int i = 0; i &lt; count(); ++i) { QStandardItem *currentItem = standartModel-&gt;item(i); Qt::CheckState checkState = static_cast&lt;Qt::CheckState&gt;(currentItem-&gt;data(Qt::CheckStateRole).toInt()); if (checkState == Qt::Checked) { mCheckedItems.push_back(currentItem-&gt;text()); } } updateDisplayText(); repaint(); } void MultiListWidget::updateDisplayText() { QRect textRect = rect().adjusted(mDisplayRectDelta.left(), mDisplayRectDelta.top(), mDisplayRectDelta.right(), mDisplayRectDelta.bottom()); QFontMetrics fontMetrics(font()); mDisplayText = mCheckedItems.join(", "); if (fontMetrics.size(Qt::TextSingleLine, mDisplayText).width() &gt; textRect.width()) { while (mDisplayText != "" &amp;&amp; fontMetrics.size(Qt::TextSingleLine, mDisplayText + "...").width() &gt; textRect.width()) { mDisplayText.remove(mDisplayText.length() - 1, 1); } mDisplayText += "..."; } } void MultiListWidget::slotModelRowsInserted(const QModelIndex &amp;parent, int start, int end) { (void)parent; QStandardItemModel *standartModel = qobject_cast&lt;QStandardItemModel*&gt;(model()); disconnect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); for (int i = start; i &lt;= end; ++i) { standartModel-&gt;item(i)-&gt;setFlags(Qt::ItemIsUserCheckable | Qt::ItemIsEnabled); standartModel-&gt;item(i)-&gt;setData(Qt::Unchecked, Qt::CheckStateRole); } connect(standartModel, SIGNAL(itemChanged(QStandardItem*)), this, SLOT(slotModelItemChanged(QStandardItem*))); } void MultiListWidget::slotModelRowsRemoved(const QModelIndex &amp;parent, int start, int end) { (void)parent; (void)start; (void)end; collectCheckedItems(); } void MultiListWidget::slotModelItemChanged(QStandardItem *item) { (void)item; collectCheckedItems(); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"multilist.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { QApplication app(argc, argv); MultiListWidget *multiList = new MultiListWidget(); multiList-&gt;addItems(QStringList() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "One" &lt;&lt; "Two" &lt;&lt; "Three" &lt;&lt; "Four"); multiList-&gt;setCheckedItems(QStringList() &lt;&lt; "One" &lt;&lt; "Three"); QHBoxLayout *layout = new QHBoxLayout(); layout-&gt;addWidget(new QLabel("Select items:")); layout-&gt;addWidget(multiList, 1); QWidget widget; widget.setWindowTitle("MultiList example"); widget.setLayout(layout); widget.show(); return app.exec(); }</span></span></span></span></code> </pre><br></div></div><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/215289/">https://habr.com/ru/post/215289/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215275/index.html">1000+ hours of Java video in Russian</a></li>
<li><a href="../215281/index.html">TeleGeography Underwater Internet Map 2014</a></li>
<li><a href="../215283/index.html">The logic of thinking. Part 9. Patterns of neuron detectors. Reverse projection</a></li>
<li><a href="../215285/index.html">Online City Design Course with Video Games, Board Games and Movies</a></li>
<li><a href="../215287/index.html">The logic of thinking. Part 10. Spatial self-organization</a></li>
<li><a href="../215291/index.html">2048</a></li>
<li><a href="../215295/index.html">Calculation of statistics of downloads in Google Analytics</a></li>
<li><a href="../215299/index.html">Wi-Fi Network: Single-Channel Architecture vs Multi-Channel Architecture</a></li>
<li><a href="../215303/index.html">How to build high-rise buildings in 2 months, and cities per 100,000 inhabitants in 2 years</a></li>
<li><a href="../215305/index.html">Tyvskvotting contrary</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>