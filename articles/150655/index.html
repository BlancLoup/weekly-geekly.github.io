<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interception of video in the browser or TCP sniffer under Windows on the knee (part one)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once, not so long ago, I was recommended a background rocking of streaming video called Jaksta , which allows you to record streaming video to disk ri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interception of video in the browser or TCP sniffer under Windows on the knee (part one)</h1><div class="post__text post__text-html js-mediator-article">  Once, not so long ago, I was recommended a background rocking of streaming video called <a href="http://www.jaksta.com/">Jaksta</a> , which allows you to record streaming video to disk right while watching YouTube, Facebook video, GoogleVideo, and so on.  As a result of its installation, I received a strong BSOD on every Windows boot.  Switching to Safe Mode, I demolished this creature, but there were questions. <br>  A brief study of the software showed that it installs the NDIS Miniport driver, which specifically in my system began to die when it was loaded.  ‚ÄúWhat for such difficulties?‚Äù, I thought, and decided to experiment with the implementation of the interception of streaming video from the browser without any drivers. <br><a name="habracut"></a><br><h4>  Foreword </h4><br>  This opus assumes some knowledge of Windows, WinAPI and some C ++, so if some obvious moments for me require more detailed explanation, then ask.  I will immediately clarify that there is no ready-made program for intercepting videos built on the principles outlined in this post (at least I have not written anything like this).  There are some blanks and theoretical fabrications, mostly motivated as antagonists to the solution with the NDIS Miniport driver and blue screens. <br>  So, if it is hypothetical to assume that we have a module capable of intercepting HTTP or TCP / IP packets from the browser, how exactly will we catch the video?  There are two options: <br><br><ol><li>  Analyze URLs as URLs. <br>  To do this, you will need to intercept outgoing packets containing HTTP GET, and look where exactly this GET is sent.  The decision is rather dubious, because it requires specific knowledge of a particular site.  On the other hand, addresses matching the ‚Äú <a href="http://www.youtube.com/watch%3Fv%3Do78nFVB1tJA">www.youtube.com/watch?v=o78nFVB1tJA</a> ‚Äù type of template will allow you to filter requests for streaming video directly BEFORE receiving the stream. </li><li>  Check replies from server <br>  This will require intercepting incoming packets and checking their HTTP headers for Content-Type.  Obviously, for the video they will be specific to specific formats.  For example, for the aforementioned Flash Video link from YouTube, <s>where I play the saxophone, the</s> server‚Äôs response will contain the header ‚ÄúContent-Type: video / x-flv‚Äù, which unequivocally informs us that Flash Video will follow the headline.  In the case of MPEG4, the header will contain video / mp4 and so on. </li></ol><br>  The final solution will probably require a combination of 1) and 2) to work effectively, but in this post we will first focus on the interception of packets. <br><br><h4>  Pitfalls and DLL injection </h4><br>  The first thing that comes to mind to write an interceptor is to inject a DLL into the browser process.  Some in this place will stop reading, because then everything is clear.  Whoever can understand everything can <a href="">download the source code here</a> and the compiled version <a href="">here</a> (yes, only 3Kb).  If you decide to try how it all works, then I strongly recommend taking a 32-bit browser and cutting down all the software that uses similar tricks, such as <a href="http://www.admuncher.com/">AdMuncher</a> (hello Murray &amp; shannow!), Because this example didn‚Äôt want to spit on correct cohabitation with such software (this correctable).  Search for results in the form of .log files in% TEMP%. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For all the others, it is necessary to clarify something, although system traps and the introduction of DLLs in Windows processes are a rather trite topic.  The end result of introducing your DLL into the browser process will look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75f/196/12e/75f19612e08d54e230e302f941b8b747.jpg" alt="image"><br><br>  That is, within each process of the browser will sit our samopisnaya DLL, which will intercept the necessary packets.  Immediately two questions arise <br><br><ol><li>  How to implement a DLL? </li><li>  How to catch packages? </li></ol><br>  Let's try to answer them below ... <br><br><h4>  The introduction of a DLL in someone else's process </h4><br>  At the first stage, it is obvious that we need to write two modules - the main application and the DLL.  The main application will be implemented, and the DLL will be implemented accordingly.  Without further ado, run Vistual Studio and immediately write the main application (Injector.cpp): <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> comment(linker, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/entry:WinMain /nodefaultlib"</span></span></span><span class="hljs-meta">) void APIENTRY winMain() { HMODULE interceptor = LoadLibrary(TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Interceptor.dll"</span></span></span><span class="hljs-meta">)); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (interceptor != NULL) { HOOKPROC cbtHook = (HOOKPROC) GetProcAddress(interceptor, (LPCSTR) 1); HHOOK hHook = (HHOOK) SetWindowsHookEx(WH_CBT, cbtHook, interceptor, 0); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (hHook != NULL) { MessageBox(NULL, TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Press OK to terminate."</span></span></span><span class="hljs-meta">), TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Interceptor is working."</span></span></span><span class="hljs-meta">), MB_OK); UnhookWindowsHookEx(hHook); } FreeLibrary(interceptor); } }</span></span></code> </pre> <br>  What does the above code do?  In the first line for reasons of compactness of the code, we put the entry point into the application directly in WinMain (), without preludes.  In the source, I generally cut off MSVCRT as unnecessary. <br>  Next, we load our interceptor, find the export function in it at number 1 (import by ordinal) and set up a global CBT type trap using the created parameters.  Then we simply display a modal message to click the "OK" button to complete and go to the astral.  Everything.  This is enough to inject DLLs into all processes that somehow use User32 WinAPI to work with windows. <br>  CBT is short for Computer-Based Training.  The WH_CBT trap is generally good because ‚Äú... The system calls this trap before activating, creating, destroying, minimizing, maximizing, moving or resizing a window.  And the same before the completion of the system command, before removing the keyboard or mouse event from the message queue, before setting the input focus and before synchronizing with the system message queue ... ‚ÄùThis is a free translation of MSDN.  In fact, this means that it will work for 99% of applications that are written in accordance with the standard window architecture. <br>  The beauty of this method is that in fact we don‚Äôt have to mess around with the Windows trap system as such. <br><br><h4>  Start writing a DLL </h4><br>  Since we are writing an interceptor, and not something else, it will be enough for him that: <br><ol><li>  The application initializes the DLL when it is loaded into the process. </li><li>  The DLL will remain in the address space of the process until its completion. </li><li>  On completion or on an external event, the application deinitializes the DLL before unloading. </li></ol><br>  It is worth saying that this technique requires that the modules match the digit capacity.  This means that a 64-bit browser will need a 64-bit DLL interceptor, the same goes for 32-bit applications.  You should not expect that a 32-bit interceptor will be loaded into a 64-bit application, and the more so on the contrary. <br>  So, let's write the skeleton of the future interceptor (Interceptor.cpp): <br><br><pre> <code class="cpp hljs">HINSTANCE g_hDllInstance; <span class="hljs-comment"><span class="hljs-comment">//  ,     LRESULT CALLBACK CBT_Hook(int nCode, WPARAM wParam, LPARAM lParam) { return 0; } //        BOOL onLoad() { return TRUE; } //        BOOL onUnload() { return TRUE; } BOOL WINAPI DllMain(HINSTANCE hDllInstance, DWORD dwReason, LPVOID lpRsrv) { switch(dwReason) { case DLL_PROCESS_ATTACH: DisableThreadLibraryCalls(hDllInstance); g_hDllInstance = hDllInstance; return onDllLoad(); break; case DLL_PROCESS_DETACH: return onDllUnload(); break; default: break; } return TRUE; }</span></span></code> </pre><br>  In addition, we need to specify export at number 1. To do this, we write a standard DEF file (Interceptor.def) and do not forget to feed it to the linker via the / DEF parameter: <br><br><pre> <code class="cpp hljs">LIBRARY Intercept EXPORTS CBT_Hook @<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Everything.  Now the DLL is glued to the processes and sits in them until completion.  In order for us not to be injected into unnecessary processes and behave correctly inside the main application (yes, yes, because it also loads and initializes the DLL) we will do an additional check: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *appsToIntercept[] = { <span class="hljs-string"><span class="hljs-string">"chrome.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"iexplore.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"opera.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"firefox.exe"</span></span>, <span class="hljs-string"><span class="hljs-string">"safari.exe"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> thisProcessPath[MAX_PATH], *thisProcessName; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> thisDllPath[MAX_PATH], *thisDllName; <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ BOOL rv = FALSE; <span class="hljs-comment"><span class="hljs-comment">//       thisProcessPath     thisProcessName GetModuleFileName(NULL, thisProcessPath, sizeof(thisProcessPath) - 1); GetFullPathName(thisProcessPath, sizeof(thisProcessPath), thisProcessPath, &amp;thisProcessName); *(TCHAR*) ((TCHAR*) (thisProcessName - sizeof(TCHAR))) = 0; //     DLL  thisDllPath   DLL  thisDllName GetModuleFileName(g_hDllInstance, thisDllPath, sizeof(thisDllPath) - 1); GetFullPathName(thisDllPath, sizeof(thisDllPath), thisDllPath, &amp;thisDllName); *(TCHAR*) ((TCHAR*) (thisDllName - sizeof(TCHAR))) = 0; //      ,       if (!lstrcmpi(thisProcessPath, thisDllPath)) return TRUE; //        for (int i = 0; appsToIntercept[i] != 0; i++) { if (!lstrcmpi(thisProcessName, appsToIntercept[i])) { rv = TRUE; break; } } //          ,   if (!rv) return FALSE; //     WinSock2 return installHooks(); }</span></span></code> </pre><br>  Thus, if the application is unknown to us, then we are not loading it.  Now we are going to directly intercept the WinSock functions. <br><br><h4>  Function interception mechanism </h4><br>  First you need to clarify the obvious things.  Since those to whom everything is already clear to this line anyway will not finish reading, I will indent it.  To my amazement, I realized that some programmers, who are very smart and advanced, do not always clearly understand how the system libraries work in Windows processes.  In this regard, I strongly recommend to view another post on Habr√© - <a href="http://habrahabr.ru/post/148194/">"Step-by-step guide to executable files (EXE) Windows"</a> . <br><br>  It is important to understand this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d44/285/d59/d44285d59bc1f0fbfc4e48083a5af446.jpg" alt="image"><br><br>  All DLL libraries, including system libraries and those specified in the PE header as imports, are loaded directly into the address space of the application that uses them.  From a logical point of view, each running application has its own individual set of copies of system and other DLLs. <br>  Thus, the easiest way to intercept packets in the browser is to intercept a call to certain functions in the system library responsible for sending and receiving packets.  At this point, some will stop reading again, because everything is again clear and nothing new, with which I fully agree.  But for all the others I will continue. <br>  Interception can be done at different levels: WinHTTP, WinINet, WinSock.  For me, the most versatile is the interception of WinSock functions from the WS2_32.DLL library.  It has its drawbacks, especially when working with HTTPS, where packets are encrypted.  For HTTPS, from my point of view, the best solution would be to intercept WinHTTP functions and / or OpenSSL libraries.  But let's start with a simple one. <br><br>  So, we highlight the main points of what we need to do: <br><ol><li>  Determine the address of the function being intercepted </li><li>  Rewrite the function call at the entry point so that its own handler is called. </li><li>  In your own handler, perform certain actions before calling the original function. </li><li>  Call the original function </li><li>  Save result </li><li>  In your own handler, perform certain actions after calling the original function </li><li>  Return the result to the call procedure </li></ol><br>  According to ancient traditions of backward compatibility in Windows, there are several ways to do the same thing by calling different functions, so we will try to catch them all.  For our task, there should be enough interception of the following from WS2_32: <br><ul><li>  send () </li><li>  WSASend () </li><li>  recv () </li><li>  WSARecv () </li><li>  WSAGetOverlappedResult () </li><li>  connect () </li><li>  WSAConnect () </li><li>  closesocket () </li></ul><br>  And the last three are needed solely for the purpose of creating and destroying the context tied to a particular connection, if it is needed at all.  In this example, I will try to get rid of the context in general.  However, in reality, it will most likely be needed to correctly assemble the HTTP request pairs ‚Äî an HTTP response.  In this case, the connect () and WSAConnect () interception is strictly not necessary, since a new context for the new socket can be created de facto when it is first written to it. <br>  So, as we will get in our DLL structure to rewrite and restore the entry point in the WinSock functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      typedef struct _APIHOOK { BOOL isInstalled; //    ? const TCHAR *moduleName; //   () const TCHAR *functionName; //    LPVOID newAddr; //    LPVOID oldAddr; //    DWORD oldCodeSize; //      char newCode[HOOK_CODE_SIZE]; //   char oldCode[HOOK_CODE_SIZE]; //   } APIHOOK, *PAPIHOOK;</span></span></code> </pre><br>  About what HOOK_CODE_SIZE is and what it depends on to read further. <br><br><h4>  Some assembly language </h4><br>  To intercept the function call at the entry point, we will have to patch the code.  So, the simplest algorithm would be: <br><ol><li>  Define your handler. <br>  In this case, the type of call to cdecl or stdcall, as well as all input parameters must be exactly the same as in the original function, otherwise we will spoil the stack. </li><li>  Determine the entry point to the function of interest <br>  With this all simple, you need to call GetProcAddress () from kernel32.dll. </li><li>  Save code from function entry point <br>  Here, too, everything is simple - byte-by-copy to a secluded place </li><li>  Patch entry point <br>  Roughly speaking, it all comes down to rewriting the code at the entry point so that when you call it, there is a transition to our handler. </li></ol><br><img src="http://s1.bild.me/bilder/160512/6098304HookExplained.jpg" alt="image"><br><br>  There are several different methods of interception, from a functional point of view.  The simplest method is to constantly rewrite the code at the very beginning of the entry point from the original to its own and back (when calling the original function).  There are more complex methods in which you do not need to constantly rewrite the code, but which require the writing of an instruction analyzer in order to correctly implement your interceptor in the middle of the original function.  Let us dwell on the simplest - rewriting at the beginning of the code. <br>  Again, there are several ways to call your handler.  Without going into details, I‚Äôll highlight two of them: unconditional jump and return through the call stack.  In the first case, the concept is: <br><br><pre> <code class="cpp hljs">MyFuncHandler: &lt;blablablablabla&gt; OriginalFunction: JMP MyFunHandler</code> </pre><br>  This is extremely simple and in a 32-bit expression requires 5 bytes, one for the code of the JMP unconditional instruction instruction and four for the relative address.  Why relative, later.  In the second case, the concept is slightly different: <br><br><pre> <code class="cpp hljs">MyFuncHandler: &lt;blablablablabla&gt; OriginalFunction: PUSH MyFuncHandler RETN</code> </pre><br>  This requires 6 bytes - two bytes for the PUSH &lt;32-bit DWORD&gt; and RETN instruction codes and four for the absolute address.  Yes Yes.  In the first case, the address is considered relative to the current address of the executable code.  In the second, it is constant and is considered relative to the beginning of the address space.  I will go first method. <br>  We write the interceptor installer: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    #define HOOK_CODE_SIZE 5 // JMP XX XX XX XX //    BOOL hookInstall(PAPIHOOK thisHook) { UCHAR asmJMP = 0xE9; if (!thisHook || thisHook-&gt;isInstalled == TRUE) { SetLastError(ERROR_ALREADY_EXISTS); return FALSE; //   ,      } //      if (thisHook-&gt;moduleName &amp;&amp; thisHook-&gt;functionName &amp;&amp; !(thisHook-&gt;oldAddr = GetProcAddress( GetModuleHandle(thisHook-&gt;moduleName), thisHook-&gt;functionName) ) ) { SetLastError(ERROR_NOT_FOUND); return FALSE; //   ,      } //      if (IsBadReadPtr(thisHook-&gt;oldAddr, HOOK_CODE_SIZE)) { SetLastError(ERROR_INVALID_ADDRESS); return FALSE; //   } //            if ( *(DWORD*)((PBYTE) thisHook-&gt;oldAddr + 1) == ((DWORD) thisHook-&gt;newAddr - (DWORD) thisHook-&gt;oldAddr - HOOK_CODE_SIZE) &amp;&amp; *(BYTE*) thisHook-&gt;oldAddr == asmJMP) { return TRUE; //       ,     } //           DWORD oldFlags; if (!VirtualProtect(thisHook-&gt;oldAddr, HOOK_CODE_SIZE, PAGE_EXECUTE_READWRITE, &amp;oldFlags) || IsBadWritePtr(thisHook-&gt;oldAddr, HOOK_CODE_SIZE)) { SetLastError(ERROR_WRITE_PROTECT); return FALSE; //     } //       memcpy(thisHook-&gt;oldCode, thisHook-&gt;oldAddr, HOOK_CODE_SIZE); //  JMP thisHook-&gt;newCode[0] = asmJMP; //    *(DWORD *) &amp;thisHook-&gt;newCode[1] = ((DWORD) thisHook-&gt;newAddr - HOOK_CODE_SIZE - (DWORD) thisHook-&gt;oldAddr); //     thisHook-&gt;isInstalled = TRUE; //      #define hookEnable(p) memcpy(p-&gt;oldAddr, p-&gt;newCode, HOOK_CODE_SIZE); //      #define hookDisable(p) memcpy(p-&gt;oldAddr, p-&gt;oldCode, HOOK_CODE_SIZE); //   hookEnable(thisHook); return TRUE; }</span></span></code> </pre><br>  I do not think that the above code needs additional explanation.  It is worth noting that we first form the patched code in the structure responsible for the content of information about the interceptor functions, and we make the patch itself using macros via memcpy ().  Fans of aesthetics can add a lock there, but in my opinion this is unnecessary, guess why? <br>  To enable the trap, we copy the new code that contains only the transition to the address of its own handler.  To turn off the trap, we restore the 5 original bytes stored in the array as oldCode. <br>  Since we have written the setting of a trap on a function, it is worth writing and restoring the initial state of the function code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     BOOL hookRemove(PAPIHOOK thisHook) { //   ,     if (!thisHook-&gt;isInstalled) return FALSE; //    hookDisable(thisHook); //      thisHook-&gt;isInstalled = FALSE; //        thisHook-&gt;newAddr = (LPVOID) NULL; thisHook-&gt;oldAddr = (LPVOID) NULL; return TRUE; }</span></span></code> </pre><br>  Now, when we can integrate into the process, set, remove, turn on and off traps, it's time to do their own handlers. <br><br><h4>  WinSock proprietary function handlers </h4><br>  So, first, let's define an array of prototypes of intercepted functions.  As stated above, we will try to intercept only the most necessary functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      #define DECLARE_HOOK(module, name) {0, module, #name, my_##name} //       APIHOOK hookList[] = { DECLARE_HOOK(winSockDll, send), DECLARE_HOOK(winSockDll, WSASend), DECLARE_HOOK(winSockDll, recv), DECLARE_HOOK(winSockDll, WSARecv), DECLARE_HOOK(winSockDll, WSAGetOverlappedResult), DECLARE_HOOK(winSockDll, closesocket), 0};</span></span></code> </pre><br>  As can be seen from the macro, each system function with an abstract name name has its own handler named my_name.  Now it is necessary to determine the handlers specified in the array.  Let's do it on the example of send (): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> WSAAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SOCKET s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span><span class="hljs-function"> </span></span>{ PAPIHOOK thisHook = hookFind(my_send); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == thisHook) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; hookDisable(thisHook); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rv; rv = send(s, buf, len, flags); hookEnable(thisHook); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br>  This will look like an empty wrapper for a system function that does nothing except what the original code calls.  Since the wrapper is essentially the same for all its own handlers, it makes sense to make a couple of macros for the convenience of determining them: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        #define DEFINE_HOOK(RTYPE, CTYPE, NAME, ARGS)\ RTYPE CTYPE my_##NAME ##ARGS \ { \ PAPIHOOK thisHook = hookFind(my_##NAME); \ if (NULL == thisHook) \ return (RTYPE) 0; \ hookDisable(thisHook); \ RTYPE rv;</span></span></code> </pre><br>  and to exit the function too: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        #define LEAVE_HOOK() } \ hookEnable(thisHook); \ return rv;</span></span></code> </pre><br>  Next, we use these macros to determine the remaining traps from the array. <br><br><h4>  Setting traps </h4><br>  The last line in our OnLoad () calls a kind of magic function InstallHooks ().  Since we have all the components of the solution, we will write a batch installation of all the specific pitfalls: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      BOOL installHooks() { BOOL rv = FALSE; for (int i = 0; hookList[i].moduleName; i++) { if (hookInstall(&amp;hookList[i])) rv = TRUE; } return rv; }</span></span></code> </pre><br>  That's so concise.  And batch trap removal is no less concise: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      BOOL removeHooks() { BOOL rv = FALSE; for (int i = 0; hookList[i].moduleName; i++) { if (hookRemove(&amp;hookList[i])) rv = TRUE; } return rv; }</span></span></code> </pre><br><br><h4>  HTTP packet interception </h4><br>  Well, we smoothly got to the most interesting.  So, we have two types of packages - HTTP requests and HTTP responses.  Accordingly, the first are sent by functions like send (), the second are received by functions of type recv ().  Send functions must be intercepted BEFORE calling the original code, while the send buffer is still pristine.  The reception functions, respectively, must be intercepted AFTER the execution of the initial code, otherwise we will not see what exactly is accepted. <br>  There are asynchronous functions.  The idea is simple.  When WSASend () or WSARecv () is called, the WSAOVERLAPPED structure is specified in which Event is written.  Asynchronous functions are completed instantly, and upon completion they give out SOCKET_ERROR with GetLastError () set to WSA_IO_PENDING.  Next, the main application waits for the Event event in any way, for example, WaitForSingleObject (), and as soon as the event status is set, the application reads the buffer through WSAGetOverlappedResult (). <br>  If you can easily remove data from synchronous functions, you will have to tinker with asynchronous a bit.  At the beginning of the post I mentioned that it would not be possible to get rid of contexts completely, and asynchronous operations are exactly that why.  In more detail.  Calling WSAGetOverlappedResult () does not carry any information about the send or receive buffer.  Therefore, it is obvious that you need to create a context and store a pointer to a buffer there. <br>  There is one more reason why context is needed.  Since for our task, of intercepting streaming video, HTTP requests and responses are also required, the most logical solution is to assemble disparate send (), recv () calls in pairs.  So let's set up a structure for a context that will be suitable for collecting pairs of HTTP requests and responses, and for working with <br>  asynchronous functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">REQUEST</span></span></span><span class="hljs-class"> {</span></span> SOCKET socket; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *request; LPWSABUF wsaBuf; PREQUEST next; }</code> </pre><br>  What is the need for all of the above?  According to the socket <i>socket</i> number, we will determine the compliance of the request and response.  That is, the main application sends and receives a request on the same TCP socket, otherwise it cannot be.  The <i>request</i> pointer will refer to the HTTP request.  The <i>LPWSABUF</i> pointer will be used for asynchronous functions.  That is, when WSASend () / WSARecv () is called, we will save the pointer to the buffer, and when WSAGetOverlappedResult () completes it, we will remove it from there.  Again, matching is determined by the socket number. <br>  Looking ahead to say that for WSASend () asynchronous calls are not used in any of the browsers that I managed to test during the writing of this post and the interceptor blanks. <br>  What is <i>next used for</i> ?  To organize a single-linked list.  It is logical that contexts for request-response pairs should be placed somewhere so that they are not lost.  In order not to inflate the size of the program and not to use something like the STL templates, it was easiest for me to solve the puzzle for the school competition and write the implementation of a simply linked list.  As you will be better, see for yourself. <br>  Without going into details, let us describe the functions for working with a linked list of request-response contexts (see the source for details): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      PREQUEST findRequest(SOCKET s); //    -     PREQUEST addRequest(SOCKET s, char *request); //     void delRequest(SOCKET s);</span></span></code> </pre><br>  Next, we write a general handler for all send () functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      BOOL commonSendHandler(PAPIHOOK thisHook, SOCKET s, char *buf, int len, BOOL isWsa) { //      'GET '    if ‚Ä¶ //  HTTP  char *request = getHttpHeaders((const char *) buf, len); if (request != NULL) addRequest(s, request); return TRUE; }</span></span></code> </pre><br>  And the general handler for all recv (): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           BOOL commonRecvHandler(PAPIHOOK thisHook, SOCKET s, char *buf, int len, BOOL isWsa) { //      'HTTP'    if ‚Ä¶ //  ,    PREQUEST req = findRequest(s); if (NULL == req) return FALSE; //  HTTP  char *response = getHttpHeaders((const char *) buf, len); if (response != NULL) { //       ... delRequest(s); } return TRUE; }</span></span></code> </pre><br> .      .          'GET'  .   HTTP GET  HTTP        .           'HTTP'    ,       GET   .          .             %TEMP%\&lt; .exe&gt;-&lt; &gt;.log <br>     . ,   WSARecv(): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// WSARecv() DEFINE_HOOK(int, WSAAPI, WSARecv, (SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)) { rv = WSARecv(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine); //   if (!rv &amp;&amp; NULL != lpNumberOfBytesRecvd) { commonRecvHandler(thisHook, s, lpBuffers-&gt;buf, *lpNumberOfBytesRecvd, TRUE); } else //   if (rv == SOCKET_ERROR &amp;&amp; WSAGetLastError() == WSA_IO_PENDING) { //  WSARecv ,   WSA ,     PREQUEST req = findRequest(s); if (req != NULL) req-&gt;wsaBuf = lpBuffers; } LEAVE_HOOK(); }</span></span></code> </pre><br>     ,           .              read(): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// WSAGetOverlappedResult() DEFINE_HOOK(BOOL, WSAAPI, WSAGetOverlappedResult, (SOCKET s, LPWSAOVERLAPPED lpOverlapped, LPDWORD lpcbTransfer, BOOL fWait, LPDWORD lpdwFlags)) { rv = WSAGetOverlappedResult(s, lpOverlapped, lpcbTransfer, fWait, lpdwFlags); if (rv &amp;&amp; NULL != lpcbTransfer &amp;&amp; *lpcbTransfer &gt; MIN_HTTP_HEADER_SIZE) { // ,    ? PREQUEST req = findRequest(s); if (req != NULL &amp;&amp; req-&gt;wsaBuf != NULL) commonRecvHandler(thisHook, s, req-&gt;wsaBuf-&gt;buf, *lpcbTransfer, TRUE); } LEAVE_HOOK(); }</span></span></code> </pre><br>       closesocket()    ,       . , , ,  ,   YouTube‚Ä¶ <br><br>         Google Chrome        <a href="http://www.youtube.com/watch%3Fv%3Do78nFVB1tJA">www.youtube.com/watch?v=o78nFVB1tJA</a> (   ): <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">22</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>:<span class="hljs-number"><span class="hljs-number">48</span></span>] [SOCKET = <span class="hljs-number"><span class="hljs-number">0</span></span>EB0, REQUEST = <span class="hljs-number"><span class="hljs-number">1327</span></span> bytes, RESPONSE = <span class="hljs-number"><span class="hljs-number">329</span></span> bytes] -&gt;GET /videoplayback?algorithm=throttle-factor&amp;burst=<span class="hljs-number"><span class="hljs-number">40</span></span>&amp;cp=U0hTS1RRU19OTUNOM19MS1dBOlR1eGNSd1JHRkdy&amp;expire=<span class="hljs-number"><span class="hljs-number">1346465093</span></span>&amp;factor=<span class="hljs-number"><span class="hljs-number">1.25</span></span>&amp;fexp=<span class="hljs-number"><span class="hljs-number">926900</span></span>%<span class="hljs-number"><span class="hljs-number">2</span></span>C910103%<span class="hljs-number"><span class="hljs-number">2</span></span>C922401%<span class="hljs-number"><span class="hljs-number">2</span></span>C920704%<span class="hljs-number"><span class="hljs-number">2</span></span>C912806%<span class="hljs-number"><span class="hljs-number">2</span></span>C924412%<span class="hljs-number"><span class="hljs-number">2</span></span>C913558%<span class="hljs-number"><span class="hljs-number">2</span></span>C912706&amp;gcr=fi&amp;id=a3bf27155075b490&amp;ip=<span class="hljs-number"><span class="hljs-number">91.155</span></span><span class="hljs-number"><span class="hljs-number">.190</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>&amp;ipbits=<span class="hljs-number"><span class="hljs-number">8</span></span>&amp;itag=<span class="hljs-number"><span class="hljs-number">34</span></span>&amp;keepalive=yes&amp;key=yt1&amp;ms=au&amp;mt=<span class="hljs-number"><span class="hljs-number">1346441292</span></span>&amp;mv=m&amp;range=<span class="hljs-number"><span class="hljs-number">13</span></span><span class="hljs-number"><span class="hljs-number">-1781759</span></span>&amp;signature=<span class="hljs-number"><span class="hljs-number">7415093589702691B</span></span>2E46681B2EF24EC370C2F1F.D6D55168E2211687994A3F47D8919AC5470C567D&amp;source=youtube&amp;sparams=algorithm%<span class="hljs-number"><span class="hljs-number">2</span></span>Cburst%<span class="hljs-number"><span class="hljs-number">2</span></span>Ccp%<span class="hljs-number"><span class="hljs-number">2</span></span>Cfactor%<span class="hljs-number"><span class="hljs-number">2</span></span>Cgcr%<span class="hljs-number"><span class="hljs-number">2</span></span>Cid%<span class="hljs-number"><span class="hljs-number">2</span></span>Cip%<span class="hljs-number"><span class="hljs-number">2</span></span>Cipbits%<span class="hljs-number"><span class="hljs-number">2</span></span>Citag%<span class="hljs-number"><span class="hljs-number">2</span></span>Csource%<span class="hljs-number"><span class="hljs-number">2</span></span>Cupn%<span class="hljs-number"><span class="hljs-number">2</span></span>Cexpire&amp;sver=<span class="hljs-number"><span class="hljs-number">3</span></span>&amp;upn=GlJDbjcQ<span class="hljs-number"><span class="hljs-number">-2</span></span>w HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: oo---preferred---elia-hel1---v11---lscache1.c.youtube.com Connection: keep-alive User-Agent: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (Windows NT <span class="hljs-number"><span class="hljs-number">6.1</span></span>; WOW64) AppleWebKit/<span class="hljs-number"><span class="hljs-number">537.4</span></span> (KHTML, like Gecko) Chrome/<span class="hljs-number"><span class="hljs-number">22.0</span></span><span class="hljs-number"><span class="hljs-number">.1229</span></span><span class="hljs-number"><span class="hljs-number">.26</span></span> Safari/<span class="hljs-number"><span class="hljs-number">537.4</span></span> Accept: *<span class="hljs-comment"><span class="hljs-comment">/* Referer: http://www.youtube.com/watch?v=o78nFVB1tJA Accept-Encoding: gzip,deflate,sdch Accept-Language: en-US,en;q=0.8 Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3 Cookie: VISITOR_INFO1_LIVE=UxycPwPFJBs; __utma=27069237.1349026492.1343302158.1343302158.1343302158.1; __utmz=27069237.1343302158.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); use_hitbox=d5c5516c3379125f43aa0d495d100d6ddAEAAAAw; recently_watched_video_id_list=697d12b6b10771c1d93bb1bb4cf53148WwEAAABzCwAAAG83OG5GVkIxdEpB; PREF=fv=11.3.31; ACTIVITY=1346441327664 &lt;-HTTP/1.1 200 OK Last-Modified: Wed, 09 May 2012 00:20:14 GMT Content-Type: video/x-flv Date: Fri, 31 Aug 2012 19:28:48 GMT Expires: Fri, 31 Aug 2012 19:28:48 GMT Cache-Control: private, max-age=23465 Accept-Ranges: bytes Content-Length: 1781747 Connection: keep-alive X-Content-Type-Options: nosniff Server: gvs 1.0</span></span></code> </pre><br>           HTTP . <br><br> -    ,          ?       ,    . <br><br><h4>  findings </h4><br>      .          IPC        -.     : <br><ol><li>  URL           . </li><li>        .     IPC,    ,          . </li><li>               . </li></ol><br>   .        YouTube / Flash Video.         .          90%           ‚ÄùContent-type‚Äù. <br>   : <br><ul><li>      . <br>    ,          .         ,        .   -  ,          . </li><li>   HTTPS <br>  ,       HTTPS     NDIS Miniport .              WinHTTP  OpenSSL. </li></ul><br>  ?  : <br><br><ol><li>             .        HTTP ,     .             TCP/IP. </li><li>       WinSock.                 .         . </li></ol><br>     -  . <br><br> <b>UPD:</b>  <a href="http://habrahabr.ru/post/150933/"> </a>      . <br><br>  Respectfully, <br> //st </div><p>Source: <a href="https://habr.com/ru/post/150655/">https://habr.com/ru/post/150655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150649/index.html">Valve like open source technology</a></li>
<li><a href="../150650/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ20 (August 25 - 31, 2012)</a></li>
<li><a href="../150651/index.html">Ruby NoName Podcast S04E16</a></li>
<li><a href="../150652/index.html">Windows 8 is a work of art. But this is not Linux</a></li>
<li><a href="../150654/index.html">How to copy an array correctly and what does it have to do with SFINAE</a></li>
<li><a href="../150656/index.html">web site (story)</a></li>
<li><a href="../150657/index.html">Real-time log analysis</a></li>
<li><a href="../150658/index.html">Raising money for a space elevator</a></li>
<li><a href="../150661/index.html">Putting dots on Li: Do I need to train lithium batteries?</a></li>
<li><a href="../150664/index.html">Command line in Firefox 16</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>