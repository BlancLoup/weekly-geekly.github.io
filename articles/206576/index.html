<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL interaction with an external image storage service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. When working with a database for a site, sometimes there is a situation when you have to choose how and where to store images. Among the pos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL interaction with an external image storage service</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/31d/418/41f/31d41841f8783931a3bab223e42d272b.png"><br>  Good day.  When working with a database for a site, sometimes there is a situation when you have to choose how and where to store images.  Among the possible options, as a rule, there are the following: <br><ul><li>  the images are entirely in the database </li><li>  the images are in the file system, the file name is stored in the database </li><li>  images are in an external specialized service </li></ul><br>  Although <b>PostgreSQL</b> provides the ability to store files in the database (directly in <i>bytea</i> fields or through <a href="http://www.postgresql.org/docs/9.3/static/largeobjects.html">large objects</a> ), this is the least optimal option, both in terms of speed and memory consumption.  Another common practice is to store images in the form of files on a disk, the path to the image is formed for the site.  Of the benefits - the ability to cache or use a specialized file system.  And the third option - a separate service is allocated for images, in which there can be caching, scaling on the fly, format change.  Let's try to implement the interaction of <b>PostgreSQL</b> with such a service. <br><a name="habracut"></a><br><h4>  Implementation </h4><br>  Outline a little picture of what is happening.  We have an http service, like <a href="https://github.com/Magomogo/barberry-service">this</a> , for images that supports these commands: <br><ul><li>  image upload - sending a POST request with a form, JSON with some image information, among which is the generated identifier, comes back </li><li>  image acquisition - sending a GET request with image identifier <i><a href="http://my.service.local/1001">my.service.local / 1001</a></i> </li><li>  image deletion - sending a DELETE request with image identifier <i><a href="http://my.service.local/1001">my.service.local / 1001</a></i> </li></ul><br>  Image identifiers will be stored in the database, in this case, it will be possible to insert tags like this on the pages of the site: <br><pre>  &lt;img src = "http: //my.service.local/1001" /&gt; </pre><br>  From the user‚Äôs side, image loading (as well as saving and deleting) should look like a call to the <i>upload_image</i> function (with the <i>filename</i> parameter), which returns the image identifier in the service, which is then written to the table.  Since it is impossible to access http requests directly from <b>PostgreSQL</b> , it is necessary to implement the required functionality on the stored functions in C, and they already have some fun in them.  For simplicity, let's do the <b>curl</b> and <b>jansson libraries</b> (the last one for working with JSON).  We can start. <br><br>  Define our function prototypes in the header file <i>barberry_impl.h</i> : <br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// get last error char* barberry_error(); // upload file to BarBerry's service and return ID int barberry_upload_file(const char *host, const char *filename); // download file from BarBerry's service by ID int barberry_download_file(const char *host, int id, const char *filename); // delete file from BarBerry's service by ID int barberry_delete_file(const char *host, int id);</span></span></code> </pre> <br>  In the source file <i>barberry_impl.c we place the</i> following global variables: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> last_error[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; FILE *file = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  The variable <i>last_error</i> will store the last error, <i>file</i> is a pointer to the file created when receiving data from the service, and the <i>result</i> will preserve the result of the functions of working with the service. <br><br>  The implementation of the <i>barberry_error</i> function is trivial - return <i>last_error</i> .  Let us examine in detail the function <i>barberry_upload_file</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Before you start working with <b>curl</b> , you need to initialize the environment for it (with the <i>curl_gobal_init</i> command) and create a session (with the <i>curl_easy_init</i> command that <i>returns a</i> pointer to the session handle).  Next, create a submit form (via <i>curl_formadd</i> ) and fill in the following options: <br><ul><li>  CURLOPT_URL - the host we work with </li><li>  CURLOPT_HTTPPOST - form sent by POST method </li><li>  CURLOPT_WRITEFUNCTION - CALLBACK function for the response from the host </li></ul><br>  Implementation <i>barberry_upload_file</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">barberry_upload_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *filename)</span></span></span><span class="hljs-function"> </span></span>{ result = <span class="hljs-number"><span class="hljs-number">-1</span></span>; curl_global_init(CURL_GLOBAL_ALL); CURL *curl = curl_easy_init(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curl) { curl_easy_setopt(curl, CURLOPT_URL, host); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curl_httppost</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">httppost</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curl_httppost</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last_ptr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> curl_formadd(&amp;httppost, &amp;last_ptr, CURLFORM_COPYNAME, <span class="hljs-string"><span class="hljs-string">"sendfile"</span></span>, CURLFORM_FILE, filename, CURLFORM_END); curl_formadd(&amp;httppost, &amp;last_ptr, CURLFORM_COPYNAME, <span class="hljs-string"><span class="hljs-string">"submit"</span></span>, CURLFORM_COPYCONTENTS, <span class="hljs-string"><span class="hljs-string">"send"</span></span>, CURLFORM_END); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, upload_response); curl_easy_setopt(curl, CURLOPT_HTTPPOST, httppost); CURLcode res = curl_easy_perform(curl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res != CURLE_OK) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, curl_easy_strerror(res)); } curl_easy_cleanup(curl); curl_formfree(httppost); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  The upload_response CALLBACK function has a prototype: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> function(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nmemb, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *userdata);</code> </pre><br>  with parameters: <br><ul><li>  ptr - pointer to the received data </li><li>  size * nmemb - their size </li><li>  userdata - pointer to FILE *, if necessary, set via the CURLOPT_WRITEDATA option </li></ul><br>  The function must return the actual size of the processed data, i.e.  size * nmemb.  In this, in this function it is necessary to parse the JSON transmitted in the response: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> upload_response(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nmemb, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *userdata) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)userdata; parse_upload_response(ptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size * nmemb; }</code> </pre><br>  Assign this to another function in which we use <b>jansson</b> to parse the answer: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_upload_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(text, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">json_error_t</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">json_t</span></span> *root = json_loads(text, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;error); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, text); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">json_t</span></span> *id = json_object_get(root, <span class="hljs-string"><span class="hljs-string">"id"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!json_is_integer(id)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, text); json_decref(root); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } result = json_integer_value(id); json_decref(root); }</code> </pre><br>  In the case of an empty file, we will receive the answer {}, we will process this case.  If everything is in order, the file has been successfully uploaded. The answer will come in the form: {"id": 1001, "ext": "png" ...}.  Interests only id, and write it to result. <br><br>  The function to save the file is a bit simpler - you just need to form a GET request, get an answer and write it to a file (after handling the situation when the file with the required id is not found): <br><div class="spoiler">  <b class="spoiler_title">barberry_download_file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">barberry_download_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *filename)</span></span></span><span class="hljs-function"> </span></span>{ result = <span class="hljs-number"><span class="hljs-number">0</span></span>; file = fopen(filename, <span class="hljs-string"><span class="hljs-string">"wb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"Can't create file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } curl_global_init(CURL_GLOBAL_ALL); CURL *curl = curl_easy_init(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curl) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"%s/%d"</span></span>, host, id); curl_easy_setopt(curl, CURLOPT_URL, buffer); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, download_response); CURLcode res = curl_easy_perform(curl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res != CURLE_OK) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, curl_easy_strerror(res)); result = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } curl_easy_cleanup(curl); } fclose(file); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">download_response</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> download_response(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nmemb, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *userdata) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)userdata; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(ptr, <span class="hljs-string"><span class="hljs-string">"{}"</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"File on server not found"</span></span>); result = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fwrite(ptr, size * nmemb, <span class="hljs-number"><span class="hljs-number">1</span></span>, file); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size * nmemb; }</code> </pre><br></div></div><br>  Deleting a file in the service is a DELETE request (the request type for <b>curl is</b> set via the CURLOPT_CUSTOMREQUEST option): <br><div class="spoiler">  <b class="spoiler_title">barberry_delete_file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">barberry_delete_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ result = <span class="hljs-number"><span class="hljs-number">0</span></span>; curl_global_init(CURL_GLOBAL_ALL); CURL *curl = curl_easy_init(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curl) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"%s/%d"</span></span>, host, id); curl_easy_setopt(curl, CURLOPT_URL, buffer); curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, <span class="hljs-string"><span class="hljs-string">"DELETE"</span></span>); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, delete_response); CURLcode res = curl_easy_perform(curl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res != CURLE_OK) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(last_error, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, curl_easy_strerror(res)); result = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } curl_easy_cleanup(curl); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">delete_response</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> delete_response(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nmemb, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *userdata) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)ptr; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)userdata; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size * nmemb; }</code> </pre><br></div></div><br>  Before moving on to the PostgreSQL part, let's write a small console utility to test our functions.  In it, we check the passed parameters, if they are as expected (example in <i>print_help</i> ), then we do the necessary actions: <br><div class="spoiler">  <b class="spoiler_title">barberry_test.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"barberry_impl.h"</span></span></span><span class="hljs-meta"> void print_help() { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Usage:\n"</span></span></span><span class="hljs-meta">); fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" bbtest upload my.service.local /home/username/image1000.png\n"</span></span></span><span class="hljs-meta">); fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" bbtest download my.service.local 1000 /home/username/image1000.png\n"</span></span></span><span class="hljs-meta">); fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" bbtest delete my.service.local 1000\n\n"</span></span></span><span class="hljs-meta">); } int main(int argc, char *argv[]) { (void)argc; (void)argv; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc &lt;= 2) { print_help(); return 0; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(argv[1], </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"upload"</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 4) { print_help(); return 0; } int id = barberry_upload_file(argv[2], argv[3]); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (id != -1) { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File uploaded with id %d\n"</span></span></span><span class="hljs-meta">, id); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, barberry_error()); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(argv[1], </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"download"</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 5) { print_help(); return 0; } int result = barberry_download_file(argv[2], atoi(argv[3]), argv[4]); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (result != -1) { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File downloaded"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, barberry_error()); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(argv[1], </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"delete"</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 4) { print_help(); return 0; } int result = barberry_delete_file(argv[2], atoi(argv[3])); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (result != -1) { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File deleted"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, barberry_error()); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { print_help(); } return 0; }</span></span></code> </pre><br></div></div><br>  Putting it all together (paths in your OS to header files and libraries may differ) and test: <br><pre> <code class="bash hljs">cc -c barberry_impl.c cc -c barberry_test.c cc -L/usr/lib -lcurl -ljansson -o bbtest barberry_test.o barberry_impl.o ./bbtest upload my.service.local ~/picture01.png File uploaded with id 1017</code> </pre><br>  If everything is in order, you can proceed to the PostgreSQL part of our library (for more information about stored C functions in PostgreSQL, see <b>[4]</b> ). <br><br>  Let's announce the functions exported for the database (with version 1): <br><pre> <code class="cpp hljs">PG_FUNCTION_INFO_V1(bb_upload_file); PG_FUNCTION_INFO_V1(bb_download_file); PG_FUNCTION_INFO_V1(bb_delete_file);</code> </pre><br>  To convert from text (type in PostgreSQL) to c-string, a small function will help: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">text_to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text *txt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = VARSIZE(txt) - VARHDRSZ; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)palloc(size + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(buffer, VARDATA(txt), size); buffer[size] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre><br>  The implementation of the exported functions consists in the delegation of the previously written functional, with the generation of an error if something went wrong: <br><div class="spoiler">  <b class="spoiler_title">bb_upload_file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Datum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bb_upload_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PG_FUNCTION_ARGS)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *host = text_to_string(PG_GETARG_TEXT_P(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *filename = text_to_string(PG_GETARG_TEXT_P(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = barberry_upload_file(host, filename); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { elog(ERROR, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, barberry_error()); } pfree(host); pfree(filename); PG_RETURN_INT32(result); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">bb_download_file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Datum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bb_download_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PG_FUNCTION_ARGS)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *host = text_to_string(PG_GETARG_TEXT_P(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = PG_GETARG_INT32(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *filename = text_to_string(PG_GETARG_TEXT_P(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = barberry_download_file(host, id, filename); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { elog(ERROR, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, barberry_error()); } pfree(host); pfree(filename); PG_RETURN_VOID(); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">bb_delete_file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Datum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bb_delete_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PG_FUNCTION_ARGS)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *host = text_to_string(PG_GETARG_TEXT_P(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = PG_GETARG_INT32(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = barberry_delete_file(host, id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { elog(ERROR, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, barberry_error()); } pfree(host); PG_RETURN_VOID(); }</code> </pre><br></div></div><br>  We compile a dynamic library and copy it to <b>PostgreSQL</b> (paths in your OS to header files and libraries may differ): <br><pre> <code class="bash hljs">rm -rf *.o cc -I/usr/include/postgresql/server -fpic -c barberry.c cc -I/usr/include/postgresql/server -fpic -c barberry_impl.c cc -L/usr/lib -lpq -lcurl -ljansson -shared -o barberry.so barberry.o barberry_impl.o cp *.so /usr/lib/postgresql</code> </pre><br>  The SQL functions created in the database are: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.bb_upload_file ( p_host <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, p_filename <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'barberry'</span></span>, <span class="hljs-string"><span class="hljs-string">'bb_upload_file'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> c VOLATILE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.bb_download_file ( p_host <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, p_id <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, p_filename <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'barberry'</span></span>, <span class="hljs-string"><span class="hljs-string">'bb_download_file'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> c VOLATILE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> public.bb_delete_file ( p_host <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, p_id <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'barberry'</span></span>, <span class="hljs-string"><span class="hljs-string">'bb_delete_file'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> c VOLATILE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>;</code> </pre><br>  Let's create a dynamic library and SQL script as an extension to PostgreSQL (described in more detail in <b>[5]</b> ).  This will require the control file <i>barberry.control</i> : <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># BarBerry image service comment = 'BarBerry image service' default_version = '1.0' module_pathname = '$libdir/barberry' relocatable = true</span></span></code> </pre><br>  The SQL script for our extension must be named as <i>barberry - 1.0.sql</i> (according to the <b>PostgreSQL</b> documentation).  Copy these two files to where <b>PostgreSQL</b> stores its extensions. <br><br>  Creating and using an extension is extremely simple: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION barberry; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> avatar <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> image = bb_upload_file ( <span class="hljs-string"><span class="hljs-string">'my.service.local'</span></span>, <span class="hljs-string"><span class="hljs-string">'images/avatar_admin.png'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'admin'</span></span>;</code> </pre><br><h4>  Source files </h4><br>  Your library is a small utility, so it is not hosted on github.  To facilitate the assembly, a Makefile has been added with barberry, barberry_test, clean, rebuild, install goals. <br><div class="spoiler">  <b class="spoiler_title">barberry_impl.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> BARBERRY_IMPL_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BARBERRY_IMPL_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;curl/curl.h&gt; #include &lt;jansson.h&gt; // get last error char* barberry_error(); // upload file to BarBerry's service and return ID int barberry_upload_file(const char *host, const char *filename); // download file from BarBerry's service by ID int barberry_download_file(const char *host, int id, const char *filename); // delete file from BarBerry's service by ID int barberry_delete_file(const char *host, int id); #endif // BARBERRY_IMPL_H</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">barberry_impl.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"barberry_impl.h"</span></span></span><span class="hljs-meta"> char last_error[1024]; FILE *file = NULL; int result = 0; void parse_upload_response(const char *text) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(text, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{}"</span></span></span><span class="hljs-meta">)) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Empty file"</span></span></span><span class="hljs-meta">); return; } json_error_t </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">; json_t *root = json_loads(text, 0, &amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!root) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, text); return; } json_t *id = json_object_get(root, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"id"</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(!json_is_integer(id)) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, text); json_decref(root); return; } result = json_integer_value(id); json_decref(root); } size_t upload_response(char *ptr, size_t size, size_t nmemb, void *userdata) { (void)userdata; parse_upload_response(ptr); return size * nmemb; } size_t download_response(char *ptr, size_t size, size_t nmemb, void *userdata) { (void)userdata; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(ptr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{}"</span></span></span><span class="hljs-meta">)) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File on server not found"</span></span></span><span class="hljs-meta">); result = -1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fwrite(ptr, size * nmemb, 1, file); } return size * nmemb; } size_t delete_response(char *ptr, size_t size, size_t nmemb, void *userdata) { (void)ptr; (void)userdata; return size * nmemb; } char* barberry_error() { return last_error; } int barberry_upload_file(const char *host, const char *filename) { result = -1; curl_global_init(CURL_GLOBAL_ALL); CURL *curl = curl_easy_init(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (curl) { curl_easy_setopt(curl, CURLOPT_URL, host); struct curl_httppost *httppost = NULL; struct curl_httppost *last_ptr = NULL; curl_formadd(&amp;httppost, &amp;last_ptr, CURLFORM_COPYNAME, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sendfile"</span></span></span><span class="hljs-meta">, CURLFORM_FILE, filename, CURLFORM_END); curl_formadd(&amp;httppost, &amp;last_ptr, CURLFORM_COPYNAME, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"submit"</span></span></span><span class="hljs-meta">, CURLFORM_COPYCONTENTS, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"send"</span></span></span><span class="hljs-meta">, CURLFORM_END); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, upload_response); curl_easy_setopt(curl, CURLOPT_HTTPPOST, httppost); CURLcode res = curl_easy_perform(curl); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (res != CURLE_OK) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, curl_easy_strerror(res)); } curl_easy_cleanup(curl); curl_formfree(httppost); } return result; } int barberry_download_file(const char *host, int id, const char *filename) { result = 0; file = fopen(filename, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"wb"</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!file) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Can't create file"</span></span></span><span class="hljs-meta">); return -1; } curl_global_init(CURL_GLOBAL_ALL); CURL *curl = curl_easy_init(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (curl) { char buffer[1024]; sprintf(buffer, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s/%d"</span></span></span><span class="hljs-meta">, host, id); curl_easy_setopt(curl, CURLOPT_URL, buffer); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, download_response); CURLcode res = curl_easy_perform(curl); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (res != CURLE_OK) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, curl_easy_strerror(res)); result = -1; } curl_easy_cleanup(curl); } fclose(file); return result; } int barberry_delete_file(const char *host, int id) { result = 0; curl_global_init(CURL_GLOBAL_ALL); CURL *curl = curl_easy_init(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (curl) { char buffer[1024]; sprintf(buffer, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s/%d"</span></span></span><span class="hljs-meta">, host, id); curl_easy_setopt(curl, CURLOPT_URL, buffer); curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"DELETE"</span></span></span><span class="hljs-meta">); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, delete_response); CURLcode res = curl_easy_perform(curl); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (res != CURLE_OK) { sprintf(last_error, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s"</span></span></span><span class="hljs-meta">, curl_easy_strerror(res)); result = -1; } curl_easy_cleanup(curl); } return result; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">barberry.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;postgres.h&gt; #include &lt;fmgr.h&gt; #include "barberry_impl.h" #ifdef PG_MODULE_MAGIC PG_MODULE_MAGIC; #endif PG_FUNCTION_INFO_V1(bb_upload_file); PG_FUNCTION_INFO_V1(bb_download_file); PG_FUNCTION_INFO_V1(bb_delete_file); char* text_to_string(text *txt) { size_t size = VARSIZE(txt) - VARHDRSZ; char *buffer = (char*)palloc(size + 1); memcpy(buffer, VARDATA(txt), size); buffer[size] = '\0'; return buffer; } Datum bb_upload_file(PG_FUNCTION_ARGS) { char *host = text_to_string(PG_GETARG_TEXT_P(0)); char *filename = text_to_string(PG_GETARG_TEXT_P(1)); int result = barberry_upload_file(host, filename); if (result == -1) { elog(ERROR, "%s", barberry_error()); } pfree(host); pfree(filename); PG_RETURN_INT32(result); } Datum bb_download_file(PG_FUNCTION_ARGS) { char *host = text_to_string(PG_GETARG_TEXT_P(0)); int id = PG_GETARG_INT32(1); char *filename = text_to_string(PG_GETARG_TEXT_P(2)); int result = barberry_download_file(host, id, filename); if (result == -1) { elog(ERROR, "%s", barberry_error()); } pfree(host); pfree(filename); PG_RETURN_VOID(); } Datum bb_delete_file(PG_FUNCTION_ARGS) { char *host = text_to_string(PG_GETARG_TEXT_P(0)); int id = PG_GETARG_INT32(1); int result = barberry_delete_file(host, id); if (result == -1) { elog(ERROR, "%s", barberry_error()); } pfree(host); PG_RETURN_VOID(); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">barberry_test.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"barberry_impl.h"</span></span></span><span class="hljs-meta"> void print_help() { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Usage:\n"</span></span></span><span class="hljs-meta">); fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" bbtest upload my.service.local /home/username/image1000.png\n"</span></span></span><span class="hljs-meta">); fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" bbtest download my.service.local 1000 /home/username/image1000.png\n"</span></span></span><span class="hljs-meta">); fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" bbtest delete my.service.local 1000\n\n"</span></span></span><span class="hljs-meta">); } int main(int argc, char *argv[]) { (void)argc; (void)argv; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc &lt;= 2) { print_help(); return 0; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(argv[1], </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"upload"</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 4) { print_help(); return 0; } int id = barberry_upload_file(argv[2], argv[3]); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (id != -1) { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File uploaded with id %d\n"</span></span></span><span class="hljs-meta">, id); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, barberry_error()); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(argv[1], </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"download"</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 5) { print_help(); return 0; } int result = barberry_download_file(argv[2], atoi(argv[3]), argv[4]); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (result != -1) { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File downloaded"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, barberry_error()); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!strcmp(argv[1], </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"delete"</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (argc != 4) { print_help(); return 0; } int result = barberry_delete_file(argv[2], atoi(argv[3])); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (result != -1) { fprintf(stdout, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"File deleted"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { fprintf(stderr, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%s\n"</span></span></span><span class="hljs-meta">, barberry_error()); } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { print_help(); } return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">barberry - 1.0.sql</b> <div class="spoiler_text"><pre> <code class="cpp hljs">CREATE OR REPLACE FUNCTION <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>.bb_upload_file ( p_host text, p_filename text ) RETURNS integer AS <span class="hljs-string"><span class="hljs-string">'barberry'</span></span>, <span class="hljs-string"><span class="hljs-string">'bb_upload_file'</span></span> LANGUAGE c VOLATILE STRICT; CREATE OR REPLACE FUNCTION <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>.bb_download_file ( p_host text, p_id integer, p_filename text ) RETURNS <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AS <span class="hljs-string"><span class="hljs-string">'barberry'</span></span>, <span class="hljs-string"><span class="hljs-string">'bb_download_file'</span></span> LANGUAGE c VOLATILE STRICT; CREATE OR REPLACE FUNCTION <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>.bb_delete_file ( p_host text, p_id integer ) RETURNS <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AS <span class="hljs-string"><span class="hljs-string">'barberry'</span></span>, <span class="hljs-string"><span class="hljs-string">'bb_delete_file'</span></span> LANGUAGE c VOLATILE STRICT</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">barberry.control</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># BarBerry image service comment = 'BarBerry image service' default_version = '1.0' module_pathname = '$libdir/barberry' relocatable = true</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">################################# # Makefile for barberry library # ################################# # options CC=cc CFLAGS=-fpic -c INCLUDEPATH=-I/usr/include/postgresql/server LIBS=-L/usr/lib -lpq -lcurl -ljansson # targets all: barberry barberry_test barberry: barberry.o barberry_impl.o $(CC) $(LIBS) -shared -o barberry.so barberry.o barberry_impl.o barberry_test: barberry_test.o barberry_impl.o $(CC) $(LIBS) -o bbtest barberry_test.o barberry_impl.o barberry.o: $(CC) $(INCLUDEPATH) $(CFLAGS) barberry.c barberry_impl.o: $(CC) $(INCLUDEPATH) $(CFLAGS) barberry_impl.c barberry_test.o: $(CC) $(INCLUDEPATH) $(CFLAGS) barberry_test.c clean: rm -rf *.o *.so bbtest rebuild: clean all install: cp *.so /usr/lib/postgresql cp *.control /usr/share/postgresql/extension cp *.sql /usr/share/postgresql/extension</span></span></code> </pre><br></div></div><br><h4>  Notes </h4><br><ul><li>  since the dynamic library is loaded on behalf of postgres (the default user for the DBMS), it must also have access to the downloaded files and the right to create saved files </li><li>  You can extend the idea by making an interface for accessing <b>curl</b> from <b>PostgreSQL</b> , screwing up a description of the form, headers and everything else in XML format, then parsing it in C code and executing the corresponding commands in <b>curl</b> </li></ul><br><h4>  Bibliography </h4><br><ol><li>  <a href="http://www.postgresql.org/docs/9.3/static/index.html">PostgreSQL documentation</a> . </li><li>  <a href="http://curl.haxx.se/libcurl/c/allfuncs.html">Curl documentation</a> . </li><li>  <a href="https://jansson.readthedocs.org/en/2.5/">Documentation on jansson</a> . </li><li>  <a href="http://habrahabr.ru/post/196544/">Stored functions on C in PostgreSQL</a> . </li><li>  <a href="http://habrahabr.ru/post/198332/">Creating extensions in PostgreSQL</a> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/206576/">https://habr.com/ru/post/206576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206566/index.html">Remote code execution on EBay</a></li>
<li><a href="../206568/index.html">One forecast given 15 years ago</a></li>
<li><a href="../206570/index.html">Course work: "The legal aspects of the development of an open operating system ReactOS"</a></li>
<li><a href="../206572/index.html">Removing 4096-bit RSA keys with a microphone</a></li>
<li><a href="../206574/index.html">Axure RP PRO 7 out of beta</a></li>
<li><a href="../206578/index.html">Special offer from Marmalade Technologies Ltd for Tizen application developers</a></li>
<li><a href="../206582/index.html">Implementation of backup on hardlinks under Windows</a></li>
<li><a href="../206586/index.html">The best advertising Bitcoin - from Pavel Durov</a></li>
<li><a href="../206588/index.html">Updated mobile poster for children and parents, reference book with geolocation for iOS</a></li>
<li><a href="../206590/index.html">Network modernization in Chuvashia: why our network is similar to formulas from organic chemistry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>