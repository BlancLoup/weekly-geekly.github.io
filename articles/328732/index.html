<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Let there be a movie with Xamarin.Forms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the coolest trends in mobile user interface design can safely be called the use of video as a background for rendering. As an example, the Tumb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Let there be a movie with Xamarin.Forms</h1><div class="post__text post__text-html js-mediator-article">  One of the coolest trends in mobile user interface design can safely be called the use of video as a background for rendering.  As an example, the Tumblr, Spotify, and Vine apps.  In this article we will analyze how to implement a similar solution in the Xamarin.Forms application, and in the end we will talk about the measures to be taken soon in St. Petersburg.  All we need is to implement two custom renderers for Android and for iOS separately. <br><br><img src="https://habrastorage.org/web/751/536/48b/75153648bf504e85af6e8e5f057c5f7a.jpg"><br><a name="habracut"></a><br><h2>  Creating a background video control for Xamarin.Forms </h2><br>  Let's first create a new project Xamarin.Forms PCL and call it <code>BackgroundVideo</code> .  Now let's go to the PCL library and create a new class named <code>Video</code> , inherited from <code>Xamarin.Forms.View</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Xamarin.Forms; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">BackgroundVideo.Controls</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Video</span></span> : <span class="hljs-title"><span class="hljs-title">View</span></span> { } }</code> </pre> <br>  In order not to complicate the description, we will try to create this control with simple requirements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to specify which video will be displayed, we need a binding property.  I will call it the <code>Source</code> property.  This is a string to determine which video file to play.  In iOS, the <code>Source</code> property is related to the <code>Resources</code> directory, whereas in Android it refers to the <code>Assets</code> directory. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BindableProperty SourceProperty = BindableProperty.Create( <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Source), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Video), <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty, BindingMode.TwoWay); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Source { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)GetValue(SourceProperty); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { SetValue(SourceProperty, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); }</code> </pre><br>  The next thing we need is a logical value to determine if the video is required in a loop or not.  Let's call this property <code>Loop</code> .  Initially, this value is set to <code>true</code> , so when you set the video <code>Source</code> property - <code>Source</code> this property will loop by default. <br><br>  Finally, we need a callback that will trigger when the video ends.  For simplicity, I use an <code>Action</code> class called <code>OnFinishedPlaying</code> .  You can change it to an event or something that is convenient. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BindableProperty LoopProperty = BindableProperty.Create( <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Loop), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Video), <span class="hljs-literal"><span class="hljs-literal">true</span></span>, BindingMode.TwoWay); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Loop { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>)GetValue(LoopProperty); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { SetValue(LoopProperty, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Action OnFinishedPlaying { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  After creating this class, you need to implement custom renderers for iOS and Android. <br><br><h2>  Customizable iOS renderer for managing background video </h2><br>  First of all, you need to create a custom renderer class called <code>VideoRenderer</code> , which will inherit from <code>ViewRenderer&lt;Video, UIView&gt;</code> .  The idea is to use the native iOS video player using the <code>MPMoviePlayerController</code> class and set its native control to our custom <code>Video</code> view.  We will also need <code>NSObject</code> to analyze the event from the video player, determining whether it ended or not. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BackgroundVideo.Controls; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BackgroundVideo.iOS.Renderers; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Foundation; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MediaPlayer; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UIKit; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Xamarin.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Xamarin.Forms.Platform.iOS; [assembly: ExportRenderer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Video), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(VideoRenderer))] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">BackgroundVideo.iOS.Renderers</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VideoRenderer</span></span> : <span class="hljs-title"><span class="hljs-title">ViewRenderer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Video</span></span>, <span class="hljs-title"><span class="hljs-title">UIView</span></span>&gt; { MPMoviePlayerController videoPlayer; NSObject notification = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  To start the iOS video player, you need to check whether there is a video from the <code>Source</code> in the Resources node or not.  If it is not there, then an empty view will be displayed. <br><br>  If there is a video file, then you need to create <code>MPMoviePlayerController</code> and interpret the location of the video file as <code>NSUrl</code> .  To make the user control clear, without a border or anything else, you need to set <code>ControlStyle</code> to <code>MPMovieControlStyle.None</code> , and set the background color to <code>UIColor.Clear</code> . <br><br>  In addition, we will probably have one video file for any resolution.  We do not need to make the video look stretched on some device, right?  In order for the video resolution to always be correct, we need to install <code>ScalingMode</code> from the video player on <code>MPMovieScalingMode.AspectFill</code> . <br><br>  We also have a <code>Loop</code> property, which determines whether video playback will be looped or not.  To set the loop, you need to change the <code>RepeatMode</code> the video player to <code>MPMovieRepeatMode.One</code> .  Otherwise, set it to <code>MPMovieRepeatMode.None</code> . <br><br>  Finally, in order for the video player to play the file, we call the <code>PrepareToPlay()</code> function.  To display a video in a user control, you must use the <code>SetNativeControl()</code> function. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitVideoPlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path = Path.Combine(NSBundle.MainBundle.BundlePath, Element.Source); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!NSFileManager.DefaultManager.FileExists(path)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Video not exist"</span></span>); videoPlayer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MPMoviePlayerController(); videoPlayer.ControlStyle = MPMovieControlStyle.None; videoPlayer.ScalingMode = MPMovieScalingMode.AspectFill; videoPlayer.RepeatMode = MPMovieRepeatMode.One; videoPlayer.View.BackgroundColor = UIColor.Clear; SetNativeControl(videoPlayer.View); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Load the video from the app bundle. NSUrl videoURL = new NSUrl(path, false); // Create and configure the movie player. videoPlayer = new MPMoviePlayerController(videoURL); videoPlayer.ControlStyle = MPMovieControlStyle.None; videoPlayer.ScalingMode = MPMovieScalingMode.AspectFill; videoPlayer.RepeatMode = Element.Loop ? MPMovieRepeatMode.One : MPMovieRepeatMode.None; videoPlayer.View.BackgroundColor = UIColor.Clear; foreach (UIView subView in videoPlayer.View.Subviews) { subView.BackgroundColor = UIColor.Clear; } videoPlayer.PrepareToPlay(); SetNativeControl(videoPlayer.View); }</span></span></code> </pre> <br>  The rest of the work with the code is to override the <code>OnElementChanged</code> and <code>OnElementPropertyChanged</code> so that the code can be functionally operated from the Xamarin.Forms project.  In <code>OnElementChanged</code> we have to wait for the event of the end of playing the video player and call the <code>OnFinishedPlaying</code> command.  The following snippet is the simplest code necessary for this to work. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnElementChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElementChangedEventArgs&lt;Video&gt; e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnElementChanged(e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Control == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { InitVideoPlayer(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.OldElement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Unsubscribe notification?.Dispose(); } if (e.NewElement != null) { // Subscribe notification = MPMoviePlayerController.Notifications.ObservePlaybackDidFinish((sender, args) =&gt; { /* Access strongly typed args */ Console.WriteLine("Notification: {0}", args.Notification); Console.WriteLine("FinishReason: {0}", args.FinishReason); Element?.OnFinishedPlaying?.Invoke(); }); } } protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) { base.OnElementPropertyChanged(sender, e); if (Element == null || Control == null) return; if (e.PropertyName == Video.SourceProperty.PropertyName) { InitVideoPlayer(); } else if (e.PropertyName == Video.LoopProperty.PropertyName) { var liveImage = Element as Video; if (videoPlayer != null) videoPlayer.RepeatMode = Element.Loop ? MPMovieRepeatMode.One : MPMovieRepeatMode.None; } }</span></span></code> </pre> <br>  Now that the iOS implementation is complete, let's consider the Android project. <br><br><h2>  Custom video renderer for Android </h2><br>  Create a new custom renderer in the Android project and also name it <code>VideoRenderer</code> .  We inherit this renderer using <code>ViewRenderer&lt;Video, FrameLayout&gt;</code> , and this means that it will be displayed as <code>FrameLayout</code> in the native Android control. <br><br>  One of the difficulties in implementing an Android renderer is that we need two types of views if we also want to cover older versions of Android.  If you just want to cover the modern OS from Android Ice Cream Sandwich and above, you can just focus on the <code>TextureView</code> implementation, if this is not enough for you, then you will also need to implement it using <code>VideoView</code> . <br><br>  Please note that the implementation of <code>VideoView</code> is not optimal here.  You may notice some flicker.  That's why I added an empty view called <code>_placeholder</code> .  It will be displayed when the video does not play or when the video source changes.  If the video file is ready to play and display, then the <code>_placeholder</code> will be hidden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.Graphics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.Graphics.Drawables; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.Media; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.OS; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.Runtime; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.Views; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Android.Widget; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BackgroundVideo.Controls; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BackgroundVideo.Droid.Renderers; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Xamarin.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Xamarin.Forms.Platform.Android; [assembly: ExportRenderer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Video), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(VideoRenderer))] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">BackgroundVideo.Droid.Renderers</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VideoRenderer</span></span> : <span class="hljs-title"><span class="hljs-title">ViewRenderer</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Video</span></span>, <span class="hljs-title"><span class="hljs-title">FrameLayout</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">TextureView</span></span>.<span class="hljs-title"><span class="hljs-title">ISurfaceTextureListener</span></span>, <span class="hljs-title"><span class="hljs-title">ISurfaceHolderCallback</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _isCompletionSubscribed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FrameLayout _mainFrameLayout = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Android.Views.View _mainVideoView = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Android.Views.View _placeholder = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br>  And now, before deciding which video container is better to use, you must first implement the video player itself.  Android already has the class we need - <code>MediaPlayer</code> .  We should use this object and make sure that it is created only once.  We can reuse the same object as the video source changes. <br><br>  We need to set the <code>Completion</code> event to implement the <code>OnFinishedPlaying</code> .  In addition, you must set the <code>Looping</code> value for the <code>Loop</code> custom property. <br><br>  Something here is different from the implementation of the renderer in the case of iOS - there is not such a simple set of properties for displaying video in different resolutions, like fills in proportions!  So, we need to implement our own method in a custom function called <code>AdjustTextureViewAspect()</code> .  This function will be called in the <code>VideoSizeChanged</code> .  We will talk about this implementation later. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaPlayer _videoPlayer = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> MediaPlayer VideoPlayer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_videoPlayer == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _videoPlayer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MediaPlayer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isCompletionSubscribed) { _isCompletionSubscribed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _videoPlayer.Completion += Player_Completion; } _videoPlayer.VideoSizeChanged += (sender, args) =&gt; { AdjustTextureViewAspect(args.Width, args.Height); }; _videoPlayer.Info += (sender, args) =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"onInfo what={0}, extra={1}"</span></span>, args.What, args.Extra); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.What == MediaInfo.VideoRenderingStart) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"[MEDIA_INFO_VIDEO_RENDERING_START] placeholder GONE"</span></span>); _placeholder.Visibility = ViewStates.Gone; } }; _videoPlayer.Prepared += (sender, args) =&gt; { _mainVideoView.Visibility = ViewStates.Visible; _videoPlayer.Start(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Element != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) _videoPlayer.Looping = Element.Loop; }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _videoPlayer; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player_Completion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { Element?.OnFinishedPlaying?.Invoke(); }</code> </pre> <br>  Now that we have a video player object, our next task is to create a function that plays the video from the <code>Source</code> property.  Please remember that the video file on Android must be stored in the <code>Assets</code> directory.  This file can be opened using the <code>Assets.OpenFd(fullPath)</code> function. <br><br>  If the file does not exist, then the function will <code>Java.IO.IOException</code> .  This means that nothing needs to be displayed in the video container. <br><br>  If the file exists, we just need to reset the video player and then set the data source based on the previous step.  We can't just play the video directly, so we need to first prepare it.  After preparation is completed, the <code>Prepared</code> event is triggered and the video is displayed in one of the video presentations implemented in the previous stage. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayVideo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fullPath</span></span></span><span class="hljs-function">)</span></span> { Android.Content.Res.AssetFileDescriptor afd = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { afd = Context.Assets.OpenFd(fullPath); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Java.IO.IOException ex) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Play video: "</span></span> + Element.Source + <span class="hljs-string"><span class="hljs-string">" not found because "</span></span> + ex); _mainVideoView.Visibility = ViewStates.Gone; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Error openfd: "</span></span> + ex); _mainVideoView.Visibility = ViewStates.Gone; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (afd != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Lenght "</span></span> + afd.Length); VideoPlayer.Reset(); VideoPlayer.SetDataSource(afd.FileDescriptor, afd.StartOffset, afd.Length); VideoPlayer.PrepareAsync(); } }</code> </pre> <br>  As mentioned above, Android does not provide us with easy properties for scaling video by aspect ratio.  You probably know that Android devices have a lot of screen resolution options, so saving the video in its original form is not an option at all.  We need to scale it correctly so that it does not look stretched. <br><br>  The good news is that we, in general, can achieve this if we use <code>TextureView</code> .  The bad news is that at the moment I do not know how to implement it with <code>VideoView</code> .  But it's better than nothing, right? <br><br>  The idea of ‚Äã‚Äãgetting the video to scale correctly is to use a matrix to scale the contents of the <code>TextureView</code> .  Thus, video scaling occurs at the top or at the bottom, depending on the video size and presentation.  Then, after scaling, the video is located in the center of the view. <br><br>  As mentioned earlier, if we want to support a wide range of Android OSs, we need to implement this in <code>TextureView</code> and <code>VideoView</code> .  This will be done as part of the <code>OnElementChanged</code> function.  In the case of both implementations, the same properties are used.  We will make the background color transparent and adjust the layout parameters to match the parent element.  Thus, the background will not have a color that could be displayed in the absence of video, and this background will fill the entire container. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustTextureViewAspect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> videoWidth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> videoHeight</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(_mainVideoView <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TextureView)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Control == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> control = Control; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textureView = _mainVideoView <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TextureView; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controlWidth = control.Width; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controlHeight = control.Height; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aspectRatio = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)videoHeight / videoWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newWidth, newHeight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (controlHeight &lt;= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(controlWidth * aspectRatio)) { <span class="hljs-comment"><span class="hljs-comment">// limited by narrow width; restrict height newWidth = controlWidth; newHeight = (int)(controlWidth * aspectRatio); } else { // limited by short height; restrict width newWidth = (int)(controlHeight / aspectRatio); newHeight = controlHeight; } int xoff = (controlWidth - newWidth) / 2; int yoff = (controlHeight - newHeight) / 2; Console.WriteLine("video=" + videoWidth + "x" + videoHeight + " view=" + controlWidth + "x" + controlHeight + " newView=" + newWidth + "x" + newHeight + " off=" + xoff + "," + yoff); var txform = new Matrix(); textureView.GetTransform(txform); txform.SetScale((float)newWidth / controlWidth, (float)newHeight / controlHeight); txform.PostTranslate(xoff, yoff); textureView.SetTransform(txform); }</span></span></code> </pre> <br>  The following code snippet shows how to implement it in a custom renderer.  As you can see, the code is quite similar to the one we used when implementing the renderer for iOS, except for creating containers and playing videos. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnElementChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElementChangedEventArgs&lt;Video&gt; e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnElementChanged(e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Control == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _mainFrameLayout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(Context); _placeholder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Android.Views.View(Context) { Background = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorDrawable(Xamarin.Forms.Color.Transparent.ToAndroid()), LayoutParameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LayoutParams( ViewGroup.LayoutParams.MatchParent, ViewGroup.LayoutParams.MatchParent), }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SdkInt &lt; BuildVersionCodes.IceCreamSandwich) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Using VideoView"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> videoView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VideoView(Context) { Background = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorDrawable(Xamarin.Forms.Color.Transparent.ToAndroid()), Visibility = ViewStates.Gone, LayoutParameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LayoutParams( ViewGroup.LayoutParams.MatchParent, ViewGroup.LayoutParams.MatchParent), }; ISurfaceHolder holder = videoView.Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SdkInt &lt; BuildVersionCodes.Honeycomb) { holder.SetType(SurfaceType.PushBuffers); } holder.AddCallback(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _mainVideoView = videoView; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Using TextureView"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textureView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextureView(Context) { Background = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorDrawable(Xamarin.Forms.Color.Transparent.ToAndroid()), Visibility = ViewStates.Gone, LayoutParameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LayoutParams( ViewGroup.LayoutParams.MatchParent, ViewGroup.LayoutParams.MatchParent), }; textureView.SurfaceTextureListener = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; _mainVideoView = textureView; } _mainFrameLayout.AddView(_mainVideoView); _mainFrameLayout.AddView(_placeholder); SetNativeControl(_mainFrameLayout); PlayVideo(Element.Source); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.OldElement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Unsubscribe if (_videoPlayer != null &amp;&amp; _isCompletionSubscribed) { _isCompletionSubscribed = false; _videoPlayer.Completion -= Player_Completion; } } if (e.NewElement != null) { // Subscribe if (_videoPlayer != null &amp;&amp; !_isCompletionSubscribed) { _isCompletionSubscribed = true; _videoPlayer.Completion += Player_Completion; } } } protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) { base.OnElementPropertyChanged(sender, e); if (Element == null || Control == null) return; if (e.PropertyName == Video.SourceProperty.PropertyName) { Console.WriteLine("Play video: " + Element.Source); PlayVideo(Element.Source); } else if (e.PropertyName == Video.LoopProperty.PropertyName) { Console.WriteLine("Is Looping? " + Element.Loop); VideoPlayer.Looping = Element.Loop; } }</span></span></code> </pre> <br>  Since we use <code>TextureView</code> and <code>VideoView</code> , here it is necessary to implement some functions from the interfaces.  One of them is designed to remove the video when the texture (texture) or surface (surface) is destroyed.  To do this, we need to set the visibility&gt; <code>_placeholder</code> to visible. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveVideo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _placeholder.Visibility = ViewStates.Visible; }</code> </pre> <br>  When using TextureView, you must implement the <code>TextureView.ISurfaceTextureListener</code> interface.  We set the surface of the video player in case the texture is available and indicated the surface hiding when destroying the texture.  The following excerpt shows how to implement this. <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Surface Texture Listener public void OnSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) { Console.WriteLine("Surface.TextureAvailable"); VideoPlayer.SetSurface(new Surface(surface)); } public bool OnSurfaceTextureDestroyed(SurfaceTexture surface) { Console.WriteLine("Surface.TextureDestroyed"); RemoveVideo(); return false; } public void OnSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) { Console.WriteLine("Surface.TextureSizeChanged"); } public void OnSurfaceTextureUpdated(SurfaceTexture surface) { Console.WriteLine("Surface.TextureUpdated"); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span></span></code> </pre> <br>  When using <code>VideoView</code> you must implement the <code>ISurfaceHolderCallback</code> interface.  Similar to <code>TextureView</code> , we set the video player display to create the surface and indicated its concealment when the surface was destroyed.  The full implementation of this interface can be seen in the following fragment. <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Surface Holder Callback public void SurfaceChanged(ISurfaceHolder holder, [GeneratedEnum] Format format, int width, int height) { Console.WriteLine("Surface.Changed"); } public void SurfaceCreated(ISurfaceHolder holder) { Console.WriteLine("Surface.Created"); VideoPlayer.SetDisplay(holder); } public void SurfaceDestroyed(ISurfaceHolder holder) { Console.WriteLine("Surface.Destroyed"); RemoveVideo(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span></span></code> </pre> <br>  For Android, that was all we needed.  Now that we have everything we need, we can test this control on the Xamarin.Forms page. <br><br><h2>  Testing at Xamarin.Forms </h2><br>  Before creating a test page, it is recommended to prepare your own video file.  It is better to use vertical video to effectively use the space. <br><br>  If you don‚Äôt have a video to test, you can download it for free from <a href="https://coverr.co/">Coverr</a> .  There are no vertical videos, but we can still get what we need.  For example, you can either trim the video vertically, or use it as it is, since we already process the aspect scaling when filling in the code. <br><br>  So you can use any video that is at hand.  I recommend using any mp4 video file with h264 encoding.  In this example, I‚Äôm using a video from Coverr called <b><a href="">Orchestra</a></b> . <br><br>  <b>Help:</b> For some Android and iOS devices, especially older models, you need to make a reservation that they probably may not be able to play MP4 files.  This is mainly due to the lack of support for the base profile.  To get around this point, you can transcode the video with a tool like <code>ffmpeg</code> and change the base profile to your liking.  Refer to the following table to verify compatibility of basic profiles with iOS.  Read also the material <a href="https://developer.android.com/guide/topics/media/media-formats.html">Supported media formats</a> from the official Android manual. <br><br>  If you already have a video file, place it in the appropriate folders for each OS.  On Android, it should be placed in the <code>Assets</code> directory.  On iOS, it should be placed in the <code>Resources</code> directory.  In this example, I placed the file in the <code>Assets/Videos</code> section of Android and in <code>Resources/Videos</code> of iOS. <br><br>  After the files are placed in the correct folders, you need to create a page in the Xamarin.Forms PCL project. <br><br>  This is a simple page with a minimum of components.  We will create a home page with a background video, two text boxes for the username and password, as well as buttons for login and registration.  There is no logic here, I just want to show you how a beautiful home page is made. <br><br>  For better placement of controls, I use the grid as a container.  The following snippet presents the corresponding XAML code completely. <br><br><pre> <code class="cs hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>?&gt; &lt;ContentPage xmlns=<span class="hljs-string"><span class="hljs-string">"http://xamarin.com/schemas/2014/forms"</span></span> xmlns:x=<span class="hljs-string"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2009/xaml"</span></span> xmlns:local=<span class="hljs-string"><span class="hljs-string">"clr-namespace:BackgroundVideo"</span></span> xmlns:controls=<span class="hljs-string"><span class="hljs-string">"clr-namespace:BackgroundVideo.Controls"</span></span> x:Class=<span class="hljs-string"><span class="hljs-string">"BackgroundVideo.BackgroundVideoPage"</span></span>&gt; &lt;Grid Padding=<span class="hljs-string"><span class="hljs-string">"0"</span></span> RowSpacing=<span class="hljs-string"><span class="hljs-string">"0"</span></span> ColumnSpacing=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;controls:Video x:Name=<span class="hljs-string"><span class="hljs-string">"video"</span></span> Source=<span class="hljs-string"><span class="hljs-string">"Videos/Orchestra.mp4"</span></span> Loop=<span class="hljs-string"><span class="hljs-string">"true"</span></span> HorizontalOptions=<span class="hljs-string"><span class="hljs-string">"Fill"</span></span> VerticalOptions=<span class="hljs-string"><span class="hljs-string">"Fill"</span></span> /&gt; &lt;StackLayout VerticalOptions=<span class="hljs-string"><span class="hljs-string">"Center"</span></span> HorizontalOptions=<span class="hljs-string"><span class="hljs-string">"FillAndExpand"</span></span> Padding=<span class="hljs-string"><span class="hljs-string">"20,10,10,20"</span></span>&gt; &lt;Entry Placeholder=<span class="hljs-string"><span class="hljs-string">"username"</span></span> FontSize=<span class="hljs-string"><span class="hljs-string">"Large"</span></span> FontFamily=<span class="hljs-string"><span class="hljs-string">"Georgia"</span></span> HeightRequest=<span class="hljs-string"><span class="hljs-string">"50"</span></span>&gt; &lt;Entry.PlaceholderColor&gt; &lt;OnPlatform x:TypeArguments=<span class="hljs-string"><span class="hljs-string">"Color"</span></span> Android=<span class="hljs-string"><span class="hljs-string">"Silver"</span></span> /&gt; &lt;/Entry.PlaceholderColor&gt; &lt;Entry.TextColor&gt; &lt;OnPlatform x:TypeArguments=<span class="hljs-string"><span class="hljs-string">"Color"</span></span> Android=<span class="hljs-string"><span class="hljs-string">"White"</span></span> /&gt; &lt;/Entry.TextColor&gt; &lt;/Entry&gt; &lt;Entry Placeholder=<span class="hljs-string"><span class="hljs-string">"password"</span></span> FontSize=<span class="hljs-string"><span class="hljs-string">"Large"</span></span> FontFamily=<span class="hljs-string"><span class="hljs-string">"Georgia"</span></span> HeightRequest=<span class="hljs-string"><span class="hljs-string">"50"</span></span> IsPassword=<span class="hljs-string"><span class="hljs-string">"true"</span></span>&gt; &lt;Entry.PlaceholderColor&gt; &lt;OnPlatform x:TypeArguments=<span class="hljs-string"><span class="hljs-string">"Color"</span></span> Android=<span class="hljs-string"><span class="hljs-string">"Silver"</span></span> /&gt; &lt;/Entry.PlaceholderColor&gt; &lt;Entry.TextColor&gt; &lt;OnPlatform x:TypeArguments=<span class="hljs-string"><span class="hljs-string">"Color"</span></span> Android=<span class="hljs-string"><span class="hljs-string">"White"</span></span> /&gt; &lt;/Entry.TextColor&gt; &lt;/Entry&gt; &lt;BoxView Color=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> HeightRequest=<span class="hljs-string"><span class="hljs-string">"10"</span></span> /&gt; &lt;Button Text=<span class="hljs-string"><span class="hljs-string">"sign in"</span></span> BackgroundColor=<span class="hljs-string"><span class="hljs-string">"#3b5998"</span></span> TextColor=<span class="hljs-string"><span class="hljs-string">"#ffffff"</span></span> FontSize=<span class="hljs-string"><span class="hljs-string">"Large"</span></span> /&gt; &lt;Button Text=<span class="hljs-string"><span class="hljs-string">"sign up"</span></span> BackgroundColor=<span class="hljs-string"><span class="hljs-string">"#fa3c4c"</span></span> TextColor=<span class="hljs-string"><span class="hljs-string">"#ffffff"</span></span> FontSize=<span class="hljs-string"><span class="hljs-string">"Large"</span></span> /&gt; &lt;/StackLayout&gt; &lt;/Grid&gt; &lt;/ContentPage&gt;</code> </pre> <br>    .    ,    ,    <code>Loop</code> .    -   ,   <code>OnFinishedPlaying</code>   C#.  ,    . <br><br><h2>    </h2><br>    ,   ,   <a href=""></a> ,   ,      iOS.  ,        .      . <br><br>   iOS, <a href=""></a> ,         Android.           iOS.      ,  -  ,      ‚Äî   ,    iOS. <br><br> ,  ,        . <br><br><h2>  Total </h2><br> ,     , ‚Äî            .   ,      (,   ,  ),      . <br><br>   , ,    ,    Android , ,   .          ,      . <br><br>       ,     . <br><br>       <a href="">GitHub</a> . <br><br><h2>    </h2><br><img src="https://habrastorage.org/files/cd5/d4d/eba/cd5d4deba4fb4819a5383ecd863cde63.jpg" align="left" width="120"> <b><a href="https://aka.ms/habr_320338_11"> </a></b> ‚Äî Xamarin-, .   .NET-  2012 .         Digamma. C 2015            Xamarin.       StecPoint  iOS . <br><br>   <a href="https://aka.ms/habr_320338_11/">XamDev.ru</a>   ¬´Xamarin Developers¬ª   : <a href="https://aka.ms/vk_xamarin_developers">VK</a> , <a href="https://aka.ms/fb_xamdev">Facebook</a> , <a href="https://aka.ms/telegram_xamarin_russia">Telegram</a> . <br><br><h2> Xamarin Dev Days  - </h2><br> 20   -   Xamarin Dev Days  .        Xamarin,      . <br><br>  Schedule: <br><br> <b>09:00 ‚Äì 09:30</b>  <br> <b>09:30 ‚Äì 10:10</b>   Xamarin <br> <b>10:20 ‚Äì 11:00</b>  UI  Xamarin.Forms <br> <b>11:10 ‚Äì 11:50</b>    Azure <br> <b>12:00 ‚Äì 13:00</b>  <br> <b>13:00 ‚Äì 16:00</b>  <br><br>        <a href="https://ti.to/xamarin/dev-days-stpetersburg-2017"></a> . </div><p>Source: <a href="https://habr.com/ru/post/328732/">https://habr.com/ru/post/328732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328718/index.html">Speed ‚Äã‚Äã- Do Bank Sites Need It?</a></li>
<li><a href="../328720/index.html">Google I / O co-browsing at the Avito office</a></li>
<li><a href="../328722/index.html">Logging, interfaces and allocations in Go</a></li>
<li><a href="../328726/index.html">Search for devices on the network by SSDP using Poco</a></li>
<li><a href="../328728/index.html">Theory of cone antennas BowTie</a></li>
<li><a href="../328734/index.html">We raise the price monitoring service of competitors</a></li>
<li><a href="../328738/index.html">Linux staff monitoring: when demand creates supply</a></li>
<li><a href="../328740/index.html">Genetic Advisor for Options Trading</a></li>
<li><a href="../328742/index.html">Data-driven Production Approach / Stock Filters</a></li>
<li><a href="../328744/index.html">MyTaskHelper online database designer: create relational databases without programming knowledge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>