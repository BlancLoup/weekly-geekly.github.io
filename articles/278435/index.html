<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Image binarization: Bradley algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to dedicate this post to a pleasant trophy, obtained in the English-speaking Internet. It will be a question of one of the methods of adaptive ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Image binarization: Bradley algorithm</h1><div class="post__text post__text-html js-mediator-article">  I want to dedicate this post to a pleasant trophy, obtained in the English-speaking Internet.  It will be a question of one of the methods of adaptive binarization of images, the Bradley method (or Bradley-Roth, since there are two authors). <br><br><h4>  Some theory </h4><br>  The process of binarization is the translation of a color (or in grayscale) image into a two-color black and white.  The main parameter of this transformation is the threshold t - the value with which the brightness of each pixel is compared.  According to the results of the comparison, the pixel is assigned the value 0 or 1. There are various binarization methods that can be divided into two groups - global and local.  In the first case, the threshold value remains unchanged during the entire binarization process.  In the second, the image is divided into regions, in each of which a local threshold is calculated. <br><br>  The main goal of binarization is a radical reduction in the amount of information with which to work.  Simply put, successful binarization greatly simplifies the subsequent work with the image.  On the other hand, failures in the binarization process can cause distortions, such as line breaks, loss of significant details, loss of integrity of objects, noise, and unpredictable distortion of characters due to background heterogeneity.  Different binarization methods have their weak points: for example, the Otsu method can lead to the loss of small details and the "sticking together" of nearby symbols, and the Niblack method sins with the appearance of false objects in the case of background heterogeneities with low contrast.  It follows that each method must be applied in its own field. <br><a name="habracut"></a><br><h4>  Test object </h4><br>  At the moment I am engaged in the recognition of the indications of household appliances in the framework of the popular idea of ‚Äã‚Äã"smart home".  Here is an example of the image that our group works with: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/55c/c88/77a/55cc8877a4444379809aed0f911e5724.jpeg"><br><br>  The photo was taken on a dark, dark night in a dark, dark room;  LED illumination on the side creates a highly heterogeneous background, and between the camera and the display of the device there is silicate glass, which creates additional noise and false formations in the background.  Our task is to prepare the image for text recognition. <br><br>  Here it is logical to use local methods, they are also adaptive.  The Niblack method is considered to be the fastest of the classical local algorithms, but it does not work well with low-contrast background asperities, which in our case fill the image slightly less than completely.  To correct this deficiency, smart people have developed several modifications of the Niblack method, called ‚ÄúNiblack‚Äù.  In my case, one of them, the Christian method, showed good results on most samples, and was almost adopted as a working option.  However, distortions appeared on other samples after applying this algorithm. <br><br><img src="https://habrastorage.org/files/2a5/5e7/b75/2a55e7b7590940edbc5cce459b4269df.jpeg"><br><br>  a) Niblack method b) Christian method <br><br><h4>  The essence of the Bradley method </h4><br>  In itself, the comparison of two values ‚Äã‚Äã- the threshold and brightness of a pixel - is an elementary task.  Not in this salt.  The difficulty lies in finding the threshold value, which should reliably separate the characters not only from the background, but also from noise, shadows, highlights and other information garbage.  Often for this resort to methods of mathematical statistics.  In the Bradley method, we go from the other side - from the side of integral images. <br><br><h4>  Integral images </h4><br>  Integral images are not only effective and fast (in just one pass through the image) a way to find the sum of pixel values, but also an easy way to find the average brightness value within a given image area. <br><br>  How it works?  Yes, elementary.  Suppose we have an 8-bit image in shades of gray (a color image can be converted to shades of gray using the formula I = 0.2125R + 0.7154G + 0.0721B).  In this case, the value of the element of the integral image is calculated by the formula: <br><br>  S (x, y) = I (x, y) + S (x-1, y) + S (x, y-1) - S (x-1, y-1); <br><br>  where S is the result of previous iterations for a given pixel position, I is the brightness of the pixel of the original image.  If the coordinates are outside the image, they are considered to be zero.  The essence of this method "on the fingers" is presented in the diagram below: <br><br><img src="https://habrastorage.org/files/bfe/956/d62/bfe956d62b8e4ef9a6ef87136a791e7f.jpg"><br><br>  Life hacking consists in the fact that once having made an integral matrix of an image, you can quickly calculate the sum of the pixel values ‚Äã‚Äãof any rectangular area within that image.  Let ABCD be a rectangular area of ‚Äã‚Äãinterest. <br><br><img src="https://habrastorage.org/files/01e/8ed/db9/01e8eddb9dbb4d59956fa174327d6c14.jpg"><br><br>  Then the total brightness S in this area is calculated by the formula: <br><br>  S (x, y) = S (A) + S (D) - S (B) - S ¬© <br><br>  where S (A), S (B), S  and S (D) are the values ‚Äã‚Äãof the elements of the integral matrix in the direction ‚Äúnorth-west‚Äù from the intersections of the sides of the rectangle: <br><br><img src="https://habrastorage.org/files/870/6d2/59e/8706d259ea11415d9ac4cf809ef64d27.jpg"><br><br><h4>  Implementation </h4><br>  If you have read this far, you have almost understood the Bradley algorithm.  Then everything is simple.  We divide the image into several areas with side d, take the average of the sum of the pixels Im in this area, add some value t, compare the value of each pixel with the result.  Im + t - is our desired threshold value.  Bradley and Roth take d and t values, respectively, 1/8 of the image width and 15% of the average pixel brightness value over the region.  Well, generally speaking, both of these parameters can and should be changed in accordance with the specific situation.  So, if the object's dimensions are larger than the square of a square with a side equal to d, then the center of this object can be taken by the algorithm as a background, and the problem is solved by reducing the value of d, however, fine details of the image can be lost. <br><br>  And this is how it looks in our example: <br><br><img src="https://habrastorage.org/files/415/ac7/759/415ac7759d2743f58758ed14345799cd.jpg"><br><br>  After median filtering: <br><br><img src="https://habrastorage.org/files/602/ee2/e8e/602ee2e8e8ad426fb1c447f55c4a7998.jpg"><br><br>  The implementation of the Bradley-Roth algorithm in C ++ is presented below: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bradley_threshold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S = width/<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s2 = S/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0.15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>* integral_image = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1, y1, x2, y2; <span class="hljs-comment"><span class="hljs-comment">//   integral_image = new unsigned long [width*height*sizeof(unsigned long*)]; for (int i = 0; i &lt; width; i++) { sum = 0; for (int j = 0; j &lt; height; j++) { index = j * width + i; sum += src[index]; if (i==0) integral_image[index] = sum; else integral_image[index] = integral_image[index-1] + sum; } } //     for (int i = 0; i &lt; width; i++) { for (int j = 0; j &lt; height; j++) { index = j * width + i; x1=i-s2; x2=i+s2; y1=j-s2; y2=j+s2; if (x1 &lt; 0) x1 = 0; if (x2 &gt;= width) x2 = width-1; if (y1 &lt; 0) y1 = 0; if (y2 &gt;= height) y2 = height-1; count = (x2-x1)*(y2-y1); sum = integral_image[y2*width+x2] - integral_image[y1*width+x2] - integral_image[y2*width+x1] + integral_image[y1*width+x1]; if ((long)(src[index]*count) &lt; (long)(sum*(1.0-t))) res[index] = 0; else res[index] = 255; } } delete[] integral_image; }</span></span></code> </pre> <br><h4>  Advantages and disadvantages </h4><br>  The advantages of the Bradley-Roth method are the ease of implementation and high speed of execution;  for most cases, there is no need to select parameters.  The method works well with a non-uniform background. <br><br>  From the latter virtue, there is a logical lack of the Bradley method, namely, the poor sensitivity to low-contrast details of the image: <br><br><img src="https://habrastorage.org/files/7d8/0ce/737/7d80ce737f6c4400a717418d561340a9.jpg"><br><br>  a) the original image b) the Bradley method c) the method of Christian <br><br>  References: <br>  <a href="http://citeseerx.ist.psu.edu/viewdoc/summary%3Fdoi%3D10.1.1.420.7883">http://citeseerx.ist.psu.edu</a> - original article by Bradley and Roth (in English) <br>  <a href="https://computersciencesource.wordpress.com/2010/09/03/computer-vision-the-integral-image/">https://computersciencesource.wordpress.com</a> - the author very clearly describes the essence of integral images (in English) <br>  <a href="http://web.mit.edu/mfeng/www/papers/mengling_ieice.pdf">http://web.mit.edu/mfeng/www/papers/mengling_ieice.pdf</a> - a review of the Niblack methods (and them too) with formulas and links to the articles of the authors (in English) <br>  <a href="http://liris.cnrs.fr/christian.wolf/software/binarize/">http://liris.cnrs.fr/christian.wolf/software/binarize/</a> - Christian Wulff implements the Christian Wolfe, Niblack and Savola algorithms (in C ++) </div><p>Source: <a href="https://habr.com/ru/post/278435/">https://habr.com/ru/post/278435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278423/index.html">Migration of UI patterns and gestures. Who has anyone that podtyril</a></li>
<li><a href="../278425/index.html">Understanding the neural network war (GAN)</a></li>
<li><a href="../278427/index.html">Connect to the Device Guard Webinar on Windows 10. Start March 3 at 11:00 (GMT)</a></li>
<li><a href="../278429/index.html">Fresh exhibition ISE - new LEDs, screens in the windows and how to break the screen that does not break</a></li>
<li><a href="../278431/index.html">First hakaton 2GIS</a></li>
<li><a href="../278437/index.html">If programmers were making pancakes (according to kosher methodologies)</a></li>
<li><a href="../278439/index.html">We fix the error of installing updates Windows 7</a></li>
<li><a href="../278441/index.html">Track updates from MongoDB Replica Set Oplog using Scala and Akka Streams</a></li>
<li><a href="../278443/index.html">Physical web concept. Bluetooth beacons. Comparison of iBeacon, AltBeacon and Eddystone standards</a></li>
<li><a href="../278445/index.html">Pomp - metaframe for parsing sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>