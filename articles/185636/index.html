<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kate Matsudeira: Scalable Web Architecture and Distributed Systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Six months ago , the question about the text for my diploma translation came out sharply. The result of collective intelligence was the decision to tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kate Matsudeira: Scalable Web Architecture and Distributed Systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/4c4/9fd/a14/4c49fda144b99fd17e09b29c5750d89e.png" align="right">  Six months ago <a href="http://habrahabr.ru/qa/34977/">, the question</a> about the text for my diploma translation <a href="http://habrahabr.ru/qa/34977/">came out</a> sharply.  The result of collective intelligence was the decision to translate the chapter <a href="http://www.aosabook.org/en/distsys.html">Scalable Web Architecture and Distributed Systems</a> by <a href="http://katemats.com/about/">Kate Matsudaira</a> .  It should be noted that this is my first translation of this volume and complexity.  The text was relatively successfully translated by me, although I would set 6-7 out of 10 for the quality of the translation. So that my efforts are not lost in vain, I publish the result of my works. <br><br>  At the <a href="http://habrahabr.ru/post/180487/">request of Habr's readers</a> , now the full version is in the form of a topic. <br><br> <a href="http://www.aosabook.org/en/index.html"><img src="https://habrastorage.org/storage2/cfc/dfe/615/cfcdfe615de64d12945458035eb53078.jpg" alt="Open Source Applications (Volume 2)"></a> <br><h1>  Scalable web architecture and distributed systems </h1><br>  <a href="http://www.aosabook.org/en/intro2.html">Kate Matsudeira</a> <br><p>  Translation: <a href="http://translatedby.com/jedi-to-be/">jedi-to-be</a> . <br>  Correction: <a href="http://translatedby.com/Anastasiaf15/">Anastasiaf15</a> , <a href="http://translatedby.com/sunshine_lass/">sunshine_lass</a> , <a href="http://translatedby.com/Amaliya/">Amaliya</a> , <a href="http://translatedby.com/fireball/">fireball</a> , <a href="http://translatedby.com/Goudron/">Goudron</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><a name="habracut"></a><br><br><p>  Open source software has become the main building block for creating some of the largest websites.  With the growth of these websites, best practices and guidelines for their architecture have emerged.  This chapter aims to cover some of the key issues that should be considered when designing large websites, as well as some of the basic components used to achieve these goals. </p><br><br><p>  This chapter focuses on the analysis of web systems, although some of the material can be extrapolated to other distributed systems. </p><br><br><h2>  1.1 Principles of building distributed web systems </h2><br><br><p>  What exactly does creating and managing a scalable website or application?  At a primitive level, it is simply the connection of users to remote resources via the Internet.  And resources or access to these resources, which are dispersed on a variety of servers and are a link to ensure the scalability of the website. </p><br><br><p>  Like most things in life, the time spent in advance on planning to build a web service can help further;  Understanding some of the considerations and trade-offs behind large websites can be rewarded with smarter solutions for creating smaller websites.  Below are some key principles affecting the design of large-scale web systems: </p><br><br><ul><li>  <strong>Accessibility: The</strong> length of time that a website is operational is critical to the reputation and functionality of many companies.  For some of the larger online retailers, unavailability even for a few minutes can result in thousands or millions of dollars in lost revenue.  Thus, the development of their constantly accessible and resilient systems is also a fundamental business and technological requirement.  High availability in distributed systems requires careful consideration of redundancy for key components, fast recovery from partial system failures, and a smooth reduction in capabilities when problems arise. </li><li>  <strong>Performance:</strong> Website performance has become an important indicator for most sites.  Website speed and user satisfaction, as well as ranking by search engines, are factors that directly affect audience retention and revenue.  As a result, the key is to create a system that is optimized for fast responses and low latency. </li><li>  <strong>Reliability: the</strong> system must be reliable, so that a particular request for data will consistently return certain data.  In the event of a data change or update, the same query must return new data.  Users need to know if something is recorded in the system or stored in it, then you can be sure that it will remain in place to be able to extract data later. </li><li>  <strong>Scalability:</strong> When it comes to any large distributed system, the size is just one item from a list that needs to be considered.  Equally important are efforts to increase throughput to handle large volumes of workload, which is commonly referred to as system scalability.  Scalability can relate to various parameters of the system: the amount of additional traffic with which it can handle, how easy it is to increase the storage capacity of the storage device, or how much more other transactions can be processed. </li><li>  <strong>Manageability:</strong> Designing a system that is easy to operate is another important factor.  The manageability of the system is equal to the scalability of the ‚Äúmaintenance‚Äù and ‚Äúupgrade‚Äù operations. To ensure the controllability, it is necessary to consider the issues of simplicity of diagnostics and understanding of emerging problems, ease of updating or modifying, whimsicalness of the system in operation. exceptions?) </li><li>  <strong>Cost:</strong> Cost is an important factor.  It can obviously include hardware and software costs, but it is also important to consider other aspects necessary to deploy and maintain the system.  The amount of developer time required to build the system, the amount of operational effort required to start the system, and even a sufficient level of training should all be provided.  Cost is the total cost of ownership. </li></ul><br><br><p>  Each of these principles is the basis for decision making in designing a distributed web architecture.  However, they may also be in conflict with each other, because achieving the goals of one is due to the neglect of others.  A simple example: the choice of simply adding multiple servers as a performance solution (scalability) can increase the cost of manageability (you must operate an additional server) and the purchase of servers. </p><br><br><p>  When developing any kind of web application, it is important to consider these key principles, even if it is to confirm that a project can donate one or more of them. </p><br><br><br><br><h2>  1.2 Basics </h2><br><br><p>  When considering the architecture of the system there are several issues that need to be addressed, for example: which components should be used, how they are combined with each other, and which compromises can be made.  Investing money in scaling without the obvious need for it can not be considered a reasonable business decision.  However, some forethought in planning can significantly save time and resources in the future. </p><br><br><p> This section focuses on some of the basic factors that are crucial for almost all large web applications: <em>services</em> , <br>  <em>redundancy</em> , <em>segmentation</em> , and <em>fault handling</em> .  Each of these factors implies choice and compromise, especially in the context of the principles described in the previous section.  For clarification, we give an example. </p><br><br><h3>  Example: image hosting application </h3><br><br><p>  You probably have already posted images on the web.  For large sites that provide storage and delivery of multiple images, there are problems in creating a cost-effective, highly reliable architecture that is characterized by low latency responses (fast retrieval). </p><br><br><p>  Imagine a system where users have the opportunity to upload their images to a central server, and at the same time images can be requested via a link to a website or API, similar to Flickr or Picasa.  To simplify the description, let's assume that this application has two main tasks: the ability to upload (write) images to the server and request images.  Of course, effective download is an important criterion, however, the priority will be fast delivery on request from users (for example, images can be requested to be displayed on a web page or another application).  This functionality is similar to what a Web server or Content Delivery Network (CDN) can provide.  A CDN server typically stores data objects in many locations, so their geographic / physical location is closer to the users, resulting in increased performance. </p><br><br><p>  Other important aspects of the system: </p><br><br><ul><li>  The number of stored images can be limitless, so storage scalability needs to be considered from this point of view. <br></li><li>  There should be a low latency for image upload / request. <br></li><li>  If a user uploads an image to the server, his data should always remain complete and accessible. <br></li><li>  The system should be easy to maintain (manageability). <br></li><li>  Since the hosting of images does not bring much profit, the system should be cost-effective. <br></li></ul><br><br><p>  <a href="https://habr.com/ru/post/185636/">Figure 1.1</a> is a simplified diagram of the functionality. </p><br><br><img src="https://habrastorage.org/storage2/99a/d3c/eb0/99ad3ceb079933c814b8dc50c15d0302.png"><br>  Figure 1.1: Simplified architecture diagram for an image hosting application <br><br><br><br><br><p>  In this example of image hosting, the system should be noticeably fast, its data is securely stored, and all these attributes are well scalable.  Creating a small version of this application would be a standard task, and a single server would be enough to host it.  However, such a situation would not be of interest to this chapter.  Let's assume that we need to create something as large as Flickr. </p><br><br><br><br><h3>  Services </h3><br><br><p>  When considering the design of a scalable system, it is useful to separate the functionality and think of each part of the system as a separate service with a well-defined interface.  In practice, it is believed that systems designed in this way have a Service-Oriented Architecture (SOA).  For these types of systems, each service has its own distinct functional context, and interaction with something outside of that context occurs through an abstract interface, usually the public API of another service. </p><br><br><p>  Deconstructing the system into a series of complementary services isolates the work of some parts from others.  This abstraction helps establish a clear relationship between the service, its underlying environment, and the consumers of the service.  Creating a clear outline can help locate problems, but also allows each part to scale independently.  This type of service-oriented design of systems for serving a wide range of requests is similar to the object-oriented approach to programming. </p><br><br><p>  In our example, all requests for loading and receiving images are processed by the same server;  however, since the system must scale, it is advisable to separate these two functions into their own services. </p><br><br><p>  Suppose the service is in intensive use in the future;  such a script helps to better track how longer recordings affect the time to read an image (since the two functions will compete for shared resources).  Depending on the architecture, this effect can be significant.  Even if the upload and receive speeds are the same (which is not typical of most IP networks, since they are designed to take at least 3: 1 ratio of receive speed to speed), readable files will usually be retrieved from the cache, and records should ultimately get on the disk (and possibly be re-recorded in similar situations).  Even if all data is in memory or read from disks (such as SSDs), writing to the database will almost always be slower than reading from it.  (Pole Position, an open source benchmarking tool for databases, <a href="http://polepos.org/">http://polepos.org/</a> and the results of <a href="http://polepos.sourceforge.net/results/PolePositionClientServer.pdf">http://polepos.sourceforge.net/results/PolePositionClientServer.pdf</a> .). <br></p><br><br><p>  Another potential problem with this design is that a web server, such as Apache or lighttpd, usually has an upper limit on the number of simultaneous connections it can handle (the default value is approximately 500, but it can be much higher) and with high traffic, recordings can quickly consume this limit.  Since reads can be asynchronous or take advantage of other performance optimizations like gzip or dividing, the web server can switch read feeds faster and switch between clients, serving far more requests than the maximum number of connections (with Apache and the maximum number of connections set to 500 is quite realistic to serve several thousand read requests per second).  Records, on the other hand, tend to maintain an open connection throughout the load.  Since transferring a 1MB file to a server could take more than 1 second in most home networks, as a result, the web server can process only 500 such simultaneous entries. </p><br><br><img src="https://habrastorage.org/storage2/a47/0a8/1db/a470a81db6662228116b99d4d55d1892.png"><br>  Figure 1.2: Separation of reading and writing <br><br><br><p>  Anticipation of such a potential problem indicates the need to separate the reading and writing of images into independent services, shown in <a href="https://habr.com/ru/post/185636/">Figure 1.2</a> .  This will allow not only to scale each of them separately (as it is likely that we will always do more readings than records), but also to be aware of what happens in each service.  Finally, it will distinguish between problems that may arise in the future, which will simplify the diagnosis and assessment of the problem of slow reading access. </p><br><br><p>  The advantage of this approach is that we are able to solve problems independently of each other - without having to think about the need to record and receive new images in the same context.  Both of these services still use the global image corpus, but when using methods appropriate to a particular service, they are able to optimize their own performance (for example, placing requests in a queue, or caching popular images - more on this later in this article).  Both in terms of service and cost, each service can be scaled independently as needed.  And this is a positive factor, since their combination and mixing could inadvertently affect their performance, as in the scenario described above. </p><br><br><p>  Of course, the operation of the aforementioned model will be optimal if there are two different endpoints (in fact, this is very similar to several implementations of cloud storage providers and Content Delivery Networks).  There are many ways to solve such problems, and in each case a compromise can be found. </p><br><br><p>  For example, Flickr solves this read-write problem by distributing users between different modules, so that each module can serve only a limited number of specific users, and when the number of users increases, more modules are added to the cluster (see the Flickr scaling presentation, <br>  <a href="http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html">http://mysqldba.blogspot.com/2008/04/mysql-uc-2007-presentation-file.html</a> ).  In the first example, it is easier to scale the hardware based on the actual usage load (the number of reads and records in the entire system), whereas the Flickr scaling is based on the user base (however, the assumption of uniform use among different users is used here, so power needs to be planned with stock).  In the past, inaccessibility or a problem with one of the services rendered the whole system functionality inoperative (for example, no one can write files), then the inaccessibility of one of the Flickr modules will only affect users belonging to it.  In the first example, it is easier to perform operations on a whole set of data ‚Äî for example, updating the recording service to include new metadata, or performing a search on all image metadata ‚Äî whereas with the Flickr architecture each module had to be updated or searched (or the search service should created to sort the metadata that is actually intended for this). </p><br><br><p>  As for these systems, there is no panacea, but one should always proceed from the principles described at the beginning of this chapter: determine system needs (load with ‚Äúread‚Äù or ‚Äúwrite‚Äù operations or all at once, level of parallelism, queries on data sets, ranges, sorting, etc.), conduct comparative benchmarking of various alternatives, understand the conditions of a potential system failure, and develop a comprehensive plan in case of failure. </p><br><br><br><br><h3>  Redundancy </h3><br><br><p>  To cope elegantly with a failure, the web architecture must have the redundancy of its services and data.  For example, if there is only one copy of a file stored on a single server, the loss of this server would mean the loss of the file.  It is unlikely that such a situation can be positively characterized, and it can usually be avoided by creating multiple or backup copies. </p><br><br><p>  This same principle applies to services.  It is possible to protect against the failure of a single node if one envisages an integral part of the functionality for the application, which guarantees the simultaneous operation of its multiple copies or versions. </p><br><br><p>  Creating redundancy in the system allows you to get rid of weak points and provide backup or redundant functionality in case of an emergency.  For example, in the event that there are two instances of the same service working in ‚Äúproduction‚Äù, and one of them fails completely or partially, the system can overcome the failure by <em>switching to a working instance</em> . <br>  Switching can occur automatically or require manual intervention. </p>  . <br><br><p>  Another key role of service redundancy is creating an <em>architecture that does not involve resource sharing</em> .  With this architecture, each node is able to work independently and, moreover, in the absence of a central ‚Äúbrain‚Äù controlling states or coordinating the actions of other nodes.  It promotes scalability, since the addition of new nodes does not require special conditions or knowledge.  And most importantly, there is no critical point of failure in these systems, which makes them much more resilient to failure. </p>  . <br><br><p>  For example, in our image server application, all images would have redundant copies somewhere in another piece of hardware (ideally with a different geographic location in the event of a disaster such as an earthquake or fire in the data center) and image access services will be redundant, despite the fact that all of them will potentially serve requests.  (See <a href="https://habr.com/ru/post/185636/">Figure 1.3</a> .) <br>  Looking ahead, load balancers are a great way to make this possible, but more on that below. </p><br><br><img src="https://habrastorage.org/storage2/e53/27f/872/e5327f872812340fcdc8d816222330a2.png"><br>  Figure 1.3: Redundancy Image Hosting Application <br><br><br><br><br><h3>  Segmentation </h3><br><br><p>  Data sets can be so large that they cannot be placed on a single server.  It may also happen that computational operations will require too much computer resources, reducing performance and making it necessary to increase power.  In any case, you have two options: vertical or horizontal scaling. </p><br><br><p>  Vertical scaling involves adding more resources to a single server.  So, for a very large data set, this would mean adding more (or more) hard drives, and thus the entire data set could fit on a single server.  In the case of computational operations, this would mean moving the computation to a larger server with faster CPUs or more memory.  In any case, the vertical scaling is performed in order to make a separate resource of the computing system capable of additional data processing. </p><br><br><p>  Horizontal scaling, on the other hand, involves adding more nodes.  In the case of a large data set, this would mean adding a second server to store part of the total data, and for a computational resource, this would mean sharing work or loading through some additional nodes.  To take full advantage of the potential of horizontal scaling, it must be implemented as an internal principle of the development of the system architecture.  Otherwise, changing and highlighting the context needed for horizontal scaling can be problematic. </p><br><br><p>  The most common method of horizontal scaling is the division of services into segments or modules.  They can be distributed in such a way that each logical set of functionality will work separately.  This can be done by geographic boundaries, or other criteria such as paying and not paying users.  The advantage of these schemes is that they provide a service or data warehouse with enhanced functionality. </p><br><br><p>  In our example of an image server, it is possible that a single file server used to store an image can be replaced by multiple file servers, each one containing its own unique set of images.  (See <a href="https://habr.com/ru/post/185636/">Figure 1.4</a> .) This architecture will allow the system to fill each file server with images, adding additional servers, as the disk space becomes full.  The design will require a naming scheme that associates the name of the image file with the server containing it.  The image name can be formed from a consistent hashing scheme associated with servers.  Or alternatively, each image may have an incremental identifier, which allows the delivery service, when requesting an image, to process only the range of identifiers associated with each server (as an index). </p><br><br><img src="https://habrastorage.org/storage2/075/665/dbb/075665dbb9545ab18e4979ba8ce2b87a.png"><br>  Figure 1.4: Image Redundancy and Segmentation Hosting Application <br><br><br><p>  Of course, there are difficulties in distributing data or functionality to multiple servers.  One of the key issues is the <em>location of the data</em> ;  in distributed systems, the closer the data is to the location of operations or the point of calculation, the better the system performance.  Consequently, the distribution of data on multiple servers is potentially problematic, since at any time when this data may be needed, there is a risk that it may not be available at the place of demand, the server will have to perform costly sampling of necessary information over the network. </p><br><br><p>  Another potential problem occurs in the form <br>  <em>inconsistency (inconsistency)</em> . When different services read and write to a shared resource, potentially another service or data store, there is the possibility of a ‚Äúrace‚Äù condition - where some data is considered updated to the current state, but in reality they are read until the moment of update. - and in this case, the data are inconsistent.  For example, in an image hosting scenario, a race condition might occur if one client sent a dog image update request with the ‚ÄúDog‚Äù title changed to ‚ÄúGuizmo‚Äù while another client was reading the image.  In such a situation it is unclear which particular title, ‚ÄúDog‚Äù or ‚ÄúGizmo‚Äù, would be received by the second client. </p>  . <br><br><p>  There are, of course, some obstacles associated with data segmentation, but segmentation makes it possible to isolate each of the problems from the others: by data, by loading, by usage patterns, etc.  in managed blocks.  This can help with scalability and manageability, but the risk is still present.  There are many ways to reduce risk and handle disruptions;  however, in the interest of brevity, they are not covered in this chapter.         ,     <a href="http://katemats.com/2011/11/13/distributed-systems-basics-handling-failure-fault-tolerance-and-monitoring/">-</a>    . </p><br><br><br><br><br><br><h2>  1.3.         </h2><br><br><p>        ,        ‚Äî    . </p><br><br><p>   -, ,   LAMP,     <a href="https://habr.com/ru/post/185636/"> 1.5</a> . </p><br><br><img src="https://habrastorage.org/storage2/1de/b24/e49/1deb24e49c3f5c281fd82bf8d0484b24.png"><br>  1.5:  - <br><br><br><p>       :         .      -         ,     .        .                  ;             . </p><br><br><p>                         . </p><br><br><img src="https://habrastorage.org/storage2/529/7d6/689/5297d6689df03db813a3ad99d580e820.png"><br>  1.6:  - <br><br><br><p>         <a href="https://habr.com/ru/post/185636/"> 1.6</a> , <br>        .      ,  ,             ,          .     ,      :        . </p><br><br><p>      ,       () ,              . (. <a href="https://habr.com/ru/post/185636/"> 1.7</a> .) <br>        -        . </p><br><br><img src="https://habrastorage.org/storage2/f47/9c5/455/f479c545518d81a256cef057fa43348c.png"><br>  1.7:     <br><br><br><p>   ,                   -.              ‚Äî  ,        ,   ,         .          ;       6  ,        ,   100,000  ‚Äî      (. ¬´  ¬ª, <a href="http://queue.acm.org/detail.cfm%3Fid%3D1563874">http://queue.acm.org/detail.cfm?id=1563874).</a>  ).  ,    ,             ,                 . </p><br><br><p>     ,     ,       ‚Äî   , ,    .       ,          ,       . </p><br><br><h3>  </h3><br><br><p>         :        .       :  ,  , -, -   .     :   ,   ,    ,   ,     .        ,         ,   ,        . </p><br><br><p>                API?      ,   .             ,    <br> <a href="https://habr.com/ru/post/185636/"> 1.8</a> . </p><br><br><img src="https://habrastorage.org/storage2/007/cbb/bb2/007cbbbb2ef319d37ae21c093fecef56.png"><br>  1.8:       <br><br><br><p>            .  ,      ,    ,  ,   .      ,       .              (  ),       (,      ). </p><br><br><img src="https://habrastorage.org/storage2/50f/10c/63b/50f10c63bfff21b0002f198fa88bcf12.png"><br>  1.9:   <br><br><br><p>  ,       ?    <a href="https://habr.com/ru/post/185636/">  1.9</a> ,       ,   ,        . ,           ,        ,       .          . </p><br><br><br><br><h3>   </h3><br><br><p>      :       .          ,  ,     ,        .         ,      .        ,       ,       .           (     ,       ,       ,   ). </p><br><br><p>      ,   .  <a href="https://habr.com/ru/post/185636/"> 1.10</a>  ,       ,            .  <a href="https://habr.com/ru/post/185636/"> 1.11</a>       ,     . </p><br><br><img src="https://habrastorage.org/storage2/54d/240/b30/54d240b3063c20b918dfe03c23f18a98.png"><br>  1.10:  ,      <br><br><br><img src="https://habrastorage.org/storage2/b09/792/02b/b0979202b15bf3bf4e40e3063669551a.png"><br>  1.11:  ,       <br><br><br><br><br><p>  ,   ,    ,        ,           . ,   ,      . ,       ,               ;            (   )  .   ‚Äî ,  ,   ,      . (   -        ‚Äî ,            ‚Äî          ,  .) </p><br><br><br><br><h3>   </h3><br><br><p>    ( <a href="https://habr.com/ru/post/185636/"> 1.12</a> ),        ,         ,               ‚Äî ,  <em></em>   ,       .       -.       ,    ,     ,  ,    .                 ,    . ,      ‚Äî   ,         . </p><br><br><p>    ‚Äî     .      ,       ; ,  ,        ,          .   ‚Äî    ,     ,     ‚Äî       ! </p><br><br><img src="https://habrastorage.org/storage2/a85/9f7/cfd/a859f7cfd53a2108c3fb5a4eeeaec3e1.png"><br>  1.12:  . <br><br><br><p>         (,    !)           . ,            .          ,          ,           . </p><br><br><p>            Memcached (),     ,    );  ,     (      ). </p><br><br><p> Memcached     -,    ,      ,      -   ,         <em>(O(1))</em> . </p><br><br><p> Facebook uses several different types of caching to achieve high performance of its site (see, <a href="http://sizzo.org/talks/">‚ÄúFacebook: caching and performance‚Äù</a> ).  They use <code>$GLOBALS</code> and APC, which are cached at the language level (represented in PHP by calling a function), which speeds up intermediate function calls and results.  (Most languages ‚Äã‚Äãare equipped with these types of libraries to improve webpage performance, and they should almost always be used.) In addition, Facebook uses a global cache that is distributed to multiple servers (see ‚Äú <a href="http://www.facebook.com/note.php%3Fnote_id%3D39391378919">Scaling memcached on Facebook‚Äù</a> ), so that one a function call that accesses the cache could simultaneously execute multiple requests for data stored on various Memcached servers.  This approach allows to achieve much higher performance and bandwidth for user profile data, and create a centralized data refresh architecture.  This is important because, with thousands of servers, the cache reversal and consistency functions can be difficult. </p><br><br><p>  The following discussion focuses on the algorithm of actions in the absence of data in the cache. </p><br><br><br><br><h3>  Proxy </h3><br><br><p>  At a basic level, a proxy server is an intermediate piece of hardware / software that receives requests from clients and sends them to the backend source servers.  As a rule, proxies are used to filter requests, log requests, or sometimes convert requests (by adding / removing headers, encrypting / decrypting or compressing). </p><br><br><img src="https://habrastorage.org/storage2/9c8/98d/70f/9c898d70f1c4fae0759d7b14c059e4c2.png"><br>  Figure 1.13 Proxy server <br><br><br><p>  Proxies are also very useful in coordinating requests from a large number of servers, which makes it possible to optimize request traffic across the entire system.  One of the ways to use a proxy to speed up data access is to combine the same or similar requests and send a single response to the request clients.  This term is called collapsed forwarding. </p><br><br><p>  Imagine that requests for identical data come from several nodes (let's call them littleB), but in the cache some of this data is missing.  If this request is sent through a proxy, then all requests can be combined into one, and as a result of this optimization littleB will be read from disk only once.  (See <a href="https://habr.com/ru/post/185636/">figure 1.14</a> ) In this case, you will have to sacrifice a bit of speed, since the processing of requests and their combination lead to somewhat longer delays.  However, under high load, on the contrary, this will lead to improved performance, especially in the case of multiple requests for the same data.  The proxy operation strategy is similar to the cache, but instead of storing data, it optimizes requests or calls to documents. </p><br><br><p>  In a LAN proxy, for example, clients do not need their own IP address to connect to the Internet.  Proxy combines requests from clients for the same content.  However, this creates ambiguity, since many proxies are also caches (since they are a logical place to put the cache), but not all caches work as proxies. </p><br><br><img src="https://habrastorage.org/storage2/ea9/97b/0be/ea997b0bef558b44ff55b45967a30627.png"><br>  Figure 1.14: Using a proxy server to combine requests <br><br><br><p>  Another great way to use a proxy is not just to combine queries for the same data, but also for pieces of data that are spatially close to each other in the source repository (sequentially on disk).  Using such a strategy maximizes the locality of the data for queries, which can reduce the delay in the query.  For example, if a node set requests parts B: part-B1, part-B2, etc., we can configure our proxy to recognize the spatial location of individual requests, combining them into a single request and returning only bigB, significantly minimizing reads from the data source.  (See <a href="https://habr.com/ru/post/185636/">figure 1.15</a> ) In the case of accessing the entire terabyte of data in an arbitrary order, the time for the implementation of the request can vary greatly.  Since proxies can essentially group several requests into one, they are especially useful in situations of high load or limited caching capabilities. </p><br><br><img src="https://habrastorage.org/storage2/382/490/3bd/3824903bd6e55a13ca2a5a1ccb9928f6.png"><br>  Figure 1.15: Using a proxy to combine requests for data that are spatially close to each other <br><br><br><p>  It is worth noting that you can use proxies and caches together, but it is usually better to place the cache in front of the proxy for the same reason that it is better to allow faster runners to start in a marathon with more participants.  This is because the cache uses data from memory, which is very fast, and this does not contradict repeated requests for the same result.  But if the cache was located on the other side of the proxy server, there would be an additional delay for each request before the cache, which could reduce performance. </p><br><br><p>  If you are considering adding proxies to your systems, then you have many options to choose from; <br>  <a href="http://www.squid-cache.org/">Squid</a> and <br>  <a href="https://www.varnish-cache.org/">Varnish has</a> passed the test of time and is widely used in many productive websites.  These proxy solutions offer many optimization options to get the most out of client-server data exchange.  Installing one of them in the reverse proxy mode (described below in the section on load balancing) at the web server level can significantly improve the performance of the web server, reducing the amount of work required to process incoming client requests. </p><br><br><br><br><h3>  Indices </h3><br><br><p>  Using an index to get quick access to your data is a well-known strategy for effectively optimizing data access.  Indexing is most widely used in databases.  The index makes reciprocal concessions by using the costs of data storage volumes and reducing the speed of ‚Äúwrite‚Äù operations (since you have to both write data and update the index at the same time), allowing you to gain in the form of faster ‚Äúread‚Äù operations. </p><br><br><p>  You can also apply this concept to larger data stores, just as you can to relational datasets.  The trick with the indexes is a clear understanding of how users access your data.  In the event that data set volumes are measured in many terabytes, and there is very little useful information in them (for example, 1 Kbyte), the use of indices is a necessity to optimize data access.  Finding a small amount of useful information in such a large data set can be a real problem, since you just can‚Äôt consistently search through such a large amount of data in any reasonable time.  In addition, it is very likely that such a large data set is distributed among several (or many!) Physical devices, and this means that you need to somehow find the correct physical location of the necessary data.  Indexes are the best way to do this. </p><br><br><img src="https://habrastorage.org/storage2/512/5e2/890/5125e2890cdacb49d60fc865dcbab22a.jpg"><br>  Figure 1.16: Indices <br><br><br><p>  The index can be used as a table of contents that directs you to the location of your data.  For example, let's say you are looking for a piece of data, part 2 of the section ‚ÄúB‚Äù - how do you know where to find it?  If you have an index sorted by data type - let's call the data ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù - it will tell you the location of the data ‚ÄúB‚Äù in the source.  Then you just have to find this location and count the part ‚ÄúB‚Äù that you need.  (See <a href="https://habr.com/ru/post/185636/">figure 1.16)</a> </p><br><br><p>  These indexes are often stored in memory or somewhere very locally with respect to an incoming client request.  Berkeley DB (BDB) and tree data structures, which are commonly used to store data in ordered lists, are ideal for access with an index. </p><br><br><p>  Often there are many levels of indices that serve as a map, moving you from one location to another, etc., until you get the part of the data you need.  (See <a href="https://habr.com/ru/post/185636/">figure 1.17</a> ) </p><br><br><img src="https://habrastorage.org/storage2/557/a77/981/557a77981b5e826d80b19c9c35d9c959.jpg"><br>  Figure 1.17: Multi-Level Indexes <br><br><br><p>  Indexes can also be used to create several different views of the same data.  For large data sets, this is a great way to define different filters and views without having to create many additional copies of the data. </p><br><br><p>  For example, suppose that the image hosting system mentioned above actually places the images of book pages, and the service allows client requests for text in these images, searching all text content for a given topic as well as search engines let you search for HTML content.  In this case, all these book images use so many servers to store files, and finding one page to present to the user can be quite complicated.  Initially, reverse indexes for querying arbitrary words and word sets should be easily accessible;  then there is the task of moving to the exact page and place in this book and retrieving the correct image for the search results.  Thus, in this case, the inverted index would be displayed on the location (such as book B), and then B may contain an index with all the words, locations and number of occurrences in each part. </p><br><br><p>  An inverted index that can display Index1 in the diagram above will look something like this: each word or set of words serves as an index for those books that contain them. </p><br><br><br><br><table><thead><tr><th>  Word (s) </th><th>  Book (s) </th></tr></thead><tbody><tr><td>  being amazing </td><td>  Book B, Book C, Book D </td></tr><tr><td>  is always </td><td>  Book C, Book F </td></tr><tr><td>  believe </td><td>  Book b </td></tr></tbody></table><br><br><br><p>  The intermediate index will look similar, but will contain only words, location and information for Book B. This multi-level architecture allows each index to take up less space than if all this information were stored in one large inverted index. </p><br><br><p>  And this is a key point in large-scale systems, because even when compressed, these indices can be quite large and costly to store.  Suppose we have many books from all over the world on this system, 100,000,000 (see the <a href="http://booksearch.blogspot.com/2010/08/books-of-world-stand-up-and-be-counted.html">‚ÄúInside Google Books‚Äù</a> blog entry) - and that each book consists of only 10 pages (in order to simplify calculations) with 250 words on one page : this gives us a total of 250 billion words.  If we take the average number of characters in a word for 5, and encode each character with 8 bits (or 1 byte, even though some characters actually take 2 bytes), thus spending 5 bytes per word, then the index containing each word only once, will require a storage capacity of more than 1 terabyte.  Thus, you can see that indexes that also contain other information, such as word sets, data location and number of uses, can grow in volumes very quickly. <br><br></p><br><br><p>  Creating such intermediate indexes and presenting data in smaller portions makes the ‚Äúbig data‚Äù problem easier to solve.  Data can be distributed across multiple servers and at the same time be quickly accessible.  Indices are the cornerstone of information retrieval and the basis for today's modern search engines.  Of course, this section only generally concerns the topic of indexing, and a lot of research has been done on how to make indices smaller, faster, containing more information (for example, relevance), and freely updated.  (There are some problems with the manageability of competing conditions, as well as the number of updates required to add new data or change existing data, especially when relevance or evaluation is involved). </p><br><br><p>  The ability to quickly and easily find your data is very important, and indexes are the easiest and most effective tool for achieving this goal. </p><br><br><h3>  Load balancers </h3><br><br><p>  Finally, another critical part of any distributed system is a load balancer.  Load balancers are the main part of any architecture, since their role is to distribute the load among the nodes responsible for servicing requests.  This allows multiple nodes to transparently serve the same function in the system.  (See <a href="https://habr.com/ru/post/185636/">Figure 1.18</a> .) Their main goal is to process many simultaneous connections and route these connections to one of the requested nodes, allowing the system to scale up by simply adding nodes to serve more requests. </p><br><br><img src="https://habrastorage.org/storage2/dc2/47d/f05/dc247df0559d7b42fd148f651fdcf3b5.png"><br>  Figure 1.18: Load Balancer <br><br><br><p>  There are many different algorithms for servicing requests, including the selection of a random node, a cyclic algorithm, or even a selection of a node based on certain criteria, such as CPU utilization or RAM.  Load balancers can be implemented as hardware or software.  Among load balancers on open source software, <a href="http://haproxy.1wt.eu/">HAProxy is the</a> most widely distributed. </p><br><br><p>  In a distributed system, load balancers are often at the ‚Äúfront end‚Äù of the system, so all incoming requests pass directly through them.  It is very likely that in a complex distributed system the request will have to go through several balancers, as shown in <br>  <a href="https://habr.com/ru/post/185636/">figure 1.19</a> . </p><br><br><img src="https://habrastorage.org/storage2/d66/34f/9f3/d6634f9f301def9412c8b76b0196d7a6.png"><br>  Figure 1.19: Multiple Load Balancers <br><br><br><p>  Like the proxy, some load balancers may also send requests in different ways, depending on the type of request.  They are also known as reverse proxies. </p><br><br><p>  Managing data that is specific to a particular user session is one of the problems when using load balancers.  On an e-commerce site, when you have only one customer, it is very simple to allow users to put things in their shopping cart and save its contents between visits (this is important, since the probability of selling goods increases significantly if the product returns to is in his basket).  However, if the user is directed to one node for the first session, and then to another node during his next visit, inconsistencies may occur, since the new node may not have data regarding the contents of the user‚Äôs recycle bin.  (Don't you get upset if you put the package of Mountain Dew drink in your basket, and when you return, it won't be there anymore?) One solution might be to make the sessions sticky, so that the user is always directed to the same node.  However, taking advantage of certain reliability features, such as automatic fault tolerance, will be significantly more difficult.  In this case, the user's basket will always have content, but if their sticky node becomes unavailable, a special approach will be needed, and the basket content assumption will no longer be true (although it is hoped that this assumption will not be embedded in the application).  Of course, this problem can be solved with the help of other strategies and tools, as described in this chapter, such as services, and many others (such as browser caches, cookies and URL rewriting). </p><br><br><p>  If the system has only a few nodes, then techniques such as a DNS carousel are likely to be more practical than load balancers, which can be expensive and increase the complexity of the system by adding an unnecessary level.  Of course, in large systems there are all sorts of different algorithms for scheduling and load balancing, including both simple ones like random choices or carousel algorithms, as well as more complex mechanisms that take into account the performance features of the system usage model.  All of these algorithms allow you to distribute traffic and requests, and can provide useful tools for reliability, such as automatic fault tolerance or automatic removal of a damaged node (for example, when it stops responding).  However, these advanced features can make troubleshooting problems cumbersome.  For example, in situations of high load, load balancers will remove nodes that may run slowly or exceed the waiting time (due to a flurry of requests), which will only aggravate the situation for other nodes.  In these cases, extensive control is important because even if it seems that full system traffic and load are reduced (as the nodes serve fewer requests), individual nodes can be overloaded to the limit. </p><br><br><p>  Load balancers are an easy way to increase system power.  Like the other methods described in this article, it plays a significant role in the distributed system architecture.  Load balancers also provide a critical function to check the health of the nodes.  If, as a result of such a check, the node is not responding or overloaded, it can be removed from the query processing pool, and, due to the redundancy of your system, the load will be redistributed among the remaining working nodes. </p><br><br><br><br><h3>  Queues </h3><br><br><p>  Until now, we have considered many ways to quickly read data.  At the same time, another important part of data-level scaling is effective record management.            ,     . ,           . , , , ,          ,        .   ,          ,         .     ‚Äî   . </p><br><br><img src="https://habrastorage.org/storage2/366/d6c/f0c/366d6cf0c5eb60515f94297dad84cc67.png"><br>  1.20:   <br><br><br><p>   ,        .        ,            .   ,    (  )       ,   ,      . ,     ,    ,          ,         .  ‚Äî   ,   <a href="https://habr.com/ru/post/185636/"> 1.20</a> . </p><br><br><p>         ;  ,   ,      .         ,  ,   ;       ,             .  ,        (    ),  ,   ,   .            ,    . </p><br><br><img src="https://habrastorage.org/storage2/36b/c4a/9af/36bc4a9afff6978e87058685669e8476.png"><br>  1.21:      <br><br><br><p>  .     :  ,   ,   ¬´¬ª   ,        . (. <a href="https://habr.com/ru/post/185636/"> 1.21</a> .)            -          .        ,       ;            .         ,    . </p><br><br><p>      ,         .   ,   ,       ,      .      ,   , ,    ,        ,   ,    .        ,    ,    ,       .  ‚Äî   ,        . </p><br><br><p>          . ,      ,      ,    -   .    ,     ,        ,          . </p><br><br><p>  ‚Äî             ,      .           <a href="http://www.rabbitmq.com/">RabbitMQ</a> , <br> <a href="http://activemq.apache.org/">ActiveMQ</a> , <br> <a href="http://kr.github.com/beanstalkd/">BeanstalkD</a> ,       <br> <a href="http://zookeeper.apache.org/">Zookeeper</a> ,      <a href="http://redis.io/">Redis</a> . </p><br><br><br><br><h2>  1.4.  Conclusion </h2><br><br><p>              ,       ,       .       ,       ‚Äî          . </p><br><br><br><br><br><hr><br><p>      <a href="http://creativecommons.org/licenses/by/3.0/legalcode"> Creative Commons Attribution 3.0</a> . .   <a href="http://www.aosabook.org/en/intro1.html">  </a> . <br></p><p>  <a href="https://habr.com/ru/post/185636/">To the top</a> <br> <a href="http://www.aosabook.org/en/index.html">  <em>The Architecture of Open Source Applications</em> .</a> </p><br><br><br><br><br><br></div><p>Source: <a href="https://habr.com/ru/post/185636/">https://habr.com/ru/post/185636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../185624/index.html">Software routing: history of moving from hub-n-spoke (vyatta + openvpn) to fullmesh (mikrotik + tincvpn) - part 1</a></li>
<li><a href="../185626/index.html">Hadoop. Detailed guide. 3rd edition</a></li>
<li><a href="../185628/index.html">Russian projects on Kickstarter in one post</a></li>
<li><a href="../185630/index.html">The future of web development CAD systems</a></li>
<li><a href="../185632/index.html">Since the birth of George Orwell - 110 years. Let's put all the surveillance cameras in holiday hats!</a></li>
<li><a href="../185638/index.html">The main feature of our developers</a></li>
<li><a href="../185640/index.html">Briefly about the new: Samsung launches the world's first smartphone based on advanced LTE-A networks - GALAXY S4 LTE-A</a></li>
<li><a href="../185642/index.html">An interesting development of Koding.com</a></li>
<li><a href="../185644/index.html">Who will take a pack of crystals</a></li>
<li><a href="../185648/index.html">Privacy of maps, coordinates and remote sensing at the household level</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>