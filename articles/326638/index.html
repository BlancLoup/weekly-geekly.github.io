<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>M * - the shortest path search algorithm, through the whole world, on a smartphone</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When searching for the shortest path on large graphs, the traditional cost estimate does not work well because the data is obviously not fit in memory...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>M * - the shortest path search algorithm, through the whole world, on a smartphone</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/774/fa4/ae7/774fa4ae79404ae3990cfa3312b1c621.png"><br><br>  When searching for the shortest path on large graphs, the traditional cost estimate does not work well because  the data is obviously not fit in memory and the total cost depends more on the number of disk accesses than on the number of edges scanned.  And the number of disk operations is a very subjective factor, depending on the difficultly formalizable suitability of a graph for disk storage in the form convenient for a specific algorithm.  In addition, compactness becomes very important - the amount of information per edge and vertex. <br><br>  Under the cat, there is a generalized heuristic to the algorithm A *, which is useful precisely in the light of practical suitability on large graphs with limited resources, for example, on a mobile phone. <br><a name="habracut"></a><br>  So, our task is to build the shortest path along a graph from point to point.  At the same time, the graph is large enough so that we would not be able to keep it entirely in memory, and it is also impossible to pre-calculate for any significant number of vertices.  A great example is the OSM road graph.  Currently, the number of vertices in <a href="https://ru.wikipedia.org/wiki/OpenStreetMap">OSM has</a> exceeded 4.6 billion, the total number of objects is 400 million. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is clear that in such conditions, the search for a more or less extended route with a pure <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Dijkstra</a> or <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2582%25D0%25B0">Levitic</a> <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">algorithm is</a> impossible due to the fact that we do not have the amount of memory required to store intermediate data. <br><br>  What is the Dijkstra algorithm doing? <br><br><ol><li>  Bring in a priority queue starting point with zero cost. </li><li>  While there is something in the queue - let the vertex V, for each outgoing edge (E), which we have not yet viewed: <br><ol><li>  check that this is not the desired edge, if so, then the end; </li><li>  calculate the cost of passage E; </li><li>  and put the final vertex of the edge E in the queue with the cost of its achievement - the cost of achieving V + cost E. </li></ol></li></ol><br>  As a result, for sparse (for example, geometric) graphs, we obtain the value O (n * log (n) + m * log (n)), where n is the number of viewed vertices, m is the number of viewed edges. <br><br><img src="https://habrastorage.org/files/dd6/d26/575/dd6d265751904d679ead8a55f54ac929.png" alt="image"><br><br>  <b>Figure 1</b> Here we see the route found and the edges scanned. <br><br>  The problem is that Dijkstra's algorithm does not use any information about the properties of the graph and the desired route, and during its operation (propagation of the so-called ‚Äúwave‚Äù), the perimeter of this ‚Äúwave‚Äù moves from the desired point in all directions without any discrimination. <br><br>  On the other hand, on geometric graphs, for example, a developed road network, it makes sense to stimulate the propagation of the ‚Äúwave‚Äù towards the target and penalize for other directions.  This idea is implemented in the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_A*">A *</a> algorithm, which is a generalization of the Dijkstra algorithm. <br><br>  In A *, the cost of the vertex when it is placed on the priority queue is not just equal to the distance traveled, but also includes an assessment of the remaining path.  How do we get this estimate? <br><br>  It should be noted that this should be a fairly computationally cheap estimate since  it is executed a large number of times.  The first thing that comes to mind is to calculate the geometric distance from the current point to the finish line and proceed from this, for example: 10 km left - the average speed when driving through the city is 20 km / h, which means our estimate is half an hour. <br><br>  In this case, if the edge leads us towards the finish line, the score for it will decrease and compensate for the distance traveled. <br><br>  For the edges leading from the target, this estimate will increase, as a result such points will fall into a queue with a lot of weight and it is quite likely that the matter will not reach them. <br><br>  Approximately the same effect can be achieved, by the way, using the Beam Search technique, where the size of the priority queue is forcibly limited and candidates that are ‚Äúunworthy‚Äù from a heuristic point of view are simply discarded. <br><br><img src="https://habrastorage.org/files/084/112/c5a/084112c5ab314269a0bed502cec4bb7f.png"><br><br>  <b>Figure 2</b> Here we see the search for the same route using the described heuristics, feel the difference. <br><br>  A * turns into Dijkstra's algorithm if the cost estimate returns 0, as if we thought that the rest of the path would rush at infinite speed. <br><br>  A * refers to the so-called.  <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">informed algorithms</a>  in heuristics, we use the assumption that moving towards a goal will rather lead us to success. <br><br>  What should be the properties of the evaluation function?  It should be believable.  As we have already found out, too optimistic evaluation negates our attempts to reduce the visible part of the graph.  On the other hand, a too pessimistic assessment will force the algorithm to build a path strictly along the direction, no matter what.  It is unlikely that we are satisfied. <br><br>  A realistic estimate should be based on the properties of the graph and better on the data model.  For example, calculated from the level of congestion at this time of day and the level of transport connectivity of the graph.  For example, in a city without rivers, the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B3%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B8%25D1%2585_%25D0%25BA%25D0%25B2%25D0%25B0%25D1%2580%25D1%2582%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B2">Manhattan distance</a> works well. <br><br>  But then immediately there is a mass of nuances: <br><br><ul><li>  How to determine that we are in the city?  It is not so cheap. </li><li>  And nothing that most of the cities built on the rivers? </li><li>  In the city, different sections of roads can be loaded heavily in different ways. </li><li>  And if we have to drive through many cities and rivers? </li></ul><br>  You can use different heuristics in the spirit of <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B2%25D0%25B5%25D0%25B9_%25D0%25B8_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2586">the branch and bound method</a> : <br><br><ol><li>  We find a way with a very pessimistic heuristics, which means that, presumably, there are more efficient routes. </li><li>  Now we will use the cost of the found route as an estimate from above, simply by not including in the priority list applicants who obviously cannot give us a route more efficient than the one already found. </li><li>  We make the assessment less pessimistic and re-build the route with the upper limit of cost. </li><li>  We get a new assessment. </li><li>  We continue this way until we get a satisfactory solution. </li></ol><br>  There is another problem with the valuation, which is worth mentioning. <br><br>  In life, geometrically close objects can be quite remote from the point of view of the road graph.  For example, being on different sides of a river, a mountain range, the sea ... In this case, an assessment based on geometric proximity will begin to aggravate the situation, stubbornly directing the "wave" in the wrong direction. <br><br><img src="https://habrastorage.org/files/953/b8d/48c/953b8d48ced545d29edb93672ce2f496.png"><br><br>  <b>Figure 3</b> This is what the viewed A * part of the OSM graph looks like for finding a route from Italy to Albania. <br><br>  However, it is still better than the algorithm Dijkstra.  You can clearly see how filling the whole of Italy, the "wave" began to overflow, picked up speed and quickly reached the goal. <br><br><img src="https://habrastorage.org/files/84d/a02/b46/84da02b46f3f4e3b99b704fb09e7ed84.png"><br><br>  <b>Figure 4</b> And this is how the scanned part of the graph looks for the Dijkstra algorithm.  Compared to her, everything is not so gloomy. <br><br>  Is it possible to somehow improve the algorithm, what does Computer Sience say about this? <br><br>  <b>Bidirectional search</b> <br><br>  You can send two A * waves towards each other.  This is called <a href="https://en.wikipedia.org/wiki/Bidirectional_search">bidirectional search</a> and at first glance seems like a very attractive idea.  In fact, with good transport connectivity, the ‚Äúwave‚Äù is an ellipsoid, two small waves, directed towards, will notice a smaller area compared to one large.  On the other hand, the problem of detecting a meeting of "waves" arises, there can be quite a lot of points in their perimeters and checking at every step the presence of an edge in someone else's perimeter is not so cheap. <br><br><img src="https://habrastorage.org/files/a8c/e28/0c8/a8ce280c87e9444abcbce223d18a0e95.png"><br><br>  <b>Figure 5</b> oncoming Dijkstra waves <br><br>  Perhaps this could be reconciled with a real gain in the volume of the scanned part of the graph.  But if we consider the above example of finding a passage from Italy to Albania, we will find that bidirectional search will not help us, but will only aggravate the situation.  in addition to pouring the whole of Italy, we will have to look through all of Greece and a half of the Balkans before the waves meet.  For instead of one ‚Äúwave‚Äù, resting on an obstacle, we will have two such. <br><br><h4>  <b>Hierarchical approaches</b> </h4><br>  <b>Using road hierarchies</b> <br><br>  Some commercial systems, such as <a href="http://www.esri.com/data/streetmap">StreetMap USA</a> , use for routing the fact that a well-planned road network has a two-tier nature - there is a network of local roads and a (much smaller) highway network for long-distance travel.  It seems natural to use this fact.  Introduced gateways (transit nodes) - the vertices at which the transition from one level to another.  Finding a ‚Äúlong enough‚Äù path comes down to finding paths from: <br><br><ul><li>  starting point to several nearby gateways; </li><li>  several nearest gateways to the final point; </li><li>  The shortest route from any of the initial gateways to any of the final ones, of course, is done in one session. </li></ul><br><img src="https://habrastorage.org/files/fb6/336/7e1/fb63367e13634060838a30d07f6a4b24.png"><br><br>  <b>6</b> Slice StreetMap <br><br>  The benefits of this approach are obvious.  The downsides are: <br><br><ul><li>  Not everywhere the road network is well planned, in some places it has grown spontaneously, therefore, the initial message does not work. </li><li>  Upper-level network must be connected and verified.  From OSM, for example, it is impossible to get such a network (with a slight movement of the hand) simply by filtering the roads by classes. </li><li>  The gateway institute also requires a lot of manual work. </li></ul><br>  <b>Construction of the graph hierarchy</b> <br><br>  If there is no possibility and / or desire to verify the graph, it remains possible to build a hierarchy automatically. <br><br>  One way or another, the idea is being exploited that even though the graph is not verified, nevertheless, the attributes of the ribs allow us to build routes of acceptable quality.  But due to the size of the graph, the construction of the same A * in the operating mode is prohibitively expensive. <br><br>  For example, it might look like this: <br><ul><li>  at the stage of pre-calculation, a set of (even random) vertices is selected; </li><li>  for pairs of spatially distant vertices, the usual A * shortest routes are constructed; </li><li>  on the basis of the constructed routes statistics of the passed edges is kept; </li><li> after a sufficient amount of data has been accumulated, the visited edges are declared as the next level of the hierarchy; </li><li>  consecutively reaching edges without branches merge into a ‚Äúmacro pattern‚Äù while maintaining the cost of travel; </li></ul><br>  The constructed graph can again be subjected to the described procedure, thus building the required number of hierarchies. <br><br>  Routing in such a hierarchical graph is performed by bidirectional search (A * or Dijkstra's algorithm). <br><br>  <b>Separators</b> <br><br>  The main idea of ‚Äã‚Äãthe method is an attempt to divide the graph into components by removing a small part of the edges - separators.  These separators and the pre-computed paths between them form the next hierarchy.  It is stated [1] that by spending O (n * log (n) ** 3) time and disk space for preliminary calculation, you can execute queries in O (sqrt (n) * log (n)) <br><br>  <b>Grid based transit nodes</b> <br><br>  This is generally the same idea with separators, but for purposes of scaling and simplicity, the graph is divided into fragments by a lattice or quadro-tree, the edges that cross the boundaries of the fragments become transit.  It is clear that the price of this - efficiency.  In the pros - high automation and, as a consequence, the absence of the human factor. <br><br>  <b>Distance tables</b> <br><br>  At the higher levels of the hierarchy in the process of searching for the path are not searched, and the cost is calculated on the basis of pre-calculated tables of the distances between the transit nodes.  When the route is defined, the paths are restored by a local search. <br><br><img src="https://habrastorage.org/files/4a1/565/c20/4a1565c204b94d1fac2739c9cd1a5138.png"><br><br>  7 [1] <br><br>  <b>Reach</b> [3] <br><br>  The idea of ‚Äã‚Äãthe method is as follows - it is noted that when building long optimal routes, ‚Äúlocal‚Äù edges are visited only at the very beginning or end of the route.  Consequently, having built a certain number of ‚Äútraining‚Äù long routes, one can understand how close one or another edge is to any of the ends of the route. <br><br>  For some training route P (s ... ..uv ... ... t), the indicator reach is entered - the minimum distance to the ends reach (uv) = min (dist (s ... ..u), dist (v ... ..t)) . <br>  On the entire training set, reach (uv) is the maximum value on all routes where the edge (uv) is encountered. <br><br>  When ‚Äúfighting‚Äù the search, we are far from the start and finish just going to try to avoid edges with a small value of reach. <br><br><img src="https://habrastorage.org/files/eff/78b/86a/eff78b86af68405a8a2a8bb19defefda.png"><br><br>  Fig.8 [21] <br><br>  The idea of ‚Äã‚Äãthe method is very beautiful, the questions are only the quality of the training sample, its sufficiency and resources spent on training. <br><br><h4>  <b>Purposeful algorithms</b> </h4><br>  <b>Arc-Flags</b> [4] <br><br>  The graph is divided into fragments.  Training on building the shortest route between predefined points.  When constructing a training path, for each edge the fact that the shortest route to the final point cell passes through it is preserved. <br><br>  Thus, for each edge we keep a flag mask, which fragments of the graph can be reached through this edge by the shortest path. <br><br>  The specific disadvantages of this method are visible to the naked eye: <br><br><ul><li>  The number of graph fragments can not be large, 8K fragments (which is not so much) will give us a (presumably incompressible) kilobyte per edge.  Sic! </li><li>  You have to be very careful with slicing fragments; inside the fragment, the graph must be connected. </li></ul><br>  <b>ALT</b> [5] <br><br>  A small number of landmarks is selected from all the vertices: Œª.  In the initial version, for each vertex, the values ‚Äã‚Äãwere pre-calculated up to each Œª.  This required a tremendous amount of additional memory and in the future the requirements were softened and the peaks began to be grouped. <br><br>  ALT searches are performed as in A *, but the remaining path is estimated based on the calculated values.  Let we consider the edge (u, v) on the way to the target vertex t.  For each Œª, in accordance with <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_%25D1%2582%25D1%2580%25D0%25B5%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0">the triangle inequality,</a> we have an estimate of the remaining part of the path (via Œª): dist (Œª, t) - dist (Œª, v) ‚â§ dist (v, t) and dist (v, Œª) - dist (t , Œª) ‚â§ dist (v, t).  The minimum for all Œª and give the desired estimate. <br><br><img src="https://habrastorage.org/files/ba6/29a/cef/ba629acefc294aa08716235688b990bd.png"><br><br>  9 <br><br><h4>  <b>Preliminary results</b> </h4><br>  We see two main areas in which development is underway: <br><br><ol><li>  Hierarchy.  They allow you to very effectively build paths at large distances in structured graphs.  But at short distances it is cheaper to use the usual A * or Dijkstra.  Therefore, there is a ‚Äúgray‚Äù area where both algorithms work mediocre. <br><br>  In addition, an attempt to build a hierarchy on amorphous graphs can only lead to problems.  Imagine a graph in the form of a rectangular lattice of equivalent roads.  When moving in a certain direction, the correct decision will turn in a random direction with a probability associated with the direction.  Those.  if the azimuth to the target is 45 ¬∞, you should turn right and left with equal probability, so as not to create traffic jams. <br><br>  An attempt to build a hierarchy on such a grid will result in inefficient use of the road network. <br><br></li><li>  Using the internal nature of the graph to decide on the direction of movement to the goal.  The idea looks promising, but it raises many questions.  The main problem is the human factor.  What lanmark'i, that fragments of Arc-Flags require the participation of an expert, if you let their definition of gravity, it is easy to get not what the doctor ordered. <br><br>  In addition, the amount of additional memory (non-linear from the graph size) is required. <br></li></ol><br><img src="https://habrastorage.org/files/a38/b15/828/a38b1582843e4d19a155a8304e323a60.png"><br><br>  Here, ‚Äúif Nikanor Ivanovich‚Äôs lips were to be attached to Ivan Kuzmich‚Äôs nose, but to take some kind of swagger, like Balthazar Baltazarovich‚Äôs, yes, perhaps ...‚Äù ¬© <br><br>  It is fair to say that there are many such attempts, some of them can be found in the list of sources of this article.  But we, of course, will not change ourselves and come up with our own, ‚Äúunparalleled‚Äù method.  Ô∏è <br><br><h4>  <b>Heuristic</b> </h4><br>  We set the task to develop a simple and cheap (both computationally and from the point of view of additionally stored information) heuristics for estimating the cost of a path from one point to another based on their geographical coordinates.  Direct distance does not fit, it can be very wrong, just look at Gibraltar and Tangier. <br><br>  The idea goes back to <a href="https://habrahabr.ru/company/2gis/blog/266753/">this</a> work. <br><br><ul><li>  Since we are working with OSM, the scale of the graph is the whole planet. </li><li>  We divide the space with a grid of 1 ¬∞, yes, it gives distortions to the poles, but we are developing only an estimate. </li><li>  When constructing the graph, we will rasterize the paths on this grid, for example, for the 2nd Krupskaya lane in Novosibirsk, we must mark the checkbox corresponding to 55 ¬∞ N.  and 82 ¬∞ E </li><li>  After rasterization of all roads known to us, we get a population map with an accuracy of a degree. <br><br><img src="https://habrastorage.org/files/0a1/213/0c5/0a12130c57ee4c87a2b867e219995218.png"><br><br>  <b>Figure 10</b> - the number of roads per square degree on a logarithmic scale. <br><br></li><li>  We will consider our map as a graph, where populated cells are vertices. </li><li>  We assume that if neighboring cells are inhabited, then this is an edge, from one can be passed to another, the cost of direct travel is 111 km at the equator, the fare is diagonally multiplied by the root of 2. </li><li>  If in this graph we launch a wave in accordance with the Dijkstra algorithm, remembering the cost of reaching each vertex, it will give us an estimate of the cost of the way to the finish at any achievable point.  For example, if you let a wave out of Novosibirsk, it will look like this: <br><br><img src="https://habrastorage.org/files/407/f32/d4e/407f32d4ea924f48b94f92317f2d297a.png"><br><br>  <b>11</b> Estimate the cost of travel from Nsk, the closer to orange, the longer the path. <br></li></ul><br>  So, for the search: <br><br><ul><li>  We store only bits per square degree of surface. </li><li>  Once we start a wave on this bitmap for the final point. </li><li>  For any vertex in the graph, knowing its coordinates, for a constant time we get an estimate of the cost of travel from this point to the finish. </li></ul><br>  But the degree is a rather coarse grid, some straits may stick together, for example, a ‚Äúsmall island‚Äù with Normandy. <br><br>  It does not matter, in OSM there is a type - a coastline.  We will rasterize coastlines and allow walking from a cell labeled coastal to the ‚Äúmainland‚Äù cells. <br><br><img src="https://habrastorage.org/files/250/1ac/67d/2501ac67d1eb410199a2a8d05c404bd3.png"><br>  <b>Fig</b> Coastline OSM <br><br>  But it turns out that: <br><br><ul><li>  the coastline is not everywhere; </li><li>  Japan et al. Consists entirely of coastal cells; </li><li>  Gibraltar and Tangier are in the same cell; </li><li>  ... </li></ul><br>  Ok, you have to draw the dividing lines in important straits with your hands, rasterize them and prohibit them to cross when the wave propagates. <br><br>  Fortunately, this is a one-time job, and there are not very many such straits. <br><br>  For example, the spread of "waves" from Italy, pay attention to the Strait of Gibraltar. <br><br><img src="https://habrastorage.org/files/587/e88/e05/587e88e052674fb98f9038c33959b5dc.png"><br><br>  <b>Fig.13</b> Estimated cost of travel to Italy, the closer to orange, the longer the path. <br><br>  In general, the scheme is acceptable, but: <br><br><ol><li>  it requires manual work; </li><li>  a lot of handmade; </li><li>  one must be very careful if several dividing lines lay on one cell. </li></ol><br>  It is possible that the variant when each ‚Äúcoastal‚Äù cell is represented by a quad-tree will work well here, and wave propagation should be carried out along the elements of the quadtree. <br><br>  But still there is a stretch in all this, so Plan B. enters the business. <br><br><h4>  <b>Plan b.</b> </h4><br><ol><li>  Suppose we have a higher level hierarchy of the graph, obtained, for example, by the method described in the section ‚ÄúConstruction of the graph hierarchy‚Äù. </li><li>  This level is rude enough so that searching for any distance in it does not pose a problem. </li><li>  So, we have in our hands a path built on a higher level of the graph hierarchy. <br><br><img src="https://habrastorage.org/files/c4d/924/fef/c4d924fefa4b4c0b8cb8c0032b43ab70.png"><br><br>  <b>Fig.14</b> The path laid on the top-level graph. <br><br></li><li>  We will put reference points on this route, for example, every 500 km, including the finish, of course <br><img src="https://habrastorage.org/files/5cf/617/512/5cf61751291341bc96946161c183600a.png"><br>  <b>Fig</b> Reference points. <br></li><li>  For each pivot point we know the rest of the way from it to the finish.  Now the remainder heuristics for A * will consist of two parts: <br><ol><li>  geometric distance to the current reference point; </li><li>  the rest of the way from the current reference point to the finish. </li></ol></li><li>  At the beginning of the search, the current reference point is assigned.  As soon as we approach it at a geometric distance closer than 200 km (conventionally, of course), we begin to focus on the next reference point.  And so to the finish. </li><li>  The result is: <br><br><img src="https://habrastorage.org/files/bc3/200/220/bc3200220ef346acaec8b022a86c587c.png"><br><br>  <b>FIG.</b>  <b>11</b> It is clearly seen how the wave begins to spread outward when the reference path changes its direction abruptly.  However, the total amount of read data is very small.  There is also an acceleration of ~ 20 times. <br><br></li><li>  Most of all, this technique resembles the image from the cap for this article.  Therefore, the author gave her the name M * (‚ÄúM‚Äù means ‚Äúcarrot‚Äù). </li></ol><br>  <b>findings</b> <br><br>  So, the reader is presented with two options for the heuristics of calculating the cost of the remainder of the path for A *. <br><br>  For both options: <br><br><ul><li>  tested their performance in practice; </li><li>  the speed of work A * is about the same, for the specified path it is 4.5 seconds (an ordinary desktop) with reading and unpacking data, 0.5 seconds - only the passage of a wave on a heated cache; </li><li>  the amount of additionally stored information is minimal - 0.2% for the second option, for the first even less; </li><li>  because  A * works with the original graph, there are no obstacles to the use of time constraints, for example, ferries, movable bridges, traffic data ... </li></ul><br>  Be that as it may, this is another tool for working with graphs, very useful in conditions of limited resources and / or unlimited data.  In particular, no one forbids using the same technique for a two-way search. <br><br><div class="spoiler">  <b class="spoiler_title">Sources</b> <div class="spoiler_text">  [1] <a href="http://www.dis.uniroma1.it/challenge9/papers/sanders.pdf">Robust, Almost Constant Time Shortest-Path Queries in Road Networks‚ãÜ</a> <a href="http://www.dis.uniroma1.it/challenge9/papers/sanders.pdf"><br></a>  <a href="http://www.dis.uniroma1.it/challenge9/papers/sanders.pdf">Peter Sanders and Dominik Schultes</a> <br><br>  [2] <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bdsssw-chgds-08.pdf">Combining Hierarchical and Goal-Directed Speed-Up Techniques for Dijkstra's Algorithm</a> <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bdsssw-chgds-08.pdf"><br></a>  <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bdsssw-chgds-08.pdf">Reinhard Bauer, Daniel Delling, Peter Sanders, Dennis Schieferdecker, Dominik Schultes, and Dorothea Wagner</a> <br><br>  [3] <a href="https://www.researchgate.net/publication/220982082_Reach-Based_Routing_A_New_Approach_to_Shortest_Path_Algorithms_Optimized_for_Road_Networks">RJ Gutman.</a>  <a href="https://www.researchgate.net/publication/220982082_Reach-Based_Routing_A_New_Approach_to_Shortest_Path_Algorithms_Optimized_for_Road_Networks">Reach-Based Routing: A New Approach to Shortest Path Algorithms for Road Networks.</a>  <a href="https://www.researchgate.net/publication/220982082_Reach-Based_Routing_A_New_Approach_to_Shortest_Path_Algorithms_Optimized_for_Road_Networks">In Proceedings of the 6th Workshop on Algorithm Engineering, 2004</a> <br><br>  [4] <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf">E. K√∂hler, RH M√∂hring, and H. Schilling.</a>  <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf">Acceleration of Shortest Path and Constrained</a> <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf"><br></a>  <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf">Shorttest Path Computation.</a>  <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf">In Proceedings of the 4th Workshop on Experimental Algorithms</a> <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf"><br></a>  <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf">(WEA'05), Lecture Notes in Computer Science, pages 126‚Äì138.</a>  <a href="http://www.dis.uniroma1.it/challenge9/papers/kohler.pdf">Springer, 2005.</a> <br><br>  [5] <a href="http://www.siam.org/meetings/alenex05/papers/03agoldberg.pdf">Goldberg, AV, Werneck, RF: Computing Point-to-Point Shortest Paths from External Memory.</a>  <a href="http://www.siam.org/meetings/alenex05/papers/03agoldberg.pdf">In: Proceedings of the 7th Workshop on Algorithm Engineering and Experiments (ALENEX 2005), pp.</a>  <a href="http://www.siam.org/meetings/alenex05/papers/03agoldberg.pdf">26‚Äì40.</a>  <a href="http://www.siam.org/meetings/alenex05/papers/03agoldberg.pdf">SIAM (2005)</a> <br><br>  [6] <a href="https://arxiv.org/pdf/1002.4330.pdf">Defining and Computing Routes in Road Networks</a> <a href="https://arxiv.org/pdf/1002.4330.pdf"><br></a>  <a href="https://arxiv.org/pdf/1002.4330.pdf">Jonathan Dees, Robert Geisberger, and Peter Sanders</a> <br><br>  [7] <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2010/01/alternativeSea2010.pdf">Alternative Routes in Road Networks</a> <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2010/01/alternativeSea2010.pdf"><br></a>  <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2010/01/alternativeSea2010.pdf">Ittai Abraham, Daniel Delling, Andrew V. Goldberg, and Renato F. Werneck</a> <br><br>  [8] <a href="https://www.researchgate.net/publication/221131524_Partitioning_Graphs_to_Speed_Up_Dijkstra%2527s_Algorithm">Dijkstra's Algorithm Partitioning Graphs to Speedup</a> <a href="https://www.researchgate.net/publication/221131524_Partitioning_Graphs_to_Speed_Up_Dijkstra%2527s_Algorithm"><br></a>  <a href="https://www.researchgate.net/publication/221131524_Partitioning_Graphs_to_Speed_Up_Dijkstra%2527s_Algorithm">ROLF H. MOHRING and HEIKO SCHILLING</a> <br><br>  [9] <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bd-sharc-09.pdf">SHARC: Fast and Robust Unidirectional Routing</a> <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bd-sharc-09.pdf"><br></a>  <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bd-sharc-09.pdf">Reinhard Bauer Daniel Delling</a> <br><br>  [10] <a href="http://camvit.com/camvit-technical-english/Camvit-Choice-Routing-Explanation-english.pdf">Cambridge Vehicle Information Technology Ltd.</a>  <a href="http://camvit.com/camvit-technical-english/Camvit-Choice-Routing-Explanation-english.pdf">Choice Routing</a> <br><br>  [11] <a href="http://algo2.iti.kit.edu/schultes/hwy/combine.pdf">Combining Hierarchical and Goal-Directed Speed-Up Techniques for Dijkstra's Algorithm?</a> <a href="http://algo2.iti.kit.edu/schultes/hwy/combine.pdf"><br></a>  <a href="http://algo2.iti.kit.edu/schultes/hwy/combine.pdf">Reinhard Bauer, Daniel Delling, Peter Sanders, Dennis Schieferdecker, Dominik Schultes, and Dorothea Wagner</a> <br><br>  [12] <a href="http://www.inf.fu-berlin.de/lehre/WS09/DBS-Sem/Reader/schultes_diss.pdf">Fast and Exact Shortest Path Queries Using Highway Hierarchies</a> <a href="http://www.inf.fu-berlin.de/lehre/WS09/DBS-Sem/Reader/schultes_diss.pdf"><br></a>  <a href="http://www.inf.fu-berlin.de/lehre/WS09/DBS-Sem/Reader/schultes_diss.pdf">Dominik schultes</a> <br><br>  [13] <a href="http://algo2.iti.kit.edu/schultes/hwy/esa06HwyHierarchies.pdf">Engineering Highway Hierarchies</a> <a href="http://algo2.iti.kit.edu/schultes/hwy/esa06HwyHierarchies.pdf"><br></a>  <a href="http://algo2.iti.kit.edu/schultes/hwy/esa06HwyHierarchies.pdf">Peter Sanders and Dominik Schultes</a> <br><br>  [14] <a href="http://algo2.iti.kit.edu/schultes/hwy/contract.pdf">Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</a> <a href="http://algo2.iti.kit.edu/schultes/hwy/contract.pdf"><br></a>  <a href="http://algo2.iti.kit.edu/schultes/hwy/contract.pdf">Robert Geisberger, Peter Sanders, Dominik Schultes, and Daniel Delling</a> <br><br>  [15] <a href="http://algo2.iti.kit.edu/schultes/hwy/dynamic.pdf">Dynamic Highway-Node Routing</a> <a href="http://algo2.iti.kit.edu/schultes/hwy/dynamic.pdf"><br></a>  <a href="http://algo2.iti.kit.edu/schultes/hwy/dynamic.pdf">Dominik Schultes and Peter Sanders</a> <br><br>  [16] <a href="http://www.cs.utexas.edu/~pingali/CS395T/2009fa/papers/metis.pdf">A FAST AND HIGH QUALITY MULTILEVEL SCHEME FOR PARTITIONING IRREGULAR GRAPHS</a> <a href="http://www.cs.utexas.edu/~pingali/CS395T/2009fa/papers/metis.pdf"><br></a>  <a href="http://www.cs.utexas.edu/~pingali/CS395T/2009fa/papers/metis.pdf">GEORGE KARYPIS AND VIPIN KUMAR</a> <br><br>  [17] <a href="http://leonidzhukov.ru/hse/2015/networks/papers/powerlawgraphs.pdf">Multilevel Algorithms for Partitioning Power-Law Graphs</a> <a href="http://leonidzhukov.ru/hse/2015/networks/papers/powerlawgraphs.pdf"><br></a>  <a href="http://leonidzhukov.ru/hse/2015/networks/papers/powerlawgraphs.pdf">Amine Abou-rjeili and George Karypis</a> <br><br>  [18] <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bdw-isst-08.pdf">Impact of Shortcuts on Speedup Techniques?</a> <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bdw-isst-08.pdf"><br></a>  <a href="http://i11www.iti.uni-karlsruhe.de/extra/publications/bdw-isst-08.pdf">Reinhard Bauer, Daniel Delling, and Dorothea Wagner</a> <br><br>  [19] <a href="http://algo2.iti.kit.edu/sanders/courses/bergen/routePlanning.pdf">Transit Node Routing based on Highway Hierarchies</a> <a href="http://algo2.iti.kit.edu/sanders/courses/bergen/routePlanning.pdf"><br></a>  <a href="http://algo2.iti.kit.edu/sanders/courses/bergen/routePlanning.pdf">Peter Sanders Dominik Schultes</a> <br><br>  [20] <a href="http://people.mpi-inf.mpg.de/~bast/papers/transit-alenex.pdf">In Transit to Constant Time Shortest-Path Queries in Road Networks ‚àó</a> <a href="http://people.mpi-inf.mpg.de/~bast/papers/transit-alenex.pdf"><br></a>  <a href="http://people.mpi-inf.mpg.de/~bast/papers/transit-alenex.pdf">Holger Bast Stefan Funke Domagoj Matijevic Peter Sanders Dominik Schultes</a> <br><br>  [21] <a href="http://www.cs.princeton.edu/courses/archive/spr09/cos423/Lectures/reach-mit.pdf">Reach for A ‚àó: an Efficient Point-to-Point Shortest Path Algorithm Andrew V. Goldberg</a> <br></div></div><br>  <b>PS</b> : article on the results of the report on the <a href="http://dump-conf.ru/">DUMP 2017</a> </div><p>Source: <a href="https://habr.com/ru/post/326638/">https://habr.com/ru/post/326638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326626/index.html">Own cryptocurrency on ethereum</a></li>
<li><a href="../326628/index.html">SDAccel - first acquaintance</a></li>
<li><a href="../326632/index.html">Under the hood of the development environment. Basic models</a></li>
<li><a href="../326634/index.html">Bash on Windows: Practical Experiments in Crossing Hedgehogs and Snacks</a></li>
<li><a href="../326636/index.html">Moving XenForo Forum to the modern platform</a></li>
<li><a href="../326640/index.html">How to cram your sensor in Android OS</a></li>
<li><a href="../326642/index.html">Recipe interface</a></li>
<li><a href="../326644/index.html">Scientists from ITMO University have proposed a new system for the transmission of energy over a distance</a></li>
<li><a href="../326646/index.html">Simplify converters for WPF</a></li>
<li><a href="../326648/index.html">St. Petersburg homeless - in Prague. Continuing the history of self-taught developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>