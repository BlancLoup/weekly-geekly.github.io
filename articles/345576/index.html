<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing AI for a turn-based game on Node.js (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 It has been a full year and a half since writing my first article on Habr√© . Since then, the FOTM project has undergone several changes. In t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing AI for a turn-based game on Node.js (part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ug/tv/lx/ugtvlxnvlln87mog6hhjzsrswpo.jpeg"><br>  Hello! <br>  It has been a full year and a half since writing my <a href="https://habrahabr.ru/post/302144/">first article on Habr√©</a> .  Since then, the FOTM project has undergone several changes.  In the beginning we will go through briefly on all upgrades, and then we proceed to a detailed analysis of the main feature - AI. <a name="habracut"></a><br><br>  In the first part of my story, I will tell you about the latest changes in the project and trying to implement AI using a neural network.  And in the next article you will learn about the decision tree and plans for the future.  So, let's begin! <br><br><h3>  It would be nice to do ... </h3><br>  After the release of the first article, I received the necessary feedback and began to implement those things that seemed to me the most reasonable and not too complicated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Chat.  Since the game is almost completely built on sockets, creating a chat was quick and easy. </li><li>  Fight in a draw  Now, after 50 moves, the game ends in a draw, so as not to waste the time and nerves of the opponent. </li><li>  Videos.  My friend recorded several training videos on character customization and combat mechanics.  Movies are now available on the YouTube channel of the game. </li><li>  Gulp.  Armed with new knowledge about this collector, I eased and slightly accelerated the client. </li><li>  Moving the logic to the server side.  This task turned out to be very difficult and painstaking.  Most of the mechanic was located exactly on the client side, which is fundamentally wrong.  The main part of the feedback on the game concerned precisely this aspect.  Nevertheless, the transfer allowed not only to make the game less accessible to evil hackers, but also made it possible to fix some terrible things. </li></ul><br>  On the above improvements it took me about six months lazy work.  As soon as the habra effect had passed, I realized that the people entering the game had no one to play with.  They write in an empty chat, stand in line at the arena and ... close the game.  After all, if you are alone on the server, then there is nobody to fight :-( <br><br><h3>  Neuro-fotm </h3><br>  To be honest, I generally wanted to abandon the project, since it has already brought its fruits and experience.  But I was always interested in machine learning, so I started searching for information on neural networks.  After some time, I came to the conclusion: I need a network learning environment.  For this, my game with an untidy field ideally suited to create learning bots. <br><br>  First, I implemented the function of forming a list of actions available on each turn.  There can be 3 of them: <br><br><ul><li>  Movement </li><li>  Use of ability </li><li>  End of turn </li></ul><br>  For each action, a resource is spent - energy, the amount of which is limited per turn.  Imagine that a player has 1000 energy at his disposal: movement costs 300 energy, using the ‚Äúfireball‚Äù ability - 400. This means that you can perform, for example, the following actions: Move -&gt; Move -&gt; Fireball -&gt; End of turn.  After that, the character's energy is replenished to the maximum, and the next player walks. <br><br>  For the sake of experiment, I made the choice of action random, to see how two crazy bots do all sorts of nonsense :) <br><br>  After that, the question arose of how exactly AI should choose an action.  I considered various options, but in the end I came to the next idea.  The neural network accepts normalized information about the situation on the battlefield as input and outputs the following behaviors: <br><br><ol><li>  <b>Offensive move</b> Moving to the cell is more advantageous from the point of view of attack (the point at which the maximum number of opponents is at the optimum distance to use attacking abilities) </li><li>  <b>Defensive move</b> Movement to the cage is more advantageous from the point of view of protection (the point at which the maximum number of allies is at the optimum distance for the use of protective abilities) </li><li>  <b>Offensive</b> Use of damage to the enemy. </li><li>  <b>Defensive</b> Use an ability to help a character or ally survive: heal him or remove negative effects. </li><li>  <b>Control</b> The use of the ability to limit the actions of the enemy: stunning, slowing down, the inability to use abilities, etc. </li><li>  <b>Gain.</b> Use abilities that increase the characteristics of the character or ally </li><li>  <b>Weakening</b> The use of the ability to reduce the characteristics of the enemy. </li></ol><br>  For the neural network model, I chose a rather simple to understand perceptron suitable for my task. <br><br><img src="https://habrastorage.org/webt/o7/ze/hl/o7zehlb1fjzpoi3gugh8mw8wnew.jpeg"><br>  <i>Multilayer perceptron</i> <br><br>  At the entrance - an array of data about the situation.  Consider a small piece of the sequence of values: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input = [..., <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.86</span></span>, ...];</code> </pre> <br>  The six numbers in the example show the ratio of the current health to the maximum for 6 characters (active character, 2 ally and 3 opponents).  At the output of the neural network, you will see the following: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = [<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.45</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">0.03</span></span>];</code> </pre><br>  This is an array of the very 7 behaviors that I described above.  Those.  in this case, the neural network estimated the situation and came to the conclusion that it is best to attack the enemy (0.7), defend oneself or an ally (0.45), or simply go to a cell closer to the enemy (0.2). <br><br>  Each ability in the game has a separate <i>useClass</i> property that classifies it. <br><br><img src="https://habrastorage.org/webt/a9/xz/29/a9xz29p0nbdv_2gyxhmbbibhr0c.jpeg"><br>  <i>The ability "Prowler" deals damage and stuns the enemy for 7 turns</i> <br><br>  For the ability "Prowler" this property is as follows: <br><br><pre> <code class="javascript hljs"> useClass : { <span class="hljs-string"><span class="hljs-string">"offensiveMove"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"defensiveMove"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"offensive"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"defensive"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"control"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"gain"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"weakening"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre><br>  And in the form of an array: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> abilityUseClassArray = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre><br>  To determine how ‚ÄúProwler‚Äù is suitable for this model, I use the solution obtained by the neural network ( <i>output</i> ) and compare 2 linear arrays. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> difference = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; output.length; i++ ) { difference += <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(output[i] - abilityUseClassArray[i]); }</code> </pre><br>  The lower the <i>difference</i> value, the more likely this ability will be used.  With the complete identity of the arrays (100% coincidence of the behavior and the <i>useClass</i> properties of the ability), the <i>difference</i> will be equal to 0. Then it remains only to choose the action for which the <i>difference</i> will be minimal. <br><br>  It seems everything looks beautiful and clear, but there are a number of problems. <br><br><h4>  Problem 1: Normalization </h4><br>  To form an input data array, it was necessary to normalize them in the range from 0 to 1. With the above-mentioned values ‚Äã‚Äãof the health balance, everything turned out to be quite easy.  More difficult with inconstant values, such as temporal effects imposed on a character (buffs and debuffs).  Each of them is an object with several important fields, like the time remaining and the effect multiplier (stacks).  To make the neural network understand how one effect differs from another, I had to enter the same <i>useClass</i> field as for abilities.  Thus, I was able to describe the effect, but the problem remained of their number.  To do this, I took the number of buffs and debuffs imposed on the character and normalized it as: <br><br><pre> <code class="javascript hljs"> buffs.length / <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre><br>  This solution practically does not tell the neural network about the properties of objects inside the array of buffs.  On average, the characters can hang 2-3 effects.  It is impossible to pass the bar at 42, because in battle only 6 characters and 7 abilities are in each.  As a result, the normalized description of the game situation is an array of about 500 values. <br>  One could make 42 sequences of values ‚Äã‚Äãfor describing effects (when there is none, fill them with zeros).  But even if, for example, 10 properties fall on each, then 420 values ‚Äã‚Äãwill be released (and this is only for buffs).  Therefore, I postponed this question for a while :) <br><br><h4>  Problem 2: Teaching Sampling </h4><br>  To form a training sample, I had to manually fill in the output values ‚Äã‚Äãfor a number of situations.  I implemented a UI that showed all the actions available this turn.  The selected action was recorded in a separate JSON file as a solution (output) for a given set of input values ‚Äã‚Äã(input).  For one batch, I managed to form about 500 input-output matches, which was the training sample.  But the main question continued to hang in the air: <b>how large should the sample be</b> ? <br><br>  Moreover, if for some reason I decided to change the description of the situation (as it happened), then everything would have to start all over again.  For example, if the input data array consists not of 520, but of 800 values, then the entire old sample can be thrown into the dustbin along with the network configuration. <br><br><h4>  Problem 3: Network Architecture and Configuration </h4><br>  So, we have about 520 values ‚Äã‚Äãin the array of input parameters and 7 values ‚Äã‚Äãat the output.  To implement the neural network, I chose the <a href="http://caza.la/synaptic/">Synaptic.js</a> library, and implemented the network as follows: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> network = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Architect.Perceptron(<span class="hljs-number"><span class="hljs-number">520</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// input: 520, hidden: 300, output: 7 var trainer = new Trainer(myNetwork); var trainingSet = [ { input: [0, ... , 1], // input.length: 520 output: [0, 0.2, 0.4, 0.5, 0.1, 0, 0] //output.length: 7 }, ... ]; trainer.train(trainingSet, { rate: .1, iterations: 10000, error: .005, shuffle: true, log: 1000, cost: Trainer.cost.CROSS_ENTROPY });</span></span></code> </pre><br>  It looked like the first network configuration.  I launched it and ... after 10,000 iterations, the neuron could not even come close to the given error value of 0.005, while spending 2 hours.  I thought about what can be changed to achieve a given value.  And I realized that everything is bad: ( <br><br>  Consider the available configuration options: <br><br><ol><li>  Sample size </li><li>  The number of hidden layers and the size of each of them </li><li>  Learning rate </li><li>  Number of iterations </li><li>  Error value </li><li>  Evaluation function (3 options or you can write your own) </li></ol><br>  It‚Äôs quite difficult to understand how each of them affects the result of work, especially if you have been doing neural networks for 2 weeks.  If you make 1 hidden layer of only 10 neurons, then an error in 0.01 is reached fairly quickly (approximately 100 iterations), but suspicions about the flexibility of such a network creep in.  Most likely, if you ‚Äúfeed‚Äù her an unusual game situation, she will take a completely unacceptable decision. <br><br><h4>  Problem 4: Speed ‚Äã‚ÄãTraining </h4><br>  With the above configuration, network training lasted about two hours (approximately 1.38 iterations per second).  This is quite a long time, considering that you need to experiment with numbers to get a result.  The problem was that the calculations were made on the CPU (Intel Core i5-4570), and not on the video card.  At this point, I wondered about transferring GPU computing using CUDA.  I shoveled a lot of stuff and came to the conclusion that the chances of setting up CUDA for Node.js on Windows are almost equal to 0. Yes, you can deploy a separate server on Linux that would only do network calculations.  Try to write this server not on Node.js, but in Python and many other options.  But what if the AI ‚Äã‚Äãversion built on a neural network is simply unacceptable for solving my problem? <br><br><h4>  Problem 5: Features of game mechanics </h4><br>  At the network development stage, I encountered two more problems with the chosen approach to implementing AI. <br><br><img src="https://habrastorage.org/webt/sp/rp/od/sprpodphp6yzvznuxoj3j8v-s3o.jpeg"><br>  <i>Lets me take it ability description</i> <br><br><ol><li>  Not all abilities can be attributed to a single behavior.  The most striking example is the oracle's ‚ÄúLets me take it‚Äù ability.  She "steals" an accidental positive effect from the opponent and applies to the one who used it.  The problem is obvious - there are quite a few varieties of positive effects: some are treated, others protect allies, others enhance the combat characteristics, and some restrict the character's movement.  If we steal the reinforcing effect, what will it be?  Strengthening yourself ( <i>gain</i> ) or weakening the enemy ( <i>weakening</i> )?  Essentially both.  But the effect can also heal, therefore - this is already <i>defensive</i> behavior;  and if treatment was taken away from the enemy, then also an <i>offensive</i> .  Thus, the ability ‚ÄúLets me take it‚Äù falls under all behaviors.  Which, of course, is very strange.  This ability is far from the only one with a random factor. </li><li>  Behavior is defined only for a specific situation.  The decision on what is best to do at the moment does not take into account the following actions of both the active player and the opponent's players.  There is no simulation of situations and miscalculations of outcomes of events. </li></ol><br>  All the above problems made me doubt the correctness of the chosen approach to the development of AI.  One colleague who was knowledgeable about machine learning advised using a decision tree instead of a neural network.  We will talk about this in the <a href="https://habrahabr.ru/post/347330/">next part of the article</a> ... <br><br>  In the meantime, thank you for your attention! </div><p>Source: <a href="https://habr.com/ru/post/345576/">https://habr.com/ru/post/345576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345556/index.html">Load testing "non-HTTP". Part 1 JMeter</a></li>
<li><a href="../345560/index.html">New C ++ 17 that everyone should use</a></li>
<li><a href="../345566/index.html">My strategy for the Russian AI Cup 2017</a></li>
<li><a href="../345570/index.html">Checklist of troubles that may occur when moving</a></li>
<li><a href="../345574/index.html">Tcl / Tk - creating extensions / packages based on dynamic libraries</a></li>
<li><a href="../345578/index.html">Bitcoin will not become new digital money: limited emission and money functions</a></li>
<li><a href="../345580/index.html">Build and heat applications in Kubernetes using dapp and GitLab CI</a></li>
<li><a href="../345584/index.html">Computer response time: 1977‚àí2017</a></li>
<li><a href="../345586/index.html">Top 10 examples and anti-examples of developer-audience interaction: Part Two</a></li>
<li><a href="../345588/index.html">From the domination of dwarf Spitz to where a homebody wants to go for a walk (1.5 months in Spain)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>