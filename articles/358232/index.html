<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Support for HTTP / 2 Server Push technology in Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In July 2017, HTTP / 2 implementation appeared in Node.js 8. Since then, it has gone through several stages of improvement, and now the Node.js Founda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Support for HTTP / 2 Server Push technology in Node.js</h1><div class="post__text post__text-html js-mediator-article">  In <a href="http-2-for-node-js-core-261ba493846e">July 2017,</a> HTTP / 2 implementation appeared in Node.js 8.  Since then, it has gone through several stages of improvement, and now the Node.js Foundation says that they are almost ready to deduce HTTP / 2 support from the level of experimental features.  If you want to experience HTTP / 2 in the Node.js environment, the best thing to do is to use Node.js 9 - here you have all the latest bug fixes and improvements. <br> <a href="https://habr.com/company/ruvds/blog/358232/"><img src="https://habrastorage.org/getpro/habr/post_images/62f/5a9/314/62f5a93140c64bc66434aea18d8edfa9.png" alt="image"></a> <br>  The material, the translation of which we are publishing today, is devoted to working with HTTP / 2, and, in particular, with Server Push, in Node.js. <br><a name="habracut"></a><br><h2>  The basics </h2><br>  In order to experience HTTP / 2, it is easiest to use the compatibility layer, which is part of the new <code>http2</code> kernel <code>http2</code> : <br><br><pre> <code class="hljs pgsql">const http2 = require(<span class="hljs-string"><span class="hljs-string">'http2'</span></span>); const <span class="hljs-keyword"><span class="hljs-keyword">options</span></span> = { key: getKeySomehow(), cert: getCertSomehow() }; //   https,     //     const <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = http2.createSecureServer(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>, (req, res) =&gt; { res.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre> <br>  The compatibility layer provides the same high-level API (request listener with familiar <code>request</code> and <code>response</code> objects), which can be used by connecting the <code>http</code> module to <code>require('http')</code> to the project module.  This makes it easy to convert existing projects to HTTP / 2. <br><br>  The compatibility layer also provides a convenient way to migrate to HTTP / 2 for framework authors.  Thus, the <a href="https://www.npmjs.com/package/restify">Restify</a> and <a href="https://www.npmjs.com/package/fastify">Fastify libraries</a> already support HTTP / 2 using the HTTP / 2 Node.js compatibility layer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://www.npmjs.com/package/fastify">Fastify</a> is a <a href="https://thenewstack.io/introducing-fastify-speedy-node-js-web-framework/">new web framework</a> that focuses on performance and is designed to make it <a href="https://www.npmjs.com/package/fastify">easier for</a> programmers to work with.  It has a rich ecosystem of plugins.  Recently released <a href="https://medium.com/%40fastifyjs/fastify-goes-lts-with-1-0-0-911112c64752">version 1.0.0</a> . <br><br>  Using HTTP / 2 with <code>fastify</code> pretty simple: <br><br><pre> <code class="hljs pgsql">const Fastify = require(<span class="hljs-string"><span class="hljs-string">'fastify'</span></span>); //   https,     //     const fastify = Fastify({ http2: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> https: {  key: getKeySomehow(),  cert: getCertSomehow() } }); fastify.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'/fastify'</span></span>, async (request, reply) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre> <br>  While the ability to run the same application code on top of HTTP / 1.1 and on top of HTTP / 2 is important during the implementation phase of the protocol, the compatibility layer itself does not give access to some of the most powerful HTTP / 2 features.  The <code>http2</code> kernel <code>http2</code> allows <code>http2</code> to work with these additional features through the new kernel API ( <a href="&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjVXbH9ysldP0QHsJCImD4qQR6DpA#http2_class_">Http2Stream</a> ), which can be accessed through the stream listener: <br><br><pre> <code class="hljs pgsql">const http2 = require(<span class="hljs-string"><span class="hljs-string">'http2'</span></span>); const <span class="hljs-keyword"><span class="hljs-keyword">options</span></span> = { key: getKeySomehow(), cert: getCertSomehow() }; //   https,     //     const <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = http2.createSecureServer(<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>, (stream, headers) =&gt; { // stream -    // headers -  ,    //  respond    // -     (:) stream.respond({ <span class="hljs-string"><span class="hljs-string">':status'</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }); // ,  ,   stream.respondWithFile() //  stream.pushStream() stream.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(<span class="hljs-number"><span class="hljs-number">3000</span></span>);</code> </pre> <br>  In fastify, you can access <code>Http2Stream</code> through the API <code>request.raw.stream</code> .  It looks like this: <br><br><pre> <code class="hljs lua">fastify.get(<span class="hljs-string"><span class="hljs-string">'/fastify'</span></span>, async (request, reply) =&gt; { request.raw.stream.pushStream({ <span class="hljs-string"><span class="hljs-string">':path'</span></span>: <span class="hljs-string"><span class="hljs-string">'/a/resource'</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stream)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) {   request.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.warn(err);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } stream.respond({ <span class="hljs-string"><span class="hljs-string">':status'</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }); stream.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(<span class="hljs-string"><span class="hljs-string">'content'</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; });</code> </pre> <br><h2>  HTTP / 2 Server Push - opportunities and difficulties </h2><br>  Compared to HTTP / 1, HTTP / 2 gives, in many cases, a huge performance improvement.  <a href="httpwg.org/specs/rfc7540.html">Server Push</a> technology is one of the HTTP / 2 features that is relevant to this. <br><br>  Here is how, simplified, looks like a typical HTTP communication session. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/563/449/7aa/5634497aa81ec7b79aa2875db0775c12.png"><br>  <i><font color="#999999">Hacker News session</font></i> <br><br><ol><li>  Browser requests an HTML document from server </li><li>  The server processes the request and sends the document to the browser, possibly generating it beforehand. </li><li>  The browser receives the server response and parses the HTML document. </li><li>  The browser identifies the resources needed to render an HTML document, such as style sheets, images, JavaScript files, and so on.  The browser then sends requests for these resources. </li><li>  The server responds to each request, sending the browser what it requested. </li><li>  The browser displays the page using HTML document code and associated resources. </li></ol><br>  All this means that during a typical browser-to-server communication session, in order to output one HTML document, the browser needs to perform several independent requests and wait for answers to them.  The first request loads the HTML code, the rest - additional materials, without loading of which the document cannot be correctly output.  It would be great if all these additional materials could be sent to the browser along with the original HTML document, which would relieve the browser from having to download them separately.  As a matter of fact, the HTTP / 2 Server Push technology is intended for the organization of similar work scenarios. <br><br>  When using HTTP / 2, the server can automatically, on its own initiative, send additional resources along with the response to the original request.  These are the resources that, in the server's opinion, the browser will necessarily request later.  When the browser needs these resources, instead of sending additional requests for receiving them, it is enough to use the data that the server sent to it in advance. <br><br>  For example, suppose that the <code>/index.html</code> file <code>/index.html</code> following content is stored on the server: <br><br><pre> <code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>Awesome Unicorn!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/css"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/static/awesome.css"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> This is an awesome Unicorn! <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/static/unicorn.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Having received the corresponding request, the server will respond to it by sending this file.  At the same time, the server knows that for the correct output of the <code>/index.html</code> file, the files <code>/static/awesome.css</code> and <code>/static/unicorn.png</code> .  As a result, the server, using the Server Push mechanism, will send these files along with the <code>/index.html</code> file. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const asset <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [<span class="hljs-string"><span class="hljs-string">'/static/awesome.css'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/unicorn.png'</span></span>]) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> stream -  ServerHttp2Stream. stream.pushStream({<span class="hljs-string"><span class="hljs-string">':path'</span></span>: asset}, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, pushStream)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;   pushStream.respondWithFile(asset); }); }</code> </pre> <br>  On the client side, as soon as the browser parses the code of the <code>/index.html</code> file, it will understand that to render this document you need the <code>static/awesome.css</code> and <code>/static/unicorn.png</code> .  In addition, the browser will become clear that these files have already been sent to him at the initiative of the server and stored in the browser cache.  As a result, he will not have to send two additional requests to the server.  Instead, it will simply take from the cache the data that has already been loaded there. <br><br>  Until now, it all looks very good.  However, if you look closely, in the above scenario, you can detect potential difficulties.  For a start, the server is not so easy to find out what additional resources can be sent on its initiative in response to the original request of the browser.  The logic of making this decision can be brought to the application level, placing the responsibility on the developer.  But even the site developer may not be easy to make such decisions.  One way to do this is as follows: a developer looks at the HTML code and makes a list of additional resources necessary for the correct display of the page in the browser.  However, as the application develops, keeping such a list up to date is laborious and fraught with errors. <br><br>  Another possible problem lies in the fact that the internal mechanisms of the browser are engaged in caching resources that have recently been loaded.  Let's return to the above example.  If, for example, the browser downloaded the <code>/index.html</code> file yesterday, it would also <code>/static/unicorn.png</code> file, which usually gets into the browser cache.  When the browser loads <code>/index.html</code> again and then tries to load the <code>/static/unicorn.png</code> file, it knows that this file is already in the cache.  Therefore, the browser does not fulfill the request to download this file, instead getting it from the cache.  In this case, sending the <code>/static/unicorn.png</code> file <code>/static/unicorn.png</code> browser at the initiative of the server will be a waste of network resources.  It would be good for the server to have some kind of mechanism that allows it to understand if the browser has already cached a certain resource. <br><br>  In fact, other nontrivial tasks are associated with Server Push technology.  If you're interested, read <a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit%3Fusp%3Dsharing">this document</a> . <br><br><h2>  Automate the use of HTTP / 2 Server Push </h2><br>  In order to simplify support for the Server Push feature for Node.js developers, Google has published an npm package for its automation: <a href="https://www.npmjs.com/package/h2-auto-push">h2-auto-push</a> .  This package is designed to solve many difficult problems, among them those we have mentioned above and those mentioned in <a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit%3Fusp%3Dsharing">this document</a> . <br><br>  The package identifies patterns in requests coming from browsers, and finds out what additional resources are associated with the source resources that browsers are looking for.  Later, when requesting the same source resources, additional resources are automatically sent to the browser at the initiative of the server.  In addition, the package evaluates the possibility that the browser already has some resources in its cache, and if it turns out that this is the case, it does not send these resources to it. <br><br>  This package is designed for use in the middleware layer of various web frameworks.  In particular, we are talking about tools for maintaining static files.  As a result, with the use of this package, the development of auxiliary means for automating the sending of materials to browsers by servers is facilitated.  For example, take a look at the <a href="https://www.npmjs.com/package/fastify-auto-push">fastify-auto-push</a> package.  This is a <a href="https://www.fastify.io/">fastify</a> plugin designed to automate sending materials to browsers initiated by servers and using the <a href="https://www.npmjs.com/package/fastify-auto-push">h2-auto-push</a> package. <br><br>  This middleware is quite simple to use and from applications: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fastify = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fastify'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fastifyAutoPush = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fastify-auto-push'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {promisify} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fsReadFile = promisify(fs.readFile); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> STATIC_DIR = path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'static'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CERTS_DIR = path.join(__dirname, <span class="hljs-string"><span class="hljs-string">'certs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createServerOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readCertFile = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fsReadFile(path.join(CERTS_DIR, filename)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [key, cert] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(     [readCertFile(<span class="hljs-string"><span class="hljs-string">'server.key'</span></span>), readCertFile(<span class="hljs-string"><span class="hljs-string">'server.crt'</span></span>)]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {key, cert}; } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {key, cert} = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> createServerOptions(); <span class="hljs-comment"><span class="hljs-comment">//    HTTP/2  https. const app = fastify({https: {key, cert}, http2: true}); //     AutoPush.       //   . app.register(fastifyAutoPush.staticServe, {root: STATIC_DIR}); await app.listen(PORT); console.log(`Listening on port ${PORT}`); } main().catch((err) =&gt; { console.error(err); });</span></span></code> </pre> <br><h2>  Results </h2><br>  According to the results of tests conducted in the Node.js Foundation, it was found that using <code>h2-auto-push</code> improves performance by about 12% compared to using HTTP / 2 without using Server Push technology, and gives a performance increase of about 135% compared to HTTP / 1. <br><br>  <b>Dear readers!</b>  How do you feel about Server Push technology? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/358232/">https://habr.com/ru/post/358232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358222/index.html">A little investigation: how YouTube uses WebRTC for streaming</a></li>
<li><a href="../358224/index.html">Software testing: automation, evaluation and ... utopian</a></li>
<li><a href="../358226/index.html">Fintech-digest: online banking unhappy because of the lack of "humanity"; $ 10 billion bitcoins are stored in Switzerland</a></li>
<li><a href="../358228/index.html">How we conduct experiments in humans. A / b testing for advanced</a></li>
<li><a href="../358230/index.html">Robot Tank on Raspberry Pi with OpenCV</a></li>
<li><a href="../358234/index.html">"Calendar tester" for May. Load service</a></li>
<li><a href="../358236/index.html">DevOps Moscow meetup: Monitoring</a></li>
<li><a href="../358238/index.html">Women's networks: who makes the choice for us?</a></li>
<li><a href="../358242/index.html">AI.Hack St. Petersburg</a></li>
<li><a href="../358244/index.html">Playing Cap: how to put the cashier on the cashier's table</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>