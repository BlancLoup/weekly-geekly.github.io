<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ pattern matching</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is no need to describe what pattern matching is good for. Since in any case there is no such construction in C ++. 
 Without it, working with te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ pattern matching</h1><div class="post__text post__text-html js-mediator-article"><p>  There is no need to describe what pattern matching is good for.  Since in any case there is no such construction in C ++. <br>  Without it, working with templates often becomes overgrown with forests of clear and useful code. <br>  So, I suggest a method of some similarity of pattern matching for C ++ 14 (rather, even type matching), which fits into 50 lines of code, does not use macros, and generally cross-compiler. </p><br><p>  First example of use: <a href="http://coliru.stacked-crooked.com/a/6066e8c3d87e31eb">http://coliru.stacked-crooked.com/a/6066e8c3d87e31eb</a> </p><br><pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">decltype</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> match(value ,[](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> value) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"This is string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value + <span class="hljs-string"><span class="hljs-string">" Hi!"</span></span>; } ,[](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"This is int"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i * <span class="hljs-number"><span class="hljs-number">100</span></span>; } ,[](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"This is default"</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } ); }</code> </pre> <br><p>  compile-time Terms: <a href="http://coliru.stacked-crooked.com/a/ccb13547b04ce6ad">http://coliru.stacked-crooked.com/a/ccb13547b04ce6ad</a> </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span>(true_type{} ,[](bool_constant&lt; T::value == <span class="hljs-number"><span class="hljs-number">10</span></span> &gt;) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"1"</span></span> ; } ,[](bool_constant&lt; (T::value == <span class="hljs-number"><span class="hljs-number">20</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args)&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;) { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"2"</span></span> ; } );</code> </pre> <br><p>  Return the type: <a href="http://coliru.stacked-crooked.com/a/0a8788d026008b4b">http://coliru.stacked-crooked.com/a/0a8788d026008b4b</a> </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t = match(true_type{} ,[](<span class="hljs-keyword"><span class="hljs-keyword">is_same_t</span></span>&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;) -&gt; type_holder&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } ,[](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) -&gt; type_holder&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>{}; } ); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> I = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(t)::type; I i = <span class="hljs-number"><span class="hljs-number">1000000</span></span>;</code> </pre> <a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">If you don‚Äôt understand why you need pattern matching (in particular, by type)</b> <div class="spoiler_text"><p>  For example, you write a wrapper for calling a java function from C ++ (via jni). <br>  Usually it would look like: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_java_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> element)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jni-&gt;CallIntMethod(....); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_java_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> element)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jni-&gt;CallFloatMethod(....); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_java_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">nullptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ jni-&gt;CallVoidMethod(....); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">call_java</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class">){</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Start Java Call"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call_java_helper(element); }</code> </pre> <br><p>  Using pattern matching: </p><br><pre> <code class="hljs markdown">template<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">class</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> auto call_java(T element){ cout <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Start</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Java</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Call</span></span></span></span><span class="xml"><span class="hljs-tag">"; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">match</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">elment</span></span></span></span><span class="xml"><span class="hljs-tag">, ,[](</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">element</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">jni-</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>CallIntMethod(element); } ,[<span class="hljs-string"></span><span class="hljs-string"></span>](<span class="hljs-link"><span class="hljs-link">float element</span></span>){ return jni-&gt;CallFloatMethod(element); } ,[](auto) { jni-&gt;CallVoidMethod(); } ); }</code> </pre> <br><p>  Everything is collected in one place. </p><br><p>  I think you can draw some kind of analogy with the <a href="https://doc.rust-lang.org/book/match.html">Rust pattern matching by enum</a> </p></div></div><br><h2>  Syntax </h2><br><pre> <code class="hljs pgsql">match(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> // &lt;- ,    ,[](std::string <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    std::string */</span></span> } ,[](<span class="hljs-type"><span class="hljs-type">int</span></span> i) { <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i+<span class="hljs-number"><span class="hljs-number">100</span></span>; } ,[](auto a) { <span class="hljs-comment"><span class="hljs-comment">/*  default:  switch */</span></span> } );</code> </pre> <br><h2>  Principle of operation </h2><br><p>  Basic logic: </p><br><pre> <code class="hljs objectivec">namespace details { template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Case, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...OtherCases&gt; decltype(auto) match_call(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Case&amp; _<span class="hljs-keyword"><span class="hljs-keyword">case</span></span>, T&amp;&amp; value, std::true_type, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OtherCases&amp;...) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _<span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(std::forward&lt;T&gt;(value)); } template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Case, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...OtherCases&gt; decltype(auto) match_call(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Case&amp; _<span class="hljs-keyword"><span class="hljs-keyword">case</span></span>, T&amp;&amp; value, std::false_type, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OtherCases&amp;...) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> match(std::forward&lt;T&gt;(value), other...); } } template&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Case, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ...Cases&gt; decltype(auto) match(T&amp;&amp; value, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Case&amp; _<span class="hljs-keyword"><span class="hljs-keyword">case</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cases&amp;... cases) { using namespace std; using args = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FunctionArgs&lt;Case&gt;::args; <span class="hljs-comment"><span class="hljs-comment">// &lt;-    ! using arg = tuple_element_t&lt;0, args&gt;; using match = is_same&lt;decay_t&lt;arg&gt;, decay_t&lt;T&gt;&gt;; return details::match_call(_case, std::forward&lt;T&gt;(value), match{}, cases...); } //   default template&lt;class T, class Case&gt; decltype(auto) match(T&amp;&amp; value, const Case&amp; _case) { return _case(std::forward&lt;T&gt;(value)); }</span></span></code> </pre> <br><p>  The <code>match</code> function accepts a comparable <code>value</code> and a list of lambdas (which serve as cases) as input.  Each lambda should have exactly one argument.  Using <code>FunctionArgs</code> we define the type of this argument.  Then we go through all the lambdas and call the one that matches the type of the argument. </p><br><p>  It is assumed that the last lambda may contain a generic argument.  Therefore, the type of its arguments is not checked.  She just called.  If it is not generic, and the type does not match, the compiler will simply generate an error (although it will first try to convert to type). </p><br><p>  <em>It would be possible to somehow define the generic last lambda or not, but how to do this is unknown.</em> </p><br><p>  FunctionArgs is a modified version of <a href="http://stackoverflow.com/a/27867127/1559666">http://stackoverflow.com/a/27867127/1559666</a> : </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctionArgs</span></span></span><span class="hljs-class"> :</span></span> FunctionArgs&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctionArgsBase</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> args = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> arity = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>...(Args)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = R; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctionArgs</span></span></span><span class="hljs-class">&lt;R(*)(Args...)&gt; :</span></span> FunctionArgsBase&lt;R, Args...&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctionArgs</span></span></span><span class="hljs-class">&lt;R(C::*)(Args...)&gt; :</span></span> FunctionArgsBase&lt;R, Args...&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctionArgs</span></span></span><span class="hljs-class">&lt;R(C::*)(Args...) const&gt; :</span></span> FunctionArgsBase&lt;R, Args...&gt; {};</code> </pre> <br><h1>  PS </h1><br><p>  I should note that there is also <a href="https://github.com/solodon4/Mach7">https://github.com/solodon4/Mach7</a> , which also implements pattern matching (you can even say that more fully).  But the syntax, the abundance of macros, its volume, and the fact that at the time of this writing it was in a bit ... exploded state pushed the author towards this bike ... <br>  However, let's hope for a bright future in the face of c ++ 23 and maybe c ++ 20 with support for pattern matching from the language. </p><br><div class="spoiler">  <b class="spoiler_title">All text code (for copy-paste)</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/* std::string s = "12"; cout &lt;&lt; match(s ,[](int&amp; i) { return "int"; } ,[](bool&amp; b) { return "bool"; } ,[](std::string&amp; s) -&gt; auto&amp; { s += " GAV"; return s; } ,[](auto j) { cout &lt;&lt; "default one"; return j; } ); */</span></span> <span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tuple&gt;</span></span></span><span class="hljs-meta"> template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt;</span></span></span><span class="hljs-meta"> struct FunctionArgs : FunctionArgs</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decltype(&amp;T::operator())&gt;</span></span></span><span class="hljs-meta"> {}; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename R, typename... Args&gt;</span></span></span><span class="hljs-meta"> struct FunctionArgsBase{ using args = std::tuple</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Args...&gt;</span></span></span><span class="hljs-meta">; using arity = std::integral_constant</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unsigned, sizeof...(Args)&gt;</span></span></span><span class="hljs-meta">; using result = R; }; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename R, typename... Args&gt;</span></span></span><span class="hljs-meta"> struct FunctionArgs</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;R(*)(Args...)&gt;</span></span></span><span class="hljs-meta"> : FunctionArgsBase</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;R, Args...&gt;</span></span></span><span class="hljs-meta"> {}; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename R, typename C, typename... Args&gt;</span></span></span><span class="hljs-meta"> struct FunctionArgs</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;R(C::*)(Args...)&gt;</span></span></span><span class="hljs-meta"> : FunctionArgsBase</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;R, Args...&gt;</span></span></span><span class="hljs-meta"> {}; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename R, typename C, typename... Args&gt;</span></span></span><span class="hljs-meta"> struct FunctionArgs</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;R(C::*)(Args...) const&gt;</span></span></span><span class="hljs-meta"> : FunctionArgsBase</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;R, Args...&gt;</span></span></span><span class="hljs-meta"> {}; // forward declarations template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Case, class ...Cases&gt;</span></span></span><span class="hljs-meta"> decltype(auto) match(T&amp;&amp; value, const Case&amp; _case, const Cases&amp;... cases); template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Case&gt;</span></span></span><span class="hljs-meta"> decltype(auto) match(T&amp;&amp; value, const Case&amp; _case); namespace details { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Case, class ...OtherCases&gt;</span></span></span><span class="hljs-meta"> decltype(auto) match_call(const Case&amp; _case, T&amp;&amp; value, std::true_type, const OtherCases&amp;... other) { return _case(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T&gt;</span></span></span><span class="hljs-meta">(value)); } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Case, class ...OtherCases&gt;</span></span></span><span class="hljs-meta"> decltype(auto) match_call(const Case&amp; _case, T&amp;&amp; value, std::false_type, const OtherCases&amp;... other) { return match(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T&gt;</span></span></span><span class="hljs-meta">(value), other...); } } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Case, class ...Cases&gt;</span></span></span><span class="hljs-meta"> decltype(auto) match(T&amp;&amp; value, const Case&amp; _case, const Cases&amp;... cases) { using namespace std; using args = typename FunctionArgs</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Case&gt;</span></span></span><span class="hljs-meta">::args; using arg = tuple_element_t</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0, args&gt;</span></span></span><span class="hljs-meta">; using match = is_same</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decay_t&lt;arg&gt;</span></span></span><span class="hljs-meta">, decay_t</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T&gt;</span></span></span><span class="hljs-meta">&gt;; return details::match_call(_case, std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T&gt;</span></span></span><span class="hljs-meta">(value), match{}, cases...); } // the last one is default template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T, class Case&gt;</span></span></span><span class="hljs-meta"> decltype(auto) match(T&amp;&amp; value, const Case&amp; _case) { return _case(std::forward</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T&gt;</span></span></span><span class="hljs-meta">(value)); }</span></span></code> </pre> </div></div><br><hr><br><p>  <strong>Update</strong> </p><br><p>  The comments offered in my opinion a more perfect way <a href="https://habrahabr.ru/post/282630/">https://habrahabr.ru/post/282630/#comment_8873766</a> . <br>  With it, you can make a comparison with the sample at once on several values. <br>  Even if you are doing a mapping of just one value, you may need to simply pass additional arguments to the function.  For example, in the following example, in clang you need to pass type to a function (gcc and VS work without it): </p><br><pre> <code class="hljs markdown"> template<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">class</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Out</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> inline Out run(Args&amp;&amp;...args){ auto in = std::tie(std::forward<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Args</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(args)...); return match(type<span class="hljs-emphasis"><span class="hljs-emphasis">_holder&lt;Out&gt;() ,[&amp;](type_</span></span>holder<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">void</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>){ command(Parcel(in), Parcel()); } ,[<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">auto type</span></span>)-&gt;Out{ Out out; // clang   :      void . //typename decltype(type)::type out; //    command(Parcel(in), Parcel(out)); return out; } ); }</code> </pre> <br><p>  But something in the spirit: </p><br><pre> <code class="hljs markdown">match( [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">false_type, auto</span></span>) { command(); }, [<span class="hljs-string"><span class="hljs-string">&amp;</span></span>](<span class="hljs-link"><span class="hljs-link">true_type, auto type</span></span>) { typename decltype(type)::type out; command(Parcel(out)); } )(is<span class="hljs-emphasis"><span class="hljs-emphasis">_void{}, type_</span></span>holder<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Out</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>{});</code> </pre> <br><p>  It is impossible to do. </p><br><p>  If the sample is not found, the compiler produces quite clear messages. </p><br><p>  <a href="http://coliru.stacked-crooked.com/a/1f3723d422ef05ee">http://coliru.stacked-crooked.com/a/1f3723d422ef05ee</a> </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">match</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Head</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">match</span></span></span><span class="hljs-class">&lt;Head, Tail...&gt; :</span></span> match&lt;Tail...&gt;, Head { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Head2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">match</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Head2</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail2</span></span></span><span class="hljs-class">&amp;&amp; ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">) :</span></span> match&lt;Tail...&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Tail2&gt;(tail)...), Head(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Head2&gt;(head)) {} <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Head::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> match&lt;Tail...&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">match</span></span></span><span class="hljs-class">&lt;T&gt; :</span></span> T { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">match</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) :</span></span> T(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;R&gt;(r)) {} <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> T::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>(); }; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cases</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">match</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cases</span></span></span><span class="hljs-class">&amp;&amp; ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cases</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::match&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;Cases&gt;::type...&gt;{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Cases&gt;(cases)...}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> io = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1000</span></span>; match( [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 , <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i2) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"int"</span></span> &lt;&lt; i1 &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i2; } ,[](<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"short"</span></span>; } ,[&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>...) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"auto "</span></span> &lt;&lt; io; } )(<span class="hljs-number"><span class="hljs-number">1</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br><p>  PS How much I did not fight, could not bring the syntax to <code>match(1,2) ( cases...)</code> so that the designer was not called move <a href="http://coliru.stacked-crooked.com/a/70d1aec24c26642a">http://coliru.stacked-crooked.com/a/70d1aec24c26642a</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/282630/">https://habr.com/ru/post/282630/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282622/index.html">March Python Meetup: Python VS Erlang and PostgreSQL Features</a></li>
<li><a href="../282624/index.html">JS Programming Contest: Word Classifier</a></li>
<li><a href="../282626/index.html">Web service for simulating pedestrian traffic and identifying improvement problems</a></li>
<li><a href="../282628/index.html">The numbers of Muammar. How I measured artificial intelligence on an internship at Yandex</a></li>
<li><a href="../28263/index.html">About acquaintance on Habr√©, and the idea of ‚Äã‚Äãa blog ...</a></li>
<li><a href="../282634/index.html">Angular 2 Beta, training course "Tour of Heroes" part 3</a></li>
<li><a href="../282636/index.html">Translator from the car, or how to teach the MFP to translate documents</a></li>
<li><a href="../282638/index.html">Google DNS no longer supports Round Robin DNS</a></li>
<li><a href="../282640/index.html">Xamarin SDK in Open Source and more at Xamarin Evolve 2016</a></li>
<li><a href="../282642/index.html">Announcement! DevCon 2016 participants will be available a master class from Intel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>