<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>First Rust Steps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Recently met with a new programming language Rust. I noticed that it is different from the others I have come across before. Therefore, I decid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>First Rust Steps</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ra/od/jn/raodjnsmyuf5nphvpqwkhcwliyi.jpeg" alt="image"></p><br><p>  Hello.  Recently met with a new programming language Rust.  I noticed that it is different from the others I have come across before.  Therefore, I decided to dig deeper.  I want to share the results and my impressions: </p><br><ul><li>  I'll start with the main, in my opinion, Rust features </li><li>  I will describe interesting syntax details </li><li>  Let me explain why Rust is not likely to take over the world. </li></ul><br><p>  Immediately I will explain that I have been writing in Java for about ten years, so I will argue from my bell tower. </p><a name="habracut"></a><br><h1 id="killer-feature">  Killer feature </h1><br><p>  Rust is trying to take an intermediate position between low-level languages ‚Äã‚Äãlike C / C ++ and high-level Java / C # / Python / Ruby ... The closer the language is to the hardware, the more control, it is easier to foresee how the code will be executed.  But having full access to the memory is much easier to shoot yourself a leg.  In contrast to C / C ++, Python / Java and all the rest appeared.  They do not need to think about cleaning up the memory.  The worst trouble is the NPE, leaks are not a common occurrence.  But for this all to work, at least garbage collector, which in turn begins to live its own life, in parallel with the user code, reducing its predictability, is necessary.  The virtual machine still provides platform independence, but as far as is necessary - a controversial issue, I will not raise it now. </p><br><p>  Rust is a low-level language, the output of the compiler is a binary, for which no additional tricks are needed.  All logic for removing unnecessary objects is integrated into the code at the time of compilation, i.e.  garbage collector at runtime either.  Rust also has no null links and the types are safe, which makes it even more reliable than Java. </p><br><p>  At the heart of memory management is the idea of ‚Äã‚Äãowning a reference to an object and borrowing.  If each object is owned by only one variable, then as soon as its life ends at the end of the block, all that it pointed out can be cleaned recursively.  Links can also be lent for reading or writing.  Here the principle of one writer and many readers work. </p><br><p>  This concept can be demonstrated in the next piece of code.  From the <em>main ()</em> method, <em>test</em> <em>()</em> is called, in which a recursive data structure <em>MyStruct</em> is <em>created</em> , which implements the destructor interface.  <em>Drop</em> allows you to set logic to execute before an object is destroyed.  Something similar to the finalizer in Java, but unlike Java, the moment of calling the <em>drop ()</em> method is quite definite. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { test(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of main"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = MyStruct { v: <span class="hljs-number"><span class="hljs-number">1</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new( <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(MyStruct { v: <span class="hljs-number"><span class="hljs-number">2</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), }) ), }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"End of test"</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyStruct</span></span></span></span> { v: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, s: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;MyStruct&gt;&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyStruct { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cleaning {}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.v) } }</code> </pre> <br><p>  The output will be as follows: </p><br><pre> <code class="plaintext hljs">End of test Cleaning 1 Cleaning 2 End of main</code> </pre> <br><p>  Those.  memory was recursively cleared before exiting <em>test ()</em> .  The compiler took care of this by inserting the necessary code.  What is <em>Box</em> and <em>Option I</em> will describe later. </p><br><p>  Thus, Rust takes security from high-level languages ‚Äã‚Äãand predictability from low-level programming languages. </p><br><h1 id="chto-esche-interesnogo">  What else interesting </h1><br><p>  Next, I will list the features of the language in descending order of importance, in my opinion. </p><br><h2 id="oop">  OOP </h2><br><p>  Here Rust is generally ahead of the rest.  If most languages ‚Äã‚Äãhave come to the conclusion that it is necessary to abandon multiple inheritance, then in Rust there is no inheritance at all.  Those.  a class can only implement interfaces in any quantity, but cannot be inherited from other classes.  In Java terms, this would mean making all classes final.  In general, the syntactic diversity to maintain OOP is not so great.  Perhaps this is for the better. </p><br><p>  To merge data there are structures that can contain implementation.  Interfaces are called trait and may also contain default implementations.  They do not reach the abstract classes, because  cannot contain fields, many complain about this restriction.  The syntax is as follows, I think the comments are not needed here: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { MyPrinter { value: <span class="hljs-number"><span class="hljs-number">10</span></span> }.print(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPrinter</span></span></span></span> { value: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Printer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MyPrinter { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value) } }</code> </pre> <br><p>  Of the features that I noticed, it is worth noting the following: </p><br><ul><li>  Classes have no constructors.  There are only initializers, which, using curly brackets, specify values ‚Äã‚Äãfor the fields.  If you need a constructor, then this is done through static methods. </li><li>  The instance method differs from the static one by the presence of the <em>&amp; self</em> reference as the first argument. </li><li>  Classes, interfaces, and methods can also be generalized.  But unlike Java, this information is not lost at compile time. </li></ul><br><h2 id="esche-nemnogo-bezopasnosti">  A little more security </h2><br><p>  As I said Rust pays great attention to the reliability of the code and tries to prevent most errors at the compilation stage.  For this, the possibility of making links empty has been excluded.  It reminded me of the nullable types from Kotlin.  Use <em>Option</em> to create null links.  Just as in Kotlin, when you try to access such a variable, the compiler will beat your hands, forcing you to insert checks.  Attempting to pull out a value without checking may result in an error.  But this certainly can not be done randomly, for example, in Java. </p><br><p>  I also liked the fact that all variables and class fields by default are immutable.  Hello Kotlin again.  If the value can change, it is obviously necessary to specify the keyword <em>mut</em> .  I think the desire for immutability greatly improves the readability and predictability of the code.  Although <em>Option is</em> for some reason mutable, I did not understand this, here is the code from the documentation: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = x.take(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(x, <span class="hljs-literal"><span class="hljs-literal">None</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(y, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre> <br><h2 id="perechisleniya">  Transfers </h2><br><p>  In Rust are called <em>enum</em> .  Only besides a limited number of values, they can still contain arbitrary data and methods.  Thus, it is a cross between enumerations and classes in Java.  The standard <em>enum Option</em> in my first example just belongs to this type: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  To handle such values ‚Äã‚Äãthere is a special design: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> a { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"empty"</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(v) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, v) } }</code> </pre> <br><h2 id="a-takzhe">  And </h2><br><p>  I do not intend to write a textbook on Rust, but just want to emphasize its features.  In this section I will describe what else is useful, but, in my opinion, not so unique: </p><br><ul><li>  Fans of functional programming will not be disappointed, for them there are lambdas.  The iterator has methods for handling the collection, for example, <em>filter</em> and <em>for_each</em> .  Something like a stream from Java. </li><li>  The <em>match</em> construct can also be used for more complex things than ordinary <em>enum</em> , for example, for processing patterns. </li><li>  There are a large number of built-in classes, for example, collections: <em>Vec, LinkedList, HashMap</em> , etc. </li><li>  You can create macros </li><li>  It is possible to add methods to existing classes. </li><li>  Supports automatic type inference. </li><li>  Along with the language comes the standard framework for testing </li><li>  The built-in <em>cargo</em> utility is used to build and manage dependencies. </li></ul><br><h1 id="lozhki-degtya">  Spoons of tar </h1><br><p>  This section is required to complete the picture. </p><br><h2 id="killer-problem">  Killer problem </h2><br><p>  The main drawback comes from the main feature.  You have to pay for everything.  In Rust, it is very inconvenient to work with variable graph data structures, since  Any object should have no more than one link.  To circumvent this limitation, there is a bunch of built-in classes: </p><br><ul><li>  <em>Box</em> - an immutable value on the heap, an analogue of wrappers for primitives in Java </li><li>  <em>Cell</em> - variable value </li><li>  <em>RefCell</em> - variable value available by reference </li><li>  <em>Rc</em> - reference counter, for several links to one object </li></ul><br><p>  And this is an incomplete list.  For the first sample of Rust, I rashly decided to write a single-linked list with basic methods.  Ultimately, the link to the node was the following <em>Option &lt;Rc &lt;RefCell &lt;ListNode &gt;&gt;&gt;</em> : </p><br><ul><li>  <em>Option</em> - to handle an empty link </li><li>  <em>Rc</em> - for several links, because  the last object is referenced by the previous node and the sheet itself </li><li>  <em>RefCell</em> - for a changeable link </li><li>  <em>ListNode</em> - the next item itself </li></ul><br><p>  It looks so-so, a total of three wrappers around one object.  The code for simply adding an item to the end of the list was very cumbersome, and there are some unobvious things in it, such as cloning and lending: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListNode</span></span></span></span> { val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, next: Node, } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LinkedList</span></span></span></span> { root: Node, last: Node, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> = <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Rc&lt;RefCell&lt;ListNode&gt;&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, val: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; LinkedList { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = Rc::new(RefCell::new(ListNode { val: val, next: <span class="hljs-literal"><span class="hljs-literal">None</span></span> })); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root.is_none()){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.root = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last.map(|v| { v.borrow_mut().next = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n.clone()) }); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.last = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } ...</code> </pre> <br><p>  On Kotlin, the same thing looks much simpler: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newNode = ListNode(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, value); root = root ?: newNode; last?.next = newNode last = newNode; }</code> </pre> <br><p>  As I found out later, such structures are not characteristic of Rust, and my code is completely non-idiomatic.  People even write whole articles: </p><br><ul><li>  <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/README.html">10 ways to make a list on Rust</a> </li><li>  <a href="https://rust-leipzig.github.io/architecture/2016/12/20/idiomatic-trees-in-rust/">Another way</a> </li><li>  <a href="https://rcoh.me/posts/rust-linked-list-basically-impossible/">Torment similar to mine</a> </li></ul><br><p>  Here Rust sacrifices readability for safety.  In addition, such exercises can still lead to looped links that hang in memory, because  no garbage collector will clean them.  I didn‚Äôt write working code on Rust, so it‚Äôs hard for me to say how much such difficulties complicate life.  It would be interesting to get comments from practicing engineers. </p><br><h2 id="slozhnost-izucheniya">  Difficulty learning </h2><br><p>  The long process of studying Rust largely follows from the previous section.  Before you write anything at all, you will have to spend time mastering the key concept of memory ownership, because  it permeates every line.  For example, the simplest list took me a couple of nights, while on Kotlin the same thing is written in 10 minutes, despite the fact that this is not my working language.  In addition, many familiar approaches to writing algorithms or data structures in Rust will look different or not work at all.  Those.  in going to it, a deeper restructuring of thinking will be needed, just mastering the syntax will not be enough.  This is not JavaScript, which swallows everything and endures everything.  I think Rust will never be the language in which children learn in programming school.  Even C / C ++ has more chances in this sense. </p><br><h1 id="v-itoge">  Eventually </h1><br><p>  The idea of ‚Äã‚Äãmemory management at compile time seemed very interesting to me.  In C / C ++, I have no experience, so I will not compare it with a smart pointer.  The syntax is generally pleasant and there is nothing superfluous.  I criticized Rust for the complexity of implementing graph data structures, but I suspect that this is a feature of all programming languages ‚Äã‚Äãwithout GC.  Perhaps the comparison with Kotlin was not entirely fair. </p><br><h1 id="todo">  Todo </h1><br><p>  In this article, I have not touched multithreading at all, I think this is a separate big topic.  There are also plans to write some kind of data structure or algorithm more complicated than the list, if you have ideas, please share in the comments.  It would be interesting to find out what type of applications they write on Rust. </p><br><h1 id="pochitat">  Read </h1><br><p>  If you are interested in Rust, then here are some links: </p><br><ul><li>  <a href="https://www.amazon.com/Programming-Rust-Fast-Systems-Development/dp/1491927283/ref%3Dsr_1_2%3Fie%3DUTF8%26qid%3D1544963104%26sr%3D8-2">Programming Rust: Fast, Safe Systems Development</a> is a good book, there is also an electronic version </li><li>  <a href="https://doc.rust-lang.org/">Rust Documentation</a> - official documentation, there are examples </li><li>  <a href="https://github.com/mre/idiomatic-rust">Idiomatic Rust code</a> - list of articles </li><li>  <a href="https://gitter.im/ruRust/easy">ruRust / easy</a> and <a href="https://gitter.im/ruRust/general">ruRust / general</a> - channels in Gitter </li><li>  <a href="https://www.reddit.com/r/rust/">r / rust /</a> - Reddit </li></ul><br><p>  <strong>UPD: Thank you all for the comments.</strong>  <strong>I learned a lot of useful things for myself.</strong>  <strong>Corrected inaccuracies and typos, added links.</strong>  <strong>I think such discussions greatly contribute to the study of new technologies.</strong> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/433302/">https://habr.com/ru/post/433302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433292/index.html">The digest of interesting materials for the mobile developer # 279 (December 10 - 16)</a></li>
<li><a href="../433294/index.html">A few simple teamwork recommendations.</a></li>
<li><a href="../433296/index.html">Financial management in an IT company</a></li>
<li><a href="../433298/index.html">Network Digest: 17 expert materials on Wi-Fi and 5G</a></li>
<li><a href="../433300/index.html">Creating a home media center. Prologue</a></li>
<li><a href="../433304/index.html">Load testing with locust. Part 3</a></li>
<li><a href="../433306/index.html">Visual studio 2019</a></li>
<li><a href="../433308/index.html">Transferring PBX configuration to 3CX PBX Express service</a></li>
<li><a href="../433316/index.html">Design Digest: onboarding, feedback, search for ideas and decision making</a></li>
<li><a href="../433318/index.html">garbage.collect ()</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>