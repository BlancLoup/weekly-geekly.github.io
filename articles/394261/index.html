<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RS232 3-in-1 device for a home Linux server: Part 1 (Hardware)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Part 1 (Hardware) Schematic diagram Printed circuit board Software 
- Schematic diagram 
- Printed circuit board 
- Software 
- Part 2 (Server) 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RS232 3-in-1 device for a home Linux server: Part 1 (Hardware)</h1><div class="post__text post__text-html js-mediator-article"><ul><li>  <strong>Part 1 (Hardware)</strong> <br><ul><li>  <a href="https://habr.com/post/394261/">Schematic diagram</a> </li><li>  <a href="https://habr.com/post/394261/">Printed circuit board</a> </li><li>  <a href="https://habr.com/post/394261/">Software</a> </li></ul></li><li>  <a href="https://habr.com/post/300968/">Part 2 (Server)</a> </li></ul><br><p>  Servers assembled from components not specifically designed for this usually have two drawbacks.  They lack a hardware watchdog timer and often lack entropy for a number of services.  The lack of entropy is especially relevant for not heavily loaded servers.  This is due to the fact that the Linux kernel uses system activity as the source of entropy, namely: network equipment, disk subsystem and hardware interrupts. </p><br><p>  Also in the home server it is often necessary to have a more economical, in comparison with Wi-Fi, radio module for communication with autonomous sensors. </p><br><p>  There is a large selection of devices with which you can solve any of these problems, but connecting each of them requires a separate port.  Assessing the situation, I finally decided to develop a 3-in-1 device connected to the RS232 (COM) port.  The remaining requirements were as follows: </p><br><ul><li> Hardware watchdog timer, suitable for working with the standard <code>watchdog</code> ; </li><li>  True random number generator based on the reverse avalanche breakdown effect of the pn junction; </li><li>  Radio module nRF24L01 + for data collection from autonomous sensors. </li></ul><br><p>  Thus, the device received the name WRN from the names of its constituent subsystems: WDT (WatchDog Timer), RNG (Random Number Generator), nRF24L01 +. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6b0/170/387/6b017038743ee2a7d30af616d240e3e6.png" alt="WRN device"></p><a name="habracut"></a><br><p>  Running a lot ahead, I want to note that the lack of entropy can be easily eliminated without additional devices, by running the <code>rngd</code> daemon with the key <code>--rng-device=/dev/urandom</code> .  The <code>/dev/urandom</code> operation algorithms are good enough for this, but I wanted a hardware RNG, so there was nowhere to go, I had to do it. </p><br><a name="wrn_schematic"></a><br><h2 id="principialnaya-shema">  Schematic diagram </h2><br><p>  <em>(click to enlarge)</em> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/874/9d0/126/8749d01261e2d18a49bb4067dcc89f56.png" alt="Schematic diagram"></a> </p><br><p>  The device is based on the ATmega328P microcontroller and operates at a maximum frequency of 20MHz.  For the sake of experiment, I tried to overclock, but I couldn't find a crystal more modest than 32MHz, the microcontroller did not work with it.  Nevertheless, any quartz resonator can be used in the device in reasonable, from the point of view of the microcontroller, limits.  The article will have more details about this, but in fact, it suffices to calculate the constants for the software clock and build the loader with the appropriate parameters. </p><br><p>  The diagram provides connectors for connecting the SPI programmer and USB-UART converter, which is required for debugging, as it is not easy to get direct access to the RS232.  In some places the scheme is not optimal, since it was assembled from components that were available.  If desired, it can be optimized, the sources for KiCAD are available on the GitHub <a href="https://github.com/alexcustos/wrn-project">alexcustos / wrn-project</a> in the <strong>pcb</strong> directory. </p><br><div class="spoiler">  <b class="spoiler_title">Description of standard circuit components</b> <div class="spoiler_text"><ul><li>  <strong>C12</strong> - protection against interference required when using an analog-to-digital converter; </li><li>  <strong>Y1, C3, C4</strong> - standard connection of the quartz resonator; </li><li>  <strong>D1, R11</strong> - LED and resistor limiting current in its circuit, chosen empirically, because the LED could not be identified; </li><li>  <strong>PB1, R2</strong> - the RESET button and pull-up (pull-up) of the output to a high level in order to avoid triggering as a result of induced interference; </li><li>  <strong>U1, C1, C2</strong> - voltage regulator for the radio module and smoothing filters, the 800mA regulator is of course not needed here, 100mA is more than enough; </li><li>  <strong>U2, R1</strong> - optocoupler and a resistor that limits the current to 20mA in the LED circuit; </li><li>  <strong>U3, C5, C6, C9, C10</strong> - RS232-TTL level converter and standard piping; </li><li>  <strong>P3, C11</strong> - power supply +5 and + 12V from the FDD connector and a smoothing filter for 12V; </li><li>  <strong>P4</strong> - connector for a radio module; </li><li>  <strong>P1</strong> - ISP connector for downloading the code to the microcontroller, required for firmware loader; </li><li>  <strong>P2</strong> - connector for connecting to computer RS232 port; </li><li>  <strong>P5</strong> - contact pad for connecting a controlled RESET button and a backup button from the front panel of the case; </li><li>  <strong>P7</strong> - connector for USB-UART converter connection. </li></ul></div></div><br><h3 id="preobrazovatel-urovney-rs232-ttl">  RS232-TTL Level Converter </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c90/a78/d63/c90a78d63fa67853f75e63d888e9a29d.png" alt="RS232-TTL Level Converter"></p><br><p>  Here, the ADM202EANZ chip from Analog Devices is used just because I have three copies of the MAX232ACPE not working properly.  Otherwise, these chips are completely interchangeable and you can use the more common version of Maxim. </p><br><p>  Resistors <strong>R3, R4, R12 are</strong> needed to connect to the USB-UART converter circuit.  At different levels on two competing signal lines, the resistance will act as a voltage divider.  Since the load impedance is much less than 1kŒ©, the signal from the directly connected converter will only be slightly attenuated, and the signal from <strong>U3</strong> can be completely neglected. </p><br><p>  It is not convenient to use only SPI for flashing the device, since a programmer and direct access to the device is required.  In addition, there is a radio module on the SPI lines, which would also have to be connected via resistors. </p><br><p>  Firmware through the bootloader is a good option, but also has a drawback.  The loader perceives the DTR (Data Terminal Ready) signal as a reboot command, which leads to an undesirable device reboot when the terminal is connected. </p><br><p>  It is not difficult to fight this; it is enough to add a <strong>Q4</strong> field-effect transistor as a switch and block the DTR line immediately after the standard load.  If you need to flash the device, just send the unlock command.  Resistor <strong>R6 is</strong> needed for the line to be connected by default;  capacitor <strong>C7</strong> - for reliable operation RESET. </p><br><p>  The ability to flash a device can be a serious vulnerability for the entire system, so you need the hardware ability to block the firmware, for this it is enough to open the jumper <strong>JP1</strong> .  In addition, it is useful for debugging when a USB-UART converter is connected. </p><br><h3 id="generator-shuma-na-effekte-lavinnogo-proboya-p-n-perehoda">  Noise generator based on avalanche breakdown effect of pn junction </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f8/f84/2d4/8f8f842d4c68c83349503a02d7677dc5.png" alt="Noise generator"></p><br><p>  The generator here is a reverse biased pn junction of the <strong>Q1</strong> transistor.  According to the passport Vebo = 6V, this is the maximum reverse-turn-on voltage when the collector is open (not connected).  Of course, the transistor will not exit from the operating mode immediately when this threshold is exceeded, so for reliability, you need to increase the voltage to 12V.  In this mode, in the pn junction, impact ionization will occur in those places where the electric field strength is sufficient.  This process is extremely unstable, the constant failure and the occurrence of ionization in various places of the pn junction, leads to a random change in current.  The transistor is used here only because the reverse bias voltage of the diodes is much higher, for example, the popular 1N4148 is 100V. </p><br><p>  The rest of the circuit works as follows: <strong>Q2</strong> amplifies the current from <strong>Q1</strong> ;  <strong>R5</strong> limits the current in the collector-emitter circuit <strong>Q2</strong> ;  <strong>C8</strong> cuts off the constant component of the signal from <strong>Q2</strong> , aligning the spectrum somewhat;  ( <strong>R7 + R8</strong> ) provides current to the base-emitter circuit <strong>Q3</strong> as a constant additive to the current from <strong>C8</strong> ;  <strong>Q3</strong> amplifies the total current from <strong>C8</strong> and ( <strong>R7 + R8</strong> );  <strong>R9, R10</strong> divider, limits the voltage to 5V at the input of the microcontroller. </p><br><a name="wrn_pcb"></a><br><h2 id="pechatnaya-plata">  Printed circuit board </h2><br><p>  In the <a href="https://habr.com/post/388079/">previous article,</a> there was already an instruction on how to draw a circuit and dilute the board in KiCAD.  There are no fundamental differences, only the board now needs to be printed. </p><br><p>  The dimensions of the printed circuit board are usually determined after layout, but you can set them initially and adjust them as necessary.  This work is done on the <strong>Edge.Cuts</strong> layer <strong>with the</strong> tool <img src="https://habrastorage.org/getpro/habr/post_images/e92/dc9/287/e92dc928723b7a38183d4b7c80b6096d.png" alt="Add graphic line or polygon">  or other suitable, if you need a round board or with rounded edges. </p><br><p>  Before printing, it is desirable to bring the pads in order.  The fact is that the shape of the pad and the diameter of the holes for each element are different.  Accordingly, unnecessary difficulties may arise when drilling, soldering, or even during tracing, when the tracks will not go where they should be. </p><br><p>  This process is not very convenient, because in the <code>pcbnew</code> editor macros are still in development, and the hot key is assigned only to edit the pad.  However, this is not difficult.  First you need to determine the diameter of the drill, in most cases the optimum will be 1mm, and assign the appropriate hole to all sites.  Then, if necessary, correct the shape of the pads so that there is enough copper on them, but at the same time they are quite far from each other and from the tracks. </p><br><p>  To edit a separate pad ( <strong>Pad</strong> ), you need to point at it with the cursor and press E, or right-click on it <img src="https://habrastorage.org/getpro/habr/post_images/913/6e4/58b/9136e458b1150d93429b64902d21a110.png" alt="Pad">  then <img src="https://habrastorage.org/getpro/habr/post_images/f99/389/b60/f99389b60f7c04ec04dfd05ade486b26.png" alt="Edit pad">  .  To copy the settings of the newly edited site to the current one, you need to use <img src="https://habrastorage.org/getpro/habr/post_images/7a1/439/2a8/7a14392a84812a92e76b8b84f288a24f.png" alt="Copy Current Settings to this Pad">  , and to apply the settings to the group, select <img src="https://habrastorage.org/getpro/habr/post_images/925/73d/49a/92573d49a6dcf24fc8b4cc68346feeec.png" alt="Edit All Pads">  .  The latter option somewhat simplifies the process, but is applicable only to one footprint or a group of identical.  Here you also need to pay attention to the checkboxes of the filter, which limit the scope. </p><br><p>  <strong>Perform design rules check</strong> tool is provided for checking the PCB. <img src="https://habrastorage.org/getpro/habr/post_images/310/d0f/f15/310d0ff15d9c4c0995f6139fd25535d3.png" alt="Perform design rules check">  ‚Üí <strong>Start DRC,</strong> both the <strong>Problems / Markers</strong> and <strong>Unconnected tabs</strong> must be empty. </p><br><p>  In conclusion, you must visually make sure that everything is in order.  To do this, be sure to admire the result in <strong>View</strong> ‚Üí <strong>3D Viewer</strong> .  Then export the PCB to Gerber format (something like PDF for documents) <strong>File</strong> ‚Üí <strong>Plot</strong> ‚Üí <strong>Gerber</strong> (Plot format), here select the necessary layers, in this case: <strong>B.Cu</strong> , <strong>Edge.Cuts</strong> and click <strong>Plot</strong> , then get the file with holes <strong>Generate Drill File</strong> ‚Üí <strong>Drill File</strong> , and close both windows. </p><br><p>  KiCAD has a built-in GerbView viewer. <img src="https://habrastorage.org/getpro/habr/post_images/3b5/a2a/890/3b5a2a890d2efafb7e71a0ec7e5193ab.png" alt="Gerbview">  , you can use it or any friend.  If everything is in order, it remains to select the menu item <strong>File</strong> ‚Üí <strong>Print</strong> to print the board.  Here, select the <strong>B.Cu</strong> layer, uncheck <strong>Print frame ref</strong> and select the size of the labels for the holes.  With full-sized holes, <strong>Real drill</strong> will need to use an awl to mark the center so that the drill does not slide off, and with the small mark <strong>Small mark you have</strong> to drill solder (after tinning) and copper.  If the drill is good, the last option is probably preferable. </p><br><div class="spoiler">  <b class="spoiler_title">Some statistics</b> <div class="spoiler_text"><ul><li>  The first revision is <strong>Real drill</strong> without coreing, a good Dremel 0.8mm drill, blunted about 3/4, finished with a drill 1.0, the result is bad: the holes started in a random place of a circle, some of the pads were torn, the DIP panels were installed with difficulty; </li><li>  second revision - <strong>Real drill</strong> with core, the previous one was reduced to 1.0, it drilled out the entire charge to them, the result is good; </li><li>  the third revision - <strong>Small mark</strong> , drills from an incomprehensible set, the previous 1.0 blunted immediately, then two more for 1.0 and one 0.9, finished with a drill 1.1, the result is good; </li><li>  the fourth revision is <strong>Real drill</strong> with core, drills from another incomprehensible set, 3 drills 1.0 blunted, the result is good, the photo can be viewed below under the spoiler. </li></ul></div></div><br><p>  Now it remains to embody the idea in the "iron".  This process is fascinating, but a lot has been written about it.  Therefore, the photo of the process with its subjective comments hid under the spoiler.  Speech, of course, on LUT. </p><br><div class="spoiler">  <b class="spoiler_title">LUT (Laser-Iron Technology)</b> <div class="spoiler_text"><p>  First, the board should be degreased with acetone or alcohol and clean it with fine sandpaper along and across.  It is desirable to print the drawing on thermal transfer paper. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/716/e30/86c/716e3086c4ba660a79ed2a5d7989ed13.png" alt="Glass fiber"></p><br><p>  It is necessary to transfer the iron heated up to 180 ¬∞ C (three points), usually it is the maximum.  When you touch the iron paper sticks immediately and securely, therefore, holding it enough to stroke with one edge, then boldly over the entire area.  When the smell of burnt paper appears, the process can be stopped; three to five minutes are enough.  Then let the fiberglass cool and peel off the paper. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/acd/b76/4a0/acdb764a007ef227ccd7c71e7b5ae405.png" alt="Translated drawing"></p><br><p>  The boundaries of the printed circuit board, it is desirable to erase, because copper is not needed there.  Acetone is well suited for this, toner is removed in one motion, the main thing is not to hook the tracks. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/713/6c6/2fa/7136c62fa19e7dc5d02c1fd3009de52c.png" alt="Prepared picture"></p><br><p>  The most convenient recipe for copper etching solution: </p><br><ul><li>  100 ml of water; </li><li>  6 tablets of hydroperit; </li><li>  50 g of citric acid; </li><li>  20 g (two teaspoons) of salt. </li></ul><br><p>  Water and hydroponic are equivalent to 100 ml of 3% hydrogen peroxide, but the peroxide has a specific odor, therefore it is better to use hydroponite. </p><br><p>  The solution must be prepared in a special dish, which is subsequently <strong>not allowed to</strong> be used for storage and cooking.  It is better to use glass, but the rules are simple: no metal and easy to clean.  You also need to remember about safety, so that the solution does not get on the skin, eyes, and especially inside. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7e/959/eca/d7e959ecacdc67a4320fd517c6869899.png" alt="Solution fee"></p><br><p>  The process proceeds without odor and special effects.  On the surface of the board bubbles are formed which must be disposed of.  In this case, by shifting the board from the solution, and then back when the bubbles collapse.  It was probably not necessary to heat the solution at 30 ¬∞ C in the room, but I conducted the first experiments at 23 ¬∞ C, which was clearly not enough.  Therefore, this time I also put the tank in a basin with hot tap water. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/962/925/881962925ca20f38ac138b17cafa4bb4.png" alt="Pickling process"></p><br><p>  Bubbles are formed intensively, so you can roll the board without leaving at all, but it‚Äôs quite enough once every 2-3 minutes.  The process must be interrupted when it is obvious that there is no longer any copper.  It usually takes 40-50 minutes.  If the solution has not yet fully worked, bubbles will form as the copper from the side of the toner remains available. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/818/7f2/be0/8187f2be00c935b450057ce0a5621ce4.png" alt="Ready board"></p><br><p>  The spent solution can be poured into domestic sewage.  Toner is easily washed off with acetone. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2f9/fb8/478/2f9fb8478a7bc73045d23f63e864eaa8.png" alt="Fee without toner"></p><br><p>  Now the board needs to be tinned to eliminate possible small cracks and prevent copper oxidation.  The easiest way to do this is to alloy Rose.  To do this, you will need enamelware (will become <strong>unsuitable</strong> for cooking and storing food), some water to cover the board by about 5 mm, a small spoonful of citric acid in water (to remove oxides from copper) and two or three drops of Rosa alloy.  Now you need to heat it all up to a boil, while the Rosa alloy will melt and it can be easily poured onto the board and applied to the tracks with a rubber spatula.  When the alloy is on all tracks, it remains only to remove the excess, sliding them beyond the board.  From three drops usually one remains in the size one and a half to two initial, it can be reused. </p><br><p>  By the way, the dishes should not be aluminum, since citric acid dissolves aluminum oxide, which causes aluminum to actively oxidize, as a result, a lot of garbage and zero visibility are formed in the container. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0a1/c83/f22/0a1c83f2265c4f4786e30dcd7928fa39.png" alt="Charge"></p><br><p>  It is desirable to drill under a thin layer of water so that the drill does not overheat, and then it will be easier to clean. </p><br><p>  <em>(click to enlarge)</em> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/181/b5e/f51/181b5ef51c26c9422a622e09a4dfdefd.png" alt="Board with holes"></a> </p></div></div><br><p>  The result was the following product: </p><br><p>  <em>(click to enlarge)</em> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/546/ac0/005/546ac0005e5ee5c18ca78d048fc9f300.png" alt="Welded product"></a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/183/a12/0e6/183a120e6fdc8370b895a81b636b0be8.png" alt="Installed product"></p><br><a name="wrn_firmware"></a><br><h2 id="programmnoe-obespechenie">  Software </h2><br><p>  The project was developed in C ++ in AtmelStudio, all source codes are available on the GitHub <a href="https://github.com/alexcustos/wrn-project">alexcustos / wrn-project</a> in the <strong>wrn</strong> directory.  Part of the code was borrowed from the Arduino IDE repository and modified to remove all unnecessary and unlink the code from the Arduino core.  For the same purpose, two libraries have been changed, which are necessary for working with a radio module.  Their source code is also available on GitHub as separate projects: </p><br><ul><li>  <a href="https://github.com/alexcustos/RF24">alexcustos / RF24</a> </li><li>  <a href="https://github.com/alexcustos/RF24Network">alexcustos / RF24Network</a> </li></ul><br><p>  The code contains data processing from the sensor, which can be found at the link: <a href="https://habr.com/post/388079/">ATtiny85: prototype of a wireless sensor</a> . </p><br><h3 id="zagruzchik">  Loader </h3><br><p>  To program the device through the serial port, you need a bootloader.  <a href="https://github.com/Optiboot/optiboot">Optiboot</a> is a great option, suitable for Atmel AVR microcontrollers.  It is easy to assemble it with the required parameters, namely, set the clock frequency and data transfer rate for the serial port, and most importantly, specify the port on which it will flash with a LED. </p><br><p>  To flash the bootloader, the device, with the radio module disconnected, needs to be connected via SPI to the programmer.  Then compile and flash your own version of the bootloader, or use the ready-made version just below. </p><br><p>  To compile, you will need a set of programs that can be installed in Ubuntu with the command: </p><br><pre> <code class="bash hljs">sudo apt-get install git gcc-avr binutils-avr gdb-avr avr-libc avrdude</code> </pre> <br><p>  Then run: </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Optiboot/optiboot.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> optiboot/optiboot/bootloaders/optiboot make atmega328_isp AVR_FREQ=20000000L BAUD_RATE=115200 LED=C0 EFUSE=FD HFUSE=DE LFUSE=F7 ISPTOOL=stk500v1 ISPPORT=/dev/ttyACM0</code> </pre> <br><p>  You should pay attention to the output of the last command to make sure that the bootloader was successfully assembled and flashed.  Also closer to the beginning will be the line: </p><br><pre> <code class="html hljs xml">BAUD RATE CHECK: Desired: 115200, Real: 113636, UBRRL = 21, Error=-1.3%</code> </pre> <br><p>  It makes sense to save the <strong>Real</strong> value, the fact is that the firmware process via USB-UART only worked for me at this speed, and through RS232-TTL only on the standard one.  Reducing <strong>Error</strong> to 0.0% does not make sense, since an error of 1-2 percent should not cause problems, but I tried it - it did not help. </p><br><p>  The microcontroller with a clock frequency of 20MHz can work with BAUD_RATE to 250000. The speed had to be reduced due to the RS232-TTL converter, even the ADM202EANZ with the declared speed of 230,000, without errors, it works only on 57600. At a speed of 115200 it appears about once an hour bad byte.  For firmware, this is not critical, since <code>avrdude</code> checks everything that it writes, and you can always try again. </p><br><p>  FUSEs: </p><br><ul><li>  EFUSE = <strong>FD</strong> - reboot when trying to write to the EEPROM when the power supply voltage is below 2.7V, you can specify <strong>FC</strong> (4.3V), but if you debug a device with USB power, then 2.7V is more reliable. </li><li>  HFUSE = <strong>DE</strong> - 512 byte downloader, programming via SPI is allowed; </li><li>  LFUSE = <strong>F7</strong> - external full-swing crystal oscillator with standard delays, differs from the others in that the microcontroller will not reduce the voltage at the output of XTAL2. </li></ul><br><p>  In the settings of the programmer (ISPTOOL, ISPPORT), arduino is indicated as a programmer, which is a good option if something like that gathers dust. </p><br><p>  The bootloader prepared according to the scheme proposed above can be downloaded at the link: <a href="">optiboot_atmega328p_20MHz.hex</a> .  For its firmware, it is enough to install only <code>avrdude</code> and execute the command: </p><br><pre> <code class="bash hljs">avrdude -C/etc/avrdude.conf -v -patmega328p -cstk500v1 -P/dev/ttyACM0 -b19200 \ -e -Ulock:w:0x3F:m -Uefuse:w:0xFD:m -Uhfuse:w:0xDE:m -Ulfuse:w:0xF7:m \ -Uflash:w:<span class="hljs-string"><span class="hljs-string">"optiboot_atmega328p_20MHz.hex"</span></span>:i -Ulock:w:0x2F:m</code> </pre> <br><p>  The first line defines the microcontroller and programmer, followed by the commands run sequentially: chip cleaning, unlocking the bootloader area, flashing FUSEs, booting the firmware, and locking the recording to the bootloader area. </p><br><p>  If everything went well, the LED will flash three times a second, indicating that everything is OK with the Optiboot, but the firmware is not yet loaded. </p><br><h3 id="mikroprogramma">  Firmware </h3><br><p>  In general, the code came out quite a lot, but I hope to deal with it will not be difficult.  Below is a list of features that are worth paying attention to. </p><br><p>  The initialization code of the SPI and serial port requires the definition of F_CPU.  It is better to add it in the compiler options or by directly specifying the <code>-DF_CPU=20000000L</code> switch.  Software clocks also use this definition, but the constants are hard-coded there and require manual recalculation when changing F_CPU. </p><br><p>  The main () function traditionally contains initialization and an infinite loop in which work with the device is performed: </p><br><ul><li>  reset the watchdog timer of the microcontroller; </li><li>  receiving data from the radio module; </li><li>  work with noise generator; </li><li>  work with the system watchdog timer; </li><li>  read commands from the serial port; </li><li>  command processing and sending data via the serial port. </li></ul><br><p>         <code>[C|W|R|N][0-99]:[1]:[2]</code> ,   ,   ,       ‚Äî  ,   .       . </p><br><p>    (struct)   .     ,     ,    .     ,      .   ,      <code>-fpack-struct</code> ,  AtmelStudio     . </p><br><p>        ,     ,         ,   .     ,      .      ,  ‚Äî . </p><br><p>        .       ,    .      ,        . </p><br><p>          ,    EEPROM .              . </p><br><p>                  (uptime).    uptime    .          . </p><br><p>       - ,  ,      ,    .         uint16_t (~12.5 ). </p><br><h3 id="programmnye-chasy">   </h3><br><p>        8  .      RF24/RF24Network,      .      ,     1000   , 64  : <code>20000000 () / 256 (8 ) / 64 () ~= 1220</code> ,      <code>256 * 64 * 1000 / 20000000 = 8192/10000 = 512/625</code> .   TIMER0_OVF         : </p><br><pre> <code class="cpp hljs">m += MILLIS_INC; <span class="hljs-comment"><span class="hljs-comment">// = 0,    ,    ()  f += FRACT_INC; // = 512,    if (f &gt;= FRACT_MAX) { // = 625,       f -= FRACT_MAX; //  m += 1; }</span></span></code> </pre> <br><p> ,            ,   ,        . </p><br><h3 id="generator-istinno-sluchaynyh-chisel">     </h3><br><p> ,       pn ,        pn  -    .                .  ,        . </p><br><p>          ,   ,               . </p><br><p> ,    ,  ,    ,    ,    ,      ,     . </p><br><pre> <code class="cpp hljs">measure = read_measure(); <span class="hljs-comment"><span class="hljs-comment">//   8   10 ( ) num_measures++; //      (  ) // measure_limit &gt; 0     if (num_measures == measure_limit) { balance = false; //     if (pan_left &gt; pan_right) fault = pan_left - pan_right; else fault = pan_right ‚Äî pan_left; //     measure_limit,        acceptable_fault = ((measure_limit - 1) / 256 + 1) * 3; if (fault &gt; acceptable_fault) { //    , //  ,     ,    if (pan_right &gt; pan_left &amp;&amp; threshold &lt; uint8_t(-1)) threshold++; else if (pan_left &gt;= pan_right &amp;&amp; threshold &gt; 0) threshold--; } else balance = true; ... //  pan_left, pan_right, num_measures ( ) ... //      (  ) if (balance &amp;&amp; measure_limit) { //     measure_limit = 0; // ,     return false; //  ,        } } else { //   ,      if (measure &lt;= threshold) pan_left++; else pan_right++; }</span></span></code> </pre> <br><p>  : </p><br><pre> <code class="cpp hljs">byte &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,     num_measures % 8 == 0 if (measure &gt; threshold) byte |= 0b00000001;</span></span></code> </pre> <br><p>    <code>rngtest</code>   rngd      monobit .        ,  ,      ADC  ¬´¬ª,       .     ,    : </p><br><pre> <code class="cpp hljs">byte ^= bit_flip; <span class="hljs-comment"><span class="hljs-comment">// XOR      bit_flip = !bit_flip;</span></span></code> </pre> <br><p>      ,       ,     monobit .            .   636 /         <code>dieharder</code>    .        -    500MB.   ,     .           <code>/dev/urandom</code> .   <code>dieharder</code>     . </p><br><div class="spoiler"> <b class="spoiler_title">rngtest</b> <div class="spoiler_text"><pre>rngtest: bits received from input: 4195417088<font></font>
rngtest: FIPS 140-2 successes: 209549<font></font>
rngtest: FIPS 140-2 failures: 221<font></font>
rngtest: FIPS 140-2(2001-10-10) Monobit: 21<font></font>
rngtest: FIPS 140-2(2001-10-10) Poker: 70<font></font>
rngtest: FIPS 140-2(2001-10-10) Runs: 59<font></font>
rngtest: FIPS 140-2(2001-10-10) Long run: 72<font></font>
rngtest: FIPS 140-2(2001-10-10) Continuous run: 0<font></font>
</pre></div></div><br><div class="spoiler"> <b class="spoiler_title">rngtest (/dev/urandom)</b> <div class="spoiler_text"><pre>rngtest: bits received from input: 4181721088<font></font>
rngtest: FIPS 140-2 successes: 208937<font></font>
rngtest: FIPS 140-2 failures: 149<font></font>
rngtest: FIPS 140-2(2001-10-10) Monobit: 20<font></font>
rngtest: FIPS 140-2(2001-10-10) Poker: 21<font></font>
rngtest: FIPS 140-2(2001-10-10) Runs: 57<font></font>
rngtest: FIPS 140-2(2001-10-10) Long run: 52<font></font>
rngtest: FIPS 140-2(2001-10-10) Continuous run: 0<font></font>
</pre></div></div><br><div class="spoiler"> <b class="spoiler_title">dieharder</b> <div class="spoiler_text"><pre>#=============================================================================#<font></font>
# dieharder version 3.31.1 Copyright 2003 Robert G. Brown #<font></font>
#=============================================================================#<font></font>
   rng_name |rands/second| Seed |<font></font>
stdin_input_raw| 1.99e+07 | 871678203|<font></font>
#=============================================================================#<font></font>
             test_name |ntup| tsamples |psamples| p-value |Assessment<font></font>
#=============================================================================#<font></font>
  0: diehard_birthdays| 0| 100| 100|0.23013568| PASSED<font></font>
  1: diehard_operm5| 0| 1000000| 100|0.41464749| PASSED<font></font>
  3: diehard_rank_6x8| 0| 100000| 100|0.83194246| PASSED<font></font>
  4: diehard_bitstream| 0| 2097152| 100|0.98469009| PASSED<font></font>
  7: diehard_dna| 0| 2097152| 100|0.82184561| PASSED<font></font>
  8: diehard_count_1s_str| 0| 256000| 100|0.63516902| PASSED<font></font>
 10: diehard_parking_lot| 0| 12000| 100|0.15579947| PASSED<font></font>
 11: diehard_2dsphere| 2| 8000| 100|0.94799044| PASSED<font></font>
 12: diehard_3dsphere| 3| 4000| 100|0.16755480| PASSED<font></font>
 14: diehard_sums| 0| 100| 100|0.00420819| WEAK<font></font>
 15: diehard_runs| 0| 100000| 100|0.58812798| PASSED<font></font>
 15: diehard_runs| 0| 100000| 100|0.23381862| PASSED<font></font>
100: sts_monobit| 1| 100000| 100|0.11747720| PASSED<font></font>
101: sts_runs| 2| 100000| 100|0.12598371| PASSED<font></font>
102: sts_serial| 1| 100000| 100|0.11747720| PASSED<font></font>
102: sts_serial| 2| 100000| 100|0.98806196| PASSED<font></font>
102: sts_serial| 3| 100000| 100|0.93420112| PASSED<font></font>
102: sts_serial| 3| 100000| 100|0.88625906| PASSED<font></font>
102: sts_serial| 4| 100000| 100|0.81837353| PASSED<font></font>
102: sts_serial| 4| 100000| 100|0.44680983| PASSED<font></font>
102: sts_serial| 5| 100000| 100|0.30069422| PASSED<font></font>
102: sts_serial| 5| 100000| 100|0.59918415| PASSED<font></font>
102: sts_serial| 6| 100000| 100|0.94111872| PASSED<font></font>
102: sts_serial| 6| 100000| 100|0.97775411| PASSED<font></font>
102: sts_serial| 7| 100000| 100|0.71034876| PASSED<font></font>
102: sts_serial| 7| 100000| 100|0.37205549| PASSED<font></font>
102: sts_serial| 8| 100000| 100|0.62281679| PASSED<font></font>
102: sts_serial| 8| 100000| 100|0.61865217| PASSED<font></font>
102: sts_serial| 9| 100000| 100|0.12357283| PASSED<font></font>
102: sts_serial| 9| 100000| 100|0.62028539| PASSED<font></font>
102: sts_serial| 10| 100000| 100|0.70302730| PASSED<font></font>
102: sts_serial| 10| 100000| 100|0.36150774| PASSED<font></font>
102: sts_serial| 11| 100000| 100|0.02416524| PASSED<font></font>
102: sts_serial| 11| 100000| 100|0.00210157| WEAK<font></font>
102: sts_serial| 12| 100000| 100|0.15545193| PASSED<font></font>
102: sts_serial| 12| 100000| 100|0.25167693| PASSED<font></font>
102: sts_serial| 13| 100000| 100|0.19659046| PASSED<font></font>
102: sts_serial| 13| 100000| 100|0.56538654| PASSED<font></font>
102: sts_serial| 14| 100000| 100|0.15529368| PASSED<font></font>
102: sts_serial| 14| 100000| 100|0.99005364| PASSED<font></font>
102: sts_serial| 15| 100000| 100|0.15517199| PASSED<font></font>
102: sts_serial| 15| 100000| 100|0.91135159| PASSED<font></font>
102: sts_serial| 16| 100000| 100|0.70484328| PASSED<font></font>
102: sts_serial| 16| 100000| 100|0.71149544| PASSED<font></font>
201: rgb_minimum_distance| 0| 10000| 1000|0.00000000| FAILED<font></font>
202: rgb_permutations| 5| 100000| 100|0.72724154| PASSED<font></font>
203: rgb_lagged_sum| 0| 1000000| 100|0.79186771| PASSED<font></font>
204: rgb_kstest_test| 0| 10000| 1000|0.46365770| PASSED<font></font>
206: dab_dct| 256| 50000| 1|0.53224869| PASSED<font></font>
207: dab_filltree| 32| 15000000| 1|0.87205525| PASSED<font></font>
207: dab_filltree| 32| 15000000| 1|0.28341671| PASSED<font></font>
208: dab_filltree2| 0| 5000000| 1|0.69766563| PASSED<font></font>
208: dab_filltree2| 1| 5000000| 1|0.68877816| PASSED<font></font>
209: dab_monobit2| 12| 65000000| 1|0.99154840| PASSED<font></font>
</pre></div></div><br><div class="spoiler"> <b class="spoiler_title">dieharder (/dev/urandom)</b> <div class="spoiler_text"><pre>#=============================================================================#<font></font>
# dieharder version 3.31.1 Copyright 2003 Robert G. Brown #<font></font>
#=============================================================================#<font></font>
   rng_name |rands/second| Seed |<font></font>
stdin_input_raw| 2.09e+07 |2043744116|<font></font>
#=============================================================================#<font></font>
             test_name |ntup| tsamples |psamples| p-value |Assessment<font></font>
#=============================================================================#<font></font>
  0: diehard_birthdays| 0| 100| 100|0.04140546| PASSED<font></font>
  1: diehard_operm5| 0| 1000000| 100|0.37860771| PASSED<font></font>
  3: diehard_rank_6x8| 0| 100000| 100|0.51810908| PASSED<font></font>
  4: diehard_bitstream| 0| 2097152| 100|0.87265669| PASSED<font></font>
  7: diehard_dna| 0| 2097152| 100|0.28188785| PASSED<font></font>
  8: diehard_count_1s_str| 0| 256000| 100|0.01571303| PASSED<font></font>
 10: diehard_parking_lot| 0| 12000| 100|0.27155245| PASSED<font></font>
 11: diehard_2dsphere| 2| 8000| 100|0.56675436| PASSED<font></font>
 12: diehard_3dsphere| 3| 4000| 100|0.95480977| PASSED<font></font>
 14: diehard_sums| 0| 100| 100|0.00076186| WEAK<font></font>
 15: diehard_runs| 0| 100000| 100|0.62119123| PASSED<font></font>
 15: diehard_runs| 0| 100000| 100|0.79241488| PASSED<font></font>
100: sts_monobit| 1| 100000| 100|0.76618520| PASSED<font></font>
101: sts_runs| 2| 100000| 100|0.89128426| PASSED<font></font>
102: sts_serial| 1| 100000| 100|0.76618520| PASSED<font></font>
102: sts_serial| 2| 100000| 100|0.51804588| PASSED<font></font>
102: sts_serial| 3| 100000| 100|0.54076681| PASSED<font></font>
102: sts_serial| 3| 100000| 100|0.51414389| PASSED<font></font>
102: sts_serial| 4| 100000| 100|0.18600760| PASSED<font></font>
102: sts_serial| 4| 100000| 100|0.22984905| PASSED<font></font>
102: sts_serial| 5| 100000| 100|0.25883020| PASSED<font></font>
102: sts_serial| 5| 100000| 100|0.99315299| PASSED<font></font>
102: sts_serial| 6| 100000| 100|0.40048642| PASSED<font></font>
102: sts_serial| 6| 100000| 100|0.73022511| PASSED<font></font>
102: sts_serial| 7| 100000| 100|0.79035813| PASSED<font></font>
102: sts_serial| 7| 100000| 100|0.91930371| PASSED<font></font>
102: sts_serial| 8| 100000| 100|0.51635740| PASSED<font></font>
102: sts_serial| 8| 100000| 100|0.87010763| PASSED<font></font>
102: sts_serial| 9| 100000| 100|0.95493347| PASSED<font></font>
102: sts_serial| 9| 100000| 100|0.15935465| PASSED<font></font>
102: sts_serial| 10| 100000| 100|0.32276697| PASSED<font></font>
102: sts_serial| 10| 100000| 100|0.67645664| PASSED<font></font>
102: sts_serial| 11| 100000| 100|0.64714937| PASSED<font></font>
102: sts_serial| 11| 100000| 100|0.83931114| PASSED<font></font>
102: sts_serial| 12| 100000| 100|0.98898429| PASSED<font></font>
102: sts_serial| 12| 100000| 100|0.98306183| PASSED<font></font>
102: sts_serial| 13| 100000| 100|0.73353342| PASSED<font></font>
102: sts_serial| 13| 100000| 100|0.75717141| PASSED<font></font>
102: sts_serial| 14| 100000| 100|0.18283051| PASSED<font></font>
102: sts_serial| 14| 100000| 100|0.52874060| PASSED<font></font>
102: sts_serial| 15| 100000| 100|0.35740156| PASSED<font></font>
102: sts_serial| 15| 100000| 100|0.83391413| PASSED<font></font>
102: sts_serial| 16| 100000| 100|0.61391208| PASSED<font></font>
102: sts_serial| 16| 100000| 100|0.83537094| PASSED<font></font>
201: rgb_minimum_distance| 0| 10000| 1000|0.00000000| FAILED<font></font>
202: rgb_permutations| 5| 100000| 100|0.85828591| PASSED<font></font>
203: rgb_lagged_sum| 0| 1000000| 100|0.84986413| PASSED<font></font>
204: rgb_kstest_test| 0| 10000| 1000|0.25942548| PASSED<font></font>
206: dab_dct| 256| 50000| 1|0.62442278| PASSED<font></font>
207: dab_filltree| 32| 15000000| 1|0.39920277| PASSED<font></font>
207: dab_filltree| 32| 15000000| 1|0.57982406| PASSED<font></font>
208: dab_filltree2| 0| 5000000| 1|0.90094772| PASSED<font></font>
208: dab_filltree2| 1| 5000000| 1|0.58950861| PASSED<font></font>
209: dab_monobit2| 12| 65000000| 1|0.94848945| PASSED<font></font>
</pre></div></div><br><p>    201  - ,    .    : </p><br><pre> <code class="bash hljs">cat /dev/urandom | dieharder -g 200 -d 201</code> </pre> <br><p>     ,     : </p><br><pre> <code class="bash hljs">cat /dev/urandom | dieharder -g 200 -a</code> </pre> <br><p>   : </p><br><pre>rgb_minimum_distance| 2| 10000| 1000|0.20617106| PASSED<font></font>
rgb_minimum_distance| 3| 10000| 1000|0.00275459| WEAK<font></font>
rgb_minimum_distance| 4| 10000| 1000|0.47683577| PASSED<font></font>
rgb_minimum_distance| 5| 10000| 1000|0.92418653| PASSED<font></font>
</pre><br><p>   dieharder,   p-value ( <a href="https://ru.wikipedia.org/wiki/P-%25D0%25B7%25D0%25BD%25D0%25B0%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">P-</a> ).     ,       [0, 1]     .   ‚â§ 0.01  ‚â• 0.99    1% ,    [0.3, 0.4)  10%    .       0  1,         . </p><br><p>         FIPS  ,     ( 1:1250),     ,   <code>rngd</code>     .     ,     ,   ,  ,  ,        . </p><br><p> <strong>Updated:</strong>          1324 /,      : </p><br><div class="spoiler"> <b class="spoiler_title">rngtest ( )</b> <div class="spoiler_text"><pre>rngtest: bits received from input: 724458496<font></font>
rngtest: FIPS 140-2 successes: 36199<font></font>
rngtest: FIPS 140-2 failures: 23<font></font>
rngtest: FIPS 140-2(2001-10-10) Monobit: 2<font></font>
rngtest: FIPS 140-2(2001-10-10) Poker: 2<font></font>
rngtest: FIPS 140-2(2001-10-10) Runs: 10<font></font>
rngtest: FIPS 140-2(2001-10-10) Long run: 9<font></font>
rngtest: FIPS 140-2(2001-10-10) Continuous run: 0<font></font>
</pre></div></div><br><p>        ,      .        (acceptable_fault).     ,         (threshold),   ,       threshold.       . </p><br><p>     AtmelStudio   <strong>Tools</strong> ‚Üí <strong>External Tools...</strong> : </p><br><pre> <code class="html hljs xml">Title: Deploy Command: D:\UTILS\avrdude\avrdude.exe Arguments: -CD:\UTILS\avrdude\avrdude.conf -v -patmega328p -carduino -PCOM5 -b113636 -D -Uflash:w:"$(BinDir)\$(TargetName).hex":i Use Output window ()</code> </pre> <br><p>        USB-UART .     113636,       .    ,     $(BinDir),       ,     ,       <strong>wrn</strong> . </p><br><p>   ,    : <a href="">wrn_atmega328p_20MHz.hex</a> .    USB-UART  Linux       : </p><br><pre> <code class="bash hljs">avrdude -C/etc/avrdude.conf -v -patmega328p -carduino -P/dev/ttyUSB0 -b113636 -D -Uflash:w:<span class="hljs-string"><span class="hljs-string">"wrn_atmega328p_20MHz.hex"</span></span>:i</code> </pre> <br><p>  ,    RS232,     , ,    ,  DTR  : </p><br><pre> <code class="bash hljs">wrnctrl flash wrn_atmega328p_20MHz.hex</code> </pre> <br><p>     Linux    ,    Habrahabr  : <a href="https://habr.com/post/300968/"> 2 ()</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/394261/">https://habr.com/ru/post/394261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../394249/index.html">Coinbase announces support for Ethereum</a></li>
<li><a href="../394251/index.html">Dell XPS 12: When not to choose between a laptop and a tablet</a></li>
<li><a href="../394253/index.html">Files transferred via Skype will be synchronized with all devices of the user.</a></li>
<li><a href="../394255/index.html">The scientific explanation of why you can not catch a dollar bill with two fingers</a></li>
<li><a href="../394257/index.html">64% of Europeans support the idea of ‚Äã‚Äãunconditional basic income</a></li>
<li><a href="../394263/index.html">Delete or not delete groups in the VC? .. That is the question</a></li>
<li><a href="../394265/index.html">Programming is the language between people and machines that everyone should own.</a></li>
<li><a href="../394267/index.html">Online sales in the B2B sector</a></li>
<li><a href="../394269/index.html">Roskomnadzor proposes to fine for poor-quality wiretapping and incomplete recording of telephone conversations of Russians</a></li>
<li><a href="../394271/index.html">Gadgets to simplify the rest in the country and outside the city</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>