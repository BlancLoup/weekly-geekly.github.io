<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Superscalar stack processor: details</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation of a series of articles that analyze the idea of ‚Äã‚Äãa superscalar processor with OoO and a stack machine front end 
 The topic of this art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Superscalar stack processor: details</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2cc/ee4/857/2ccee4857e1f496cb6a8e92a510593cf.jpg"><br><br>  Continuation of a series of articles that analyze the idea of ‚Äã‚Äãa <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">superscalar</a> processor with <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">OoO</a> and a stack machine <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">front end</a> <br>  The topic of this article is function call, inside view. <br><a name="habracut"></a><br>  Previous articles: <br>  <a href="https://habrahabr.ru/post/278575/">1</a> - description of work on a linear piece <br>  <a href="https://habrahabr.ru/post/279123/">2</a> - function call, save registers <br><br>  By focusing in the last article on the outside of the function call, we lost sight of how it would all be executed inside.  The author does not consider himself a specialist in hardware, but he still foresees problems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We mentioned that after returning from a function, I want to get the processor in the same state as before.  And it is precisely for this that they preserved the state of the registers.  But the state of the processor is not only registers.  but also queues of mopov, condition of conveyors ... <br><br>  Imagine a situation where at the time of a function call we have: <br><ul><li>  some number of mops in the decoder stack </li><li>  mops removed by the decoder from the stack but waiting for the parent mop to be executed </li><li>  mops on the performance in conveyors </li></ul><br>  As a result, it is impossible to just start the execution of a new function because <br><ul><li>  for this, it may be trite not enough mops - those that remain from the parent function will not be released until we return from this </li><li>  The stack of mop indexes in the decoder has a fixed depth and can easily overflow during recursion or just a long chain of calls. </li><li>  mops in pipelines will be executed after (after calling a new function) the numbering of registers changes </li></ul><br><br>  It may seem that we have taken certain measures to avoid the problems described when declaring a function call with a generalized instruction, which must wait for the call to calculate all its arguments. <br><br>  However, there is a problem with the fact that the decoder will have time to process the code after calling the function, if it is independent of the data.  For example: <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; ‚Ä¶ i = foo (i + <span class="hljs-number"><span class="hljs-number">1</span></span>); j += k; bar (i, j);</code> </pre> <br>  After returning from foo, we cannot rely on the fact that j managed to be calculated and saved (and then restored) in the context of the current task, nor on the fact that the mops survived from j + = k;  if she did not have time to calculate. <br><br>  Suppose, after seeing the function call, the decoder stops its operation until it returns from this function.  Then how to deal with this situation: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; ‚Ä¶ bar (foo (i + <span class="hljs-number"><span class="hljs-number">1</span></span>), j += k);</code> </pre><br>  One decoder is not enough.  It seems that after returning from a function, you simply need to start decoding and executing further code again. <br><br>  But after all, basically, these problems caused by superscalarity are not unique to our architecture, you may not need to reinvent the wheel, but it‚Äôs worth seeing how it has already been solved before. <br><br>  Ok, let's take a look at Intel's <a href="http://www.ixbt.com/cpu/sandy-bridge-1.shtml">Sandy Bridge</a> (thanks to <a href="http://forum.ixbt.com/users.cgi%3Fid%3Dinfo:Felid">Takit Murka aka Felid</a> ) <br>  and also <a href="http://www.realworldtech.com/sandy-bridge">here</a> <br><br><h3>  Sandy Bridge. </h3><br><img src="https://habrastorage.org/files/ba0/38d/52f/ba038d52f18c42788bf51a4a5b8a2fa9.png"><br>  Presumably, the Sandy Bridge frontend, <br><br><ul><li>  executable code enters the precoder buffer (in the upper left corner of the circuit) from the instruction cache of the first level (L1I) </li><li>  Precoder can process up to 7 instructions per clock, depending on their total length and complexity </li><li>  marked commands fall into one of two command queues (IQ) - one for each thread (hyperthreading), for 20 teams each </li><li>  <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">the decoder</a> alternately reads the commands from the queues and translates them into mops </li><li>  depending on the type of command, the decoder uses different types of translators </li><li>  the decoding result goes to <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">the mop cache</a> and two hyperthreading <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">buffers</a> </li><li>  the aligned pieces (portions) of 32 bytes of the source code are cached, while: <br><ul><li>  the key is the entry point in the portion, if there were transitions to different places in one portion, this portion will be multiplied in the cache </li><li>  portion decoding starts at its entry point </li><li>  only portions that spawn no more than 18 mop are cached - 3 lines of 6 mop each </li><li>  the instruction, divided by the boundary of two portions, refers to the first of them </li><li>  from the portion it is allowed to have no more than 6 transitions, only one of them can be unconditional - and the last at the same time.  <b>This is important</b> because  a function call is an unconditional transition and everything that happens after it does not fall into the current caching unit, and therefore will not be executed until we try to go back. </li><li>  if the portion does not end with an unconditional transition, a transition occurs to the first instruction of the next section address </li><li>  The mop cache (L0m) is synchronized with L1I, the last cache line is 64 bytes, so that when you push out the L1I line, everything related to two portions is deleted from L0m </li><li>  just curious, L1I works with physical addresses, L0m - with virtual </li></ul></li><li>  As for speculative execution: <br><ul><li>  <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">The predictor of transitions</a> (BPU) is able for a conditional transition mop to report the probability of the occurrence of an event of this transition </li><li>  because  in the current queue of mops, the decoder has already identified all potential transitions, you can check them </li><li>  if the transition probability is high enough, it makes sense to preload the necessary portion of code in advance and execute it speculatively </li><li>  if the transition really happens, we will get at least a decoded piece of data, perhaps part of the instructions (which have no data dependencies) will have time to complete </li><li>  if there is no transition, instructions that have not yet been completed should be removed from execution, those that have managed to work out should not have irreparable consequences.  All captured resources are released. </li><li>  so, they will be executed in a special speculative mode: <br><ul><li>  memory should be deferred </li><li>  reading from memory is performed only if data is already in the data cache, otherwise execution is blocked (in order to avoid useless cache misses and subsequent access to the swap) </li><li>  everything that can cause an exception (division by 0, for example) is marked accordingly and is also blocked, however, this is a generalization of the previous paragraph.  Now, when the transition occurs, we can honestly restart the blocked mops </li><li>  <i>and, of course, it is worth recalling that all this is only speculation, only Intel knows the real picture</i> </li></ul></li></ul></li></ul><br>  How does the function call occur? <br>  Let us examine the following example. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k, l, m, n; ... i = <span class="hljs-number"><span class="hljs-number">1</span></span> + foo (<span class="hljs-number"><span class="hljs-number">1</span></span> + bar (<span class="hljs-number"><span class="hljs-number">1</span></span> + biz (<span class="hljs-number"><span class="hljs-number">1</span></span> + baz (<span class="hljs-number"><span class="hljs-number">1</span></span> + j) + k) + l) + m) + n;</code> </pre><br>  We will naively assume that all this code will be located in one 32 byte chunk and the order of code generation (with the optimizer disabled) will correspond to the order of the text.  Mark the code according to which instance of the section it will be in the L0m cache: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k, l, m, n; ... <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; i = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; foo ( <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; bar ( <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; biz ( <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; baz (<span class="hljs-number"><span class="hljs-number">1</span></span> + j) <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; + k) <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; + l) <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; + m) <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; + n;</code> </pre>  This fragment seems to take 5 cache lines out of 256 available. <br>  It is not surprising that the compiler tries its best to inline small functions. <br><br><h3>  findings </h3><br>  So, we looked at how functions are called in one of the highly sophisticated micro-architectures, what benefits can we derive from this? <br><br>  Select the objective points: <br><ul><li>  The instruction cache is needed; without this, no intelligible processor is possible. </li><li>  The cache has a granularity, at the moment the typical size is a string of 64 bytes. </li><li>  Decoding (for x86_64, at least) is a rather expensive operation, it makes sense to cache the decoded code as strings of mops </li><li>  Access by entry point is a great idea if it is possible to do without reproduction of records at the same time - the question of implementation </li><li>  No more than one mandatory exit - a simple and natural solution, eliminating a lot of problems </li></ul><br>  It may seem that all this will work for our architecture with a stack frontend.  But there is a nuance. <br>  Let's explain with an example.  Here <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2590%25D0%25BA%25D0%25BA%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">is Ackermann</a> 's <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2590%25D0%25BA%25D0%25BA%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">function</a> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a(m - <span class="hljs-number"><span class="hljs-number">1</span></span>, a(m, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre>  It looks simple, but it demonstrates the wonders of recursion.  The following graph shows the dynamics of the nesting depth for the call to a (3, 5), the x number is the step number, and the y number is the call depth. <br><img src="https://habrastorage.org/files/ad0/94d/495/ad094d49527f48e79a2364b586c81bab.png"><br>  Since we decided to consider the function call as a generalized instruction with an arbitrary number of parameters, in the case of m * n! = 0, the first argument (m-1) will remain on the stack of the mops, while the second argument will be calculated: a (m, n- one).  Well, if the first argument has time to be calculated and its value will be saved when called in the register stack.  But it may happen that the expression for the first argument will be evaluated longer than the arguments of the child call in the second argument.  And then we will hang in considerable quantities incomplete mops. <br>  The parent call mop will also wait until the child call is completed.  Call depth can easily reach (tens) thousands of units, for example, SandyBrige simply doesn‚Äôt have as many mops. <br><br>  The essence of the problem is that, recognizing the call as a generalized instruction, we thereby recognized the program as a generalized expression.  And the tree of this expression, due to recursion, can be of any height.  On the other hand, the expression stack is limited.  And the elements of the stack are the indexes of the mops, of which there is also a limited number. <br><br>  But we are not accustomed to surrender so easily, that‚Äôs why B.‚Äôs plan comes into play. <br><br><h3>  Plan b </h3><br>  Register superscalar processors have no such problems.  Identification of connections between mopami occurs later - at the stage of renaming registers. <br>  We have these links are stored in the stack of indexes mopov. <br><br>  Maybe save the stack state?  To keep the mop indexes a little, as we found out, the mops themselves also need our care.  It seems natural to organize the preservation of mops through a stack, allocated or not, the question is completely separate. <br><br>  And here we are faced with the same problems that we encountered when trying to save registers.  Namely, with a single (for all functions) identification of mops: <br><ul><li>  order of use of mops depends on the history of calls </li><li>  inside the function it is determined dynamically </li><li>  there are no guarantees that after the FILL operation we will not get a conflict with the already occupied mop </li></ul><br>  The way to solve these problems is the same: <br><ul><li>  mop ring buffer </li><li>  for each function its own numbering of mops, for example, 0 ... </li><li>  FILL and SPILL are made for the whole function, which allows, if necessary, to bind the stack of registers and the stack of mops to one memory area. </li><li>  FILL and SPILL are done only for mops waiting to be completed, therefore, a mask (or enumeration) of serialized mops fits into the stack. </li><li>  stack of mop indexes we also need to save </li></ul><br>  At first glance, the need to drive decoded mops through memory seems monstrous.  But when the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2582%25D0%25B5%25D1%2585%25D0%25BE%25D0%25BB%25D0%25B0%25D0%25BC%25D0%25B8%25D0%25BD%25D1%258B">catecholamines</a> burn out, it becomes clear that the scale of the disaster is not so great. <br><ol><li>  although in modern processors, the parameters (at least part of them) are passed through registers, when recursively calling, the parameters are saved and there is no place except on the stack, besides: <br><ul><li>  return address and frame pointer are also saved in the stack </li><li>  <a href="https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx">volatile registers</a> are stored on the stack by the caller. </li><li>  <a href="https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx">non-volatile registers are</a> also stored in the stack, but by the called party </li></ul></li><li>  expressions like 'a (m - 1, a (m, n - 1))' the compiler can break up by introducing (explicitly or indirectly) a temporary variable equal to a (m, n - 1).  This reduces the number of mops that need to be saved. </li><li>  all the failed conditional branches at the time of the unconditional transition, which is a function call, we have already thrown out </li><li>  we can also throw out all the mops for the upcoming call or simply do not load them using a technique similar to that in SandyBridge </li><li>  and we can leave, then upon returning from the function, we get a bonus ready for execution or already even partially executed (data independent) code </li><li>  in the most "economical" version, only one serialized mop call will fall onto the stack, and this is not much different from passing the frame-fuffer address, for example </li><li>  (de) serialization of mops does not look like a costly operation, moreover, it can be done in the background, in advance, without blocking the current return from the function </li><li>  storing mops on the stack along with loading is supposed to be an alternative to the l0m cache, which is no longer needed </li><li>  the size of the serialized mop is not too large, for SandyBridge the initial size of the mop <a href="http://www.ixbt.com/cpu/sandy-bridge-1.shtml">is estimated to be a</a> maximum of 147 bits, compressed - 85 bits (and there are also x87, SSE and AVX of all stripes) </li><li>  the fact that the processor‚Äôs technological features are accessible from the outside and any technical secrets can be compromised, doesn‚Äôt scare the author.  In the end, let the processor xor'it this data with a one-time notebook. </li></ol><br><br><h3>  What's next </h3><br>  Until now, we have not paid attention to the weak point of all stack machines ‚Äî redundant memory accesses. <br>  Here we will deal with them in the <a href="https://habrahabr.ru/post/281352/">next article</a> . </div><p>Source: <a href="https://habr.com/ru/post/280087/">https://habr.com/ru/post/280087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280077/index.html">Oracle SPARC T7 and M7 Servers - A New Platform for Secure Computing</a></li>
<li><a href="../280079/index.html">Time to learn: Digest of free educational materials from Mail.Ru Group</a></li>
<li><a href="../280081/index.html">Sorting tables in Cach√© DBMS</a></li>
<li><a href="../280083/index.html">Microservices. How to do and when to apply?</a></li>
<li><a href="../280085/index.html">Windows Trojan specializes in stealing data from isolated air-gapped computers</a></li>
<li><a href="../280089/index.html">Conference DUMP-2016: Review of the Web-design section</a></li>
<li><a href="../280091/index.html">Who are the most famous hackers in history?</a></li>
<li><a href="../280093/index.html">25 questions asked during an interview with Linux system administrators</a></li>
<li><a href="../280095/index.html">Emulate and intercept SIM commands via the SIM Toolkit on Android 5.1 and below (CVE-2015-3843)</a></li>
<li><a href="../280097/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 32. The Mall</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>