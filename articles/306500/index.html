<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elixir: Registering Processes - A Practical Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Processes in Elixir (and of course Erlang ) are identified using a unique process identifier - pid . 
 We use them to interact with processes. Message...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elixir: Registering Processes - A Practical Guide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a58/a0f/0dd/a58a0f0dd4074fccbc36f4aed8d9201d.jpg" align="left"><br><p> Processes in <code>Elixir</code> (and of course <code>Erlang</code> ) are identified using a <em>unique process identifier</em> - <strong>pid</strong> . <br>  We use them to interact with processes.  Messages are sent as if <em>to the</em> <code>pid</code> , and the virtual machine itself takes care of delivering these messages to the correct process. <br>  Sometimes, however, excessive confidence in the <code>pid</code> can lead to significant problems. <br>  For example, we can store the <code>pid</code> already dead process, or we can use the <code>Supervisor</code> , which abstracts the creation of processes from us, so we don‚Äôt even know what their <code>pid</code> ( <em>per</em> : and <code>Supervisor</code> can restart the fallen process with another <code>pid</code> , and we this will not know in any way). <br>  Let's create a simple application and see: what problems we may face and how we will solve these problems. </p><a name="habracut"></a><br><h3>  We start without any registry </h3><br><p>  For the first example, let's create a simple chat.  Let's start by creating a <code>mix</code> project: </p><br><pre> <code class="bash hljs">$ mix new chat</code> </pre> <br><p>  Let's create an absolutely standard <code>GenServer</code> , which we will use throughout all the examples in this article: </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/server.ex defmodule Chat.Server do use GenServer # API def start_link do GenServer.start_link(__MODULE__, []) end def add_message(pid, message) do GenServer.cast(pid, {:add_message, message}) end def get_messages(pid) do GenServer.call(pid, :get_messages) end # SERVER def init(messages) do {:ok, messages} end def handle_cast({:add_message, new_message}, messages) do {:noreply, [new_message | messages]} end def handle_call(:get_messages, _from, messages) do {:reply, messages, messages} end end</span></span></code> </pre> <br><blockquote>  If this code seems unfamiliar or incomprehensible to you, read the beginning of working with <code>Elixir</code> , which has <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html">excellent</a> OTP <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html">paragraphs</a> . </blockquote><br><p>  <code>iex</code> session with the <code>mix</code> environment and try to work with our server: </p><br><pre> <code class="bash hljs">$ iex -S mix iex&gt; {:ok, pid} = Chat.Server.start_link {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.107.0&gt;} iex&gt; Chat.Server.add_message(pid, "foo") :ok iex&gt; Chat.Server.add_message(pid, "bar") :ok iex&gt; Chat.Server.get_messages(pid) ["bar", "foo"]</span></span></code> </pre> <br><blockquote>  The code for this stage is in this <a href="https://github.com/brianstorti/elixir-registry-example-chat-app/commit/125113ef7f88bb5a4148557b8d64cbb41d426e0a">commit.</a> </blockquote><br><p>  At this stage, everything seems to be so good, which is just wonderful.  We get the <code>pid</code> process, then for each message we want to send ( <code>add_message/2</code> and <code>get_messages/1</code> ) we pass this <code>pid</code> - and everything works so predictably that it‚Äôs even boring. <br>  However, the fun begins when we try to add the <code>Supervisor</code> ... </p><br><h3>  Very nice: I am <strong><code>Supervisor</code></strong> ! </h3><br><p>  So for some reason our <code>Chat.Server</code> process <code>Chat.Server</code> dying.  We are left alone in an empty and cold <code>iex</code> session, and we have no choice but to start a new process, get its <code>pid</code> and write messages to this new <code>pid</code> .  So let's create a <code>Supervisor</code> - and we will not have to worry about such trifles! </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/supervisor.ex defmodule Chat.Supervisor do use Supervisor def start_link do Supervisor.start_link(__MODULE__, []) end def init(_) do children = [ worker(Chat.Server, []) ] supervise(children, strategy: :one_for_one) end end</span></span></code> </pre> <br><p>  Well, creating a <code>Supervisor</code> is easy.  But we now have a problem if the behavior model of our server does not change.  After all, we do not start the <code>Chat.Server</code> process ourselves, the <code>Supervisor</code> does it for us.  And so we have no access to the <code>pid</code> process! </p><br><p>  This is not a bug, but a feature of such an <code>OTP</code> pattern as <code>Supervisor</code> .  We cannot access the <code>pid</code> its child processes, because it can unexpectedly (but, of course, only if necessary) restart the process, and in fact kill it and create a new one with a new <code>pid</code> . </p><br><h3>  Register process names </h3><br><p>  To access our <code>Chat.Server</code> process <code>Chat.Server</code> we need to think of a way to point to the process, the other is not a <code>pid</code> .  we need such a pointer so that it is saved even when the process is restarted through the <code>Supervisor</code> ( <em>trans</em> : that is, even when the <code>pid</code> changes). <br>  And this pointer is called the <code></code> ! </p><br><p>  To begin, change <code>Chat.Server</code> : </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/server.ex defmodule Chat.Server do use GenServer def start_link do # We now start the GenServer with a `name` option. GenServer.start_link(__MODULE__, [], name: :chat_room) end # And our function doesn't need to receive the pid anymore, # as we can reference the process with its unique name. def add_message(message) do GenServer.cast(:chat_room, {:add_message, message}) end def get_messages do GenServer.call(:chat_room, :get_messages) end # ... end</span></span></code> </pre> <br><blockquote>  The changes are in this <a href="https://github.com/brianstorti/elixir-registry-example-chat-app/commit/c728238ca05bd22d066f0eb7d3969a1d1987f7f5">commit.</a> </blockquote><br><p>  Now everything should work the same, but only better - after all, we should not transmit this <code>pid</code> everywhere: </p><br><pre> <code class="bash hljs">$ iex -S mix iex&gt; Chat.Supervisor.start_link {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.94.0&gt;} iex&gt; Chat.Server.add_message("foo") :ok iex&gt; Chat.Server.add_message("bar") :ok iex&gt; Chat.Server.get_messages ["bar", "foo"]</span></span></code> </pre> <br><p>  Even if the process restarts, we will still be able to access it in the same way: </p><br><pre> <code class="bash hljs">iex&gt; Process.whereis(:chat_room) <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.111.0&gt; iex&gt; Process.whereis(:chat_room) |&gt; Process.exit(:kill) true iex&gt; Process.whereis(:chat_room) #PID&lt;0.114.0&gt; iex&gt; Chat.Server.add_message "foo" :ok iex&gt; Chat.Server.get_messages ["foo"]</span></span></code> </pre> <br><p>  Well, for our current tasks, the problems seem to be solved, but let's try to do something more complicated (and more approximate to real problems). </p><br><h3>  Dynamic process creation </h3><br><p>  Imagine that we need to maintain multiple chat rooms.  The client can create a new room with the name, and he expects to be able to send messages to the room he wants.  Then the interface should be approximately like this: </p><br><pre> <code class="bash hljs">iex&gt; Chat.Supervisor.start_room(<span class="hljs-string"><span class="hljs-string">"first room"</span></span>) iex&gt; Chat.Supervisor.start_room(<span class="hljs-string"><span class="hljs-string">"second room"</span></span>) iex&gt; Chat.Server.add_message(<span class="hljs-string"><span class="hljs-string">"first room"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>) iex&gt; Chat.Server.add_message(<span class="hljs-string"><span class="hljs-string">"second room"</span></span>, <span class="hljs-string"><span class="hljs-string">"bar"</span></span>) iex&gt; Chat.Server.get_messages(<span class="hljs-string"><span class="hljs-string">"first room"</span></span>) [<span class="hljs-string"><span class="hljs-string">"foo"</span></span>] iex&gt; Chat.Server.get_messages(<span class="hljs-string"><span class="hljs-string">"second room"</span></span>) [<span class="hljs-string"><span class="hljs-string">"bar"</span></span>]</code> </pre> <br><p>  Let's start from above, and change <code>Supervisor</code> to support all this: </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/supervisor.ex defmodule Chat.Supervisor do use Supervisor def start_link do # We are now registering our supervisor process with a name # so we can reference it in the `start_room/1` function Supervisor.start_link(__MODULE__, [], name: :chat_supervisor) end def start_room(name) do # And we use `start_child/2` to start a new Chat.Server process Supervisor.start_child(:chat_supervisor, [name]) end def init(_) do children = [ worker(Chat.Server, []) ] # We also changed the `strategty` to `simple_one_for_one`. # With this strategy, we define just a "template" for a child, # no process is started during the Supervisor initialization, # just when we call `start_child/2` supervise(children, strategy: :simple_one_for_one) end end</span></span></code> </pre> <br><p>  And let's make our <code>Chat.Server</code> accept names in the <code>start_link</code> function: </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/server.ex defmodule Chat.Server do use GenServer # Just accept a `name` parameter here for now def start_link(name) do GenServer.start_link(__MODULE__, [], name: :chat_room) end #... end</span></span></code> </pre> <br><blockquote>  The changes are in this <a href="https://github.com/brianstorti/elixir-registry-example-chat-app/commit/c3675e16125c83bccac0c3456a42dd30a28f162b">commit.</a> </blockquote><br><p>  And here is the problem!  We can have several <code>Chat.Server</code> processes, and they cannot all be named <code>:chat_room</code> .  Trouble ... </p><br><pre> <code class="bash hljs">$ iex -S mix iex&gt; Chat.Supervisor.start_link {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.107.0&gt;} iex&gt; Chat.Supervisor.start_room "foo" {:ok, #PID&lt;0.109.0&gt;} iex&gt; Chat.Supervisor.start_room "bar" {:error, {:already_started, #PID&lt;0.109.0&gt;}}</span></span></code> </pre> <br><p>  To be honest, the <code>VM</code> very eloquent.  We are trying to create a second process, but a process with the same name already exists, which is what the environment reminds us of.  We need to come up with some other way, but which one? .. </p><br><p>  Unfortunately, the type of the <code>name</code> argument is defined quite clearly.  We cannot use something like <code>{:chat_room, "room name"}</code> .  Let's go to the <a href="http://elixir-lang.org/docs/stable/elixir/GenServer.html">documentation</a> : </p><br><blockquote>  Supported values: <br>  <code>atom</code> - in this case, <code>GenServer</code> registered locally with the given name <code>atom</code> using <code>Process.register/2</code> . <br>  <code>{:global, term}</code> - in this case, <code>GenServer</code> registered globally with the given name <code>term</code> using functions in the <code>:global</code> module. <br>  <code>{:via, module, term}</code> <code>GenServer</code> this case, the <code>GenServer</code> registered using the mechanism defined in the <code>module</code> and the name `term. </blockquote><br><div class="spoiler">  <b class="spoiler_title">Original in English</b> <div class="spoiler_text"><blockquote>  The supported values ‚Äã‚Äãare: <br>  an <code>atom</code> - <code>GenServer</code> is registered with the given name using <code>Process.register/2</code> . <br>  <code>{:global, term}</code> - <code>GenServer</code> is registered globally with the <code>:global</code> module. <br>  <code>{:via, module, term}</code> - <code>GenServer</code> is registered with the mechanism and name. </blockquote></div></div><br><p>  The first option is <code>atom</code> , we have already used it, and we know for sure that in our cunning case it is not suitable. <br>  The second option is used to register the process globally in a cluster of nodes.  It uses a local <code>ETS</code> table.  In addition, it will require constant synchronization within the nodes in the cluster, and therefore the program will slow down.  So use it only when you <strong>really</strong> need it. <br>  The third, and last, option uses the tuple with <code>:via</code> as a parameter, and this is exactly what we need to solve our problem!  This is what the documentation says: </p><br><blockquote>  Option <code>:via</code> takes as its parameter a module that has the following interface: <code>register_name/2</code> , <code>unregister_name/1</code> , <code>whereis_name/1</code> and <code>send/2</code> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Original in English</b> <div class="spoiler_text"><blockquote>  Exports_name / 2, unregister_name / 1, whereis_name / 1 and send / 2. </blockquote></div></div><br><p>  Isn't it clear at all?  Me too!  So let's see this method in action. </p><br><h3>  Use tuple <strong><code>:via</code></strong> </h3><br><p>  So the tuple <code>:via</code> is a way to tell <code>Elixir</code> that we are going to use a separate module to register our processes.  This module should do the following things: </p><br><ul><li>  Register a name, which can be any <code>term</code> , using the <code>register_name/2</code> function; </li><li>  Delete names from the register using the <code>unregister_name/1</code> function; </li><li>  Find <code>pid</code> by name, using <code>whereis_name/1</code> ; </li><li>  Send messages to a specific process using <code>send/2</code> . </li></ul><br><p>  In order for this to work, the above functions must transmit the response in a certain format defined in the <code>OTP</code> - just as <code>handle_call/3</code> and <code>handle_cast/2</code> follow certain rules. </p><br><p>  Let's try to identify the module that knows all this: </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/registry.ex defmodule Chat.Registry do use GenServer # API def start_link do # We register our registry (yeah, I know) with a simple name, # just so we can reference it in the other functions. GenServer.start_link(__MODULE__, nil, name: :registry) end def whereis_name(room_name) do GenServer.call(:registry, {:whereis_name, room_name}) end def register_name(room_name, pid) do GenServer.call(:registry, {:register_name, room_name, pid}) end def unregister_name(room_name) do GenServer.cast(:registry, {:unregister_name, room_name}) end def send(room_name, message) do # If we try to send a message to a process # that is not registered, we return a tuple in the format # {:badarg, {process_name, error_message}}. # Otherwise, we just forward the message to the pid of this # room. case whereis_name(room_name) do :undefined -&gt; {:badarg, {room_name, message}} pid -&gt; Kernel.send(pid, message) pid end end # SERVER def init(_) do # We will use a simple Map to store our processes in # the format %{"room name" =&gt; pid} {:ok, Map.new} end def handle_call({:whereis_name, room_name}, _from, state) do {:reply, Map.get(state, room_name, :undefined), state} end def handle_call({:register_name, room_name, pid}, _from, state) do # Registering a name is just a matter of putting it in our Map. # Our response tuple include a `:no` or `:yes` indicating if # the process was included or if it was already present. case Map.get(state, room_name) do nil -&gt; {:reply, :yes, Map.put(state, room_name, pid)} _ -&gt; {:reply, :no, state} end end def handle_cast({:unregister_name, room_name}, state) do # And unregistering is as simple as deleting an entry # from our Map {:noreply, Map.delete(state, room_name)} end end</span></span></code> </pre> <br><p>  Again: in our hands, choose how our registry will work inside.  Here we use a simple <code>Map</code> to associate a name and a <code>pid</code> .  This code is absolutely straightforward, especially if you know well how <code>GenServer</code> works.  Only values ‚Äã‚Äãreturned by functions can seem unfamiliar. </p><br><p>  It's time to try our registry in the <code>iex</code> session: </p><br><pre> <code class="bash hljs">$ iex -S mix iex&gt; {:ok, pid} = Chat.Server.start_link(<span class="hljs-string"><span class="hljs-string">"room1"</span></span>) {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.107.0&gt;} iex&gt; Chat.Registry.start_link {:ok, #PID&lt;0.109.0&gt;} iex&gt; Chat.Registry.whereis_name("room1") :undefined iex&gt; Chat.Registry.register_name("room1", pid) :yes iex&gt; Chat.Registry.register_name("room1", pid) :no iex&gt; Chat.Registry.whereis_name("room1") #PID&lt;0.107.0&gt; iex&gt; Chat.Registry.unregister_name("room1") :ok iex&gt; Chat.Registry.whereis_name("room1") :undefined</span></span></code> </pre> <br><p>  5 seconds - great flight!  The registry works as it should: it registers and deletes the registration.  Let's try to use it in our chat rooms. </p><br><p>  Our problem was that we had several <code>Chat.Server</code> servers <code>Chat.Server</code> , initialized through <code>Supervisor</code> .  To send a message to a specific room, we would call <code>Chat.Server.add_message(‚Äúroom1‚Äù, ‚Äúmy message‚Äù)</code> , so we would have to register server names as <code>{:chat_room, ‚Äúroom1‚Äù}</code> and <code>{:chat_room, ‚Äúroom2‚Äù}</code> .  Here's how this is done through the tuple <code>:via</code> : </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/server.ex defmodule Chat.Server do use GenServer # API def start_link(name) do # Instead of passing an atom to the `name` option, we send # a tuple. Here we extract this tuple to a private method # called `via_tuple` that can be reused in every function GenServer.start_link(__MODULE__, [], name: via_tuple(name)) end def add_message(room_name, message) do # And the `GenServer` callbacks will accept this tuple the # same way it accepts a pid or an atom. GenServer.cast(via_tuple(room_name), {:add_message, message}) end def get_messages(room_name) do GenServer.call(via_tuple(room_name), :get_messages) end defp via_tuple(room_name) do # And the tuple always follow the same format: # {:via, module_name, term} {:via, Chat.Registry, {:chat_room, room_name}} end # SERVER (no changes required here) # ... end</span></span></code> </pre> <br><blockquote>  The changes are in this <a href="https://github.com/brianstorti/elixir-registry-example-chat-app/commit/b76cb5e293d26cb2426b5ab08528768fd0933879">commit.</a> </blockquote><br><p>  Here is what happens: every time we send a message to <code>Chat.Server</code> , passing the name of the room, it will find the <code>pid</code> desired process using the module that we passed to it in the tuple <code>:via</code> (in this case, <code>Chat.Registry</code> ) . <br>  This solves our problem: now we can use any number of <code>Chat.Server</code> processes (well, until the fantasy of names ends), and we never need to know their <code>pid</code> .  Totally. </p><br><p>  However, there is another problem in this solution.  Guess? <br>  Exactly!  Our registry is not aware of the processes that have fallen, and must be restarted through <code>Supervisor</code> .  This means that when this happens, the registry will not allow to re-create a record with the same name, and will store the <code>pid</code> dead process. </p><br><p>  In theory, the solution to this problem is not too complicated.  We will force our registry to monitor all processes that it stores <code>pid</code> .  As soon as such an ‚Äúobservable‚Äù process drops, we will simply remove it from our registry. </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># in lib/chat/registry.ex defmodule Chat.Registry do # ... def handle_call({:register_name, room_name, pid}, _from, state) do case Map.get(state, room_name) do nil -&gt; # When a new process is registered, we start monitoring it. Process.monitor(pid) {:reply, :yes, Map.put(state, room_name, pid)} _ -&gt; {:reply, :no, state} end end def handle_info({:DOWN, _, :process, pid, _}, state) do # When a monitored process dies, we will receive a # `:DOWN` message that we can use to remove the # dead pid from our registry. {:noreply, remove_pid(state, pid)} end def remove_pid(state, pid_to_remove) do # And here we just filter out the dead pid remove = fn {_key, pid} -&gt; pid != pid_to_remove end Enum.filter(state, remove) |&gt; Enum.into(%{}) end end</span></span></code> </pre> <br><blockquote>  The changes are in this <a href="https://github.com/brianstorti/elixir-registry-example-chat-app/commit/6ed76971a103a5b7c4adb9fd744fbb6abfddde8e">commit.</a> </blockquote><br><p>  Make sure everything works: </p><br><pre> <code class="bash hljs">$ iex -S mix iex&gt; Chat.Registry.start_link {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.107.0&gt;} iex&gt; Chat.Supervisor.start_link {:ok, #PID&lt;0.109.0&gt;} iex&gt; Chat.Supervisor.start_room("room1") {:ok, #PID&lt;0.111.0&gt;} iex&gt; Chat.Server.add_message("room1", "message") :ok iex&gt; Chat.Server.get_messages("room1") ["message"] iex&gt; Chat.Registry.whereis_name({:chat_room, "room1"}) |&gt; Process.exit(:kill) true iex&gt; Chat.Server.add_message("room1", "message") :ok iex&gt; Chat.Server.get_messages("room1") ["message"]</span></span></code> </pre> <br><p>  Well, now it doesn‚Äôt matter how many times <code>Supervisor</code> restarts the <code>Chat.Server</code> process: as soon as we send a message to the room, it will be delivered at the correct <code>pid</code> . </p><br><h3>  Simplify with <strong><code>gproc</code></strong> </h3><br><p>  In principle, with our chat, we will end here, but I would like to tell you about another feature that will simplify our registration with the help of a tuple <code>:via</code> .  This is <a href="https://github.com/uwiger/gproc"><u><strong><code>gproc</code></strong></u></a> , is the <code>Erlang</code> library. <br>  And we will teach our <code>Chat.Server</code> use <code>gproc</code> instead of our <code>Chat.Registry</code> , and then we will generally get rid of <code>Chat.Registry</code> . </p><br><p>  Let's start with dependencies.  To do this, add <code>gproc</code> to <code>mix.exs</code> : </p><br><pre> <code class="hljs vbscript"># ./mix.exs defmodule Chat.Mixfile <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... def application <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [applications: [:logger, :gproc]] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp deps <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [{:gproc, <span class="hljs-string"><span class="hljs-string">"0.3.1"</span></span>}] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Then we pull up the dependencies with: </p><br><pre> <code class="bash hljs">$ mix deps.get</code> </pre> <br><p>  Now we can change our registration with the help of a tuple <code>:via</code> - let it use <code>gproc</code> , and not <code>Chat.Registry</code> : </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./lib/chat/server.ex defmodule Chat.Server do # ... # The only thing we need to change is the `via_tuple/1` function, # to make it use `gproc` instead of `Chat.Registry` defp via_tuple(room_name) do {:via, :gproc, {:n, :l, {:chat_room, room_name}}} end # ... end</span></span></code> </pre> <br><p>  <code>gproc</code> uses <code>gproc</code> keys consisting of three values: <code>{type, scope, key}</code> . </p><br><p>  In our case, we use: </p><br><ul><li>  <code>:n</code> - this means a <code></code> , that is, there can not be more than one process registered with such a key; </li><li>  <code>:l</code> - this means <code>local</code> , that is, the process is registered only on our node; </li><li>  <code>{:chat_room, room_name}</code> is the key itself as a tuple. </li></ul><br><p>  For more information on the possible settings <code>gproc</code> look <a href="">here</a> . </p><br><p>  After such changes, we generally <code>Chat.Registry</code> our <code>Chat.Registry</code> , and check that everything continues to work in the <code>iex</code> session: </p><br><pre> <code class="bash hljs">$ iex -S mix iex&gt; Chat.Supervisor.start_link {:ok, <span class="hljs-comment"><span class="hljs-comment">#PID&lt;0.190.0&gt;} iex&gt; Chat.Supervisor.start_room("room1") {:ok, #PID&lt;0.192.0&gt;} iex&gt; Chat.Supervisor.start_room("room2") {:ok, #PID&lt;0.194.0&gt;} iex&gt; Chat.Server.add_message("room1", "first message") :ok iex&gt; Chat.Server.add_message("room2", "second message") :ok iex&gt; Chat.Server.get_messages("room1") ["first message"] iex&gt; Chat.Server.get_messages("room2") ["second message"] iex&gt; :gproc.where({:n, :l, {:chat_room, "room1"}}) |&gt; Process.exit(:kill) true iex&gt; Chat.Server.add_message("room1", "first message") :ok iex&gt; Chat.Server.get_messages("room1") ["first message"]</span></span></code> </pre> <br><blockquote>  The changes are in this <a href="https://github.com/brianstorti/elixir-registry-example-chat-app/commit/dc7c49f32ad5fe6fb591bc7ed944a43b1722c2a4">commit.</a> </blockquote><br><h3>  Where to sail further, captain? </h3><br><p>  We have dealt with a bunch of difficult questions.  Main conclusions: </p><br><ul><li>  Be careful when working with <code>pid</code> directly: they change as soon as the process restarts. </li><li>  If you need to get a link to only one process (as we had with a single room in the chat), registering a process with the name in the form of an atom is a sufficient measure; </li><li>  If you need to create processes dynamically (many chat rooms), you can use a tuple <code>:via</code> to provide your own registry; </li><li>  Such registries already exist (for example, <code>gproc</code> ), and if you use them, you will not have to build your bike; </li></ul><br><p>  Of course, this is not all.  If you need global registration on all nodes in a cluster, other tools may be good too.  <code>Erlang</code> has global modules for global registrations, <code>pg2</code> for process groups, and the same <code>gprc</code> can help you. </p><br><p>  If you are interested in this article, read <strong><code>Sa≈°a Juriƒá. Elixir in Action</code></strong>  <strong><code>Sa≈°a Juriƒá. Elixir in Action</code></strong> . </p><br><p>  And here is a <a href="https://github.com/brianstorti/elixir-registry-example-chat-app">turnip with cheese</a> ) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306500/">https://habr.com/ru/post/306500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306490/index.html">How to deploy Windows Nano Server (TP5) on vSphere</a></li>
<li><a href="../306492/index.html">Live chat for websites: self-hosted / open source</a></li>
<li><a href="../306494/index.html">Community of experts, collaborating on projects and other updates of the FlyElephant platform</a></li>
<li><a href="../306496/index.html">Wishes Come True: Interesting C ++ Conference of Russia</a></li>
<li><a href="../306498/index.html">Methods of finding the causes of poor server performance 1c</a></li>
<li><a href="../306502/index.html">Content marketing: how to write clear and minimally annoying email text</a></li>
<li><a href="../306504/index.html">Open source initiative Docker4Drupal.org</a></li>
<li><a href="../306506/index.html">30 questions for which you must have an answer during the interview</a></li>
<li><a href="../306508/index.html">According to Rambler.iOS # 7</a></li>
<li><a href="../306510/index.html">Page segmentation - overview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>