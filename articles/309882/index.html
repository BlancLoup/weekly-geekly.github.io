<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Android device as a thin UI for C ++ programs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share with the community a project that I have been quietly doing over the past few months. 

 Foreword 
 There are often situations when yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Android device as a thin UI for C ++ programs</h1><div class="post__text post__text-html js-mediator-article">  I want to share with the community a project that I have been quietly doing over the past few months. <br><br><h3>  Foreword </h3><br>  There are often situations when you want to manage your program from a phone or tablet, but it is impractical (or not possible) to write a separate application for this on the phone (too much effort for this project, no development experience for android, etc.) ).  This situation periodically arose in me, and in the end I decided to deal with this problem once and for all.  The result is a system, the architecture and use of which are described in this article. <br><a name="habracut"></a><br><h3>  purpose </h3><br>  Creating a system that allows you to implement a plug-in UI based on android devices in C ++ programs.  At the same time, we wanted to minimize the dependencies of custom C ++ code on third-party libraries, as well as to abstract it from the data transfer protocol.  The system should consist of two parts: C ++ libraries and android applications. <br><br><h3>  System architecture </h3><br>  The system has a client-server architecture, where clients are android devices, the server is a user program.  Communication between them is carried out using TCP / IP sockets.  To implement the communication protocol, the <a href="https://github.com/vosel/tau">TAU</a> library was created. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main tasks for which the library is responsible: <br><br><ul><li>  generation and processing of data transmitted between the server and the client </li><li>  transfer control to user code to react to various events that occurred on the client (UI event handlers) </li><li>  creating and maintaining a connection between the server and the client </li><li>  generation of necessary data structures for describing the configuration of UI elements displayed on clients </li></ul><br>  The library consists of the following namespaces: <br><br><ul><li>  <i>tau :: communications_handling</i> - is responsible for the formation of packets, the parsing of data received from the client, the call of handlers in user code.  Everything that happens between the moments of connecting and disconnecting the client is controlled by the class code from this namespace. <br><br></li><li>  <i>tau :: layout_generation</i> - contains functionality that allows you to create json-structures that describe the location and behavior of elements of the user interface.  This data is then sent to the client and it displays the corresponding UI. <br><br></li><li>  <i>tau :: util</i> - contains various auxiliary functionality that is not necessary for the library to be used in a custom C ++ project, but often turns out to be useful.  The classes in this namespace are the only ones that can use third-party libraries or non-standard compiler extensions.  Therefore, here are the classes responsible for working with TCP / IP sockets - this is platform-specific code.  Now there are two implementations of network communication: based on boost :: asio and C ++ / CLI.  The removal of the implementation of all network calls outside of tau :: communications_handling allows the user of the library to write the entire network portion if desired. <br><br></li><li>  <i>tau :: common</i> - contains classes used from other parts of the library (they are derived here so that there are no dependencies between tau :: layout_generation and tau :: communications_handling) </li></ul><br><h3>  Using.  Example # 1 - hello, world </h3><br>  We'll start the demonstration of using the library with the simplest example, in which a welcome message will be displayed on the screen.  Here is what the custom code will look like in our case: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tau/layout_generation/layout_info.h&gt; #include &lt;tau/util/basic_events_dispatcher.h&gt; #include &lt;tau/util/boost_asio_server.h&gt; class MyEventsDispatcher : public tau::util::BasicEventsDispatcher { public: MyEventsDispatcher( tau::communications_handling::OutgiongPacketsGenerator &amp; outgoingGeneratorToUse): tau::util::BasicEventsDispatcher(outgoingGeneratorToUse) {}; virtual void packetReceived_requestProcessingError( std::string const &amp; layoutID, std::string const &amp; additionalData) { std::cout &lt;&lt; "Error received from client:\nLayouID: " &lt;&lt; layoutID &lt;&lt; "\nError: " &lt;&lt; additionalData &lt;&lt; "\n"; } virtual void onClientConnected( tau::communications_handling::ClientConnectionInfo const &amp; connectionInfo) { std::cout &lt;&lt; "Client connected: remoteAddr: " &lt;&lt; connectionInfo.getRemoteAddrDump() &lt;&lt; ", localAddr : " &lt;&lt; connectionInfo.getLocalAddrDump() &lt;&lt; "\n"; } void packetReceived_clientDeviceInfo( tau::communications_handling::ClientDeviceInfo const &amp; info) { using namespace tau::layout_generation; std::cout &lt;&lt; "Received client information packet\n"; std::string greetingMessage = "Hello, habrahabr!"; sendPacket_resetLayout(LayoutInfo().pushLayoutPage( LayoutPage(tau::common::LayoutPageID("FIRST_LAYOUT_PAGE"), LabelElement(greetingMessage))).getJson()); } }; int main(int argc, char ** argv) { boost::asio::io_service io_service; short port = 12345; tau::util::SimpleBoostAsioServer&lt;MyEventsDispatcher&gt;::type s(io_service, port); std::cout &lt;&lt; "Starting server on port " &lt;&lt; port &lt;&lt; "...\n"; s.start(); std::cout &lt;&lt; "Calling io_service.run()\n"; io_service.run(); return 0; }</span></span></span></span></code> </pre> </div></div><br>  The main class that contains all user logic that interacts with the client device ( <i>MyEventsDispatcher</i> ) must be inherited from <i>tau :: util :: BasicEventsDispatcher</i> .  It overrides 2 methods from the base class: <i>onClientConnected ()</i> and <i>packetReceived_clientDeviceInfo ()</i> .  The first is called when the client connects.  The second method will be executed when the client device information comes after the connection (the first packet after connection is sent by the client). <br><br>  In our case, the first method is trivial - it only displays an informational message on the console.  In the second method, the server sends a layout to the client ‚Äî data on which interface should be displayed on the client. <br><br>  All the code responsible for transferring data over the network is in main ().  In this case, <i>boost :: asio is</i> used to implement the communication.  In the <i>tau :: util</i> namespace there are corresponding abstractions, which makes this example as compact as possible.  Using boost is optional - any implementation of TCP / IP sockets can be fairly easily used with a library. <br><br><h3>  Compilation </h3><br>  As an example, we will use g ++ for compilation.  In our case, the command will be as follows: <br><br><pre> <code class="bash hljs">g++ -lboost_system -pthread -lboost_thread -D TAU_HEADERONLY -D TAU_CPP_03_COMPATIBILITY -I <span class="hljs-variable"><span class="hljs-variable">$LIBRARY_LOCATION</span></span> main.cpp -o demo</code> </pre> <br>  As you can see, the compiler is passed several additional parameters: <br><br><ul><li>  include path to library sources (option <i>-I $ LIBRARY_LOCATION</i> ) </li><li>  additional libraries needed for boost :: asio (options <i>-lboost_system -pthread -lboost_thread</i> ) </li><li>  declare additional macros to indicate how we compile the library in our project ( <i>-D TAU_HEADERONLY -D TAU_CPP_03_COMPATIBILITY</i> ) </li></ul><br>  This set of options is the most common version of the assembly, which will allow the library to be included in any project with minimal effort. <br><br>  You can get rid of them all if you want.  If you use the library within the project, you do not need to specify <i>-I $ LIBRARY_LOCATION</i> and <i>-D TAU_HEADERONLY</i> .  For compilers that are compatible with C ++ 11, the <i>-D TAU_CPP_03_COMPATIBILITY</i> option is not needed.  Dependence on <i>boost :: asio</i> has only the network part, which can be easily rewritten without dependencies. <br><br>  After compiling and running, the server starts listening on port 12345. <br><br>  We start the client on the phone, create a connection and connect to it to display a message.  This is how it will look like (I started the server on a remote computer via PuTTY, and the client was started in the emulator): <br><br><div class="spoiler">  <b class="spoiler_title">Creating a server connection</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d9f/ee4/5dc/d9fee45dc45a4040810c6ecc7f41fba5.gif"></div></div><br>  This example does not provide for the transmission and receipt of additional notifications between the client and the server, so let's move on to the following example. <br><br><h3>  Example 2 - a more detailed demonstration of the system's capabilities </h3><br>  In this example, we will add several different elements in our server, learn how to receive notifications from them, change their state and switch pages. <br><br>  The server code will look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tau/layout_generation/layout_info.h&gt; #include &lt;tau/util/basic_events_dispatcher.h&gt; #include &lt;tau/util/boost_asio_server.h&gt; namespace { std::string const INITIAL_TEXT_VALUE("initial text"); tau::common::LayoutID const LAYOUT_ID("SAMPLE_LAYOUT_ID"); tau::common::LayoutPageID const LAYOUT_PAGE1_ID("LAYOUT_PAGE_1"); tau::common::LayoutPageID const LAYOUT_PAGE2_ID("LAYOUT_PAGE_2"); tau::common::ElementID const BUTTON_WITH_NOTE_TO_REPLACE_ID("BUTTON_WITH_NOTE_TO_REPLACE"); tau::common::ElementID const BUTTON_TO_RESET_VALUES_ID("BUTTON_TO_RESET_NOTES"); tau::common::ElementID const BUTTON_TO_PAGE_1_ID("BUTTON_TO_PG1"); tau::common::ElementID const BUTTON_TO_PAGE_2_ID("BUTTON_TO_PG2"); tau::common::ElementID const BUTTON_1_ID("BUTTON_1"); tau::common::ElementID const BUTTON_2_ID("BUTTON_2"); tau::common::ElementID const BUTTON_3_ID("BUTTON_3"); tau::common::ElementID const BUTTON_4_ID("BUTTON_4"); tau::common::ElementID const TEXT_INPUT_ID("TEXT_INPUT"); tau::common::ElementID const BOOL_INPUT_ID("BOOL_INPUT"); tau::common::ElementID const LABEL_ON_PAGE2_ID("LABEL_ON_PAGE2"); }; class MyEventsDispatcher : public tau::util::BasicEventsDispatcher { public: MyEventsDispatcher( tau::communications_handling::OutgiongPacketsGenerator &amp; outgoingGeneratorToUse): tau::util::BasicEventsDispatcher(outgoingGeneratorToUse) {}; virtual void packetReceived_requestProcessingError( std::string const &amp; layoutID, std::string const &amp; additionalData) { std::cout &lt;&lt; "Error received from client:\nLayouID: " &lt;&lt; layoutID &lt;&lt; "\nError: " &lt;&lt; additionalData &lt;&lt; "\n"; } virtual void onClientConnected( tau::communications_handling::ClientConnectionInfo const &amp; connectionInfo) { std::cout &lt;&lt; "Client connected: remoteAddr: " &lt;&lt; connectionInfo.getRemoteAddrDump() &lt;&lt; ", localAddr : " &lt;&lt; connectionInfo.getLocalAddrDump() &lt;&lt; "\n"; } virtual void packetReceived_clientDeviceInfo( tau::communications_handling::ClientDeviceInfo const &amp; info) { using namespace tau::layout_generation; std::cout &lt;&lt; "Received client information packet\n"; LayoutInfo resultLayout; resultLayout.pushLayoutPage(LayoutPage(LAYOUT_PAGE1_ID, EvenlySplitLayoutElementsContainer(true) .push(EvenlySplitLayoutElementsContainer(false) .push(BooleanInputLayoutElement(true).note(INITIAL_TEXT_VALUE).ID(BOOL_INPUT_ID)) .push(ButtonLayoutElement().note(INITIAL_TEXT_VALUE) .ID(BUTTON_WITH_NOTE_TO_REPLACE_ID))) .push(TextInputLayoutElement().ID(TEXT_INPUT_ID).initialValue(INITIAL_TEXT_VALUE)) .push(EmptySpace()) .push(EmptySpace()) .push(EmptySpace()) .push(EvenlySplitLayoutElementsContainer(false) .push(ButtonLayoutElement().note("reset notes").ID(BUTTON_TO_RESET_VALUES_ID)) .push(EmptySpace()) .push(ButtonLayoutElement().note("go to page 2").ID(BUTTON_TO_PAGE_2_ID) .switchToAnotherLayoutPageOnClick(LAYOUT_PAGE2_ID)) ) ) ); resultLayout.pushLayoutPage(LayoutPage(LAYOUT_PAGE2_ID, EvenlySplitLayoutElementsContainer(true) .push(EvenlySplitLayoutElementsContainer(false) .push(ButtonLayoutElement().note("1").ID(BUTTON_1_ID)) .push(ButtonLayoutElement().note("2").ID(BUTTON_2_ID))) .push(EvenlySplitLayoutElementsContainer(false) .push(ButtonLayoutElement().note("3").ID(BUTTON_3_ID)) .push(ButtonLayoutElement().note("4").ID(BUTTON_4_ID))) .push(EvenlySplitLayoutElementsContainer(true) .push(LabelElement("").ID(LABEL_ON_PAGE2_ID)) .push(ButtonLayoutElement().note("back to page 1").ID(BUTTON_TO_PAGE_1_ID))) )); resultLayout.setStartLayoutPage(LAYOUT_PAGE1_ID); sendPacket_resetLayout(resultLayout.getJson()); } virtual void packetReceived_buttonClick( tau::common::ElementID const &amp; buttonID) { std::cout &lt;&lt; "event: buttonClick, id=" &lt;&lt; buttonID &lt;&lt; "\n"; if (buttonID == BUTTON_TO_RESET_VALUES_ID) { sendPacket_updateTextValue(TEXT_INPUT_ID, INITIAL_TEXT_VALUE); } else if (buttonID == BUTTON_TO_PAGE_1_ID) { sendPacket_changeShownLayoutPage(LAYOUT_PAGE1_ID); } else if (buttonID == BUTTON_1_ID) { sendPacket_changeElementNote(LABEL_ON_PAGE2_ID, "Button 1 pressed"); } else if (buttonID == BUTTON_2_ID) { sendPacket_changeElementNote(LABEL_ON_PAGE2_ID, "Button 2 pressed"); } else if (buttonID == BUTTON_3_ID) { sendPacket_changeElementNote(LABEL_ON_PAGE2_ID, "Button 3 pressed"); } else if (buttonID == BUTTON_4_ID) { sendPacket_changeElementNote(LABEL_ON_PAGE2_ID, "Button 4 pressed"); } } virtual void packetReceived_layoutPageSwitched( tau::common::LayoutPageID const &amp; newActiveLayoutPageID) { std::cout &lt;&lt; "event: layoutPageSwitch, id=" &lt;&lt; newActiveLayoutPageID &lt;&lt; "\n"; } virtual void packetReceived_boolValueUpdate( tau::common::ElementID const &amp; inputBoxID, bool new_value, bool is_automatic_update) { std::cout &lt;&lt; "event: boolValueUpdate, id=" &lt;&lt; inputBoxID &lt;&lt; ", value=" &lt;&lt; new_value &lt;&lt; "\n"; } virtual void packetReceived_textValueUpdate( tau::common::ElementID const &amp; inputBoxID, std::string const &amp; new_value, bool is_automatic_update) { std::cout &lt;&lt; "event: textValueUpdate, id=" &lt;&lt; inputBoxID &lt;&lt; ",\n\tvalue=" &lt;&lt; new_value &lt;&lt; "\n"; sendPacket_changeElementNote(BOOL_INPUT_ID, new_value); sendPacket_changeElementNote(BUTTON_WITH_NOTE_TO_REPLACE_ID, new_value); } }; int main(int argc, char ** argv) { boost::asio::io_service io_service; short port = 12345; tau::util::SimpleBoostAsioServer&lt;MyEventsDispatcher&gt;::type s(io_service, port); std::cout &lt;&lt; "Starting server on port " &lt;&lt; port &lt;&lt; "...\n"; s.start(); std::cout &lt;&lt; "Calling io_service.run()\n"; io_service.run(); return 0; }</span></span></span></span></code> </pre></div></div><br>  All changes from the previous example were made in the class <i>MyEventsDispatcher</i> .  The following event handler methods from the client have been added: <br><br><ul><li>  handler of event of pressing of the button <i>packetReceived_buttonClick</i> .  The button ID is passed to the method as a parameter. </li><li>  handlers of packets that transmit variable values ‚Äã‚Äãfrom client to server: <i>packetReceived_boolValueUpdate, packetReceived_intValueUpdate, packetReceived_floatPointValueUpdate, packetReceived_textValueUpdate</i> </li><li>  handler of event of change of the displayed page with <i>packetReceived_layoutPageSwitched</i> elements </li></ul><br>  In addition, the layout sent to the client upon connection has changed accordingly. <br><br>  Since we have a demo, the code in the handlers is as simple as possible - dumping event information into the console, as well as sending various commands to the client. <br><br>  All commands will be sent to the client from the handler for pressing the <i>packetReceived_buttonClick ()</i> buttons (of course, this is not necessarily done there, but it‚Äôs easier and clearer). <br><br>  Each command corresponds to a packet transmitted from the server to the client.  Formation and sending of these packets occurs when calling special methods defined in <i>BasicEventsDispatcher</i> : <br><br><ul><li>  <i>sendPacket_resetLayout ()</i> - replacement of the entire layout </li><li>  <i>sendPacket_requestValue ()</i> - request for the value of a variable in one of the inputs </li><li>  <i>sendPacket_updateBooleanValue (), sendPacket_updateIntValue (), sendPacket_updateFloatPointValue, sendPacket_updateTextValue ()</i> - change the value of variables in inputs </li><li>  <i>sendPacket_changeElementNote ()</i> - change any read-only text (text on buttons, checkboxes, labels) </li><li>  <i>sendPacket_changeShownLayoutPage ()</i> - switching to another page with elements </li><li>  <i>sendPacket_changeElementEnabledState ()</i> - switching the active status of items (inactive items are displayed, but they cannot be interacted with) </li></ul><br>  Here is how this example works: <br><br><div class="spoiler">  <b class="spoiler_title">Demonstration of working with UI elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/467/d65/9a8/467d659a8fcb4faca500d35eb70bde44.gif"></div></div><br>  As you can see, for each action on the client device, the corresponding code is executed on the server.  When the values ‚Äã‚Äãof the user input elements change, the server receives a notification about the new value of the variable in this element.  In the button press handler, various packages are sent from the server to the client (the type of package depends on which button was pressed).  This example also shows how page switching works.  Breaking the layout into pages allows you to group elements according to their functions.  On the client screen, only one of the pages is always displayed, which reduces the load on the interface. <br><br><h3>  Example 3 - something useful </h3><br>  The last example today is the partial implementation of one of the tasks for which I started this project.  This is the simplest keyboard input emulator for windows (uses the <i><a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms646310(v%3Dvs.85).aspx">SendInput ()</a></i> winapi function). <br><br>  The code for this example is on my <a href="https://github.com/vosel/tau-additional/blob/master/habr_article_01/sample03-simpleHotkeyEmulator/boost_asio/">githaba</a> .  I will not give it here - it does not demonstrate anything new in the use of the library compared to the second example.  Here I will give only a demo of his work: <br><br><div class="spoiler">  <b class="spoiler_title">Keyboard Emulation</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/cfb/695/016/cfb69501675044019576953cc16da6a6.gif"></div></div><br>  The code of this example is easy to expand to more complex tasks of emulating keyboard input. <br><br><h3>  Epilogue </h3><br>  Instead of a conclusion, I want to appeal to the community.  Do you need a similar system?  Do I invent another bicycle?  What needs to be described in more detail?  In which direction do you need to develop further? <br><br>  The following development paths occur to me now (they are almost completely orthogonal, so I would like to prioritize): <br><br><ul><li>  adding client applications for other platforms (IOS, PC) </li><li>  expansion of data transmission protocol functionality (heartbeat packets for connection monitoring, communication control commands) </li><li>  adding new UI elements (drop-down boxes, images, etc) </li><li>  deeper customization of the appearance of the elements on the client (colors, fonts, styles) </li><li>  support for more specific client device functions (notifications, sensors, volume buttons, etc) </li><li>  adding server libraries for other programming languages </li></ul><br>  In addition, I will be glad to hear criticism about the architecture and implementation of the library in the state in which it is now. <br><br>  References: <br><br><ul><li>  <a href="https://github.com/vosel/tau">C ++ github library</a> </li><li>  <a href="https://github.com/vosel/tau-additional/tree/master/habr_article_01">examples from this article</a> </li><li>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.tau.client">google play client application</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/309882/">https://habr.com/ru/post/309882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309872/index.html">Eddystone beacons to control power consumption</a></li>
<li><a href="../309874/index.html">Business Development for SaaS Services: Strategy Design Design</a></li>
<li><a href="../309876/index.html">Google Device Lab Winners: Explore Project Tango</a></li>
<li><a href="../309878/index.html">How to understand that Agile works</a></li>
<li><a href="../309880/index.html">How we developed the game, where there are no fixed rules</a></li>
<li><a href="../309884/index.html">The developer who lives on the roof: chronicles of the past PDUG Picnic</a></li>
<li><a href="../309888/index.html">Key skills of a successful Agile team or how to make Agile work?</a></li>
<li><a href="../309892/index.html">Configuring automatic password retrieval for VPN on Mikrotik</a></li>
<li><a href="../309898/index.html">PCI Express 4.0, cables and everything</a></li>
<li><a href="../309900/index.html">While the thunder did not strike, or Continuity and GOST R 53647.4-2011 / ISO / PAS 22399: 2007</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>