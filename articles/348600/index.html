<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tutorial on Unreal Engine: C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blueprints is a very popular way to create gameplay in the Unreal Engine 4. However, if you‚Äôve been programming and prefer code for a long time, C ++ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tutorial on Unreal Engine: C ++</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/da3/bce/e1fda3bce1ec3c3654adbb93e4730d7b.jpg" alt="image"></div><br>  Blueprints is a very popular way to create gameplay in the Unreal Engine 4. However, if you‚Äôve been programming and prefer code for a long time, C ++ is perfect for you.  With C ++ you can even make changes to the engine and create your own plugins. <br><br>  In this tutorial you will learn the following: <br><br><ul><li>  Create C ++ Classes </li><li>  Add components and make them visible for Blueprints </li><li>  Create a Blueprint class based on the C ++ class </li><li>  Add variables and make them editable from Blueprints </li><li>  Associate axis and action bindings with functions </li><li>  Redefine C ++ Functions in Blueprints </li><li>  Associate a collision event with a function </li></ul><a name="habracut"></a><br>  It is worth considering that this is <em>not a</em> tutorial on learning C ++.  We will focus on working with C ++ in the context of the Unreal Engine. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  <em>Note:</em> this tutorial assumes that you are already familiar with the basics of the Unreal Engine.  If you're new to the Unreal Engine, first learn the ten-part <a href="https://habrahabr.ru/post/344394/">Unreal Engine tutorial for beginners</a> . </blockquote><br><h2>  Getting Started </h2><br>  If you have not done this yet, then you will need to install <a href="https://www.visualstudio.com/">Visual Studio</a> .  Follow the instructions from Epic's <a href="https://docs.unrealengine.com/latest/INT/Programming/Development/VisualStudioSetup/">official guide</a> for setting up Visual Studio for the Unreal Engine 4. (You can use alternative IDEs, but this tutorial uses Visual Studio because Unreal is designed to work with it.) <br><br>  Then download the <a href="">project blank</a> and unpack it.  Navigate to the project folder and open <em>CoinCollector.uproject</em> .  If the application is asked to rebuild the modules, then click <em>Yes</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebe/b4b/d05/ebeb4bd05c58f87d682483e2ced1175c.jpg"></div><br>  When finished with this, you will see the following scene: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/d4b/46d/ebcd4b46de6641165647fe1ef5770cc4.jpg"></div><br>  In this tutorial, we will create a ball that the player will move to collect coins.  In previous tutorials, we used player-driven characters using Blueprints.  In this tutorial, we will create it using C ++. <br><br><h2>  Creating a C ++ Class </h2><br>  To create a C ++ class, go to the Content Browser and select <em>Add New \ New C ++ Class</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d17/aa9/a32/d17aa9a323c80c7886ea1195c687a1b5.jpg"></div><br>  This will open the C ++ Class Wizard.  First, you will need to choose which class we will inherit from.  Since the class must be a controlled player, we will need a pawn.  Select <em>Pawn</em> and click <em>Next</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/494/aea/4f0/494aea4f0cebed025ed7d76451eaf02b.jpg"></div><br>  On the next screen, you can specify the name and path to the .h and .cpp files.  Replace <em>Name</em> with <em>BasePlayer</em> and click on <em>Create Class</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/572/981/39f572981149f833fa7180a89a82907f.jpg"></div><br>  This will create files and compile the project.  After compiling, Unreal will open Visual Studio.  If <em>BasePlayer.cpp</em> and <em>BasePlayer.h are</em> not open, go to Solution Explorer and open them.  They are located in the <em>Games \ CoinCollector \ Source \ CoinCollector folder</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/241/80a/e4e24180ae97f6a9fae9f0804b034861.jpg"></div><br>  Before moving on, you need to learn about <a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection">the</a> Unreal <a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection">reflection system</a> .  This system manages various parts of the engine, such as the Details panel and garbage collection.  When creating a class using C ++ Class Wizard, the Unreal engine adds three lines to the header: <br><br><ol><li><code>#include "TypeName.generated.h"</code> </li> <li> <code>UCLASS()</code> </li> <li> <code>GENERATED_BODY()</code> </li> </ol><br>  The Unreal engine needs these lines in order for the class to be visible to the reflection system.  If this is not clear to you, then do not worry.  You only need to know that the reflection system allows you to do such things as expanding the functions and variables of Blueprints and the editor. <br><br>  You may also notice that the class is called <code>ABasePlayer</code> , not <code>BasePlayer</code> .  When creating a class of type actor, Unreal prefixes the class name with the name <em>A</em> (from the word <em>actor</em> ).  For the reflection system to work, it needs the classes to have the appropriate prefixes.  Read more about prefixes in <a href="https://docs.unrealengine.com/latest/INT/Programming/Development/CodingStandard/">the</a> Epic <a href="https://docs.unrealengine.com/latest/INT/Programming/Development/CodingStandard/">Code Design Standard</a> . <br><br><blockquote>  <em>Note:</em> prefixes are not displayed in the editor.  For example, if you need to create a variable of type <em>ABasePlayer</em> , then you need to look for <em>BasePlayer</em> . </blockquote><br>  That's all you need to know about the reflection system.  Now we need to add a player model and a camera.  For this you need to use <em>components</em> . <br><br><h3>  Add components </h3><br>  For a pawn player, we need to add three components: <br><br><ol><li>  <em>Static Mesh:</em> it allows you to select a mesh that is a player‚Äôs model. </li><li>  <em>Spring Arm:</em> This component is used as a camera tripod.  One end will be attached to the mesh, and a camera will be attached to the other. </li><li>  <em>Camera:</em> Unreal shows the player everything that the camera sees. </li></ol><br>  First, we need to add headers for each type of component.  Open <em>BasePlayer.h</em> and add the following lines above <code>#include "BasePlayer.generated.h"</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include "Components/StaticMeshComponent.h" #include "GameFramework/SpringArmComponent.h" #include "Camera/CameraComponent.h"</span></span></code> </pre> <br><blockquote>  <em>Note:</em> It is important to add the <em>last</em> <em>.generated.h</em> file.  In our case, include directives should look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include "CoreMinimal.h" #include "GameFramework/Pawn.h" #include "Components/StaticMeshComponent.h" #include "GameFramework/SpringArmComponent.h" #include "Camera/CameraComponent.h" #include "BasePlayer.generated.h"</span></span></code> </pre> <br>  If it is not the last one to include, then we will get an error when compiling. </blockquote><br>  Now we need to declare variables for each component.  Add the following lines after <code>SetupPlayerInputComponent()</code> : <br><br><pre> <code class="cs hljs">UStaticMeshComponent* Mesh; USpringArmComponent* SpringArm; UCameraComponent* Camera;</code> </pre> <br>  The name used here will be the name of the component in the editor.  In our case, the components will be displayed as <em>Mesh</em> , <em>SpringArm</em> and <em>Camera</em> . <br><br>  Next, we need to make each variable visible to the reflection system.  To do this, add <code>UPROPERTY()</code> over each variable.  Now the code should look like this: <br><br><pre> <code class="cs hljs">UPROPERTY() UStaticMeshComponent* Mesh; UPROPERTY() USpringArmComponent* SpringArm; UPROPERTY() UCameraComponent* Camera;</code> </pre> <br>  You can also add <code>UPROPERTY()</code> to <code>UPROPERTY()</code> <a href="https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/">)</a> .  They will control the behavior of the variable in various aspects of the engine. <br><br>  Add <code>VisibleAnywhere</code> and <code>BlueprintReadOnly</code> inside the brackets of each <code>UPROPERTY()</code> .  Separate each descriptor with a comma. <br><br><pre> <code class="cs hljs">UPROPERTY(VisibleAnywhere, BlueprintReadOnly)</code> </pre> <br>  <code>VisibleAnywhere</code> will allow each component to be visible in the editor (including Blueprints). <br><br>  <code>BlueprintReadOnly</code> allows you <em>to get a</em> reference to a component using Blueprint nodes.  However, it will not allow us <em>to set the</em> component.  For components, it is important to be read-only, because their variables are pointers.  We <em>do not want</em> users to ask them, otherwise they may indicate a random place in memory.  It is worth noting that <code>BlueprintReadOnly</code> still allows you to set variables <em>inside the</em> component, and it is for this behavior that we seek. <br><br><blockquote>  <em>Note:</em> For variables that are not pointers (int, float, boolean, etc.), use <code>EditAnywhere</code> and <code>BlueprintReadWrite</code> . </blockquote><br>  Now that we have variables for each component, we need to initialize them.  For this you need to create them inside the <em>constructor</em> . <br><br><h3>  Component initialization </h3><br>  You can use <code>CreateDefaultSubobject&lt;Type&gt;("InternalName")</code> to create components.  Open <em>BasePlayer.cpp</em> and add the following lines to <code>ABasePlayer()</code> : <br><br><pre> <code class="cs hljs">Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(<span class="hljs-string"><span class="hljs-string">"Mesh"</span></span>); SpringArm = CreateDefaultSubobject&lt;USpringArmComponent&gt;(<span class="hljs-string"><span class="hljs-string">"SpringArm"</span></span>); Camera = CreateDefaultSubobject&lt;UCameraComponent&gt;(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>);</code> </pre> <br>  This will create a component of each type, and then assign them an address in the memory of the passed variable.  The string argument is the internal name of the component used by the engine ( <em>and not the</em> display name, despite the fact that in our case they are the same). <br><br>  Then we need to set up a hierarchy (select the root component, and so on).  Add after the previous code the following: <br><br><pre> <code class="cs hljs">RootComponent = Mesh; SpringArm-&gt;SetupAttachment(Mesh); Camera-&gt;SetupAttachment(SpringArm);</code> </pre> <br>  The first line makes <code>Mesh</code> <em>root</em> component.  The second line will attach <code>SpringArm</code> to <code>Mesh</code> .  Finally, the third line will attach the <code>Camera</code> to the <code>SpringArm</code> . <br><br>  After completing the component code, we need to compile.  Choose one of the following compilation methods: <br><br><ol><li>  In Visual Studio, select <em>Build \ Build Solution.</em> </li><li>  In the Unreal Engine, click on <em>Compile</em> in the <em>Toolbar</em> </li></ol><br>  Then we need to specify which mesh to use and the rotation of the spring lever.  It is recommended to do this in Blueprints, because it is undesirable to specify the paths to resources in C ++.  For example, in C ++, to set a static mesh, you need to do something like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConstructorHelpers::<span class="hljs-function"><span class="hljs-function">FObjectFinder&lt;UStaticMesh&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeshToUse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TEXT(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"StaticMesh'/Game/MyMesh.MyMesh"</span></span></span></span></span><span class="hljs-function">)</span></span>; MeshComponent-&gt;SetStaticMesh(MeshToUse.Object);</code> </pre> <br>  However, in Blueprints, simply select a mesh from the drop-down list. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaa/d60/8eb/aaad608eb70c7ed3d5929edd24fac0aa.jpg"></div><br>  If you move a resource to another folder, Blueprints will not spoil anything.  However, in C ++ you will have to change every link to this resource. <br><br>  To set the rotation of the mesh and spring arm in Blueprints, you will need to create a Blueprint based on the <em>BasePlayer</em> . <br><br><blockquote>  <em>Note:</em> It is usually practiced to create base classes in C ++ and then create a subclass of Blueprint.  It simplifies changing classes for artists and designers. </blockquote><br><h2>  Highlighting subclasses of C ++ classes </h2><br>  In the Unreal Engine, go to the <em>Blueprints</em> folder and create the <em>Blueprint Class</em> .  Expand the <em>All Classes</em> section and locate the <em>BasePlayer</em> .  Select <em>BasePlayer</em> , and then click on <em>Select</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b55/283/1b1/b552831b1f32a1a73eb6466c5d12b238.jpg"></div><br>  Rename it to <em>BP_Player</em> , and then open it. <br><br>  First we set the mesh.  Select the <em>Mesh</em> component and set its <em>Static Mesh</em> to <em>SM_Sphere</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/086/265/983/086265983770bd21f487b43b73d68184.jpg"></div><br>  Then we need to set the rotation and length of the spring arm.  Our game will be with a top view, so the camera must be above the player. <br><br>  Select the <em>SpringArm</em> component and set the <em>Rotation</em> value to <em>(0, -50, 0)</em> .  This will rotate the spring lever so that the camera will look at the mesh from top to bottom. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63d/776/5fd/63d7765fdbb72bec2f64e32636b4a53a.jpg"></div><br>  Since the spring arm is a child of the mesh, it begins to rotate when the ball begins to rotate. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/786/c95/859786c9541078bc6b670e14cfcd1f71.gif"></div></div></div><br>  To fix this, we need to make the turn of the lever <em>absolute</em> .  Click on the <em>arrow</em> next to <em>Rotation</em> and select <em>World</em> . <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a19/b7b/e60/a19b7be604d4494b837d0ad27d9afd68.gif"></div></div></div><br>  Then set the <em>Target Arm Length</em> to <em>1000</em> .  So we move the camera away by 1000 units from the mesh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40d/90e/4a7/40d90e4a791470dd84b66dd352ec6edc.jpg"></div><br>  Then you need to set the Default Pawn Class to use our Pawn.  Click on <em>Compile</em> and return to the editor.  Open <em>World Settings</em> and set the <em>Default Pawn</em> value to <em>BP_Player</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/64f/a25/02f64fa25c4ee4e325f06f1c5895fbea.jpg"></div><br>  Click on <em>Play</em> to see the pawn in the game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/da3/bce/e1fda3bce1ec3c3654adbb93e4730d7b.jpg"></div><br>  The next step is to add features to the player so that he can move. <br><br><h2>  Implementation of the movement </h2><br>  Instead of adding displacement for motion, we will move with the help of physics!  First we need a variable indicating the magnitude of the force applied to the ball. <br><br>  Return to Visual Studio and open <em>BasePlayer.h</em> .  Add the following after the variable components: <br><br><pre> <code class="cs hljs">UPROPERTY(EditAnywhere, BlueprintReadWrite) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> MovementForce;</code> </pre> <br>  <code>EditAnywhere</code> allows <code>EditAnywhere</code> to change the <code>MovementForce</code> in the Details panel.  <code>BlueprintReadWrite</code> will allow you to set and read the <code>MovementForce</code> using Blueprint nodes. <br><br>  Next we need to create two functions.  One for moving up and down, the other for moving left and right. <br><br><h3>  Creating motion functions </h3><br>  Add the following function declarations under <code>MovementForce</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  We will later bind the axle <em>mapping</em> to these functions.  Due to this, axis bindings will be able to transfer their <em>scale</em> (therefore, the function needs the <code>float Value</code> parameter). <br><br><blockquote>  <em>Note:</em> If you are unfamiliar with axis and scale bindings, check out the <a href="https://habrahabr.ru/post/344446/">Blueprints</a> tutorial. </blockquote><br>  Now we need to create an implementation for each function.  Open <em>BasePlayer.cpp and</em> add the following to the end of the file: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ABasePlayer::MoveUp(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Value) { FVector ForceToAdd = FVector(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) * MovementForce * Value; Mesh-&gt;AddForce(ForceToAdd); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ABasePlayer::MoveRight(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Value) { FVector ForceToAdd = FVector(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) * MovementForce * Value; Mesh-&gt;AddForce(ForceToAdd); }</code> </pre> <br>  <code>MoveUp()</code> adds physical strength for <code>Mesh</code> along <em>the x axis</em> .  The magnitude of the force is given by the <code>MovementForce</code> .  By multiplying the result by <code>Value</code> (axis binding scale), the mesh can move in <em>positive</em> or <em>negative</em> directions. <br><br>  <code>MoveRight()</code> does the same thing as <code>MoveUp()</code> , but along <em>the Y axis</em> . <br><br>  Having completed the creation of motion functions, we must associate axes with them. <br><br><h3>  Linking axis bindings to functions </h3><br>  For the sake of simplicity, I have already created the axis bindings.  They are in the <em>Project Settings</em> , in the <em>Input</em> section. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cc/d5f/00c/3ccd5f00c1823ed19d237dd6a7a7cdf6.jpg"></div><br><blockquote>  <em>Note:</em> Axis bindings are not required to have the same name as the functions with which we associate them. </blockquote><br>  Add the following code inside <code>SetupPlayerInputComponent()</code> : <br><br><pre> <code class="hljs kotlin">InputComponent-&gt;BindAxis(<span class="hljs-string"><span class="hljs-string">"MoveUp"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;ABasePlayer::MoveUp); InputComponent-&gt;BindAxis(<span class="hljs-string"><span class="hljs-string">"MoveRight"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;ABasePlayer::MoveRight);</code> </pre> <br>  So we will bind the bindings of the <em>MoveUp</em> and <em>MoveRight axes</em> to <code>MoveUp()</code> and <code>MoveRight()</code> . <br><br>  At this point we are done with the functions of the movement.  Now we need to enable physics for the <em>Mesh</em> component. <br><br><h3>  Turning on physics </h3><br>  Add the following lines to <code>ABasePlayer()</code> : <br><br><pre> <code class="hljs lisp">Mesh-&gt;SetSimulatePhysics(<span class="hljs-name"><span class="hljs-name">true</span></span>)<span class="hljs-comment"><span class="hljs-comment">; MovementForce = 100000;</span></span></code> </pre> <br>  The first line will allow <code>Mesh</code> to influence physical forces.  The second line sets the <code>MovementForce</code> value to <em>100,000</em> .  This means that as the ball moves, 100,000 strength will be added.  By default, physical objects weigh about 110 kilograms, so moving them takes a lot of power! <br><br>  If we create a subclass, some properties will not change, even if we change them in the base class.  In our case, <em>BP_Player</em> will not enable <em>Simulate Physics</em> .  However, now in all created subclasses it will be enabled by default. <br><br>  Compile and return to the Unreal Engine.  Open <em>BP_Player</em> and select the <em>Mesh</em> component.  Then turn on <em>Simulate Physics</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/ccf/6d3/18dccf6d330a8e221d8e0fbabfff8d4e.jpg"></div><br>  Click <em>Compile</em> , and then on <em>Play</em> .  Press <em>W</em> , <em>A</em> , <em>S</em> and <em>D</em> to move the ball. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/1c4/759/0951c475999df77679fe5d478097cc03.gif"></div></div></div><br>  Next, we declare a C ++ function that can be implemented using Blueprints.  This will allow designers to create functionality without using C ++.  To learn this, we will create a jump function. <br><br><h2>  Creating a jump function </h2><br>  First we need to bind the jump to the function binding.  In this tutorial we will assign a jump to <em>the space bar</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/415/839/a38415839528c87d56d8dca951a68e9a.jpg"></div><br>  Return to Visual Studio and open <em>BasePlayer.h</em> .  Add the following lines under <code>MoveRight()</code> : <br><br><pre> <code class="hljs cs">UPROPERTY(EditAnywhere, BlueprintReadWrite) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> JumpImpulse; UFUNCTION(BlueprintImplementableEvent) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Jump</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  The first is the float variable named <code>JumpImpulse</code> .  We can use it in the implementation of the jump.  It uses <code>EditAnywhere</code> so that it can be edited in the editor.  It also uses <code>BlueprintReadWrite</code> so that we can read and write it using Blueprint nodes. <br><br>  Next comes the jump function.  <code>UFUNCTION()</code> makes <code>Jump()</code> visible to the reflection system.  <code>BlueprintImplementableEvent</code> allows Blueprints to implement <code>Jump()</code> .  If the implementation is absent, then <code>Jump()</code> calls will lead to nothing. <br><br><blockquote>  <em>Note:</em> If you want to create a default implementation in C ++, use <code>BlueprintNativeEvent</code> .  Below we describe how to do this. </blockquote><br>  Since <em>Jump</em> is an <em>action</em> binding, the binding method is slightly different.  Close <em>BasePlayer.h</em> and open <em>BasePlayer.cpp</em> .  Add the <code>SetupPlayerInputComponent()</code> to <code>SetupPlayerInputComponent()</code> : <br><br><pre> <code class="hljs lisp">InputComponent-&gt;BindAction(<span class="hljs-string"><span class="hljs-string">"Jump"</span></span>, IE_Pressed, this, <span class="hljs-symbol"><span class="hljs-symbol">&amp;ABasePlayer</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:Jump</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  So we will associate the <em>Jump</em> binding with <code>Jump()</code> .  It will be executed only when <em>you</em> press the jump key.  If you want to execute it when you <em>release the</em> key, then use <code>IE_Released</code> . <br><br>  Next we will redefine <code>Jump()</code> in Blueprints. <br><br><h3>  Redefinition of functions in Blueprints </h3><br>  Compile and close <em>BasePlayer.cpp</em> .  Then go back to the Unreal Engine and open the <em>BP_Player</em> .  Go to the My Blueprints panel and hover your mouse over the <em>Functions</em> so that the <em>Override</em> drop-down list appears.  Click on it and select <em>Jump</em> .  So we will create an <em>event jump</em> . <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9c/c90/e25/d9cc90e2525b1c21ce5c2412f2515b67.gif"></div></div></div><br><blockquote>  <em>Note:</em> Overriding will be an event if there is no return type.  If the return type exists, it will be a function. </blockquote><br>  Next we will create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/721/8a8/dc87218a8efce98549e7ee0b5b464306.jpg"></div><br>  So we will add a <em>Mesh</em> impulse ( <em>JumpImpulse</em> ) along <em>the Z axis</em> .  Note that in this implementation the player can jump endlessly. <br><br>  Next we need to set the <em>JumpImpulse</em> value.  Click on <em>Class Defaults</em> in the Toolbar, and then go to the Details panel.  Set the <em>JumpImpulse</em> value to <em>100000</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/6fc/2e9/c646fc2e9b4c78bc02d03fc5efae4b74.jpg"></div><br>  Click on <em>Compile</em> , and then close <em>BP_Player</em> .  Click on <em>Play</em> and try to jump with the <em>spacebar</em> . <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21a/f39/4b6/21af394b68d0c5c8b122dd2d05a506ba.gif"></div></div></div><br>  In the next section, we will make the coins disappear on contact with the player. <br><br><h2>  Collecting coins </h2><br>  To handle collisions, we need to associate a function with an overlay event.  To do this, the function must meet two requirements.  The first is that the function must have the <code>UFUNCTION()</code> macro.  The second requirement is that the function must have the correct signature.  In this tutorial, we will use the <em>OnActorBeginOverlap</em> event.  This event requires the function to have the following signature: <br><br><pre> <code class="hljs lisp">FunctionName(<span class="hljs-name"><span class="hljs-name">AActor*</span></span> OverlappedActor, AActor* OtherActor)</code> </pre> <br>  Return to Visual Studio and open <em>BaseCoin.h</em> .  Add the following lines under <code>PlayCustomDeath()</code> : <br><br><pre> <code class="hljs lisp">UFUNCTION() void OnOverlap(<span class="hljs-name"><span class="hljs-name">AActor*</span></span> OverlappedActor, AActor* OtherActor)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  After binding, <code>OnOverlap()</code> will be executed when a different actor is overlaid.  <code>OverlappedActor</code> will be a coin, and <code>OtherActor</code> be another actor. <br><br>  Next, we need to implement <code>OnOverlap()</code> . <br><br><h3>  Implementation of overlays </h3><br>  Open <em>BaseCoin.cpp</em> and add the following to the end of the file: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ABaseCoin</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::OnOverlap(AActor</span></span>* <span class="hljs-selector-tag"><span class="hljs-selector-tag">OverlappedActor</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">AActor</span></span>* <span class="hljs-selector-tag"><span class="hljs-selector-tag">OtherActor</span></span>) { }</code> </pre> <br>  Since we want to recognize only player overlays, we need to bring <code>OtherActor</code> to <code>ABasePlayer</code> .  Before performing the cast, we need to add a header for the <code>ABasePlayer</code> .  Add the following to <code>#include "BaseCoin.h"</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#include "BasePlayer.h"</span></span></code> </pre> <br>  Now we need to perform a cast.  In the Unreal Engine, the cast can be done as follows: <br><br><pre> <code class="cs hljs">Cast&lt;TypeToCastTo&gt;(ObjectToCast);</code> </pre> <br>  If the cast is successful, it will return a pointer to <code>ObjectToCast</code> .  If unsuccessful, it will return <code>nullptr</code> .  By checking the result on <code>nullptr</code> , we can determine if the object had the desired type. <br><br>  Add the <code>OnOverlap()</code> to <code>OnOverlap()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Cast</span></span>&lt;ABasePlayer&gt;(OtherActor) != nullptr) { Destroy(); }</code> </pre> <br>  Now that <code>OnOverlap()</code> is executed, it will check if <code>OtherActor</code> type <code>ABasePlayer</code> .  If so, then it will destroy the coin. <br><br>  Next we need to bind <code>OnOverlap()</code> . <br><br><h3>  Binding overlay function </h3><br>  To associate a function with an overlay event, we need to use the <code>AddDynamic()</code> event.  Add the <code>ABaseCoin()</code> to <code>ABaseCoin()</code> : <br><br><pre> <code class="hljs kotlin">OnActorBeginOverlap.AddDynamic(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;ABaseCoin::OnOverlap);</code> </pre> <br>  So we associate <code>OnOverlap()</code> with the <em>OnActorBeginOverlap</em> event.  This event always happens when the actor is superimposed on another actor. <br><br>  Compile and return to the Unreal Engine.  Click <em>Play</em> and start collecting coins.  Upon contact with the coin, it will be destroyed, which leads to its disappearance. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60a/9e7/08b/60a9e708ba790d3b2153cea0a14dbc51.gif"></div></div></div><br><blockquote>  <em>Note:</em> If the coins do not disappear, try restarting the editor to complete full recompilation.  Some changes require a restart to work. </blockquote><br>  In the next section, we will create another overridden C ++ function.  However, this time we will also create a default implementation.  To demonstrate this, we will use <code>OnOverlap()</code> . <br><br><h2>  Create default function implementation </h2><br>  To create a function with a default implementation, you need to use the <code>BlueprintNativeEvent</code> handle.  Return to Visual Studio and open <em>BaseCoin.h</em> .  Add for <code>OnOverlap()</code> <br>  in <code>UFUNCTION()</code> <code>BlueprintNativeEvent</code> : <br><br><pre> <code class="cs hljs">UFUNCTION(BlueprintNativeEvent) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">AActor* OverlappedActor, AActor* OtherActor</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  To make the function the default implementation, we need to add the <code>_Implementation</code> suffix.  Open <em>BaseCoin.cpp</em> and replace <code>OnOverlap</code> with <code>OnOverlap_Implementation</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ABaseCoin::OnOverlap_Implementation(AActor* OverlappedActor, AActor* OtherActor)</code> </pre> <br>  Now if the child Blueprint does not implement <code>OnOverlap()</code> , then this implementation will be used. <br><br>  The next step is to implement <code>OnOverlap()</code> in <em>BP_Coin</em> . <br><br><h3>  Creating an implementation in Blueprint </h3><br>  To implement in Blueprint, we will call <code>PlayCustomDeath()</code> .  This C ++ feature will increase the rotational speed of the coin.  After 0.5 seconds, the coin will destroy itself. <br><br>  To call the C ++ function from Blueprints, we need to use the <code>BlueprintCallable</code> handle.  Close <em>BaseCoin.cpp</em> and open <em>BaseCoin.h</em> .  Add the <code>PlayCustomDeath()</code> : <br><br><pre> <code class="cs hljs">UFUNCTION(BlueprintCallable)</code> </pre> <br>  Compile and exit Visual Studio.  Return to the Unreal Engine and open <em>BP_Coin</em> .  Override <em>On Overlap</em> and create the following schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72f/78b/b40/72f78bb403a67f6a63d479375d578adb.jpg"></div><br>  Now when a player overlays a coin, <em>Play Custom Death</em> will be performed. <br><br>  Click on <em>Compile</em> and close <em>BP_Coin</em> .  Click <em>Play</em> and collect some coins to test the new implementation. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f1/062/5c4/3f10625c4f81d5a4803f89cf027bbed2.gif"></div></div></div><br><h2>  Where to go next? </h2><br>  You can download the finished project <a href="">from here</a> . <br><br>  As you can see, working with C ++ in the Unreal Engine is quite simple.  Although we have already achieved something in C ++, you still need to learn a lot!  I recommend exploring Epic's tutorial series on creating <a href="https://www.youtube.com/watch%3Fv%3DNyXq0Hy9xQs%26amp%3Blist%3DPLZlv_N0_O1gaz3ydgU5wt6c_JtJzwXUKW">a top-down shooter</a> using C ++. <br><br>  If you're new to the Unreal Engine, then learn our ten-part <a href="https://habrahabr.ru/post/344394/">beginner tutorial series</a> .  In this series, you will learn about various systems such as Blueprints, materials, and particle systems. </div><p>Source: <a href="https://habr.com/ru/post/348600/">https://habr.com/ru/post/348600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348590/index.html">What is not written in the documentation, or the subtleties of refactoring on .Net Core</a></li>
<li><a href="../348592/index.html">Fintech Digest: eBay vs. PayPal, the international payment system on the blockchain</a></li>
<li><a href="../348594/index.html">Internet people and non-people</a></li>
<li><a href="../348596/index.html">Traffic Management with Fiddler</a></li>
<li><a href="../348598/index.html">5 best countries for IT business</a></li>
<li><a href="../348602/index.html">Using Boost.Asio with Coroutines TS</a></li>
<li><a href="../348604/index.html">What happened to the manufacturers of ITSM solutions in 2017 (Gartner report)</a></li>
<li><a href="../348606/index.html">The transition from AngularJS to Angular: life after AngularJS (3/3)</a></li>
<li><a href="../348610/index.html">Html-sketchapp - a pledge of unity of programmers and designers</a></li>
<li><a href="../348612/index.html">Javascript es6: extension operator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>