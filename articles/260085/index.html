<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write SSL tunnel in python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There was a problem: there is a Windows application that makes HTTPS requests to the server and receives responses. After updating the server, the app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write SSL tunnel in python</h1><div class="post__text post__text-html js-mediator-article">  There was a problem: there is a Windows application that makes HTTPS requests to the server and receives responses.  After updating the server, the application stopped working.  It turned out that the SSL version was changed on the server (switched from SSLv3 to TLSv1), and our application can work only over SSLv3.  Nobody supports the application for a long time and did not want to change, recompile, test.  It was decided to make a layer between the application and the server, which will translate SSLv3 to TLSv1 and vice versa.  I looked for some proxy on the Internet, but I didn‚Äôt find it right away (I was looking badly).  I decided to make a proxy on python.  I am not a professional in python, but it seemed to me that it is well suited for this task, and it is interesting in parallel to study python using the example of a real problem. <br><a name="habracut"></a><br>  <b>Start</b> <br><br>  So, set the python 3.4.  We write a script, I used a notepad for this.  For ssl sockets, you need an ssl module.  For, in fact, sockets socket. <br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ssl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket</code> </pre> <br>  We create the socket listening to the client since  this will be an SSL server, you will have to create a self-signed certificate for it, which it will provide to the client.  To create a certificate, I used the openssl utility.  I downloaded the utility from here <a href="http://indy.fulgan.com/SSL/">indy.fulgan.com/SSL</a> .  To create a certificate, you will need a config for the utility, an example here is <a href="">web.mit.edu/crypto/openssl.cnf</a> .  Put the config in a folder on the computer and set the path to it (hereinafter all the actions on the command line): <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> OPENSSL_CONF=__\openssl.cnf</code> </pre><br>  Generate private key <br><pre> <code class="bash hljs">openssl genrsa -des3 -out server.key 1024</code> </pre><br>  Along the way, it will be proposed to enter the password to the key and confirm the password, enter.  Create a certificate request <br><pre> <code class="bash hljs">openssl req -new -key server.key -out server.csr</code> </pre><br>  When generating a request, we will need to enter the key password and fill in information about the company, city, country, etc.  Fill.  In order to use the key without a password, copy it and unload it. <br><pre> <code class="bash hljs">copy server.key server.key.org openssl rsa -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server.key.org -out server.key</code> </pre><br>  Finally, create a self-signed certificate. <br><pre> <code class="bash hljs">openssl x509 -req -days 365 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server.csr -signkey server.key -out server.crt</code> </pre><br>  For convenience, we put our certificate and key next to the python script.  We create a socket that will listen to the client and set it to listen to the port on which our application will go (hereinafter code in python) <br><pre> <code class="python hljs">sock = ssl.wrap_socket(socket.socket(), <span class="hljs-string"><span class="hljs-string">'server.key'</span></span>, <span class="hljs-string"><span class="hljs-string">'server.crt'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) sock.bind( (<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">43433</span></span>) ) sock.listen(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br>  We receive incoming connection and request from the client <br><pre> <code class="python hljs">conn, addr = sock.accept() data = conn.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>)</code> </pre><br>  Next, we need to send the received data to the server to which they were intended.  We create for this a socket and a helmet data in it. <br><pre> <code class="python hljs">serv = ssl.wrap_socket(socket.socket()) serv.connect( (<span class="hljs-string"><span class="hljs-string">'server_url'</span></span>, <span class="hljs-number"><span class="hljs-number">443</span></span>) ) serv.send(data)</code> </pre><br>  So, the request was sent, now we need to get answers and give it to our client <br><pre> <code class="python hljs">data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) conn.send(data)</code> </pre><br>  Well, all our proxy is ready, we launch, we throw the request - it does not work!  To find out why, let's add logging. <br><br>  <b>Logging</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will connect the logging module, configure the logging configuration and add logging to interesting places. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging logging.basicConfig(filename = <span class="hljs-string"><span class="hljs-string">"proxy.log"</span></span>, level = logging.DEBUG, format = <span class="hljs-string"><span class="hljs-string">"%(asctime)s - %(message)s"</span></span>) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); conn, addr = sock.accept() logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>) data = conn.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) logging.info(data) logging.info(<span class="hljs-string"><span class="hljs-string">"   "</span></span>) serv.send(data) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) logging.info(data) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) client.send(resp)</code> </pre><br><br>  <b>Read all data</b> <br><br>  It turned out that the client transmits the data in blocks, i.e.  we did not read the full request.  Then it turns out that the server also gives a block response.  We will improve our code to read the request and the answer by blocks.  To do this, we create a buffer in which we will add the entire request, set the socket a timeout of 0.1 seconds, which it will wait for the data from the incoming connection and read in the loop and add the data to the buffer.  If there is no data, we will get an exception and exit the loop. <br><pre> <code class="python hljs">logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>) data = conn.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) req = <span class="hljs-string"><span class="hljs-string">b''</span></span> conn.settimeout(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data: req += data <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: data = conn.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(req)</code> </pre><br>  The same for reading data from the server <br><pre> <code class="python hljs">logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) resp = <span class="hljs-string"><span class="hljs-string">b''</span></span> serv.settimeout(<span class="hljs-number"><span class="hljs-number">1</span></span>) data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data: resp += data <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(resp)</code> </pre><br>  Change the data that will be sent to the server and client <br><pre> <code class="python hljs">logging.info(<span class="hljs-string"><span class="hljs-string">"   "</span></span>) serv.send(req) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) client.send(resp)</code> </pre><br>  We start.  Now it works, but you have to run the script with each request to the server, which is not very convenient. <br><br>  <b>Handling multiple requests</b> <br><br>  We will improve the script, after processing the request, we will again listen to the socket <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); conn, addr = sock.accept() logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>) data = conn.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) req = <span class="hljs-string"><span class="hljs-string">b''</span></span> conn.settimeout(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data: req += data <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: data = conn.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(req) logging.info(<span class="hljs-string"><span class="hljs-string">"   "</span></span>) serv.send(req) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) resp = <span class="hljs-string"><span class="hljs-string">b''</span></span> serv.settimeout(<span class="hljs-number"><span class="hljs-number">1</span></span>) data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data: resp += data <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(resp) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) client.send(resp)</code> </pre><br>  This will work, but there is a problem - we have an endless loop from which the program cannot exit normally.  To exit, you can use the keyboard interrupt Ctrl + C and send a request, after which the program ends with the exception KeyboardInterrupt. <br><br>  <b>Service stop</b> <br><br>  In order to provide a more or less normal output, I decided to send a STOP to the socket, this will be the final control command.  Let's write a handler for such a command.  To do this, we need to modify the code reading from the client socket.  We get the first four bytes and if they are STOP, we interrupt the cycle. <br><pre> <code class="python hljs"> logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>) data = conn.recv(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data == <span class="hljs-string"><span class="hljs-string">b'STOP'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span></code> </pre><br>  Let's write a function to stop our proxy.  We will create a socket (ssl) in it and send STOP to our proxy <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">""</span></span>); me = ssl.wrap_socket(socket.socket()) me.connect( (<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">43433</span></span>) ) me.send(<span class="hljs-string"><span class="hljs-string">b'STOP'</span></span>) me.close()</code> </pre><br>  To run the STOP command, we will use the command line parameter.  If you passed the stop line on the command line, then we will call our stop () function (We place this code and the stop function at the beginning, after setting the logging format). <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">"stop"</span></span>: stop();</code> </pre><br>  Now we can stop our proxy with the same script.  To stop the server startup code from running after the stop, wrap the main code in the run function, we‚Äôll get <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    -   def stop(): #    if len(sys.argv) &gt; 1: if sys.argv[1] == "stop": stop(); else: print("  ", sys.argv[1]) else: run()</span></span></code> </pre><br>  At the same time processed the case with the wrong command. <br><br>  <b>Demonization</b> <br><br>  There is a problem, when launching our proxy, the application will hang on the command line, at first glance it seems that it is hanging.  To solve this problem let's make a demon.  Since  we have Windows, then the daemon is done here by running the process without a window, this code will be non-platform.  So, let's write the daemonize () function. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">daemonize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>); subprocess.Popen(<span class="hljs-string"><span class="hljs-string">"py proxy.py"</span></span>, creationflags=<span class="hljs-number"><span class="hljs-number">0x08000000</span></span>, close_fds=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre><br>  Here creationflags = 0x08000000, setting the CREATE_NO_WINDOW flag for the process.  We will start our service in daemon mode if we send start on the command line <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">"stop"</span></span>: stop(); <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">"start"</span></span>: daemonize(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>, sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: run()</code> </pre><br>  Now we can start our service in daemon mode and stop. <br><br>  <b>Multitasking</b> <br><br>  Another small touch, we add the ability to handle multiple clients, for this we take out our code of work with the client in a separate function <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client_run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(client, data)</span></span></span><span class="hljs-function">:</span></span> req = <span class="hljs-string"><span class="hljs-string">b''</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>) client.settimeout(<span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data: req += data <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: data = client.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(req) serv = ssl.wrap_socket(socket.socket()) serv.connect( (<span class="hljs-string"><span class="hljs-string">'server_name'</span></span>, <span class="hljs-number"><span class="hljs-number">443</span></span>) ) logging.info(<span class="hljs-string"><span class="hljs-string">"   "</span></span>) serv.send(req) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) resp = <span class="hljs-string"><span class="hljs-string">b''</span></span> serv.settimeout(<span class="hljs-number"><span class="hljs-number">1</span></span>) data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data: resp += data <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: data = serv.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> socket.error: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(resp) logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) client.send(resp)</code> </pre><br>  And in the main function, we will run client_run in a separate thread, since  we installed socket.listen (10), then at the same time we can have up to 10 threads <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); sock = ssl.wrap_socket(socket.socket(), <span class="hljs-string"><span class="hljs-string">'server.key'</span></span>, <span class="hljs-string"><span class="hljs-string">'server.crt'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) sock.bind( (<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">43433</span></span>) ) sock.listen(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: logging.info(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); conn, addr = sock.accept() data = conn.recv(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data == <span class="hljs-string"><span class="hljs-string">b'STOP'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">" "</span></span>) t = threading.Thread(target = client_run, args = ( conn, data ) ) t.run() logging.info(<span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre><br>  Now our proxy service is ready. <br><br>  PS: Later, my colleague suggested to me that for my task you can use stunnel, and I decided to put it, and put the script here, all of a sudden it will be interesting to anyone.  Config for stunnel this: <br><pre> <code class="hljs pgsql">[client-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>] sslVersion = SSLv3 accept = <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">43433</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> = <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>] sslVersion = TLSv1 client = yes accept = <span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> = server_name:<span class="hljs-number"><span class="hljs-number">443</span></span></code> </pre><br>  With stunnel also had to tinker, because  there were incorrect settings on the server and SNI verification did not pass, it only worked with version 4.36, since  there is no such verification. <br><br>  Sources on github <a href="https://github.com/sesk/py_proxy">github.com/sesk/py_proxy</a> </div><p>Source: <a href="https://habr.com/ru/post/260085/">https://habr.com/ru/post/260085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260071/index.html">Charm Solitaire game defense study</a></li>
<li><a href="../260073/index.html">The construction of Bitcoin data centers continues, despite the fall in the cost of cryptocurrency</a></li>
<li><a href="../260077/index.html">WWDC15. Third day. Interesting</a></li>
<li><a href="../260081/index.html">On the organization of the workflow of the photographer. (Comparing with the opinion of the magazine What Digital Camera)</a></li>
<li><a href="../260083/index.html">Calculate Pi using Intel Threading Building Blocks</a></li>
<li><a href="../260087/index.html">‚ÄúTabtabus 2015‚Äù - do you need it?</a></li>
<li><a href="../260089/index.html">Mobile applications and the main factors of freemium monetization. Part 1</a></li>
<li><a href="../260091/index.html">Freemium in mobile applications. The story of one failure and one success</a></li>
<li><a href="../260093/index.html">Once again about the design of the mobile application. What color to choose for your program's icon?</a></li>
<li><a href="../260095/index.html">Mobile app design. How to achieve optimal results?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>