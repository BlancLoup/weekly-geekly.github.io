<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dilute asynchronous programming functionality on Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings In this article, it will be shown how, having the usual Futures in hand, to make in scala a similarity to corutin and asynchronous stream-s....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dilute asynchronous programming functionality on Scala</h1><div class="post__text post__text-html js-mediator-article">  Greetings  In this article, it will be shown how, having the usual Futures in hand, to make in scala a similarity to corutin and asynchronous stream-s.  A sort of small tutorial on functional programming. <br><br><h3>  What is it and why </h3><br><div class="spoiler">  <b class="spoiler_title">What is the future of human language</b> <div class="spoiler_text">  Future is an entity that describes the result of some calculations, which we will receive not immediately, but in the future.  But there is one feature: often we, not knowing the result, know exactly what we are going to do with it.  For example, we asked the server for some kind of config, and now we have Future [Config].  We haven‚Äôt received the config itself yet, but we know for sure that when we receive it, we‚Äôll get the address from it and ask the server for a picture at this address (config =&gt; Future [Image]).  And Future [Config] is capable of changing in such a way that instead of a config, and then pictures can <i>immediately</i> get a <i>picture</i> .  Entities that can be combined in this way are called <i>monads</i> . <br></div></div><br>  Unfortunately, a simple sequential combination of 2 or more asynchronous operations (download the config, and then the picture at the address from the config as an example) is all that ordinary Future as monads are capable of.  They do not allow either to save state, or to do cycles from asynchronous operations, nor to produce several (or infinitely many) values.  These are the shortcomings we are going to do now. <br><br>  Let's present for definiteness a certain widget.  It waits for a config that is updated at regular intervals, loads a value (for example, temperature) at the address from the config, and draws on the screen the current value, minimum, maximum, average, and so on.  And it does everything in a loop, and even asynchronously. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Applying the knowledge from this article, we can describe this process like this: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  'FState' - ,    ,   -   Future def getNextConfig: FState[Config] def getTemperature(from: String): FState[Int] case class State(temperature: Int, sumTemp: Long, count: Int) { def isGood = ... } //  ,      , //       val handle = while_ ( _.isGood) { for ( config &lt;- getNextConfig(); if (config.isDefined); //   -   nextValue &lt;- getTemperature(config().source); //    state &lt;- gets[State]; //      newState = State(nextValue, state.sumTemp + nextValue, state.count + 1); _ &lt;- puts(newState); // ..    _ &lt;- runInUiThread { drawOnScreen(newState) } ) yield() }</span></span></code> </pre> <br></div></div><br>  Or like this: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> configs: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">Config</span></span>] = ... <span class="hljs-comment"><span class="hljs-comment">//  - stream  def getTemperature(from: String): FState[Int] case class State(temperature: Int, sumTemp: Long, count: Int) //    ,    'getNextConfig' // ,  ,    - stream   val handle = foreach(configs) { config =&gt; for ( nextValue &lt;- getTemperature(config().source); //    state &lt;- gets[State]; //      newState = State(nextValue, state.sumTemp + nextValue, state.count + 1); _ &lt;- puts(newState); // ..    _ &lt;- runInUiThread { drawOnScreen(newState) } ) yield() }</span></span></code> </pre><br></div></div><br>  Anyone who is interested, please under the cat. <br><a name="habracut"></a><br><h3>  Stateful asynchronous computations </h3><br>  This is such a Future, which allows you to save and change the state of the pseudo-algorithm inside the for-construction, the very gets [State] and puts [State].  And the fact that gives this very pseudo-algorithm some kind korutinoobraznoe. <br><br>  Let's look at this interesting entity: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// S -   , A -   case class FState[S, +A](func: S =&gt; Future[(A, S)]) { def apply(s: S) = func(s) }</span></span></code> </pre><br>  As you can see, this is a simple wrapper over a function that takes the current state and returns Future to the result together with the new state.  The view of this entity is obtained by a simple combination of the Future and State monads (and what we are doing now is called the monad transformer). <br><br>  Let's teach this entity to be a monad.  In principle, it is enough for us to determine the unit and flatMap operations for this entity (and also the map, which is expressed in the first two), but we will immediately go through the thorny scalaz, and we will receive a bonus algebra of operations defined in terms of these two. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FStateMonad</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">[({ type f[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">X</span></span>]})#f] { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">X</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](a: =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](m: <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>]): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FStateMonad</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">[({ type f[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">X</span></span>]})#f] { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">X</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](a: =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">FState</span></span>((s: <span class="hljs-type"><span class="hljs-type">S</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>((a, s))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](m: <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>]): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-type"><span class="hljs-type">FState</span></span>((s: <span class="hljs-type"><span class="hljs-type">S</span></span>) =&gt; m(s) flatMap { pair =&gt; f(pair._1)(pair._2) }) }</code> </pre><br></div></div><br>  For example, we just received for free such a completely magnificent operation: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//        - ! def whileM_[A](p: F[Boolean], body: =&gt; F[A]): F[Unit]</span></span></code> </pre><br>  But how to change the state inside the pseudo-algorithm?  We can see that it does not appear in the <i>bind</i> combinator.  We write: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gets</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>](): <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>](news: <span class="hljs-type"><span class="hljs-type">S</span></span>): <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,     ,   //  ""  . def gets[S](): FState[S, S] = FState((s: S) =&gt; Future((s, s))) //      def puts[S](news: S): FState[S, S] = FState((_: S) =&gt; Future((news, news)))</span></span></code> </pre><br></div></div><br>  That's basically it!  Now we can write something like: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FStateMonad</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//  -  Int //       10... val algo = for( _ &lt;- m.whileM_(gets[Int] map (_ &lt; 10), for( i &lt;- gets[Int]; _ &lt;- puts(i + 1) ) yield(())); v1 &lt;- gets[Int] ) yield (v1) // algo(0)() should be ((10, 10))</span></span></code> </pre><br>  But we can write ourselves as much syntactic sugar as we want, and end up with something like this: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FStateMonad</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//  -  Int val algo = for( //   for,  ,     _ &lt;- m.forM_ ( _ &lt; 10, _ + 1) { //   FState }; v1 &lt;- gets[Int] ) yield (v1) // algo(0)() should be ((10, 10))</span></span></code> </pre><br><h3>  Asynchronous stream </h3><br>  This is just such a Future that can return more than one value asynchronously.  In the second example, at the beginning of the article, we simply iterate over this stream with a stateful pseudo-algorithm.  However, with stream th you can do some more different interesting things, but let's order.  Let's start by building a stream. <br><br>  What is stream?  Simplified - a list with a tail calculated lazily.  Consequently, it can be infinite.  Our asynchronous AsyncStream will look something like this: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">fp: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, sp: =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> first = fp <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> second = sp } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](first: <span class="hljs-type"><span class="hljs-type">A</span></span>, second: =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Pair</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](first, second) } <span class="hljs-comment"><span class="hljs-comment">//  stream-   Future(null),     // -  Future-,  -  . //       Option-,    null. case class AsyncStream[A](data: Future[Pair[A, AsyncStream[A]]])</span></span></code> </pre><br>  So, everything seems to be simple: asynchronously we return the value and the tail, and the laziness of the tail should keep us from stackoverflow when using infinite streams. <br><br>  But the streams have one very attractive feature: they can be minimized!  We write: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   foldLeft,   Future[B] // -       def foldLeft[B](start: B)(f: (B, A) =&gt; B): Future[B]</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foldLeft</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](start: <span class="hljs-type"><span class="hljs-type">B</span></span>)(f: (<span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = { <span class="hljs-comment"><span class="hljs-comment">// ,    ,  //   data def impl(d: Future[Pair[A, AsyncStream[A]]], acc: Future[B]): Future[B] = d flatMap (pair =&gt; { if (pair eq null) acc else impl(pair.second.data, acc map (b =&gt; f(b, pair.first))) }) impl(data, Future(start)) }</span></span></code> </pre><br></div></div><br>  You can still collapse like this: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatten</span></span></span><span class="hljs-function"> </span></span>: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatten</span></span></span><span class="hljs-function"> </span></span>: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = foldLeft[<span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]](<span class="hljs-type"><span class="hljs-type">Nil</span></span>)((list, el) =&gt; el :: list) map (_.reverse)</code> </pre><br></div></div><br>  Another couple of useful functions, mainly for working with endless streams: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span></span>(p: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span>): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span></span>(n: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeWhile</span></span></span></span>(p: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span>): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](data map (pair =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pair eq <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p(pair.first)) <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Pair</span></span>(pair.first, pair.second.takeWhile(p)) })) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span></span>(n: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) nil <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](data map (pair =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pair eq <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Pair</span></span>(pair.first, pair.second.take(n - <span class="hljs-number"><span class="hljs-number">1</span></span>)) }))</code> </pre><br></div></div><br>  We have learned to turn off, but to build such a stream is still inconvenient.  Fix it and write a generic stream generator: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// 'gen'   -,    // Future(null),       def genAsyncStream[S,A](start: S)(gen: S =&gt; Future[(A, S)]): AsyncStream[A]</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">genAsyncStream</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>,<span class="hljs-type"><span class="hljs-type">A</span></span>](start: <span class="hljs-type"><span class="hljs-type">S</span></span>)(gen: <span class="hljs-type"><span class="hljs-type">S</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>[(<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>)]): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]( gen(start) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _: <span class="hljs-type"><span class="hljs-type">NoFuture</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> future =&gt; future map (pair =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Future[Pair[A, AsyncStream]] if (pair eq null) null else Pair(pair._1, genAsyncStream(pair._2)(gen)) })})</span></span></code> </pre><br></div></div><br>  By the way, with the help of <i>foldLeft</i> + <i>genAsyncStream streams</i> can be copied. <br><br>  Stream-s can be connected: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](s1: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>], s2: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](s1: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>], s2: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](s1.data flatMap (pair =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pair eq <span class="hljs-literal"><span class="hljs-literal">null</span></span>) s2.data <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Future</span></span>(<span class="hljs-type"><span class="hljs-type">Pair</span></span>(pair.first, concat(pair.second, s2))) }))</code> </pre><br></div></div><br>  And asynchronous stream is also a monad: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncStreamMonad</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncStream</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](a: =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]( ma: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>]): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncStreamMonad</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AsyncStream</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](a: =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = unit(a) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]( ma: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>]): <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](ma.data flatMap (pair =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pair eq <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-type"><span class="hljs-type">Future</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> f(pair.first).data map ( pair2 =&gt; <span class="hljs-type"><span class="hljs-type">Pair</span></span>(pair2.first, concat(pair2.second, bind(pair.second)(f)))) })) }</code> </pre><br></div></div><br>  Basically, the construction of asynchronous stream can be completed. <br><br><h3>  FState + AsyncStream =? </h3><br>  In fact, they get along fine.  Let's look at the generator function in <i>genAsyncStream</i> , nothing like?  Yes, it's FState! <br><br>  Now let's learn how to iterate over stream: <br><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">S</span></span>] (stream: <span class="hljs-type"><span class="hljs-type">AsyncStream</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">FState</span></span>[<span class="hljs-type"><span class="hljs-type">S</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">answer</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   foldLeft- def foreach[A, S] (stream: AsyncStream[A])(f: A =&gt; FState[S, Any]): FState[S, Unit] = FState(s =&gt; { stream.foldLeft(Future(s))( (futureS, a) =&gt; futureS.flatMap(s2 =&gt; f(a)(s2).map(_._2))).flatten.map( ((), _) ) })</span></span></code> </pre><br></div></div><br>  That is, we can quite calmly write a generator that yields values ‚Äã‚Äãto the asynchronous stream, then transfer this stream somewhere, and use it to iterate over another algorithm ‚Äî quite convenient, IMHO, when you need to transfer data from one program module to another and I do not want to introduce dependencies. <br><br><h3>  Total </h3><br>  As a result, we got a couple of entities that extend the capabilities of ordinary Future-s.  I hope it was interesting. <br>  Thanks for attention) <br><br>  The code is <a href="https://github.com/iboltaev/scala-async">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/281346/">https://habr.com/ru/post/281346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281334/index.html">Character regression and another approach</a></li>
<li><a href="../281338/index.html">Deploy ASP.NET applications with symbolic links</a></li>
<li><a href="../281340/index.html">6 reasons for the failure of the mobile game in the international market</a></li>
<li><a href="../281342/index.html">JavaScript goes beyond the Web in 2015</a></li>
<li><a href="../281344/index.html">What criteria are important for a large client when choosing an agency for web development?</a></li>
<li><a href="../281350/index.html">Haordic Organization Visa (Part 1)</a></li>
<li><a href="../281352/index.html">Superscalar Stacking Processor: Optimization</a></li>
<li><a href="../281354/index.html">Implementation of monitoring and integration testing information system using Scalatest. Part 2</a></li>
<li><a href="../281356/index.html">Simple automation of the management of acts of marriage on SharePoint with examples and pictures</a></li>
<li><a href="../281358/index.html">JetBrains is looking for a technical evangelist with Java experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>