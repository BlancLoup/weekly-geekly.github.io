<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Depth accuracy clearly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depth accuracy is a pain in the ass, which sooner or later any graphics programmer faces. Many articles and papers have been written on this topic. An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Depth accuracy clearly</h1><div class="post__text post__text-html js-mediator-article">  Depth accuracy is a pain in the ass, which sooner or later any graphics programmer faces.  Many articles and papers have been written on this topic.  And in different games and engines, and on different platforms, you can see a lot of different formats and settings for the <b>depth buffer</b> . <br><br>  The transformation of depth on the GPU does not seem obvious because of how it interacts with the perspective projection, and the study of equations does not clarify the situation.  To understand how this works, it is useful to draw some pictures. <br><br><img src="https://developer.nvidia.com/sites/default/files/styles/main_image/public/akamai/gameworks/blog/Depthprecision/graph.jpg?itok=tLMbXLov" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article is divided into 3 parts: <br><br><ol><li>  I will try to explain the motivation of the <b>nonlinear</b> depth conversion. </li><li>  I will present several graphs that will help you understand how nonlinear depth conversion works in different situations, intuitively and visually. </li><li>  Discussion of the main findings of <a href="http://www.geometry.caltech.edu/pubs/UD12.pdf">Tightening the Precision of Perspective Rendering</a> [Paul Upchurch, Mathieu Desbrun (2012)] concerning the effect of round-off floating-point error on depth accuracy. </li></ol><br><a name="habracut"></a><br><h2>  Why 1 / z? </h2><br>  Hardware GPU <b>depth buffer</b> usually does not store a linear representation of the distance between the object and the camera, contrary to what is naively expected from it at the first meeting.  Instead, depth buffer stores values ‚Äã‚Äãinversely proportional to the depth of the view-space.  I want to briefly describe the motivation for such a decision. <br><br>  In this article I will use <b>d</b> to represent the values ‚Äã‚Äãstored in the depth buffer (in the range [0, 1] for DirectX), and <b>z</b> to represent the depth view-space, i.e.  real distance from the camera, in world units, for example, meters.  In general, the relationship between them is as follows: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math1.jpg" alt="image"><br><br>  where <b>a, b</b> are constants associated with the near and far settings of the planes.  In other words, <b>d</b> is always some linear transformation from <b>1 / z</b> . <br><br>  At first glance it may seem that as <b>d</b> you can take any function of <b>z</b> .  So why does she look that way?  There are two main reasons for this. <br><br>  First, <b>1 / z</b> naturally fits into the perspective projection framework.  And this is the most basic class of transformations, which is guaranteed to keep straight.  Therefore, the perspective projection is suitable for hardware rasterization, since the straight edges of the triangles remain straight on the screen.  We can obtain a linear transformation from <b>1 / z</b> , taking advantage of the promising division, which the GPU already performs: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/math2.jpg" alt="image"><br><br>  Of course, the real strength of this approach is that the projection matrix can be multiplied with other matrices, allowing you to combine many transformations into one. <br><br>  The second reason is that <b>1 / z</b> is linear in the screen space (screen space), <a href="http://www.humus.name/index.php%3FID%3D255">as noted by Emil Persson</a> .  This makes it easy to interpolate d in a triangle during rasterization, and things like <b>hierarchical Z-buffers</b> , <b>early Z-culling</b> and <b>compression depth buffer</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Short from article</b> <div class="spoiler_text">  While the value of <b>w (view-space depth)</b> is linear in the view space, it is non-linear in the screen space.  <b>z (depth)</b> , non-linear in the view space, on the other hand, is linear in the screen space.  This can be easily verified with a simple DX10 shader: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dx = ddx(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dy = ddy(In.position.z); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1000.0</span></span> * float4(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dx), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(dy), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Here In.position is SV_Position.  The result looks something like this: <br><br><img src="http://www.humus.name/News/ZGradient.png" alt="image"><br><br>  Notice that all surfaces look monochrome.  The difference in <b>z</b> from pixel to pixel is the same for any primitive.  This is very important for the GPU.  One of the reasons is that <b>z</b> interpolation is cheaper than <b>w</b> interpolation.  For <b>z, it is</b> not necessary to perform a perspective correction.  With cheaper hardware units, you can handle more pixels per cycle with the same transistor budget.  Naturally, this is very important for the <b>pre-z pass</b> and <b>shadow map</b> .  With modern hardware, linearity in the screen space is also a very useful feature for z-optimizations.  Given that the gradient is linear for the entire primitive, it is also relatively easy to calculate the exact depth range within the tile for <b>Hi-z culling</b> .  This also means that <b>z-compression</b> is possible.  With the constant <b>Œîz</b> in <b>x</b> and <b>y,</b> you do not need to store a lot of information to be able to fully restore all <b>z</b> values ‚Äã‚Äãin the tile, provided that the primitive covered the entire tile. <br></div></div><br><h2>  Depth chart graphics </h2><br>  Equations are hard, let's look at a couple of pictures! <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph1.jpg" alt="image"><br><br>  The way to read these graphs: from left to right, then down.  Start with <b>d</b> on the left axis.  Since <b>d</b> can be an arbitrary linear transformation from <b>1 / z</b> , we can arrange 0 and 1 to any convenient place on the axis.  The marks indicate different <b>depth buffer</b> .  For the sake of clarity, I am modeling a 4-bit integer normalized <b>depth buffer</b> , so there are 16 evenly spaced marks. <br><br>  The graph above shows the ‚Äústandard‚Äù vanilla depth conversion in D3D and similar APIs.  You can immediately see how, due to the <b>1 / z</b> curve, the values ‚Äã‚Äãclose to the near plane are grouped, and the values ‚Äã‚Äãclose to the far plane are scattered. <br><br>  It is also easy to see why the near plane influences depth accuracy so much.  Distance to the near plane will lead to a rapid increase in <b>d</b> values ‚Äã‚Äãrelative to <b>z</b> values, which will lead to an even more uneven distribution of values: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph2.jpg" alt="image"><br><br>  Similarly, in this context, it is easy to see why moving a far plane to infinity does not have such a large effect.  It simply means extending the range <b>d</b> to <b>1 / z = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph3.jpg" alt="image"><br><br>  But what about floating-point depth?  The following graph adds marks corresponding to a float format with 3 bits of exponent and 3 bits of mantissa: <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph4.jpg" alt="image"><br><br>  Now in the range [0,1] there are 40 different values ‚Äã‚Äã- a little more than 16 values ‚Äã‚Äãearlier, but most of them are uselessly grouped close to the near plane (closer to 0, float has higher accuracy), where we really don‚Äôt need greater accuracy. <br><br>  Now a well-known trick is to invert the depth, displaying the near plane on <b>d = 1</b> and the far plane on <b>d = 0</b> : <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph5.jpg" alt="image"><br><br>  Much better!  Now the quasi-logarithmic distribution of float somehow compensates for the nonlinearity of <b>1 / z</b> , while closer to the near plane gives an accuracy similar to the integer depth buffer, and gives a much greater accuracy elsewhere.  The accuracy of the depth deteriorates very slowly if you move further away from the camera. <br><br>  The <b>reversed-Z</b> trick may have been reinvented independently several times, but at least the first mention was in <a href="https://dl.acm.org/citation.cfm%3Fid%3D311579">SIGGRAPH '99 paper</a> [Eugene Lapidous and Guofang Jiao (unfortunately not publicly available)].  And recently he was re-mentioned on the blog by <a href="https://mynameismjp.wordpress.com/2010/03/22/attack-of-the-depth-buffer/">Matt Petineo</a> and <a href="http://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html">Brano Kemen</a> , and in the speech of Emil Persson, <a href="http://www.humus.name/Articles/Persson_CreatingVastGameWorlds.pdf">Creating Vast Game Worlds</a> SIGGRAPH 2012. <br><br>  All previous graphics assumed the depth [0,1] range after projection, which is an agreement in D3D.  What about <b>OpenGL</b> ? <br><br><img src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/blog/Depthprecision/graph6.jpg" alt="image"><br><br>  <b>OpenGL</b> defaults to the depth [-1, 1] range after projection.  For integer formats, nothing changes, but for a floating point all accuracy is concentrated in the middle uselessly.  (The depth value is mapped to the [0,1] range for subsequent storage in the depth buffer, but this does not help, since the initial mapping to [-1,1] has already destroyed all accuracy in the far half of the range.) And because of the symmetry, the trick <b>reversed-Z</b> won't work here. <br><br>  Fortunately, this can be fixed in the desktop OpenGL using the widely supported <a href="https://www.opengl.org/registry/specs/ARB/clip_control.txt">ARB_clip_control</a> extension (also starting with OpenGL 4.5, <a href="http://docs.gl/gl4/glClipControl">glClipControl</a> is included in the standard).  Unfortunately, the GL ES in the span. <br><br><h2>  The effect of rounding error </h2><br>  The <b>1 / z</b> conversion and the choice of <b>float vs int depth buffer</b> is a big part of the accuracy story, but not all.  Even if you have enough depth depth to represent the scene you are trying to render, it is easy to degrade the accuracy with arithmetic errors during the vertex conversion process. <br><br>  At the beginning of the article it was mentioned that Upchurch and Desbrun studied this problem.  They offered two basic recommendations for minimizing rounding errors: <br><br><ol><li>  Use infinite far plane. </li><li>  Keep the projection matrix separate from other matrices, and apply it as a separate operation in the vertex shader, and not combine it with the view matrix. </li></ol><br>  Upchurch and Desbrun compiled these recommendations using an analytical method based on processing round-off errors as small random errors presented in each arithmetic operation, and tracking them until the first order in the conversion process.  I decided to test the results in practice. <br><br>  The sources <a href="https://gist.github.com/Reedbeta/ae437a9acb5dc137eabf">here</a> are Python 3.4 and numpy.  The program works as follows: a sequence of random points is generated, ordered by depth, located linearly or logarithmically between the near and far planes.  Then the points are multiplied by the view and projection of the matrix and the perspective division is performed, 32-bit floats are used, and optionally the final result is converted into a 24-bit int.  At the end, the sequence is followed by counting how many times 2 neighboring points (which initially had different depths) either became identical, as their total depth coincided, or the order changed in general.  In other words, the program measures the frequency with which depth comparison errors occur - which corresponds to issues such as <b>Z-fighting</b> - under various scenarios. <br><br>  Here are the results for near = 0.1, far = 10K, with a linear depth of 10K.  (I tried the logarithmic depth interval and other near / far relationships, and although specific numbers varied, the overall trends in the results were the same.) <br><br>  In the table, ‚Äúeq‚Äù - two points with the nearest depth get the same value in the depth buffer, and ‚Äúswap‚Äù - two points with the nearest depth are swapped. <br><table><tbody><tr><td colspan="1" rowspan="2"></td><td colspan="2" rowspan="1">  <b>Composite view-projection matrix</b> </td><td colspan="2" rowspan="1">  <b>Separate view and projection matrix</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td><td colspan="1" rowspan="1">  <b>float32</b> </td><td colspan="1" rowspan="1">  <b>int24</b> </td></tr><tr><td colspan="1" rowspan="1">  <b>Unchanged Z values ‚Äã‚Äã(control test)</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standard projection</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinite far</b> </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  45% eq <br>  18% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Reversed z</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinite + reversed-Z</b> </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td><td colspan="1" rowspan="1">  0% eq <br>  0% swap </td><td colspan="1" rowspan="1">  76% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Standard + GL-style</b> </td><td colspan="1" rowspan="1">  56% eq <br>  12% swap </td><td colspan="1" rowspan="1">  56% eq <br>  12% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td></tr><tr><td colspan="1" rowspan="1">  <b>Infinite + GL-style</b> </td><td colspan="1" rowspan="1">  59% eq <br>  10% swap </td><td colspan="1" rowspan="1">  59% eq <br>  10% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td><td colspan="1" rowspan="1">  77% eq <br>  0% swap </td></tr></tbody></table><br>  I apologize for the fact that without graphics, the dimension is too large and just can not build it!  In any case, looking at the numbers, the following conclusions are obvious: <br><br><ul><li>  In most cases, there is no difference between <b>int</b> and <b>float depth buffer</b> .  Arithmetic errors of depth calculation overlap conversion errors to int.  Partially because float32 and int24 are almost equal to the ULP (the unit of least precision is the distance to the nearest adjacent number) by [0.5.1] (since float32 has a 23-bit mantissa), so almost the entire depth range does not add a conversion error in int. </li><li>  In most cases, the separation of <b>view</b> and <b>projection</b> matrices (following the recommendations of Upchurch and Desbrun) improves the result.  Despite the fact that the overall error rate does not decrease, ‚Äúswaps‚Äù become equal values, and this is a step in the right direction. </li><li>  The infinite far plane slightly changes the error rate.  Upchurch and Desbrun predicted a 25% reduction in the frequency of numerical errors (accuracy errors), but this does not seem to lead to a decrease in the frequency of comparison errors. </li></ul><br>  However, the above conclusions do not have a real value compared to the magic <b>reversed-Z</b> .  Check: <br><br><ul><li>  Reversed-Z with float depth buffer gives <i>zero error rate</i> in the test.  Now, of course, you may get some errors if you continue to increase the interval of input depth values.  However, reversed-Z with float is ridiculously more accurate than any other option. </li><li>  Reversed-Z with integer depth buffer is as good as other integer options. </li><li>  Reversed-Z erases the differences between the composite and separate view / projection matrices, and the finite and infinite far planes.  In other words, with reversed-Z, you can multiply the projection with other matrices, and use any far plane you want without compromising accuracy. </li></ul><br><h2>  Conclusion </h2><br>  I think the conclusion here is clear.  In any situation, when dealing with perspective projection, simply use the <b>float depth buffer and reversed-Z</b> !  And if you can't use the float depth buffer, you should still use reversed-Z.  This is not a panacea for all ills, especially if you create an open-world environment with extreme depth ranges.  But this is a great start. </div><p>Source: <a href="https://habr.com/ru/post/434322/">https://habr.com/ru/post/434322/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434308/index.html">How the Ivideon video surveillance system is arranged: a review of PC software</a></li>
<li><a href="../434312/index.html">Conference time! Summing up the year 2018</a></li>
<li><a href="../434314/index.html">Alternatives LastPass. Comparative score of six password managers</a></li>
<li><a href="../434316/index.html">Secret Santa, quests, quiz and skating rink - as we met ABBYY New Year</a></li>
<li><a href="../434320/index.html">How we test Sberbank Online for iOS</a></li>
<li><a href="../434326/index.html">Ballet in the air: controlled levitation of particles due to sound waves</a></li>
<li><a href="../434328/index.html">Electronic signature for participation in procurement</a></li>
<li><a href="../434330/index.html">What's new in YouTrack 2018.4</a></li>
<li><a href="../434332/index.html">And one more time about SearchInform CIB: sorting out the news</a></li>
<li><a href="../434334/index.html">How baghunters intercepted letters in the pneumatic mail on ZeroNights</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>