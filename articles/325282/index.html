<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Twitter infrastructure: scale</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Twitter Park Overview 
 Twitter came from an era when it was decided to install equipment from specialized manufacturers in data centers. Since then, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Twitter infrastructure: scale</h1><div class="post__text post__text-html js-mediator-article"><h1>  Twitter Park Overview </h1><br>  Twitter came from an era when it was decided to install equipment from specialized manufacturers in data centers.  Since then, we have continuously developed and updated the server park, seeking to benefit from the latest open technology standards, as well as improve the efficiency of the equipment to provide the best experience for users. <br><br>  Our current equipment distribution is shown below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/df0/67b/6a4df067b8ca2ced7e5602225de6a73f.png"></div><br><a name="habracut"></a><br><h1>  Network traffic </h1><br>  We started leaving third-party hosting in early 2010.  This means that we had to learn how to build and maintain our own infrastructure.  Having a vague idea of ‚Äã‚Äãthe needs of basic infrastructure, we began to try different versions of the network architecture, equipment and manufacturers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      By the end of 2010, we completed the first network architecture project.  She had to solve the problems with scaling and maintenance that we experienced at the hoster.  We had ToR switches with deep buffers to handle bursts of service traffic, as well as core and carrier class switches without oversubscription at this level.  They supported an early version of Twitter, which set several notable engineering achievements, such as TPS records (tweets per second) after the release of the Japanese film ‚ÄúCastle in the Sky‚Äù and during the 2014 FIFA World Cup. <br><br>  If we quickly travel back a couple of years, then we already had a network with points of presence on five continents and data centers with hundreds of thousands of servers.  In early 2015, we began to experience some growth problems due to changes in the service architecture and increased power requirements, and eventually reached physical limitations of scalability in the data center when the mesh topology could not withstand the addition of additional equipment in the new racks.  In addition, IGP in the existing data center began to behave unpredictably due to the increased scale of routing and complexity of the topology. <br><br>  To cope with this, we began to transfer existing data centers to the topology of <a href="https://tools.ietf.org/html/draft-ietf-rtgwg-bgp-routing-large-dc-09">Clos</a> + <a href="https://tools.ietf.org/html/rfc1105">BGP</a> - a <a href="https://www.nanog.org/sites/default/files/20161016_Woodfield_Routing_Protocol_Migrations_v1.pdf">transformation</a> that had to be done on a live network.  Despite the complexity, it was completed with minimal impact on services in a relatively short time.  Now the network looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eae/cfc/f52/eaecfcf528e4f6442d01549b4c17c7c4.png"></div><br>  Key points of the new approach: <br><br><ul><li>  Smaller radius of impact from failure of one device. </li><li>  Capacity horizontal scaling capabilities. </li><li>  Smaller overhead routing engine on the CPU;  much more efficient handling of routing changes. </li><li>  More routing capacity due to low overhead CPU. </li><li>  More detailed control of routing rules for each device and each connection. </li><li>  There is no longer any chance of facing the root causes of the most serious incidents that happened in the past: increased protocol reconvergence time, problems with downed routes, and unexpected problems due to the inherent complexity of OSPF. </li><li>  The ability to move racks without consequences. </li></ul><br>  Let's take a closer look at our network infrastructure. <br><br><h1>  Data Center Traffic </h1><br><h3>  Tasks </h3><br>  Our first data center was built on the model of the capacity and traffic profiles of a well-known system installed at our hosting provider.  Only a few years passed, and our data centers were 400% larger than the original design.  And now, when our application stack has evolved, and Twitter has become more distributed, the traffic profiles have also changed.  The initial assumptions on which network design was developed at the beginning are no longer relevant. <br><br>  Traffic grows faster than we manage to redo the whole data center, so it is important to create a highly scalable architecture that allows you to consistently add capacity instead of sharp migrations. <br><br>  An extensive microservice system requires a highly reliable network that can withstand a variety of traffic.  Our traffic ranges from long-lived TCP connections to special MapReduce tasks and incredibly short microbursts.  Initially, we deployed network equipment with deep packet buffers to work with this variety of traffic types, but this caused our own problems: higher costs and increased hardware complexity.  Later projects used more standard buffer sizes and end-to-end switching functions along with a better configured TCP stack on the server side for more elegant micro splash processing. <br><br><h3>  Lessons learned </h3><br>  Years later and after the improvements made, we realized a few things that are worth mentioning: <br><br><ul><li>  Design beyond the original specifications and requirements, make bold and quick changes if traffic approaches the upper limit of the capacity embedded in the network. </li><li>  Rely on data and metrics to make correct technical design decisions, and make sure that these metrics are understandable to network operators - this is especially important on hosting or in the cloud. </li><li>  There is no such thing as a temporary change or a workaround: in most cases, workarounds are technical debt. </li></ul><br><h1>  Backbone traffic </h1><br><h3>  Tasks </h3><br>  We have backbone traffic dramatically increasing every year - and we still see bursts of 3-4 times the normal traffic, when we move traffic between data centers.  This sets unique challenges for historical protocols that were not designed for this.  For example, the <a href="https://tools.ietf.org/html/rfc3209">RSVP</a> protocol in <a href="https://tools.ietf.org/html/rfc3031">MPLS</a> assumes to some extent a gradual increase in traffic, rather than sudden bursts.  We had to spend a lot of time setting up these protocols in order to get the fastest response time.  In addition, to handle traffic spikes (especially when replicating to storage systems), we implemented a priority system.  Although we always need to guarantee the delivery of user traffic, we can allow a delay of low-priority replication traffic from storage systems with daily SLAs.  Thus, our network uses all available bandwidth and maximizes resource utilization.  User traffic is always more important than low-priority backend traffic.  In addition, to solve the container packing (bin-packing) problems associated with <a href="https://tools.ietf.org/html/rfc3209">RSVP</a> automatic bandwidth, we implemented the <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/dynamic-bandwidth-management-overview.html">TE ++</a> system, which, as traffic increases, creates additional <a href="https://tools.ietf.org/html/rfc3031">LSPs</a> and removes them as traffic decreases.  This allows us to effectively manage traffic between connections, while reducing the CPU load needed to support a large number of LSPs. <br><br>  Although initially no one was engaged in designing traffic for backbone, it was later added to help us scale in line with our growth.  To do this, we have split the roles with separate routers to route kernel traffic and boundary traffic, respectively.  It also allowed us to scale in a budget mode, because we did not need to buy routers with complex boundary functionality. <br><br>  At the border, this means that here our kernel is connected to everything and can be scaled in a very horizontal way (for example, installing many, many routers in one place, and not just a couple, since the core interconnects connect everything through). <br><br>  To scale the <a href="https://tools.ietf.org/html/draft-ietf-i2rs-rib-info-model-08">RIB</a> in our routers to meet the scaling requirements, we had to implement route reflection, but by doing this and moving to a hierarchical structure, we also implemented route reflector clients for their own route reflectors! <br><br><h3>  Lessons learned </h3><br>  Over the last year, we transferred device configurations to templates, and now we regularly check them. <br><br><h1>  Boundary traffic </h1><br>  Twitter has direct interconnections with more than 3,000 unique networks in many data centers around the world.  Direct traffic delivery is a top priority.  We move 60% of our traffic through our global network backbone to interconnect points and points of presence (POP), where we have local frontend servers, closing client sessions, all to be as close as possible to users. <br><br><h3>  Tasks </h3><br>  The unpredictability of world events leads to the same unpredictable traffic bursts.  These surges during major events like sports, elections, natural disasters and other significant events stress our network infrastructure (especially photos and videos).  They are difficult to predict or come at all without warning.  We provide capacity for such events and prepare for big jumps - often 3-10 times higher than normal peak levels if a significant event is planned in the region.  Due to our significant annual growth, it is an important task to increase capacity in the required volume. <br><br>  Although we set up peering connections with all client networks whenever possible, this is not without problems.  Surprisingly often, networks or providers prefer to set up interconnects far from the home market or, due to their routing rules, direct traffic to a point of presence outside the market.  And although Twitter openly establishes peer-to-peer connections with all the largest (by the number of users) networks where we see traffic, not all Internet providers do the same.  We spend considerable time optimizing our routing rules to drive traffic as close to our users as possible. <br><br><h3>  Lessons learned </h3><br>  Historically, when someone sent a request to <code>www.twitter.com</code> , based on the location of our DNS server, we gave them different regional IP addresses to direct to a specific server cluster.  Such a methodology (GeoDNS) is partly inaccurate, because you cannot rely on users to select the correct DNS servers or our ability to pinpoint where the DNS server is physically located in the world.  In addition, the topology of the Internet does not always correspond to geography. <br><br>  To solve the problem, we switched to the BGP Anycast model, in which we stated the same route from all locations and optimized our routing in order to work out the best path from users to our points of presence.  By doing so, we get the best possible performance given the limitations of the topology of the Internet and do not depend on unpredictable assumptions about where the DNS servers are located. <br><br><h1>  Storage </h1><br>  Hundreds of millions of tweets are published daily.  They are processed, stored, cached, shipped, and analyzed.  For this amount of content, we need the appropriate infrastructure.  The storage and messaging represent 45% of the total Twitter infrastructure. <br><br>  Storage and messaging groups provide the following services: <br><br><ol><li>  <a href="https://blog.twitter.com/2015/hadoop-filesystem-at-twitter">Hadoop</a> clusters for computing and HDFS. </li><li>  <a href="https://blog.twitter.com/2014/manhattan-our-real-time-multi-tenant-distributed-database-for-twitter-scale">Manhattan</a> clusters for all key-value storages with low latency. </li><li>  <a href="https://blog.twitter.com/2010/introducing-flockdb">Graph</a> storage for shardish MySQL clusters. </li><li>  <a href="https://blog.twitter.com/2012/blobstore-twitter-s-in-house-photo-storage-system">Blobstore</a> clusters for all large objects (video, images, binary files ...). </li><li>  <a href="https://blog.twitter.com/2012/caching-with-twemcache">Caching</a> clusters </li><li>  <a href="https://blog.twitter.com/2015/building-distributedlog-twitter-s-high-performance-replicated-log-service">Messaging</a> clusters. </li><li>  Relational storage ( <a href="https://blog.twitter.com/2015/another-look-at-mysql-at-twitter-and-incubating-mysos">MySQL</a> , PostgreSQL and <a href="https://blog.twitter.com/2016/discovery-and-consumption-of-analytics-data-at-twitter">Vertica</a> ). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/a76/7fd/e0ea767fd68f30c60b3da9104bdb184f.png"></div><br><h3>  Tasks </h3><br>  Although at this level there are a number of different problems, one of the most notable problems that had to be overcome was multiple ownership (multi-tenancy).  Often, users have boundary situations that affect existing tenure and force us to build dedicated clusters.  The more dedicated clusters, the greater the operational load to support them. <br><br>  There is nothing surprising in our infrastructure, but here are some interesting facts: <br><br><ul><li>  Hadoop: our numerous clusters store more than 500 PBs, divided into four groups (real time, processing, data storage and cold storage).  In the largest cluster more than 10 thousand nodes.  We have 150 thousand applications and runs 130 million containers per day. <br><br></li><li>  Manhattan (backend for tweets, private messages, twitter accounts, etc.): we have several clusters for different tasks, these are large clusters with multiple ownership, smaller for unusual tasks, read only and read / write clusters for heavy traffic for reading and writing.  The read only cluster processes tens of millions of requests per second (QPS), and the read / write cluster processes millions of QPS.  Each data center has a cluster with the highest performance - a cluster of observability that processes tens of millions of records. <br><br></li><li>  Graph: our historic shard cluster based on Gizzard / MySQL for graph storage.  Our social graph Flock is able to cope with a peak load of tens of millions of QPS, distributing it to MySQL servers with an average of 30-45 thousand QPS. <br><br></li><li>  Blobstore: a repository for images, videos, and large files that contains hundreds of billions of objects. <br><br></li><li>  Cache: Redis and Memcache clusters cache users, timelines, tweets, etc. <br><br></li><li>  SQL: includes MySQL, PostgreSQL and Vertica.  MySQL / PosgreSQL is used where strict integrity is needed in managing campaigns, advertising exchanges, and for internal tools.  Vertica is a column repository that is often used as a backend for sales with Tableau support and user organization. </li></ul><br>  Hadoop / HDFS is also a backend for Scribe-based logging systems, but the final stages of testing for <a href="https://flume.apache.org/">Apache Flume are</a> now being completed.  It should help to overcome the limitations, such as the lack of limits / narrowing of the bandwidth for individual customer traffic to aggregators, the lack of delivery guarantee by category.  Also will help solve problems with memory corruption.  We process more than a trillion messages a day, all of them are processed and distributed into more than 500 categories, combined and then selectively copied across our clusters. <br><br><h2>  Chronological evolution </h2><br>  Twitter was built on MySQL and initially all data was stored in it.  We moved from a small database to a large instance, and then to a large number of large database clusters.  Manual data transfer between MySQL instances took a lot of time, so in April 2010 we introduced <a href="https://blog.twitter.com/2010/introducing-gizzard-a-framework-for-creating-distributed-datastores">Gizzard</a> , a framework for creating distributed data stores. <br><br>  At the time, the ecosystem looked like this: <br><br><ul><li>  Replicated MySQL Clusters. </li><li>  Shardirovannye MySQL clusters based on Gizzard. </li></ul><br>  After the release of Gizzard in May 2010, we introduced <a href="https://blog.twitter.com/2010/introducing-flockdb">FlockDB</a> , a solution for storing graphs on top of Gizzard and MySQL, and in June 2010 - <a href="https://blog.twitter.com/2010/announcing-snowflake">Snowflake</a> , our unique identifier service.  2010 was the year we invested in <a href="https://blog.twitter.com/2010/hadoop-at-twitter">Hadoop</a> .  Originally intended for storing MySQL backups, it is now heavily used for analytics. <br><br>  Around 2010, we also implemented Cassandra as a storage solution, and although it did not completely replace MySQL due to the lack of an automatic gradual increase function, it was used to store indicators.  As traffic increased exponentially, we needed to increase the cluster, so in April 2014 we launched <a href="https://blog.twitter.com/2014/manhattan-our-real-time-multi-tenant-distributed-database-for-twitter-scale">Manhattan</a> : our distributed real-time database with multiple ownership.  Since then, Manhattan has become one of our main storage levels, and Cassandra has been disabled. <br><br>  In December 2012, Twitter allowed uploading photos.  Behind the fa√ßade, this was made possible by the new data storage solution <a href="https://blog.twitter.com/2012/blobstore-twitter-s-in-house-photo-storage-system">Blobstore</a> . <br><br><h3>  Lessons learned </h3><br>  Over the years, as data migrated from MySQL to Manhattan to improve accessibility, reduce delays and simplify development, we also introduced additional data storage engines (LSM, b + tree ...) to better serve our traffic patterns.  In addition, we learned lessons from incidents and began to protect our data storage levels from abuse by sending back pressure and activating request filtering. <br><br>  We continue to concentrate on providing the right tool for the job, but for that you need to understand all the use cases.  A universal ‚Äúone size fits all‚Äù solution rarely works - you should avoid cutting corners in boundary situations, because there is nothing more permanent than a temporary solution.  And finally, do not overestimate your decision.  Everything has advantages and disadvantages, and everything needs to be adapted without losing touch with reality. <br><br><h1>  Cache </h1><br>  Although the cache occupies only about 3% of our infrastructure, it is critical for Twitter because it protects our backend storage from heavy read traffic and also allows us to store objects with a high price of swelling.  We use several caching technologies, like Redis and Twemcache, on a huge scale.  More specifically, we have a mix of Twitter memcached (twemcache) clusters, dedicated or multi-owned, as well as Nighthawk clusters (shaded Redis).  We have transferred almost all of our main caching from bare metal to Mesos to reduce maintenance costs. <br><br><h3>  Tasks </h3><br>  Scaling and performance - the main tasks for the caching system.  We have hundreds of clusters with an aggregate packet transfer rate of 320 million packets per second, delivering 120 GB / s to our customers, and we set the goal to provide each response with a delay of 99.9% and 99.99% even during peak traffic spikes during significant events. <br><br>  To meet our service level objectives (SLO) in terms of high bandwidth and low latency, we need to continuously measure the performance of our systems and look for options to optimize efficiency.  To this end, we have written the <a href="https://github.com/twitter/rpc-perf">rpc-perf</a> program, it helps to better understand how our caching systems behave.  This is critical for capacity planning, since we have switched from dedicated servers to the current Mesos infrastructure.  As a result of this optimization, it was possible to more than double the bandwidth per server without sacrificing delays.  We still think that big optimizations are possible here. <br><br><h3>  Lessons learned </h3><br>  The transition to Mesos was a huge operational victory.  We codify our configurations and can gradually deploy them, maintaining the cache hit ratio and avoiding problems for persistent data stores.  Growth and scaling of this level occurs with greater confidence. <br><br>  With thousands of connections to each twemcache instance, any process restart, spike in network traffic, or another problem can cause a DDoS-like connection flow to the cache level.  As it progressed, it became more than a serious problem.  We have implemented benchmarks that help in the case of DDoS to narrow the band for connections to each individual cache with a high level of reconnects, otherwise we would have departed from our stated goals in terms of service level. <br><br>  We logically split our caches by users, tweets, timelines, etc., so that, in general, each caching cluster is configured for a specific use.  Depending on the type of cluster, it can process from 10 million to 50 million QPS, and works on the number of instances from hundreds to thousands. <br><br><h2>  Haplo </h2><br>  Let us introduce Haplo.  This is the main Twitter timeline cache and it works on a customized version of Redis (using HybridList).  Read operations from Haplo are performed by the Timeline Service, and write operations by the Timeline Service and Fanout Service.  It is also one of our caches that have not yet migrated to Mesos. <br><br><ul><li>  The total number of teams from 40 million to 100 million per second. </li><li>  Network I / O 100 Mbps to the host. </li><li>  The total number of requests for service 800 thousand per second. </li></ul><br><h3>  For further reading </h3><br>  Yao Yue ( <a href="https://twitter.com/intent/user%3Fscreen_name%3Dthinkingfish">@thinkingfish</a> ) over the years has spent several excellent lectures and has published a number of articles on caching, including <a href="https://www.youtube.com/watch%3Fv%3DrP9EKvWt0zo">our use of Redis</a> , as well as our newer <a href="https://www.youtube.com/watch%3Fv%3DpLRztKYvMLk">code base Pelikan</a> .  You can watch these videos and read a recent <a href="https://twitter.github.io/pelikan/2016/04/03/caching-in-datacenters.html">blog post</a> . <br><br><h1>  Puppet work on a large scale </h1><br>  We have a large array of kernel infrastructure services, such as Kerberos, Puppet, Postfix, Bastions, Repositories, and Egress Proxies.  We focus on scaling, creating tools and managing these services, as well as supporting the expansion of data centers and points of presence.  Last year alone, we significantly expanded the geography of our points of presence, which required a complete redesign of the architecture of how we plan, prepare and launch new locations. <br><br>  To manage all configurations, we use Puppet and install an initial batch installation on our systems.  This section describes some of the tasks that had to be solved and what we plan to do with our infrastructure for managing configurations. <br><br><h3>  Tasks </h3><br>  As we grow to meet user requests, we quickly outgrow our standard tools and practices.  We have more than 100 authors of commits per month, more than 500 modules and more than 1000 roles.  In the end, we managed to reduce the number of roles, modules and lines of code, while at the same time improving the quality of our code base. <br><br><h3>  Branches </h3><br>  We have three branches that Puppet refers to as environments.  This allows for testing, testing and eventually releasing changes for the working environment.  We also allow separate specialized environments for more isolated testing. <br><br>  Transferring changes from the test to the work environment currently requires some human participation, but we are moving to a more automated CI system with an automated integration / rollback process. <br><br><h3>  Code base </h3><br>  Our Puppet repository contains more than 1 million lines of code, where only the Puppet code is more than 100 thousand lines in each branch.  We recently did a massive cleanup of the codebase, removing unnecessary and duplicate code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c69/ea4/b9d/c69ea4b9dc017d7dbd38e81938ed7339.png"><br><br>  This graph shows the total number of lines of code (excluding various automatically updated files) from 2008 to today. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/300/294/2a2/3002942a2eb1a57444a4420b935d18a3.png"><br><br>  This graph shows the total number of files (excluding various automatically updated files) from 2008 to today. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8e/9c2/057/f8e9c2057029831eb498a52610adb961.png"><br><br>  This graph shows the average file size (excluding various automatically updated files) from 2008 to today. <br><br><h3>  Big wins </h3><br>  The biggest victories for our code base were static code analysis (lint), style checking hooks, documentation of best practices, and regular work meetings. <br><br>  With lint tools (puppet-lint), we were able to meet generally accepted lint standards.  We reduced the number of lint errors and warnings in our code base to tens of thousands of lines, and the transformation affected 20% of the code base. <br><br>  After the initial purge, it is now easier to make smaller changes to the code base, and the introduction of automated style checking as a hook for version control has dramatically reduced the number of style errors in our code base. <br><br>  With more than a hundred contributors to Puppet throughout the organization, the importance of documenting best practice practices, both internal practices and community standards, is greatly increasing.  The presence of a single reference document improved the quality of the code and the speed of its implementation. <br><br>  Holding regular ancillary meetings (sometimes by invitation) helps to provide one-on-one assistance when the tickets and channel in the chat do not provide sufficient communication density or cannot display a complete picture of what needs to be achieved.  As a result, after the meetings, many commit authors improved the quality of the code and the speed of work, understanding the requirements of the community, best practices and how best to apply the changes. <br><br><h3>  Monitoring </h3><br>  System indicators are not always useful (see the Caitlin McCaffrey <a href="https://speakerdeck.com/caitiem20/tackling-alert-fatigue">lecture</a> at the Monitorama 2016 conference), but they provide additional context for those indicators that we consider useful. <br><br>  Some of the most useful indicators for which alerts are generated and charts are drawn up: <br><br><ul><li>  Malfunctions: Number of unsuccessful Puppet launches. </li><li>  Duration of work: the time it takes the Puppet client to complete the work. </li><li>  No job: the number of Puppet launches that did not take place in the expected interval. </li><li>  Directory sizes: size of directories in megabytes. </li><li>  Directory compilation time: the time in seconds the directory needs to be compiled. </li><li>  Number of compiled directories: the number of directories that each Master compiled. </li><li>  File resources: the number of files processed. </li></ul><br>  All these indicators are collected for each host and are summarized by roles.  This allows you to instantly issue alerts and determine if a problem exists for specific roles, role sets, or wider problems. <br><br><h3>  Effect </h3><br>  After switching from Puppet 2 to Puppet 3 and updating Passenger (we will later post posts on both topics), we were able to reduce the average operating time of Puppet processes in Mesos clusters from more than 30 minutes to less than 5 minutes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe7/172/8aa/fe71728aa16acc397a71c6e7cc007fba.png"><br><br>  This graph shows the average Puppet process time in seconds in our Mesos clusters. <br><br>  If you want to help with our Puppet infrastructure, we <a href="https://careers.twitter.com/en/work-for-twitter/site-reliability-engineer.html">invite you to work</a> ! </div><p>Source: <a href="https://habr.com/ru/post/325282/">https://habr.com/ru/post/325282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325272/index.html">7 workflow optimization techniques you may not have heard about</a></li>
<li><a href="../325274/index.html">CAPWAP State Machine in the Cisco Unified Wireless Implementation: Join State</a></li>
<li><a href="../325276/index.html">Zabbix for DevOps: how we implemented the monitoring system in the development and testing processes</a></li>
<li><a href="../325278/index.html">Abstract lectures on the design of game mechanics sandbox projects from the creator of Life is Feudal</a></li>
<li><a href="../325280/index.html">Specification Design Pattern in C #</a></li>
<li><a href="../325284/index.html">VR Design: scene content</a></li>
<li><a href="../325286/index.html">Live stream from MoscowJS Superjob office</a></li>
<li><a href="../325288/index.html">GoTech 2017 technological projects competition has started</a></li>
<li><a href="../325290/index.html">How to simplify software development when outsourcing?</a></li>
<li><a href="../325292/index.html">Kazakhstan: How I helped to submit 100 forms of tax reporting. Start 200 form</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>