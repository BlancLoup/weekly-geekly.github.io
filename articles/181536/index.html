<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript module path</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the time of writing this article in JavaScript, there was no official modular system yet and everyone emulated the modules as best they could. 

 M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript module path</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/storage2/f75/3b6/6e5/f753b66e57434dab766eb63110086560.png"></div><br><br>  At the time of writing this article in JavaScript, there was no official modular system yet and everyone emulated the modules as best they could. <br><br>  Modules or similar structures are an integral part of any adult programming language.  Just nothing else.  The modules allow you to limit the scope, allow you to reuse parts of the application, make the application more structured, separate resources from noise, and generally make the code more visible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      JavaScript has its own atmosphere - there are no official modules in the language; moreover, all the files are located remotely, one application stream.  You have to constantly solve some strange problems with downloading, tricky to pack modules into one file to speed up the loading time.  It happens that you need to fight with double standards, to adapt modules of a different format. <br><br>  The fact is that before they didn‚Äôt think that huge projects could be done with JavaScript, and not just ‚Äúpatch the DOM‚Äù, so they didn‚Äôt think about the modules.  Yes, and did not think about the future.  And then suddenly the future turned up!  Everything seems to be already there, and the modules in JavaScript, to put it mildly, are late.  Therefore, developers have to spin and invent some modularity emulators. <br><br>  I think many of you have read the excellent article Addy Osmani <a href="http://addyosmani.com/writing-modular-js/">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</a> , which was one of the chapters of his book <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book/">Learning JavaScript Design Patterns</a> in this article talks about "modern" JavaScript modules or read a rather old article <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">JavaScript Module Module : In-Depth</a> 2010 about the "old" modules. <br><br>  I will not translate these articles and I will not make a hodgepodge of them.  In my article I want to talk about my modular way.  About how I made my way from the ‚Äúold‚Äù modules to the ‚Äúnew‚Äù ones and what I use now and why. <br><a name="habracut"></a><br>  This article consists of 3 parts: Module path, Module mate guides, and common types of modules. <br><br><div class="spoiler">  <b class="spoiler_title">tl; dr</b> <div class="spoiler_text">  I have come a long way from non-modules through <a href="http://requirejs.org/docs/whyamd.html">AMD</a> and <a href="http://browserify.org/">browserify</a> to <a href="http://lmdjs.org/">LMD</a> , which satisfies all my needs and makes life easier.  In the future, I bet on <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:modules">ECMAScript 6 Modules</a> . <br></div></div><br><h4>  Module path </h4><br><h5>  Stage 1: Without Modules </h5><br>  In those days, when the JavaScript code was not enough, I completely managed without modules.  Then I did not need them.  The introduction of a modular system would turn my 50 lines of code into 150. And I could quickly patch the DOM without modules.  I completely managed with namespaces and did not use the assembly, but minifiers were not developed then. <br><br>  Module <br><pre><code class="javascript hljs">MyNs.MyModule = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; MyNs.MyModule.prototype = { <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Assembly <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"myNs.js"</span></span></span><span class="hljs-tag">/&gt;</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"myNs/myModule.js"</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="undefined"></span></span><span class="xml"><span class="undefined"></span></span></code> </pre><br>  The progress of my application stepped another half step forward when I began to collect my files using cat <br><pre> <code class="bash hljs">$ cat js/*.js &gt; build.js</code> </pre><br><br><h5>  Stage 2: Preprocessing </h5><br>  Progress does not stand still and my 50 lines of code gradually turned into 1500, I began to use third-party libraries and their plugins.  And the application that I wrote could be called the Rich Internet Application.  The division into modules and their partial isolation solved my problems of that time.  For assembly I began to use preprocessors.  There were a lot of modules, they had dependencies, and I didn‚Äôt really want to resolve dependencies, so preprocessing was irreplaceable then.  I used namespaces, although there was a lot of messing around with them: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> MyNamespace === <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyNamespace = {}; }</code> </pre><br>  and excess writings: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyNamespace.MyConstructor(MyNamespace.MY_CONST); <span class="hljs-comment"><span class="hljs-comment">// vs new MyConstructor(MY_CONST);</span></span></code> </pre><br>  and the minifiers of that time compressed such code badly: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> a.MyConstructor(a.MY_CONST); <span class="hljs-comment"><span class="hljs-comment">// vs new a(b);</span></span></code> </pre><br>  My modules stepped a little further forward when I began to apply total isolation and threw out the namespace, replacing it with a scope.  And I began to use these modules: <br><pre> <code class="javascript hljs">include(<span class="hljs-string"><span class="hljs-string">'deps/dep1.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyModule = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; MyModule.prototype = { <span class="hljs-comment"><span class="hljs-comment">// ... }; return MyModule; })();</span></span></code> </pre><br>  And this assembly <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ include(<span class="hljs-string"><span class="hljs-string">'myModule.js'</span></span>); }());</code> </pre><br>  And the same preprocessing <br><pre> <code class="bash hljs">$ includify builds/build.js index.js</code> </pre><br>  Each module has a local scope and the entire assembly is wrapped with another IEFE.  This allows you to protect the modules from each other and the entire application from the global. <br><br><h5>  Stage 3: AMD </h5><br><img src="https://habrastorage.org/storage2/bff/a9d/00e/bffa9d00e252e3730d8f482cfdcf9f4d.png"><br>  One day, while reading Reddit, I came across an article on AMD and RequireJS. <br><br>  A small digression.  In fact, the idea of ‚Äã‚ÄãAMD was borrowed from the <a href="http://yuilibrary.com/yui/docs/yui/create.html">YUI Modules</a> and well finished.  For the use and declaration of modules, it was no longer necessary to write out unnecessary characters, configuration was also easier. <br><br>  It was <br><pre> <code class="javascript hljs">YUI().use(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Y</span></span></span><span class="hljs-function">) </span></span>{ Y.dep1.sayHello(); });</code> </pre><br>  It became <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1</span></span></span><span class="hljs-function">) </span></span>{ dep1.sayHello(); });</code> </pre><br>  Having got acquainted with AMD, I realized that until that time I had done everything wrong.  Only 2 functions <code>require()</code> and <code>define()</code> and all my problems were solved!  The modules began to download their own dependencies, appeared sane exports and imports.  The module was divided into 3 parts (import, export, module body), which could be easily understood.  It also became easy to find the resources he needs and which he exports.  The code has become structured and cleaner! <br><br>  Module <br><pre> <code class="javascript hljs">define(<span class="hljs-string"><span class="hljs-string">'myModule'</span></span>, [<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyModule = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; MyModule.prototype = { <span class="hljs-comment"><span class="hljs-comment">// ... }; return MyModule; });</span></span></code> </pre><br>  Assembly <br><pre> <code class="bash hljs">$ node r.js index.js bundle.js</code> </pre><br>  But not everything is so simple ... <br><br><h5>  Stage 4: Disappointment at AMD </h5><br>  What I showed above is an ideal module and an ideal assembly.  This does not happen in a real project.  And it happens that the module has a lot of dependencies.  Then it turns into something like this: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'deps/dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep2'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep3'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep4'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep5'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep6'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep7'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> dep1, dep2, dep3, dep4, dep5, dep6, dep7</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br>  This module can be used, but with it a lot of fuss.  To overcome this problem, you can redo this module on Simplified CommonJS.  Even in this case, it is possible not to write at all <code>define()</code> wrapper and create honest CommonJS modules, and then assemble them using <code>r.js</code> <br><pre> <code class="javascript hljs">define(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">require, module, exports</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep2'</span></span>), dep3 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep3'</span></span>), dep4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep4'</span></span>), dep5 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep5'</span></span>), dep6 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep6'</span></span>), dep7 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep7'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><br>  The Simplified CommonJS format for RequireJS is ‚Äúnot native,‚Äù just the developer had to do it.  If you start writing such modules, then RequireJS will start looking for dependencies of this module in regular form. <br><br><img src="https://habrastorage.org/storage2/739/571/f6e/739571f6e2d3318bb1778249b09933b4.png"><br><br>  And something can not find: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"myModule//"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"my module"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"my"</span></span> + <span class="hljs-string"><span class="hljs-string">"Module"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span> = r; r(<span class="hljs-string"><span class="hljs-string">"myModule"</span></span>);</code> </pre><br>  This code is valid, but there is not a single module.  Of course, the abstract example and some names are contrived, but I have often come across cases with dynamic construction of the module name, for example, with templates or some factories. <br><br>  RequireJS, of course, has a solution for this ‚Äî register each such module in the config file: <br><pre> <code class="javascript hljs">({ <span class="hljs-string"><span class="hljs-string">"paths"</span></span>: { <span class="hljs-string"><span class="hljs-string">"myModule"</span></span>: <span class="hljs-string"><span class="hljs-string">"modules/myModule.js"</span></span> } })</code> </pre><br>  It also happens that there are many such modules (templates) and you do not want to prescribe a new module each time into the config, and therefore the code begins to acquire all kinds of magic like dynamic generation of the config.  And not to use "dynamic modules" is stupid with the available options. <br><br>  I began to write honest CommonJS modules, use the assembly via r.js even in development.  The rejection of AMD also allowed the use of these modules with Node.js without any magic.  I began to understand that this tool suits me in principle, but with crutches and additional polishing. <br><br>  Those features of dynamic loading of modules that RequireJS offered me were not needed by me.  I wanted to be sure that I would have the most similar code in development and production, so asynchronous loading of modules in development did not suit me and that is why I assembled my modules into 1 file. <br><br>  Some part of the project was loaded at the start (1 request), the rest of the parts were loaded on demand.  And they were not loaded by a bunch of small requests, but by one big one (building several modules in the 1st file).  This saved time and traffic and reduced the risk of network errors. <br><br>  It also happens that you need to do several assemblies.  For example, an application with a Russian locale for a testing environment or an application optimized for IE with English for a corporate network.  Or an application optimized for iPad for Ukraine with disabled ads.  Anarchy and copy-paste reigned ... <br><br>  In the RequireJs philosophy, I didn‚Äôt like the fact that <code>require()</code> is a universal factory for the production of any resources.  <code>require()</code> does an abstraction over plugins and already loaded modules. If the plug-in was not connected for some reason, then somehow it does not quite explicitly load it, and then using it loads the resource. <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'async!i18n/data'</span></span>, <span class="hljs-string"><span class="hljs-string">'pewpew.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'text!templates/index.html'</span></span>], fucntion (data, pewpew, template) { });</code> </pre><br>  In projects where resources are monotonous or resources are not very much - it may be ok. <br><br><h5>  Stage 5: Search for a module </h5><br>  I realized that I could no longer live like this ... but I knew what I needed: <br><br><h6>  1 Module must be CommonJS </h6><br>  It is often a case when you need to run the same module under Node.js and under JS @ DOM.  Most often, these are some modules not related to the external environment (file system / DOM) or parts that are abstracted from it: templates (the most common part), time management functions, formatting functions, localization, validators ... <br><br>  When writing AMD and you need to reuse something you have 2 ways: rewrite AMD on CJS or use node-require.  More often choose the second option because you do not need to change anything.  BUT.  Then a modular porridge appears, a strange abstraction over the already existing module loading system in Node.js.  I really didn‚Äôt like the AMD modules in Node.js. <br><br>  CJS, in addition to compatibility with Node.js, is devoid of a <code>define()</code> wrapper and indentation that formats the function body.  Its require and export is clearer and closer to ES6 Modules than <code>define()</code> -way.  Compare yourself: <br><br>  ES6 Modules <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"dep1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dep1; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"dep2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> dep2; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br>  CommonJS / Modules <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"dep1"</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"dep2"</span></span>); exports.name = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br>  AMD <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; } }; });</code> </pre><br>  And if it turns out that I have to go back to AMD, it will not hurt at all - I just need to register one line in the config file so that r.js wraps my CJS modules. <br><br><h6>  2 Module Builder </h6><br>  Today, everything is collected, even if you do not write CoffeeScript, then you somehow check, collect, compress your scripts. <br><br>  To adapt the CJS module, you need a wrapper that the collector can do for me.  The collector could also check me: whether all modules exist, whether I was mistaken in the name of the module, whether I declared all the plugins. <br><br>  As a result of the assembly, I would like to receive 1 file that contains both my modules and scripts necessary for their work. <br><br>  Dividing the application into ‚Äúmy scripts‚Äù and ‚Äúnot mine‚Äù ‚Äúfor the benefit of caching‚Äù (connect the bootloader code separately and my code separately) did not make sense to me because as I write mostly one-page web applications, and the cache today can be leaked for minutes  Compiling all-in-one will also get rid of compatibility issues with the "module loader" when upgrading. <br><br><h6>  3 Flexible configuration system: dependencies, inheritance, mixins </h6><br>  As I already wrote, in my applications there are a lot of assemblies for different devices, browsers, environments and locales.  I really wanted to get an unobtrusive configuration system without unnecessary copy-paste and writing. <br><br>  For example, there is a <code>prod</code> config from it inherits the <code>dev</code> config and replaces some modules.  There are also <code>ru</code> and <code>en</code> configs, which we can mix <code>prod+en</code> , <code>dev+ru</code> .  Now, instead of ‚Äúcommon‚Äù and copy-paste ( <code>prod-ru</code> , <code>prod-en</code> , <code>dev-ru</code> , <code>dev-en</code> ), we have only 4 ‚Äúdry‚Äù config files: <code>prod</code> , <code>dev</code> , <code>ru</code> , <code>en</code> . <br><br><h6>  4 CLI </h6><br>  This is the interface to the robot that does half the work for you.  If he is very overloaded or needs to - <code>--  ----</code> , then it starts to strain and causes a <code>Makefile</code> appear and waste a lot of time starting this very robot, which should save time. <br><br>  Any actions that are repeated often should be as simple as possible.  Default values ‚Äã‚Äãshould be used, the same argument names for subcommands.  In general, the developer remembers and writes a minimum. <br><br>  Compare <br><pre> <code class="bash hljs">$ tool make -f path/to/build_name.js -o path/to/build.js</code> </pre><br>  and <br><pre> <code class="bash hljs">$ tool make build_name</code> </pre><br>  And when you once again write out this long command in the console without autocomplete, you begin to hate this tool.  It is clear that option 1 is perhaps more pronounced than the second, but it is very much like a graphoman's tool. <br><br><h5>  Stage 6: browserify </h5><br><br> <a href="https://github.com/substack/node-browserify"><img src="https://habrastorage.org/storage2/cf5/442/50b/cf544250baf484ac5d1402ef0f7fbe58.png"></a> <br><br>  <a href="https://github.com/substack/node-browserify">Browserify</a> is a tool that allows you to run any Node.js modules in a browser. <br><br>  Just <code>browserify main.js &gt; bundle.js</code> and running. <br><br>  Having worked with browserify for a while, I realized its true use-case: adapting the Node.js environment to work in a browser.  Browserify is perfect for its purposes, but not for the realities in which web applications are created.  When there are not adapted third-party modules, when there is a dynamic loading of large parts of the application.  I had to conjure a lot in the console so that everything worked. <br><br><h5>  Stage 7: LMD </h5><br><br> <a href="http://lmdjs.org/"><img src="https://habrastorage.org/storage2/a7f/46b/0ae/a7f46b0ae46c334555f7d5217d46cac2.png"></a> <br><br>  I really didn‚Äôt want to, but I had to start working on <a href="http://lmdjs.org/">LMD</a> , a tool that would make my life easier.  I could no longer adjust existing tools to my goals. <br><br>  As a result, a tool was developed that was engaged in assembling the script part of my projects. <br><br>  Here are a few features that formed the basis of the LMD: <br><br><h6>  1 Build from config </h6><br>  Since the presence of a config is inevitable, why not be based on it ?!  The behavior of lmd is fully defined by the config, it contains both modules and plugins and export paths for the resulting file.  Configs can be inherited and mixed with other configs. <br><br>  It looks like a config <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"My Config"</span></span>, <span class="hljs-string"><span class="hljs-string">"root"</span></span>: <span class="hljs-string"><span class="hljs-string">"../js"</span></span>, <span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"../build.lmd.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"modules"</span></span>: { <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"optimize"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"ie"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"promise"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  If you have hundreds of modules - you do not need to register each module in the config!  It is enough to register the ‚Äúrewrite rule‚Äù for modules of the same type. <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"modules"</span></span>: { <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;%= file %&gt;Template"</span></span>: <span class="hljs-string"><span class="hljs-string">"templates/*.html"</span></span> } }</code> </pre><br>  And in extreme cases, you can write a config in the form of a CJS module and generate everything on the fly. <br><br><h6>  2 Abstract FS: No binding to the file system </h6><br>  Binding to the file system on the one hand is natural and the HTTP server can uniquely reflect the file system.  But it is worth remembering that the browser does not have a file system and the HTTP server delivers resources, and the code already understands that this text at this URL is a module.  Resources can be moved, laid out on a CDN under arbitrary names. <br><br>  The introduction of an abstract file system allows you to make abstractions over modules.  For example, you have a locale module under which both locale.ru.json and locale.en.json can hide, because these modules have the same interface, we can transparently change one file to another. <br><br>  You are free to call your modules as you like and connect without thinking about relative paths.  If you have many modules and you forgot what file is hidden under this module, then you just need to use <code>lmd info</code> : <br><pre> <code class="bash hljs">$ lmd info build_name | grep module_name info: module_name ‚úò plain ‚úò ‚úò ‚úò info: module_name &lt;- /Users/azproduction/project/lib/module_name.js</code> </pre><br><h6>  3 Not overloaded with require () and plugins </h6><br>  I didn‚Äôt like that require is a factory, so its behavior was slightly rewritten.  Now just <code>require()</code> loads modules from the abstract file system and nothing else.  And <code>require.*()</code> Will use the plugin <code>*</code> and do the same thing.  For example, <code>require.js()</code> load any JavaScript file by analogy with <code>$.loadScript</code> . <br><br>  Plug-ins need to be explicitly registered in the config, however, LMD will help you remember to enable the plugin if you are writing the ‚Äúcorrect code‚Äù. <br><br>  For example, in this code LMD will help not to forget 3 plug-ins: css, parallel and promise <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.css([<span class="hljs-string"><span class="hljs-string">'/pewpew.css'</span></span>, <span class="hljs-string"><span class="hljs-string">'/ololo.css'</span></span>]).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ });</code> </pre><br>  But in this code only plugin js <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> js = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.js; js(<span class="hljs-string"><span class="hljs-string">'http://site.com/file.js'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ });</code> </pre><br>  You can enable and disable plugins using inheritance and configs mixes. <br><br><h6>  4 Adaptation of modules </h6><br>  It so happens that there are some files in the project that are difficult to call modules, but they need to be used like other modules.  LMD can easily adapt any file and make a CJS module out of it at build time.  In addition to the use of text files (templates) and JSON-files do not need to prescribe either plug-ins (see text plug-in for RequireJS) or adapters.  Unlike the same RequireJS, LMD turns these files into honest modules, rather than adapting them with shim. <br><br>  Today, LMD has a bunch of plug-ins and examples of working with them and a built-in analytics system for assembly work.  And, of course, LMD makes my life easier.  Further story about LMD goes beyond the boundaries of my article.  Next time I will write an article with an example of a project on LMD. <br><br><h5>  Future? </h5><br><br> <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:modules"><img src="http://habrastorage.org/storage2/ef2/9f2/934/ef29f29341ff778490720c63f10f3ac3.png"></a> <br><br>  Yes, of course, this is ES6 Modules.  Their format is similar to many module formats from other languages ‚Äã‚Äãand meets the expectations of newbies in JavaScript.  They have all the necessary attributes of the module: import, export, module wrapper (in case you need to concatenate several files).  They are <a href="http://addyosmani.com/blog/author-in-es6-transpile-to-es5-as-a-build-step-a-workflow-for-grunt/">well broadcast in CJS and AMD</a> .  However, in the form in which they are now in draft they are difficult to use in real projects. <br><br>  Import static.  You need to use the module collector to speed up the start of the application.  Importing an external module will be blocking: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> {get, Deferred} </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"http://yandex.st/jquery/3.0/jquery.min.js"</span></span></span><span class="javascript">; get(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'/'</span></span></span><span class="javascript">).then(</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log.bind(</span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">)); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  This is almost the same. <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://yandex.st/jquery/3.0/jquery.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="javascript"><span class="xml"><span class="javascript"> </span></span><span class="hljs-keyword"><span class="xml"><span class="javascript"><span class="hljs-keyword">var</span></span></span></span><span class="xml"><span class="javascript"> get = $.get, Deferred = $.Deferred; get(</span></span><span class="hljs-string"><span class="xml"><span class="javascript"><span class="hljs-string">'/'</span></span></span></span><span class="xml"><span class="javascript">).then(</span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">console</span></span></span></span><span class="xml"><span class="javascript">.log.bind(</span></span><span class="hljs-built_in"><span class="xml"><span class="javascript"><span class="hljs-built_in">console</span></span></span></span><span class="xml"><span class="javascript">)); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In turn, the lock can be removed using <code>&lt;script async/&gt;</code> <br><br>  There is a dynamic loading of modules, but it is not perfect now: <br><pre> <code class="javascript hljs">Loader.load(<span class="hljs-string"><span class="hljs-string">'http://json.org/modules/json2.js'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JSON</span></span></span><span class="hljs-function">) </span></span>{ alert(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify([<span class="hljs-number"><span class="hljs-number">0</span></span>, {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}])); });</code> </pre><br>  I hope that the module loader will be able to load an assembly of several modules.  Then it will be enough. <br><br>  The standard is now being actively discussed and what I showed you today may be tomorrow will look different (but unlikely).  Today, the modules and syntax of import / export is similar to the one you used to see in other languages.  This is good because many developers use JavaScript and it hurts them to see wild hacks like AMD.  Today, one of the directions of development of ECMAScript is aimed at turning the language into a kind of assembler for broadcasting from other languages.  And modules are an integral part of this direction. <br><br><h5>  findings </h5><br>  Today, we can say that JavaScript does not have a well-established modular system, only modularity emulators are available, but you can use the syntax of ES6 Modules and compile your modules in CJS and AMD.  JavaScript has its own atmosphere, a lot of restrictions (network brakes, traffic, lags), which do not allow the use of many of the usual imports.  The problem of assembly and asynchronous loading is somehow solved in popular modularity emulators, but how the ES6 developers will solve it is a question. <br><br><h4>  Materiel </h4><br>  If you have mastered my modular way, then I think you will be interested in my small modular classification. <br><br>  I classified existing JavaScript ‚Äúmodules‚Äù and their infrastructure by features.  The classification takes into account many features.  Let's look at the classification of modules, and then the individual modular systems. <br><br><ul><li>  Dependency resolution <br><ul><li>  Manual control </li><li>  Dependencies are registered in the config </li><li>  Dependencies are written in the module itself. </li><li>  Dependencies are written in the module and in the config </li></ul><br></li><li>  Access to dependencies <br><ul><li>  Arbitrary </li><li>  Dynamic </li><li>  Declarative </li></ul><br></li><li>  Export from module <br><ul><li>  Chaotic export </li><li>  Strong name unmanaged export </li><li>  Self-export with a strong name </li><li>  Managed export with arbitrary name </li><li>  Honest import / export </li></ul><br></li><li>  Module failure <br><ul><li>  No build </li><li>  File concatenation by mask </li><li>  Preprocessing </li><li>  Static dependency analysis </li><li>  Build from config </li></ul><br></li><li>  Module initialization and interpretation <br><ul><li>  Initialized and interpreted at startup. </li><li>  Initialized at startup, interpreted on demand. </li><li>  Initialized and interpreted on demand. </li></ul><br></li><li>  Loading external dependencies <br><ul><li>  Unmanaged Module Loader </li><li>  Loader "managed" module </li></ul><br></li><li>  Insulation Modules <br><ul><li>  Modules not isolated </li><li>  Insulated modules </li><li>  Modules are totally isolated </li></ul><br></li></ul><br><h5>  Dependency resolution </h5><br>  How the assembly tool or the developer determines which dependencies need to be connected / initialized for the normal operation of this module.  Dependencies, in turn, can also have dependencies. <br><br><h6>  Dependency resolution.  Manual control </h6><br>  Dependency management on the developer‚Äôs shoulders.  The developer analytically understands what dependencies need to be connected. <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"deps/dep1.js"</span></span></span><span class="hljs-tag">/&gt;</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"deps/dep2.js"</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="xml"><span class="xml"><span class="xml"> </span></span><span class="hljs-tag"><span class="xml"><span class="xml"><span class="hljs-tag">&lt;</span></span></span><span class="hljs-name"><span class="xml"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span></span><span class="xml"><span class="xml"><span class="hljs-tag"> </span></span></span><span class="hljs-attr"><span class="xml"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span></span><span class="xml"><span class="xml"><span class="hljs-tag">=</span></span></span><span class="hljs-string"><span class="xml"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"moduleName.js"</span></span></span></span></span><span class="xml"><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span><span class="undefined"></span></span></span><span class="xml"><span class="xml"><span class="undefined"></span></span></span></code> </pre><br>  And accordingly in <code>main.js</code> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br><img src="http://1450827712423028101698">  No third party libraries need to be used. <br><img src="http://1450827712423028101698">  When there are not many modules and they are all yours - this is ok <br><img src="http://1450827712636035329649">  When a lot of modules such code can not be supported <br><img src="http://1450827712636035329649">  Multiple files = multiple requests to the server <br><br>  Suitable for "fast nakodit." <br><br><h6>  Dependency resolution.  Dependencies are registered in the config </h6><br>  Dependencies are registered in the external config and can be inherited.  Using this config, some assembly tool loads / connects dependencies of this module.  The config can be written both for a specific module and for the entire project. <br><br>  This config is used in LMD <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"modules"</span></span>: { <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"moduleName.js"</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;%= file %&gt;"</span></span>: <span class="hljs-string"><span class="hljs-string">"deps/*.js"</span></span> } }</code> </pre><br>  And accordingly in <code>main.js</code> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep2'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br><img src="http://1450827712423028101698">  Modules are not tied to the file system (you can give any name to any file) <br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without changing the name of the module, you can change its contents. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to write such a config. You </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need an additional tool / library.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependency resolution. </font><font style="vertical-align: inherit;">Dependencies are written in the module itself.</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The file itself declares the dependencies, the paths to the file and how they will be called during operation. </font><font style="vertical-align: inherit;">The module actually determines any resources needed for operation, and the loader provides them. </font><font style="vertical-align: inherit;">While dependencies and dependencies are not loaded, the module will not start its work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method uses AMD (RequireJS)</font></font><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'deps/dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If one module has a lot of dependencies, then this syntax is usually degraded to CommonJS define or use any perversions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perversions</font></font><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'deps/dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep2'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep3'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep4'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep5'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep6'</span></span>, <span class="hljs-string"><span class="hljs-string">'deps/dep7'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> dep1, dep2, dep3, dep4, dep5, dep6, dep7</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Degradation to commonjs define </font></font><br><pre> <code class="javascript hljs">define(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">require, module, exports</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep2'</span></span>), dep3 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep3'</span></span>), dep4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep4'</span></span>), dep5 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep5'</span></span>), dep6 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep6'</span></span>), dep7 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep7'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using such degradation, RequireJS looks for dependencies with regulars. This is 95% reliable. Honest way (AST or clever processing) consumes too many resources (amount of code and processing time), but also does not cover all needs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are cases when it is also necessary to write a config in order, for example, to adapt some old module that cannot define or if some kind of ‚Äúhonest module‚Äù is dynamically initialized - </font></font><code>require('templates/' + type)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the regular schedule cannot find it. Dynamic initialization is a rare thing and is mainly used for dynamic loading of templates, but it is possible. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almost all dependencies are described in the </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configs </font><font style="vertical-align: inherit;">file </font><font style="vertical-align: inherit;">itself asynchronously loaded </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No need to write a config</font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But sometimes you have to write it all the same. You </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need an additional tool / library.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependency resolution. </font><font style="vertical-align: inherit;">Dependencies are written in the module and in the config</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependencies are registered with the file itself and in a special config. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The config is used by any package manager to eliminate dependencies. </font><font style="vertical-align: inherit;">For example npm and</font></font><code>package.json</code> <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"3.x"</span></span>, <span class="hljs-string"><span class="hljs-string">"colors"</span></span>: <span class="hljs-string"><span class="hljs-string">"*"</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And correspondingly </font></font><code>main.js</code> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var express = require('express'); //   var dep1 = require('./deps/dep1'), dep2 = require('./deps/dep2'); module.exports function () { return dep1 + dep2; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The developer determines the list of dependencies and their versions. </font><font style="vertical-align: inherit;">The package manager loads the modules and their dependencies. </font><font style="vertical-align: inherit;">Here, in principle, without options, the manager knows nothing about the module. </font></font><code>package.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the manager, the only interaction interface. </font><font style="vertical-align: inherit;">In turn, each module can download its parts directly from the file system. </font></font><code>require('pewpew.js')</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you use this approach for the browser, there are such advantages and disadvantages. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dependencies are described in the file. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">External dependencies version control is possible. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This module can be used both on the server and on the client </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need an additional tool / library to build, for example browserify</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to dependencies </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Determines how the module uses dependencies within itself, how it accesses the required module. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access to dependencies. </font><font style="vertical-align: inherit;">Arbitrary</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All modules are open in the global scope or in the namespace. </font><font style="vertical-align: inherit;">Each module can, without any restrictions anywhere, access any part of the application in any way.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; alert(dep1 + dep2);</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are not many modules and they are not large, then this is ok. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there are many modules, then such code cannot be maintained. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It‚Äôs impossible to determine the dependencies of the module by eye (you need to look for names of global variables or namespace)</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access to dependencies. </font><font style="vertical-align: inherit;">Dynamic</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access to the module can only be obtained through the "loader" - </font></font><code>require()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or declaring the dependencies of the module through </font></font><code>define()</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method is used in most popular libraries, when the require function is forwarded through the "short circuit of the module" through which the module can access other modules. </font><font style="vertical-align: inherit;">This feature may also be available globally.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./deps/dep1'</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./deps/dep2'</span></span>); alert(dep1 + dep2);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accordingly, the way with </font></font><code>define()</code> <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'./deps/dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'./deps/dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ alert(dep1 + dep2); });</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Easy to understand / find dependencies </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access to dependencies is moderated, you can lazily initialize the module, calculate runtime dependencies, etc. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can statically determine almost the entire dependency graph </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code is a little Verbose, but this is a good support fee. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional library needed</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access to dependencies. </font><font style="vertical-align: inherit;">Declarative</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modules are declared when writing code and are not loaded dynamically. </font><font style="vertical-align: inherit;">A static code analyzer can unambiguously understand what set of modules is necessary for the application to work. </font><font style="vertical-align: inherit;">Almost all import constructions work this way.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dep1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dep2"</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also under this method of access to dependencies can be attributed, and static AMD define () </font></font><br><pre> <code class="javascript hljs">define(<span class="hljs-string"><span class="hljs-string">'module'</span></span>, [<span class="hljs-string"><span class="hljs-string">'./deps/dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'./deps/dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Static import allows collectors to collect dependencies, and ES6 Modules translators to convert code into ES3-compatible. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Static analysis is possible (full or partial). </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ES6 Modules can be translated. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In its pure form it is rarely applicable.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Export from module </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most often, modules provide some resources that other modules can use. </font><font style="vertical-align: inherit;">These can be data, utilities (format of dates, numbers, i18n, etc.). </font><font style="vertical-align: inherit;">Exporting from a module determines how the module says ‚ÄúI provide such and such resources‚Äù.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Export. </font><font style="vertical-align: inherit;">Chaotic export</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The module exports anything, anytime, anywhere. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = b;</code> </pre><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clogged global scope of </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hell and nightmare, in any case this is not supported in principle</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Export. </font><font style="vertical-align: inherit;">Strong name unmanaged export</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we slightly modify the previous method by adding IIFE, we will get this method. </font><font style="vertical-align: inherit;">The module knows in advance where it will lie and how it will be called.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; })();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Or a slightly different option. </font></font><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } exports.dep1 = b; })(exports);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Or named AMD </font></font><br><pre> <code class="javascript hljs">define(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, [], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; });</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's easy. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No special tools are needed for building and using such modules (except AMD). </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only the necessary one is exported. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module knows where it is exported and what its name will be</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Export. </font><font style="vertical-align: inherit;">Self-export with a strong name</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basis of this method is a special function of ‚Äúregistering a module‚Äù </font></font><code>ready()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which a module must call when it is ready. </font><font style="vertical-align: inherit;">It takes 2 arguments - the name of the module and the resources it provides.</font></font><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } ready(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, b); })();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To download the dependencies of such a module, a function </font></font><code>load()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar to</font></font><code>require()</code> <br><pre> <code class="javascript hljs">load(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ ready(<span class="hljs-string"><span class="hljs-string">'dep3'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }); });</code> </pre><br><pre> <code class="javascript hljs">load(<span class="hljs-string"><span class="hljs-string">'dep3'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>.stuff);</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A module is exported asynchronously and can postpone its export. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module does not know where it will be. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module is exported itself (the module subordinates the module that uses it). </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module knows its name and can change it dynamically. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module can register several modules. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A special library is needed.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Export. </font><font style="vertical-align: inherit;">Managed export with arbitrary name</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module does not know its name or where it will lie. </font><font style="vertical-align: inherit;">The consumer of the module itself determines how this module will be called in the context of the consumer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is CommonJS module</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = b;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or anonymous AMD </font></font><br><pre> <code class="javascript hljs">define([], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We can use any name during the export of the module. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'deps/dep1'</span></span>);</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module does not know where it is or what it will be called when using. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When renaming a module, you only need to rename the file. You </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need a library to build and use</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Export. </font><font style="vertical-align: inherit;">Honest import / export</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method of module declaration uses every second programming language. </font><font style="vertical-align: inherit;">ECMAScript 6 Modules specification appeared long enough, therefore, sooner or later such syntax will come in JavaScript. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We declare the module.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> <span class="hljs-string"><span class="hljs-string">"deps"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = b; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep2 = b + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also declare a module without binding </font></font><code>module {}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use default names and write less</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"deps"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dep1);</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can avoid name conflicts using a kind of ‚Äúnamespace‚Äù </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"crypto"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ns; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ns.dep1);</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can export part of the module </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {dep1} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"deps"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dep1);</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Familiar imports from many languages ‚Äã‚Äã- familiar and clear </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is ECMAScript 6 </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to translate the ES6 module into ES3-compatible code, for example, use modules from TypeScript</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module failure </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Today, almost all modules are assembled as well. </font><font style="vertical-align: inherit;">Even if you do not use CoffeeScript and AMD, then in any case you collect your project: concatenate files, compress them.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No build </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All in html </font></font><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"deps/dep1.js"</span></span></span><span class="hljs-tag">/&gt;</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"deps/dep2.js"</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="xml"><span class="xml"><span class="xml"> </span></span><span class="hljs-tag"><span class="xml"><span class="xml"><span class="hljs-tag">&lt;</span></span></span><span class="hljs-name"><span class="xml"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span></span><span class="xml"><span class="xml"><span class="hljs-tag"> </span></span></span><span class="hljs-attr"><span class="xml"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span></span><span class="xml"><span class="xml"><span class="hljs-tag">=</span></span></span><span class="hljs-string"><span class="xml"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"moduleName.js"</span></span></span></span></span><span class="xml"><span class="xml"><span class="hljs-tag">/&gt;</span></span></span></span><span class="undefined"></span></span></span><span class="xml"><span class="xml"><span class="undefined"></span></span></span></code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's easy. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With an increase in the number of modules, the application ceases to be supported and begins to slow down due to an increase in the number of requests. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML entity blending and the declaration of the module. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New assembly - new .html</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly of modules. </font><font style="vertical-align: inherit;">File concatenation by mask</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We collect </font></font><br><pre> <code class="bash hljs">$ cat **/*.js &gt; build.js</code> </pre><br>  We use <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"build.js"</span></span></span><span class="hljs-tag">/&gt;</span></span><span class="undefined"></span><span class="undefined"></span></code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's quite simple. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only 1 file is loaded. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each type of assembly, you need to create new scripts. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Files can be assembled in random order in different OS and FS.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembly of modules. </font><font style="vertical-align: inherit;">Preprocessing</font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The way is to search for special "tags" in files - </font></font><code>include('path/name.js')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>// include path/name.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar ones.</font></font><br><pre> <code class="javascript hljs">include(<span class="hljs-string"><span class="hljs-string">'deps/dep1.js'</span></span>); include(<span class="hljs-string"><span class="hljs-string">'deps/dep2.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All this is developed by a special utility in such a format. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* start of deps/dep1.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* end of deps/dep1.js */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* start of deps/dep2.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* end of deps/dep2.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br>              . <br><br><img src="http://1450827712423028101698">   1  <br><img src="http://1450827712423028101698">   - ¬´ ¬ª <br><img src="http://1450827712636035329649">            <code>include</code> <br><img src="http://1450827712636035329649">           <br><img src="http://1450827712636035329649">         <br><br>         ,    <code>"use strict"</code> ,     . <br><br>    <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; include(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     return dep1 + i; })();</span></span></code> </pre><br>    <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">4</span></span>, dep = <span class="hljs-number"><span class="hljs-number">01234</span></span>;</code> </pre><br> ,    ;-) <br><br><h6>  .    </h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Static analysis of the content of the module with the search for dependencies. </font><font style="vertical-align: inherit;">This method uses r.js (RequireJS modules collector) and browserify (CommonJS modules adapter and browser Node.js infrastructure). </font><font style="vertical-align: inherit;">They use an AST parser, look for define / require calls and thus find dependencies and, unlike include, place these dependencies outside the module. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, here is such a module</font></font><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if it is driven through r.js, it will be redone here </font></font><br><pre> <code class="javascript hljs">define(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, [], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }); define(<span class="hljs-string"><span class="hljs-string">'dep2'</span></span>, [], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; }); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br> browserify    ,      <br><br><img src="http://1450827712423028101698">   1  <br><img src="http://1450827712423028101698">       <br><img src="http://1450827712636035329649">              <br><img src="http://1450827712636035329649">       (   ) <br><img src="http://1450827712636035329649">       ,     <br><br><h6>  .    </h6><br>    .      .        .      ,   -   - . <br><br>    LMD. <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"root"</span></span>: <span class="hljs-string"><span class="hljs-string">"../js"</span></span>, <span class="hljs-string"><span class="hljs-string">"modules"</span></span>: { <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"main.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"dep1"</span></span>: <span class="hljs-string"><span class="hljs-string">"deps/dep1.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"dep2"</span></span>: <span class="hljs-string"><span class="hljs-string">"deps/dep2.js"</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The option, of course, is interesting, but why write the same thing 2 times in the module and in the config file ?! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is easily explained. LMD does not know about the file system, and the config is actually an abstract file system. This allows you not to think about relative paths and during the transfer / rename module do not run and do not change the path for the entire project. Using abstract FS, it becomes possible to get cheap Dependency Injection for localization, changing environment configs and other optimizations. It also happens that the modules are connected dynamically and the static analyzer cannot physically find them, so you have to make an entry about the module in the config. It is clear that registering the module to the config each time is a step backwards, so LMD has the ability to connect entire directories with subdirectories using </font></font><a href="http://en.wikipedia.org/wiki/Glob_(programming)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glob-ing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a kind of rewrite rule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This config is identical to the previous one.</font></font><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"root"</span></span>: <span class="hljs-string"><span class="hljs-string">"../js"</span></span>, <span class="hljs-string"><span class="hljs-string">"modules"</span></span>: { <span class="hljs-string"><span class="hljs-string">"&lt;%= file %&gt;"</span></span>: <span class="hljs-string"><span class="hljs-string">"**/*.js"</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You determine which files are needed, and then write the template and thereby say how they need to submit this LMD module. </font><font style="vertical-align: inherit;">To determine the name, LMD uses a template engine from lodash, so you can write more </font></font><a href="https://github.com/azproduction/lmd/tree/master/examples/features/glob"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clever constructs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"root"</span></span>: <span class="hljs-string"><span class="hljs-string">"../js"</span></span>, <span class="hljs-string"><span class="hljs-string">"modules"</span></span>: { <span class="hljs-string"><span class="hljs-string">"&lt;%= file %&gt;&lt;%= dir[0][0].toUpperCase() %&gt;&lt;%= dir[0].slice(1, -1) %&gt;"</span></span>: <span class="hljs-string"><span class="hljs-string">"{controllers,models,views}/*.js"</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results of this method are as follows: </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clearly - the entire project tree can be described in one file </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliably - analyzer errors are excluded </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract file system </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Need to write a config </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Need a collector</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module initialization and interpretation </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is quite an important point, which allows you to reduce the lag when the application starts, when a lot of code is executed. </font><font style="vertical-align: inherit;">When the code gets to the page, it is initialized (the function was written - it registered under some name) during initialization, the code is parsed, validated and transferred to AST for further interpretation and possible JIT compilation. </font><font style="vertical-align: inherit;">When a function is called, its code is interpreted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function is not initialized and not interpreted. </font><font style="vertical-align: inherit;">Only javascript string is initialized.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'function a() {return Math.PI;}'</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The function is initialized. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The function is initialized and interpreted. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI; } a();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each function declaration and its call takes some time, especially on mobile, so it would be good to reduce this time. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialized and interpreted at startup. </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module is delivered as it is and runs when the program starts. </font><font style="vertical-align: inherit;">Even if we don't need it right now. </font><font style="vertical-align: inherit;">As you can see in the module there are some cycles that can slow down the work.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; })();</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No need to use additional tools. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the code is not large, then the initialization time is not significant. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the amount of code increases, Startup Latency begins to manifest.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialized at startup, interpreted on demand. </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now quite popular method that is used by both AMD and modules in Node.js </font></font><br><pre> <code class="javascript hljs">define(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, [], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This module will be initialized at startup. </font><font style="vertical-align: inherit;">But his body will be executed on demand, and the result will be </font></font><code>return b;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cached and the next call will not be interpreted. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You do not need to change much of the appearance of the </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startup Latency </font><font style="vertical-align: inherit;">module; it is </font><font style="vertical-align: inherit;">significantly reduced with a large amount of code. An </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">additional library is needed.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialized and interpreted on demand. </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small modification of the previous method, which allows to postpone the initialization of the code. </font><font style="vertical-align: inherit;">It is mainly used to optimize code loading on mobile devices. </font><font style="vertical-align: inherit;">This optimization can be done for RequireJS and for LMD. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A piece of LMD assembly (not config)</font></font><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">'dep1'</span></span>: <span class="hljs-string"><span class="hljs-string">'(function(){var a=10,b="";for(var i=0;i&lt;a;i++){b+=i;}return b;})'</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a module requires module resources </font></font><code>dep1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the LMD interprets and initializes this code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something like this:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resources = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'return '</span></span> + modules[<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>])()(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, exports);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initialization time of the code through </font></font><code>new Function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be a little slower than through fair initialization, but if you use this optimization wisely, then we can gain time at the start. </font><font style="vertical-align: inherit;">The generated code </font><font style="vertical-align: inherit;">can be optimized by the JIT compiler </font></font><code>new Function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as opposed to </font></font><code>eval()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This operation is transparent to the developer. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional library is </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">needed.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loading external dependencies </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said, JavaScript @ DOM has its own atmosphere, so the usual methods for loading modules do not work here. </font><font style="vertical-align: inherit;">The modules lie remotely and their synchronous loading is not real. </font><font style="vertical-align: inherit;">If in the desktop application we can synchronously link the library ‚Äúat the speed of light‚Äù, then in JavaScript @ DOM this is hardly realistic due to the EventLoop blocking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We cannot download everything at once, so we have to invent and suffer something :)</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unmanaged Module Loader </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By an unsupported module, I simply understand any code that does not require any additional processing. </font><font style="vertical-align: inherit;">Such a loader, for example, is </font></font><code>jQuery.getScript(file)</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">about the following:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>); script.src = file; script.onload = done; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you load several modules at the same time, they will be executed in the order of loading. </font><font style="vertical-align: inherit;">It so happens that you need to run the modules in the order they are listed. </font><font style="vertical-align: inherit;">The LAB.js library, for example, uses XHR to simultaneously download script code, and then executes this code sequentially. </font><font style="vertical-align: inherit;">XHR, in turn, introduces its limitations.</font></font><br><pre> <code class="javascript hljs">$LAB .script(<span class="hljs-string"><span class="hljs-string">"framework.js"</span></span>).wait() .script(<span class="hljs-string"><span class="hljs-string">"plugin.framework.js"</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rest of the boot loaders, like YepNope and script.js, do about the same thing. </font></font><br><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheap solution </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There may be restrictions on the part of XHR or additional writing.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loader "managed" module </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any adult modular system comes with its own loader and can load any modules and their dependencies. </font><font style="vertical-align: inherit;">For example, it does function </font></font><code>require()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>define()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of RequireJS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>require()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from RequireJS will load the necessary dependencies and dependencies of dependencies and execute the code of these modules in the specified order.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dep1 + dep2); });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In LMD, for example, there is such a thing as a bundle - several modules assembled into one file. </font><font style="vertical-align: inherit;">When downloading this bundle, all its modules become available to any module.</font></font><br><pre> <code class="javascript hljs">_e4fg43a({ <span class="hljs-string"><span class="hljs-string">'dep1'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello, &lt;%= name %&gt;!'</span></span> });</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.bundle(<span class="hljs-string"><span class="hljs-string">'name'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff });</span></span></code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manage both module loading and initialization. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Almost transparent for developer. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requires additional tools and configuration.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insulation Modules </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The security of modules or their isolation is needed, rather for developers than for those who break their labors. </font><font style="vertical-align: inherit;">Direct and chaotic access to the properties of the modules can, if misused, ‚Äúspoil the code‚Äù. </font><font style="vertical-align: inherit;">On the other hand, if there are no traces of your JavaScript in the global scope, it will be harder for the researcher of your code to understand and ‚Äúbreak‚Äù something, but then it‚Äôs more of a question of time.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modules not isolated </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The module or some of its parts are available globally, any developer from any place can take and use. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; })();</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, this is just. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No tools needed. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to think about namespaces. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no division of labor for a module. </font><font style="vertical-align: inherit;">He does his job and he manages to get dependencies.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insulated modules </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module is not available globally, but it can be obtained by knowing the name - </font></font><code>require('pewpew')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hiding, as I said, is not the goal of a modular system, but a consequence. </font><font style="vertical-align: inherit;">In AMD there are 2 functions with which you can somehow access the module - this </font></font><code>require()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>define()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It is enough to know the code name of the module to get its resources.</font></font><br><pre> <code class="javascript hljs">define(<span class="hljs-string"><span class="hljs-string">'dep3'</span></span>, [<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>, <span class="hljs-string"><span class="hljs-string">'dep2'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The modules are isolated from other modules and you cannot spoil anything. </font></font><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access to another module is explicitly declared. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Special libraries </font><font style="vertical-align: inherit;">are </font><font style="vertical-align: inherit;">needed to work with such modules.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modules are totally isolated </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The purpose of such modules is to make it impossible to reach the module from the outside. </font><font style="vertical-align: inherit;">I think many have already seen such "modules", for example:</font></font><br><pre> <code class="javascript hljs">$(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>, b = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) { b += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; })(); $(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).click(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dep1); }); });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it is a totally isolated module; one cannot reach its insides from the outside. </font><font style="vertical-align: inherit;">But this is an example of a single module. </font><font style="vertical-align: inherit;">If each such module is wrapped in a "closure", then they will not be able to interact. </font><font style="vertical-align: inherit;">To isolate several modules, they can be placed in a common field of view or some common resources can be thrown into their field of view. </font><font style="vertical-align: inherit;">With the help of these resources, such modules will be able to communicate with each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enough to wrap these modules in IEFE:</font></font><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* start of deps/dep1.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* start of deps/dep2.js */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; })();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This build method uses, for example, jQuery. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LMD and browserify also totally isolate modules from the environment, but unlike the all-in-one assembly, their modules are isolated from each other and from the control part of the assembly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They are going about here in this structure:</font></font><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">main, modules</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lmd_require</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// ... main(lmd_require); }) (function (require) { var dep1 = require('dep1'); // ... }, { dep1: function (r,m,e) {} });</span></span></code> </pre><br><img src="http://1450827712423028101698"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the simple case, total isolation can be easily achieved. </font></font><br><img src="http://1450827712636035329649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For other cases, additional tools are needed.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparative table of popular module emulators in JavaScript </font></font></h4><br><table><tbody><tr><th></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AMD, YUI </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ES6 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CJS / LMD </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IEFE </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dependency resolution </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In module + config </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the module </font></font></td><td>  In config </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manual </font></font></td></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to dependencies </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Declarative </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbitrary </font></font></td></tr><tr><th>  Export </th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With arbitrary name </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Honest import / export </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With arbitrary name </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaotic / Uncontrollable </font></font></td></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module failure </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Static analysis </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not needed / Concatenation </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Build from config </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concatenation </font></font></td></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpretation of the module </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On demand </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Native solution </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On demand </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At start </font></font></td></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insulation Modules </font></font></th><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isolated </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isolated </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Totally isolated </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not isolated </font></font></td></tr></tbody></table><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Common Module Formats </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And finally, some background information on the existing modulators "emulators" in JavaScript. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No module </font></font></h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Namespace </font></font></h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyNs.moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyNs.dep1 + MyNs.dep2; };</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IIFE return </font></font></h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleName = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; }(dep1, dep2));</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IIFE exports </font></font></h5><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exports, dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ exports.moduleName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; }(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>, dep1, dep2));</code> </pre><br><h5>  AMD </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUI modules are semantically similar to AMD. </font><font style="vertical-align: inherit;">I will not show them.</font></font><br><pre> <code class="javascript hljs">define([<span class="hljs-string"><span class="hljs-string">"dep1"</span></span>, <span class="hljs-string"><span class="hljs-string">"dep2"</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dep1, dep2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AMD wrapper for CommonJS </font></font></h5><br><pre> <code class="javascript hljs">define(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">require, module, exports</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep2'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; }; });</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Commonjs </font></font></h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dep1 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep1'</span></span>), dep2 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dep2'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dep1 + dep2; };</code> </pre><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UMD </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be seen that now there are at least 3 formats of modules that need to be supported. </font><font style="vertical-align: inherit;">It's one thing if you write your project and can write on anything. </font><font style="vertical-align: inherit;">Another thing is open-source projects in which it would be good to support all formats. </font><font style="vertical-align: inherit;">All these modules are just different wrappers that essentially do the same thing - take resources and provide resources. </font><font style="vertical-align: inherit;">Not so long ago, the </font></font><a href="https://github.com/umdjs/umd"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UMD: Universal Module Definition</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project appeared </font><font style="vertical-align: inherit;">, which ‚Äústandardized‚Äù a universal wrapper for all formats.</font></font><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">root, factory</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> exports === <span class="hljs-string"><span class="hljs-string">'object'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  1: CommonJS factory(exports, require('dep1'), require('dep2')); } else if (typeof define === 'function' &amp;&amp; define.amd) { //  2: AMD ( ) define(['exports', 'dep1', 'dep2'], factory); } else { //  3:    factory(window, root.dep1, root.dep2); } })(this, function (exports, dep1, dep2) { //  exports.moduleName = function () { return dep1 + dep2; }; });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is clear that in the development of such a use is somehow strange, but the "export" is the most. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Read </font></font></h4><br><ol><li> <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript Module Pattern: In-Depth</font></font></a> </li><li> <a href="http://yuilibrary.com/yui/docs/yui/create.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating YUI Modules</font></font></a> </li><li> <a href="http://addyosmani.com/writing-modular-js/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Writing Modular JavaScript With AMD, CommonJS &amp; ES Harmony</font></font></a> </li><li> <a href="http://requirejs.org/docs/whyamd.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why AMD?</font></font></a> </li><li> <a href="http://tomdale.net/2012/01/amd-is-not-the-answer/">AMD is Not the Answer</a> </li><li> <a href="http://tagneto.blogspot.ru/2011/11/why-not-amd.html">Why not AMD?</a> </li><li> <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:modules">Proposal ES6 Modules</a> </li><li> <a href="http://blog.bittersweetryan.com/2013/02/playing-with-ecmascriptharmony-modules.html">Playing with ECMAScript.Harmony Modules using Traceur</a> </li><li> <a href="http://addyosmani.com/blog/author-in-es6-transpile-to-es5-as-a-build-step-a-workflow-for-grunt/">Author In ES6, Transpile To ES5 As A Build-step: A Workflow For Grunt</a> </li></ol><br> <font color="#999">   , ,  .</font> </div><p>Source: <a href="https://habr.com/ru/post/181536/">https://habr.com/ru/post/181536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181524/index.html">Skype and Lync - there is a contact</a></li>
<li><a href="../181526/index.html">Screencast by Node.JS</a></li>
<li><a href="../181528/index.html">How is the IT survey?</a></li>
<li><a href="../181530/index.html">Coordination of user actions in VMware before their execution</a></li>
<li><a href="../181534/index.html">Who are you? Bot? Let's goodbye!</a></li>
<li><a href="../181538/index.html">Top 5 Tips to Increase Android Phone Running Time</a></li>
<li><a href="../181540/index.html">What can modern quadrocopters?</a></li>
<li><a href="../181542/index.html">HTC One Review</a></li>
<li><a href="../181544/index.html">New rules of the official game</a></li>
<li><a href="../181546/index.html">Trends in the mobile development market in 2013</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>