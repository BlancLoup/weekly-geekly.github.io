<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>View OpenCV images while debugging C ++ code in Visual Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you write code to process images in C ++, you probably use the wonderful OpenCV library . I am sure you have repeatedly wanted to look at the image...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>View OpenCV images while debugging C ++ code in Visual Studio</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/c50/285/d62/c50285d6276ead1c7b2015ac716cc511.png"><br><br>  If you write code to process images in C ++, you probably use the wonderful <a href="http://opencv.willowgarage.com/wiki/">OpenCV library</a> .  I am sure you have repeatedly wanted to look at the images in the process of debugging your code.  To do this, you can use such convenient functions as <a href="http://docs.opencv.org/modules/highgui/doc/user_interface.html">imshow</a> or <a href="http://docs.opencv.org/modules/highgui/doc/reading_and_writing_images_and_video.html">imwrite</a> .  However, this requires modification of the source code, and any modern IDE during debugging allows you to watch the values ‚Äã‚Äãof variables on the fly.  Wouldn't it be great to look at the images? <br><br>  If you use Visual Studio as an IDE, then you know that <a href="http://code.google.com/p/opencvsharp/wiki/DebuggerVisualizer">everything is</a> <a href="http://victorhurdugaci.com/projects/vsimagevisualizer/">simpler</a> with <a href="http://code.google.com/p/opencvsharp/">.NET</a> .  However, we are talking about OpenCV, and this is only native C ++, only hardcore.  In this article, I‚Äôll tell you how to make Visual Studio show images right during the debugging process and give you a link to a ready-made solution.  And also briefly talk about how to customize Visual Studio. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  For those who just want to use a ready-made solution, I‚Äôll immediately provide links: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://sourceforge.net/projects/nativeviewer/">NativeViewer at SourceForge</a> </li><li>  <a href="http://visualstudiogallery.msdn.microsoft.com/657956e4-8e02-4764-8022-72a0c9cc5b17">NativeViewer for Visual Studio 2010 in Visual Studio Extensions Gallery</a> </li><li>  <a href="http://visualstudiogallery.msdn.microsoft.com/26a8aecf-03b0-49ff-b691-41844c52f20e">NativeViewer for Visual Studio 2012 in Visual Studio Extensions Gallery</a> </li></ul><br>  I will briefly tell the rest about the tools with which you can, in principle, customize Visual Studio, and in more detail about the implementation of the solution by one of them.  All experiments were performed in Visual Studio 2010, the turnkey solution was tested in Visual Studio 2005, 2008, 2010, 2012 (and in theory should work in 2003). <br><br><h4>  Search for a turnkey solution </h4><br>  When I needed to work on debugging C ++ code that uses OpenCV for working with images, I immediately wanted to be able to watch them directly during debugging.  I happily climbed into Google, and began to look for ready-made solutions.  And ... found nothing.  Neither for OpenCV images, nor for generally visualizing anything from native C ++ code.  I <a href="http://stackoverflow.com/questions/9080283/debugging-unmanaged-c-images-in-visual-studio">asked the public</a> what <a href="http://stackoverflow.com/users/17034/hans-passant">the resident credible</a> <a href="http://stackoverflow.com/questions/9080283/debugging-unmanaged-c-images-in-visual-studio">said to</a> me <a href="http://stackoverflow.com/questions/9080283/debugging-unmanaged-c-images-in-visual-studio">that</a> , in principle, the native code debugger cannot be extended in this way.  At this point, I was convinced that the bike was not yet invented. <br><br><h4>  Visual Studio Customization Features </h4><br>  To choose a suitable tool for the visualizer, you need at least an approximation of which sides you can extend Visual Studio from.  First we need to know two things: <br><br><ul><li>  <b><a href="http://msdn.microsoft.com/en-us/library/envdte.dte(v%3Dvs.100).aspx">DTE</a></b> Visual Studio Interface, which was introduced in .NET versions (since 2003).  With it, you can get objects that provide access to the most different parts of Visual Studio ‚Äî the solution structure, shell settings, active window, even the debugger. </li><li>  <b><a href="http://mef.codeplex.com/">The MEF</a></b> Managed Extensibility Framework is a newer model, available from Visual Studio 2010. Allows for tighter integration and allows for interoperability of MEF components, which in turn can use DTE. </li></ul><br>  The following is a list of entities used to customize Visual Studio.  The list was compiled for a specific task, therefore it does not claim to be complete. <br><br><ul><li>  <b><a href="http://msdn.microsoft.com/en-us/library/b4c73967(v%3Dvs.100).aspx">Macros (Macros)</a></b> Excellent for automating any actions performed on the source code, project structure, etc.  With their help, you can check the style of the code, generate templates, record and play back some user actions.  Have access to DTE.  Available in Tools ‚Üí Macros. </li><li>  <b><a href="http://msdn.microsoft.com/en-us/library/5abkeks7(v%3Dvs.100).aspx">Add-ons (Add-Ins)</a></b> Appeared since Visual Studio .NET.  Used for any conceivable customization, from improved syntax highlighting to integration of the version control system.  Have access to DTE.  Available through Tools ‚Üí Add-In Manager. </li><li>  <b><a href="http://msdn.microsoft.com/en-us/library/dd885119(v%3Dvs.100).aspx">Extensions</a></b> Appeared since Visual Studio 2010, are a more advanced version of add-ons (a list of differences <a href="http://keyvan.io/visual-studio-addin-vs-integration-package-part-4">here</a> ).  Interact with MEF.  Available through Tools ‚Üí Extension Manager. </li><li>  <b><a href="http://msdn.microsoft.com/en-us/library/zayyhzts(v%3Dvs.100).aspx">Visualizers (Visualizers)</a></b> Designed to display objects in the debugging process.  Available when clicking a small icon with a magnifying glass next to the variable name when displaying its contents. </li></ul><br>  It would seem that visualizers are exactly what you need.  But here's the bad luck - they only work with managed C ++.  The first three options (macros, add-ons and extensions) can access the memory of the process being debugged only by using the <a href="http://msdn.microsoft.com/en-us/library/envdte.debugger(v%3Dvs.100).aspx">Debugger</a> object, which only has <a href="http://msdn.microsoft.com/en-us/library/envdte.debugger.executestatement(v%3Dvs.100).aspx">ExecuteStatement</a> and <a href="http://msdn.microsoft.com/en-us/library/envdte.debugger.getexpression(v%3Dvs.100).aspx">GetExpression</a> from the appropriate functions.  However, both of them somehow return the results in the form of strings limited in size.  Of course, you can try to tear out the contents of the image piece by piece and translate it back into a binary form, but it turns out somehow very crooked. <br><br>  There is also such a magic file called autoexp.dat.  It is installed with Visual Studio and usually lies at <br><br><pre><code class="dos hljs">:\Program Files (x86)\Microsoft Visual Studio &lt;vs_version&gt;\Common7\Packages\Debugger\autoexp.dat</code> </pre> <br>  It describes the rules according to which the contents of variables are displayed when debugging native C ++ code.  It is he who makes, for example, the contents of the std :: vector container look like on the left, not like on the right: <br><br><img src="https://habrastorage.org/storage2/8ab/aae/71c/8abaae71c603a9cff28fd22d228dde85.png"><br><br>  And this is how he does it: <br><br><div class="spoiler">  <b class="spoiler_title">Output rule std :: vector in autoexp.dat</b> <div class="spoiler_text"><pre> ; ------------------------------------------------- -----------------------------
 ;  std :: vector from &lt;vector&gt;
 ; ------------------------------------------------- -----------------------------
 ;  vector is previewed with "[&lt;size&gt;] (&lt;elements&gt;)".
 ;  It has [size] and [capacity] children, followed by its elements.
 ;  The other containers follow its example.
 std :: vector &lt;*&gt; {
	 preview (
		 # (
			 "[",
			 $ e._Mylast - $ e._Myfirst,
			 "] (",
			 #array (
				 expr: $ e._Myfirst [$ i],
				 size: $ e._Mylast - $ e._Myfirst
			 ),
			 ")"
		 )
	 )

	 children (
		 # (
			 # ([size]: $ e._Mylast - $ e._Myfirst),
			 # ([capacity]: $ e._Myend - $ e._Myfirst),
			 #array (
				 expr: $ e._Myfirst [$ i],
				 size: $ e._Mylast - $ e._Myfirst
			 )
		 )
	 )
 }
 std :: _ Vector_iterator &lt;*&gt; | std :: _ Vector_const_iterator &lt;*&gt; {
	 preview (
		 * $ e._Ptr
	 )

	 children (
		 # ([ptr]: $ e._Ptr)
	 )
 }
</pre></div></div><br>  This is an old, poorly documented technology.  It is supported starting from Visual C ++ 6.0.  A small guide on the use <a href="http://www.idigitalhouse.com/Blog/%3Fp%3D83">here</a> .  However, it turned out that it is she who will <s>save the father of Russian democracy that</s> will allow us to get normal access to the memory of the process being debugged.  In addition, if you often work with complex multi-level structures (for example, consider geometry using <a href="http://www.cgal.org/">CGAL</a> ), a couple of manually added rules in this file can seriously simplify your life. <br><br>  It turns out that the syntax of the autoexp.dat file allows not only to write expressions for, for example, address arithmetic, but also to call any third-party code in general!  This is done using the special $ ADDIN construct.  In the absence of the best, I used this tool for my visualizer. <br><br><h4>  Expression Evaluator Add-In Solution </h4><br>  A small guide to writing libraries for the autoexp.dat file is <a href="http://msdn.microsoft.com/en-us/library/8fwk67y3%2528v%3Dvs.90%2529.aspx">available on MSDN</a> , where they call it the Expression Evaluator Add-In.  To call a library function, simply specify the path to the .dll file and the name of the function being called. <br><br><pre> <code class="dos hljs"><span class="hljs-function"><span class="hljs-function">cv::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mat</span></span></span><span class="hljs-function">=$</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADDIN</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NativeViewer.dll</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CvMatViewer</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  The prototype of the function in the dll is as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CvMatViewer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD dwAddress, DEBUGHELPER* pHelper, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nBase, BOOL bUniStrings, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pResult, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max, DWORD reserved)</span></span></span></span></code> </pre><br>  In the pHelper argument, a pointer is passed to the DEBUGHELPER structure, which provides functions for accessing the memory of the process being debugged and returns the address of the object displayed in the debugger: <br><br><div class="spoiler">  <b class="spoiler_title">Structure Code DEBUGHELPER</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tagDEBUGHELPER</span></span></span><span class="hljs-class"> {</span></span> DWORD dwVersion; HRESULT (WINAPI *ReadDebuggeeMemory)( struct tagDEBUGHELPER *pThis, DWORD dwAddr, DWORD nWant, VOID* pWhere, DWORD *nGot ); <span class="hljs-comment"><span class="hljs-comment">// from here only when dwVersion &gt;= 0x20000 DWORDLONG (WINAPI *GetRealAddress)( struct tagDEBUGHELPER *pThis ); HRESULT (WINAPI *ReadDebuggeeMemoryEx)( struct tagDEBUGHELPER *pThis, DWORDLONG qwAddr, DWORD nWant, VOID* pWhere, DWORD *nGot ); int (WINAPI *GetProcessorType)( struct tagDEBUGHELPER *pThis ); } DEBUGHELPER;</span></span></code> </pre></div></div><br>  In pResult, you need to save the string shown by the debugger.  In theory, this is all that this function should do.  But who will stop us?  We already have access to memory.  And then, as they say, the matter of technology. <br><br><h5>  Extract image content </h5><br>  The only type information currently available to us is its name, cv :: Mat.  This means that you have to calculate the field addresses based on the .h file of a particular version of OpenCV.  However, I do not think that in the future the structure of the fields of this fundamental class will change. <br><br>  I will not dwell on technical issues in detail, such as knowing how to read an object from memory, knowing its address and having an .h file with its description, the sources are uploaded to SourceForge.  I will only note that the pHelper structure allows you to find out the bit depth of the process being debugged.  This means that you need to take into account that pointers can be either 4 or 8 bytes in size.  When we read all the fields of the cv :: Mat object, we can also read the contents of the image itself, because  its address is in the data field. <br><br><h5>  Formatting the display string </h5><br>  Well, since we're still here, let's really format the line displayed by the debugger.  And then the standard insides do not look very nice.  We do something like this: <br><br><img src="https://habrastorage.org/storage2/15d/58e/136/15d58e136985867b1b02455314d8abcc.png"><br><br><h5>  Image visualization </h5><br>  Actually, for the sake of what we are here and gathered.  Now that we have an image, we can render it using .NET.  I used the good old Windows Forms and C #.  The form with the dialog for visualization is in a separate assembly, the System.Bitmap object is passed to it in the constructor.  To construct it, the original dll was built with .NET support, with the / clr key.  This allowed the use of C ++ / CLI. <br><br>  I was worried that calling the .NET-dialog from the native library would cause difficulties and would have to create the AppDomain myself.  However, since the studio itself is a .NET application, nothing like that was done.  It all worked right away, so I didn‚Äôt begin to understand more.  I will only note that I had to show the dialogue from a separate thread with the ApartmentState :: STA parameter, otherwise there were problems when opening additional dialogs, for example, to save the image to a disk. <br><br>  Now we are faced with the main drawback of the chosen approach - it is impossible to determine whether the function is called when formatting the output in the Watch window, or when the user hovers over a variable in the editor.  If every time to show the window with the image, it will not be possible to use it. <br><br>  The only adequate solution that I could come up with is the following: the window is displayed only if any special key is pressed.  Namely, Ctrl.  Otherwise, only the output string is formatted.  Thus, in order to view the image in the process of debugging, the user needs to hold down Ctrl, aim the variable in the editor and then a window will pop up.  Crooked, yes, but in fact it turned out to be quite convenient to use. <br><br><img src="https://habrastorage.org/storage2/fe0/f95/f99/fe0f95f99a299f9cd024cb8e1c32922b.png"><br><br>  When the window with the image is shown, the Visual Studio process is blocked, because  formally, we are in the debugger output formatting function.  This is unpleasant, but there is nothing fatal about it, because  There is no need to simultaneously study the image and continue to interact with the studio. <br><br><h5>  Integration with Visual Studio </h5><br>  There is a solution, now you need to pack it.  The existing extension mechanism is great for this.  Initially, I focused on Visual Studio 2010, so I chose more modern extensions, and not more universal add-ons. <br><br>  Creating extensions is <a href="http://blogs.msdn.com/b/visualstudio/archive/2010/02/19/how-vsix-extensions-are-discovered-and-loaded-in-vs-2010.aspx">well documented</a> .  First, we need the <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D2680">Visual Studio SDK</a> (for 2010 or 2012).  After installation, you can create a new Visual C # ‚Üí Extensibility ‚Üí Visual Studio Package project.  This will launch a wizard that will ask for information about the extension: <br><br><img src="https://habrastorage.org/storage2/ada/4ef/ee1/ada4efee180c287b9a8fc79976b6db93.png"><br><br>  By default, he suggests creating a menu command (Menu Comand), a tool window (Tool Window), or tweaking the editor (Custom Editor).  We do not need any of this.  The fact is that the extension is a VSIX file, which is just a zip archive.  When installed in Visual Studio, it unpacks it into one of the user directories (more details <a href="http://blogs.msdn.com/b/visualstudio/archive/2009/12/07/bootstrapping-of-vs-packages-and-vsix-extensions-in-vs2010.aspx">here</a> ).  There may be libraries interacting with MEF, but there may be any other files.  For example, our library with Expression Evaluator Add-In. <br><br>  There is a small problem with loading the assembly with a form for visualization.  If you add it to References, then its search will occur in the directory with the devenv.exe executable file and in the <acronym>GAC</acronym> .  It is also located in the directory with the extension, so it has to be loaded manually using the <a href="http://msdn.microsoft.com/en-us/library/1009fa28(v%3Dvs.100).aspx">Assembly :: LoadFrom function</a> .  The dialogue is then created and displayed using the <a href="http://msdn.microsoft.com/en-us/library/f7ykdhsy.aspx">reflection-</a> methods. <br><br>  I wanted to make settings that could be changed from the Tools ‚Üí Options menu.  This is well described in <a href="http://msdn.microsoft.com/en-us/library/bb166195">the MSDN manual</a> .  It describes how to create a standard key / value grid, and an arbitrary form: <br><br><img src="https://habrastorage.org/storage2/f2a/781/a95/f2a781a95a07ecffa6fe8568929b1a85.png"><br><br><img src="https://habrastorage.org/storage2/743/7fe/cbc/7437fecbc5c417c358af271c4e4f8deb.png"><br><br>  The last form will be needed to automatically add a line to the autoexp.dat file.  Unfortunately, there is no possibility to execute any command at the time of the installation of the VSIX extension (see the Supported Capabilities table <a href="http://msdn.microsoft.com/en-us/library/dd393694(v%3Dvs.100).aspx">here</a> ).  Therefore, after installing the extension, the user needs to go to this page and click the ‚ÄúAdd entry‚Äù button. <br><br>  To find the autoexp.dat file, you need to know where Visual Studio is installed.  This can be viewed in the registry, but it is better to ask her herself with the help of DTE.  How to get a DTE object from an extension is written <a href="http://social.msdn.microsoft.com/Forums/en-US/vsx/thread/c3291548-8100-4256-85b9-10871800317a/">here</a> .  The FullName property will return the full path to the devenv.exe file. <br><br>  I was pleasantly surprised by Visual Studio 2012. It finally proposed replacing the outdated autoexp.dat file - the <a href="http://blogs.msdn.com/b/mgoldin/archive/2012/06/06/visual-studio-2012-and-debugger-natvis-files-what-can-i-do-with-them.aspx">NATVIS</a> technology.  There is no documentation as such yet, but there is a good <a href="http://code.msdn.microsoft.com/windowsdesktop/Writing-type-visualizers-2eae77a2">description</a> on the Microsoft blog.  And, the glory of backward compatibility, they left the possibility of calling third-party code through the same mechanism, only now it is specified in the LegacyAddin argument.  The only description that I found in the answer to <a href="http://stackoverflow.com/questions/11545418/how-to-write-a-custom-native-visualizer-dll-for-visual-studio-2012-debugger">this question</a> .  It is felt that the technology has recently been announced. <br><br>  A huge plus of NATIVS is that now the rules of visualization (drawn up as separate XML files with the natvis extension) can be scattered in different directories.  Including on user, and also they can be contained in extensions.  To do this, the .nativs file is enough to add to Assets when building an extension.  Therefore, in the NativeViewer extension for Visual Studio 2012 there is no page with integration and it works out of the box. <br><br>  Regarding debugging VSIX extensions.  This turned out to be implemented very conveniently.  When you run a VSIX project, an experimental copy of Visual Studio opens in which the current version of the extension is installed.  Debugging works fine, I managed to debug the native code in the dll in the source studio, which was loaded by an experimental copy. <br><br>  Since extensions appeared only in Visual Studio 2010, earlier versions will have to be manually installed.  So far I have written the <a href="https://sourceforge.net/p/nativeviewer/wiki/QuickStartGuide_VSold/">manual</a> , but in an amicable way, of course, you should make an installer. <br><br><h4>  Conclusion </h4><br>  In this article, I described a solution to the problem I encountered during the development process.  Remarkable is the fact that it is intended for popular development tools, but, oddly enough, has no analogues.  Well, at least I could not find anything like that. <br><br>  In this article I tried to focus less on technical details and compensate for this with an abundance of links.  Those interested can watch the source code and ask questions.  If any aspect seems interesting enough to the public, I can write a more detailed article about it. <br><br>  I really hope that this extension will be useful to many.  If someone wants to take part in the development of the project - write. <br><br><h4>  Links </h4><br><ul><li>  <a href="https://sourceforge.net/projects/nativeviewer/">NativeViewer at SourceForge</a> </li><li>  <a href="http://visualstudiogallery.msdn.microsoft.com/657956e4-8e02-4764-8022-72a0c9cc5b17">NativeViewer for Visual Studio 2010 in Visual Studio Extensions Gallery</a> </li><li>  <a href="http://visualstudiogallery.msdn.microsoft.com/26a8aecf-03b0-49ff-b691-41844c52f20e">NativeViewer for Visual Studio 2012 in Visual Studio Extensions Gallery</a> </li><li>  <a href="http://code.opencv.org/projects/opencv/wiki/Debug_in_Visual_Studio_using_NativeViewer">Debug in Visual Studio using NativeViewer</a> </li></ul><br><ul><li>  <a href="http://msdn.microsoft.com/en-us/library/8fwk67y3%2528v%3Dvs.90%2529.aspx">EEAddIn Sample: Debugging Expression Evaluator Add-In</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/dd997148(VS.100).aspx">Anatomy of a VSIX Package</a> </li><li>  <a href="http://blogs.msdn.com/b/visualstudio/archive/2009/12/09/building-and-publishing-an-extension-for-visual-studio-2010.aspx">Building and publishing an extension for Visual Studio 2010</a> </li><li>  <a href="http://social.msdn.microsoft.com/Forums/en-US/vsx/thread/0be62d3d-84b2-4e17-a306-bcc460621192">VSX FAQ</a> </li><li>  <a href="http://code.msdn.microsoft.com/windowsdesktop/Writing-type-visualizers-2eae77a2">Writing debugger type visualizers for C ++ using .natvis files</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/bb166195">Walkthrough: Creating an Options Page</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/161605/">https://habr.com/ru/post/161605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161585/index.html">In Russian iTunes Store got pornography from the domain .XXX</a></li>
<li><a href="../161591/index.html">AWS CLI utilities now for PowerShell</a></li>
<li><a href="../161595/index.html">StoreVirtual - a new name for Lefty</a></li>
<li><a href="../161597/index.html">Multi-threading implementation of the CART caching algorithm</a></li>
<li><a href="../161601/index.html">How to find out about the problem of the server first, or how to SMS PRTG Network Monitor</a></li>
<li><a href="../161607/index.html">Once you read about the volatile keyword ...</a></li>
<li><a href="../161609/index.html">Overview of dialer programs for Windows Phone OS</a></li>
<li><a href="../161611/index.html">Traffic jams from the future</a></li>
<li><a href="../161615/index.html">Room plans are now available for Google Maps / Germany</a></li>
<li><a href="../161617/index.html">Old Shakes: intercepting data stream between i386 and ATA controller using STM32</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>