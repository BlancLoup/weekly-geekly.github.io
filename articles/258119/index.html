<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is so special about Nim?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Nim programming language (previously called Nimrod) is exciting! While the official documentation with examples smoothly introduces the language, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is so special about Nim?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/616/55b/6ee/61655b6ee8f6472d96d54e2184a0917d.png"></div><br><br>  The <a href="http://nim-lang.org/">Nim</a> programming language (previously called Nimrod) is exciting!  While the <a href="http://nim-lang.org/docs/tut1.html">official documentation with examples</a> smoothly introduces the language, I want to quickly show you what can be done with Nim, which would be more difficult or impossible to do in other languages. <br><br>  I discovered Nim when I was looking for the right tool for writing a game, HoorRace, the successor to my current DDNet game / mod Teeworlds. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>(note lane. The syntax of Nim was influenced by Modula 3, Delphi, Ada, C ++, Python, Lisp, Oberon.)</i> <br><br><h1>  Run! </h1><br>  Yes, this part is still not exciting, but just follow the continuation of the post: <br><br><pre><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>: echo <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..i]</code> </pre> <br><a name="habracut"></a><br>  To run, of course, you will need the <a href="http://nim-lang.org/download.html">Nim compiler</a> (for example, the translation in ArchLinux, for example, the package is <code>community/nim</code> ).  Save this code in the file hello.nim, compile it with <code>nim c hello.nim</code> , and finally run the executable file <code>./hello</code> .  Or use the <code>nim -rc hello.nim</code> , which will compile and run the resulting file.  To build an optimized version, use the <code>nim -d:release c hello.nim</code> .  After launching, you will see this output in the console: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">H</span></span> He Hel Hell Hello Hello Hello W Hello Wo Hello Wor Hello Worl Hello World</code> </pre><br><br><h1>  Execute code at compile time </h1><br>  To implement an efficient CRC32 procedure, you will need a precomputed table.  You can calculate it at runtime or save it in the code as a magic array.  Of course, we don‚Äôt want magic numbers in our code, so we‚Äôll compute a table at the start of the program (at least for now): <br><br><pre> <code class="ruby hljs">import unsigned, strutils type CRC32* = uint32 const initCRC32* = CRC32(-<span class="hljs-number"><span class="hljs-number">1</span></span>) proc createCRCTable(): array[<span class="hljs-number"><span class="hljs-number">256</span></span>, CRC32] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">255</span></span>: var rem = CRC32(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rem <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: rem = (rem shr <span class="hljs-number"><span class="hljs-number">1</span></span>) xor CRC32(<span class="hljs-number"><span class="hljs-number">0xedb88320</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> rem = rem shr <span class="hljs-number"><span class="hljs-number">1</span></span> result[i] = rem <span class="hljs-comment"><span class="hljs-comment"># Table created at runtime var crc32table = createCRCTable() proc crc32(s): CRC32 = result = initCRC32 for c in s: result = (result shr 8) xor crc32table[(result and 0xff) xor ord(c)] result = not result # String conversion proc $, automatically called by echo proc `$`(c: CRC32): string = int64(c).toHex(8) echo crc32("The quick brown fox jumps over the lazy dog")</span></span></code> </pre><br><br>  Fine!  It works and we got <code>414FA339</code> .  However, it would be much better if we could calculate the CRC table at compile time.  And in Nim this can be done very easily, we replace our string with assignment of crc32table to the following code: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># Table created at compile time const crc32table = createCRCTable()</span></span></code> </pre><br>  Yes, that's right, all we need to do is replace <code>var</code> with <code>const</code> .  Great, isn't it?  We can write the same code that can be executed both in the work of the program and at the compilation stage.  No template metaprogramming. <br><br><h1>  Expand language </h1><br>  Templates and macros can be used to avoid copying and noodles in the code, and they will be processed at the compilation stage. <br><br>  Templates are simply replaced by calls to the corresponding functions at compile time.  We can define our own cycles like this: <br><br><pre> <code class="ruby hljs">template times(<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> expr, <span class="hljs-symbol"><span class="hljs-symbol">y:</span></span> stmt): stmt = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> y <span class="hljs-number"><span class="hljs-number">10</span></span>.<span class="hljs-symbol"><span class="hljs-symbol">times:</span></span> echo <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span></code> </pre><br><br>  The compiler converts <code>times</code> to a normal loop: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>: echo <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span></code> </pre><br><br>  If you are interested in the <code>10.times</code> syntax, then know that this is just a normal call to <code>times</code> with the first argument <code>10</code> and a block of code as the second argument.  You could just write: <code>times(10):</code> see more about Unified Call Syntax below. <br><br>  Or initialize sequences (arrays of arbitrary length) more conveniently: <br><br><pre> <code class="ruby hljs">template newSeqWith(<span class="hljs-symbol"><span class="hljs-symbol">len:</span></span> int, <span class="hljs-symbol"><span class="hljs-symbol">init:</span></span> expr): expr = var result = newSeq[type(init)](len) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> .. &lt;<span class="hljs-symbol"><span class="hljs-symbol">len:</span></span> result[i] = init result <span class="hljs-comment"><span class="hljs-comment"># Create a 2-dimensional sequence of size 20,10 var seq2D = newSeqWith(20, newSeq[bool](10)) import math randomize() # Create a sequence of 20 random integers smaller than 10 var seqRand = newSeqWith(20, random(10)) echo seqRand</span></span></code> </pre><br><br>  The macro goes one step further and allows you to analyze and manipulate the AST.  For example, in Nim there are no <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25B2%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">list inclusions</a> (comment of the list comprehensions), but we can add them to the language using a macro.  Now instead of: <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">res:</span></span> seq[int] = @[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x mod <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: res.add(x) echo res const n = <span class="hljs-number"><span class="hljs-number">20</span></span> var <span class="hljs-symbol"><span class="hljs-symbol">result:</span></span> seq[tuple[a,b,<span class="hljs-symbol"><span class="hljs-symbol">c:</span></span> int]] = @[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-symbol"><span class="hljs-symbol">n:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x..<span class="hljs-symbol"><span class="hljs-symbol">n:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> y..<span class="hljs-symbol"><span class="hljs-symbol">n:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x*x + y*y == z*<span class="hljs-symbol"><span class="hljs-symbol">z:</span></span> result.add((x,y,z)) echo result</code> </pre><br><br>  You can use the <code>future</code> module and write: <br><br><pre> <code class="ruby hljs">import future echo lc[x <span class="hljs-params"><span class="hljs-params">| (x &lt;- 1..10, x mod 2 == 0), int] const n = 20 echo lc[(x,y,z) |</span></span> (x &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span>..n, y &lt;- x..n, z &lt;- y..n, x*x + y*y == z*z), tuple[a,b,<span class="hljs-symbol"><span class="hljs-symbol">c:</span></span> int]]</code> </pre><br><br><h1>  Add our own optimizations to the compiler </h1><br>  Instead of optimizing your code, would you rather make the compiler smarter?  In Nim this is possible! <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> int <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">1_000_000_000</span></span>: x += <span class="hljs-number"><span class="hljs-number">2</span></span> * i echo x</code> </pre><br>  This (rather useless) code can be sped up by training the compiler in two optimizations: <br><br><pre> <code class="ruby hljs">template optMul{<span class="hljs-string"><span class="hljs-string">`*`</span></span>(a,<span class="hljs-number"><span class="hljs-number">2</span></span>)}(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> int): int = let x = a x + x template canonMul{<span class="hljs-string"><span class="hljs-string">`*`</span></span>(a,b)}(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> int{lit}, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> int): int = b * a</code> </pre><br>  In the first pattern, we indicate that <code>a * 2</code> can be replaced by <code>a + a</code> .  In the second pattern, we indicate that the <code>int</code> variables can be swapped, if the first argument is a constant number, this is necessary so that we can apply the first pattern. <br><br>  More complex patterns can also be implemented, for example, to optimize Boolean logic: <br><br><pre> <code class="ruby hljs">template optLog1{a <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a}(a): auto = a template optLog2{a <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (b <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b))}(a,b): auto = a template optLog3{a <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a}(<span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> int): auto = <span class="hljs-number"><span class="hljs-number">0</span></span> var x = <span class="hljs-number"><span class="hljs-number">12</span></span> s = x <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x <span class="hljs-comment"><span class="hljs-comment"># Hint: optLog1(x) --&gt; 'x' [Pattern] r = (x and x) and ((s or s) or (not (s or s))) # Hint: optLog2(x and x, s or s) --&gt; 'x and x' [Pattern] # Hint: optLog1(x) --&gt; 'x' [Pattern] q = (s and not x) and not (s and not x) # Hint: optLog3(s and not x) --&gt; '0' [Pattern]</span></span></code> </pre><br>  Here <code>s</code> optimized to <code>x</code> , <code>r</code> also optimized to <code>x</code> , and <code>q</code> immediately initialized to zero. <br><br>  If you want to see how templates are used to avoid highlighting <code>bigint</code> , take a look at templates that start with <code>opt</code> in <a href="">the biginsts.nim library</a> : <br><br><pre> <code class="ruby hljs">import bigints var i = <span class="hljs-number"><span class="hljs-number">0</span></span>.initBigInt <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-symbol"><span class="hljs-symbol">true:</span></span> i += <span class="hljs-number"><span class="hljs-number">1</span></span> echo i</code> </pre><br><br><h1>  Connect your C-functions and libraries </h1><br>  Since Nim is translated to C (C ++ / Obj-C), using third-party functions is no problem. <br><br>  You can easily use your favorite functions from the standard library: <br><br><pre> <code class="ruby hljs">proc printf(<span class="hljs-symbol"><span class="hljs-symbol">formatstr:</span></span> cstring) {.<span class="hljs-symbol"><span class="hljs-symbol">header:</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;stdio.h&gt;"</span></span>, varargs.} printf(<span class="hljs-string"><span class="hljs-string">"%s %d\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)</code> </pre><br><br>  Or use your own code written in C: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> hi(<span class="hljs-type"><span class="hljs-type">char</span></span>* <span class="hljs-type"><span class="hljs-type">name</span></span>) { printf("awesome %s\n", <span class="hljs-type"><span class="hljs-type">name</span></span>); }</code> </pre><br><pre> <code class="ruby hljs">{.<span class="hljs-symbol"><span class="hljs-symbol">compile:</span></span> <span class="hljs-string"><span class="hljs-string">"hi.c"</span></span>.} proc hi*(<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> cstring) {.importc.} hi <span class="hljs-string"><span class="hljs-string">"from Nim"</span></span></code> </pre><br><br>  Or any library you like with c2nim: <br><br><pre> <code class="ruby hljs">proc set_default_dpi*(<span class="hljs-symbol"><span class="hljs-symbol">dpi:</span></span> cdouble) {.cdecl, <span class="hljs-symbol"><span class="hljs-symbol">importc:</span></span> <span class="hljs-string"><span class="hljs-string">"rsvg_set_default_dpi"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">dynlib:</span></span> <span class="hljs-string"><span class="hljs-string">"librsvg-2.so"</span></span>.}</code> </pre><br><br><h1>  Manage the garbage collector </h1><br>  To achieve "soft realtime", you can tell the garbage collector when and how much it can work.  The basic logic of the game with the prevention of garbage collector intervention can be implemented on Nim like this: <br><br><pre> <code class="ruby hljs">gcDisable() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-symbol"><span class="hljs-symbol">true:</span></span> gameLogic() renderFrame() gcStep(us = leftTime) sleep(restTime)</code> </pre><br><br><h1>  Type safe sets and enum </h1><br>  Often you may need a mathematical set with values ‚Äã‚Äãthat you defined yourself.  This is how it can be implemented with the confidence that the types will be checked by the compiler: <br><br><pre> <code class="ruby hljs">type FakeTune = enum freeze, solo, noJump, noColl, noHook, jetpack var <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> set[FakeTune] x.incl freeze x.incl solo x.excl solo echo x + {noColl, noHook} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> freeze <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> echo <span class="hljs-string"><span class="hljs-string">"Here be freeze"</span></span> var y = {solo, noHook} y.incl <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment"># Error: type mismatch</span></span></code> </pre><br><br>  You cannot accidentally add a value of another type.  Internally, it works as an effective bit vector. <br><br>  The same is possible with arrays, index them with enum. <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> array[FakeTune, int] a[freeze] = <span class="hljs-number"><span class="hljs-number">100</span></span> echo a[freeze]</code> </pre><br><br><h1>  Unified Call Syntax </h1><br>  It‚Äôs just syntactic sugar, but it‚Äôs definitely very convenient (I think it‚Äôs terrible!).  In Python, I always forget the <code>len</code> and <code>append</code> functions or methods.  In Nim, you don't need to remember this, because you can write as you please.  Nim uses Unified Call Syntax (Unified Call syntax), which is also now proposed in C ++ by the comrades Herb Sutter and Bjarne Stroustrup. <br><br><pre> <code class="ruby hljs">var xs = @[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment"># Procedure call syntax add(xs, 4_000_000) echo len(xs) # Method call syntax xs.add(0b0101_0000_0000) echo xs.len() # Command invocation syntax xs.add 0x06_FF_FF_FF echo xs.len</span></span></code> </pre><br><br><h1>  Performance </h1><br>  (Note: this section in the original article is ‚Äúoutdated‚Äù, therefore I offer links to the <a href="">original updated benchmark</a> and <a href="http://hookrace.net/blog/what-is-special-about-nim/">benchmark given in the original article</a> ) <br><br>  From the translator: <br><br>  In short, Nim generates code that is as fast as human-written C / C ++.  Nim can translate the code in C / C ++ / Obj-C (and it will be shown below that it can in JS) and compile it with gcc / clang / llvm_gcc / MS-vcc / Intel-icc.  As artificial tests show, Nim is comparable in speed with C / C ++ / D / Rust and faster than Go, Crystal, Java and many others. <br><br><h1>  We broadcast in JavaScript </h1><br>  Nim can translate Nim code in javascript.  This allows you to write both client and server code in Nim.  Let's make a small site that will count visitors.  This will be our client.nim: <br><br><pre> <code class="ruby hljs">import htmlgen, dom type Data = object visitors {.importc.}: int uniques {.importc.}: int ip {.importc.}: cstring proc printInfo(<span class="hljs-symbol"><span class="hljs-symbol">data:</span></span> Data) {.exportc.} = var infoDiv = document.getElementById(<span class="hljs-string"><span class="hljs-string">"info"</span></span>) infoDiv.innerHTML = p(<span class="hljs-string"><span class="hljs-string">"You're visitor number "</span></span>, $data.visitors, <span class="hljs-string"><span class="hljs-string">", unique visitor number "</span></span>, $data.uniques, <span class="hljs-string"><span class="hljs-string">" today. Your IP is "</span></span>, $data.ip, <span class="hljs-string"><span class="hljs-string">"."</span></span>)</code> </pre><br><br>  We define the type of <code>Data</code> that will be sent from the server to the client.  The procedure <code>printInfo</code> will be called with this data for display.  To build our client code, run the <code>nim js client</code> command.  The result will be saved in <code>nimcache/client.js</code> . <br><br>  For the server, we will need the Nimble package manager, since we will need to install the <a href="https://github.com/dom96/jester">Jester</a> (a sinatra-like web framework for Nim).  Install Jester: <code>nimble install jester</code> .  Now we write our server.nim: <br><br><pre> <code class="ruby hljs">import jester, asyncdispatch, json, strutils, times, sets, htmlgen, strtabs var visitors = <span class="hljs-number"><span class="hljs-number">0</span></span> uniques = initSet[string]() <span class="hljs-symbol"><span class="hljs-symbol">time:</span></span> TimeInfo <span class="hljs-symbol"><span class="hljs-symbol">routes:</span></span> get <span class="hljs-string"><span class="hljs-string">"/"</span></span>: resp body( <span class="hljs-string"><span class="hljs-string">`div`</span></span>(id=<span class="hljs-string"><span class="hljs-string">"info"</span></span>), script(src=<span class="hljs-string"><span class="hljs-string">"/client.js"</span></span>, <span class="hljs-string"><span class="hljs-string">`type`</span></span>=<span class="hljs-string"><span class="hljs-string">"text/javascript"</span></span>), script(src=<span class="hljs-string"><span class="hljs-string">"/visitors"</span></span>, <span class="hljs-string"><span class="hljs-string">`type`</span></span>=<span class="hljs-string"><span class="hljs-string">"text/javascript"</span></span>)) get <span class="hljs-string"><span class="hljs-string">"/client.js"</span></span>: const result = staticExec <span class="hljs-string"><span class="hljs-string">"nim -d:release js client"</span></span> const clientJS = staticRead <span class="hljs-string"><span class="hljs-string">"nimcache/client.js"</span></span> resp clientJS get <span class="hljs-string"><span class="hljs-string">"/visitors"</span></span>: let newTime = getTime().getLocalTime <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newTime.monthDay != time.<span class="hljs-symbol"><span class="hljs-symbol">monthDay:</span></span> visitors = <span class="hljs-number"><span class="hljs-number">0</span></span> init uniques time = newTime inc visitors let ip = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.headers.hasKey <span class="hljs-string"><span class="hljs-string">"X-Forwarded-For"</span></span>: request.headers[<span class="hljs-string"><span class="hljs-string">"X-Forwarded-For"</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> request.ip uniques.incl ip let json = <span class="hljs-string"><span class="hljs-string">%{"visitors": %visitors, "uniques": %uniques.len, "ip": %ip}</span></span> resp <span class="hljs-string"><span class="hljs-string">"printInfo($#)"</span></span>.format(json) runForever()</code> </pre><br><br>  When opening <a href="http://localhost:5000/">http: // localhost: 5000 /, the</a> server will return a ‚Äúblank‚Äù page with <code>/client.js</code> and <code>/visitors</code> connected.  <code>/client.js</code> will return the file received through the <code>nim js client</code> , and <code>/visitors</code> will generate the JS code with a call to <code>printInfo(JSON)</code> . <br><br>  You can see the <a href="http://visitors.hookrace.net/">resulting Jester site online</a> , it will show this line: <br><br><pre> <code class="hljs vhdl">You<span class="hljs-symbol"><span class="hljs-symbol">'re</span></span> visitor number <span class="hljs-number"><span class="hljs-number">11</span></span>, unique visitor number <span class="hljs-number"><span class="hljs-number">11</span></span> today. Your IP <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">134.90</span></span>.<span class="hljs-number"><span class="hljs-number">126.175</span></span>.</code> </pre><br><br><h1>  Conclusion </h1><br>  I hope I could get interested in the Nim programming language. <br>  Please note that the language is not yet completely stable.  However, Nim 1.0 is just around the corner.  So this is a great time to explore Nim! <br><br>  Bonus: since Nim is translated to C and depends only on the standard C library, your code will work almost everywhere. </div><p>Source: <a href="https://habr.com/ru/post/258119/">https://habr.com/ru/post/258119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258107/index.html">Transitions with CoreAnimation: animating the appearance of the image</a></li>
<li><a href="../258109/index.html">Mexico and Russia: similar problems in learning to develop electronics</a></li>
<li><a href="../258111/index.html">Social network on Android for a few days off - part II (server)</a></li>
<li><a href="../258113/index.html">HL7v3 vs. HL7 FHIR comparison</a></li>
<li><a href="../258115/index.html">Bluetooth heart rate monitor or photoplethysmograph device. Part 1</a></li>
<li><a href="../258121/index.html">Simple suffix tree</a></li>
<li><a href="../258125/index.html">The digest of interesting materials for the mobile # 103 developer (on May 12-17)</a></li>
<li><a href="../258127/index.html">OpenHAB and home controller - we make iron</a></li>
<li><a href="../258129/index.html">Installing OTRS v4 on Windows</a></li>
<li><a href="../258135/index.html">Modified driver from ReactOS makes life easier on Windows on a Chromebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>