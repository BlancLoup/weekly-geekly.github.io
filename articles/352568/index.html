<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gradual programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programming is essentially an incremental (or gradual, sequential) process, and the programming languages ‚Äã‚Äãwe use should reflect this fact. This arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gradual programming</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Programming is essentially an incremental (or gradual, sequential) process, and the programming languages ‚Äã‚Äãwe use should reflect this fact.  This article discusses several different areas in which software models move as they evolve, and also raises the question of how potential research in the field of usability of programming languages ‚Äã‚Äãwill serve in the future to shape the concept of human-oriented programming languages. </blockquote><h2>  Choose the right task </h2><br>  What serious problems do programming languages ‚Äã‚Äãhave that we use in our work in 2018?  Which of them after the decision will have the greatest effect on the next generation of programmers? <br><blockquote>  If you are interested in this question, we recommend to read the post of Graydon Hoare (the creator of Rust) <a href="https://graydon2.dreamwidth.org/253769.html">‚ÄúWhat's next?‚Äù</a> , As well as the post of Stephen Diehl <a href="http://dev.stephendiehl.com/nearfuture.pdf">‚ÄúThe near future of programming languages‚Äù</a> . </blockquote>  For me, the most attractive feature of the study of programming languages ‚Äã‚Äãis hidden in this issue - the fact is that the tools and theories that we develop affect not only one specific area, but also potentially <i>all</i> who are engaged in programming.  Hence the following question also arises: from where, please tell us, do we know about the needs of every programmer living on Earth?  It is easy to work on the X language, based on the new type theory, or on the Y language, in which there is a new feature interesting to me personally - but what about all the other programmers? <br><a name="habracut"></a><br>  This is one of the most important drawbacks of programming languages ‚Äã‚Äãas a modern field of study.  A huge amount of such research is carried out under the banner of the intuition of the researchers themselves, and in addition to them the specific experience of certain people working with specific programming tools, languages, environments, etc. is superimposed.  Obviously, the intuitive approach allowed us to move quite far, since we were able to reach our current level - confirming the thesis that smart people most often have good intuition - but let me assume that the obvious stagnation in the widespread use of modern PL research practices first of all with a lack of attention to the end user (in other words, to an ordinary programmer).  The opinion I have come across several times is that the last big and <a href="https://youtu.be/-I_jE0l7sYQ%3Ft%3D10m49s">truly new idea was Prolog</a> . <br><br>  It seems to me that looking at programming languages ‚Äã‚Äã( <i>PL, PL</i> ) through the lenses of human-machine interaction ( <i>HCI</i> ) is the most important meta-problem of the field today.  More than ever, we need to conduct polls, interviews, study user experience, involve sociologists and psychologists, and so on - in order to formulate hypotheses based on the data obtained that will affect the "difficult" sections of the programming discipline.  It is necessary not only to make the programming process comfortable for those who are just beginning to learn it, but also for everyone else - from gray-haired low-level system developers to young people represented by web developers.  Interest in this direction is already beginning to form;  for example, a CHI conference called <a href="https://docs.google.com/document/d/1-GUt5oVPpi7rlObbU1WbA5V1OQBX1iaghryLJ6-ND9o/edit">Usability of Programming Languages ‚Äã‚ÄãSpecial Interest Group is</a> being held, scientific papers such as the <i>Empirical Analysis of Programming Language Adoption</i> , and <a href="https://medium.com/bits-and-behavior/designing-learnable-teachable-and-productive-programming-languages-dagstuhl-trip-report-81e41bde84bd">working groups on language usability are emerging</a> . <br><br>  However, even if our knowledge of the usability of languages ‚Äã‚Äãis not so great yet, nothing keeps us from continuing to work on the key problems of PL, which in our opinion will bring tangible results.  The manifesto I formulated further is based mostly on my personal experience - I have been programming for over ten years, have been involved in game development (Lua, C), websites (PHP, JS), high load / distributed systems (C ++, Go, Rust ), compilers (Standard ML, OCaml) and data science (Python, R).  During this time I managed to work on small scripts, personal projects, open source software, products in tiny (2 people), small (15 people), medium (500 people) and large (2000+ people) companies, and now I am engaged in scientific research.  I studied the theory of programming languages ‚Äã‚Äãat Carnegie Mellon University, and today I teach <a href="http://cs242.stanford.edu/">the CS242 programming language course at Stanford</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I told all this for the purpose of making it clear to you: even if we need much more data in order to thoroughly approach the discussion of these problems, I have tried to formulate an informed opinion about the problems that exist in modern programming languages, in many ways various fields of activity and are really found in the real world.  Of course, I will not deny that there is a lot that I don‚Äôt know about - so, as usual, I suggest you read this post with a healthy degree of criticism. <br><br><h2>  Thinking gradually </h2><br>  I firmly believe in the following: <b>programming languages ‚Äã‚Äãmust be designed in such a way that they directly correspond to the programming processes that take place in the programmer‚Äôs head.</b>  We must strive to understand exactly how people think about programs, and try to determine which of the programming processes are understood by the human mind on an intuitive level.  There are enough of all kinds of interesting questions, for example: <br><br><ul><li>  Is imperative programming more intuitive for people than functional programming?  If so, is this because our brain is so configured, or simply because it is the most popular form of programming? </li><li>  How far should we go in striving to conform to the natural processes occurring in the human head?  Or maybe the balance, on the contrary, should be shifted towards changing the way of thinking of programmers? </li><li>  How much does the comment actually affect our understanding of the programs?  Variable names?  Types?  Control flow? </li></ul><br>  A simple observation of the human programming process shows that this process is incremental.  No one writes the entire program from scratch in one pass, compiles it and immediately releases it, after which it never opens its code again.  Programming is when you stick for a long time through trial and error, where the duration of the trial and the severity of the errors closely depend on the specific field and tools.  That is why the ability to explore output and quick compilation times is so significant - for example, the ability to change an HTML document and immediately refresh the page to see what happened.  Bret Victor in his article <a href="http://worrydream.com/">‚ÄúLearnable Programming‚Äù</a> discusses this idea in detail. <br><br>  I call this process <i>‚Äúgradual programming‚Äù</i> . <br><blockquote>  I would use the term "incremental" programming, but <a href="https://en.wikipedia.org/wiki/Incremental_computing">incremental calculations</a> already have their own, distinct from my and fixed meaning, especially since the term "gradual" is used in the environment of the PL enthusiasts in this context. <br><br>  As far as I know, the only recorded case of using the term ‚Äúgradual programming‚Äù (apart from this article) is <a href="https://pdfs.semanticscholar.org/c4cc/7f05e105d188433b1a72ec4507a3b1b5273b.pdf">this publication</a> , but the term is given a slightly different perspective.  One of its authors is Jeremy Sike - one of the founders of <i>gradual typing</i> . <br></blockquote>  While paradigms of imperative or functional programming focus on the aspects underlying our mental program model, gradual programming describes the process by which this mental model is formed.  In this sense, gradual programming is just ... programming;  but, as it seems to me, the new term is appropriate here, since it is useful to us in order not to get confused further. <br><br>  With gradual programming, the programmer monitors co-evolution ( <i>parallel evolution</i> ) of two things: 1) a syntax representation of the program, expressed for the computer in a programming language, and 2) a conceptual representation of the program, located in the programmer's head.  At the beginning of this process, the programmer starts without any syntax (from an empty file) and is usually armed with a very vague idea of ‚Äã‚Äãhow the final program should work.  From this point, the programmer continues to take small steps in the direction of building components of the program - until its final version is ready. <br><br>  If you are programming, you almost certainly went through this process several times, and you probably more or less recognized it in my description - however, usually most of our thinking process occurs implicitly (for example, inside your head), and never appears in the form communications.  To make sure that this gradual process exists, let's look at the following example in detail.  Suppose I want to write a program that adds a string with text to a file.  In my head I have a certain model of the program, which looks something like this: <br><br><pre><code class="hljs 1c"> <span class="hljs-type"><span class="hljs-type"></span></span> =     <span class="hljs-built_in"><span class="hljs-built_in"></span></span> =         </code> </pre> <br>  Then I decide in what language I will write this program - in our case it will be Python.  To begin with, instead of trying to write the whole program at once, I just take the first line from the model and try to write it as it is in Python. <br><br><pre> <code class="python hljs">$ cat append.py input_file = input() print(input_file)</code> </pre> <br>  Here I made several decisions.  First, I decided that the input would be from <code>stdin</code> (for simplicity), and used the <code>input()</code> function, the standard Python library function.  I had to come up with a name for this value, <code>input_file</code> , and this name had to conform to syntactic conventions in Python.  I also added a <code>print</code> statement that was not part of my original programming model, but was part of a temporary programming model designed to debug my little programs.  Then I will try to execute it: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test.txt"</span></span> | python append.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"append.py"</span></span>, line 1, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; input_file = input() File <span class="hljs-string"><span class="hljs-string">"&lt;string&gt;"</span></span>, line 1, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; NameError: name <span class="hljs-string"><span class="hljs-string">'test'</span></span> is not defined</code> </pre> <br>  Oops, I mixed up <code>input()</code> and <code>raw_input()</code> .  The problem was not with my programming model ‚Äî I still think about the program in exactly the same way as before ‚Äî but with my ‚Äúdecoding‚Äù in Python.  Correcting my mistake: <br><br><pre> <code class="python hljs">$ cat append.py input_file = raw_input() input_line = raw_input() print(input_file, input_line) $ echo <span class="hljs-string"><span class="hljs-string">"test.txt\ntest"</span></span> | python append.py (<span class="hljs-string"><span class="hljs-string">'test.txt'</span></span>, <span class="hljs-string"><span class="hljs-string">'test'</span></span>)</code> </pre> <br>  Next, I have to figure out how to add a line to the end of the file.  In my original mental model, it was encapsulated into the expression ‚Äúwriting the input line to the end of the input file‚Äù (‚Äúwrite input line‚Äù), but now it‚Äôs time to turn this vague idea into more specific steps that I can easy to write in python.  In particular, if I already have an understanding of how the file system works, then I know that I must first open the file in <i>append mode</i> , write a line, and then close the file. <br><br>  After some reflection, my mental model begins to look like this: <br><br><pre> <code class="python hljs">  =      =    =                 </code> </pre> <br><br>  So now let's ‚Äútranslate‚Äù all of this in Python: <br><pre> <code class="bash hljs">$ cat append.py input_file = raw_input() input_line = raw_input() file = open(input_file, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) file.write(input_line) file.close() $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"test.txt\ntest"</span></span> | python append.py $ cat test.txt <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Success!  Again, the purpose of our example was to demonstrate the co-evolution of the syntactic and conceptual model of the program as we work on it.  Based on my programming experience, along with teaching others programming, I can say that she gives a fairly common example of the thinking process that accompanies the way many of us program. <br><br><h2>  Axis of evolution </h2><br>  The example described above showed us the gradual nature of the programming process, but did not shed any light on how we should approach the process of creating tools that would fit this process.  To simplify your task, let's break the evolution of the program into many small axes of evolution.  Essentially, let's ask ourselves: what kind of useful information about their program, developers will learn and understand gradually?  Then we can suggest how programming languages ‚Äã‚Äãcan help optimize each of the axes separately. <br><br><h3>  1. Concrete / Abstraction (Concrete / abstract) </h3><br>  When creating programs, the generally accepted way of working is considered to start from a specific example that you are trying to implement, and then a generalization (or abstraction) of this example, which is produced so that it can cover a wider set of use cases.  Abstraction is the cornerstone of programming languages, usually provided through functions and interfaces.  For example, we can turn our script into a function: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_line</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input_file, input_line)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    append_line('test.txt', 'test') append_line('test.txt', 'test again')</span></span></code> </pre> <br>  However, the more uncertain your model is from the start, the more difficult it will be to move immediately to an abstract solution, so this evolution from specifics to abstraction is often observed today when working with modern programming languages ‚Äã‚Äã(again, see the chapter ‚ÄúCreate by Abstracting‚Äù in <a href="http://worrydream.com/">Learnable Programming</a> ) . <br><br><h3>  2. Anonymity / Name (Anonymous / named) </h3><br>  When we are at the beginning of our programming process at the iteration / experimentation stage, it‚Äôs natural that we, as programmers, want to optimize the speed of writing code, <a href="https://talks.golang.org/2014/names.slide">rather than reading it</a> .  One form of this optimization is short variable names and anonymous values.  For example, a shortened version of the first version of our script could look like this: <br><br><pre> <code class="python hljs">s = raw_input() f = open(s, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) f.write(raw_input()) f.close()</code> </pre> <br>  Here the variable names are less informative than before: we use <code>s</code> instead of <code>input_file</code> , <code>f</code> instead of <code>file</code> , and <code>input_line</code> has lost its name altogether.  However, if it is faster to write, and the script will never be read again, why not?  If we plan to continue to use this script in a large code base, then we can begin to incrementally change the names to more informative ones so that the citizens conducting code review are satisfied.  Here is another example of a gradual change that is easy to apply in practice and which is commonly used among programmers who write in modern programming languages. <br><br><h3>  3. Imperativeness / declarativeness (Imperative / declarative) </h3><br>  For a variety of reasons, programmers perceived linear, sequential imperative code more naturally as compared to functional / declarative code in terms of their conceptual program model.  For example, a simple list transformation will almost certainly use <code>for</code> loops: <br><br><pre> <code class="python hljs">in_l = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] out_l = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> in_l: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: out_l.append(x * <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  While a more declarative version abstracts the flow of execution into object-oriented primitives: <br><br><pre> <code class="python hljs">in_l = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] out_l = map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * <span class="hljs-number"><span class="hljs-number">2</span></span>, filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>, in_l))</code> </pre> <br>  The difference between these two approaches is not only stylistic - the declarative code is usually much easier to analyze into a structure, for example, a <code>map</code> (map, map) can be parallelized in a trivial way, while the for loop is generally much worse for this.  Such transformations most often occur in languages ‚Äã‚Äãthat are supported by a mixture of imperative and functional code (at least - closures). <br><br><h3>  4. Dynamic typing / static typing (Dynamically typed / statically typed) </h3><br>  The rise of the popularity of dynamically typed languages ‚Äã‚Äãin the last 20 years (Python, Javascript, R, Lua, ...) should be sufficient evidence that people find dynamic typing useful - no matter <a href="http://danluu.com/empirical-pl/">which side of the barricades you are in</a> , the fact remains .  Despite the fact that dynamic typing has many advantages (various data structures, free duck typing, etc.), the simplest is to increase productivity by omitting: the types of variables do not need to be known at compile time, so the programmer does not have to spend his mental energy is also for this. <br><br>  However, types are still extremely useful tools to ensure correctness and performance, so that a programmer may want to gradually add type signatures to an untyped program if he can be sure that a variable must be of a certain type.  This nascent idea, which is called optional or gradual typing, has already gained recognition in <a href="https://docs.python.org/3/library/typing.html">Python</a> , <a href="http://www.typescriptlang.org/">Javascript</a> , <a href="https://docs.julialang.org/en/stable/manual/types/">Julia</a> , <a href="https://clojure.github.io/core.typed/">Clojure</a> , <a href="https://docs.racket-lang.org/ts-guide/">Racket</a> , <a href="https://github.com/soutaro/steep">Ruby</a> , <a href="http://hacklang.org/">Hack</a> and other languages. <br><br>  For example, our program after rewriting might look like this: <br><br><pre> <code class="rust hljs">input_file: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = raw_input() input_line: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = raw_input() file: File = open(input_file, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) file.write(input_line) file.close()</code> </pre> <br><h3>  5. Dynamic deallocation / static deallocation (Dynamically deallocated / statically deallocated) </h3><br>  You can look at memory management, or at life time, through the same prism through which we looked at types.  In 2018, all programming languages ‚Äã‚Äãshould have <a href="http://willcrichton.net/notes/rust-memory-safety/">secure access to memory</a> , the only question here is whether memory allocation should be defined at compile time (such as in Rust with its <i>borrow checker</i> ) or at run time (as in any other language in which there is a garbage collector).  Garbage collection is, without a doubt, a big plus for the programmer's performance - so it is natural that our initial software model should not assume how much time each value should live until the deallocation happens. <br><br>  However, as before, point control over the lifetime of a value is still useful for correctness and performance.  Ownership and borrowing, similar to that implemented in Rust, can help structure the system to <a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">eliminate data races</a> during competitive programming, as well as avoid the need to use a garbage collector at runtime. <br><br>  Extending our typed example, it might look like this: <br><br><pre> <code class="rust hljs">input_file: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = raw_input() input_line: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = raw_input() file: <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> File = open(&amp;input_file, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) file.write(&amp;input_line) file.close()</code> </pre> <br>  As far as I know, unlike the optional, or gradual typing, there is no work in the direction of creating gradual (optional) memory management (with the exception of <a href="https://drive.google.com/file/d/0B_4wx_3dTGICWG1Ddk81Rnh0YzA/view">this publication</a> ). <br><br><h3>  6. General Purpose / Object Orientation (General-purpose / domain-specific) </h3><br>  When a programmer starts writing a program, he wants every function in his language available for use in the implementation to be used to achieve the highest possible prototyping speed in order to increase the productivity of the creative process.  Usually it doesn‚Äôt occur to anyone during software development, except perhaps from a coding-style perspective (‚Äúwhich subset of Python should I use?‚Äù). <br><br>  However, a growing wave of high-performance, domain-specific languages ‚Äã‚Äãlike <a href="https://www.tensorflow.org/">TensorFlow</a> , <a href="http://halide-lang.org/">Halide</a> , <a href="http://ebblang.org/">Ebb</a> , and <a href="https://www.weld.rs/">Weld</a> point out that if a programmer uses only a small subset of general-purpose programs (for example, differentiable pure functions), the optimizer can produce a significantly more efficient code.  From the point of view of gradualness, this suggests the possibility of a future workflow in which the programmer gradually narrows a subset of the language that he uses in the individual part of the program so that the compiler can provide a much better optimized backend for it. <br><br><h2>  Concept of gradual programming </h2><br>  Not that these axes could be called a new idea - in the sense that, say, a compromise between static and dynamic typing has been known for quite some time.  However, what I wanted to demonstrate to you is that these solutions are not one-time and one-time solutions - they may change as the program itself is developed.  Therefore, all the axes are most likely 1) changing as the individual program evolves, and 2) changing with the help of precise coordination, i.e.  for example, when typed and untyped code must be mixed within the same system.  This is anathema to the ‚Äúall or nothing‚Äù approach that most languages ‚Äã‚Äãtoday adhere to: everything must either be typed or must be untyped.  Everything should either be collected by the garbage collector, or should not be collected at all.  This forces programmers to deal with absurd trade-offs, such as a complete change of the entire ecosystem of a language in order to take advantage of static typing. <br><br>  In light of this, advanced gradual programming involves the following research process: <br><br><ul><li>  Detection of parts of the programming process that change gradually step-by-step in time, but now require an unjustified overhead or switching between languages ‚Äã‚Äãfor use in work. </li><li>  Development of linguistic mechanisms that will allow programmers to gradually move along specific axes with a uniform software environment. </li><li>  An empirical test on real living programmers, whether the proposed mechanisms work in practice, and whether their results coincide with hypotheses. </li></ul><br>  Each of these steps requires further investigation.  I gave an initial analysis of my perspective of the important incremental parts of the programming process, but I inevitably missed many others.  For some of the axes I mentioned (memory management, language specialization), there are still no documented attempts to systematize attitudes towards them at the language level.  I think that working on <a href="http://willcrichton.net/notes/extensible-compilation/">extensible compilation</a> will help speed up the speed of developing language extensions on these fronts. <br><br>  Even for more beaten-up areas like <i>gradual typing</i> , publications began in 2016, whose authors wondered <a href="https://www2.ccs.neu.edu/racket/pubs/popl16-tfgnvf.pdf">‚ÄúIs it true that Sound Gradual Typing has come to an end?‚Äù</a> ( <a href="http://www.cs.cornell.edu/~ross/publications/nomalive/nomalive-oopsla17.pdf">Very</a> much <a href="http://www.cs.cornell.edu/~ross/publications/nomalive/nomalive-oopsla17.pdf">alive and feeling fine</a> , thank you very much for your concern).  <a href="https://circleci.com/blog/why-were-no-longer-using-core-typed/">CircleCI abandoned the use of gradual typing at Clojure</a> two years later.  Let the theory itself be well understood and the work productivity grows - there is no practical information on how programmers interact with optional (gradual) types.  Is it easy to write programs using this typing?  Are partly typed programs more complicated than fully typed / untyped programs?  Can the IDE solve any of the problems listed here?  And so on - we have no answers to these questions. <br><br>  Another important issue of gradual programming is the choice between type inference and type signatures (annotations) ( <i>inference vs. annotation</i> ).  As our compilers become smarter, it becomes easier for the compiler to output information like types, lifetime, etc.  in the case when the programmer did not specify them explicitly.  However, the output engines are far from perfect, and in the case when they cannot work as they should (as far as I know), each language capability based on the output will require an explicit annotation from the user, as opposed to suitable dynamic checks. <br><br>  I imagine it this way: gradual systems have three modes of operation: for any particular type of program information (for example, type), it is either <i>explicitly annotated</i> , <i>inferred</i> , or deferred to runtime ( <i>deferred to runtime</i> ). <br><br>  This question is interesting in itself, if we try to consider it from the point of view of HCI (human-computer interaction): how effectively can people program in a system where the missing type indication may or may not be displayed?  How does this affect usability, performance and correctness?  Most likely, all these questions will become another important research area for gradual programming. <br><br>  In general, I welcome the wide opportunities that can provide us with methods of gradual programming.  When they begin to gain popularity, programmers of all skill levels will be able to benefit from languages ‚Äã‚Äãthat best fit their way of thinking. <br><br>  <i>Comments can also be sent <a href="http://wcrichto%40cs.stanford.edu/">to the post author of the article,</a> as well as left on Hacker News.</i> </div><p>Source: <a href="https://habr.com/ru/post/352568/">https://habr.com/ru/post/352568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352558/index.html">Spring AOP and JavaConfig in Atlassian Jira plugins</a></li>
<li><a href="../352560/index.html">Tibero and Oracle compatibility issues. Part 2. Java application development</a></li>
<li><a href="../352562/index.html">Modifying the Vanilla Music Player for Android (Part 2)</a></li>
<li><a href="../352564/index.html">What is EVPN / VXLAN</a></li>
<li><a href="../352566/index.html">We crack Windows Server through 1–°</a></li>
<li><a href="../352570/index.html">No new: Pointers will be removed from C ++</a></li>
<li><a href="../352572/index.html">Data Layout Specialist</a></li>
<li><a href="../352574/index.html">Dependency injection patterns. Part 2</a></li>
<li><a href="../352576/index.html">Easy way to install Mikrotik RouterOS in any cloud</a></li>
<li><a href="../352580/index.html">The digest of interesting materials for the mobile developer # 247 (March 26 - April 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>