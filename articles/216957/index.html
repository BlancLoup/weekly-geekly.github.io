<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ZeroMQ. Chapter 2: Introduction to Sockets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue the free translation of the book "ZeroMQ.Use ZeroMQ". I apologize in advance that I did not publish a sequel for so long, but as t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ZeroMQ. Chapter 2: Introduction to Sockets</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue the <b>free</b> translation of the book "ZeroMQ.Use ZeroMQ".  I apologize in advance that I did not publish a sequel for so long, but as they say: ‚ÄúLaziness was born in front of us ...‚Äù.  Well, the lyrics aside, continue. <br><br>  Content <br><ul><li>  <a href="http://habrahabr.ru/post/198578/">Chapter 1: Getting Started</a> </li><li>  <b>Chapter 2: Introduction to Sockets</b> </li><li>  Chapter 3: Using Socket Topology </li><li>  Chapter 4: Additional Patterns </li></ul><br><br>  After we looked at the basic structures of ZeroMQ in the previous chapter, in this we will look at sockets, as follows: <br><ul><li>  client-server pattern (publish-subscribe) </li><li>  pattern pipeline </li></ul><br><a name="habracut"></a><br><h4>  Publish-subscribe pattern </h4><br>  First, let's introduce the classic pattern, the client-server pattern (publish-subscribe), which is one-sided by the nature of the distribution when the server sends messages to a specific list of clients.  This model is one to many.  The main idea of ‚Äã‚Äãthis pattern is that the server sends a message and the connected clients receive this message, while the disconnected ones just skip it.  The server is weakly connected with clients, it does not care at all whether there are any clients at all.  This is similar to how television channels or radio stations work.  TV channels always broadcast TV shows and only viewers decide whether or not to broadcast.  If you miss the right time, you won‚Äôt be able to watch your favorite TV show (if you don‚Äôt have TiVo or something like that, but let's assume that our script happens in a world where the records were not invented).  The advantage of the publish-subscribe pattern is that it provides a dynamic network topology. <br>  The client-server model can be viewed from the following main parties: <br><ul><li>  post: post is posted by creator </li><li>  Notify: the client is notified of the posting </li><li>  subscribe: customer is issued a new signature </li><li>  unsubscribe: client deletes existing signature </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's take an example to clarify the situation.  Consider the scenario where we would like to create an exchange program.  There are brokers, and they want to know what actions are taking place in the market.  Our server will be the stock market, and brokers will be customers. <br>  Instead of real prices from stock markets, we simply generate several numbers. <br>  Before moving on to any code, first let's see what the client-server model looks like. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d41/873/d3f/d41873d3f153b4b2b88c85a5eae16cab.png"><br><br>  Below is the code of the creator (server): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Stock Market Server * Binds PUB socket to tcp://*:4040 * Publishes random stock values of random companies */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* publisher = zmq_socket(context, ZMQ_PUB); printf("Starting server...\n"); int conn = zmq_bind(publisher, "tcp://*:4040"); const char* companies[2] = {"Company1", "Company2"}; int count = 0; for(;;) { int price = count % 2; int which_company = count % 2; int index = strlen(companies[0]); char update[12]; snprintf(update, sizeof update, "%s", companies[which_company]); zmq_msg_t message; zmq_msg_init_size(&amp;message, index); memcpy(zmq_msg_data(&amp;message), update, index); zmq_msg_send(&amp;message, publisher, 0); zmq_msg_close(&amp;message); count++; } zmq_close(publisher); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre> <br><br>  We also give the client code below: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Stock Market Client * Connects SUB socket to tcp://localhost:4040 * Collects stock exchange values */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* subscriber = zmq_socket(context, ZMQ_SUB); printf("Collecting stock information from the server.\n"); int conn = zmq_connect(subscriber, "tcp://localhost:4040"); conn = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, 0, 0); int i; for(i = 0; i &lt; 10; i++) { zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, subscriber, 0); int length = zmq_msg_size(&amp;reply); char* value = malloc(length); memcpy(value, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); printf("%s\n", value); free(value); } zmq_close(subscriber); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre><br><br>  Signing with <code>zmq_setsockopt ()</code> and <code>subscribeis</code> is required whenever you use a SUB socket, otherwise you will not receive any messages.  This is a very common mistake. <br>  A client can set multiple signatures to any of the messages he receives if the update matches any of the subscriptions.  He can also unsubscribe from certain subscriptions.  Subscriptions have a fixed length. <br>  The client receives the message using <code>zmq_msg_recv</code> ().  <code>zmq_msg_recv</code> () receives and saves the message.  The previous message, if any, is unloaded. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zmq_msg_recv</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">zmq_msg_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *socket, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span></span>;</code> </pre><br><br>  Option flag can take only one value - <code>ZMQ_DONTWAIT</code> .  If the flag is <code>ZMQ_DONTWAIT</code> , then the operation is performed in non-blocking mode.  If a message is received, <code>zmq_msg_recv</code> () returns the size of the message in bytes, otherwise -1 is returned and an error message flag is returned. <br>  The client-server model is asynchronous and sending a message to the <code>SUB</code> socket causes an error.  You could call <code>zmq_msg_send</code> () to send messages, but you should never call <code>zmq_msg_recv</code> () for a PUB socket. <br>  The following is an example of client-side output: <br><br><pre> <code class="cpp hljs">Company2 <span class="hljs-number"><span class="hljs-number">570</span></span> Company2 <span class="hljs-number"><span class="hljs-number">878</span></span> Company2 <span class="hljs-number"><span class="hljs-number">981</span></span> Company2 <span class="hljs-number"><span class="hljs-number">783</span></span> Company1 <span class="hljs-number"><span class="hljs-number">855</span></span> Company1 <span class="hljs-number"><span class="hljs-number">524</span></span> Company2 <span class="hljs-number"><span class="hljs-number">639</span></span> Company1 <span class="hljs-number"><span class="hljs-number">984</span></span> Company1 <span class="hljs-number"><span class="hljs-number">158</span></span> Company2 <span class="hljs-number"><span class="hljs-number">145</span></span></code> </pre><br><br>  The server will always send messages, even if there are no clients.  You can try it out and see the result.  If you do, you will see something like the following: <br><br><pre> <code class="cpp hljs">Sending... Company2 <span class="hljs-number"><span class="hljs-number">36</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">215</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">712</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">924</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">721</span></span> Sending... Company1 <span class="hljs-number"><span class="hljs-number">668</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">83</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">209</span></span> Sending... Company1 <span class="hljs-number"><span class="hljs-number">450</span></span> Sending... Company1 <span class="hljs-number"><span class="hljs-number">940</span></span> Sending... Company1 <span class="hljs-number"><span class="hljs-number">57</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">3</span></span> Sending... Company1 <span class="hljs-number"><span class="hljs-number">100</span></span> Sending... Company2 <span class="hljs-number"><span class="hljs-number">947</span></span></code> </pre><br><br>  Let's say we want to get results for Company1, or another company whose name you specify as an argument.  In this case, we would need to change our client program as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Stock Market Client // Connects SUB socket to tcp://localhost:4040 // Collects stock exchange values // #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* subscriber = zmq_socket(context, ZMQ_SUB); const char* filter; if(argc &gt; 1) { filter = argv[1]; } else { filter = "Company1"; } printf("Collecting stock information from the server.\n"); int conn = zmq_connect(subscriber, "tcp://localhost:4040"); conn = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, filter, strlen(filter)); int i = 0; for(i = 0; i &lt; 10; i++) { zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, subscriber, 0); int length = zmq_msg_size(&amp;reply); char* value = malloc(length + 1); memcpy(value, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); printf("%s\n", value); free(value); } zmq_close(subscriber); zmq_ctx_destroy(context); return 0; }</span></span></code> </pre><br><br>  The output will contain something like the following: <br><br><pre> <code class="cpp hljs">Company1 <span class="hljs-number"><span class="hljs-number">575</span></span> Company1 <span class="hljs-number"><span class="hljs-number">504</span></span> Company1 <span class="hljs-number"><span class="hljs-number">513</span></span> Company1 <span class="hljs-number"><span class="hljs-number">584</span></span> Company1 <span class="hljs-number"><span class="hljs-number">444</span></span> Company1 <span class="hljs-number"><span class="hljs-number">1010</span></span> Company1 <span class="hljs-number"><span class="hljs-number">524</span></span> Company1 <span class="hljs-number"><span class="hljs-number">963</span></span> Company1 <span class="hljs-number"><span class="hljs-number">929</span></span> Company1 <span class="hljs-number"><span class="hljs-number">718</span></span></code> </pre><br><br><h4>  Message Filtering </h4><br>  Our main stock exchange application sends messages to customers.  It seems all the messages delivered, as expected, right?  Unfortunately not. <br>  Let's change our server code to the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Stock Market Server // Binds PUB socket to tcp://*:4040 // Publishes random stock values of random companies // #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* publisher = zmq_socket(context, ZMQ_PUB); int conn = zmq_bind(publisher, "tcp://*:4040"); const char* companies[3] = {"Company1", "Company10", "Company101"}; int count = 0; for(;;) { int price = count % 17; int which_company = count % 3; int index = strlen(companies[which_company]); char update[64]; snprintf(update, sizeof update, "%s", companies[which_company]); zmq_msg_t message; zmq_msg_init_size(&amp;message, index); memcpy(zmq_msg_data(&amp;message), update, index); zmq_msg_send(&amp;message, publisher, 0); zmq_msg_close(&amp;message); count++; } zmq_close(publisher); zmq_ctx_destroy(context); return 0; }</span></span></code> </pre><br><br>  Now let's change our client code to the following: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Stock Market Client // Connects SUB socket to tcp://localhost:4040 // Collects stock exchange values // #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* subscriber = zmq_socket(context, ZMQ_SUB); const char* filter; if(argc &gt; 1) { filter = argv[1]; } else { filter = "Company1"; } printf("Collecting stock information from the server.\n"); int conn = zmq_connect(subscriber, "tcp://localhost:4040"); conn = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, filter, strlen(filter)); int i = 0; for(i = 0; i &lt; 10; i++) { zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, subscriber, 0); int length = zmq_msg_size(&amp;reply); char* value = malloc(length + 1); memcpy(value, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); printf("%s\n", value); free(value); } zmq_close(subscriber); zmq_ctx_destroy(context); return 0; }</span></span></code> </pre><br><br>  In this case, the output will be something similar to the following: <br><br><pre> <code class="cpp hljs">Collecting stock information from the server. Company101 <span class="hljs-number"><span class="hljs-number">950</span></span> Company10 <span class="hljs-number"><span class="hljs-number">707</span></span> Company101 <span class="hljs-number"><span class="hljs-number">55</span></span> Company101 <span class="hljs-number"><span class="hljs-number">343</span></span> Company10 <span class="hljs-number"><span class="hljs-number">111</span></span> Company1 <span class="hljs-number"><span class="hljs-number">651</span></span> Company10 <span class="hljs-number"><span class="hljs-number">287</span></span> Company101 <span class="hljs-number"><span class="hljs-number">8</span></span> Company1 <span class="hljs-number"><span class="hljs-number">889</span></span> Company101 <span class="hljs-number"><span class="hljs-number">536</span></span></code> </pre><br><br>  Our client code clearly says that we want to see the result for Company1.  However, the server again sends us the results for Company10 and Company101.  This, of course, is not what we want.  We have to solve this little problem. <br>  We can do a little hack to get what we want, but using the delimiter is a simpler option. <br>  We need to make some changes, both in the client code and in the server code, we will filter company names using a separator. <br>  Below is the updated server code that fixes past problems.  Pay attention to the highlighted lines, they show how we can use a separator to send a message to customers: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Stock Market Server // Binds PUB socket to tcp://*:4040 // Publishes random stock values of random companies // #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* publisher = zmq_socket(context, ZMQ_PUB); int conn = zmq_bind(publisher, "tcp://*:4040"); conn = zmq_bind(publisher, "ipc://stock.ipc"); const char* companies[3] = {"Company1", "Company10", "Company101"}; for(;;) { int price = count % 17; int which_company = count % 3; int index = strlen(companies[which_company]); char update[64]; sprintf(update, "%s| %d", companies[which_company], price); zmq_msg_t message; zmq_msg_init_size(&amp;message, index); memcpy(zmq_msg_data(&amp;message), update, index); zmq_msg_send(&amp;message, publisher, 0); zmq_msg_close(&amp;message); count++; } zmq_close(publisher); zmq_ctx_destroy(context); return 0; }</span></span></code> </pre><br><br>  Take a look at the updated client code to filter the results: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Stock Market Client // Connects SUB socket to tcp://localhost:4040 // Collects stock exchange values // #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* subscriber = zmq_socket(context, ZMQ_SUB); const char* filter; filter = "Company1|"; printf("Collecting stock information from the server.\n"); int conn = zmq_connect(subscriber, "tcp://localhost:4040"); conn = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, filter, strlen(filter)); int i = 0; for(i = 0; i &lt; 10; i++) { zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, subscriber, 0); int length = zmq_msg_size(&amp;reply); char* value = malloc(length + 1); memcpy(value, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); printf("%s\n", value); free(value); } zmq_close(subscriber); zmq_ctx_destroy(context); return 0; }</span></span></code> </pre><br><br>  After the changes that were made to the client and server code, we can see exactly the results that were expected. <br><br><h4>  Socket options </h4><br>  Since we use the client-server model, we use the parameter named <code>ZMQ_SUBSCRIBE</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> conn = zmq_connect(subscriber, <span class="hljs-string"><span class="hljs-string">"tcp://localhost:4040"</span></span>); conn = zmq_setsockopt(subscriber, ZMQ_SUBSCRIBE, option_value, <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(option_value));</code> </pre><br><br>  Socket options are set in the zmq_setsockopt () function.  It takes four parameters: <br><ul><li>  socket </li><li>  option name </li><li>  option value </li><li>  option size </li></ul><br><br>  This can be seen from the following line: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zmq_setsockopt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *socket, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> option_name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *option_ value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> option_len)</span></span></span></span>;</code> </pre><br><br><h5>  Subscribe </h5><br>  <code>ZMQ_SUBSCRIBE</code> creates a new message in the <code>ZMQ_SUB</code> socket.  If the <code>option_value</code> argument <code>option_value</code> not empty, then we subscribe to all messages that begin with <code>option_value</code> .  You can configure multiple filters for one <code>ZMQ_SUB</code> socket. <br><br><h5>  Unsubscribe </h5><br>  <code>ZMQ_UNSUBSCRIBE</code> deletes the message from the <code>ZMQ_SUB</code> socket.  It only deletes one message, even if several filters are configured. <br>  The main thing that we need to learn about the client-server socket is that we will never know when the client starts to receive messages.  In this case, it is a good idea to start the client first, and then the server.  Because the client always perceives the first message as a connection to the server, which takes a lot of time, and the server can already send messages at this time. <br>  However, we will talk about how to synchronize the server with the client, since we should not send messages if the client is not in touch. <br><br><h4>  Notes on the client-server model </h4><br>  In the client-server model, you should pay attention to the following points: <br><ul><li>  Messages are queued on the server side if you are using TCP, and the client is too slow to receive messages.  We show how you can protect the application from this. </li><li>  A client can connect to multiple servers.  Data will be transferred according to the fair-queue strategy. </li><li>  The server sends all messages to all clients, and filtering is performed on the client side, this was demonstrated above in the exchange market program. </li></ul><br>  In Chapter 4, we will return to the client-server model, consider more complex examples and show how to deal with ‚Äúslow‚Äù clients. <br><br><h4>  Pattern pipeline </h4><br>  Let's continue, consider the model pipeline.  The pipeline pattern transfers data between the ordered nodes to the pipeline.  Data is transmitted continuously and at each step the pipe is attached to one of several nodes.  Between nodes, a cyclic data transfer strategy is used.  This is a bit like a request-response model. <br><br><h5>  Strategy divide and conquer </h5><br>  There is no salvation from this strategy of divide and conquer when you program.  Remember, when you first started learning programming, and your teacher used it almost in merge sorting, and after a week half of the group stopped attending classes.  I am sure that everyone remembers this very well.  And here again, divide and conquer! <br>  Let's write something parallel on ZeroMQ.  Consider a scenario where we have a generator that generates random numbers.  We have workers who find the square root of these numbers by the Newton method.  We also have a collector who collects the results from the workers. <br>  Below is the server code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/time.h&gt; #include &lt;time.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); // This is the socket that we send messages. void* socket = zmq_socket(context, ZMQ_PUSH); zmq_bind(socket, "tcp://*:4040"); // This is the socket that we send batch message. void* connector = zmq_socket(context, ZMQ_PUSH); zmq_connect(connector, "tcp://localhost:5050"); printf("Please press enter when workers are ready..."); getchar(); printf("Sending tasks to workers...\n"); // The first message. It's also the signal start of batch. int length = strlen("-1"); zmq_msg_t message; zmq_msg_init_size(&amp;message, length); memcpy(zmq_msg_data(&amp;message), "-1", length); zmq_msg_send(&amp;message, connector, 0); zmq_msg_close(&amp;message); // Generate some random numbers. srandom((unsigned) time(NULL)); // Send the tasks. int count; int msec = 0; for(count = 0; count &lt; 100; count++) { int load = (int) ((double) (100) * random () / RAND_MAX); msec += load; char string[10]; sprintf(string, "%d", load); } printf("Total: %d msec\n", msec); sleep(1); zmq_close(connector); zmq_close(socket); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre><br><br>  Just take a look at the employee's code, where we do some calculations for calculating the square root of a number by the Newton method: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include "zmq.h" double square(double x) { return x * x; } double average(double x, double y) { return (x + y) / 2.0; } double good_enough(double guess, double x) { return abs(square(guess) - x) &lt; 0.000001; } double improve(double guess, double x) { return average(guess, x / guess); } double sqrt_inner(double guess, double x) { if(good_enough(guess, x)) return guess; else return sqrt_inner(improve(guess, x), x); } double newton_sqrt(double x) { return sqrt_inner(1.0, x); } int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); // Let's initialize a socket to receive messages. void* receiver = zmq_socket(context, ZMQ_PULL); zmq_connect(receiver, "tcp://localhost:4040"); // Let's initialize a socket to send the messages. void* sender = zmq_socket(context, ZMQ_PUSH); zmq_connect(sender, "tcp://localhost:5050"); for(;;) { zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, receiver, 0); int length = zmq_msg_size(&amp;reply); char* msg = malloc(length + 1); memcpy(msg, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); fflush(stdout); double val = atof(msg); printf("%.1f: %.1f\n", val, newton_sqrt(val)); sleep(1); free(msg); zmq_msg_t message; char* ssend = "T"; int t_length = strlen(ssend); zmq_msg_init_size(&amp;message, t_length); memcpy(zmq_msg_data(&amp;message), ssend, t_length); zmq_msg_send(&amp;message, receiver, 0); zmq_msg_close(&amp;message); } zmq_close(receiver); zmq_close(sender); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre><br><br>  We give the code and collector: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;string.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* receiver = zmq_socket(context, ZMQ_PULL); zmq_bind(receiver, "tcp://*:5050"); // We receive the first message and discard it since it's the // signal start of batch which is -1. zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, receiver, 0); int length = zmq_msg_size(&amp;reply); char* msg = malloc(length + 1); memcpy(msg, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); free(msg); int count; for(count = 0; count &lt; 100; count++) { zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, receiver, 0); int length = zmq_msg_size(&amp;reply); char* value = malloc(length + 1); memcpy(value, zmq_msg_data(&amp;reply), length); zmq_msg_close(&amp;reply); free(value); if(count / 10 == 0) printf("10 Tasks have been processed."); fflush(stdout); } zmq_close(receiver); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre><br><br>  The following diagram represents the code written above: <br><br><img src="//habrastorage.org/files/2ae/497/dd5/2ae497dd56724322ab9476d887d51f74.png"><br><br>  What do we have: <br><ul><li>  First you need to synchronize the time when workers begin to work.  As mentioned earlier, the connection process takes some time.  If we do not synchronize, the first worker will receive messages while others are at the connection stage.  In order to prevent this, we must synchronize the start of work so that everything works in parallel. </li><li>  PULL socket collector gets results using the developed fair queue (we talked about it in more detail in the <a href="http://habrahabr.ru/post/198578/">first part</a> ) </li><li>  PUSH server socket evenly sends tasks to employees </li><li>  Workers are connected to both the server and the picker.  If you wish, you can employ more workers. </li></ul><br>  We mentioned that workers are connected to both the server and the collector.  Let's look at these links in more detail. <br>  Let's look at the following lines from our employee‚Äôs code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Let's initialize a socket to receive messages. void* receiver = zmq_socket(context, ZMQ_PULL); zmq_connect(receiver, "tcp://localhost:4040");</span></span></code> </pre><br><br><h5>  ZMQ_PULL socket </h5><br>  When we want to get data from the input to the nodes, we use <code>ZMQ_PULL</code> .  The socket type <code>ZMQ_PULL</code> used to receive messages from the upstream nodes in the pipeline.  As we said earlier, this process is carried out through planning a fair queue. <br><br><h5>  ZMQ_PUSH socket </h5><br>  When we want to communicate with the lower nodes, we use <code>ZMQ_PUSH</code> .  The socket type <code>ZMQ_PUSH</code> used to send messages to the following nodes in the pipeline. <br>  <code>ZMQ_PUSH</code> never discards messages.  If the upstream node is ready to send a message to the downstream node, but the latter is not ready to receive the message and process it, then all messages sent with <code>zmq_send</code> () are blocked until at least one node is available to receive the message. <br><br><h4>  Get ZeroMQ context </h4><br>  Most likely, you noticed that all the examples that were previously given, began with zmq_ctx_new ().  ZeroMQ applications always start by creating a context.  All sockets are created within one process using a context that participates in the process of creating sockets, as they are the fastest way to connect threads in one process.  The ZeroMQ context is thread-safe, so it can be easily transferred between threads. <br>  If the ZeroMQ context cannot be created, then NULL is returned. <br>  Although it is possible to create several contexts that will be considered as separate ZeroMQ applications, the best idea would be to create one context and transfer it to other threads. <br><br><h4>  Context destructor ZeroMQ </h4><br>  At the end of each application, you need to destroy the context that you created by calling <code>zmq_ctx_destroy</code> ().  After calling <code>zmq_ctx_destroy</code> (), all processes return an error code ( <code>ETERM</code> ), <code>zmq_ctx_destroy</code> () blocks calls to open sockets and closes them, calling <code>zmq_close</code> (). <br><br><h4>  Cleaning </h4><br>  When you program in programming languages ‚Äã‚Äãlike Pyhton or Java, you don‚Äôt need to worry about memory management, as these languages ‚Äã‚Äãhave built-in garbage collectors. <br>  For example, Pyhton uses reference counting, when the counter becomes zero, then the memory is freed automatically.  Thus, you should explicitly close the connection when writing a ZeroMQ application on Pyhton, since it will be automatically closed as soon as the object‚Äôs reference count is zero.  However, it should be noted that this will not work in Jython, PyPy, or IronPython.  Anyway, you can find enough information in the Python documentation.  Let's go back to our main task. <br>  When you write in C, memory management is entirely your responsibility.  Otherwise, you will have an unstable application that will have memory leaks. <br>  You must take care of closing the sockets, deleting messages and the ZeroMQ context.  There are several things to consider in order to successfully complete an application: <br><ul><li>  As mentioned earlier, to close the application you need to destroy the ZeroMQ context by calling <code>zmq_ctx_destroy</code> ().  However, if there are open sockets, then <code>zmq_ctx_destroy</code> can wait to close them indefinitely.  Thus, you must first close all sockets and then call <code>zmq_ctx_destroy</code> () to destroy the context. </li><li>  <code>zmq_ctx_destroy</code> () will wait indefinitely if there is an open connection or there are messages in the queue to send. </li><li>  whenever you finish processing a message, you must close it immediately by calling <code>zmq_msg_close</code> (), otherwise your application will have memory leaks. </li><li>  do not open many sockets.  If you do this, then this largely means that you are doing something wrong and better design the application from scratch. </li></ul><br>  You may be surprised to see what happens with your application if it is written incorrectly, especially if it is multi-threaded.  In this case, it will be extremely difficult to catch the error. <br><br><h4>  Memory leak detection </h4><br>  An application written in C or C ++ needs a well-written memory manager, since memory management completely falls on the programmer‚Äôs shoulders.  For this we will use a wonderful Linux tool called Valgrind.  Among many other useful features for source code analysis, this tool can be used to detect memory leaks. <br>  The next section is a small tutorial on Valgrind, in which we take a closer look at how to use Valgrind when writing applications on ZeroMQ. <br><br><h5>  Introduction to Valgrind </h5><br>  You can compile your application using the ‚Äìg option to display debug information.  In this case, the error messages will contain the exact line numbers. <br>  Consider the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char const *argv[]) { char* a = malloc(4); int b; printf("b = %d\n", b); return 0; }</span></span></span></span></code> </pre><br><br>  Let's compile in gcc by typing <code>gcc ‚Äìg ‚Äìo test test.c</code>  Now it's time to run Valgrind to check for memory leaks.  Let's run the following command: <br><br><pre> <code class="cpp hljs">valgrind --leak-check=full --show-reachable=yes test</code> </pre><br><br>  After we entered the previous command, Valgrind will start checking the code for memory errors using the memcheck tool.  You can call it separately by running tool = memcheck, but that would be meaningless, since memcheck is the default tool.  The output will be similar to the following: <br><br><pre> <code class="cpp hljs">==<span class="hljs-number"><span class="hljs-number">98190</span></span>== Conditional jump <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> move depends on uninitialised value(s) ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== at <span class="hljs-number"><span class="hljs-number">0x2D923</span></span>: __vfprintf ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== by <span class="hljs-number"><span class="hljs-number">0x4AC5A</span></span>: vfprintf_l ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== by <span class="hljs-number"><span class="hljs-number">0x952BE</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== by <span class="hljs-number"><span class="hljs-number">0x1F5E</span></span>: main (test.c:<span class="hljs-number"><span class="hljs-number">8</span></span>) ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== <span class="hljs-number"><span class="hljs-number">4</span></span> bytes in <span class="hljs-number"><span class="hljs-number">1</span></span> blocks are definitely lost in loss record <span class="hljs-number"><span class="hljs-number">1</span></span> of <span class="hljs-number"><span class="hljs-number">5</span></span> ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== at <span class="hljs-number"><span class="hljs-number">0xF656</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (vg_replace_malloc.c:<span class="hljs-number"><span class="hljs-number">195</span></span>) ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== by <span class="hljs-number"><span class="hljs-number">0x1F46</span></span>: main (test.c:<span class="hljs-number"><span class="hljs-number">6</span></span>) ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== LEAK SUMMARY: ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== definitely lost: <span class="hljs-number"><span class="hljs-number">4</span></span> bytes in <span class="hljs-number"><span class="hljs-number">1</span></span> blocks ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== indirectly lost: <span class="hljs-number"><span class="hljs-number">0</span></span> bytes in <span class="hljs-number"><span class="hljs-number">0</span></span> blocks ==<span class="hljs-number"><span class="hljs-number">98190</span></span>== possibly lost: <span class="hljs-number"><span class="hljs-number">0</span></span> bytes in <span class="hljs-number"><span class="hljs-number">0</span></span> blocks</code> </pre><br><br>  Now let's describe a little the previous output: <br><ul><li>  we will not discuss 98190, as this is the process ID </li><li>  <code>Conditional jump or move depends on uninitialised value(s)</code> means that the initialization in our code was successful </li><li>  <code>definitely lost</code> means there is a memory leak and we need to fix it. </li><li> <code>indirectly lost</code>   ,     </li><li> <code>possibly lost</code> ,      </li></ul><br>   Valgrind  <code>$PREFIX/lib/valgrind/default.supp</code> .   ,          ZeroMQ,      : <br><br><pre> <code class="cpp hljs">{ &lt;socketcall_sendto&gt; Memcheck:Param socketcall.sendto(msg) fun:send ... } { &lt;socketcall_sendto&gt; Memcheck:Param socketcall.send(msg) fun:send ... }</code> </pre><br><br>      Valgrind      : <br><br><pre> <code class="cpp hljs">valgrind --leak-check=full --show-reachable=yes --suppressions=zeromq.supp server</code> </pre><br><br><h4>  Conclusion </h4><br>            ,    -   pipeline.           ,      .           Valgrind. <br><br>    ,       . </div><p>Source: <a href="https://habr.com/ru/post/216957/">https://habr.com/ru/post/216957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216941/index.html">FireChat: First Mesh Messenger</a></li>
<li><a href="../216943/index.html">How we did the island of the Mistress of Copper Mountain</a></li>
<li><a href="../216949/index.html">MS Word vulnerability is exploited in-the-wild</a></li>
<li><a href="../216953/index.html">New CEO Mozilla has become the creator of JavaScript Brendan Ike</a></li>
<li><a href="../216955/index.html">Use traits with benefits</a></li>
<li><a href="../216959/index.html">GamesJamKanobu is over. Winners Announced</a></li>
<li><a href="../216961/index.html">Google Now appeared in Chrome on Windows and Mac</a></li>
<li><a href="../216963/index.html">Soaring wind turbine BAT: electricity, cellular, Wi-Fi and weather station</a></li>
<li><a href="../216967/index.html">The new Google Glass will be designed by the manufacturer Ray-Ban.</a></li>
<li><a href="../216969/index.html">Learning to deal with</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>