<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using LevelDB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Faced a situation where my colleagues use SQLite, MemcacheDB, Redis to ignore embedded repositories such as LevelDB, Sophia, HamsterDB, etc. to organi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using LevelDB</h1><div class="post__text post__text-html js-mediator-article">  Faced a situation where my colleagues use SQLite, MemcacheDB, Redis to ignore embedded repositories such as LevelDB, Sophia, HamsterDB, etc. to organize local persistent key-value repositories. <br><br>  I broke the article into two parts: <br><ol><li>  <a href="https://habr.com/ru/post/256207/">small introduction to LevelDB api;</a> </li><li>  <a href="https://habr.com/ru/post/256207/">using LevelDB, for storing time series.</a> </li></ol><br><a name="habracut"></a><br><br><h4> <b><a name="1"></a></b>  <b>LevelDB and its API</b> </h4><br>  Some properties of LevelDB: <br><ul><li>  key-value storage; </li><li>  key and value is an arbitrary array of bytes; </li><li>  data is stored in an orderly manner; the order can be set; </li><li>  forward and reverse iterator for crawling data; </li><li>  multiple atomic update; </li><li>  snapshot support; </li><li>  data compression via <a href="https://code.google.com/p/snappy/">snappy</a> . </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  <b>Opening and closing</b> </h5><br>  Opening: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;assert&gt; #include "leveldb/db.h" leveldb::DB* db; leveldb::Options options; options.create_if_missing = true; leveldb::Status status = leveldb::DB::Open(options, "/tmp/testdb", &amp;db); assert(status.ok());</span></span></span></span></code> </pre> <br><br>  Closing: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> db;</code> </pre><br><br>  <b>Options:</b> <br><table><tbody><tr><th>  Name </th><th>  Description </th><th>  Default value </th></tr><tr><td>  comparator </td><td>  key order setting comparator </td><td>  BytewiseComparator, uses within itself <a href="http://www.cplusplus.com/reference/cstring/memcmp/">memcmp</a> </td></tr><tr><td>  create_if_missing </td><td>  create base if absent </td><td>  false </td></tr><tr><td>  error_if_exists </td><td>  throw error if base exists </td><td>  false </td></tr><tr><td>  paranoid_checks </td><td>  aggressive base integrity check </td><td>  false </td></tr><tr><td>  env </td><td>  environment through which I / O operations will be performed </td><td>  Env :: Default () </td></tr><tr><td>  write_buffer_size </td><td>  write buffer size </td><td>  4MB </td></tr><tr><td>  max_open_files </td><td>  number of open files </td><td>  1000 </td></tr><tr><td>  block_cache </td><td>  use special block cache </td><td>  NULL, creates and uses 8MB internal cache </td></tr><tr><td>  block_size </td><td>  approximate amount of user data in the block </td><td>  4K </td></tr><tr><td>  compression </td><td>  block compression </td><td>  kSnappyCompression </td></tr><tr><td>  filter_policy </td><td>  filter (bloom) to reduce disk read operations. </td><td>  Null </td></tr></tbody></table><br><br><h5>  <b>Slice</b> </h5><br>  Slice is a structure representing the key and value in a number of methods.  Slice contains a pointer to the data and data size, while Slice does not contain a buffer for the data, so you should not allow such situations: <br><pre> <code class="cpp hljs">leveldb::Slice slice; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = ...; slice = str; } Use(slice);</code> </pre><br>  leveldb :: Slice has a number of constructors for usability: <br><pre> <code class="cpp hljs">Slice(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* d, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) : data_(d), size_(n) { } Slice(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s) : data_(s.data()), size_(s.size()) { } Slice(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* s) : data_(s), size_(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(s)) { }</code> </pre><br>  And methods for getting data <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* leveldb::Slice::data() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> leveldb::Slice::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> leveldb::Slice::ToString() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>;</code> </pre><br><br><h5>  <b>Status</b> </h5><br><br>  To report possible errors, most functions in LevelDB return status. <br>  By status, you can check the function completed successfully and get a text description of the error. <br><pre> <code class="cpp hljs">leveldb::Status s = ...; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s.ok()) <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; s.ToString() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><h5>  <b>Read, write, delete</b> </h5><br>  Signatures Put, Get, Delete: <br><pre> <code class="cpp hljs">Status leveldb::DB::Put(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WriteOptions&amp; options, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Slice&amp; key, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Slice&amp; value); Status leveldb::DB::Get(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ReadOptions&amp; options, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Slice&amp; key, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>* value); Status leveldb::DB::Delete(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WriteOptions&amp; options, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Slice&amp; key);</code> </pre><br>  Usage example: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> value; leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);</code> </pre><br><br><h5>  <b>Iterator</b> </h5><br><br>  The iterator is represented by the leveldb :: Iterator class and has the following interface: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> leveldb::Iterator::Valid() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> leveldb::Iterator::SeekToFirst(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> leveldb::Iterator::SeekToLast(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> leveldb::Iterator::Seek(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Slice&amp; target); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> leveldb::Iterator::Next(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> leveldb::Iterator::Prev(); Slice leveldb::Iterator::key() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; Slice leveldb::Iterator::value() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; Status leveldb::Iterator::status() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>;</code> </pre><br><br>  The iterator interface provides methods for sequential and arbitrary <br>  access.  Sequential access can be performed both in direct and in reverse. <br>  direction. <br><br><pre> <code class="cpp hljs">leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; it-&gt;key().ToString() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; it-&gt;value().ToString() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } assert(it-&gt;status().ok()); <span class="hljs-comment"><span class="hljs-comment">// Check for any errors found during the scan delete it;</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (it-&gt;Seek(start); it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit; it-&gt;Next()) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) { ... }</code> </pre><br><br><h4> <b><a name="2"></a></b>  <b>Use LevelDB to store time series.</b> </h4><br><br>  My work is related to monitoring systems, and therefore time series and <a href="http://en.wikipedia.org/wiki/Time_series_database">time series database appeared</a> . <br><br>  We confine ourselves to two operations: <br><ul><li>  adding data; </li><li>  sequential read interval. </li></ul><br><br><h5>  <b>Data schema</b> </h5><br><br>  The following scheme is used to store metrics in a key-value repository: key = metric + timestamp + tags (optional tags). <br>  Similarly, <a href="http://opentsdb.net/">OpenTSDB</a> works on top of HBase. <br>  Inside OpenTSDB there is a metric uid scheme and a data schema.  The same principle will be involved here. <br><br>  One database will be used to store identifiers of metrics.  The key here will be a number in <b>size_t</b> , the value of the string in the style of C. <br><br>  The second base will be used for the data, the key here will be the structure of the form: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> muid; <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> timestamp; };</code> </pre><br>  the value will be stored as <b>double</b> .  Here the fact that the key and value in LevelDB is an array of bytes, is used to its fullest <br>  so we can use simple data structures without any serialization. <br><br><h5>  <b>Storage interface</b> </h5><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctime&gt; #include &lt;cstdint&gt; #include &lt;memory&gt; #include &lt;unordered_map&gt; namespace leveldb { class DB; class Iterator; class Slice; class Comparator; class Cache; } /*! *   */ class Storage { public: class Iterator; typedef size_t MetricUid; /*! *   */ struct Key { MetricUid muid; //!&lt; uid  time_t timestamp; //!&lt;  }; /*! *  * @param dir         * @param cacheSizeMb    */ Storage(const std::string&amp; dir, size_t cacheSizeMb = 16); /*! * @brief  . * @param name   * @return    * *     UID'   UID . *     ,   UID  */ MetricUid addMetric(const std::string&amp; name); /*! *   * @param muid   * @param timestamp   * @param value  * @return true    */ bool put(MetricUid muid, time_t timestamp, double value); /*! *       * @param muid   * @param from   * @param to   * @return  */ Iterator get(MetricUid muid, time_t from, time_t to); Storage(const Storage&amp;) = delete; Storage&amp; operator=(const Storage&amp;) = delete; private: /*! *   uid  */ void initUID(); /*! *   */ void initData(); private: /*! *    UID */ MetricUid m_currentIndx; /*! *   */ std::string m_dir; /*! *    */ size_t m_cacheSizeMb; /*! *    */ std::shared_ptr&lt;leveldb::Cache&gt; m_dataCache; /*! *  UID' */ std::shared_ptr&lt;leveldb::DB&gt; m_uid; /*! *   */ std::shared_ptr&lt;leveldb::DB&gt; m_data; /*! *   -&gt; uid */ std::unordered_map&lt;std::string, MetricUid&gt; m_metric2uid; }; /*! *      */ class Storage::Iterator { public: typedef std::tuple&lt;time_t, double&gt; Value; typedef std::shared_ptr&lt;leveldb::Iterator&gt; IteratorPrivate; Iterator(); Iterator(const IteratorPrivate&amp; iter, const Key&amp; limit); /*! *     * @return true    */ bool valid() const; /*! *   * @return  &lt;, &gt; */ Value value() const; /*! *     */ void next(); private: IteratorPrivate m_iter; //!&lt;  LevelDB Key m_limit; //!&lt;      };</span></span></span></span></code> </pre><br><br>  The Storage constructor takes the path to the directory where the base with the uid and the database will be placed, the size of the cache block. <br><br><h5>  <b>Implementation</b> </h5><br><br>  Let's start with the comparator, because  Memcmp is not suitable for comparing numbers.  Due to the use of the structure as a key, the code is simple and readable: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimeMeasurementComporator</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> leveldb::Comparator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leveldb::Slice&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leveldb::Slice&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* dataA = a.data(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* dataB = b.data(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Storage::Key* keyA = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Storage::Key*&gt;(dataA); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Storage::Key* keyB = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Storage::Key*&gt;(dataB); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyA-&gt;muid &lt; keyB-&gt;muid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyA-&gt;muid &gt; keyB-&gt;muid) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyA-&gt;timestamp &lt; keyB-&gt;timestamp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keyA-&gt;timestamp &gt; keyB-&gt;timestamp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Ignore the following methods for now: const char* Name() const { return "TimeMeasurementComporator"; } void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { } void FindShortSuccessor(std::string*) const { } }; TimeMeasurementComporator GLOBAL_COMPORATOR; }</span></span></code> </pre><br><br>  Further initialization / creation of a database for data: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Storage::initData() { DB* data; Options options; options.create_if_missing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; options.compression = kNoCompression; options.comparator = &amp;GLOBAL_COMPORATOR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_cacheSizeMb) { options.block_cache = leveldb::NewLRUCache(m_cacheSizeMb * <span class="hljs-number"><span class="hljs-number">1048576</span></span>); m_dataCache.reset(options.block_cache); } Status status = DB::Open(options, m_dir + <span class="hljs-string"><span class="hljs-string">"/data"</span></span>, &amp;data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!status.ok()) { LOG(ERROR)&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Error opening database "</span></span>&lt;&lt;status.ToString(); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } m_data.reset(data); }</code> </pre><br>  In the options, the global comparator is transmitted, and compression is disabled.  LelelDB is going without Snappy. <br><br>  Database initialization with metric identifiers: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Storage::initUID() { Options options; options.create_if_missing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; options.compression = kNoCompression; DB* cfg; Status status = DB::Open(options, m_dir + <span class="hljs-string"><span class="hljs-string">"/conf"</span></span>, &amp;cfg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!status.ok()) { LOG(ERROR)&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Error opening database "</span></span>&lt;&lt;status.ToString(); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } m_uid.reset(cfg); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;leveldb::Iterator&gt; it( m_uid-&gt;NewIterator(leveldb::ReadOptions())); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* index = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*&gt;(it-&gt;key().data()); m_metric2uid[it-&gt;value().ToString()] = *index; m_currentIndx = *index; } }</code> </pre><br>  This is where the base is initialized and the display of the metric in the UID is filled. <br><br>  Adding data is quite simple: <br><pre> <code class="cpp hljs">Storage::MetricUid Storage::addMetric(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; name) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = m_metric2uid.find(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != m_metric2uid.end()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result-&gt;second; } ++m_currentIndx; m_metric2uid[name] = m_currentIndx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = m_uid-&gt;Put(WriteOptions(), Slice(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;m_currentIndx), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(m_currentIndx)), name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s.ok()) { LOG(ERROR)&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Error put "</span></span>&lt;&lt;s.ToString(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_currentIndx; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Storage::put(MetricUid muid, <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> timestamp, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Key key = {muid, timestamp}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s = m_data-&gt;Put(WriteOptions(), Slice(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;key), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(key)), Slice(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;value), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(value))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s.ok()) { LOG(ERROR)&lt;&lt;<span class="hljs-string"><span class="hljs-string">"Error put "</span></span>&lt;&lt;s.ToString(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.ok(); }</code> </pre><br><br>  Data acquisition is implemented by creating a wrapper over a LevelDB iterator: <br><pre> <code class="hljs cpp">Storage::Iterator Storage::get(MetricUid muid, <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> from, <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> to) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Key begin = {muid, from}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Key end = { muid, to }; Storage::Iterator::<span class="hljs-function"><span class="hljs-function">IteratorPrivate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_data-&gt;NewIterator(ReadOptions()))</span></span></span></span>; iter-&gt;Seek(Slice(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(&amp;begin), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(begin))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Storage::Iterator(iter, end); } Storage::Iterator::Iterator(): m_iter(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;m_limit, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(m_limit)); } Storage::Iterator::Iterator(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IteratorPrivate&amp; iter, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Key&amp; limit) : m_iter(iter), m_limit(limit) { } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Storage::Iterator::valid() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!m_iter) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Slice </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*&gt;(&amp;m_limit), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(m_limit))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_iter-&gt;Valid() &amp;&amp; (GLOBAL_COMPORATOR.Compare(m_iter-&gt;key(),right) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>); } Storage::Iterator::Value Storage::Iterator::value() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!m_iter) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Key* data =<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Key*&gt;(m_iter-&gt;key().data()); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val = *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>*&gt;(m_iter-&gt;value().data()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value(data-&gt;timestamp, val); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Storage::Iterator::next() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(m_iter &amp;&amp; m_iter-&gt;Valid()) { m_iter-&gt;Next(); } }</code> </pre><br><br>  The source code for the prototype is on <a href="https://github.com/RPG-18/tmdb">github</a> . <br><br>  From the interesting: <br>  <a href="https://vimeo.com/95313698">An overview of popular modern disk storage algorithms: LevelDB, TokuDB, LMDB, Sophia</a> <br>  <a href="http://www.highload.ru/2013/abstracts/1617.html">Deep immersion in disk data structures, B-trees, LSM-trees and fractal trees</a> </div><p>Source: <a href="https://habr.com/ru/post/256207/">https://habr.com/ru/post/256207/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256193/index.html">Localization of WPF applications on the fly</a></li>
<li><a href="../256197/index.html">Step-by-step instructions on how to implement uploading files to the server without reloading the page in PHP + Javascript</a></li>
<li><a href="../256199/index.html">Analysis of ARPD on the example of several small mobile applications and games</a></li>
<li><a href="../256201/index.html">CLRium: continue the tour of the cities. Ekaterinburg and Peter</a></li>
<li><a href="../256203/index.html">How and why do I write articles on Habrahabr. Personal experience</a></li>
<li><a href="../256209/index.html">The story of creating another robot. Part Two, "it's alive!"</a></li>
<li><a href="../256211/index.html">Multithreading in Rust</a></li>
<li><a href="../256213/index.html">How to make JSON Vulnerability Protection in the server response under Yii2</a></li>
<li><a href="../256215/index.html">Breaking gas leakage sensor</a></li>
<li><a href="../256217/index.html">What you need to know about migration to Russia by September 1, 2015 from foreign infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>