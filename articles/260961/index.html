<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write on JS in functional and declarative style</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I love functional languages ‚Äã‚Äãfor their simplicity, clarity and predictability. I write mainly on Elixir / Erlang / OTP, I tried other ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write on JS in functional and declarative style</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/72e/b82/252/72eb822524f0413db211508b78f24adf.jpg"><br><br><h1>  Introduction </h1><br>  I love functional languages ‚Äã‚Äãfor their simplicity, clarity and predictability.  I write mainly on Elixir / Erlang / OTP, I tried other languages, but Erlang with its actors is still much closer to me than Lisp or Haskell, for example.  As you know, Erlang == web, and something written for the web sometimes has a client web interface: html, css, js - content.  Alas, js is the standard of the modern web, for it there are libraries for almost any task for almost all occasions, and this is more or less the only available tool to do something in the client-side browser.  Therefore, we still need js.  At first I thought ‚ÄúLambda and functions of a higher order are there, it will be easy to write on js.  I will learn the syntax and write as I write in Erlang / Lisp / Haskell. ‚Äù  How wrong I was. <br><a name="habracut"></a><br><br><h1>  Choose a language </h1><br>  Let's start with the fact that pure js is absolutely no good for writing code.  From the abundance of braces and semicolons in the eyes.  The word return written anywhere in the function body completely opaquely hints at the imperativeness of the language and destroys my belief in the best.  There are many languages, including  and functional ( <a href="http://www.purescript.org/">purescript</a> , <a href="https://github.com/faylang/fay/wiki">fay</a> , <a href="https://github.com/clojure/clojurescript">clojurescript</a> ) compiled in js.  But for myself, I chose <a href="http://coffeescript.org/">coffeescript</a> - a fairly compromise version that both functionaries and imperatives can understand.  In part, this choice was justified by the fact that I use to build projects <a href="http://brunch.io/">brunch</a> , which is written in coffeescript.  Well, compared to fay, for example, the overhead for switching from js to coffeescript is almost equal to 0. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Choosing a framework </h1><br>  The second intriguing question is how to connect our code and html-page.  There are a lot of options.  There are a lot of huge frameworks that actually look quite holistic.  I myself used <a href="https://angularjs.org/">angularjs</a> for some time, but after some practice, obvious disadvantages became apparent: in order to do something, directives are needed, if they are not there, you need to write your bikes, and to understand the internal structure of the angulyar is more difficult than it seems, also view frankly - the most frequently used ng-model directive provides two-way data binding and presentation, which from the point of view of the functional manager is completely ideomatically incorrect and breaks encapsulation in general, moreover, all these Angulyar applications are  otroller etc. itp quite heavy weight code.  Yes, and by the way, the performance of an angulyar is really so-so.  Some time ago I met with <a href="http://facebook.github.io/react/">react js</a> - and my choice fell not on him.  The idea impresses with its simplicity and more or less functional-declarative style.  There is a state that can change in the course of the application operation.  We just pass it from time to time to jreact for rendering. <br><br><pre><code class="coffeescript hljs">widget = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"widget"</span></span>) do_render = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> React.render(widget(state), domelement) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> domelement? render_process = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> do_render() <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> error <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log error setTimeout(render_process, <span class="hljs-number"><span class="hljs-number">500</span></span>)</code> </pre> <br><br>  And that's it!  Madness is simple and effective.  React is concerned with the optimization of rendering, we can now not be interested in this issue at all.  It remains to ensure that the state object changes in a way that fits the functional paradigm.  And here the most interesting begins. <br><br><h1>  Trouble in the kitchen </h1><br>  The first and not very significant problem is the soft types js.  In Erlang, they are of course also soft, but in js they are really soft as, sorry for the expression, shit.  For example, a not very informative, but rather funny <a href="https://www.destroyallsoftware.com/talks/wat">video</a> on this topic.  But in practice, type conversions happen infrequently (in any case, if your code is good) - so I took the soft types js more or less as they are. <br><br>  When I started practicing a little js at first everything was more or less good, but at some point the applications for some reason started to work not at all as I wanted.  I climbed deeper and saw the terrible: <br><br><pre> <code class="bash hljs">coffee&gt; map = {a: 1} { a: 1 } coffee&gt; lst = [] [] coffee&gt; lst.push map 1 coffee&gt; map.a = 2 2 coffee&gt; lst.push map 2 coffee&gt; map.a = 3 3 coffee&gt; lst.push map 3 coffee&gt; lst [ { a: 3 }, { a: 3 }, { a: 3 } ]</code> </pre><br><br>  although in this case I certainly expected to see <br><br><pre> <code class="bash hljs">coffee&gt; lst [ { a: 1 }, { a: 2 }, { a: 3 } ]</code> </pre><br><br>  It really was a shock.  The bingo data in js is mutable!  And as it turned out - everything that is more complicated than the number, string, null and undefined will be passed by reference! <br><br>  But when I saw that <br><br><pre> <code class="bash hljs">coffee&gt; [1,2,3] == [1,2,3] <span class="hljs-literal"><span class="hljs-literal">false</span></span> coffee&gt; {a: 1} == {a: 1} <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  then my hair began to move in various places.  For such a life I did not prepare.  It turns out that the data types of maps and lists in js are not compared by value, but also by reference. <br><br>  I began to think how to be.  With regards to mutability, for example, it was decided to wrap the constant data (for example, to initialize any values) in the lambda-function of arity zero, in such cases they really remained in general not mutable.  You can simply call them in those expressions where they are needed and not be afraid that they (the data) will change. <br><br><pre> <code class="bash hljs">coffee&gt; const_lst = () -&gt; [1,2,3] [Function] coffee&gt; new_lst = const_lst().concat([4,5,6]) [ 1, 2, 3, 4, 5, 6 ] coffee&gt; const_lst() [ 1, 2, 3 ]</code> </pre><br><br>  In principle, I thought, if I recursively wrap all the data in general, if all functions take lambdas and return lambdas, the language will become really functional!  In principle, this is a solution.  You just need to describe these lambda data types based on ordinary types, write functions for recursive direct and inverse transformations into ordinary js types, as well as higher-order functions for working with these lambda types (map, reduce, filter, zip, etc.).  At the same time, by the way, you can make these new types less soft.  The task is, in principle, solved, but rather voluminous, partly by the way already implemented, for example, in this <a href="https://facebook.github.io/immutable-js/">library</a> .  But this approach has quite significant drawbacks: <br><br>  1) Since our code is usually not suspended in the air, but has dependencies on other js libraries, each time referring to them, you need to remember to convert the lambda type to the usual type, and vice versa. <br>  2) With this approach, we will certainly to some extent ensure the purity of the functions and the immunity of the data, but there will still not be transactional <br>  3) This code will not be very clear to those who prefer the imperative approach. <br><br>  Thus, I have so far refused this idea (but if I pay attention to it in the future) and decided to do something less radical, but just as simple and understandable.  Obviously, in order to locally solve the problem of mutability and comparing data by reference, I needed to learn how to recursively copy and compare any js data by value. <br><br>  We write the clone function <br><pre> <code class="coffeescript hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> Object.prototype.toString.call(some) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Undefined]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Boolean]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> some <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Number]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> some <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object String]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> some <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Function]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> some.bind({}) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Null]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Array]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> some.map (el) -&gt; clone(el) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Object]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Object.keys(some).reduce (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acc, k)</span></span></span><span class="hljs-function"> -&gt;</span></span> acc[clone(k)] = clone(some[k]); acc), {}</code> </pre><br><br>  Writing the equal function <br><pre> <code class="coffeescript hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span><span class="hljs-function"> -&gt;</span></span> [type_a, type_b] = [Object.prototype.toString.call(a), Object.prototype.toString.call(b)] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_a == type_b <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> type_a <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Undefined]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a == b <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Boolean]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a == b <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Number]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a == b <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object String]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a == b <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Function]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a.toString() == b.toString() <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Null]"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a == b <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Array]"</span></span> len_a = a.length len_b = b.length <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len_a == len_b [<span class="hljs-number"><span class="hljs-number">0.</span></span>.len_a].every (n) -&gt; equal(a[n], b[n]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-string"><span class="hljs-string">"[object Object]"</span></span> keys_a = Object.keys(a).sort() keys_b = Object.keys(b).sort() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> equal(keys_a, keys_b) keys_a.every (k) -&gt; equal(a[k], b[k]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  It turned out to be simpler than I thought, the only "but" is that if there are circular references in the data, of course, we will get a stack overflow.  For me, in principle, this is not a problem, since I do not use such abstractions as "circular references".  I think you can somehow and process them in the process of data cloning, but then of course the code will not be so simple and elegant.  In general, I collected these and some other functions in the <a href="https://github.com/timCF/imuta">library</a> and I think that the problem of data mutability in js for some time has been solved for me. <br><br><h1>  Actors </h1><br>  Now let's talk why we need the transactional change in data.  Suppose there is some more or less complex state and we change it in the process of performing a function. <br><pre> <code class="coffeescript hljs">state.aaa = <span class="hljs-number"><span class="hljs-number">20</span></span> state.foo = <span class="hljs-number"><span class="hljs-number">100</span></span> state.bar = state.bar.map (el) -&gt; baz(el, state)</code> </pre><br><br>  In practice, the process of changing the state of course can be more complex and lengthy, contain asynchronous calls to external api, etc., etc.  But the bottom line is that if somewhere in the process of changing a state, the function func (state) will be called somewhere else ‚Äî what will happen?  Will the half-changed state be valid?  And maybe due to the single-threaded js semi-modified state, there will not be any at all and everything is fine?  And if not?  And what should I do if I need to make some external calls and it is vital that while I make them state changed?  In order not to wrestle with such difficult issues, we will make the state change transactional. <br><br>  Here I think many will remember about mutexes.  I also remembered mutexes.  And about the states of the race.  And about deadlocks.  And I realized that I do not want this at all, so we will not write a mutex, but will borrow the concept of ‚Äúactor‚Äù from the Erlang language.  In the context of js, the actor will simply be some kind of object that is initialized by a certain state, and will do only three things. <br><br>  1) receive ‚Äúmessages‚Äù as arity 1 or 0 functions and add them to the queue <br>  2) independently ‚Äúraking‚Äù the message queue by applying the arity 1 functions to its internal state (the arity 0 functions are simply called, the state does not change) - all this is done strictly in the order in which the messages were received. <br>  3) on request, return the value of its internal state <br><br>  Naturally, in order to comply with non-data mutability, we will each time clone a state when changing, and in the get function we will return not its state itself, but its copy.  For this we will use the library written earlier.  As a result, we get the code. <br><br><pre> <code class="coffeescript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Act = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(init_state, timeout)</span></span></span><span class="hljs-function"> -&gt;</span></span> obj = { <span class="hljs-comment"><span class="hljs-comment"># # priv # state: Imuta.clone(init_state) queue: [] init: () -&gt; try @state = Imuta.clone(@queue.shift()(@state)) while @queue.length != 0 catch error console.log "Actor error" console.log error this_ref = this setTimeout((() -&gt; this_ref.init()), timeout) # # public # cast: (func) -&gt; if (func.length == 1) and Imuta.is_function(func) @queue.push(Imuta.clone(func)) @queue.length else throw(new Error("Act expects functions arity == 1 (single arg is actor's state)")) zcast: (func) -&gt; if (func.length == 0) and Imuta.is_function(func) @queue.push( ((state) -&gt; Imuta.clone(func)(); state) ) @queue.length else throw(new Error("Act expects functions arity == 0")) get: () -&gt; Imuta.clone(@state) } obj.init() obj</span></span></code> </pre><br>  * Functions that put lambda in a queue are called cast and zcast, by analogy with Erlang functions handle_cast <br><br>  Since not all js-data is cloned (remember cyclic references and external libraries), we will create another version of the constructor for the actor in which we will remove the internal state cloning and collect the whole thing into the <a href="https://github.com/timCF/act">library</a> . <br><br>  Enjoying: <br><pre> <code class="bash hljs">coffee&gt; actor = new Act({a: 1}, <span class="hljs-string"><span class="hljs-string">"pure"</span></span>, 500) { state: { a: 1 }, queue: [], init: [Function], cast: [Function], zcast: [Function], get: [Function] } coffee&gt; actor.cast((state) -&gt; state.b = 1; state) 1 coffee&gt; actor.<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>() { a: 1, b: 1 } coffee&gt; actor.cast((state) -&gt; state.c = 1; state) 1 coffee&gt; value = actor.<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>() { a: 1, b: 1, c: 1 } coffee&gt; value.d = 123 123 coffee&gt; value { a: 1, b: 1, c: 1, d: 123 } coffee&gt; actor.<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>() { a: 1, b: 1, c: 1 } coffee&gt; actor.zcast(() -&gt; console.log <span class="hljs-string"><span class="hljs-string">"hello"</span></span>) 1 coffee&gt; hello coffee&gt; actor.<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>() { a: 1, b: 1, c: 1 } coffee&gt; global_var = {foo: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>} { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } coffee&gt; actor.cast((_) -&gt; global_var) 1 coffee&gt; actor.<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>() { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } coffee&gt; global_var.baz = <span class="hljs-string"><span class="hljs-string">"baf"</span></span> <span class="hljs-string"><span class="hljs-string">'baf'</span></span> coffee&gt; global_var { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, baz: <span class="hljs-string"><span class="hljs-string">'baf'</span></span> } coffee&gt; actor.<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>() { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> }</code> </pre><br><br>  All state changes are made exclusively through the queue using the cast function.  As we can see in the ‚Äúclean‚Äù version of the state, it is completely encapsulated inside the actor, no matter what we do with it after getting from the get function (the same is true if we add something from the outside world to the cast function).  Transactional provided by the message queue.  We received practically Erlang code, only on js.  If we want to use non-clonable data in our state for some reason, then we will simply use the ‚Äúdirty‚Äù version of the actor with a global state.  In principle, even this option (if the state is changed strictly through the actor) is acceptable and ensures the transactional change of the data.  There was also the idea to make changes to the data not just transactional, but in some sense even atomic, transferring not one lambda, but three (for example, in case of some use in external libraries). <br><br><pre> <code class="coffeescript hljs">actor.cast( { prepare: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state)</span></span></span><span class="hljs-function"> -&gt;</span></span> prepare_process(state) apply: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, args)</span></span></span><span class="hljs-function"> -&gt;</span></span> do_work(state, args) rollback: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, args)</span></span></span><span class="hljs-function"> -&gt;</span></span> do_rollback(state, args, error) })</code> </pre><br><br>  But I thought that this is already a bend, especially since in the current version you can just write <br><pre> <code class="coffeescript hljs">actor.cast(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state)</span></span></span><span class="hljs-function"> -&gt;</span></span> args = init_args(state) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> do_work(state, args) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> error rollback(state, args, error))</code> </pre><br>  if suddenly atomicity is so vital. <br><br><h1>  Conclusion </h1><br>  Js ended up not as hopeless as it seemed to me at the beginning.  Behind its lambda functions, there is a real functional power and, with the right level of skill, you can write in a rather declarative style on it.  And for a snack, a simple <a href="https://github.com/timCF/megaweb">example</a> using the actors + react + jade + sass + bullet (Erlang web sockets).  Stay functional, stay web! <br><br><h1>  UPD </h1><br>  Residents of Habr pointed out a number of gross errors in my code, thanks to them for it :) Corrected the shortcomings, namely: <br><br>  1) Replaced in the clone <a href="https://github.com/timCF/imuta/commit/fbf57631f8f690cd7691aa8ee4b67ca6861a0606">binding</a> function with a more adequate and obvious operation of <a href="https://github.com/timCF/imuta/commit/fbf57631f8f690cd7691aa8ee4b67ca6861a0606">cloning the</a> function <br>  2) In the equal function, I added a fairly obvious <a href="https://github.com/timCF/imuta/commit/fbf57631f8f690cd7691aa8ee4b67ca6861a0606">test</a> at the beginning which should improve performance :) <br>  3) I have <a href="https://github.com/timCF/imuta/commit/fbf57631f8f690cd7691aa8ee4b67ca6861a0606">removed the</a> silly function check by the value of func.toString (). <br>  4) When comparing arrays, I no longer use the possibly redefined field length, but simply <a href="https://github.com/timCF/imuta/commit/fbf57631f8f690cd7691aa8ee4b67ca6861a0606">count the</a> elements <br>  5) When storing objects, I do not use the "Object.keys" function, but simply <a href="https://github.com/timCF/imuta/commit/fbf57631f8f690cd7691aa8ee4b67ca6861a0606">collect</a> all the keys from the object.  In a sense, the code has become so even slimmer and more functional. <br><br>  Thanks again to all those who contributed to making this code better.  Actual versions of libraries can be found <a href="https://github.com/timCF/imuta">here</a> and <a href="https://github.com/timCF/act">here</a> .  I am pleased to hear your wishes and suggestions. </div><p>Source: <a href="https://habr.com/ru/post/260961/">https://habr.com/ru/post/260961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260947/index.html">Monitoring and alerting about events in Windows logs: sending to E-mail in Windows Server 2012 R2</a></li>
<li><a href="../260949/index.html">Why is programming so hard?</a></li>
<li><a href="../260953/index.html">10 Tips for Using ExecutorService</a></li>
<li><a href="../260955/index.html">Backup with Bareos and Relax-and-Recover</a></li>
<li><a href="../260957/index.html">Who is stronger - an elephant or ... an elephant?</a></li>
<li><a href="../260963/index.html">Generating mapping via t4 templates</a></li>
<li><a href="../260965/index.html">Building a Rubik's Cube with a genetic algorithm online without SMS</a></li>
<li><a href="../260967/index.html">Droidcon Berlin 2015: how it was</a></li>
<li><a href="../260969/index.html">The digest of news from the world of development on Unity</a></li>
<li><a href="../260971/index.html">Brubeck is a fast, statsd-compatible metric aggregator from GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>