<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>For beginners about stdafx.h</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article is intended for people who are familiar with the Visual Studio environment and try to compile their C ++ projects in it. In an unfamiliar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>For beginners about stdafx.h</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/04c/958/ad7/04c958ad7de22fce899f9506ed207f6a.png" alt="StdAfx.h, Precompiled headers" align="left"><br>  The article is intended for people who are familiar with the Visual Studio environment and try to compile their C ++ projects in it.  In an unfamiliar environment, everything seems strange and incomprehensible.  Especially novice annoying stdafx.h file, because of which there are strange errors during compilation.  Very often it all ends with the fact that a newbie for a long time everywhere carefully turns off Precompiled Headers.  To help people figure out what was happening, this article was written. <br><a name="habracut"></a><br><h2>  What are Precompiled Headers for? </h2><br>  Precompiled headers are designed to speed up the build of projects.  Usually, programmers start to get familiar with Visual C ++ using tiny projects.  It is difficult to notice the gain from precompiled headers on them.  What happens to them, that without them, the program compiles the same time.  This adds confusion.  The person does not see the benefit of this mechanism for himself and decides that he is for specific tasks and he will never need it.  And sometimes he thinks so for many years. <br><br>  In fact, precompiled headers is a very useful technology.  The benefit from it can be seen, even if the project has only a few dozen files.  Especially the gain becomes noticeable if such heavy libraries as boost are used. <br><br>  If you look at the * .cpp files in the project, you will notice that many include the same sets of header files.  For example, &lt;vector&gt;, &lt;string&gt;, &lt;algorithm&gt;.  In turn, these files include other header files and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All this leads to the fact that the preprocessor in the compiler again and again performs the same work.  It must read the same files, insert them into each other, select the #ifdef branches and substitute the values ‚Äã‚Äãof the macros.  There is a tremendous duplication of the same operations. <br><br>  You can significantly reduce the amount of work that the preprocessor must do when compiling a project.  The idea is to <a href="http://www.viva64.com/ru/t/0040/">preprocess a</a> group of files in advance and then simply substitute a ready-made piece of text. <br><br>  In fact, a number of steps are being taken.  You can store not just text, but more processed information.  I don't know how exactly Visual C ++ works.  But, for example, you can store the text already broken into lexemes.  This will further speed up the compilation process. <br><br><h2>  How Precompiled Headers Work </h2><br>  The file that contains the precompiled headers has the extension ".pch".  The file name is usually the same as the project name.  Naturally, this and other used names can be changed in the settings.  A file can be quite large and depends on how many header files it contains.  For example, in the PVS-Studio project, it takes about 3 megabytes. <br><br>  The * .pch file occurs after compiling stdafx.cpp.  The file is collected with the "/ Yc" key.  This key just tells the compiler to create precompiled headers.  The stdafx.cpp file can contain one line: #include "stdafx.h". <br><br>  The file "stdafx.h" is the most interesting.  Here you need to include header files that will be preprocessed in advance.  As an example, here is the stdafx.h file that we use in PVS-Studio (the file is abbreviated for the article): <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"VivaCore/VivaPortSupport.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For /Wall #pragma warning(push) #pragma warning(disable : 4820) #pragma warning(disable : 4619) #pragma warning(disable : 4548) #pragma warning(disable : 4668) #pragma warning(disable : 4365) #pragma warning(disable : 4710) #pragma warning(disable : 4371) #pragma warning(disable : 4826) #pragma warning(disable : 4061) #pragma warning(disable : 4640) #include &lt;stdio.h&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;algorithm&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;list&gt; #include &lt;deque&gt; #include &lt;memory&gt; #pragma warning(pop) //For /Wall</span></span></span></span></code> </pre> <br>  Directives "#pragma warning" we need to get rid of the warnings issued to the standard library. <br><br>  Now in all files * .c / *. Cpp should include "stdafx.h".  At the same time it is worth removing from these files the headers that are already included with the help of "stdafx.h". <br><br>  And what if there are used though similar, but different sets of header files?  For example, such: <ul><li>  File A: &lt;vector&gt;, &lt;string&gt; </li><li>  File B: &lt;vector&gt;, &lt;algorithm&gt; </li><li>  File C: &lt;string&gt;, &lt;algorithm&gt; </li></ul>  Need to do separate precompiled headers?  So you can do, but not necessary. <br><br>  It is enough to make one precompiled header in which &lt;vector&gt;, &lt;string&gt; and &lt;algorithm&gt; will be opened.  The gain is due to the fact that during preprocessing it is not necessary to read a lot of files and insert them into each other much more than the losses on the syntax analysis of unnecessary code fragments. <br><br><h2>  How to use Precompiled Headers </h2><br>  When creating a new Wizard project in Visual Studio, it creates two files: stdafx.h and stdafx.cpp.  It is through them that the precompiled headers mechanism is implemented. <br><br>  In fact, these files can be called as you like.  It is important not the name, but the compilation parameters in the project settings. <br><br>  In the * .c / *. Cpp file you can use only one precompiled header.  However, there may be several different precompiled headers in the same project.  For now, we‚Äôll assume that we have only one. <br><br>  So, if you use the wizard, then you already have the files stdafx.h and stdafx.cpp.  Plus exhibited all the necessary compilation keys. <br><br>  If the project did not use the precompiled headers mechanism, then let's consider how to enable it.  I suggest the following sequence of actions: <ol><li>  In all configurations for all * .c / *. Cpp files we enable the use of precompiled headers.  This is done on the Precompiled Header tab: <ol><li>  Set the value for "Precompiled Header" to "Use (/ Yu)". </li><li>  For the ‚ÄúPrecompiled Header File‚Äù parameter, specify ‚Äústdafx.h‚Äù. </li><li>  For the "Precompiled Header Output File" parameter, specify "$ (IntDir) $ (TargetName) .pch". </li></ol></li><li>  Create and add the stdafx.h file to the project.  In the future, we will include in it those header files that we want to preprocess in advance. </li><li>  Create and add the stdafx.cpp file to the project.  It has one single line: #include "stdafx.h". </li><li>  In all configurations, we change the settings for the stdafx.cpp file.  Set the ‚ÄúPrecompiled Header‚Äù value to ‚ÄúCreate (/ Yc)‚Äù. </li></ol>  So we turned on the precompiled headers mechanism.  Now, if we run the compilation, a * .pch file will be created.  However, then the compilation will stop due to errors. <br><br>  For all * .c / *. Cpp files, we indicated that they should use precompiled headers.  This is not enough.  Now in each of the files you need to add #include "stdafx.h". <br><br>  <b>The header file "stdafx.h" should be included in the first * .c / *. Cpp file.</b>  Sure to!  Otherwise, compilation errors will still occur. <br><br>  If you think about it, there is logic.  When the file ‚Äústdafx.h‚Äù is at the very beginning, you can substitute already preprocessed text.  This text is always the same and does not depend on anything. <br><br>  Imagine the situation if we could include another file before ‚Äústdafx.h‚Äù.  And in this file, take and write: # define bool char.  There is an ambiguity.  We change the contents of all files that mention "bool".  Now you just can not take and substitute a preprocessed text.  The whole mechanism of "precompiled headers" is breaking.  I think this is one of the reasons why ‚Äústdafx.h‚Äù should be located at the beginning.  Perhaps there are others. <br><br><h2>  Life hack </h2><br>  Writing #include "stdafx.h" into all * .c / *. Cpp files is quite tiresome and not interesting.  Additionally, you will get a revision in the version control system, where a huge number of files will be changed.  Not good. <br><br>  Another inconvenience is caused by third-party libraries that are included in the project as files with code.  Edit these files is not washed away.  For the right, they need to disable the use of "precompiled headers".  However, if several small third-party libraries are used, this is inconvenient.  The programmer constantly stumbles on precompiled headers. <br><br>  There is an option how to use precompiled headers is easy and simple.  The method does not fit everywhere and always, but he often helped me. <br><br>  You can not add to all #include ‚Äústdafx.h‚Äù files, but use the ‚ÄúForced Included File‚Äù mechanism. <br><br>  Go to the settings tab ¬´Advanced¬ª.  Select all configurations.  In the field "Forced Included File" we write: <br><br>  StdAfx.h;% (ForcedIncludeFiles) <br><br>  Now "stdafx.h" will automatically be included in the beginning of ALL compiled files.  PROFIT! <br><br>  You no longer need to write #include "stdafx.h" at the beginning of all * .c / *. Cpp files.  The compiler will do it himself. <br><br><h2>  What to include in stdafx.h </h2><br>  This is a very important point.  Thoughtless inclusion in the ‚Äústdafx.h‚Äù just in a row will not only not speed up the compilation, but, on the contrary, slow it down. <br><br>  All files that include "stdafx.h" depend on its content.  Suppose that the file "Xh" is included in "stdafx.h".  If you change at least something in "Xh", this may entail a complete recompilation of the entire project. <br><br>  <b>Rule</b>  Include in stdafx.h only those files that never change or change VERY rarely.  Good candidates are system header files and third-party libraries. <br><br>  If you include your own files from the project in ‚Äústdafx.h‚Äù, keep double vigilance.  Include only those files that change very, very rarely. <br><br>  If any * .h file changes once a month, it is too often.  As a rule, it is rarely possible to make all edits in the h-file the first time.  It usually takes 2-3 iterations.  Agree, 2-3 times to completely recompile the entire project is an unpleasant task.  Plus full recompilation is required for all your colleagues. <br><br>  Do not get carried away with unchangeable files.  Include only what is often used.  It makes no sense to include &lt;set&gt; if it is needed only in two places.  Where necessary, there connect this header file. <br><br><h2>  Multiple Precompiled Headers </h2><br>  Why in one project may need several precompiled headers?  Indeed, this is not necessary often.  But I will give a couple of examples. <br><br>  In the project, * .c and * .cpp files are used simultaneously.  For them, you can not use a single * .pch file.  The compiler will generate an error. <br><br>  You need to create two * .pch files.  One should be obtained when compiling the C-file (xx.c), and the other when compiling the C ++ file (yy.cpp).  Accordingly, it is necessary to specify in the settings that one precompiled header is used in the C-files, and another one is used in the C ++ files. <br><br>  Note.  Do not forget to specify different names for * .pch files.  Otherwise, one file will grind another. <br><br>  Another situation.  One part of the project uses one large library, and the other part uses another large library. <br><br>  Naturally, it is not worth all parts of the code to know about both libraries.  In (unsuccessful) libraries, the names of some entities may overlap. <br><br>  It is logical to make two precompiled headers and use them in different parts of the program.  As already noted, you can specify arbitrary file names from which * .pch files are generated.  And the name of the * .pch file can also be changed.  All this, of course, needs to be done carefully, but there is nothing difficult to use the two precompiled headers. <br><br><h2>  Typical errors when using Precompiled Headers </h2><br>  After reading carefully the material above, you can understand and eliminate errors related to stdafx.h.  But let's go through the compilation type errors again and analyze their causes.  Repetition is the mother of learning. <br><br><h3>  Fatal error C1083: Cannot open precompiled header file: 'Debug \ project.pch': No such file or directory </h3><br>  You are trying to compile a file that uses a precompiled header.  But the corresponding * .pch file is missing.  Possible reasons: <ol><li>  The stdafx.cpp file was not compiled and, as a result, the * .pch file has not yet been created.  This may be, for example, if you clean the project at the beginning (Clean Solution), and then try to compile one * .cpp file (Compile Ctrl-F7).  Solution: compile the whole project or at least the stdafx.cpp file. </li><li>  In the settings there is not a single file from which the * .pch file should be generated.  This is a compilation key / Yc.  As a rule, this situation occurs in beginners who want to use precompiled headers for their project.  How to do this is described above in the "How to use Precompiled Headers" section. </li></ol><br><h3>  Fatal error C1010: while looking for a precompiled header.  Did you forget to add '#include "stdafx.h"' to your source? </h3><br>  The message speaks for itself if you read it.  The file is compiled with the / Yu.  This means that you should use the precompiled header.  But ‚Äústdafx.h‚Äù is not included in the file. <br><br>  It is necessary to enter in the file #include "stdafx.h". <br><br>  If this is not possible, then you should not use the precompiled header for this * .c / *. Cpp file.  Remove the key / Yu. <br><br><h3>  Fatal error C1853: 'comp.pch' precompiled header of the compiler, or the precompiled header of the compiler </h3><br>  There are both C (* .c) and C ++ (* .cpp) files in the project.  For them, you cannot use a single precompiled header (* .pch file). <br><br>  Possible solutions: <ol><li>  Disable precompiled headers for all C-files.  As practice shows, * .c files are preprocessing several times faster than * .cpp files.  If * .c files are not very many, then by disabling the precompiled headers for them, you will not lose anything </li><li>  Start two precompiled headers.  The first should be created from stdafx_cpp.cpp, stdafx_cpp.h.  The second of stdafx_c.c, stdafx_c.h.  Accordingly, different precompiled headers should be used in * .c and * .cpp files.  The names of the * .pch files naturally should also be different. </li></ol><br><h3>  Due to the precompiled header the compiler is buggy </h3><br>  Most likely, something is done wrong.  For example, #include "stdafx.h" is not located at the very beginning. <br><br>  Consider an example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> int _tmain(int argc, _TCHAR* argv[]) { return A; }</span></span></code> </pre> <br>  This code will not compile.  At first glance, the compiler will generate a strange error message: <br><pre> <code class="cpp hljs">error C2065: <span class="hljs-string"><span class="hljs-string">'A'</span></span> : undeclared identifier</code> </pre> <br>  The compiler thinks that everything up to the line #include "stdafx.h" (inclusive) is the precompiled header.  When compiling a file, the compiler will replace everything before #include "stdafx.h" with text from the * .pch file.  As a result, the line ‚Äúint A = 10‚Äù is lost. <br><br>  The correct option is: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> int A = 10; int _tmain(int argc, _TCHAR* argv[]) { return A; }</span></span></code> </pre> <br>  Another example: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"my.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span></span></code> </pre> <br>  The contents of the file "my.h" will not be used.  As a result, you will not be able to use the functions declared in this file.  This behavior is very confusing for programmers.  They ‚Äúcure‚Äù it by completely disabling the precompiled headers and then telling stories about the glitchiness of Visual C ++.  Remember, the compiler is one of the most rarely buggy tools.  In 99.99% of cases, one should not get angry at the compiler, but look for the error in oneself ( <a href="http://www.viva64.com/ru/b/0161/">Proof</a> ). <br><br>  To avoid such situations, ALWAYS write #include "stdafx.h" at the very beginning of the file.  Comments before #include "stdafx.h" can be left.  They still do not participate in the compilation. <br><br>  Another option is to use Forced Included File.  See the ‚ÄúLife hack‚Äù section above. <br><br><h3>  Because of the precompiled headers, the project is constantly recompiled entirely. </h3><br>  A stdafx.h file is included that is regularly edited.  Or accidentally included auto-generated file. <br><br>  Carefully check the contents of the stdafx.h file.  It should include only header files that do not change or change very rarely.  Note that the included files may not change, but inside they refer to other variable * .h files. <br><br><h3>  Something incomprehensible going on </h3><br>  Sometimes it may be a situation that you have corrected the code, but the error does not disappear.  The debugger shows incomprehensible things. <br><br>  The reason may be a * .pch file.  Somehow it happened that the compiler does not notice the changes in one of the header files and does not rebuild the * .pch file.  As a result, the old code is substituted.  Perhaps this was due to some failures related to the time of file modification. <br><br>  This is a VERY rare situation.  But it is possible and you need to know about it.  For many years of programming, I have come across it only 2-3 times.  The complete recompilation of the project helps. <br><br><h3>  The project using precompiled headers cannot be verified with PVS-Studio </h3><br>  This is the most common situation with which we are approached in support.  Details are given in the documentation: " <a href="http://www.viva64.com/ru/d/0304/">Troubleshooting during PVS-Studio work</a> ".  Here I will describe the situation briefly. <br><br>  If the solution is compiled, it does not mean that it is properly organized.  Often, one solution contains many projects.  Each project uses its own precompiled headers (there is its own stdafx.h and stdafx.cpp). <br><br>  Problems arise when they start using files from a nearby project.  It is convenient and so often done.  They just forget that it is written in the * .cpp file: #include "stdafx.h". <br><br>  And which stdafx.h picks up is an interesting question.  But once the program is compiled - the programmer is lucky. <br><br>  Unfortunately, it is difficult for us to repeat the behavior that occurs when using the * .pch file.  An ‚Äúhonest‚Äù preprocessor works differently. <br><br>  The fact that the solution, in fact, does not work correctly, can be seen by temporarily disabling the precompiled headers.  A lot of interesting errors can come out right away, and the programmer will be genuinely surprised at how miraculously his project was compiled. <br><br>  For details, I again refer to the documentation.  Plus, if something is still not clear, we will show in support. <br><br><h2>  Conclusion </h2><br>  As you saw, there is nothing difficult in precompiled headers.  All the ‚Äúnumerous compiler glitches‚Äù that a programmer encounters when using them are, in fact, a lack of understanding of the principles of operation.  I hope this article will help eliminate misunderstanding. <br><br>  Precompiled headers are a very useful mechanism to significantly increase the speed of compiling projects. </div><p>Source: <a href="https://habr.com/ru/post/227521/">https://habr.com/ru/post/227521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227511/index.html">Students of the Massachusetts Technology Group gathered to send a time capsule to Mars in 2017</a></li>
<li><a href="../227513/index.html">The Israelis have developed a chip that traps explosives in the air at a distance of up to five meters</a></li>
<li><a href="../227515/index.html">Atmospheric absorption or how to evaluate air pollution</a></li>
<li><a href="../227517/index.html">New rules for the importation of goods from abroad come into force (intermediaries warn users)</a></li>
<li><a href="../227519/index.html">Simple implementation of a user support tool in the SaaS Quickme service</a></li>
<li><a href="../227523/index.html">Human rights activists demand to deprive Iran of the Internet</a></li>
<li><a href="../227527/index.html">Tail wind energy</a></li>
<li><a href="../227529/index.html">Why Vase drowned, and C ++ still afloat</a></li>
<li><a href="../227531/index.html">ElasticSearch - mapping and search without surprises</a></li>
<li><a href="../227533/index.html">Database backup - is it there?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>