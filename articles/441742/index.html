<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ expression categories</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Categories of expressions, such as lvalue and rvalue , relate more to the fundamental theoretical concepts of the C ++ language than to the practical ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ expression categories</h1><div class="post__text post__text-html js-mediator-article"><p>  Categories of expressions, such as <strong>lvalue</strong> and <strong>rvalue</strong> , relate more to the fundamental theoretical concepts of the C ++ language than to the practical aspects of its use.  For this reason, many even experienced programmers are rather vaguely aware of what they mean.  In this article I will try to explain as simply as possible the meaning of these terms, diluting theory with practical examples.  Immediately make a reservation: the article does not pretend to the most complete and rigorous description of categories of expressions, for details I recommend to contact directly to the source: C ++ language standard. </p><a name="habracut"></a><br><blockquote>  The article will have quite a lot of English-language terms, due to the fact that some of them are difficult to translate into Russian, while others are translated in different sources in different ways.  Therefore, I will often indicate English terms <em>in italics</em> . </blockquote><br><h2 id="nemnogo-istorii">  A bit of history </h2><br><p>  The terms <strong>lvalue</strong> and <strong>rvalue</strong> appeared in the C language. It is worth noting that the confusion was inherent in the terminology initially, because they refer to expressions, and not to values.  Historically, a <strong>lvalue</strong> is something that can be left ( <em>left</em> ) of an assignment operator, and <strong>rvalue</strong> is something that can only be right ( <em>right</em> ). </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  However, such a definition somewhat simplifies and distorts the essence.  The C89 standard defined <strong>lvalue</strong> as an <em>object locator</em> , i.e.  an object with an identifiable memory location.  Accordingly, everything that did not fit this definition was included in the <strong>rvalue</strong> category. </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn rushes to the rescue </h2><br><p>  In C ++, the terminology of categories of expressions has evolved quite strongly, especially after the adoption of C ++ Standard 11, where the concepts of <strong>rvalue</strong> links and <em>move semantics</em> were introduced.  The history of the emergence of new terminology is interestingly described in the Straustrup article <a href="http://www.stroustrup.com/terminology.pdf">‚ÄúNew‚Äù Value Terminology</a> . </p><br><p>  The basis of a new, more rigorous terminology was formed by 2 properties: </p><br><ul><li>  the presence of identity ( <em>identity</em> ) - that is, some parameter by which one can understand whether two expressions refer to the same entity or not (for example, an address in memory); </li><li>  <em>can be moved from</em> ‚Äî supports move semantics. </li></ul><br><p>  <strong>Identical</strong> expressions are generalized under the term <strong>glvalue</strong> ( <em>generalized values</em> ), the expressions being moved are called <strong>rvalue</strong> .  Combinations of these two properties defined 3 main categories of expressions: </p><br><table><thead><tr><th></th><th>  Have identity </th><th>  Deprived of identity </th></tr></thead><tbody><tr><td>  <strong>Cannot be moved</strong> </td><td>  lvalue </td><td>  - </td></tr><tr><td>  <strong>Can be moved</strong> </td><td>  xvalue </td><td>  prvalue </td></tr></tbody></table><br><p>  In fact, in the C ++ Standard 17, the concept of <em>copy elision appeared</em> - the formalization of situations when the compiler can and should avoid copying and moving objects.  In this regard, the <strong>prvalue may</strong> not necessarily be moved.  Details and examples of this can be found <a href="https://medium.com/%40barryrevzin/value-categories-in-c-17-f56ae54bccbe">here</a> .  However, this does not affect the understanding of the general pattern of categories of expressions. </p><br><p>  In the modern C ++ Standard, the category structure is given in the form of the following scheme: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="image"></p><br><p>  Let us examine in general terms the properties of categories, as well as language expressions that fall into each of the categories.  Immediately, I note that the following lists of expressions for each category cannot be considered complete, for more precise and detailed information, refer directly to the C ++ Standard. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  <strong>Glvalue</strong> expressions have the following properties: </p><br><ul><li>  can be implicitly converted to a <strong>prvalue</strong> ; </li><li>  they can be polymorphic, i.e. the concepts of static and dynamic type make sense for them; </li><li>  cannot have the <strong>void</strong> type - this directly follows from the identity presence property, because for expressions of the <strong>void</strong> type there is no such parameter that would allow to distinguish them from one another; </li><li>  may be incomplete type, for example, in the form of a <em>forward declaration</em> (if this is permitted for a specific expression). </li></ul><br><h2 id="rvalue">  rvalue </h2><br><p>  Expressions in the <strong>rvalue</strong> category have the following properties: </p><br><ul><li>  you cannot get the address of the <strong>rvalue</strong> in memory - this directly follows from the property of lack of identity; </li><li>  cannot be on the left side of an assignment or compound assignment operator; </li><li>  can be used to initialize a constant <strong>lvalue</strong> link or <strong>rvalue</strong> link, while the object's lifetime extends to the link's lifetime; </li><li>  if used as an argument when calling a function that has 2 overloaded versions: one accepts the constant <strong>lvalue</strong> link, and the other <strong>rvalue</strong> link, then the version that accepts the <strong>rvalue</strong> link is selected.  This property is used in the implementation of <em>move semantics semantics</em> : </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Technically, A &amp;&amp; is an <strong>rvalue</strong> and can be used to initialize both the constant <strong>lvalue</strong> reference and the <strong>rvalue</strong> reference.  But thanks to this property, there is no ambiguity; a variant of the constructor is chosen that accepts an <strong>rvalue</strong> link. </blockquote><br><h2 id="lvalue">  lvalue </h2><br><p>  Properties: </p><br><ul><li>  all properties are <strong>glvalue</strong> (see above); </li><li>  you can take the address (using the built-in unary operator <code>&amp;</code> ); </li><li>  modifiable lvalues ‚Äã‚Äãcan be on the left side of an assignment statement or compound assignment statements; </li><li>  can be used to initialize a reference to an <strong>lvalue</strong> (both constant and non-constant). </li></ul><br><p>  The <strong>lvalue</strong> category includes the following expressions: </p><br><ul><li>  the name of a variable, function, or field of a class of any type.  Even if the variable is an <strong>rvalue</strong> reference, the name of this variable in the expression is <strong>lvalue</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  a call to a function or an overloaded operator that returns an <strong>lvalue</strong> link, or a conversion expression of the type <strong>lvalue</strong> link; </li><li>  built-in assignment operators, compound assignment operators ( <code>=</code> , <code>+=</code> , <code>/=</code> , etc.), built-in pre-increment and pre-decrement ( <code>++a</code> , - <code>--b</code> ), built-in pointer dereference operator ( <code>*p</code> ); </li><li>  the built-in index operator ( <code>a[n]</code> or <code>n[a]</code> ), when one of the operands is an <strong>lvalue</strong> array; </li><li>  a call to a function or an overloaded statement that returns an <strong>rvalue</strong> link to the function; </li><li>  string literal, for example <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  A string literal differs from all other literals in C ++ by the fact that it is an <strong>lvalue</strong> (albeit immutable).  For example, you can get his address: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;‚ÄùHello, world!‚Äù; //   ,   </code> </pre> <br><h2 id="prvalue">  prvalue </h2><br><p>  Properties: </p><br><ul><li>  all <strong>rvalue</strong> properties (see above); </li><li>  can not be polymorphic: static and dynamic types of expressions are always the same; </li><li>  cannot be of an incomplete type (except for the <strong>void</strong> type, this will be discussed below); </li><li>  cannot have an abstract type or be an array of elements of an abstract type. </li></ul><br><p>  The <strong>prvalue</strong> category includes the following expressions: </p><br><ul><li>  literal (except string), for example <code>42</code> , <code>true</code> or <code>nullptr</code> ; </li><li>  a call to a function or overloaded operator that returns a non-reference ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) or a conversion expression to a non-reference type (for example, <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  embedded postincrement and postdecrement ( <code>a++</code> , <code>b--</code> ), embedded mathematical operations ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> , etc.), embedded logic operations ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> , and so on), comparison operations ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> , etc.), the built-in operation of taking the address ( <code>&amp;a</code> ); </li><li>  pointer <strong>this</strong> ; </li><li>  enumeration item; </li><li>  non-standard template parameter if it is not a class; </li><li>  A lambda expression, for example <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> . </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Properties: </p><br><ul><li>  all <strong>rvalue</strong> properties (see above); </li><li>  all properties are <strong>glvalue</strong> (see above). </li></ul><br><p>  Examples of <strong>xvalue</strong> category <strong>expressions</strong> : </p><br><ul><li>  a call to a function or a built-in operator that returns an <strong>rvalue</strong> link, for example, <em>std :: move (x)</em> ; </li></ul><br><blockquote>  indeed, for the result of a call to <em>std :: move (),</em> you cannot get an address in memory or initialize a link to it, but at the same time, this expression can be polymorphic: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  ‚ÄúXB::f()‚Äù</code> </pre> <br><ul><li>  the built-in index operator ( <code>a[n]</code> or <code>n[a]</code> ), when one of the operands is an <strong>rvalue</strong> array. </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Some special cases </h2><br><h3 id="operator-zapyataya">  Operator comma </h3><br><p>  For the inline comma operator, the category of the expression always matches the category of the second operand. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Void type expressions </h2><br><p>  Calls to functions that return <strong>void</strong> , type-casting expressions to <strong>void</strong> , and throwing exceptions ( <em>throw</em> ) are considered to be expressions of the <strong>prvalue</strong> category, but they cannot be used to initialize references or as function arguments. </p><br><h2 id="ternarnyy-operator-sravneniya">  Ternary comparison operator </h2><br><p>  Definition of the category of <code>a ? b : c</code>  <code>a ? b : c</code> is a non-trivial case, it all depends on the categories of the second and third arguments ( <code>b</code> and <code>c</code> ): </p><br><ul><li>  if <code>b</code> or <code>c</code> are of type <strong>void</strong> , then the category and type of the whole expression correspond to the category and type of another argument.  If both arguments are of type <strong>void</strong> , then the result is a <strong>prvalue of</strong> type <strong>void</strong> ; </li><li>  if <code>b</code> and <code>c</code> are <strong>glvalues ‚Äã‚Äãof the</strong> same type, then the result is a <strong>glvalue of</strong> the same type; </li><li>  in other cases, the result is a prvalue. </li></ul><br><p>  For the ternary operator, a number of rules are defined, according to which implicit conversions can be applied to the arguments b and c, but this is somewhat beyond the topic of the article, and I <strong><em>am interested in referring</em></strong> to the section Standard <strong><em>Conditional operator [expr.cond]</em></strong> . </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  References to fields and methods of classes and structures </h2><br><p>  For expressions of the form <code>am</code> and <code>p-&gt;m</code> (here we are talking about the built-in operator <code>-&gt;</code> ), the following rules apply: </p><br><ul><li>  if <code>m</code> is an element of an enumeration or a non-static method of a class, then the whole expression is considered a <strong>prvalue</strong> (although the link cannot be initialized with such an expression); </li><li>  if <code>a</code> is <strong>rvalue</strong> and <code>m</code> is a non-static field of non-reference type, then the whole expression belongs to the category <strong>xvalue</strong> ; </li><li>  otherwise it is a <strong>lvalue</strong> . </li></ul><br><p>  For pointers to class members ( <code>a.*mp</code> and <code>p-&gt;*mp</code> ), the rules are similar: </p><br><ul><li>  if <code>mp</code> is a pointer to a class method, then the whole expression is considered to be <strong>prvalue</strong> ; </li><li>  if <code>a</code> is an <strong>rvalue</strong> and <code>mp</code> is a pointer to a data field, then the whole expression refers to <strong>xvalue</strong> ; </li><li>  otherwise it is a <strong>lvalue</strong> . </li></ul><br><h2 id="bitovye-polya">  Bit fields </h2><br><p>  Bit fields are a convenient tool for low-level programming, however, their implementation falls somewhat out of the general structure of categories of expressions.  For example, a reference to a bit field seems to be an <strong>lvalue</strong> , <strong>since it</strong> may be present on the left side of an assignment operator.  At the same time, it is not possible to take the address of the bit field or initialize a non-constant link.  You can initialize a constant reference to a bit field, but a temporary copy of the object will be created: </p><br><blockquote>  <strong><em>Bit-fields [class.bit]</em></strong> <br>  <em>If the initializer is used for a reference, it is subject to</em>  <em>the link is not directly bound to the bit field directly.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Instead of conclusion </h2><br><p>  As I mentioned in the introduction, this description does not claim to be complete, but merely gives a general idea of ‚Äã‚Äãthe categories of expressions.  This representation will allow a little better understanding of the Standard paragraphs and the compiler error messages. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/441742/">https://habr.com/ru/post/441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441728/index.html">Summing up the online contest on the game Blotto</a></li>
<li><a href="../441730/index.html">Entanglion - Haskell among the desktops</a></li>
<li><a href="../441732/index.html">Notes Biorobot</a></li>
<li><a href="../441736/index.html">Automate the conversion of word files to other formats</a></li>
<li><a href="../441738/index.html">Thermal Acoustics Basics</a></li>
<li><a href="../441750/index.html">Projects at CodeFest: how can a manager survive in a continuously changing world?</a></li>
<li><a href="../441752/index.html">ZTE has shown a smartphone watch Œ±</a></li>
<li><a href="../441754/index.html">Kubernetes success stories in production. Part 10: Reddit</a></li>
<li><a href="../441756/index.html">For the Russian industrial PC platform took the processors "Baikal-T1" and OS "Alt"</a></li>
<li><a href="../441758/index.html">Eye operations ‚Äúin a dream‚Äù - to sleep or not to sleep - that is the question</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>