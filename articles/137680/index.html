<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparing Objects in C # .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C # .NET offers many ways to compare objects, both instances of classes and structures. There are so many ways that without streamlining these methods...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparing Objects in C # .NET</h1><div class="post__text post__text-html js-mediator-article">  C # .NET offers many ways to compare objects, both instances of classes and structures.  There are so many ways that without streamlining these methods and understanding their proper use and implementation (if it is possible to redefine), inevitably, porridge is formed. <br><a name="habracut"></a><br>  So, the System.Object class offers the following methods: <br><ul><li><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReferenceEquals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> objA, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> objB</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objA == objB; }</code> </pre> <br></li><li><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> objA, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> objB</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> objA == objB || (objA != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; objB != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; objA.Equals(objB)); }</code> </pre><br></li><li><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RuntimeHelpers.Equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, obj); }</code> </pre><br></li></ul><br>  And of course: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (Foo left, Foo right);</code> </pre> <br>  It is also possible to inherit IEquatable, IStructuralEquatable. <br><br><h5>  ReferenceEquals </h5><br>  The ReferenceEquals method compares two links.  If object references are identical, then returns true.  This means that this method checks instances not for equality, but for identities.  In the case of passing to this method instances of a meaningful type (even if you pass the same instance) will always return false.  This will happen because during the transfer there will be a packaging of significant types and references to them will be different. <br>  Here I would also like to mention the comparison of two lines by this method.  For example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> a = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> b = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(a,b)) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Same objects"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Not the same objects"</span></span>); Console.ReadLine(); } }</code> </pre><br>  Such a program can easily display "Same objects".  Do not worry, this is due to the internment of strings.  But this is a completely different story and there will be no talk about this here. <br><br><h5>  public static bool Equals (object objA, object objB) </h5><br>  First, this method checks instances for identities, and if the objects are not identical, then checks them for null and delegates responsibility for comparing to the redefined instance method Equals. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  public virtual bool Equals (object obj) </h5><br>  By default, this method behaves exactly the same as ReferenceEquals.  However, for significant types it is redefined and in System.ValueType looks like this: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } RuntimeType runtimeType = (RuntimeType)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetType(); RuntimeType left = (RuntimeType)obj.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left != runtimeType) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ValueType.CanCompareBits(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ValueType.FastEqualsCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, obj); } FieldInfo[] fields = runtimeType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; fields.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj2 = ((RtFieldInfo)fields[i]).InternalGetValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj3 = ((RtFieldInfo)fields[i]).InternalGetValue(obj, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj3 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!obj2.Equals(obj3)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  God forbid anyone to use such implementation on large sets.  BCL developers cannot know which significant types we will determine and compare instances of significant types by their fields, using reflection, without knowing anything about these fields in advance.  Of course, this is not a very productive way to compare.  Therefore, when using the significant types known at the compilation stage, it is necessary to redefine this method, because who can know better than you how to compare two objects you have developed?  For reference types, without the need to compare two instances in the manner of significant types, it is not necessary to override this method. <br>  Let's look at an example of a competent redefinition of this method and immediately implement IEquatable: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Vehicle</span></span>:<span class="hljs-title"><span class="hljs-title">IEquatable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Vehicle</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vehicle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vehicle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = speed; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     . //    null  other,  other.GetType()   //NullReferenceException. if (other == null) return false; //        ,    . if (object.ReferenceEquals(this, other)) return true; //          ,    // Vehicle tmp = other as Vehicle; if(tmp==null) return false; //   ,     tmp. if (this.GetType() != other.GetType()) return false; return this.Equals(other as Vehicle); } public bool Equals(Vehicle other) { if (other == null) return false; //    . //  ,            - // . if (object.ReferenceEquals(this, other)) return true; //   ,         , //           . if (this.GetType() != other.GetType()) return false; if (string.Compare(this.Name, other.Name, StringComparison.CurrentCulture) == 0 &amp;&amp; this.speed.Equals(other.speed)) return true; else return false; } }</span></span></code> </pre><br>  A comment about the top of the hierarchy in the redefinition of the virtual method is not just made.  If you create a successor of the Vehicle class (for example, Bike), which will also have the overridden virtual method Equals, in which there will be no type comparison by GetType, but there will be an attempt to cast the type <code>Bike tmp = other as Bike; if(tmp!=null) this.Equals(tmp);</code> <code>Bike tmp = other as Bike; if(tmp!=null) this.Equals(tmp);</code>  in this case, the following code may cause problems: <br><pre> <code class="cs hljs">Vehicle vehicle = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vehicle(); Bike bike = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bike(); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> vehicleObj = vehicle; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> bikeObject = bike; bike.Equals(vehicleObj); <span class="hljs-comment"><span class="hljs-comment">//      .  ,   //    </span></span></code> </pre><br><br><h5>  public static bool operator == (foo left, foo right) </h5><br>  For meaningful types, you should always redefine as virtual Equals ().  For reference types, it is better not to override, for, by default, behavior from == on reference types is expected to behave as in the ReferenceEquals () method.  So, everything is simple. <br><br><h5>  Istructuralequatable </h5><br>  IStructuralEquatable goes hand in hand with the IEqualityComparer interface.  The IStructuralEquatable interface is implemented by classes such as System.Array or System.Tuple.  As Bill Wagner writes, IStructuralEquality declares that a type can constitute larger objects that implement the semantics of significant types and hardly ever need to implement it ourselves.  Although what is difficult in its implementation?  Just look at its implementation in System.Array: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> other, IEqualityComparer comparer) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Array array = other <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || array.Length != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetValue(i); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> value2 = array.GetValue(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!comparer.Equals(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, value2)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Actually, first the identity of objects is checked, then they are reduced to the same type and compared in length.  If the length is equal, then an element-by-element comparison starts by delegating responsibility for this comparison to the interface (IEqualityComparer) Equals method. <br><br>  Here, in essence, is all that can be said about comparing objects in C # .NET, but one more small but important detail remains: the GetHashCode () method. <br><br><h5>  public virtual int GetHashCode () </h5><br>  In general, the standard implementation of this method behaves as a unique identifier generator.  The disadvantage of this approach is that identical semantically objects can return different hash values.  Richter complains that the standard implementation is also low-performing.  Competent implementation of this method is very problematic.  It is necessary to calculate hash quickly and have a large scatter in the result so that repetitions on large enough sets do not happen.  In fact, in most cases, the implementation of GetHashCode () is very simple.  Everywhere shifts are made, ‚Äúbitwise or‚Äù, or ‚Äúexclusive or‚Äù.  Richter himself gives an example with a structure that has two fields of type int.  GetHashCode () it offers to implement something like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Point</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a ^ b; } }</code> </pre><br>  And this is how GetHasCode () is overridden in System.Char: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> | (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  Many examples can be cited and heuristic indicators are used almost everywhere for shifts that exclude or so on. <br><br>  While writing the article, well-known sources were used: <br>  <a href="http://www.amazon.com/CLR-via-C-Jeffrey-Richter/dp/0735627045/ref%3Dntt_at_ep_dpt_1">J. Richter, CLR via C #</a> <br>  <a href="http://www.amazon.com/Effective-Covers-4-0-Specific-Development/dp/0321658701/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1328457799%26sr%3D8-1">B. Wagner Effective C #</a> <br>  It also used its experience and sources on the Internet, which does not make much sense. <br><br><br>  Translation <a href="http://engineerspock.com/2016/04/02/objects-equality-in-c/">here</a> </div><p>Source: <a href="https://habr.com/ru/post/137680/">https://habr.com/ru/post/137680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137672/index.html">Handling all exceptions in controllers using an attribute</a></li>
<li><a href="../137673/index.html">Satellite speedometer on STM32F1 and FreeRTOS</a></li>
<li><a href="../137674/index.html">7app chart # 10</a></li>
<li><a href="../137677/index.html">Python sqlite3: Finding slow queries</a></li>
<li><a href="../137679/index.html">Windows v Enikey</a></li>
<li><a href="../137681/index.html">Hello world on ESB Toolkit</a></li>
<li><a href="../137682/index.html">Javascript Prefix Trees</a></li>
<li><a href="../137684/index.html">D-Link PowerLine: DHP-306AV Review</a></li>
<li><a href="../137685/index.html">The potential of the subscription base for the Internet entrepreneur and common mistakes when working to increase the subscription base</a></li>
<li><a href="../137686/index.html">Why online consultant does not make money, but only spoils my site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>