<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Make all the symbols of the Linux kernel available. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The state of affairs 
 This discussion relates to the kernel of the Linux operating system, and is of interest to developers of kernel modules and dri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Make all the symbols of the Linux kernel available. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h1>  The state of affairs </h1><br>  This discussion relates to the kernel of the Linux operating system, and is of interest to developers of kernel modules and drivers for this operating system.  For all others, these notes are hardly of interest. <br><a name="habracut"></a><br>  Everyone who wrote his simplest Linux kernel module knows, and it is written in all existing books on the technique of writing Linux drivers, that only names (mainly core API functions) that are exported by the kernel can be used in the module's own code.  This is one of the most confusing notions from the Linux kernel area ‚Äî exporting kernel symbols.  In order for a name from the kernel space to be available for binding in another module, two conditions must be met for this name: a).  the name must have a global scope (in your module such names should not be declared static) and b).  the name must be explicitly declared exportable, it must be explicitly written with the EXPORT_SYMBOL macro parameter (or EXPORT_SYMBOL_GPL, which is not the same by its consequences). <br><br>  All names known in the kernel are dynamically displayed in the / proc / kallsyms pseudo-file, and their number is huge: <br><br><pre><code class="bash hljs">$ uname -r 3.13.0-37-generic $ cat /proc/kallsyms | wc -l 108960</code> </pre> <br>  The number of names exported by the kernel (provided for use in the program code of the modules) is much smaller: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">$ cat /lib/modules/`uname -r`/build/Module.symvers | wc -l 17533</code> </pre><br>  It is easy to see that several hundred thousand names are defined in the kernel (depending on the version of the kernel).  But only a small part (about 10%) of these names are declared as exported, and are available for use (binding) in the code of kernel modules. <br><br>  Recall that the kernel API calls are made at the absolute location address of the name.  Each exported kernel (or any module) name is associated with an address, and it is used to bind when loading a module using this name.  This is the main mechanism of interaction of the module with the kernel.  When the system is executed, the module is dynamically loaded and becomes an integral part of the kernel code.  This explains the fact that a kernel module in Linux can only be compiled for a specific kernel (usually at the installation location), and an attempt to load such a binary module with another kernel will lead to the crash of the operating system. <br><br>  As a result of this brief excursion, we can formulate that the Linux kernel developers provide for developers of extensions (kernel modules) a very limited (and extremely poorly documented) set of APIs, which, in their opinion, is sufficient for writing kernel extensions.  But this opinion may not coincide with the opinion of the driver developers themselves, who would like to have the entire kernel arsenal in their hands.  And it is quite possible to use it, which we will discuss in the rest of the text. <br><br><h1>  Address search by name </h1><br>  Let's take a look at the structure of the line-entry of any (out of 108960) kernel names in / proc / kallsyms: <br><br><pre> <code class="dos hljs">$ sudo cat /proc/kallsyms | grep ' T ' | grep sys_close c1176ff0 T sys_close</code> </pre><br>  This is the exported name of the system call handler (POSIX) close ().  (In some Linux distributions, the addresses in the line will be filled only if they are read as root, for other users a zero value will be shown in the address field.) <br><br>  We could well use the sys_close () function call in the code of our module.  But we cannot do this with the sys_open () call, which is perfectly symmetrical to it, because this name is not exported by the kernel.  When building such a module, we get a warning like the following: <br><br><pre> <code class="dos hljs">$ make ... MODPOST <span class="hljs-number"><span class="hljs-number">2</span></span> modules WARNING: "sys_open" [/home/olej/<span class="hljs-number"><span class="hljs-number">2011</span></span>_WORK/LINUX-books/examples.DRAFT/sys_call_table/md_0o.ko] undefined! ...</code> </pre><br>  But an attempt to load such a module will fail: <br><br><pre> <code class="dos hljs">$ sudo insmod md_0o.ko insmod: error inserting 'md_0o.ko': -<span class="hljs-number"><span class="hljs-number">1</span></span> Unknown symbol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> module $ dmesg md_0o: Unknown symbol sys_open</code> </pre><br>  Such a module cannot be loaded, because it contradicts the kernel integrity rules: it contains an unresolved external symbol ‚Äî this symbol is not exported by the kernel for binding (that is, a warning from the compiler‚Äôs point of view looks like a critical error from the developer‚Äôs point of view). <br><br>  Does the one shown above mean that only exported kernel symbols are available in the code of our module.  No, it only means that the recommended way to bind by name (at the absolute address of the name) applies only to exported names.  Exporting provides another additional line of control to ensure the integrity of the kernel ‚Äî minimal impropriety leads to a complete crash of the operating system, sometimes it does not even have time to make the message: Oops ... <br><br>  Once all kernel symbols are displayed in the / proc / kallsyms pseudo-file, the module code could take them from there.  Moreover, this means that the kernel API has methods for localizing all names, and these methods can be used in your code for the same purpose.  Omitting the intermediate solutions path, consider only 2 options, 2 exported calls (all definitions in the &lt;linux / kallsyms.h&gt; in the kernel, or see <a href="">lxr.free-electrons.com/source/include/linux/kallsyms.h</a> ): <br><br>  Call: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kallsyms_lookup_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name )</span></span></span></span>;</code> </pre><br>  Here name is the name we are looking for, and its absolute address is returned.  The disadvantage of this option is that it appears in the kernel somewhere between the 2.6.32 and 2.6.35 kernel versions (or approximately between the distribution packs of the summer 2010 and spring 2011 editions), or rather, it was present before, but was not exported.  For embedded and small systems, this can be a serious obstacle. <br><br>  More general challenge: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kallsyms_on_each_symbol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*fn)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data )</span></span></span></span>;</code> </pre><br>  This challenge is more difficult, and brief explanations are needed here.  The first parameter (fn) it receives a pointer to your user function, which will be sequentially (in a loop) called for all characters in the kernel table, and the second (data) is a pointer to an arbitrary block of data (parameters) that will be passed to each call This function fn (). <br><br>  The prototype of the user-defined function fn, which is cyclically called for each name: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *symb, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *mod, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr )</span></span></span></span>;</code> </pre><br>  Here: <br>  data is a block of parameters, filled in the calling unit, and transferred from the call to the kallsyms_on_each_symbol () function (2nd call parameter), as described above, here, just and it is good to transfer the name of the character that we are looking for; <br>  symb is a symbolic image (string) of a name from the kernel name table, which is processed on the current func call; <br>  mod - the kernel module to which the symbol being processed belongs; <br>  addr - the address of the character in the address space of the kernel (this, in fact, is what we are looking for); <br><br>  The iteration of the kernel table names can be interrupted at the current step and no longer continue (for efficiency reasons, if we have already processed the characters we need), if the user function func returns a nonzero value. <br><br>  To use the kallsyms_on_each_symbol () call, we will prepare our own wrapper function, similar in meaning to kallsyms_lookup_name (): <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_sym</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sym )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// find address kernel symbol sym static unsigned long faddr = 0; // static !!! // ----------- nested functions are a GCC extension --------- int symb_fn( void* data, const char* sym, struct module* mod, unsigned long addr ) { if( 0 == strcmp( (char*)data, sym ) ) { faddr = addr; return 1; } else return 0; }; // -------------------------------------------------------- kallsyms_on_each_symbol( symb_fn, (void*)sym ); return (void*)faddr; }</span></span></code> </pre><br>  Here we used the trick with the embedded definition of the function symb_fn (), which is a completely legal use of the GCC compiler extension (relative to the C standard), but we only use GCC to compile kernel modules.  This code avoids the declaration of a global intermediate variable, prevents clogging of the namespace and contributes to the localization of the code. <br><br><h1>  Usage example </h1><br>  One of the most sacred places in the Linux operating system is the sys_call_table selector table, through which any system call takes place: having prepared the parameters in advance, writing the number (selector) of the system call with the 1st parameter, the system executes the transition command into the kernel: int 80h ( older versions) or sysenter, which is essentially the same thing.  The system call number (selector, 1st parameter) is the index in the sys_call_table table (array) of pointers to the core call handling functions.  We can look at the numbers of all system calls, for example, for the i386 architecture: <br><br><pre> <code class="bash hljs">$ cat /usr/include/i386-linux-gnu/asm/unistd_32.h ... <span class="hljs-comment"><span class="hljs-comment">#define __NR_restart_syscall 0 #define __NR_exit 1 #define __NR_fork 2 #define __NR_read 3 #define __NR_write 4 #define __NR_open 5 #define __NR_close 6 #define __NR_waitpid 7 #define __NR_creat 8 ...</span></span></code> </pre><br>  Here is a table of system call indexes (numbers) used in the user's address space, implemented by the standard C library libc.so.  The exact analogue of this table is also present in the kernel header files, in the address space of the kernel.  And similar tables of indexes of system calls are present for all architectures supported by Linux (tables for different architectures differ in dimension, composition, and numerical values ‚Äã‚Äãof indices for similar calls!). <br><br>  Starting with version 2.6 of the kernel, the sys_call_table symbol was excluded from being exported, proceeding from the considerations of security that were very peculiarly understood by the kernel development team (I can assume that security was supposed to be interpreted in the sense of: security of a piece of bread by kernel developers from third-party programmers).  All books on writing Linux drivers state that it is impossible to use sys_call_table in driver code.  Now, and even more in the subsequent parts of the discussion, we will show that it is not so! <br><br>  For quite a long time (since 2011), working with the topics under discussion, I read a lot of publications on this subject.  Virus writers and any other trash scaring themselves with a scary word hacker, which they didn‚Äôt invent to search for sys_cal_table - even dynamically decoded dumps of binary memory fragments occupied by the kernel, doing a scan of the kernel‚Äôs memory sections (looking for, for example, sys_close () positions that are exported is always).  As will be shown now, all this is done much easier.  The only Linux resilience secret is not.  that the dirty tricks can't find something there, but the fact that the regulation of access rights does not allow (without root rights) to do any nasty things outside of this regulation ... and no one gives root rights to dirty tricks. <br><br>  But back to the task of resolving non-exported kernel symbols.  The first option (the mod_kct.c file) demonstrates the use of kallsyms_lookup_name () (for simplicity and shortening, the inclusion of header files is not shown, the necessary macros like MODULE _ * () ... - all this is in the archive files): <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">int</span></span> __init ksys_call_tbl_init( <span class="hljs-type"><span class="hljs-type">void</span></span> ) { <span class="hljs-type"><span class="hljs-type">void</span></span>** sct = (<span class="hljs-type"><span class="hljs-type">void</span></span>**)kallsyms_lookup_name( "sys_call_table" ); printk( "+ sys_call_table address = %p\n", sct ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sct ) { <span class="hljs-type"><span class="hljs-type">int</span></span> i; <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[ <span class="hljs-number"><span class="hljs-number">120</span></span> ] = "sys_call_table : "; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++ ) sprintf( <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> + strlen( <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ), "%p ", sct[ i ] ); printk( "+ %s ...\n", <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPERM; } module_init( ksys_call_tbl_init );</code> </pre><br>  Here, the address of the sys_call_table table and then the addresses of the handlers of the first 10 system calls (__NR_restart_syscall ... __NR_link) contained in it are extracted: <br><br><pre> <code class="bash hljs">$ sudo insmod mod_kct.ko insmod: ERROR: could not insert module mod_kct.ko: Operation not permitted $ dmesg | tail -n 2 [39473.496040] + sys_call_table address = c1666140 [39473.496045] + sys_call_table : c1067840 c1059280 c1055eb0 c1179ee0 c1179f70 c1178cb0 c1176ff0 c1059570 c1178d10 c1188860 ...</code> </pre><br>  (The error 'Operation not permitted' should not be embarrassing - we didn‚Äôt intend to load the module, which is indicated by a non-zero return code -EPERM, we simply execute our code in the privileged mode, supervisor, zero processor protection ring). <br><br>  Let us make sure what the addresses found correspond to the beginning of the sys_call_table array correspond to: <br><br><pre> <code class="bash hljs">$ sudo cat /proc/kallsyms | grep c1067840 c1067840 T sys_restart_syscall $ sudo cat /proc/kallsyms | grep c1059280 c1059280 T SyS_exit c1059280 T sys_exit $ sudo cat /proc/kallsyms | grep c1055eb0 c1055eb0 T sys_fork</code> </pre><br>  ... and so on (compare with the table of system call numbers shown earlier). <br><br>  The next option will be a little harder to understand, it uses the kallsyms_on_each_symbol () function, but it is also more universal (mod_koes.c file): <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">int</span></span> __init ksys_call_tbl_init( <span class="hljs-type"><span class="hljs-type">void</span></span> ) { <span class="hljs-type"><span class="hljs-type">void</span></span> **sct = find_sym( "sys_call_table" ); // <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sys_call_table address printk( "+ sys_call_table address = %p\n", sct ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sct != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) { <span class="hljs-type"><span class="hljs-type">int</span></span> i; <span class="hljs-type"><span class="hljs-type">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>[ <span class="hljs-number"><span class="hljs-number">120</span></span> ] = "sys_call_table : "; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++ ) sprintf( <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> + strlen( <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ), "%p ", sct[ i ] ); printk( "+ %s ...\n", <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPERM; } module_init( ksys_call_tbl_init );</code> </pre><br>  Textually, it almost completely repeats the previous one; all productive work is performed by the find_sym () function, which is presented and discussed above.  The result of the execution is always the same: <br><br><pre> <code class="bash hljs">$ sudo insmod mod_koes.ko insmod: ERROR: could not insert module mod_koes.ko: Operation not permitted $ dmesg | tail -n2 [42451.186648] + sys_call_table address = c1666140 [42451.186654] + sys_call_table : c1067840 c1059280 c1055eb0 c1179ee0 c1179f70 c1178cb0 c1176ff0 c1059570 c1178d10 c1188860 ...</code> </pre><br><br><h1>  Discussion </h1><br>  A skeptic may say: "So what?".  And the fact that the necessary and sufficient mechanisms are shown in order to use any kernel API in the actual code of the kernel modules loaded dynamically.  The shown technique expands the range of possibilities of the author of the kernel module by orders of magnitude!  These are so voluminous prospects that for their consideration we will need the following parts of this discussion. <br><br>  ... but so that the end of the story is not so boring, we will show one of the simple but impressive applications - the execution of the system call code (generally speaking, any) of the user library from the code of the kernel module. <br><br>  Have you been told that the kernel module code outputs to the system log (printk ()) and cannot output to the terminal (printf ())?  Now we will show that this is not so ... Here is such a simple kernel module that outputs to the terminal: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> asmlinkage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*sys_write)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __user *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wr_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[ <span class="hljs-number"><span class="hljs-number">80</span></span> ] = <span class="hljs-string"><span class="hljs-string">"Hello from kernel!\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( buf ), n; sys_write = find_sym( <span class="hljs-string"><span class="hljs-string">"sys_write"</span></span> ); printk( <span class="hljs-string"><span class="hljs-string">"+ sys_write address = %p\n"</span></span>, sys_write ); printk( <span class="hljs-string"><span class="hljs-string">"+ [%d]: %s"</span></span>, len, buf ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sys_write != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">mm_segment_t</span></span> fs = get_fs(); set_fs( get_ds() ); n = sys_write( <span class="hljs-number"><span class="hljs-number">1</span></span>, buf, len ); set_fs( fs ); printk( <span class="hljs-string"><span class="hljs-string">"+ printf() return : %d\n"</span></span>, n ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPERM; } module_init( wr_init );</code> </pre><br>  And here is its execution (attempt to boot with the emergency exit code): <br><br><pre> <code class="dos hljs">$ sudo insmod mod_wrc.ko Hello from kernel! insmod: ERROR: could <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> insert module mod_wrc.ko: Operation <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> permitted $ dmesg | tail -n3 [<span class="hljs-number"><span class="hljs-number">23942</span></span>.<span class="hljs-number"><span class="hljs-number">974587</span></span>] + sys_write address = c1179f70 [<span class="hljs-number"><span class="hljs-number">23942</span></span>.<span class="hljs-number"><span class="hljs-number">974591</span></span>] + [<span class="hljs-number"><span class="hljs-number">19</span></span>]: Hello from kernel! [<span class="hljs-number"><span class="hljs-number">23942</span></span>.<span class="hljs-number"><span class="hljs-number">974612</span></span>] + printf() return : <span class="hljs-number"><span class="hljs-number">19</span></span></code> </pre><br>  The first line here is derived from the write () system call.  Naturally, the output is made to the controlling terminal of the insmod user process, but here it is important that we execute the write () system call from the kernel space code.  Here some details may require additional explanations: <br><br>  Where did I get such a ‚Äúcunning‚Äù prototype of the description of the address variable sys_write?  Of course, I unscrupulously copied it from the original definition of the sys_write () function in the kernel, in the header file &lt;linux / syscalls.h&gt;, which is indicated by the comment in the code (in the full code, in the archive): <br><br><pre> <code class="hljs vbscript">/* &lt;linux/syscalls.h&gt; asmlinkage long sys_write( unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> fd, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char __user *buf, size_t count ); */</code> </pre><br>  And only this way should be done for all used non-exported kernel names - writing off the prototypes of the implementing functions from the corresponding header files.  Any minimal mismatch of the prototype will lead to an immediate crash of the operating system! <br><br>  What do several similar calls of the form mean: get_ds (), get_fs (), set_fs ()?  This is a small trick in temporarily replacing data segments in the kernel.  The fact is that in the prototype of the sys_write () system call handler there is a __user qualifier, indicating that the pointer points to data in user space.  The system call code checks for ownership (only the range of the numerical value of the address), and if the address points to an area of ‚Äã‚Äãkernel space (as in our case) it will cause an abnormal termination.  With this trick, we show the control code that our address should be interpreted as belonging to user space.  In such cases, this trick can be used mechanically, without particularly thinking about its meaning. <br><br><h1>  Notes </h1><br>  Experiments with similar codes, and even more so in more detailed cases that I intend to discuss later, are fraught with troubles - even minor errors in the code instantly flood the operating system.  Even worse, the system collapses in an unstable, unstable state, and there is a finite (not high) probability that the system will not recover even after a reboot. <br><br>  During experiments with similar codes all the time I was interested in the question: is it possible to work out and test them in a virtual machine?  For all that, we will have to perform (later) very machine-dependent things, such as writing to the hidden hardware registers of the processor, for example CR0. <br><br>  I can state with satisfaction that all the discussed codes are adequately executed in virtual machines in the Oracle VirtualBox environment, at least in relatively recent versions, starting from the 2013 state. <br><br>  Therefore, I strongly recommend working with such codes initially in virtual machines in order to avoid serious trouble. <br>  The mention of Oracle VirtualBox does not mean that this state of affairs will not be saved in other virtual machine managers, I just did not check the codes in these managers (almost certainly everything will be fine in QEMU / KVM, since VirtualBox borrows the virtualization code from QEMU). <br><br>  The archive of files (codes) for experiments, which is mentioned in the text, can be found <a href="https://yadi.sk/d/1I4q9M61jFZGC">here</a> or <a href="https://drive.google.com/open%3Fid%3D0B__cqmYoRw_6SC1XSEQtMXJ1dEk">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/267535/">https://habr.com/ru/post/267535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267519/index.html">Adaptive video as a background site caps</a></li>
<li><a href="../267523/index.html">Setting up sending email notifications in Zabbix on CentOS 7</a></li>
<li><a href="../267525/index.html">From Euroset to game design or 5 beginner's mistakes</a></li>
<li><a href="../267527/index.html">Revolution on the threshold or another niche for "people in the subject"?</a></li>
<li><a href="../267533/index.html">Brotli - Google's new web data compression algorithm</a></li>
<li><a href="../267537/index.html">Registration for the SQLSaturday conference on October 17 is open</a></li>
<li><a href="../267539/index.html">Speech Recognition with CMU Sphinx</a></li>
<li><a href="../267541/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 7. ‚ÄúMax Vision‚Äù</a></li>
<li><a href="../267543/index.html">Moscow Python Meetup at Rambler & Co</a></li>
<li><a href="../267547/index.html">The company D-Link mistakenly published the secret keys for signing firmware</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>