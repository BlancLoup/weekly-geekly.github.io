<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservices - MIF on C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About three years ago, I had the idea of ‚Äã‚Äãcreating a small framework for developing small services that could somehow interact with each other, provi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservices - MIF on C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/7ce/1fb/996/7ce1fb99603d4d6195b4b9e9f9a5f7fb.png" align="right">  About three years ago, I had the idea of ‚Äã‚Äãcreating a small framework for developing small services that could somehow interact with each other, provide an API to the outside, work with databases and a little more.  During the solution of some work tasks, the idea of ‚Äã‚Äãa project close to the solution of work tasks was finally formed.  About a year ago, all this was formed in the <a href="https://github.com/tdv/mif">MIF</a> project <a href="https://github.com/tdv/mif">(MetaInfo Framework)</a> .  It was supposed that with its help it would be possible to solve such tasks as: <br><br><ul><li>  Development of lightweight HTTP services </li><li>  Microservice communication via inter-process interfaces </li><li>  Serialization and deserialization based on the reflection of data structures in different formats </li><li>  Work with databases </li><li>  Some auxiliary components for creating service frameworks </li></ul><br>  All of this is focused on developing backend services for the web, but can be used in other systems. <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  The release of the new standard C ++, the preparation of the following.  Years pass, but there is no reflection in C ++.  The possibility of the appearance of reflection in C ++ was discussed, and it seemed that it would be included in the next standard.  No ... Maybe reflection is not needed?  Maybe ... But there are tasks where it could be useful: interprocess communication (IPC, RPC, REST API, microservices), work with databases (ORM), various (de) serializers, etc.  - In general, there is space for use. <br><br>  The compiler has all the information about the types, and why not to share it with the developers?  I will try to assume that there is just no document on which compiler developers should release this information to honest developers of other software.  Such a document is a C ++ standard, in which the ‚Äúmerging‚Äù regulation will not appear. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In many languages ‚Äã‚Äãthere is reflection.  C ++ is considered a language for software development, where performance is important and, it would seem, one of its applications is web development.  Development of backend services.  In this industry, there are REST APIs, and ORM, and all sorts of serialization into anything (often in json).  To solve these problems, you have to use ready-made libraries or write your own, in which C ++ data is manually linked with other entities, for example, mapping structures in C ++ to json format.  Sometimes using macros adds meta information about the type, which is used later in building the REST API, ORM, etc.  There are even solutions with plugins for the compiler, for example, <a href="http://www.codesynthesis.com/products/odb/">odb</a> . <br><br>  I would like to have something more natural, without code generation by external utilities, cluttering up macros and templates, or manual ‚Äúmapping‚Äù.  This is not yet there, and to solve the above problems, you need to choose one of the above approaches. <br><br>  The proposed solution is based on the addition of meta-information to C ++ types and its subsequent use in solving various problems.  We can say that ‚Äúthe type needs to be shod in meta-information about it‚Äù, after which it will be able to safely step across the boundaries of processes and data centers and be able to present itself in different ways (binary, json, xml, text, etc) with minimal developer intervention. <br><br>  Often, such tasks are solved using code generation, for example, <a href="https://thrift.apache.org/">thrift</a> , <a href="http://www.cs.fsu.edu/~engelen/soap.html">gSOAP</a> , <a href="https://developers.google.com/protocol-buffers/docs/overview">protobuf</a> , etc.  I wanted to get my solution, which will eliminate external code generation, and everything that is necessary will be added to the type at the time of compilation, and at the same time there is a desire to preserve the natural syntax of C ++ language as much as possible without creating a new language in the existing language. <br><br><h1>  MIF in examples </h1><br>  I would like to show some features of the MIF project.  And by feedback on the post, perhaps I will prepare a post about the implementation with all its tediousness, subtleties and explanations why one or another solution was chosen. <br><br>  The tasks listed at the beginning of the post suggest that there will be some possibility to display C ++ data types for serialization, object-oriented interprocess communication, implementation of the REST API, etc.  With this offer and start ... <br><br><h2>  Reflection </h2><br>  Reflection is the basis of the whole project, allowing to solve my applied tasks. <br><br>  An example of how you can get the name of a C ++ data structure, the number of its fields and access one of the fields by its number. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> field2; };</code> </pre> <br>  The solution of the problem could look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Data data; data.field1 = <span class="hljs-number"><span class="hljs-number">100500</span></span>; data.field2 = <span class="hljs-string"><span class="hljs-string">"Text"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Meta = Mif::Reflection::Reflect&lt;Data&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Struct name: "</span></span> &lt;&lt; Meta::Name::GetString() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Field count: "</span></span> &lt;&lt; Meta::Fields::Count &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Field1 value: "</span></span> &lt;&lt; data.field1 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Field2 value: "</span></span> &lt;&lt; data.field2 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Modify fields."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; data.*Meta::Fields::Field&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;::Access() = <span class="hljs-number"><span class="hljs-number">500100</span></span>; data.*Meta::Fields::Field&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::Access() = <span class="hljs-string"><span class="hljs-string">"New Text."</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Field1 value: "</span></span> &lt;&lt; data.field1 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Field2 value: "</span></span> &lt;&lt; data.field2 &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Everything would have been like this, it was written a little differently, but the standard does not make it possible to simply display C ++ data types.  And in order for the code to work, you need to add meta information to the Data structure. <br><br><pre> <code class="cpp hljs">MIF_REFLECT_BEGIN(Data) MIF_REFLECT_FIELD(field1) MIF_REFLECT_FIELD(field2) MIF_REFLECT_END() MIF_REGISTER_REFLECTED_TYPE(Data)</code> </pre><br>  Meta-information about the type could be added to the type itself, expanding it.  I wanted to refuse such a decision in order to be able to display types that cannot be interfered with in the code (types of third-party libraries).  Several macros allow you to add all the necessary information for further work.  There is also the possibility of inheritance, but more on that later ... <br><br><div class="spoiler">  <b class="spoiler_title">Sample code entirely</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// STD #include &lt;iostream&gt; #include &lt;string&gt; // MIF #include &lt;mif/reflection/reflect_type.h&gt; #include &lt;mif/reflection/reflection.h&gt; struct Data { int field1 = 0; std::string field2; }; MIF_REFLECT_BEGIN(Data) MIF_REFLECT_FIELD(field1) MIF_REFLECT_FIELD(field2) MIF_REFLECT_END() MIF_REGISTER_REFLECTED_TYPE(Data) int main() { Data data; data.field1 = 100500; data.field2 = "Text"; using Meta = Mif::Reflection::Reflect&lt;Data&gt;; std::cout &lt;&lt; "Struct name: " &lt;&lt; Meta::Name::GetString() &lt;&lt; std::endl; std::cout &lt;&lt; "Field count: " &lt;&lt; Meta::Fields::Count &lt;&lt; std::endl; std::cout &lt;&lt; "Field1 value: " &lt;&lt; data.field1 &lt;&lt; std::endl; std::cout &lt;&lt; "Field2 value: " &lt;&lt; data.field2 &lt;&lt; std::endl; std::cout &lt;&lt; "Modify fields." &lt;&lt; std::endl; data.*Meta::Fields::Field&lt;0&gt;::Access() = 500100; data.*Meta::Fields::Field&lt;1&gt;::Access() = "New Text."; std::cout &lt;&lt; "Field1 value: " &lt;&lt; data.field1 &lt;&lt; std::endl; std::cout &lt;&lt; "Field2 value: " &lt;&lt; data.field2 &lt;&lt; std::endl; return 0; }</span></span></code> </pre></div></div><br>  A slightly complicated example: try to write a generalized code of output to the console of all fields of the structure and its basic structures. <br><br><div class="spoiler">  <b class="spoiler_title">Structure traversal example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// STD #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;type_traits&gt; // MIF #include &lt;mif/reflection/reflect_type.h&gt; #include &lt;mif/reflection/reflection.h&gt; #include &lt;mif/serialization/traits.h&gt; struct Base1 { int field1 = 0; bool field2 = false; }; struct Base2 { std::string field3; }; struct Nested { int field = 0; }; struct Data : Base1, Base2 { int field4 = 0; std::string field5; std::map&lt;std::string, Nested&gt; field6; }; MIF_REFLECT_BEGIN(Base1) MIF_REFLECT_FIELD(field1) MIF_REFLECT_FIELD(field2) MIF_REFLECT_END() MIF_REFLECT_BEGIN(Base2) MIF_REFLECT_FIELD(field3) MIF_REFLECT_END() MIF_REFLECT_BEGIN(Nested) MIF_REFLECT_FIELD(field) MIF_REFLECT_END() MIF_REFLECT_BEGIN(Data, Base1, Base2) MIF_REFLECT_FIELD(field4) MIF_REFLECT_FIELD(field5) MIF_REFLECT_FIELD(field6) MIF_REFLECT_END() MIF_REGISTER_REFLECTED_TYPE(Base1) MIF_REGISTER_REFLECTED_TYPE(Base2) MIF_REGISTER_REFLECTED_TYPE(Nested) MIF_REGISTER_REFLECTED_TYPE(Data) class Printer final { public: template &lt;typename T&gt; static typename std::enable_if&lt;Mif::Reflection::IsReflectable&lt;T&gt;(), void&gt;::type Print(T const &amp;data) { using Meta = Mif::Reflection::Reflect&lt;T&gt;; using Base = typename Meta::Base; PrintBase&lt;0, std::tuple_size&lt;Base&gt;::value, Base&gt;(data); std::cout &lt;&lt; "Struct name: " &lt;&lt; Meta::Name::GetString() &lt;&lt; std::endl; Print&lt;0, Meta::Fields::Count&gt;(data); } template &lt;typename T&gt; static typename std::enable_if &lt; !Mif::Reflection::IsReflectable&lt;T&gt;() &amp;&amp; !Mif::Serialization::Traits::IsIterable&lt;T&gt;(), void &gt;::type Print(T const &amp;data) { std::cout &lt;&lt; data &lt;&lt; std::boolalpha &lt;&lt; std::endl; } template &lt;typename T&gt; static typename std::enable_if &lt; !Mif::Reflection::IsReflectable&lt;T&gt;() &amp;&amp; Mif::Serialization::Traits::IsIterable&lt;T&gt;(), void &gt;::type Print(T const &amp;data) { for (auto const &amp;i : data) Print(i); } private: template &lt;std::size_t I, std::size_t N, typename T&gt; static typename std::enable_if&lt;I != N, void&gt;::type Print(T const &amp;data) { using Meta = Mif::Reflection::Reflect&lt;T&gt;; using Field = typename Meta::Fields::template Field&lt;I&gt;; std::cout &lt;&lt; Field::Name::GetString() &lt;&lt; " = "; Print(data.*Field::Access()); Print&lt;I + 1, N&gt;(data); } template &lt;std::size_t I, std::size_t N, typename T&gt; static typename std::enable_if&lt;I == N, void&gt;::type Print(T const &amp;) { } template &lt;typename K, typename V&gt; static void Print(std::pair&lt;K, V&gt; const &amp;p) { Print(p.first); Print(p.second); } template &lt;std::size_t I, std::size_t N, typename B, typename T&gt; static typename std::enable_if&lt;I != N, void&gt;::type PrintBase(T const &amp;data) { using Type = typename std::tuple_element&lt;I, B&gt;::type; Print(static_cast&lt;Type const &amp;&gt;(data)); PrintBase&lt;I + 1, N, B&gt;(data); } template &lt;std::size_t I, std::size_t N, typename B, typename T&gt; static typename std::enable_if&lt;I == N, void&gt;::type PrintBase(T const &amp;) { } }; int main() { Data data; data.field1 = 1; data.field2 = true; data.field3 = "Text"; data.field4 = 100; data.field5 = "String"; data.field6["key1"].field = 100; data.field6["key2"].field = 200; Printer::Print(data); return 0; }</span></span></code> </pre></div></div><br>  <b>Result</b> <br><br><pre> <code class="bash hljs">Struct name: Base1 field1 = 1 field2 = <span class="hljs-literal"><span class="hljs-literal">true</span></span> Struct name: Base2 field3 = Text Struct name: Data field4 = 100 field5 = String field6 = key1 Struct name: Nested field = 100 key2 Struct name: Nested field = 200</code> </pre><br>  An example is a prototype for a full serializer, because  based on the added meta information, it serializes the structure into a stream (in the example, to standard output stream).  To determine whether a type is a container, use a function from the Serialization namespace.  In this namespace are assembled ready-made serializers in json and boost.archives (xml, text, binary).  They are built according to the principle close to the one given in the example.  If there is no need to extend the framework with its serializer, then there is no need to write such code. <br><br>  Instead of using the Printer class, you can use a ready serializer, for example, in json, and the amount of code will be greatly reduced. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mif/reflection/reflect_type.h&gt; #include &lt;mif/serialization/json.h&gt; // Data and meta int main() { Data data; // Fill data auto const buffer = Mif::Serialization::Json::Serialize(data); //   json std::cout &lt;&lt; buffer.data() &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Work result</b> <div class="spoiler_text"><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"Base1"</span></span> : { <span class="hljs-string"><span class="hljs-string">"field1"</span></span> : 1, <span class="hljs-string"><span class="hljs-string">"field2"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"Base2"</span></span> : { <span class="hljs-string"><span class="hljs-string">"field3"</span></span> : <span class="hljs-string"><span class="hljs-string">"Text"</span></span> }, <span class="hljs-string"><span class="hljs-string">"field4"</span></span> : 100, <span class="hljs-string"><span class="hljs-string">"field5"</span></span> : <span class="hljs-string"><span class="hljs-string">"String"</span></span>, <span class="hljs-string"><span class="hljs-string">"field6"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-string"><span class="hljs-string">"key1"</span></span>, <span class="hljs-string"><span class="hljs-string">"val"</span></span> : { <span class="hljs-string"><span class="hljs-string">"field"</span></span> : 100 } }, { <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-string"><span class="hljs-string">"key2"</span></span>, <span class="hljs-string"><span class="hljs-string">"val"</span></span> : { <span class="hljs-string"><span class="hljs-string">"field"</span></span> : 200 } } ] }</code> </pre></div></div><br>  For variety, you can try to use serialization boost.archives in xml format. <br><br><div class="spoiler">  <b class="spoiler_title">Serialization in xml using boost.archives</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// BOOST #include &lt;boost/archive/xml_oarchive.hpp&gt; // MIF #include &lt;mif/reflection/reflect_type.h&gt; #include &lt;mif/serialization/boost.h&gt; // Data and meta int main() { Data data; // Fill data boost::archive::xml_oarchive archive{std::cout}; archive &lt;&lt; boost::serialization::make_nvp("data", data); return 0; }</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Work result</b> <div class="spoiler_text"><pre> <code class="bash hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span> standalone=<span class="hljs-string"><span class="hljs-string">"yes"</span></span> ?&gt; &lt;!DOCTYPE boost_serialization&gt; &lt;boost_serialization signature=<span class="hljs-string"><span class="hljs-string">"serialization::archive"</span></span> version=<span class="hljs-string"><span class="hljs-string">"14"</span></span>&gt; &lt;data class_id=<span class="hljs-string"><span class="hljs-string">"0"</span></span> tracking_level=<span class="hljs-string"><span class="hljs-string">"0"</span></span> version=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;Base1 class_id=<span class="hljs-string"><span class="hljs-string">"1"</span></span> tracking_level=<span class="hljs-string"><span class="hljs-string">"0"</span></span> version=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;field1&gt;1&lt;/field1&gt; &lt;field2&gt;1&lt;/field2&gt; &lt;/Base1&gt; &lt;Base2 class_id=<span class="hljs-string"><span class="hljs-string">"2"</span></span> tracking_level=<span class="hljs-string"><span class="hljs-string">"0"</span></span> version=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;field3&gt;Text&lt;/field3&gt; &lt;/Base2&gt; &lt;field4&gt;100&lt;/field4&gt; &lt;field5&gt;String&lt;/field5&gt; &lt;field6 class_id=<span class="hljs-string"><span class="hljs-string">"3"</span></span> tracking_level=<span class="hljs-string"><span class="hljs-string">"0"</span></span> version=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;count&gt;2&lt;/count&gt; &lt;item_version&gt;0&lt;/item_version&gt; &lt;item class_id=<span class="hljs-string"><span class="hljs-string">"4"</span></span> tracking_level=<span class="hljs-string"><span class="hljs-string">"0"</span></span> version=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;first&gt;key1&lt;/first&gt; &lt;second class_id=<span class="hljs-string"><span class="hljs-string">"5"</span></span> tracking_level=<span class="hljs-string"><span class="hljs-string">"0"</span></span> version=<span class="hljs-string"><span class="hljs-string">"0"</span></span>&gt; &lt;field&gt;100&lt;/field&gt; &lt;/second&gt; &lt;/item&gt; &lt;item&gt; &lt;first&gt;key2&lt;/first&gt; &lt;second&gt; &lt;field&gt;200&lt;/field&gt; &lt;/second&gt; &lt;/item&gt; &lt;/field6&gt; &lt;/data&gt; &lt;/boost_serialization&gt;</code> </pre></div></div><br>  From the example it can be seen that, apart from calling a specific serializer, nothing changes.  The same metainformation is used.  It will also be used in other places when implementing interprocess communication. <br><br>  Serialization and deserializers of several formats are implemented in the frame.  And if necessary, you can add support for the new format using the example of the Printer class or using the (de) serializer of json format using the proposed API to bypass the C ++ data structures.  There are some restrictions on the types (where without them), but more on that later. <br><br>  Next, I propose to move on to more interesting things - the implementation of interprocess communication based on interfaces transferred between processes (C ++ data structures with purely virtual methods). <br><br><h2>  Interprocess communication </h2><br>  What started the project MIF - is the implementation of interprocess communication.  It was a primary need.  At one of the first implementations of this mechanism, one of the services was developed, which at the time of writing these lines of the post has worked steadily for more than six months without crashing and reloading. <br><br>  There was a need to make communication services, located on multiple machines, using interfaces.  I wanted to work with services as if they were all in the same process. <br><br>  The example shows how close it was to get closer to the desired result. <br><br>  <b>Objective: to</b> develop a server and client to exchange information about employees of a fictional company. <br><br>  The solution of such problems is reduced to several steps of the same type. <br><br><ul><li>  Identify the interface (s) for component interaction </li><li>  Define custom data structures (if necessary) for method parameters or as return values </li><li>  Add meta information </li><li>  Implement server application </li><li>  Implement the client application </li></ul><br>  <a href="https://github.com/tdv/mif/tree/master/examples/complex_type">Example complex_type</a> <br><br><h3>  a common part </h3><br>  <b>Data structures</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// data.h namespace Service { namespace Data { using ID = std::string; struct Human { std::string name; std::string lastName; std::uint32_t age = 0; }; enum class Position { Unknown, Developer, Manager }; struct Employee : public Human { Position position = Position::Unknown; }; using Employees = std::map&lt;ID, Employee&gt;; } // namespace Data } // namespace Service</span></span></code> </pre><br>  <b>Meta-information</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// meta/data.h namespace Service { namespace Data { namespace Meta { using namespace ::Service::Data; MIF_REFLECT_BEGIN(Human) MIF_REFLECT_FIELD(name) MIF_REFLECT_FIELD(lastName) MIF_REFLECT_FIELD(age) MIF_REFLECT_END() MIF_REFLECT_BEGIN(Position) MIF_REFLECT_FIELD(Unknown) MIF_REFLECT_FIELD(Developer) MIF_REFLECT_FIELD(Manager) MIF_REFLECT_END() MIF_REFLECT_BEGIN(Employee, Human) MIF_REFLECT_FIELD(position) MIF_REFLECT_END() } // namespace Meta } // namespace Data } // namespace Service MIF_REGISTER_REFLECTED_TYPE(::Service::Data::Meta::Human) MIF_REGISTER_REFLECTED_TYPE(::Service::Data::Meta::Position) MIF_REGISTER_REFLECTED_TYPE(::Service::Data::Meta::Employee)</span></span></code> </pre><br>  <b>Interface</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// imy_company.h namespace Service { struct IMyCompany : public Mif::Service::Inherit&lt;Mif::Service::IService&gt; { virtual Data::ID AddEmployee(Data::Employee const &amp;employee) = 0; virtual void RemoveAccount(Data::ID const &amp;id) = 0; virtual Data::Employees GetEmployees() const = 0; }; } // namespace Service</span></span></code> </pre><br>  <b>Meta-information</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ps/imy_company.h namespace Service { namespace Meta { using namespace ::Service; MIF_REMOTE_PS_BEGIN(IMyCompany) MIF_REMOTE_METHOD(AddEmployee) MIF_REMOTE_METHOD(RemoveAccount) MIF_REMOTE_METHOD(GetEmployees) MIF_REMOTE_PS_END() } // namespace Meta } // namespace Service MIF_REMOTE_REGISTER_PS(Service::Meta::IMyCompany)</span></span></code> </pre><br>  The definition of the data structure and the addition of meta-information to it are the same as in the reflection examples, except that everything is separated by namespaces. <br><br>  Interface definition is the definition of a C ++ data structure containing only pure virtual methods. <br><br>  For interfaces, there was another wish - the ability to request from one interface the others contained in the implementation, and, possibly, not connected into a single hierarchy.  Therefore, the interface being defined must always inherit Mif :: Service :: IService or any other that inherits from Mif :: Service :: IService.  There is multiple inheritance.  Inheritance is done through the intermediate entity Mif :: Service :: Inherit.  This is a template with a variable number of parameters.  Its parameters are inherited interfaces or implementations ( <a href="https://github.com/tdv/mif/tree/master/examples/inheritance">inheritance</a> ).  This is necessary for the implementation of the interface request mechanism that is the same as dynamic_cast, but operating outside the boundaries of the process. <br><br>  Adding meta information to an interface is not much different from adding meta information to data structures.  This is another, but similar, set of macros.  Perhaps later, everything will be reduced to a single set of macros for defining data structures and interfaces.  While they are different.  This happened during the development of the project. <br><br>  When adding meta information to the interface, you do not need to specify its basic interfaces.  The entire hierarchy will be found at compile time.  Here, the small auxiliary entity Mif :: Service :: Inherit plays its main role in the search for heirs and related meta-information. <br><br>  When adding meta information to interfaces, only the interface and its methods are specified without specifying parameters, return values ‚Äã‚Äãand cv qualifiers.  There was a desire to make adding meta-information to the interfaces in the spirit of minimalism.  The lack of overload has become a pay for minimalism.  I think this is a small price for the opportunity not to list all the parameters and return types of values ‚Äã‚Äãfor each method and not to edit them with minor changes in the interface. <br><br>  Having identified common entities, it remains to implement the server and client applications. <br><br>  Each interface can have multiple implementations.  They somehow need to be distinguished.  When creating an object, you need to explicitly specify the desired implementation.  This requires identifiers of interface implementations and their connection with implementations. <br><br>  For convenience and rejection of the ‚Äúmagic values ‚Äã‚Äãin the code‚Äù, the identifiers of implementations are better placed in one or several header files.  The MIF project uses numbers as an identifier.  In order to somehow give uniqueness while not building any counters or not putting everything into a single enum and being able to logically separate IDs across different files and namespaces, it is proposed to use crc32 from the string as an identifier, with the creation of unique problems the developer should have less. <br><br>  To implement the interface IMyCompany need an identifier <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// id/service.h namespace Service { namespace Id { enum { MyCompany = Mif::Common::Crc32("MyCompany") }; } // namespace Id } // namespace Service</span></span></code> </pre><br><h3>  Server application </h3><br>  <b>IMyCompany implementation</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// service.cpp // MIF #include &lt;mif/common/log.h&gt; #include &lt;mif/reflection/reflection.h&gt; #include &lt;mif/service/creator.h&gt; // COMMON #include "common/id/service.h" #include "common/interface/imy_company.h" #include "common/meta/data.h" namespace Service { namespace Detail { namespace { class MyCompany : public Mif::Service::Inherit&lt;IMyCompany&gt; { public: // ‚Ä¶ private: // ‚Ä¶ // IMyCompany virtual Data::ID AddEmployee(Data::Employee const &amp;employee) override final { // ... } virtual void RemoveAccount(Data::ID const &amp;id) override final { // ... } } virtual Data::Employees GetEmployees() const override final { // ... } }; } // namespace } // namespace Detail } // namespace Service MIF_SERVICE_CREATOR ( ::Service::Id::MyCompany, ::Service::Detail::MyCompany )</span></span></code> </pre><br>  There are several points that I would like to draw attention to: <br><ul><li>  Inheritance in the implementation is also via Mif :: Service :: Inherit.  This is not necessary, but it can be considered a good form and will be useful when implementing several interfaces with the inheritance of a part of previously implemented interfaces. </li><li>  The whole implementation can and, preferably, should be made in one cpp-file, without separation into h and cpp files.  That allows to increase the encapsulation and in large projects to reduce the compilation time due to the fact that all necessary include implementation files are in the implementation file.  When they are modified, a smaller number of dependent cpp-files undergo recompilation. </li><li>  Each implementation has an entry point - MIF_SERVICE_CREATOR, which is a factory implementation.  Parameters are implementation class, identifier and, if necessary, a variable number of parameters passed to the implementation constructor. </li></ul><br>  To complete the server application, it remains to add an entry point - the main function. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// MIF #include &lt;mif/application/tcp_service.h&gt; // COMMON #include "common/id/service.h" #include "common/ps/imy_company.h" class Application : public Mif::Application::TcpService { public: using TcpService::TcpService; private: // Mif.Application.Application virtual void Init(Mif::Service::FactoryPtr factory) override final { factory-&gt;AddClass&lt;::Service::Id::MyCompany&gt;(); } }; int main(int argc, char const **argv) { return Mif::Application::Run&lt;Application&gt;(argc, argv); }</span></span></code> </pre><br>  When creating an entry point, you need to implement your application class ‚Äî a successor from the base application class or from one of the predefined application templates.  In the overridden Init method, you need to add to the factory all existing implementations of the interfaces that the service will export (factory-&gt; AddClass).  In the AddClass method, you can pass parameters to the implementation constructor. <br><br>  The service uses a predefined transport tcp, serialized on the basis of boost.archive in binary format with gzip data compression to exchange information about interfaces, methods, parameters, returned results, exceptions and instances of objects. <br><br>  You can use another type of transport (for example, http, which is also available in MIF or implement your own), serialize and assemble your own unique data processing chain (defining package boundaries, compression, encryption, multi-thread processing, etc.).  To do this, you no longer need to use the application template, but the base application class (Mif :: Application :: Application), determine the necessary parts of the data processing chain or the transport yourself. <br><br>  In the first version of the MIF project, there were no predefined application templates.  The examples did not look so short, but they showed the entire path that needs to be done in order to have complete control over the data processing flow.  The entire chain is shown in the examples of the first version of the project ( <a href="">MIF 1.0</a> ). <br><br><h3>  Client application </h3><br>  On the client side, everything that was defined in the common part is used. <br>  The client is the same framework of the application (in the example the predefined application template is used) in which a remote class / service factory is requested, through which the necessary object is created and its methods are called. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// MIF #include &lt;mif/application/tcp_service_client.h&gt; #include &lt;mif/common/log.h&gt; // COMMON #include "common/id/service.h" #include "common/ps/imy_company.h" class Application : public Mif::Application::TcpServiceClient { public: using TcpServiceClient::TcpServiceClient; private: void ShowEmployees(Service::Data::Employees const &amp;employees) const { // ... } // Mif.Application.TcpServiceClient virtual void Init(Mif::Service::IFactoryPtr factory) override final { auto service = factory-&gt;Create&lt;Service::IMyCompany&gt;(Service::Id::MyCompany); { Service::Data::Employee e; e.name = "Ivan"; e.lastName = "Ivanov"; e.age = 25; e.position = Service::Data::Position::Manager; auto const eId = service-&gt;AddEmployee(e); MIF_LOG(Info) &lt;&lt; "Employee Id: " &lt;&lt; eId; } { Service::Data::Employee e; e.name = "Petr"; e.lastName = "Petrov"; e.age = 30; e.position = Service::Data::Position::Developer; auto const eId = service-&gt;AddEmployee(e); MIF_LOG(Info) &lt;&lt; "Employee Id: " &lt;&lt; eId; } auto const &amp;employees = service-&gt;GetEmployees(); ShowEmployees(employees); if (!employees.empty()) { auto id = std::begin(employees)-&gt;first; service-&gt;RemoveAccount(id); MIF_LOG(Info) &lt;&lt; "Removed account " &lt;&lt; id; auto const &amp;employees = service-&gt;GetEmployees(); ShowEmployees(employees); try { MIF_LOG(Info) &lt;&lt; "Removed again account " &lt;&lt; id; service-&gt;RemoveAccount(id); } catch (std::exception const &amp;e) { MIF_LOG(Warning) &lt;&lt; "Error: " &lt;&lt; e.what(); } } } }; int main(int argc, char const **argv) { return Mif::Application::Run&lt;Application&gt;(argc, argv); }</span></span></code> </pre><br><h3>  Result </h3><br><div class="spoiler">  <b class="spoiler_title">The result of the server application</b> <div class="spoiler_text"><pre> <code class="bash hljs">2017-08-09T14:01:23.404663 [INFO]: Starting network application on 0.0.0.0:55555 2017-08-09T14:01:23.404713 [INFO]: Starting server on 0.0.0.0:55555 2017-08-09T14:01:23.405442 [INFO]: Server is successfully started. 2017-08-09T14:01:23.405463 [INFO]: Network application is successfully started. Press <span class="hljs-string"><span class="hljs-string">'Enter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> quit. 2017-08-09T14:01:29.032171 [INFO]: MyCompany 2017-08-09T14:01:29.041704 [INFO]: AddEmployee. Name: Ivan LastName: Ivanov Age: 25 Position: Manager 2017-08-09T14:01:29.042948 [INFO]: AddEmployee. Name: Petr LastName: Petrov Age: 30 Position: Developer 2017-08-09T14:01:29.043616 [INFO]: GetEmployees. 2017-08-09T14:01:29.043640 [INFO]: Id: 0 Name: Ivan LastName: Ivanov Age: 25 Position: Manager 2017-08-09T14:01:29.043656 [INFO]: Id: 1 Name: Petr LastName: Petrov Age: 30 Position: Developer 2017-08-09T14:01:29.044481 [INFO]: Removed employee account <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Id: 0 Name: Ivan LastName: Ivanov Age: 25 Position: Manager 2017-08-09T14:01:29.045121 [INFO]: GetEmployees. 2017-08-09T14:01:29.045147 [INFO]: Id: 1 Name: Petr LastName: Petrov Age: 30 Position: Developer 2017-08-09T14:01:29.045845 [WARNING]: RemoveAccount. Employee with id 0 not found. 2017-08-09T14:01:29.046652 [INFO]: ~MyCompany 2017-08-09T14:02:05.766072 [INFO]: Stopping network application ... 2017-08-09T14:02:05.766169 [INFO]: Stopping server ... 2017-08-09T14:02:05.767180 [INFO]: Server is successfully stopped. 2017-08-09T14:02:05.767238 [INFO]: Network application is successfully stopped.</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">The result of the client application</b> <div class="spoiler_text"><pre> <code class="bash hljs">2017-08-09T14:01:29.028821 [INFO]: Starting network application on 0.0.0.0:55555 2017-08-09T14:01:29.028885 [INFO]: Starting client on 0.0.0.0:55555 2017-08-09T14:01:29.042510 [INFO]: Employee Id: 0 2017-08-09T14:01:29.043296 [INFO]: Employee Id: 1 2017-08-09T14:01:29.044082 [INFO]: Employee. Id: 0 Name: Ivan LastName: Ivanov Age: 25 Position: Manager 2017-08-09T14:01:29.044111 [INFO]: Employee. Id: 1 Name: Petr LastName: Petrov Age: 30 Position: Developer 2017-08-09T14:01:29.044818 [INFO]: Removed account 0 2017-08-09T14:01:29.045517 [INFO]: Employee. Id: 1 Name: Petr LastName: Petrov Age: 30 Position: Developer 2017-08-09T14:01:29.045544 [INFO]: Removed again account 0 2017-08-09T14:01:29.046357 [WARNING]: Error: [Mif::Remote::Proxy::RemoteCall] Failed to call remote method <span class="hljs-string"><span class="hljs-string">"IMyCompany::RemoveAccount"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance with id <span class="hljs-string"><span class="hljs-string">"411bdde0-f186-402e-a170-4f899311a33d"</span></span>. Error: RemoveAccount. Employee with id 0 not found. 2017-08-09T14:01:29.046949 [INFO]: Client is successfully started. 2017-08-09T14:01:29.047311 [INFO]: Network application is successfully started. Press <span class="hljs-string"><span class="hljs-string">'Enter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> quit. 2017-08-09T14:02:02.901773 [INFO]: Stopping network application ... 2017-08-09T14:02:02.901864 [INFO]: Stopping client ... 2017-08-09T14:02:02.901913 [INFO]: Client is successfully stopped. 2017-08-09T14:02:02.901959 [INFO]: Network application is successfully stopped.</code> </pre></div></div><br>  Yes, exceptions also overcome the boundaries of processes ... <br><br><pre> <code class="bash hljs">[WARNING]: Error: [Mif::Remote::Proxy::RemoteCall] Failed to call remote method <span class="hljs-string"><span class="hljs-string">"IMyCompany::RemoveAccount"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance with id <span class="hljs-string"><span class="hljs-string">"411bdde0-f186-402e-a170-4f899311a33d"</span></span>. Error: RemoveAccount. Employee with id 0 not found.</code> </pre><br>  From the message you can see that the method of deleting information about an employee with identifier 0 was recalled. On the server side, there is already no such record, as indicated by the server with the exception ‚ÄúEmployee with id 0 not found‚Äù / <br><br>  The example demonstrated the interprocess communication of the client with the server, hiding as much as possible all the details related to the transport and the format of the transmitted data. <br><br>  This example completes the presentation of the base underlying the MIF project.  Additional features include <br><br><ul><li>  <a href="https://github.com/tdv/mif/tree/master/examples/inheritance">The ability to request interfaces</a> from an implementation not merged into a single hierarchy (not counting the inheritance from Mif :: Service :: IService). </li><li>  Pass pointers and smart pointers to interfaces between services.  What can be useful for different implementations of services with callbacks. ,    publish/subscribe.       <a href="https://github.com/tdv/mif/tree/master/examples/visitor">visitor</a> ,          tcp. </li></ul><br><h2>  HTTP </h2><br>         TCP -,  HTTP -.         , , curl   . <br><br>  HTTP    ,      web-  - json REST API,           C++ . <br><br>     .     HTTP-      ,  .    HTTP-      publish / subscribe.    ,    HTTP   ¬´-¬ª.       . <br><br>   MIF TCP-    .     ,   .        .  ,        ,      .         publish / subscribe,       <a href="https://github.com/tdv/mif/tree/master/examples/visitor"></a> . <br><br>  MIF HTTP   , ..      backend   .     HTTP -,      HTTP         HTTP        .          web-, ,      web-      . <br><br><h3>  HTTP web- </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// MIF #include &lt;mif/application/http_server.h&gt; #include &lt;mif/common/log.h&gt; #include &lt;mif/net/http/constants.h&gt; class Application : public Mif::Application::HttpServer { public: using HttpServer::HttpServer; private: // Mif.Application.HttpServer virtual void Init(Mif::Net::Http::ServerHandlers &amp;handlers) override final { handlers["/"] = [] (Mif::Net::Http::IInputPack const &amp;request, Mif::Net::Http::IOutputPack &amp;response) { auto data = request.GetData(); MIF_LOG(Info) &lt;&lt; "Process request \"" &lt;&lt; request.GetPath() &lt;&lt; request.GetQuery() &lt;&lt; "\"\t Data: " &lt;&lt; (data.empty() ? std::string{"null"} : std::string{std::begin(data), std::end(data)}); response.SetCode(Mif::Net::Http::Code::Ok); response.SetHeader( Mif::Net::Http::Constants::Header::Connection::GetString(), Mif::Net::Http::Constants::Value::Connection::Close::GetString()); response.SetData(std::move(data)); }; } }; int main(int argc, char const **argv) { return Mif::Application::Run&lt;Application&gt;(argc, argv); }</span></span></code> </pre><br>       <br><br><pre> <code class="bash hljs">curl -iv -X POST <span class="hljs-string"><span class="hljs-string">"http://localhost:55555/"</span></span> -d <span class="hljs-string"><span class="hljs-string">'Test data'</span></span></code> </pre><br>         HTTP -     MIF .   backend  libevent.      ab     160K   .     ¬´¬ª,    ,  ,   ..    -     Python  Go.   Python   2  ,   Go       10%     .  ,   C++   Python  Go     ,        ,    C++,                ‚Ä¶ <br><br><h3> HTTP  </h3><br>     <a href="https://github.com/tdv/mif/blob/master/include/mif/net/">Mif::Net::Http::Connection</a> .   HTTP-  C++   MIF.     ‚Ä¶          MIF-, ,    , , ,  ,    .. <br><br>    -,      : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// STD #include &lt;cstdlib&gt; #include &lt;future&gt; #include &lt;iostream&gt; #include &lt;string&gt; // MIF #include &lt;mif/net/http/connection.h&gt; #include &lt;mif/net/http/constants.h&gt; int main() { try { std::string const host = "localhost"; std::string const port = "55555"; std::string const resource = "/"; std::promise&lt;std::string&gt; promise; auto future = promise.get_future(); Mif::Net::Http::Connection connection{host, port, [&amp;promise] (Mif::Net::Http::IInputPack const &amp;pack) { if (pack.GetCode() == Mif::Net::Http::Code::Ok) { auto const data = pack.GetData(); promise.set_value({std::begin(data), std::end(data)}); } else { promise.set_exception(std::make_exception_ptr( std::runtime_error{ "Failed to get response from server. Error: " + pack.GetReason() })); } } }; auto request = connection.CreateRequest(); request-&gt;SetHeader(Mif::Net::Http::Constants::Header::Connection::GetString(), Mif::Net::Http::Constants::Value::Connection::Close::GetString()); std::string data = "Test data!"; request-&gt;SetData({std::begin(data), std::end(data)}); connection.MakeRequest(Mif::Net::Http::Method::Type::Post, resource, std::move(request)); std::cout &lt;&lt; "Response from server: " &lt;&lt; future.get() &lt;&lt; std::endl; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></code> </pre><br>          .      .    - , ,    curl,            . <br><br><h3> HTTP web-    </h3><br>      HTTP   MIF.    HTTP web-,          curl,    ,   C++           .      Mif::Application::HttpServer,   .       .     github   <a href="http">http</a> . <br><br><h4>  a common part </h4><br>  <b>Interface</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Service { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IAdmin</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Mif::Service::Inherit&lt;Mif::Service::IService&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;title)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;body)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace Service</span></span></code> </pre><br>    ,  - ‚Äî ,      . <br><br><h4>  Server part </h4><br> <b> </b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Mif::Application::HttpServer { <span class="hljs-comment"><span class="hljs-comment">//... private: // Mif.Application.HttpService virtual void Init(Mif::Net::Http::ServerHandlers &amp;handlers) override final { std::string const adminLocation = "/admin"; std::string const viewLocation = "/view"; auto service = Mif::Service::Create&lt;Service::Id::Service&gt;(viewLocation); auto webService = Mif::Service::Cast&lt;Mif::Net::Http::IWebService&gt;(service); auto factory = Mif::Service::Make&lt;Mif::Service::Factory, Mif::Service::Factory&gt;(); factory-&gt;AddInstance(Service::Id::Service, service); std::chrono::microseconds const timeout{10000000}; auto clientFactory = Service::Ipc::MakeClientFactory(timeout, factory); handlers.emplace(adminLocation, Mif::Net::Http::MakeServlet(clientFactory)); handlers.emplace(viewLocation, Mif::Net::Http::MakeWebService(webService)); } };</span></span></code> </pre><br>      ,    ,  : <br><br><ul><li>      </li><li>           </li><li>       </li><li>   :   HTTP , , REST API        C++  </li></ul><br>        Mif::Net::Http::WebService.     .  Since   ,     ,       ,   -         ‚Äî  .        HTTP web-     Mif::Net::Http::MakeServlet. <br><br> <b><i> MIF  - ‚Äî   .  MIF     - ,       HTTP-    . -    .     MIF            .</i></b> <br><br> <b>-</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Service { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Detail { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebService</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Mif::Service::Inherit &lt; IAdmin, Mif::Net::Http::WebService &gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WebService(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;pathPrefix) { AddHandler(pathPrefix + <span class="hljs-string"><span class="hljs-string">"/stat"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;WebService::Stat); AddHandler(pathPrefix + <span class="hljs-string"><span class="hljs-string">"/main-page"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;WebService::MainPage); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ // IAdmin virtual void SetTitle(std::string const &amp;title) override final { // ... } // ‚Ä¶ // Web hadlers Result&lt;Mif::Net::Http::JsonSerializer&gt; Stat() { // ... std::map&lt;std::string, std::int64_t&gt; resp; // Fill resp return resp; } Result&lt;Mif::Net::Http::PlainTextSerializer&gt; MainPage(Prm&lt;std::string, Name("format")&gt; const &amp;format) { // ... } }; } // namespace } // namespace Detail } // namespace Service MIF_SERVICE_CREATOR ( ::Service::Id::Service, ::Service::Detail::WebService, std::string )</span></span></code> </pre><br>       : <br><br><ul><li>      Mif::Service::Inherit   .     Mif::Service::Inherit  .       IAdmin     ,       IWebService     Mif::Net::Http::WebService,     HTTP . </li><li>     .      ,    - Mif::Net::Http::WebService  ,     AddHandler.           ,  <b>/view/stat</b> </li><li>      ,     .         -.          .            . </li><li> -   .      Prm.  Prm   ,  .           Prm.       ,    ,          ( stl , , list, vector, set).   ,   timestamp ,      boost::posix_time.       Content.      .            ,       Headers  /  Params.      .        <a href="http_crud">http_crud</a> </li><li>           MIF_SERVICE_CREATOR   ,       .   MIF_SERVICE_CREATOR  . </li></ul><br>  <b>Customer</b> <br><br>         .       .    .    HTTP  MIF     .  ‚Ä¶  , , -     .    ‚Äî   <a href="http">http</a> . <br><br>  <b>results</b> <br><br>           , ,    curl    <br><br><pre> <code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:55555/view/main-page?format=text"</span></span> curl <span class="hljs-string"><span class="hljs-string">"http://localhost:55555/view/main-page?format=html"</span></span> curl <span class="hljs-string"><span class="hljs-string">"http://localhost:55555/view/main-page?format=json"</span></span></code> </pre><br>     ,              curl .  ,           HTTP  . <br><br><h2>     </h2><br> Backedn  ?  How without them?  ,    ‚Ä¶ <br><br>         MIF     .       .       ,  -     .         ,      ORM,         ,   .  ORM -   .    .    ,   . ,              ORM   , ..      -    ,        ,          SQL-. <br><br>  ORM ,   ‚Ä¶ <br><br>      : <br><br><ul><li>  -   </li><li>  ,    </li><li>   </li><li>  </li></ul><br>    -  ,  JDBC ( Java)  -   C++       . <br><br>   <a href="https://github.com/tdv/mif/tree/master/examples/db_client">db_client</a>     : PostgreSQL  SQLite. <br><br><h2> HTTP CRUD  </h2><br>  <a href="http_crud">http_crud</a>       HTTP   ‚Äî     ,       . <br><br>  web-      CRUD.      .          .       ,     ‚Äî   .           NoSQL         .          .       .  ‚Äî    C++    .                .   ,  ,       . <br><br><h1>  Conclusion </h1><br> ,   : , ,  ,  ,   ,  HTTP ‚Äî          <a href="https://github.com/tdv/mif/tree/master/examples/microservices">  </a> .    ,    ,   .      ,    Json API   .       <a href="http_crud">http_crud</a>     () ,       . <br><br>   MIF,   , , <a href="https://github.com/tdv/mif/tree/master/examples/db_client">db_client</a> ,        .    ( )      .   MIF,   ,      HTTP   .           ,   ,         . ,                 .     ¬´-¬ª.     ,    <a href="https://github.com/tdv/mif/tree/master/examples/visitor">visitor</a> ,              . <br><br>  , ,      ,      ,     , ,  ¬´ ¬ª MIF,      ,    ,    thrift    ,            ..  ,  ¬´home project¬ª ,    ,  ,       ,       ,     . <br><br>  ,     <a href="https://github.com/tdv/mif">MIF on C++</a> . <br><br> <i>  .</i> <br></div><p>Source: <a href="https://habr.com/ru/post/239571/">https://habr.com/ru/post/239571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239555/index.html">Intel¬Æ Parallel Studio XE 2015 - Talk About New Names and "Chips"</a></li>
<li><a href="../239557/index.html">Beetle modeling</a></li>
<li><a href="../239559/index.html">IBM invites to the conference "Infrastructure 2014"</a></li>
<li><a href="../239563/index.html">As 3 people without investment "magic button" for the stores did</a></li>
<li><a href="../239567/index.html">Hacking using search, inattention and my accomplice GitHub</a></li>
<li><a href="../239573/index.html">Automated template for front-end projects</a></li>
<li><a href="../239577/index.html">About the special course in school and whether to force children to learn?</a></li>
<li><a href="../239579/index.html">Customize the Vim start screen</a></li>
<li><a href="../239581/index.html">Lots of free * tools from GitHub for students</a></li>
<li><a href="../239583/index.html">Your own AWS. Part 0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>