<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Chinese video cameras and TCP: a bug or feature?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In connection with the usurpation of the position of the house manager of our MKD, and the need to ‚Äúbrush‚Äù public disorder, we are slowly constructing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Chinese video cameras and TCP: a bug or feature?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/645/147/3bc6451476d7ee36e7bcd4d413590111.jpg" align="right">  In connection with the usurpation of the position of the house manager of our MKD, and the need to ‚Äúbrush‚Äù public disorder, we are slowly constructing a video surveillance system. <br>  Of course, funding is minimal, the plans are ambitious, so everything is collected from pasture. <br>  Details a little later, but one of the interesting bugs, which forced to sort out a lot of things. <br><br>  So, everything started from a small one ‚Äî a simple dome camera; the lousy one was taken on the principle ‚Äú <a href="http://www.aliexpress.com/snapshot/262542561.html">only IP and dome</a> ‚Äù.  After the process of busting the software started (the topic of a separate post, will be, again, later) ... At the end, I fixed onto Macroscop in one channel.  It was a couple of months, I did not ask for a drink, I did not help addicts to drive. <br><br>  And it works like everything, but somehow podlagivaet periodically.  He sinned on everything: on percents, on the network, on the software, on the weather on Mars ... The support for the logs says that the camera periodically falls off. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Upd</b> <br><a name="habracut"></a><br>  Yes, more cameras were purchased, the quality and price are much higher.  Having overcome laziness in three beautiful days in different weeks, it was all mounted on the 1st floor, set up in a computer, connected.  And the second iteration of software brute forceing went, so that the cameras are bigger, more humane, the interface is more convenient ... After the second brute force round, there is AxxonNext for now.  Yes, only the lags have reached a new level: the cameras fall off almost non-synchronously every 5-10 minutes if you enable TCP;  and if you keep UDP, then the artifacts climb like I do not know what. <br><br>  I complained about this topic on the topic, and take <a href="https://habrahabr.ru/users/maxlapshin/" class="user_link">maxlapshin</a> and say that it is a stable bug of the Chinese cameras, where the firmware was created by their own efforts: if the client does not have time to rake out, then garbage climbs into the stream.  Since it was sold on ali, it was decided to try to solve the problem thoroughly.  Several times I tried to describe the bug with different words, but I understood that the English of us both leaves much to be desired, so you just need to ‚Äúshow code‚Äù. <br><br><h3>  The first stage of the excavation: to find the cause </h3><br><br>  So, first we take tcpdump, and wait for the clipping situation.  Wait for long, in 5 minutes I caught as many as 3 pieces.  How to understand what happened?  A stream in one and a half million packages ... For a start we filter, leaving only one camera.  Then Ctrl + F =&gt; tcp.flags.syn == 1 =&gt; find the beginning of the reconnect, from where we scroll up to see what happened ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/cbd/557/033/cbd557033feb0db7418fab4cade55b38.png"></a> <br><br>  We observe that the connection was closed from the side of the computer ... But it‚Äôs just embarrassing that before that Win = 11460, Win = 10200, Win = 8940 - that is, it seems that the client doesn‚Äôt have time.  Stop stop stop.  How does it not have time?  AMD Phenom II X6 1100T?  Not weird.  Io?  So writing to a separate disk, and did not rest on the shelf.  Yes, and then there would be a dependence on viewing, for example - but it is not there ... In general, we leaf through even higher slightly: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/135/224/015/135224015d8c1ab71d55e42bb578022e.png"></a> <br><br>  So literally a second ago, everything went away in ZeroWindow.  Not exactly in time.  But why break something ?!  Scroll below, look at another cliff ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d09/bd3/ecc/d09bd3ecc5cc875136602ed3c60e1551.png"><br><br></a>  <a href="">So, we observe ZeroWindow for as much as 2.5 seconds - it does not climb at all into any gate.</a>  <a href="">Scroll below, and it seems, we begin to understand:</a> <a href=""><br><br></a> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/06e/b70/d03/06eb70d031c41574f3c18f6848ae3f3e.png"></a> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/329/ff4/79b/329ff479b89d69beca38dd93df3c8033.png"></a> <br><br>  We look at the TCP stack (the cameras? Probably ...) did not behave very well, after which the RTP stream lost its way - at one point instead of DynamicRTP-Type-96, RTSP Continuation went. <br><br>  So, we conclude: all that is needed for the simulation is to request the RTP stream, pull it out a little, and then do sleep (), and see if the stream breaks. <br><br><h3>  Search parts for Frankenstein </h3><br><br>  What to do when you need to quickly throw a test piece?  Take a scripting language, a set of ready-made libraries, make it all together, rejoice.  We climb to google.  Python + ONVIF.  Rotten  Ruby + ONVIF.  Oh, there is a <a href="">ruby-onvif-client</a> .  OK, we take.  Stream URL caught.  Great, but if: protocol to twist? .. UDP, HTTP, TCP ... the result is one - excellent, I learned to catch the URL by onvif, now I‚Äôd like to merge it. <br><br>  Curl?  Does not chew.  Okay, Ruby + RTSP ... Hooray, <a href="https://github.com/turboladen/rtsp">there is</a> lib.  We eat him url, and bummer.  Attempts to log in exclusively through Basic.  A little more google.  Bummer.  Then there is one method - a file.  <a href="https://github.com/turboladen/rtsp/commit/5eeb8e74c51b0ccc95bf0190c6c7d4ddf393bd1f">We solder with a hot iron</a> , using the way of swearing at the volumes of the magic of Ruby (who will tell me how to do an "honest" recursion correctly, so that both return and yield work correctly, and how to guess from the function description, what it may be needed? her - and cleaner code, and silky hair). <br><br>  And once again we exult, rtsp_client works.  Open in the second window tcpdump ... Damn!  I requested from ONVIF: protocol =&gt; "TCP".  What the hell, why UDP? <br><br>  A soldering iron in hand ... Ha!  UDP is nailed at lib/rtsp/client.rb@request_transport.  So, solder there with the same nails / TCP.  Run - falls.  Why?  Where?  Yeah, he requires client_port ... What client_port, if it is TCP?  Hardcode rtp_port if it is not in 554. So, the IP is necessary server - hardcode.  Oops, can not, he says, at 'bind ()' it doesn‚Äôt root on port 554.  Is logical.  So, why?  Well ... This is in <a href="">RTP :: Receiver</a> ... We look at the <a href="">init_socket</a> in the mode: TCP and wonder - why does he need a TCPServer for Receiver?  Something wrong.  Obviously, no one debugged it explicitly on TCP. <br><br>  After a couple of minutes of attempts to understand the logic, it turned out to the Sharp-Sighted Eyes that there was no wall: <br><pre> transport: RTP / AVP / TCP; unicast; destination = 172.28.1.199; source = 172.28.1.95; interleaved = 0-1
</pre><br><br>  Well, well ... what interleaved?  Google: rtp interleaved =&gt; <a href="http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">Wikipedia</a> =&gt; Find on page ‚Äúinterleaved‚Äù =&gt; Aha!  So RTP and RTSP fall in the same connection! <br><br>  We throw out the rtsp libu, since for my task to edit either I don‚Äôt want to be frank - here it is obviously necessary to redo the architecture in an amicable way. <br><br><h3>  We grow amoeba </h3><br><br>  So, we are again at zero: we have a rtsp: // url of the camera, there is a need to merge it and play around while merging with the connection ... Stop!  At first.  There is an url.  I have a camera.  There is a task to reproduce a bug on it.  Why do I need ONVIF?  Why RTSP?  You just need to request and download the answer. <br><br>  No sooner said than done.  DESCRIBE?  And why do we need it ... We only need to first SETUP, from where to pick up the Session: then PLAY with it. <br><br>  The very first experience showed that he doesn‚Äôt even need authorization here. <br>  Fine!  The first pancake was fired right away: a <a href="">simple script</a> perfectly reproduced the bug - after sleep (), and the stream broke with a bang. <br><br>  But in order to play around with the TCP Window, you would have to be able to set TCP_WINDOW_CLAMP.  And for this you need to do setsockopt to connect but after creating a socket. <br>  And how to do it in Ruby?  Um ... Looking at Google ... Empty.  Looking at the <a href="">source</a> - init_inetsock_internal ... FIG there!  we first create rsock_socket (), and then immediately rsock_connect ().  Pancake. <br><br>  Okay, I still do not really love chopping.  In 2 minutes we rewrite <a href="https://github.com/datacompboy/chinacambug/blob/master/cambug.py">to python</a> , add setsockopt.  We add the analysis of the RTP packet number. <br><br>  The result of the analysis: from the size of the initial window, the amount of information changes, how much does the camera manage to transmit normal, before it breaks.  However, it does not matter, he commits the result, and wrote a bug report to the seller, so that they give the developers the firmware. <br><br>  It would have calmed down, but <a href="https://habrahabr.ru/users/maxlapshin/" class="user_link">maxlapshin</a> asked whether it was possible to somehow live with this bug.  And this required additional excavations. <br><br><h3>  Basically, how to live with it? </h3><br>  1) You can monitor the failure and reconnect yourself <br>  2) You can track your own lag (I do not know how, but you can) and join immediately, without waiting for the flow to break <br>  3) You can try to restore synchronization with the stream. <br><br>  So, we stick instead of the call of the raise - call reconnect, and analyze the losses by the difference of the RTP packet numbers.  If we act on point 1, then the losses amount to about 1,500‚Äì1,800 RTP packets (approximately 600 packets per second sleep ()). <br><br>  We stick reconnect right after sleep ().  The result is exactly the same. <br><br>  We stick the resynchronization with the search method "$ \ x00" - it works disgustingly.  We stick the resynchronization with the search method "$ \ x00 [LEN] {len bytes} $ \ x00" - it works stably, the loss is one and a half times less than with reconnect.  But the most important thing is that the TCP connection does not fall off, which means that the TCP Window adaptation algorithm and receive buffers continue to work.  As a result, after 1-2 failures at the beginning of the connection, the flow simply stops breaking - sleep () continues to put the client to sleep regularly, and the flow does not fall. <br><br>  The resulting test script <a href="https://github.com/datacompboy/chinacambug/blob/master/cam-resync.py">quality code does not shine</a> , but perfectly performs the function of proof-of-concept. <br><br>  And now, finally, we come to the question asked in the title. <br><br><h3>  Is it a bug or a feature? </h3><br><br>  My personal opinion is really better than breaking the connection entirely: there are connection numbers for RTP packets, so you can measure the lost volume without problems. <br>  If the channel is thinner than the network bandwidth, then losses will grow, thus finding losses for more than 5 seconds - you can safely complain about the channel thickness (reconnect with lower quality, ask for a cable change, blow up nuclear power plants, or any other way of reacting to this problem);  if the problem is that the receiver simply does not have time for some reason to rake - resync behavior = our luck.  We get a combination of the advantages of both UDP and TCP approaches: if something is bad at all, a piece is lost;  in other cases, retransmitters are automatic and do not cause problems. <br><br>  Well, for a snack, let's talk about that for a bug in the firmware ... And the bug is simple: send (somedata, somelen) returns &lt;0 in case of an error, the number of bytes if it worked.  And any mistake of all novice network developers: send (somedata, somelen) can return something LESS than somelen - it did not fit into the buffer. <br><br>  If this is not processed, the tail from somedata is simply lost - it was not sent and thrown away. <br><br><h3>  How to fix? </h3><br><br>  To fix it this way: you have to memorize the unfinished piece, and stop sending anything, until the send () of this remainder sends the whole thing.  After that, you need to start sending _next_ packets (discarding those that were all the time that the buffer was busy).  Then we get the very behavior of the TCP-UDP mix, but without the need for the client to engage in magic resynchronization with packet boundaries. <br><br>  Hopefully, the manufacturers will correct this bug, and after a while, all the Chinese firmware for Chinese cameras will delight you to work correctly without a single break &amp; tm; <br><br><h3>  Source of joy: LIVE555 Jurassic </h3><br><br>  The <a href="https://habrahabr.ru/users/macroscop/" class="user_link">support macroscop</a> drew my stupid inattention to the fact that LIVE555 is being announced in 2011 ... So through binwalk + dd + mount I looked into the giblets of the firmware.  rtsp_streamer and true from 2011. <br>  Looked into the diff between the two versions of live.2013.10.10.09.tar.gz and live.2014.02.19.tar.gz: <br><pre><code class="diff hljs">diff --git a/liveMedia/RTPInterface.cpp b/liveMedia/RTPInterface.cpp index d45e5a8..3d88d55 100644 --- a/liveMedia/RTPInterface.cpp +++ b/liveMedia/RTPInterface.cpp @@ -324,19 +325,23 @@ Boolean RTPInterface::sendRTPorRTCPPacketOverTCP(u_int8_t* packet, unsigned p } Boolean RTPInterface::sendDataOverTCP(int socketNum, u_int8_t const* data, unsigned dataSize, Bool - if (send(socketNum, (char const*)data, dataSize, 0/*flags*/) != (int)dataSize) { - // The TCP send() failed. - - if (forceSendToSucceed &amp;&amp; envir().getErrno() == EAGAIN) { - // The OS's TCP send buffer has filled up (because the stream's bitrate has exceeded the cap + int sendResult = send(socketNum, (char const*)data, dataSize, 0/*flags*/); + if (sendResult &lt; (int)dataSize) { + // The TCP send() failed - at least partially. + + unsigned numBytesSentSoFar = sendResult &lt; 0 ? 0 : (unsigned)sendResult; + if (numBytesSentSoFar &gt; 0 || (forceSendToSucceed &amp;&amp; envir().getErrno() == EAGAIN)) { + // The OS's TCP send buffer has filled up (because the stream's bitrate has exceeded + // the capacity of the TCP connection!). // Force this data write to succeed, by blocking if necessary until it does: + unsigned numBytesRemainingToSend = dataSize - numBytesSentSoFar; #ifdef DEBUG_SEND - fprintf(stderr, "sendDataOverTCP: resending %d-byte send (blocking)\n", dataSize); fflush(st + fprintf(stderr, "sendDataOverTCP: resending %d-byte send (blocking)\n", numBytesRemainingToS #endif makeSocketBlocking(socketNum); - Boolean sendSuccess = send(socketNum, (char const*)data, dataSize, 0/*flags*/) == (int)dataS + sendResult = send(socketNum, (char const*)(&amp;data[numBytesSentSoFar]), numBytesRemainingToSen makeSocketNonBlocking(socketNum); - return sendSuccess; + return sendResult == (int)numBytesRemainingToSend; } return False; }</code> </pre> <br><br>  And here is a clipping from changelog.txt: <br> <code><a href="http://www.en.tpsee.com/"></a> <a href="http://www.mvista.com/product_detail_pro.php"></a> 2013.12.04: <br> - Updated the "sendDataOverTCP()" function (in "RTPInterface.cpp") to allow for the possibility of <br> one of the "send()" calls partially succeeding - ie, writing some, but not all, of its data. <br> - Fixed a couple of minor bugs. (Thanks to "maksqwe1ukr.net".) <br> <br> ?    .     ,     LIVE555 . <br> <br>  ,     -- topsee;        MontaVista.     ,    .</code> </div><p>Source: <a href="https://habr.com/ru/post/213063/">https://habr.com/ru/post/213063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213051/index.html">(Frequencies 5150-5350 and 5650-6425 MHz) Information from the radio frequency center</a></li>
<li><a href="../213053/index.html">Mac Pro: A computer for those who understand why it is needed. And only for them</a></li>
<li><a href="../213055/index.html">Facebook knows who you fell in love with</a></li>
<li><a href="../213057/index.html">Air conditioner controller (fan)</a></li>
<li><a href="../213061/index.html">Prototype. From idea to trial lot</a></li>
<li><a href="../213065/index.html">Typing (defining properties) of an object by the hands of site users</a></li>
<li><a href="../213069/index.html">The risks of AI from LessWrong.com, part 1: an interview with Shane Legge from DeepMind</a></li>
<li><a href="../213071/index.html">Telephony integration in distributed call centers</a></li>
<li><a href="../213073/index.html">Get out of the room</a></li>
<li><a href="../213075/index.html">Backup and Restore Graylog Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>