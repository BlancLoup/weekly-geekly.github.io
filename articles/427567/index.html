<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cards from hexagons in Unity: water cycle, erosion, biomes, cylindrical map</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts 1-3: mesh, cell colors and heights 

 Parts 4-7: bumps, rivers and roads 

 Parts 8-11: water, landforms and walls 

 Parts 12-15: saving and lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cards from hexagons in Unity: water cycle, erosion, biomes, cylindrical map</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habr.com/post/424257/">Parts 1-3: mesh, cell colors and heights</a> <br><br>  <a href="https://habr.com/post/424491/">Parts 4-7: bumps, rivers and roads</a> <br><br>  <a href="https://habr.com/post/425463/">Parts 8-11: water, landforms and walls</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habr.com/post/425919/">Parts 12-15: saving and loading, textures, distances</a> <br><br>  <a href="https://habr.com/post/426481/">Parts 16-19: Pathfinding, Player Squads, Animations</a> <br><br>  <a href="https://habr.com/post/427003/">Parts 20-23: fog of war, map exploration, procedural generation</a> <br><br>  <a href="https://habr.com/post/427567/">Parts 24-27: water cycle, erosion, biomes, cylindrical map</a> <br><br><h1>  Part 24: Regions and Erosion </h1><br><ul><li>  Add a border out of the water around the map. </li><li>  We divide the map into several regions. </li><li>  We use erosion to cut the cliffs. </li><li>  Move the land to smooth relief. </li></ul><br>  In the previous section, we laid the foundation for procedural map generation.  This time we will limit the places of possible land appearance and act on it with erosion. <br><br>  This tutorial was created in Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>We divide and smooth the land.</i> <br><a name="habracut"></a><br><h2>  Map boundary </h2><br>  As we pick up land at random, it may happen that the land touches the edge of the map.  This may not be desirable.  A water-bound card contains a natural barrier that prevents players from approaching the edge.  Therefore, it would be nice if we banned land from rising above the water level near the edge of the map. <br><br><h3>  Border size </h3><br>  How close should the land be to the edge of the map?  There is no right answer to this question, therefore we will make this parameter customizable.  We will add two sliders to the <code>HexMapGenerator</code> component, one for the borders along the edges along the X axis, the other for the borders along the Z axis. So we can use a wider border in one of the dimensions, or even create a border in only one dimension.  Let's use the interval from 0 to 10 with a default value of 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Card sliders.</i> <br><br><h3>  We limit the land centers </h3><br>  Without boundaries, all cells are valid.  When the boundaries are present, the minimum allowable offset coordinates increase, and the maximum allowable coordinates decrease.  Since to generate plots we need to know the allowable interval, let's track it with the help of four integer fields. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Initialize constraints in <code>GenerateMap</code> before creating sushi.  We use these values ‚Äã‚Äãas parameters for <code>Random.Range</code> calls, so the maxima are in fact exceptional.  Without a border, they are equal to the number of measurement cells, therefore, not minus 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); ‚Ä¶ }</code> </pre> <br>  We will not strictly prohibit the appearance of land beyond the edge of the border, because this would create sharply cut edges.  Instead, we will restrict only the cells used to start generating plots.  That is, the approximate centers of the sections will be limited, but parts of the sections will be able to go beyond the border area.  This can be done by changing <code>GetRandomCell</code> so that it selects a cell in the interval of allowable offsets. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>The borders of the map are 0 √ó 0, 5 √ó 5, 10 √ó 10 and 0 √ó 10.</i> <br><br>  When all parameters of the map are set to default values, the border of size 5 will reliably protect the edge of the map from touching the land.  However, this is not guaranteed.  Drying can sometimes come close to the edge, and sometimes touch it in several places. <br><br>  The likelihood that land will cross the entire border depends on the size of the border and the maximum size of the site.  Without hesitation, areas remain hexagons.  Full hexagon with radius <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  contains <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></mn><msup><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn></msup><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></mn><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  cells  If there are hexagons with a radius equal to the size of the border, then they will be able to cross it.  A full hexagon with a radius of 5 contains 91 cells.  Since the default maximum is 100 cells per plot, this means that the land will be able to pave a bridge across 5 cells, especially if there are fluctuations.  To prevent this from happening, either reduce the maximum size of the area or increase the size of the border. <br><br><div class="spoiler">  <b class="spoiler_title">How is the formula for the number of cells in the hexagonal region derived?</b> <div class="spoiler_text">  With a radius of 0, we are dealing with a single cell.  From here it took 1. With a radius of 1 around the center there are six additional cells, i.e. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  These six cells can be considered the ends of six triangles tangent to the center.  With a radius of 2, a second row is added to these triangles, that is, two more cells are obtained on the triangle, and <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  With a radius of 3, a third row is added, that is, three more cells per triangle, and the total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  And so on.  That is, in general terms, the formula looks like <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>u</mi><msub><mi>m</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="73.759ex" height="3.312ex" viewBox="0 -950 31757.4 1426" role="img" focusable="false" aria-hidden="true" style="vertical-align: -1.106ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-75" x="1359" y="0"></use><g transform="translate(1932,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="1242" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-69" x="3185" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-3D" x="3809" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="4865" y="0"></use><g transform="translate(5365,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-69" x="6174" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="6520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="7131" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="8132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-3D" x="8910" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-36" x="9967" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="10467" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="10857" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="11246" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="11698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="12087" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="12761" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="13762" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="14262" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="14652" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2F" x="15041" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-32" x="15542" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="16042" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="16654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="17655" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-3D" x="18433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-33" x="19489" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="19990" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-28" x="20441" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="20831" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="21504" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="22505" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-29" x="23006" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="23617" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="24618" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-3D" x="25396" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-33" x="26453" y="0"></use><g transform="translate(26953,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="28081" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-33" x="29081" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMATHI-72" x="29582" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-2B" x="30256" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/427567/&amp;xid=17259,15700021,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgRh1cGcrim1bxIq1KqDioeXrTfiw#MJMAIN-31" x="31256" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></mi><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></mi><msub><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo></msub><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></mi><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><msup><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi></msup><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mrow class="MJX-TeXAtom-ORD"><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></mo></mrow><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></mn><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></mn><msup><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn></msup><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></mn><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></mi><mo><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></mo><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one</font></font></mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (sum_ (i = 1) ^ r i) +1 = 6 ((r (r + 1)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  To see this more clearly, we can set the border size to 200. Since the full hexagon with a radius of 8 contains 217 cells, the land will most likely touch the edge of the map.  At least, if you use the default border size value (5).  Increasing the boundary to 10 will greatly decrease the probability. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>The land area has a constant size of 200, the boundaries of the map are 5 and 10.</i> <br><br><h3>  Pangea </h3><br>  Note that by increasing the border of the map and maintaining the same percentage of land, we force the land to form a smaller area.  As a result, a large default map is likely to create a single large mass of land ‚Äî the supercontinent Pangea ‚Äî possibly with several small islands.  With an increase in the size of the border, the probability of this increases, and at certain values, we are almost guaranteed to get the supercontinent.  However, when the percentage of land is too large, most of the available areas are filled and as a result we get an almost rectangular mass of land.  To avoid this, you need to reduce the percentage of land. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>40% sushi with border cards 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Where did the name Pangea come from?</b> <div class="spoiler_text">  That was the name of the last known supercontinent that existed on Earth many years ago.  The name is composed of the Greek words pan and Gaia, meaning something like ‚Äúall nature‚Äù or ‚Äúall land‚Äù. </div></div><br><br><h3>  Defending against impossible cards </h3><br>  We generate the right amount of land, simply continuing to raise the land until we reach the desired land mass.  It works, because sooner or later we will raise each cell on the water level.  However, when using the border of the map, we cannot reach every cell.  When a very high percentage of land is required, it will lead to endless "attempts and failures" of the generator to raise more land, and it will get stuck in an endless cycle.  The application will freeze, but this should not happen. <br><br>  We cannot reliably find impossible configurations in advance, but we can protect ourselves from infinite loops.  We will simply track the number of cycles executed in <code>CreateLand</code> .  If there are too many iterations, then we are most likely stuck and should stop. <br><br>  For a large map, a value of a thousand iterations seems acceptable, and ten thousand iterations already seem absurd.  So let's use this value as the end point. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); ‚Ä¶ } }</span></span></code> </pre> <br>  If we get a spoiled map, then performing 10,000 iterations will not take much time, because many cells will quickly reach their maximum height, which will prevent new areas from growing. <br><br>  Even after interrupting the cycle, we still get the right map.  It just does not have the right amount of sushi and it will not look very interesting.  Let's display a notification to the console, informing us of the remaining amount of land we could not spend. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>95% of the land with a border of 10 cards could not spend the entire amount.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Why does a failed card still have variability?</b> <div class="spoiler_text">  The coastline is variable, because when the heights inside the creation area become too high, new areas prevent them from growing outwards.  The same principle does not allow the sites to grow into small areas of land, not yet reached the maximum height and just disappeared.  In addition, the variability increases with lowering plots. </div></div><br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-24/map-border/map-border.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Splitting the card into parts </h2><br>  Now that we have a map boundary, we essentially divided the map into two separate regions: the region of the border and the region of creation of the plots.  Since only the region of creation is important for us, we can consider such a situation as a situation with one region.  The region simply does not cover the entire map.  But if this is not possible, then nothing prevents us from dividing the map into several unconnected regions of land creation.  This will allow land masses to form independently of each other, denoting different continents. <br><br><h3>  Map Region </h3><br>  Let's start by describing one region of the map as a struct.  This will make it easier for us to work with several regions.  For this we create a <code>MapRegion</code> structure, which simply contains the fields of the region‚Äôs borders.  Since we will not use this structure outside the <code>HexMapGenerator</code> , we can define it within this class as a private internal structure.  Then four integer fields can be replaced with one <code>MapRegion</code> field. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  For everything to work, we need to add the <code>region.</code> prefix to the fields of minimum-maximum in <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  And also in <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Several regions </h3><br>  To support multiple regions, replace one <code>MapRegion</code> field <code>MapRegion</code> list of regions. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  At this stage, it would be nice to add a separate method for creating regions.  It must create the desired list or clear it if it already exists.  After that, it will identify one region, as we did before, and add it to the list. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Let's call this method in <code>GenerateMap</code> , but we will not create a region directly. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  In order for <code>GetRandomCell</code> to work with an arbitrary region, we give it the <code>MapRegion</code> parameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Now the <code>RaiseTerraion</code> and <code>SinkTerrain</code> must pass the corresponding region to <code>GetRandomCell</code> .  To do this, each of them also needs a region parameter. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ }</code> </pre> <br>  The <code>CreateLand</code> method should determine if each region should be raised or lowered.  In order to balance land between regions, we will simply bypass the list of regions in a cycle over and over again. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  However, we still need to do so that the lowering of the plots is distributed evenly.  This can be done while deciding for all regions whether to lower them. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Finally, to use exactly the entire amount of land, we need to stop the process as soon as the amount reaches zero.  This can occur at any stage of the region's cycle.  Therefore, we move the check to zero amount in the inner loop.  In fact, we can perform this check only after raising land, because when lowering the amount is never spent.  If we are done, we can immediately exit the <code>CreateLand</code> method. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Two regions </h3><br>  Although we now have the support of several regions, we still ask only one.  Let's change <code>CreateRegions</code> so that it divides the map in half vertically.  To do this, halve the value of <code>xMax</code> added region.  Then use the same value for <code>xMin</code> and again use the original value for <code>xMax</code> , using it as the second region. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Generating maps at this stage will not make any difference.  Although we have defined two regions, they occupy the same region as one old region.  To separate them to the side, you need to leave between them an empty space.  This can be done by adding a region border slider, using the same interval and default value as for the map borders. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Slider border region.</i> <br><br>  Since the land can be formed on either side of the space between the regions, the probability of creating bridges from land at the edges of the map will increase.  To prevent this, we use the region's border to set the land-free zone between the dividing line and the area in which the plots can begin.  This means that the distance between neighboring regions is two more than the size of the border of the region. <br><br>  To apply this region boundary, subtract it from the <code>xMax</code> first region and add to <code>xMin</code> second region. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>The map is divided vertically into two regions.</i> <br><br>  With the default parameters, two noticeably separated regions will be created, however, as in the case of one region and a large map boundary, we are not guaranteed to get exactly two land masses.  Most often it will be two large continents, possibly with several islands.  But sometimes two or more large islands can be created in a region.  And sometimes two continents can be connected by an isthmus. <br><br>  Of course, we can also split the map horizontally by changing the approaches for measuring X and Z. Let's randomly choose one of two possible orientations. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Map horizontally divided into two regions.</i> <br><br>  Since we use a wide map, with horizontal separation, wider and thinner regions will be created.  As a result, these regions are more likely to form several divided land masses. <br><br><h3>  Four regions </h3><br>  Let's make the number of regions customizable, create support from 1 to 4 regions. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Slider for the number of regions.</i> <br><br>  We can use the <code>switch</code> to select the execution of the corresponding region code.  We start by repeating the code for one region, which will be used by default, and leave the code for the two regions for case 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">What kind of switch statement?</b> <div class="spoiler_text">  This is an alternative to writing a sequence of if-else-if-else statements.  switch is applied to a variable, and labels are used to indicate which code to execute.  There is also a label <code>default</code> , which is used as the last block <code>else</code> .  Each option must be completed with either a <code>break</code> statement or a <code>return</code> . <br><br>  In order for a <code>switch</code> block to remain readable, it is usually best to make all cases short, ideally with a single statement or method call.  I will not do this for an example of a region code, but if you want to create more interesting regions, I recommend that you use separate methods.  For example: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Three regions are like two, only thirds are used instead of half.  In this case, the horizontal separation will create too narrow regions, so we created support only for the vertical separation.  Notice that as a result we have double the space of the region‚Äôs border, therefore there is less space for creating new sites than in the case of two regions. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Three regions.</i> <br><br>  Four regions can be created by combining horizontal and vertical divisions and adding one region to each corner of the map. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Four regions.</i> <br><br>  The approach used here is the simplest way to split a card.  It generates approximately the same land mass in terms of mass, and their variability is controlled by other map generation parameters.  However, it will always be pretty obvious that the map was divided along straight lines.  The more control we need, the less organic the result will look.  Therefore, it is normal if you need approximately equal regions for gameplay.  But if you need the most variable and unlimited land, you will have to make it with the help of one region. <br><br>  In addition, there are other ways to split a map.  We can not be limited to straight lines.  We are not even obliged to use regions of the same size, as well as cover the entire map with them.  We can leave holes.  You can also allow the intersection of regions or change the distribution of land between regions.  You can even set your own generator parameters for each region (although this is more difficult), for example, so that both a large continent and an archipelago are on the map. <br><br>  <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-24/partitioning-the-map/partitioning-the-map.unitypackage" rel="nofollow">unitypackage</a> <br><br><h2>  Erosion </h2><br>  So far, all the cards we generated looked pretty rough and broken.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The real relief may look like this, but over time it becomes smoother and smoothed, its sharp parts become dull due to erosion. </font><font style="vertical-align: inherit;">To improve the maps, we can apply this process of erosion. </font><font style="vertical-align: inherit;">We will do this after creating coarse sushi, in a separate method.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosion rate </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The more time passes, the more erosion appears. </font><font style="vertical-align: inherit;">Therefore, we want erosion to be not permanent, but customizable. </font><font style="vertical-align: inherit;">At a minimum, erosion is zero, which corresponds to the maps created earlier. </font><font style="vertical-align: inherit;">At maximum, erosion is comprehensive, that is, the further application of erosion forces will no longer change the relief. </font><font style="vertical-align: inherit;">That is, the erosion parameter should be a percentage from 0 to 100, and by default we take 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider erosion.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search for destructible cells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosion makes the relief smoother. In our case, the only sharp parts are the cliffs. Therefore, the purpose of the erosion process will be they. If a precipice exists, erosion should reduce it, until it eventually turns into a slope. We will not smooth the slopes, because it will lead to dull relief. To do this, we need to determine which cells are on the tops of the cliffs, and reduce their height. These will be erosion prone cells.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's create a method that determines whether a cell can be subject to erosion. </font><font style="vertical-align: inherit;">He determines this by checking the neighbors of the cell until he finds a large enough height difference. </font><font style="vertical-align: inherit;">Since the cliffs need a difference of at least one or two levels of height, the cell is prone to erosion if one or several of its neighbors are at least two steps below it. </font><font style="vertical-align: inherit;">If there is no such neighbor, the cell cannot be eroded.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use this method to </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cycle through all cells and write all eroded cells to a temporary list.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as we know the total number of erosion-prone cells, we can use the percentage of erosion to determine the number of remaining erosion-prone cells. </font><font style="vertical-align: inherit;">For example, if the percentage is 50, then we must subject the cells to erosion, until half of the original amount remains. </font><font style="vertical-align: inherit;">If the percentage is 100, then we will not stop until we destroy all erosion prone cells.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shouldn't we consider only eroded land cells?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cell reduction </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with a naive approach and assume that simply lowering the height of a cell destroyed by erosion will make it no longer prone to erosion. </font><font style="vertical-align: inherit;">If this were true, then we could just take random cells from the list, lower their height, and then remove them from the list. </font><font style="vertical-align: inherit;">We would repeat this operation until we reach the required number of eroded cells.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To prevent the search required </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will rewrite the current cell last in the list, and then delete the last element. </font><font style="vertical-align: inherit;">We still do not care about their order.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A naive decrease in 0% and 100% erosion-prone cells, seed cards 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosion tracking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our naive approach allows us to apply erosion, but not to the necessary extent. </font><font style="vertical-align: inherit;">This happens because the cell can still remain subject to erosion after one drop in height. </font><font style="vertical-align: inherit;">Therefore, we will remove a cell from the list only when it is no longer subject to erosion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% erosion while maintaining the erosion-prone cells in the list. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we get much more erosion, but using 100%, we still do not get rid of all the cliffs. </font><font style="vertical-align: inherit;">The reason is that after reducing the height of the cell, one of its neighbors may become eroded. </font><font style="vertical-align: inherit;">Therefore, as a result, we may have more erosion prone cells than was originally. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After lowering the cell, we need to check all its neighbors. </font><font style="vertical-align: inherit;">If now they are subject to erosion, but they are not yet in the list, then you need to add them there.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All erosion prone cells are omitted.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We save a lot of sushi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the process of erosion can continue until all the cliffs disappear. This significantly affects the land. Most of the land mass disappeared and we got a much smaller percentage of the land needed. It happened because we remove land from the map. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True erosion does not destroy matter. She takes her from one place and places her somewhere else. We can do the same. By dropping one cell, we have to pick up one of its neighbors. In fact, one level of height is transferred to a lower cell. This saves the total amount of map heights, while simply smoothing it out.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To realize this, we need to decide where to move the products of erosion. </font><font style="vertical-align: inherit;">This will be our target point of erosion. </font><font style="vertical-align: inherit;">Let's create a method to determine the target point of the cell that will be eroded. </font><font style="vertical-align: inherit;">Since this cell contains a break, it will be logical to select a cell under this break as a target. </font><font style="vertical-align: inherit;">But a cell prone to erosion may have several cliffs, so check all the neighbors and put all candidates on a temporary list, and then we will choose one of them randomly.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we determine the target cell immediately after the selection of the cell to be eroded. </font><font style="vertical-align: inherit;">Then we decrease and increase the heights of the cells immediately one after another. </font><font style="vertical-align: inherit;">At the same time, the target cell itself may become subject to erosion, but this situation is resolved when we check the neighbors of the cell just eroded.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we raised the target cell, part of the neighbors of this cell may cease to be subject to erosion. </font><font style="vertical-align: inherit;">It is necessary to bypass them and check whether they are subject to erosion. </font><font style="vertical-align: inherit;">If not, but they are in the list, then you need to remove them from it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% erosion preserving the mass of land. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, erosion can smooth out the relief much better, lowering some areas and raising others. </font><font style="vertical-align: inherit;">As a result, the mass of land can both increase and narrow. </font><font style="vertical-align: inherit;">This may change the percentage of land on a few percent in one direction or another, but serious deviations rarely occur. </font><font style="vertical-align: inherit;">That is, the more erosion we apply, the less control we will have over the resulting percentage of land.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accelerated erosion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we do not need to worry about the effectiveness of the erosion algorithm, it is possible to make simple improvements to it. </font><font style="vertical-align: inherit;">First, note that we are explicitly checking whether the cell we have eroded can be eroded. </font><font style="vertical-align: inherit;">If not, then essentially we remove it from the list. </font><font style="vertical-align: inherit;">Therefore, you can skip checking this cell when traversing the neighbors of the target cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, we only needed to check the neighbors of the target cell when there was a break between them, but now it is not necessary. </font><font style="vertical-align: inherit;">This happens only when the neighbor is now one step higher than the target cell. </font><font style="vertical-align: inherit;">If this is so, then the neighbor is guaranteed to be on the list, so we don‚Äôt need to check it, that is, we can skip an unnecessary search.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thirdly, we can use a similar trick when checking the neighbors of an erosion-prone cell. </font><font style="vertical-align: inherit;">If there is a cliff between them now, then the neighbor is subject to erosion. </font><font style="vertical-align: inherit;">To find out, we do not need to call </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, we still need to check whether the target cell is prone to erosion, but the cycle shown above no longer does this. </font><font style="vertical-align: inherit;">Therefore, we do this explicitly for the target cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can apply erosion rather quickly and to the desired percentage relative to the initial number of generated cliffs. </font><font style="vertical-align: inherit;">Note that due to the fact that we slightly changed the place in which the target cell is added to the list of erosion-prone, the result has slightly changed compared to the result before optimizations.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% and 100% erosion. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also note that despite the changed shape of the coast, the topology has not fundamentally changed. </font><font style="vertical-align: inherit;">Sushi masses usually remain either connected or separated. </font><font style="vertical-align: inherit;">Only small islands can drown completely. </font><font style="vertical-align: inherit;">The relief details are smoothed out, but the general shapes remain the same. </font><font style="vertical-align: inherit;">A narrow connection may disappear, or grow slightly. </font><font style="vertical-align: inherit;">A small space can fill up or expand slightly. </font><font style="vertical-align: inherit;">Therefore, erosion will not strongly glue the separated regions.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The four fully eroded regions still remain separate. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-24/erosion/erosion.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 25: the water cycle </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Display raw map data. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We form the climate of cells. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a partial simulation of the water cycle. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part we will add moisture on land. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This tutorial was created in Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use the water cycle to determine the biomes.</font></font></i> <br><br><h2>  Clouds </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, the map generation algorithm changed only the height of the cells. </font><font style="vertical-align: inherit;">The biggest difference between cells was whether they were above or under water. </font><font style="vertical-align: inherit;">Although we can set different types of terrain, this is just a simple visualization of the height. </font><font style="vertical-align: inherit;">It will be better to set the types of relief, given the local climate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Earth's climate is a very complex system. </font><font style="vertical-align: inherit;">Fortunately, we do not need to create a realistic climate simulation. </font><font style="vertical-align: inherit;">We will need something that looks natural enough. </font><font style="vertical-align: inherit;">The most important aspect of climate is the water cycle, because for survival the flora and fauna need liquid water. </font><font style="vertical-align: inherit;">Temperature is also very important, but for now we will focus on water, essentially leaving the global temperature constant and changing only the humidity.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The water cycle describes the movement of water around the environment. </font><font style="vertical-align: inherit;">Simply put, the reservoirs evaporate, which creates clouds that shed rain, which again flows into the reservoirs. </font><font style="vertical-align: inherit;">The system has many more aspects, but simulations of these stages may already be enough to create a natural-looking distribution of water on the map.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data visualization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we move on to this simulation, it will be helpful to directly see the relevant data. </font><font style="vertical-align: inherit;">To do this, we change the shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Add a switchable property to it, which can be switched to data visualization mode, which displays raw map data instead of ordinary relief textures. </font><font style="vertical-align: inherit;">This can be implemented using float-properties with a switchable attribute that specifies the keyword. </font><font style="vertical-align: inherit;">Due to this, it will appear in the material inspector as a checkbox that controls the task of the keyword. </font><font style="vertical-align: inherit;">The name of the property itself is not important, we are only interested in the keyword. </font><font style="vertical-align: inherit;">We use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Switch to display the map data. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a shader function to enable keyword support.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will make it so that one float value is displayed, as is the case with the rest of the relief data. </font><font style="vertical-align: inherit;">To do this, we will add a </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field </font><font style="vertical-align: inherit;">to the structure </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when the keyword is defined.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the vertex program, we use the Z channel of the cell data to fill </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as always interpolated between cells.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you need to display the data of the cells, use them directly as an albedo fragment instead of the usual color. </font><font style="vertical-align: inherit;">Multiply it by the grid so that the grid is still enabled when rendering data.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To actually pass the data to the shader. </font><font style="vertical-align: inherit;">we need to add to the </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method that writes something to the blue channel of the texture data. </font><font style="vertical-align: inherit;">The data is one float value, limited in the range of 0‚Äì1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this decision affects the research system. </font><font style="vertical-align: inherit;">The value of 255 blue channel data is used to indicate that cell visibility is in transition. </font><font style="vertical-align: inherit;">In order for this system to continue to work, we need to use as a maximum the byte value of 254. Note that the movement of the detachment will erase all the card data, but this suits us, because they are used for debugging card generation.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a method with the same name and in </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will transmit the request to its shader data.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To test the code, we change it </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it sets the data of each cell of the map. </font><font style="vertical-align: inherit;">Let's visualize the height converted from integer to float in the interval 0‚Äì1. </font><font style="vertical-align: inherit;">This is done by subtracting the minimum height from the height of the cell and then dividing it by the maximum height minus the minimum. </font><font style="vertical-align: inherit;">Let's make the division be floating point.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can switch between regular terrain and data visualization using the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Show Map Data</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> checkbox of the asset of the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> material </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map 1208905299, the usual relief and visualization of heights.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Climate creation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To simulate climate, we need to track climate data. </font><font style="vertical-align: inherit;">Since the map consists of discrete cells, each of them has its own local climate. </font><font style="vertical-align: inherit;">Create a structure </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to store all relevant data. </font><font style="vertical-align: inherit;">Of course, you can add data to the cells themselves, but we will only use them when generating a map. </font><font style="vertical-align: inherit;">Therefore, save them separately. </font><font style="vertical-align: inherit;">This means that we can define this struct inside </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, like </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will start by tracking only the clouds, which can be implemented using a single float field.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add a list to track climate data for all cells. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need a method for creating a climate map. </font><font style="vertical-align: inherit;">It should begin by clearing the list of climatic zones, and then add one item for each cell. </font><font style="vertical-align: inherit;">The climate data is simply zero, this can be achieved using a standard constructor </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The climate should be created after the impact on the land of erosion before specifying the types of relief. </font><font style="vertical-align: inherit;">In reality, erosion is mainly caused by the movement of air and water, which are part of the climate, but we will not simulate it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modify </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that we can see cloud data instead of cell height. </font><font style="vertical-align: inherit;">Initially, it will look like a black card.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changing climate </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first stage of the climate simulation is evaporation. </font><font style="vertical-align: inherit;">How much water should evaporate? </font><font style="vertical-align: inherit;">Let's control this value with the slider. </font><font style="vertical-align: inherit;">A value of 0 means no evaporation, 1 means maximum evaporation. </font><font style="vertical-align: inherit;">By default we use 0.5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporation slider. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's create another method specifically for forming a single cell climate. </font><font style="vertical-align: inherit;">We give it the cell index as a parameter and use it to get the corresponding cell and its climate data. </font><font style="vertical-align: inherit;">If the cell is under water, then we are dealing with a reservoir that must evaporate. </font><font style="vertical-align: inherit;">We immediately turn steam into clouds (ignoring dew points and condensation), so we directly add evaporation to the value of the cell clouds. </font><font style="vertical-align: inherit;">Finished with this, copy the climate data back to the list.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call this method for each cell in </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is not enough. </font><font style="vertical-align: inherit;">To create a complex simulation, we need to form a climate of cells several times. </font><font style="vertical-align: inherit;">The more often we do this, the better the result will be. </font><font style="vertical-align: inherit;">Let's just pick a constant value. </font><font style="vertical-align: inherit;">I use 40 cycles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since for the time being we only increase the value of the clouds above the cells filled with water, as a result we will have black land and white water bodies. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporation above water.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cloud scattering </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clouds are not constantly in one place, especially when more water evaporates. </font><font style="vertical-align: inherit;">The difference in pressure causes the air to move, which manifests itself in the form of wind, which also forces the clouds to move. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is no dominant wind direction, then on average the clouds of cells will evenly disperse in all directions, finding themselves in neighboring cells. </font><font style="vertical-align: inherit;">When generating new clouds in the next cycle, let's distribute all the clouds in a cell, according to its neighbors. </font><font style="vertical-align: inherit;">That is, each neighbor gets one sixth of the cell clouds, after which there is a local decrease to zero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To actually add clouds to your neighbors, you need to go around them in a loop, get their climate data, increase the value of the clouds and copy them back to the list. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scattering clouds.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the same time, an almost white map is created, because at each cycle underwater cells add more and more clouds to the global climate. After the first cycle, land cells next to the water will also have clouds that need to be dispersed. This process continues until most of the map is covered with clouds. In the case of the map 1208905299 with default parameters, only the inner part of a large land mass in the northeast remained completely uncovered.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that reservoirs can generate an infinite amount of clouds. </font><font style="vertical-align: inherit;">The water level is not part of the climate simulation. </font><font style="vertical-align: inherit;">In reality, water bodies are saved only because water flows back into them approximately at the rate of evaporation. </font><font style="vertical-align: inherit;">That is, we simulate only a partial water cycle. </font><font style="vertical-align: inherit;">This is normal, but we need to understand that the longer the simulation is performed, the more water is added to the climate. </font><font style="vertical-align: inherit;">So far, water is lost only at the edges of the map, where scattered clouds are lost due to the absence of neighbors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can see the loss of water at the top of the map, especially in the cells at the top right. </font><font style="vertical-align: inherit;">In the last cell there are no clouds at all, because it remains the last in which the climate is formed. </font><font style="vertical-align: inherit;">She has not yet received from the neighbor of the clouds.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shouldn't the climate of all cells be parallel?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3>  Precipitation </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water does not stay in a cold state forever. At some point, she must fall to the ground again. This usually happens in the form of rain, but sometimes it can be snow, hail or sleet. All this is generally called precipitation. The magnitude and speed of the disappearance of clouds vary greatly, but we simply use a custom global precipitation coefficient. A value of 0 means no precipitation, a value of 1 means that all clouds disappear instantly. The default is 0.25. This means that in each cycle a quarter of the clouds will disappear.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rainfall slider. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will simulate precipitation after evaporation and before scattering of clouds. </font><font style="vertical-align: inherit;">This will mean that part of the water evaporated from water bodies immediately precipitates, so the number of scattering clouds decreases. </font><font style="vertical-align: inherit;">Over land, precipitation will lead to the disappearance of clouds.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fading clouds. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we are destroying 25% of the clouds in each cycle, the land has again become almost black. </font><font style="vertical-align: inherit;">Clouds manage to move only a few steps deep into the land, after which they become imperceptible. </font></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/clouds/clouds.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2>  Humidity </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although precipitation destroys clouds, they should not remove water from the climate. </font><font style="vertical-align: inherit;">After falling to the ground, water is saved, only in a different state. </font><font style="vertical-align: inherit;">It can exist in many forms, which we will generally consider humidity.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humidity tracking </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are going to improve the climate model by tracking two states of water: clouds and humidity. </font><font style="vertical-align: inherit;">To implement this, add to the </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In its most generalized form, evaporation is the process of converting moisture into clouds, at least in our simple climate model. </font><font style="vertical-align: inherit;">This means that evaporation should not be a constant value, but another factor. </font><font style="vertical-align: inherit;">Therefore, we perform a refactoring-rename </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the cell is under water, we simply declare that the humidity level is 1. This means that the evaporation is equal to the evaporation coefficient. </font><font style="vertical-align: inherit;">But now we can also get evaporation from sushi cells. </font><font style="vertical-align: inherit;">In this case, we need to calculate the evaporation, subtract it from the humidity and add the result to the clouds. </font><font style="vertical-align: inherit;">After that, precipitation is added to the humidity.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the clouds are now supported by evaporation from over land, we can move them further inland. </font><font style="vertical-align: inherit;">Now the bulk of the land has become gray.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clouds with evaporation of humidity. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's change it </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it displays humidity instead of clouds, because we will use it to determine the types of relief.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moisture display. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, the humidity looks quite similar to the clouds (except that all the underwater cells are white), but this will change soon.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sediment runoff </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporation is not the only way moisture can leave a cell. </font><font style="vertical-align: inherit;">The water cycle tells us that the main part of the moisture added to the land somehow turns out to be in the water bodies again. </font><font style="vertical-align: inherit;">The most visible process is the flow of water over land under the influence of gravity. </font><font style="vertical-align: inherit;">We will not simulate real rivers, but use a custom coefficient for rainfall runoff. </font><font style="vertical-align: inherit;">It will denote the percentage of water flowing to the lower areas. </font><font style="vertical-align: inherit;">Let's default drain will be equal to 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drain slider.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not generate the river?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water flow acts as a scattering of clouds, but with three differences. First, not all moisture is removed from the cell. Secondly, it carries moisture, not clouds. Thirdly, he descends, that is, only to neighbors with a lower height. The runoff coefficient describes the amount of humidity that would pour out of the cell if all the neighbors were lower, but often they are less. This means that we will reduce the humidity of the cell only when we find a neighbor below.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water flowing to a lower height. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we have a more varied moisture distribution, because high cells transfer their moisture to the lower ones. </font><font style="vertical-align: inherit;">We also see much less moisture in the coastal cells, because they drain the moisture into the underwater cells. </font><font style="vertical-align: inherit;">To weaken this effect, we also need to use the water level when determining whether the cell is lower, that is, to take the apparent height.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use the visible height.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Percolation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water not only flows down, it spreads, seeping through the level relief, and is absorbed by land adjacent to water bodies. </font><font style="vertical-align: inherit;">This effect may have a minor effect, but it is useful for smoothing the distribution of moisture, so let's add it to the simulation. </font><font style="vertical-align: inherit;">Create it with your own customizable coefficient, the default is 0.125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penetration slider. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The leakage is similar to the drain, except that it applies when the neighbor has the same apparent height as the cell itself.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Added a bit of trickle down. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/moisture/moisture.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rain shadows </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we have already created a decent simulation of the water cycle, it does not look very interesting, because there are no rain shadows in it that most clearly demonstrate climatic differences. </font><font style="vertical-align: inherit;">Rain shadows are areas in which there is a significant lack of precipitation compared to neighboring areas. </font><font style="vertical-align: inherit;">Such areas exist because mountains make it difficult for the clouds to reach them. </font><font style="vertical-align: inherit;">To create them requires high mountains and the dominant wind direction.</font></font><br><br><h3>  Wind </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start by adding the dominant wind direction to the simulation. </font><font style="vertical-align: inherit;">Although the dominant wind directions on the surface of the Earth vary greatly, we will manage a custom global wind direction. </font><font style="vertical-align: inherit;">Let's use northwest by default. </font><font style="vertical-align: inherit;">In addition, let's make the wind power adjustable from 1 to 10 with a default value of 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wind direction and strength. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The strength of the dominant wind is expressed relative to the total dispersion of clouds. </font><font style="vertical-align: inherit;">If the wind force is 1, then the scattering is the same in all directions. </font><font style="vertical-align: inherit;">When it is 2, the scattering is two higher in the direction of the wind than in other directions, and so on. </font><font style="vertical-align: inherit;">We can accomplish this by changing the divisor in the cloud scattering formula. </font><font style="vertical-align: inherit;">Instead of six, it will be five plus wind power.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the wind direction determines the direction from which the wind blows. </font><font style="vertical-align: inherit;">Therefore, we need to use the opposite direction as the main direction of scattering.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can check whether the neighbor is in the main direction of scattering. </font><font style="vertical-align: inherit;">If so, then we must multiply the scattering of clouds by the force of the wind.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">North-west wind, force 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The dominant wind adds the direction of the distribution of humidity over land. </font><font style="vertical-align: inherit;">The stronger the wind, the more powerful the effect becomes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Absolute height </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second ingredient in getting rain shadows is mountains. We do not have a strict classification of what is a mountain, as there is no nature. Only absolute height is important. In fact, when the air moves over the mountain, it is forced to rise, cools and may contain less water, which leads to precipitation before the air passes over the mountain. As a result, on the other side we get dry air, that is, a rain shadow.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most importantly, the higher the air rises, the less water it can contain. </font><font style="vertical-align: inherit;">In our simulation, we can imagine this as a forced restriction of the maximum cloud value for each cell. </font><font style="vertical-align: inherit;">The higher the apparent height of the cell, the lower this maximum should be. </font><font style="vertical-align: inherit;">The easiest way to do this is to set the maximum to 1 minus the apparent height divided by the maximum height. </font><font style="vertical-align: inherit;">But in fact, let's divide by a maximum of minus 1. This will allow a small fraction of the clouds to make their way even through the highest cells. </font><font style="vertical-align: inherit;">We assign this maximum after calculating the precipitation and before scattering.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If, as a result, we get more clouds than acceptable, then simply convert the excess clouds to humidity. </font><font style="vertical-align: inherit;">In fact, this is how we add additional rainfall, as it happens in real mountains.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rain shadows caused by high altitude. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/rain-shadows/rain-shadows.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finish the simulation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, we already have quite high-quality partial simulation of the water cycle. </font><font style="vertical-align: inherit;">Let's tidy it up a little, and then apply it to determine the type of cell relief.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallel computation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned earlier under the spoiler, the cell formation order affects the result of the simulation. </font><font style="vertical-align: inherit;">Ideally, this should not be and in fact we form all the cells in parallel. </font><font style="vertical-align: inherit;">This can be done by applying all changes of the current stage of formation to the second climate list </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clean up and initialize this list, like everyone else. </font><font style="vertical-align: inherit;">Then we will exchange lists on each cycle. </font><font style="vertical-align: inherit;">The simulation will alternately use two lists and apply current and following climate data.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When a cell affects the climate of its neighbor, we must change the following climate data, not the current one. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; ‚Ä¶ nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And instead of copying the following climate data back to the current climate list, we get the following climate data, add current humidity to it and copy it all into the following list. </font><font style="vertical-align: inherit;">After that, reset the data in the current list so that it is updated for the next cycle.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> While we are doing this, let's also assign a maximum of 1 to the humidity level so that the land cells could not be more wet than the underwater ones. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallel computations.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initial humidity </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a possibility that as a result of the simulation too much dry land will appear, especially with a high percentage of land. </font><font style="vertical-align: inherit;">To improve the picture, we can add a customizable initial moisture level with a default value of 0.1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the top of the slider is the original moisture. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use this value for the humidity of the original climate list, but not for the following.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With initial moisture.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We set biomes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We conclude by using humidity instead of height to specify the type of cell topography. </font><font style="vertical-align: inherit;">Let's use snow for completely dry sushi, use snow for dry regions, then there is a stone, grass for wet enough, and land for water-soaked and underwater cells. </font><font style="vertical-align: inherit;">The easiest way to use five intervals in increments of 0.2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using a uniform distribution, the result is not very good, and it looks unnatural. </font><font style="vertical-align: inherit;">It is better to use other thresholds, such as 0.05, 0.12, 0.28 and 0.85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modified biomes. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-25/finishing-the-simulation/finishing-the-simulation.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 26: Biomes and Rivers </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We create the rivers originating from high cells with humidity. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a simple temperature model. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use the biome matrix for the cells, and then change it. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part we will supplement the water cycle with rivers and temperature, and also assign more interesting biomes to the cells. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial was created using Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heat and water enliven the map.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River generation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers are a consequence of the water cycle. </font><font style="vertical-align: inherit;">In fact, they are formed by drains that are pulled out with the help of erosion of the channel. </font><font style="vertical-align: inherit;">This implies that you can add rivers based on the value of the sinks of the cells. </font><font style="vertical-align: inherit;">However, this does not guarantee that we will get something resembling real rivers. </font><font style="vertical-align: inherit;">When we start the river, it will have to flow as far as possible, potentially through a multitude of cells. </font><font style="vertical-align: inherit;">This is not consistent with our simulation of the water cycle, which processes cells in parallel. </font><font style="vertical-align: inherit;">In addition, it is usually necessary to control the number of rivers on the map. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the rivers are very different, we will generate them separately. </font><font style="vertical-align: inherit;">We use the results of a simulation of the water cycle to determine the location of the rivers, but the rivers in turn will not affect the simulation.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is the river flow sometimes wrong?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         (¬´¬ª). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } ‚Ä¶ }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> High humidity cells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On our maps, the cell may or may not have a river. In addition, they can branch or join. In reality, rivers are much more flexible, but we will have to get by with this approximation, creating only large rivers. The most important thing is that we need to determine the place where the big river starts, which is chosen randomly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since rivers require water, the source of the river must be in a cell with high humidity. But this is not enough. Rivers flow down the slopes, so ideally the source should have a great height. The higher the cell above the water level, the better candidate it is for the source of the river. We can visualize this as map data, dividing the height of the cell by the maximum height. To get the result relative to the water level, we will subtract it from both heights before dividing.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humidity and altitude above water level. Large map number 1208905299 with default parameters.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The best candidates are those cells that have both high humidity and high altitude. We can combine these criteria by multiplying them. The result will be the value of fitness or weight for the source of the rivers.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weights for sources of the rivers.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ideally, we would use these weights to reject the random selection of the source cell. Although we can create a list with the right weights and choose from it, this is a non-trivial approach and it slows down the generation process. A simpler classification of significance divided into four levels will be sufficient for us. The first candidates will be weights with values ‚Äã‚Äãhigher than 0.75. Good candidates have weights from 0.5. Eligible candidates - more than 0.25. All other cells are discarded. Let's show how it looks graphically.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Categories of the weights of the origins of the rivers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With such a classification scheme, we will most likely get rivers with sources in the highest and humid areas of the map. </font><font style="vertical-align: inherit;">But nevertheless, the likelihood of creating rivers in relatively dry or low areas is preserved, which increases variability. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a method </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that fills the list of cells based on these criteria. </font><font style="vertical-align: inherit;">Eligible cells are added to this list once, good ones - twice, and main candidates - four times. </font><font style="vertical-align: inherit;">Underwater cells are always discarded, so you can not check them.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method should be called after </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that we have moisture data available.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After completing the classification, you can get rid of the visualization of its data on the map. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Points </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How many rivers do we need? </font><font style="vertical-align: inherit;">This parameter must be customizable. </font><font style="vertical-align: inherit;">Since the length of the rivers varies, it will be more logical to control it with the help of river points, which determine the number of land cells in which the rivers should be contained. </font><font style="vertical-align: inherit;">Let's express them as a percentage with a maximum of 20% and a default value of 10%. </font><font style="vertical-align: inherit;">Like the percentage of land, this is a target value, not a guaranteed one. </font><font style="vertical-align: inherit;">As a result, we may have too few candidates or rivers that are too short to cover the required amount of land. </font><font style="vertical-align: inherit;">That is why the maximum percentage should not be too large.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slider percentage of rivers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To determine river points, expressed as the number of cells, we need to memorize how many land cells were generated in </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside the </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">number of points of the rivers can now be calculated just as we do in </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we continue to take and remove random cells from the original list, while we still have points and source cells. </font><font style="vertical-align: inherit;">In case of completion of the number of points we will display a warning in the console.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we will add a method for directly creating rivers. </font><font style="vertical-align: inherit;">As a parameter, it needs the source cell, and after completion it must return the length of the river. </font><font style="vertical-align: inherit;">We start with the procurement method, which returns zero length.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call this method at the end of the loop we just added in </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, using to reduce the number of points left. </font><font style="vertical-align: inherit;">Let's make it so that a new river is created only if there is no river flowing through it in the selected cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flowing rivers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is logical to create a river flowing to the sea or another reservoir. </font><font style="vertical-align: inherit;">When we start from the source, we immediately get the length 1. After that we choose a random neighbor and increase the length. </font><font style="vertical-align: inherit;">We continue to move until we reach the underwater cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random rivers. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of this naive approach, we get randomly scattered fragments of rivers, mainly due to the replacement of previously generated rivers. </font><font style="vertical-align: inherit;">This can even lead to errors, because we do not check whether the neighbor actually exists. </font><font style="vertical-align: inherit;">We need to check all directions in the loop and make sure that there is a neighbor there. </font><font style="vertical-align: inherit;">If there is one, then we add this direction to the list of potential flow directions, but only if a river does not flow through this neighbor. </font><font style="vertical-align: inherit;">Then select a random value from this list.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this new approach, we may have zero flow directions available. </font><font style="vertical-align: inherit;">When this happens, the river can no longer flow further and must be completed. </font><font style="vertical-align: inherit;">If at this moment the length is 1, then this means that we could not flow out of the source cell, that is, there can be no river at all. </font><font style="vertical-align: inherit;">In this case, the length of the river is zero.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preserved rivers.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run down </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we keep the already created rivers, but we still may receive isolated fragments of rivers. </font><font style="vertical-align: inherit;">This is because while we ignored the height. </font><font style="vertical-align: inherit;">Every time we forced the river to flow to a greater height, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrupted this attempt, which led to ruptures in the rivers. </font><font style="vertical-align: inherit;">Therefore, we also need to skip directions that make the river flow upwards.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers flowing down. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we will get rid of many fragments of the river, but some still remain. </font><font style="vertical-align: inherit;">From this moment, getting rid of the most ugly rivers becomes a matter of refinement. </font><font style="vertical-align: inherit;">To begin with, rivers prefer to flow down as quickly as possible. </font><font style="vertical-align: inherit;">They will not necessarily choose the shortest possible route, but the likelihood of this is high. </font><font style="vertical-align: inherit;">To imitate this, the directions down we add to the list three times.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoid sharp turns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to flowing down, water also has inertia. </font><font style="vertical-align: inherit;">A river is more likely to flow straight or slightly curved than it makes a sudden sharp turn. </font><font style="vertical-align: inherit;">We can add such distortion by tracking the last direction of the river. </font><font style="vertical-align: inherit;">If the potential flow direction does not deviate too far from this direction, then we add it to the list again. </font><font style="vertical-align: inherit;">This is not a problem for the source, so we will just always add it again.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This greatly reduces the likelihood of re-zigzags that look ugly. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fewer sharp turns.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River confluence </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes it turns out that the river flows right next to the source of the previously created river. </font><font style="vertical-align: inherit;">If the source of this river is not at a higher altitude, then we can decide that the new river flows into the old one. </font><font style="vertical-align: inherit;">As a result, we get one long river, not two adjacent ones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, we will pass the neighbor, only if it has an incoming river, or if it is the source of the current river. </font><font style="vertical-align: inherit;">Having determined that this direction is not up, we check if there is an outgoing river there. </font><font style="vertical-align: inherit;">If there is, then we again found the old river. </font><font style="vertical-align: inherit;">Since this happens quite rarely, we will not check other neighboring sources and immediately unite the rivers.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers before and after combining.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Save the distance </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since good candidates for the source are usually a bunch of hands together, we will have clusters of rivers. </font><font style="vertical-align: inherit;">In addition, we may have rivers that take the source directly next to the reservoir, as a result of which rivers of length 1 will arise. We can distribute the sources, discarding those that are located next to the river or reservoir. </font><font style="vertical-align: inherit;">We do this by circumventing the neighbors of the selected source in a loop inside </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If we find a neighbor violating the rule, then the source does not suit us and we must skip it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And although the rivers will still flow next to each other, they tend to cover a large area. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without and with the saved distance.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We finish the river with a lake </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not all rivers reach the reservoir, some get stuck in the valleys or blocked by other rivers. This is not a particular problem, because often real rivers also seem to disappear. This can happen, for example, if they flow underground, disperse in swampy areas or dry out. Our rivers cannot visualize this, so they simply end. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, we can try to minimize the number of such cases. Although we cannot unite the rivers or force them to flow upwards, we can make them end in lakes, which is often found in reality and looks good. For this</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should raise the water level in the cell if it gets stuck. </font><font style="vertical-align: inherit;">The possibility of this depends on the minimum height of the neighbors of this cell. </font><font style="vertical-align: inherit;">Therefore, in order to keep track of this when examining neighbors, a small code modification is required.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we are stuck, first of all we need to check whether we are still in the source. </font><font style="vertical-align: inherit;">If yes, then just cancel the river. </font><font style="vertical-align: inherit;">Otherwise, we check if all the neighbors are at least as high as the current cell. </font><font style="vertical-align: inherit;">If so, then we can raise the water to this level. </font><font style="vertical-align: inherit;">This will create a lake from a single cell, unless the height of the cell remains at the same level. </font><font style="vertical-align: inherit;">If so, then simply assign the height one level below the water level.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ends of the rivers without lakes and with lakes. </font><font style="vertical-align: inherit;">In this case, the percentage of rivers is equal to 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notice that now we can have underwater cells that are above the water level used when generating the map. </font><font style="vertical-align: inherit;">They will denote lakes above sea level.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional lakes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also create lakes even if we are not stuck. </font><font style="vertical-align: inherit;">In this case, the river can flow, flowing and flowing from the lake. </font><font style="vertical-align: inherit;">If we are not stuck, the lake can be created by raising the water level of the current height of the cell, and then reducing the height of the cell. </font><font style="vertical-align: inherit;">This is applicable only when the minimum height of the neighbor is at least equal to the height of the current cell. </font><font style="vertical-align: inherit;">We do this at the end of the river cycle and before moving to the next cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Without and with additional lakes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Several lakes are beautiful, but without limitations we can create too many lakes. </font><font style="vertical-align: inherit;">So let's add a custom probability for additional lakes, the default value of 0.25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It will control the likelihood of generating an additional lake, if possible. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional lakes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How about creating lakes for more than one cell?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/generating-rivers/generating-rivers.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2>  Temperature </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water is only one of the factors that can determine the biome of a cell. </font><font style="vertical-align: inherit;">Another important factor is temperature. </font><font style="vertical-align: inherit;">Although we can simulate the course and diffusion of temperatures like a simulation of water, to create an interesting climate we need only one complex factor. </font><font style="vertical-align: inherit;">Therefore, we will keep the temperature simple and will set it for each cell.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperature and latitude </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The latitude is most affected by temperature. </font><font style="vertical-align: inherit;">It is hot at the equator, cold at the poles, and there is a smooth transition between them. </font><font style="vertical-align: inherit;">Let's create a method </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that returns the temperature of a given cell. </font><font style="vertical-align: inherit;">To begin with, we simply use the Z coordinate of the cell divided by the Z dimension as the latitude, and then use this value as the temperature.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determine the temperature in </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use it as a data card.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitude as temperature, southern hemisphere. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We get a linear temperature gradient increasing from bottom to top. </font><font style="vertical-align: inherit;">You can use it to simulate the southern hemisphere, with the pole below and the equator above. </font><font style="vertical-align: inherit;">But we do not need to describe the entire hemisphere. </font><font style="vertical-align: inherit;">Using a smaller temperature difference or no difference at all, we can describe a smaller area. </font><font style="vertical-align: inherit;">To do this, we will make low and high temperatures customizable. </font><font style="vertical-align: inherit;">We set these temperatures in the range of 0‚Äì1, and use the extreme values ‚Äã‚Äãas default values.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperature sliders. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apply the temperature range using linear interpolation, using latitude as the interpolator. </font><font style="vertical-align: inherit;">Since we express latitude as a value from 0 to 1, we can use </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that low temperatures are not necessarily lower than high temperatures. </font><font style="vertical-align: inherit;">If desired, you can flip them.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemispheres </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can model the southern hemisphere, and possibly the northern one, if we reverse the temperatures. </font><font style="vertical-align: inherit;">But it is much more convenient to use a separate configuration option to switch between the hemispheres. </font><font style="vertical-align: inherit;">Let's create an enumeration and a field for it. </font><font style="vertical-align: inherit;">Thus, we will also add the option to create both hemispheres, which is applicable by default.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The choice of the hemisphere. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we need the northern hemisphere, we can simply flip the latitude, subtracting it from 1. To simulate both hemispheres, the poles must be below and above the map, and the equator should be in the middle. </font><font style="vertical-align: inherit;">You can do this by doubling the latitude, while the lower hemisphere will be processed correctly, and the upper one will have a latitude from 1 to 2. To fix this, we will subtract the latitude from 2 when it exceeds 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both hemispheres. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that this makes it possible to create an exotic map in which the equator is cold and the poles are warm.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The higher the colder </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to latitude, the height also noticeably affects the temperature. </font><font style="vertical-align: inherit;">On average, the higher we climb, the colder it gets. </font><font style="vertical-align: inherit;">We can turn this into a factor, as we did with the candidates of the rivers. </font><font style="vertical-align: inherit;">In this case, we use the height of the cell. </font><font style="vertical-align: inherit;">In addition, this indicator decreases with height, that is, it is equal to 1 minus the height divided by the maximum relative to the water level. </font><font style="vertical-align: inherit;">So that the indicator at the highest level does not fall to zero, we add to the divisor. </font><font style="vertical-align: inherit;">Then we use this indicator to scale the temperature.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Height affects temperature.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperature fluctuations </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can make the simplicity of the temperature gradient less noticeable by adding random temperature variations. </font><font style="vertical-align: inherit;">A small chance to make it more realistic, but with too large fluctuations, they will look arbitrary. </font><font style="vertical-align: inherit;">Let's make the temperature fluctuation force adjustable and express it as the maximum temperature deviation with a default value of 0.1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperature slider. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such oscillations should be smooth with small local changes. </font><font style="vertical-align: inherit;">For this you can use our noise texture. </font><font style="vertical-align: inherit;">We will call </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use the position of the cell scaled to 0.1 as an argument. </font><font style="vertical-align: inherit;">Let's take the W channel, center it and scale it to the oscillation coefficient. </font><font style="vertical-align: inherit;">Then add this value to the previously calculated temperature.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temperature fluctuations with values ‚Äã‚Äãof 0.1 and 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We can add a little variation to each map to fluctuations, choosing random noise from four channels. </font><font style="vertical-align: inherit;">Set the channel once in </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then index the color channels in </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different temperature fluctuations with maximum power. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/temperature/temperature.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have data on humidity and temperature, we can create a matrix of biomes. </font><font style="vertical-align: inherit;">By indexing this matrix, we can assign all cells to the biome, creating a more complex landscape than using only one dimension of the data.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biome matrix </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many climate models, but we will not use any of them. We will make it very simple, we are only interested in consistency. Dry means desert (cold or hot), for it we use sand. Cold and wet means snow. Hot and wet means a lot of vegetation, that is, grass. Between them we will have taiga or tundra, which we denote by the grayish texture of the earth. A 4 √ó 4 matrix will be enough to create transitions between these biomes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, we assigned relief types based on five moisture ranges. We simply drop the driest lane to 0.05, and save the rest. For temperature bands, we use 0.1, 0.3, 0.6 and higher. For convenience, we will set these values ‚Äã‚Äãin static arrays.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we specify only the type of terrain based on the biome, you can also use it to determine other parameters. </font><font style="vertical-align: inherit;">Therefore, let's define a </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">structure </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that describes the configuration of an individual biome. </font><font style="vertical-align: inherit;">So far it contains only the relief index plus the corresponding constructor method.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use this structure to create a static array containing the matrix data. </font><font style="vertical-align: inherit;">We use the humidity as the X coordinate, and the temperature as the Y. Fill the lowest temperature line with snow, the second line with tundra, and the other two with grass. </font><font style="vertical-align: inherit;">Then we replace the driest column by the desert, redefining the choice of temperature.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrix of biomes with indices of a one-dimensional array.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biome Definition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to determine the </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cell's biome, we cycle around the temperature and humidity intervals to determine the matrix indices we need. </font><font style="vertical-align: inherit;">We use them to obtain the desired biome and set the type of cell relief.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // ‚Ä¶ // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief based on the biome matrix.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biome tuning </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can not be limited to biomes given in the matrix. For example, in the matrix all dry biomes are defined as sandy deserts, but not all dry deserts are filled with sand. There are many stony deserts that look very different. So let's replace some of the desert cells with stones. We will do this simply on the basis of height: the sand is at low altitudes, and above usually there are bare rocks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assume that the sand turns into stone when the height of the cell is closer to the maximum height than to the water level. This is the height line of stony deserts, which we can calculate at the beginning </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When we meet a cell with sand, and its height is large enough, we change the relief of the biome to stone.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandy and stony deserts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another change based on height is to force cells at maximum height into snow peaks, regardless of their temperature, only if they are not too dry. </font><font style="vertical-align: inherit;">This will increase the likelihood of snow peaks near the hot and humid equator.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Snow caps at maximum height.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plants </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's make the biomes determine the level of the plant cells. </font><font style="vertical-align: inherit;">To do this, add to the </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field of plants and include it in the constructor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the coldest and driest biomes there will be no plants at all. </font><font style="vertical-align: inherit;">In all other respects, the warmer and more humid the climate, the more plants. </font><font style="vertical-align: inherit;">The second column of humidity gets only the first level of plants for the hottest row, so [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">The third column increases the levels by one, with the exception of snow, that is, [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">And the wettest column again increases them, that is, it turns out [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Modify the array </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by adding the plant configuration to it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biome matrix with plant levels. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can set the level of plants for the cell.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomes with plants.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do plants now look different?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    ‚Äî (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can change the level of plants for biomes. </font><font style="vertical-align: inherit;">First, we need to make sure that they do not appear on the snow relief, which we could already adjust. </font><font style="vertical-align: inherit;">Second, let's increase the level of plants along the rivers, if it is not yet at its maximum.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Altered plants.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Underwater biomes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Up to this point, we completely ignored the underwater cells. </font><font style="vertical-align: inherit;">Let's add some variation to them and not use the texture of the earth for all of them. </font><font style="vertical-align: inherit;">A simple solution based on height will be enough to create a more interesting picture. </font><font style="vertical-align: inherit;">For example, let's use grass for cells with a height one step below the water level. </font><font style="vertical-align: inherit;">Let's also use grass for cells above the water level, that is, for lakes created by rivers. </font><font style="vertical-align: inherit;">Negative-height cells are deep-water areas, so we use stone for them. </font><font style="vertical-align: inherit;">All other cells remain land.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Underwater variability.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's add some more details for the underwater cells along the coast. These are cells that have at least one neighbor above the water. If such a cell is shallow, then we will create a beach. And if it is near a cliff, then it will be the dominant visual detail, and we use stone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To determine this, we will check the neighbors of the cells that are one step below the water level. Consider the number of connections by cliffs and slopes with adjacent cells, which are land.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can use this information to classify cells. </font><font style="vertical-align: inherit;">First, if more than half of the neighbors are land, then we are dealing with a lake or a bay. </font><font style="vertical-align: inherit;">For such cells we use grass texture. </font><font style="vertical-align: inherit;">Otherwise, if we have cliffs, then use a stone. </font><font style="vertical-align: inherit;">Otherwise, if we have slopes, then we use sand to create a beach. </font><font style="vertical-align: inherit;">The only remaining option is a shallow water area away from the coast, for which we still use grass.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variability of the coast. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a final touch, let's check that we do not have green underwater cells in the coldest temperature range. </font><font style="vertical-align: inherit;">For such cells use land.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We were able to generate randomly looking, rather interesting and natural maps with many configuration options. </font></font><br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-26/biomes/biomes.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 27: folding the map </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We divide cards into columns that can be moved. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We center the map in the camera. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We carry out folding of all. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this last part, we will add support for folding the map, connecting the eastern and western edges. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial created using Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folding makes the world go round.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folding cards </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our maps can be used to model areas of different sizes, but they are always limited to a rectangular shape. We can create a map of one island or a whole continent, but not the entire planet. Planets are spherical, they have no rigid boundaries that prevent movement on their surface. If you continue to move in one direction, then sooner or later you will return to the starting point. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We cannot wrap a grid of hexagons around a sphere, such an overlay is impossible. In the best approximations, the icosahedral topology is used, in which the twelve cells must be pentagons. However, without any distortions and exceptions, the mesh can be wrapped around a cylinder. To do this, simply connect the eastern and western edges of the map. With the exception of the wrapping logic, everything else remains the same.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cylinder is a bad approximation of the sphere, because we cannot model the poles. </font><font style="vertical-align: inherit;">But this did not prevent many game developers from using east-west folding to simulate maps of the planets. </font><font style="vertical-align: inherit;">The polar regions are simply not part of the gaming zone.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How about rolling north and south?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two ways to implement cylindrical folding. </font><font style="vertical-align: inherit;">The first is to actually make the map cylindrical, bending its surface and everything on it so that the eastern and western edges adjoin. </font><font style="vertical-align: inherit;">Now you will play not on a flat surface, but on a real cylinder. </font><font style="vertical-align: inherit;">The second approach is to save a flat map and use teleportation or duplication for folding. </font><font style="vertical-align: inherit;">Most games use the second approach, so we take it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optional folding </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The need for folding the map depends on its scale - local or planetary. </font><font style="vertical-align: inherit;">We can use the support of both, making the folding optional. </font><font style="vertical-align: inherit;">To do this, we will add a </font><font style="vertical-align: inherit;">new switch to the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menu </font><font style="vertical-align: inherit;">with minimization enabled by default.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu new map with the option of folding. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add in the </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field to track the selection, as well as a method to change it. </font><font style="vertical-align: inherit;">Let's make it so that when the state of the switch changes, this method is called.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When a new map is requested, we transfer the value of the folding option. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Change it </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it takes this new argument and then passes it on to </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ grid.CreateMap(x, z, wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code&gt; HexGrid needs to know if we are doing the folding, so we will add a field to it and force it </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to be set. </font><font style="vertical-align: inherit;">Other classes should change their logic depending on whether the grid is collapsed, so we will make the field general. </font><font style="vertical-align: inherit;">In addition, it allows you to set the default value through the inspector.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; ‚Ä¶ }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">causes its own </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in two places. </font><font style="vertical-align: inherit;">We can simply use its own field for the folding argument.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateMap(cellCountX, cellCountZ, wrapping); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The grid folding switch is on by default.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Save and Load </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since folding is set for each card, it must be saved and loaded. </font><font style="vertical-align: inherit;">This means that you need to change the format of the save file, so we will increase the version constant in </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When saving, let </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it simply record the boolean value of the folding after the size of the map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When loading we will read it only with the correct version of the file. </font><font style="vertical-align: inherit;">If it is different, then this is an old map and it should not be rolled up. </font><font style="vertical-align: inherit;">Save this information in a local variable and compare it with the current state of folding. </font><font style="vertical-align: inherit;">If it is different, then we cannot reuse the existing topology of the map in the same way as it would when loading a map with other sizes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folding metrics </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To fold the map, serious changes in logic will be required, for example, when calculating distances. </font><font style="vertical-align: inherit;">Therefore, they can touch code that does not have a direct reference to the grid. </font><font style="vertical-align: inherit;">Instead of passing this information as arguments, let's add it to </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Add a static integer containing the folding size that matches the width of the map. </font><font style="vertical-align: inherit;">If it is greater than zero, then we are dealing with a folding map. </font><font style="vertical-align: inherit;">To test this, add a property.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to set the size of the collapse at each call </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since this data will not survive the recompilation in Play mode, we will also set it in </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cell width </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When working with collapsible maps, we often have to deal with positions along the X axis, measured in cell widths. </font><font style="vertical-align: inherit;">Although it can be used for this </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it would be more convenient if we didn‚Äôt have to add multiplication each time. </font><font style="vertical-align: inherit;">So let's add a constant </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can already use the diameter in three places. </font><font style="vertical-align: inherit;">First, in </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when positioning a new cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when the position of the camera is limited.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And also in the </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversion from position to coordinates.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/wrapping-maps/wrapping-maps.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Map Centering </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the map is not folded, it has clearly defined eastern and western edges, and therefore a clear center horizontally. </font><font style="vertical-align: inherit;">But in the case of a folding card, everything is different. </font><font style="vertical-align: inherit;">It has neither east, nor western region, nor center. </font><font style="vertical-align: inherit;">Alternatively, we can assume that the center is where the camera is. </font><font style="vertical-align: inherit;">This will be useful because we want the map to always be centered relative to our point of view. </font><font style="vertical-align: inherit;">Then, wherever we are, we will not see either the east or west edges of the map.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Map Fragments Columns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for the map visualization to be centered relative to the camera, we need to change the placement of elements depending on the camera movement. If it moves to the west, then we need to take what is currently on the edge of the eastern part and move it to the edge of the western part. The same applies to the opposite direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ideally, as soon as the camera shifts to the adjacent column of cells, we should immediately move the farthest column of cells to the other side. However, we do not need to be so accurate. Instead, we can transfer the entire map fragments. This allows us to move parts of the map without having to change the meshes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we simultaneously move entire columns of fragments, let's group them together by creating a parent column object for each group. </font><font style="vertical-align: inherit;">Add an array for these objects in </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and initialize it in </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will use them only as containers, so we only need to track the link to their components </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As in the case of fragments, their initial positions are in the local grid origin.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the fragment should become a child of the corresponding column, not the grid. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments grouped into columns. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since all fragments have now become child elements of columns, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it‚Äôs enough to directly destroy all columns, not fragments. </font><font style="vertical-align: inherit;">So we get rid of the child fragments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teleport columns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new method </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with position X as a parameter. </font><font style="vertical-align: inherit;">Let's transform a position to a column index, dividing it by fragment width in units of Unity. </font><font style="vertical-align: inherit;">This will be the index of the column in which the camera is currently located, that is, it will be the center column of the map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is enough for us to change the map visualization only when the index of the central column changes. </font><font style="vertical-align: inherit;">So let's track it in the field. </font><font style="vertical-align: inherit;">We use the default value ‚àí1 and when creating the map so that new maps are always centered.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we know the index of the central column, we can determine the minimum and maximum indices by simply subtracting and adding half the number of columns. Since we use integer values, with an odd number of columns, this works perfectly. In the case of an even number of ideally centered columns can not be, therefore, one of the indices will be one step further than necessary. This creates an offset by one column in the direction of the farthest edge of the map, but for us this is not a problem.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that these indices may be negative or greater than the natural maximum index of a column. </font><font style="vertical-align: inherit;">The minimum is zero only when the camera is near the natural center of the map. </font><font style="vertical-align: inherit;">Our task is to move the columns so that they correspond to these relative indices. </font><font style="vertical-align: inherit;">This can be done by changing the local X coordinate of each column in the loop.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each column, we check if the index is less than the minimum index. </font><font style="vertical-align: inherit;">If so, it is too far left from the center. </font><font style="vertical-align: inherit;">He must teleport to the other side of the map. </font><font style="vertical-align: inherit;">This can be done by making its X coordinate equal to the width of the map. </font><font style="vertical-align: inherit;">Similarly, if the column index is greater than the maximum index, then it is too far to the right from the center, and must teleport in the other direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moving the camera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's change it </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that when working with a collapsible map, he instead </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">called </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">First, we simply make a new method </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duplicate </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but with the only difference: in the end it will call </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To make the map immediately centered, call the </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">method </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Move left and right while centering on the camera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although we still limit camera movement, the map is now trying to center relative to the camera, if necessary, teleport the columns of the map fragments. </font><font style="vertical-align: inherit;">With a small map and a distant camera, this is clearly visible, but on a large map, teleported fragments are outside the camera's view. </font><font style="vertical-align: inherit;">Obviously, only the original eastern and western edges of the map are visible, because there is no triangulation between them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to collapse the camera, remove the restriction of its X-coordinate </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, we will continue to increase the X coordinate by the width of the map until it is below zero, and decrease it while it is larger than the width of the map.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collapsible camera moves along the map.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collapsible shader textures </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the exception of the triangulation space, folding the camera in game mode should be imperceptible. However, when this occurs, a visual change occurs in half the relief and water. This happens because we use our position in the world to sample these textures. Sharp teleportation of the fragment changes the location of the textures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can solve this problem by arranging the textures to be arranged in tiles multiple to the size of the fragment. The fragment size is calculated from the constants in </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so let's create the include file for the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexMetrics.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">and </font><em><font style="vertical-align: inherit;">insert the</font></em><font style="vertical-align: inherit;"> appropriate definitions into it. The baseline tiling scale is calculated from the fragment size and the outer radius of the cell. If you use other metrics, you will need to change the file accordingly.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This gives us a tiling scale of 0.00866025404. </font><font style="vertical-align: inherit;">If we use an integer multiple of this value, then the fragment teleportation will not affect the texturing. </font><font style="vertical-align: inherit;">In addition, the textures on the eastern and western edges of the map will be seamlessly connected after we correctly triangulate their connection. </font><font style="vertical-align: inherit;">We used 0.02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as the UV scale in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Instead, we can use the double tiling scale, which is 0.01732050808. </font><font style="vertical-align: inherit;">The scale is slightly smaller than it was, and the scale of the texture has increased slightly, but visually it is imperceptible.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">for UV noise, we used a scale of 0.025. </font><font style="vertical-align: inherit;">Instead, you can use the triple tiling scale. </font><font style="vertical-align: inherit;">This gives us 0.02598076212, which is pretty close.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we used 0.015 for foam and 0.025 for waves. </font><font style="vertical-align: inherit;">Here again we can replace these values ‚Äã‚Äãwith a doubled and tripled scale of tiling.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); ‚Ä¶ } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/centering-the-map/centering-the-map.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connecting East and West </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, the only visual evidence of map folding is a small space between the most eastern and western columns. </font><font style="vertical-align: inherit;">This space occurs because we do not yet triangulate the connections of edges and angles between cells on opposite sides of the map without folding.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Space on the edge.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Folding neighbors </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To triangulate the east-west connection, we need to make cells on opposite sides of each other‚Äôs neighbors. </font><font style="vertical-align: inherit;">So far we are not doing this, because the </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ‚Äì W relationship is established with the previous cell only if its index in X is greater than zero. </font><font style="vertical-align: inherit;">To collapse this connection, we need to connect the last cell of the row with the first cell in the same row with the collapse map turned on.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having established the connection of the E ‚Äì W neighbors, we obtain a partial triangulation of the gap. </font><font style="vertical-align: inherit;">The connection of edges is imperfect, because the distortions are hidden incorrectly. </font><font style="vertical-align: inherit;">We will deal with this later.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ‚Äì W connections. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also need to collapse the NE ‚Äì SW links. </font><font style="vertical-align: inherit;">This can be done by connecting the first cell of each even row with the last cells of the previous row. </font><font style="vertical-align: inherit;">This will be just the previous cell.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NE ‚Äì SW connections. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the SE ‚Äì NW connections are established at the end of each odd line below the first. </font><font style="vertical-align: inherit;">These cells should connect to the first cell of the previous row.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SE ‚Äì NW connections.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Noise reduction </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to perfectly hide the gap, we need to ensure that on the eastern and western edges of the map there is a perfect match between the noise used to distort the vertex positions. </font><font style="vertical-align: inherit;">We can use the same trick used for shaders, but the noise scale is 0.003 for distortion. </font><font style="vertical-align: inherit;">To provide tiling, you need to significantly increase the scale, which will lead to a more chaotic distortion of the vertices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An alternative solution is not to damp noise, but to make a smooth attenuation of noise along the edges of the card. </font><font style="vertical-align: inherit;">If you perform a smooth attenuation along the width of a single cell, then the distortion will create a smooth transition without breaks. </font><font style="vertical-align: inherit;">The noise in this area will be slightly smoothed, and from a long distance the change will seem abrupt, but this is not so obvious when using a slight distortion of the vertices.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What about temperature fluctuations?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we do not fold the card, then we can do in a </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">single sample. </font><font style="vertical-align: inherit;">But when folding it is necessary to add attenuation. </font><font style="vertical-align: inherit;">Therefore, before returning the sample, save it in a variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When folding, we need to perform mixing with the second sample. </font><font style="vertical-align: inherit;">We will perform the transition in the eastern part of the map, so the second sample must be moved to the west side.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attenuation is performed using simple linear interpolation from the west to the east, over the width of one cell. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mixing noise, a non-ideal solution.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, we get a not quite exact match, because part of the cells on the east side has negative X coordinates. In order not to approach this area, let's move the transition area to the west by half the cell width.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correct attenuation.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editing cells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that the triangulation seems correct, let's make sure that we can edit everything on the map and on the folding seam. As it turns out, in teleported fragments, the coordinates are erroneous and large brushes are cut off with a seam.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brush cut.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To fix this, we need to report </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folding. We can do this by matching the X coordinate in the constructor method. We know that the axial X coordinate is obtained from the X coordinate of the offset by subtracting half the Z coordinate. You can use this information to perform the inverse transform and check if the coordinate of the zero offset is less. If so, then we have the coordinate for the eastern side of the unfolded map. Since in each direction we teleport no more than half of the map, it will be enough for us to add the size of folding to X once. And when the coordinate offset is larger than the size of the collapse, we need to perform subtraction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes when I edit the bottom or top of the map, I get errors. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This happens when, due to the distortion of the vertices, the cursor appears in a row of cells outside the map. </font><font style="vertical-align: inherit;">This is a bug that occurs because we do not match the coordinates in </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the parameter-vector. </font><font style="vertical-align: inherit;">This can be corrected by applying the method </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with coordinates as parameters, which will perform the necessary checks.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coast collapse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation works well for relief, but along the east-west seam there are no edges of the coast. </font><font style="vertical-align: inherit;">In fact, they are, they just do not fold. </font><font style="vertical-align: inherit;">They are flipped and stretched to the other side of the card.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Missing water edge. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This happens because we use the position of a neighbor when triangulating the water of the coast. </font><font style="vertical-align: inherit;">To fix this, we need to determine that we are dealing on the other side of the map. </font><font style="vertical-align: inherit;">To simplify the task, we will add the </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property for the cell column index.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assign this index to </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It simply equals the coordinate of the X offset divided by the fragment size.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determine what collapses by comparing the column index of the current cell and its neighbor. </font><font style="vertical-align: inherit;">If the index of the neighbor's column is less than one step less, then we are on the west side, and the neighbor is on the east side. </font><font style="vertical-align: inherit;">Therefore, we need to move the neighbor to the west. </font><font style="vertical-align: inherit;">Similar and with the opposite direction.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ribs of the coast, but no corners. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we took care of the edges of the coast, but so far we have not dealt with the corners. </font><font style="vertical-align: inherit;">We need to do the same with the next neighbor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properly folded coast.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Card generation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The option of connecting the east and west sides affects the generation of maps. </font><font style="vertical-align: inherit;">When the map is minimized, the generation algorithm must also be minimized. </font><font style="vertical-align: inherit;">This will create another map, but when using a non-zero </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map Border X,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> folding is not obvious.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Large map 1208905299 with default settings. With and without folding.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When minimized it does not make sense to use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Map Border the X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But we can not just get rid of him, because in this case the regions will merge. When minimized, we can simply use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder instead</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Change </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, replacing in all cases </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This new variable will be either </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, depending on the value of the minimize option. Below I have shown the changes only for the first case.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, the regions remain separate, but this is necessary only if there are different regions on the east and west sides of the map. </font><font style="vertical-align: inherit;">There are two cases when this is not respected. </font><font style="vertical-align: inherit;">The first is when we have only one region. </font><font style="vertical-align: inherit;">The second is when there are two regions separating the map horizontally. </font><font style="vertical-align: inherit;">In these cases, we can assign a </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value of zero, which allows the land masses to cross the east-west seam.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One region of folding. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first glance, it seems that everything is working correctly, but there is actually a gap along the seam. </font><font style="vertical-align: inherit;">This becomes more noticeable if you assign a </font><font style="vertical-align: inherit;">zero value </font><font style="vertical-align: inherit;">to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erosion Percentage</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the erosion is turned off, the seam on the relief becomes noticeable.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A rupture occurs because the seam prevents the growth of relief fragments. To determine what is added first, the distance from the cell to the center of the fragment is used, and the cells on the other side of the map can be very far away, so they almost never turn on. Of course, this is wrong. We need to make sure that </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">he knows about the folding map. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We calculate the distance between </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, summing the absolute distances along each of the three axes and halving the result. The Z distance is always true, but folding can affect the X and Y distances. So let's start with a separate calculation of X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determining whether folding creates a smaller distance for arbitrary cells is not a simple task, so let's just calculate X + Y for cases when we fold another coordinate to the west side. </font><font style="vertical-align: inherit;">If the value is less than the original X + Y, then use it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If this does not lead to a shorter distance, then there is a possibility of folding shorter in another direction, so check it out. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we always get as a result the shortest distance on the collapsible map. </font><font style="vertical-align: inherit;">Relief fragments are no longer blocked by a seam, which allows the land masses to curl.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properly rolled relief without erosion and with erosion. </font></font></i> <br><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/connecting-east-and-west/connecting-east-and-west.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traveling around the world </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Having considered the card generation and triangulation, let's now move on to checking units, research and visibility. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Investigated seam </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first obstacle that we encounter when moving a detachment around the world is the edge of the map that cannot be explored. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Card seam cannot be explored. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cells along the edge of the map are made unexplored to hide the abrupt completion of the map. </font><font style="vertical-align: inherit;">But when the map is minimized, only the northern and southern cells should be marked, but not the eastern and western cells. </font><font style="vertical-align: inherit;">Change </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to take this into account.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibility of relief objects </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's check if visibility is working right along the seam. </font><font style="vertical-align: inherit;">It works for the relief, but not for the objects of the relief. </font><font style="vertical-align: inherit;">It seems that the collapsed objects get the visibility of the last cell that was not collapsed.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incorrect visibility of objects. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This happens because the clamping mode </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is set </font><font style="vertical-align: inherit;">for the texture folding mode </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To solve a problem, just change its clamp mode to repeat. </font><font style="vertical-align: inherit;">But we need to do this only for the U coordinates, so </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will set </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separately.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Squads and columns </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another problem is that the units are not collapsing yet. </font><font style="vertical-align: inherit;">After moving the column in which they are located, the detachments remain in the same place.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The detachment is not transferred and is on the wrong side. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This problem can be solved by making the units the children of the columns, as we did with the fragments. </font><font style="vertical-align: inherit;">First, we will no longer make them the immediate children of the grid in </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the units move, they may end up in a different column, that is, their parent will need to change. </font><font style="vertical-align: inherit;">To make this possible, we add it to the </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">general method </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and as parameters, we will give it a component of the </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">child element and an index of the column.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will call this method when the property is set </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This solves the problem with the creation of units. </font><font style="vertical-align: inherit;">But we also need to make them move to the right column when moving. </font><font style="vertical-align: inherit;">To do this, you need to track the </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index of the current column. </font><font style="vertical-align: inherit;">At the beginning of this method is the index of the cell column at the beginning of the path, or the current one, if the movement was interrupted by recompilation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> During each iteration of the move we will check if the index of the next column is different, and if so, change the parent of the squad. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will allow units to move in the same way as fragments. </font><font style="vertical-align: inherit;">However, while moving through the seam of the map, the detachments do not yet collapse. </font><font style="vertical-align: inherit;">Instead, they suddenly begin to move in the wrong direction. </font><font style="vertical-align: inherit;">This happens regardless of the location of the seam, but most noticeably when they jump across the entire map.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Racing through the map. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we can use the same approach that was used for the coast, only this time we will fold the curve along which the detachment moves. </font><font style="vertical-align: inherit;">If the next column is turned east, we will teleport the curve to the east too, similarly for another direction. </font><font style="vertical-align: inherit;">You need to change the control points of the curve </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will also affect the control point </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movement with folding.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The last thing to do is to change the initial turn of the squad when it looks at the first cell to which it moves. If this cell is on the other side of the east-west seam, the unit will look in the wrong direction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When folding a map, there are two ways to look at a point that is not exactly located in the north or south. You can look either to the east or to the west. It will be logical to look in the direction corresponding to the closest distance to the point, because it is also the direction of motion, so let's use it in </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When folding, we will check the relative distance along the X axis. If it is smaller than the negative half of the width of the map, then we must look to the west, which can be done by turning the point to the west. </font><font style="vertical-align: inherit;">Otherwise, if the distance is more than half the width of the map, then we must roll up to the east.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have a full-featured map with folding. </font><font style="vertical-align: inherit;">And with this we complete the series of tutorials on hexagon maps. </font><font style="vertical-align: inherit;">As mentioned in the previous sections, other topics may be considered, but they do not relate specifically to hexagon maps. </font><font style="vertical-align: inherit;">Perhaps I will consider them in future series of tutorials.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I downloaded the last package and get turn errors in Play mode</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I downloaded the last package and the graphics are not as beautiful as in the screenshots.</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I downloaded the last packet and it constantly generates the same card.</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://catlikecoding.com/unity/tutorials/hex-map/part-27/traveling-around-the-world/traveling-around-the-world.unitypackage" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitypackage</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/427567/">https://habr.com/ru/post/427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427555/index.html">Animals that humans have learned to track using face recognition technology</a></li>
<li><a href="../427557/index.html">IT digest of November events (part one)</a></li>
<li><a href="../427561/index.html">The right to repair: the first steps in the right direction from Motorola</a></li>
<li><a href="../427563/index.html">The standard Encrypted SNI is implemented in Firefox Nightly</a></li>
<li><a href="../427565/index.html">‚ÄúMy achievement was that I generally returned to the profession‚Äù - 10 questions for a programmer, issue 10</a></li>
<li><a href="../427569/index.html">OpenStack fine tuning under high load</a></li>
<li><a href="../427571/index.html">Union R and PostgreSQL. We analyze the work of airports, calculate pensions.</a></li>
<li><a href="../427573/index.html">Candy or life: Halloween as a reason to attract a child to science</a></li>
<li><a href="../427575/index.html">Why Wi-Fi will not work as planned, and why know which employee uses the phone</a></li>
<li><a href="../427577/index.html">Machine learning vs signature analysis when detecting attacks on a web application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>