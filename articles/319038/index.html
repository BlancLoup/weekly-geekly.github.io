<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Isomorphic React Applications: Performance and Scaling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Denis Izmaylov ( DenisIzmaylov ) 
 Hello! Briefly tell about yourself. I am Denis Izmailov. For the past 5 years, he has focused on JS development, ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Isomorphic React Applications: Performance and Scaling</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/57e/bae/9df/57ebae9df6df80cd75203199b3bf5969.jpg"><br><br><h2>  Denis Izmaylov ( <a href="https://habrahabr.ru/users/denisizmaylov/" class="user_link">DenisIzmaylov</a> ) </h2><br>  Hello!  Briefly tell about yourself.  I am Denis Izmailov.  For the past 5 years, he has focused on JS development, has done a lot of Single Page Application, highload, React, spoke at MoscowJS several times, kammitil webpack, etc. <br><br>  Today I would like to talk about this: why the Single Page Application in its classic form should be abandoned;  how isomorphic applications will affect your salary;  and what will you do this weekend? <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/cf2/3dc/de2/cf23dcde26da6fbde468ed3dba95e74e.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It would be ideal if you already had some experience with React 14, with a webpack, understood how ES6 works, did something with express / koa, and at least vividly imagine what isomorphic applications are, they are universal. <br><br>  Part 1. <br><br>  The web has become very big.  Now the development of a web has become a fine line between science and art. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d2/5fa/e2c/8d25fae2c469317dc9a6ae935f12c371.png"><br><br>  Previously, it was quite simple: I made some kind of script on the server, added a couple of JS and sent it to the production, everything worked. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b46/279/9e6/b462799e626d5331e5eef826976ec6a9.png"><br><br>  The browser made a request to the server, and the server did absolutely everything, and gave some HTML page. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/4a3/7ef/bb54a37efad283de54d13916b96cb450.png"><br><br>  CSS, JS - it was optional, practically not necessary.  It worked.  But then began to stand out Single Page Application (SPA). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/f70/d64/43ef70d640cae2ef2763127a1a8ff60a.png"><br><br>  The code on the client began to grow.  The server has already begun to play a small role.  It was literally checked whether we have a page, is authorization necessary, do we have access to it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/290/f7d/1aa/290f7d1aa74e7150d59442f74a800cdc.png"><br><br>  And the server gave already small HTML, CSS and huge JS bundle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/680/f48/04b/680f4804b3a01adc4d6a854a0ffb04cd.png"><br><br>  The advantages here are quite large, i.e.  easy to start writing - looked at the webpack report, set up, made a little HTML, connected Redux, React, and it all worked. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce2/b18/129/ce2b181291a36c4b5cabdcfdce5c9c1e.png"><br><br><ul><li>  Rich functionality.  We all load immediately in the case of Single Page, and we do not need to worry about the fact that we do not have something.  We can include absolutely anything there - pictures, images, we can even shove a video inside the bundle, and this will work. <br></li><li>  It is easy to finalize it quickly - we don‚Äôt have to worry about any optimization, everything works fine, everything is super, everything is cool, we can just add-add-add. <br></li><li>  Responsive UI - accordingly, everything is loaded with us, and there is no need to reload anything. <br></li><li>  This is all very convenient to cache.  When we downloaded a bundle once, we already have it always cached in the browser and next time it loads quickly. <br></li></ul><br>  And not one minus?  Cons, there is. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/080/0f8/41f/0800f841fdb359c51e10c560e8010043.png"><br><br>  Firstly, due to the fact that the bundle is very large, sometimes it reaches 3-5 MB, it takes a very long time to load it for the first time.  Those.  Often, when you go to the site for the first time, to a resource of some kind, or after updating to the past, we see a wheel, which many do not like.  So  The first call to the application takes a long time.  This is also not done quickly.  And the memory is eating well. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db7/e93/c93/db7e93c93d14a3ac7e9023f04b325450.png"><br><br>  Difficulty of support.  Who supported the large Single Page Application applications, he knows that often some plugins that we add to some, even individual pages, can affect any other pages.  Those.  we cannot control this.  And memory leak.  Few people tested it, but when the application is large and it works long in the tab, it often happens that the memory grows and for some reason everything starts to hang.  3-4 hours have passed and ... But we do not test, as a rule. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc7/242/99f/dc724299fcb05eb1b6bcbe9fc5c9d6f1.png"><br><br>  Accordingly, long download, support complexity, a blank page, one url (I will explain later why this is a minus) and old browsers.  We recently conducted research and watched that even now in our 2015-2016 year, it would seem that all browsers should have been updated, but no.  5% is the 12th Opera and 7-8th IE, and the 6th is even present.  Just last week watched. <br><br>  Are these cons?  For business, it is cons. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d0/e11/372/6d0e113727562bf24d46653aef625b6a.png"><br><br>  Long loading is the loss of UX, in which big money is invested.  The difficulty of support is risk.  These are risks as not to meet the deadline, and get out of the budget.  A blank page is SEO problems.  Here, many may have such an objection: there are pre-vendors, our Angular application can be easily rendered in advance.  But this is essentially a hack.  There are very few opportunities in this regard.  1 URL is an SMM problem.  SMM - this means that the user can not easily share your page on social networks, it will lead to one page.  And accordingly, if this page does not turn out on the old browser, then if you do not have polyphiles, which many now refuse, then the person on the old browser in these 5% will see a blank page.  All this for business expenses. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/946/d1f/b59/946d1fb599a191391eadf3debdd19614.png"><br><br>  What to do?  We can now take the best of these two worlds and do it in the form of isomorphic applications. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cd/868/50d/4cd86850d6f08aacfbe7e6637cd6d342.png"><br><br>  In 2011, Charlie Robbins formulated it in such a way that by isomorphic we mean the code in which each line taken can be executed both on the server and on the client.  With a few exceptions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b45/6bd/5c9/b456bd5c962cf6cba438c567eee7e8f2.png"><br><br>  Here it is very important to focus and understand now, because the question arises: how to divide and how to organize isomorphic applications?  I tried to formulate in such a way that these parts are templates, services, static files, Actions, Reducers, it is absolutely universal in us, and small starting things can be a client file, or an admin, i.e.  what the router initializes - we can already have it for the server part, ours for the client part. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd3/bd7/55b/dd3bd755b016818f6b6e30b0ec9cfb06.png"><br><br>  It all looks like this, that we have a browser, there is a front-end server (it is allocated separately), and there is an old familiar back-end server.  It may even be a database without any server.  The browser accesses the front-end server, it can go for data somewhere to the old server or to the database, get the data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfb/597/ce6/cfb597ce68f019227ee402e372a1f85a.png"><br><br>  Further, it can generate full HTML, render some critical CSS, which is needed only for rendering this page, and not, as is the case with SPA, for rendering the entire application, which you may well need. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/098/ef6/161/098ef6161eb5ee058ae00cf80cb84260.png"><br><br>  And at the end give JS bundle.  At this point, we will have a front-end client assembled on the client side and raised, which in turn can further communicate with the previous backend server, say, through the RESTful API. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b22/cd2/467/b22cd2467daf97dc889358575706fc20.png"><br><br>  So, we have a unified execution environment, a common code base and full control, because when we have a backend server, for example, in Java, the front-end developer is problematic enough to affect or push any changes to the server.  And again, we have an ecosystem, i.e.  node package manager. <br><br>  How to implement it in life?  Via Sever-Side Rendering. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d8/049/c24/5d8049c24eb9836667f698c03d181659.png"><br><br>  The point is that we build at Server-Side Rendering, the entire application is built on React, for example, on the front-end server, on Node.js.  At the same time, we get an instantaneous mapping, i.e.  we have rendered the application, we immediately get it in the form of HTML - even before loading JS.  And the user sees it instantly.  Those.  at the first appeal.  And when JS is loaded, React will simply add event handlers, and all this happens quite quickly. <br><br>  The code on the server side looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37b/812/e55/37b812e55d2c95c27c75628a73e17873.png"><br><br>  Those.  we have a certain React'ovskiy renderer, this is already the 14th version, and that is our application.  Those.  this is compiled into a string and given.  It is clear that all the routes are already wrapped inside the application, because  we have the same code to be executed, we already know that we have some way, something we need to display for this way, we will have the tree we need displayed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd2/5ce/320/cd25ce320c9d3ac1dea7c9a7f7c4018d.png"><br><br>  In the end, what do we have?  The user instantly sees the page, and we do not have any additional requests for receiving data, because to display it, we already have all the data collected and put inside, where necessary.  And the page can be launched even without JS.  It is very important to work on the same legasy browser of that 5%.  Let them have something there will not function as cool as it is now on the last chrome, but it will more or less work.  And full URL navigation, and at the same time, meta tags, i.e.  This is all that will allow us (for grocery stories this is especially important) to fumble, share some links to individual pages much more efficiently than it is now with the hash.  And at the same time, we have the preservation of all the opportunities relevant to JS that we have. <br><br>  Part 2. Performance and scaling.  Scaling is not about load performance, but about functional scaling - how we will grow. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/452/5ac/52e4525ac3efcf3ada0dc4e8b8b5ba31.png"><br><br>  In the case of Server-Side Rendering, everything is super when we already have all the data.  Everyone understands that Node.js is a single-threaded story, because  as usual JS and, accordingly, everything is super when we have data, and we can draw all this in one stream. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/939/07c/41d/93907c41dda52f73d95ce46717ee0fda.png"><br><br>  But what if we need this data?  To do some kind of request at the same time, we do not have the right to block the thread, the current event loop. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/531/482/178/531482178819d2c6d9841f69ff1e3844.png"><br><br>  Here we have three main ways: remove the necessary data manually and then return it as to the incoming state;  use Facebook Relay;  and I developed a plugin for redux-catch-promise. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/433/752/a0e4337521780e4038d9f1be25227e8d.png"><br><br>  Manually for each page - everything is simple enough, we get state from the base and then just give it to renderToString.  Nothing changes with us, but in this case we have to invent for each page, but how will we get this data to the server?  We can no longer just take and add a page, we will have to somehow extract this data, climb, enter additional entities into the project.  Also not always convenient. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ef0/b72/40bef0b72f38f7e82bc9f23278f00d8d.png"><br><br>  Facebook Relay, which they presented a few months ago, is a framework that allows you to declare specific requests for data in the components.  There's quite an interesting story, i.e.  you declaratively specify the request, what data you need, the conditions that they are tied.  Relay accumulates all this data and then immediately throws it to the server, and you get it all at once.  Those.  this happens batching requests, which we talked about.  The only problem is that this is not yet available on the server, i.e.  server-side, but in the first quarter of 2016, Facebook promises to realize this, and everything will work.  There is a link to GitHub issues, you can watch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56f/1d0/d74/56f1d0d746a84d6902d61b1f3afcaa1b.png"><br><br>  Redux-catch-promise is a small life project that I did working for one project.  What is Redux?  I told on MoscowJS about him.  This is the state container for React.  In essence, this is a replacement for Flux, a much more successful replacement is shown.  Link to the speech is.  Redux-catch-promise is middleware, i.e.  plugin for redux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a56/7cc/4d7/a567cc4d7f338059779b59e4b0a93b07.png"><br><br>  What is he doing?  We hang up a callback to capture Promise actions in the stream and render the application.  When rendering a component, we make a request, i.e.  we send the action to receive the data and give it a reply Promise.  This Promise we catch at the top level, where we render the application, and as a result we get a collection of Promisees.  Having waited for its permission, we render again application with the obtained data.  It turns out quite comfortably, a kind of compromise between manual receipt and what is now implemented in Relay. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b05/35f/295/b0535f2953dfa42061842732d73bf1e8.png"><br><br>  The link to GitHub here, there is an example, maybe a bit outdated, everything is changing very quickly. <br><br>  Performance - the second part. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f18/92c/79a/f1892c79ab87ab9781647d65a5b2646f.png"><br><br>  When they began to see how quickly Server-Side is rendered on a regular MacBook ... <br><br>  To understand it - the page takes 56 KB, it looks literally in 4 screens, a small profile ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/103/e32/877/103e32877bcf2152ae8c0e48c701fecd.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/490/950/0e1/4909500e1ee732902ef71ee362ca2bd8.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/b1c/af4/258b1caf4bf00b1cae8a4ea1c9170419.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d1/e7b/706/9d1e7b7069a57e502b3c0de4a8f41d7f.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/79c/107/69e/79c10769e0d09b909492c7af7fe058d2.png"><br><br>  With all the data, take ab testing, the request is complete.  Has left 61 msec. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/415/908/8b3/4159088b384b24c3f5188cbc13c32c62.png"><br><br>  A little bit incomprehensible, it‚Äôs a lot or a little.  Let's say the same one, if we do Hendlebars, it will be 8 ms. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/254/431/47e/25443147ead22f2ab9d5c68a45439913.png"><br><br>  I think the difference is more obvious, not super. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/6d7/764/43b6d77641b6883182fec5a85c466f00.png"><br><br>  We start to look for something, we look, we go to Google - there is nothing concrete there.  We try to ask Twitter, too, everyone is silent, retweets, but we do not find any answers. <br><br>  At the same time, we will try to put NODE_ENV in production. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/7df/dc1/9e17dfdc16d95c2b98417a8294fea9ef.png"><br><br>  Run and - bang!  - almost twice as fast.  Great, interesting.  It seems better, but still not a cake. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/285/9bc/f89/2859bcf8989d36e09f046e7330b54a7f.png"><br><br>  Go ahead.  Let's see, let's get into GitHub issues. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64e/c86/74d/64ec8674dd02a2699825fcc6da5e21f3.png"><br><br>  Let's find the interesting such ‚ÄúServer rendering is slower with npm react‚Äù.  There is given the decision that you need to connect, and not just import the react, connect the file explicitly react.min.js. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9cc/959/49f/9cc95949f2d380b0629c991d642ca406.png"><br><br>  Ok, let's try.  Let's create some node_modules for the test.  For cleanliness we will do this.  Here we obviously use min.js in the case of production.  And in the end, how did this change the result?  We start. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c7/d82/16c/6c7d8216ce781e7d0d73bc3d83edef29.png"><br><br>  It turned out even slower. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2e/8eb/38b/b2e8eb38b61aedeb95c98c02e1dec3a4.png"><br><br>  Slide that test failed. <br><br>  As it turned out, that advice worked well for React's past, but for the 14th, it does not work.  The overall picture looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e0/5c5/b4e/9e05c5b4ee21969278af72e27df402ba.png"><br><br>  Those.  8 ms is occupied by Hendlebars, all the rest is, in fact, if we specify production, and purple - if we use js min.  Only 39% less. <br><br>  Any further global research - no hack in Server-Side Rendering, we will not see.  At the level of React, there is no place to optimize it all, for now.  There are only enough hardcore ways. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3db/a5d/a02/3dba5da028831b72ddc484bb9e7d3e2b.png"><br><br>  If you globally divide this, then use some Precompilation and Cache, this is split Rendering.  And use the recently released React DOM Stream plugin.  Using Facebook BigPipe is a very interesting extension from Facebook that has long been used.  And HAProxy is more to devops, other sections of the report. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/e34/e72/110e34e72cebc3e9202383fa308d0724.png"><br><br>  What is the essence of Precompilation?  In fact, if we start from the fact that the UI is the result of performing a certain function of state - f (state), where f is React Component, and state is, maybe, let's say, only the way, if it is site or tree of pages, or it may be tied to something else.  We can quite easily cach our HTML that we render using this key. <br><br>  A simple solution is to simply use redis.  If we need to have a quick response right away, we can use redis, plus queues, plus workers.  Those.  we show some kind of castor, we do partial loading, and in the background we have workers render our component with each request.  Here we get where First render, what we have, in fact, in this case, the page will be given instantly, everything will be rendered in our background, and with the next request we can already give the cached part of the components. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/a80/2c0/73ea802c08ebecf4563cb4750096fe03.png"><br><br>  Rendering Separation.  Linkedin conducted research, and they observed that most of their pages (long, especially) do not need full server rendering, it suffices to show only the first part - the visible one.  And we can add all the rest separately, for example, client JS.  And in most cases their clients saw only the first part, no one scrolled, i.e.  Thus, we can render the first part on the server and immediately give it away, and the next part can be programmatically downloaded via JS.  This gives a fairly large advantage in performance and in resources. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/040/a6d/bac/040a6dbac29d230e7e4679753d9bd08d.png"><br><br>  React DOM Stream is the next extension - this is a recently published project.  The man (aickin) forked React and implemented a technology of premature dumping there, like http usual, i.e.  you render-render, and then all at once gives.  In this case, he was able to implement the technology, when you immediately as the component is being rendered, and not in the form of html-code, they are dropped into the stream server.  It turns out quite an interesting performance effect.  The time to the first byte is reduced already by 65%, i.e.  this is almost 2 times, and to the last byte - by 37%.  If we combine these two approaches, it turns out quite well ... The only negative thing that affected React itself was that it needed to be slightly modified, so it uses fork there, and this is not the React that is official.  There is a discussion about this now, you can observe, it will be ready soon. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/1f1/177/43e1f1177c61902520483111fcf8cfec.png"><br><br>  Facebook BigPipe.  Very cool extension.  They made it a long time ago, 2-3 years ago.  This is when the page is assembled during the loading process.  Those.  we are loading everything in parallel, which makes us error resistance.  The point is this: we have a page, and it has certain parts that we can select and load already in the process.  Those.  In the process of loading the page, we form a call for JS, CSS required for these blocks, and our data is loaded by itself through some json pipe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4d/1ba/d59/f4d1bad590ec5baceee905f59ca4b72c.png"><br><br>  It turns out that when we first render we see this almost full page.  We can even see something important, like Yandex, for example, does.  In Yandex, when you enter a search phrase, press enter, you will first display the top toolbar with your query, and only then will the upload results be loaded.  Here the process is depicted. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c85/a8e/0e0/c85a8e0e06e0b0da9e6a9abf6979f4bd.png"><br><br>  HAProxy.  This is a little about DevOps, but I think everyone now has access to a DevOps specialist, or else you can configure something yourself.  The essence is that on the production it is better to raise several nodes and to circulate between them. <br><br>  In conclusion, I want to bring some useful materials: <br><br><ol><li>  Supercharging page load (100 Days of Google Dev) <a href="https://youtu.be/d5_6yHixpsQ">https://youtu.be/d5_6yHixpsQ</a> </li><li>  Making Netflix.com Faster <a href="http://techblog.netflix.com/2015/08/making-netflixcom-faster.html">http://techblog.netflix.com/2015/08/making-netflixcom-faster.html</a> </li><li>  New technologies for the new LinkedIn home page <a href="https://engineering.linkedin.com/frontend/new-technologies-new-linkedin-home-page">https://engineering.linkedin.com/frontend/new-technologies-new-linkedin-home-page</a> </li><li>  Improving performance on twitter.com <a href="https://blog.twitter.com/2012/improving-performance-on-twittercom">https://blog.twitter.com/2012/improving-performance-on-twittercom</a> </li><li>  Scaling Isomorphic Javascript Code <a href="https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/">https://blog.nodejitsu.com/scaling-isomorphic-javascript-code/</a> </li><li>  From AngularJS to React: The Isomorphic Way <a href="https://blog.risingstack.com/from-angularjs-to-react-the-isomorphic-way/">https://blog.risingstack.com/from-angularjs-to-react-the-isomorphic-way/</a> </li><li>  Isomorphic JavaScript: The Future of Web Apps <a href="http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/">http://nerds.airbnb.com/isomorphic-javascript-future-web-apps/</a> </li><li>  React server side rendering performance <a href="http://www.slideshare.net/nickdreckshage/react-meetup">http://www.slideshare.net/nickdreckshage/react-meetup</a> </li><li>  The Lost Art of Progressive HTML Rendering <a href="https://blog.codinghorror.com/the-lost-art-of-progressive-html-rendering/">https://blog.codinghorror.com/the-lost-art-of-progressive-html-rendering/</a> </li></ol><br>  And as a recommendation, join the MoscowJS community and stay tuned. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2be/3bf/ecc/2be3bfeccda9c2bf4ff4317dbf177f75.png"><br><br>  There we constantly have something interesting happening. <br><br>  The most important thing is to improve English, come to the English-language reports and "do not read Soviet newspapers."  Read the originals and technical blogs.  Let's say the same companies - Linkedin, Facebook, Netflix - they write very actual things.  On Twitter, you can always see all these announcements.  And Twitter, GitHub now are probably the main things with which you can keep abreast and understand what is happening in the world of frontend. <br><br>  I want to give two quotes that I really liked in this regard: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d1/c77/438/0d1c77438daf1c3b23d0f1c64b6af90f.png"><br><br>  "Most of the problems of algorithms can be solved by changing the data structure."  This is Andrei Sitnik said in one of the releases of RadioJS.  And in one of the videos: ‚ÄúChanges is our work‚Äù, i.e.  change is our job.  This is jake from google said. <br><br>  I hope, I have now answered the question why the classic Single Page Application should be abandoned and where it is worth moving.  This is actually not as difficult as it seems, and I urge you to move further in this direction. <br><br><h3>  Contacts </h3><br>  ¬ª <a href="https://habrahabr.ru/users/denisizmaylov/" class="user_link">DenisIzmaylov</a> <br>  ¬ª <a href="https://github.com/DenisIzmaylov">Github</a> <br>  <a href="https://twitter.com/denisizmaylov">Twitter</a> <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the conference of developers of high-loaded systems <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad ++ of the</a> special section <strong>"</strong> <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">Frontend</a> <strong>performance"</strong> .</font> <font color="gray"><br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> <font color="gray"><br><br></font>  <font color="gray">Well, the main news is that we have begun preparations for the spring festival " <a href="http://ritfest.ru/">Russian Internet Technologies</a> ", which includes eight conferences, including <strong>Frontend Conf</strong> .</font>  <font color="gray">This is a professional <a href="http://frontendconf.ru/">conference</a> for developers of high-load systems.</font>  <font color="gray">And Denis, by the way, is on her Program Committee.</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/319038/">https://habr.com/ru/post/319038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319028/index.html">Results: which is stronger - assembler or habraeffekt?</a></li>
<li><a href="../319030/index.html">Segmentation as it is. Part 2</a></li>
<li><a href="../319032/index.html">Difficulties in modeling operations in standard ways. Modeling 4-objects, problem statement</a></li>
<li><a href="../319034/index.html">Infrastructure simple electronic signature. Part 2: Target System Modeling</a></li>
<li><a href="../319036/index.html">Comparison of lock-free algorithms - CAS and FAA on the example of JDK 7 and 8</a></li>
<li><a href="../319040/index.html">Effective calculation of the field of view and the line of sight in games</a></li>
<li><a href="../319042/index.html">Recognize checks in Google Docs using the ABBYY OCR SDK</a></li>
<li><a href="../319048/index.html">Hadoop From Scratch</a></li>
<li><a href="../319050/index.html">Galois field on Scala</a></li>
<li><a href="../319052/index.html">NoSQL - briefly about the main thing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>