<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to Shader Programming: Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having mastered the basics of working with shaders, we will try to practice to curb all the power of the GPU, creating a system of realistic dynamic l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to Shader Programming: Part 3</h1><div class="post__text post__text-html js-mediator-article">  Having mastered the basics of working with shaders, we will try to practice to curb all the power of the GPU, creating a system of realistic dynamic lighting. <br><br><img src="https://habrastorage.org/files/fb6/77e/691/fb677e69164540a098cfeea507d29795.jpg"><br><a name="habracut"></a><br>  In the first lesson of this series we covered the basics of <a href="http://gamedevelopment.tutsplus.com/ru/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313">creating graphic shaders.</a>  In the second, we studied the <a href="https://habrahabr.ru/company/plarium/blog/281599/">general algorithm of actions</a> when setting up shaders for any platform.  Now it's time to understand the basic concepts from the field of graphic shaders without reference to the platform.  For convenience, we will still use JavaScript / WebGL in the examples. <br><br>  Before moving forward, make sure that you choose the most convenient way to work with shaders.  The easiest option would be javascript / webgl, but I recommend trying your hand at your favorite platform. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Goals</b> <br><br>  By the end of this lesson you will not only be able to boast a deep understanding of the principle of operation of lighting systems, but also create such a system yourself from beginning to end. <br><br>  This is what the final result will look like ( <a href="http://codepen.io/tutsplus/pen/RPYbqp">go to CodePen</a> to switch the lighting): <br><br><img src="https://habrastorage.org/files/00d/2d9/04a/00d2d904a3ad401281fca43185b9c810.png"><br><br>  Despite the fact that ready-made lighting systems are built into many game engines, understanding their creation will help you apply more flexible settings and make your game more unique.  The role of shader effects should not be reduced to a purely decorative: they can be used to create new game mechanics. <br><br>  An excellent example of dynamic lighting is the <a href="http://iamclaw.com/%3Fpage_id%3D15">Chroma</a> game: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/G8-ivm3iuKc%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh9vvuzU9CWjW7eaWbLOZZBuFQH8g" frameborder="0" allowfullscreen=""></iframe><br><br>  <b>Getting Started: starting scene</b> <br><br>  We will skip most of the preparations, since all of this was covered in the previous lesson.  Let's start with a simple fragmentary shader with a texture: <br><br><img src="https://habrastorage.org/files/5c3/12b/d47/5c312bd4782847aeacf61b0f3b3903e8.png"><br><br>  So far, nothing special.  JavaScript code sets the scene settings and sends the texture to the render, and the screen settings to the shader. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = { <span class="hljs-attr"><span class="hljs-attr">tex</span></span> : {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-attr"><span class="hljs-attr">value</span></span>:texture},<span class="hljs-comment"><span class="hljs-comment">//The texture res : {type: 'v2',value:new THREE.Vector2(window.innerWidth,window.innerHeight)}//Keeps the resolution }</span></span></code> </pre> <br><br>  Declare variables in GLSL code: <br><pre> <code class="javascript hljs">uniform sampler2D tex; uniform vec2 res; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main() { vec2 pixel = gl_FragCoord.xy / res.xy; vec4 color = texture2D(tex,pixel); gl_FragColor = color; }</code> </pre><br><br>  It is necessary to adjust the coordinates of the pixels before using them to draw textures. <br>  But first, let's do the following task to warm up. <br><br>  <b>Task:</b> Will you manage to display the texture, keeping its proportions?  Try to do it yourself before proceeding to the solution below. <br><br>  The reason why the texture is stretched is quite obvious.  But here's a little hint: take a look at the line in which the coordinates are adjusted: <br><br><pre> <code class="javascript hljs">vec2 pixel = gl_FragCoord.xy / res.xy;</code> </pre><br><br>  We divide vec2 by vec2, which is similar to dividing each component separately.  In other words, the line above is equivalent to the following: <br><br><pre> <code class="javascript hljs">vec2 pixel = vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>); pixel.x = gl_FragCoord.x / res.x; pixel.y = gl_FragCoord.y / res.y;</code> </pre><br><br>  As we divide x and y into different numbers (width and height of the screen), naturally, the texture stretches. <br>  But what would happen if we simply divided x and y from the variable gl_FragCoord by the value of x res?  Or, on the contrary, the value of y res? <br>  For simplicity, the experiment will leave everything as is until the end of the lesson.  But, anyway, it is very important to understand what is happening in the code and why. <br><br>  <b>Step 1. Add a light source</b> <br><br>  First of all, let's add a light source.  The light source is nothing more than a point that we send to the shader.  Create a new uniform variable for this point: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = { <span class="hljs-comment"><span class="hljs-comment">//Add our light variable here light: {type:'v3', value:new THREE.Vector3()}, tex : {type:'t',value:texture},//The texture res : {type: 'v2',value:new THREE.Vector2(window.innerWidth,window.innerHeight)}//Keeps the resolution }</span></span></code> </pre><br><br>  We have created a vector with three parameters, since we will use the x and y values ‚Äã‚Äãto indicate the position of the light source on the screen, and z as its radius. <br><br>  Set the light source values ‚Äã‚Äãin the JavaScript code: <br><br><pre> <code class="javascript hljs">uniforms.light.value.z = <span class="hljs-number"><span class="hljs-number">0.2</span></span>;<span class="hljs-comment"><span class="hljs-comment">//Our radius</span></span></code> </pre><br><br>  Set the radius to 0.2, which corresponds to 20% of the screen size.  However, the units do not play a special role, the size can be set in pixels.  This does not affect anything until it comes to GLSL code. <br><br>  Add an event listener to the JavaScript code to locate the mouse cursor: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Update the light source to follow our mouse uniforms.light.value.x = event.clientX; uniforms.light.value.y = event.clientY; }</span></span></code> </pre><br><br>  Now we write the shader code to make the light source work.  Let's start with a simple one: let's make sure that all the pixels within the radius of light are visible, and all the others are black. <br><br>  In the GLSL code, it will look something like this: <br><br><pre> <code class="javascript hljs">uniform sampler2D tex; uniform vec2 res; uniform vec3 light;<span class="hljs-comment"><span class="hljs-comment">//Remember to declare the uniform here! void main() { vec2 pixel = gl_FragCoord.xy / res.xy; vec4 color = texture2D(tex,pixel); //Distance of the current pixel from the light position float dist = distance(gl_FragCoord.xy,light.xy); if(light.z * res.x &gt; dist){//Check if this pixel is without the range gl_FragColor = color; } else { gl_FragColor = vec4(0.0); } }</span></span></code> </pre><br><br>  So, here is what we did: <br><br>  ‚Ä¢ Declared a uniform variable for the light source. <br>  ‚Ä¢ Used the built-in distance function to determine the distance between the light source and this pixel. <br>  ‚Ä¢ Checked the value of the distance function (in pixels).  If it is more than 20% of the screen width, we return the color of this pixel, if not, we return black. <br><br><img src="https://habrastorage.org/files/d72/efa/4cb/d72efa4cbc644752bddeec96aaa7521e.png"><br>  See in action - <a href="http://codepen.io/tutsplus/pen/vOzBPx">on CodePen.</a> <br><br>  Oops!  It seems that something is wrong with the logic of the movement of light. <br>  <b>Task:</b> Can you fix it?  I repeat: try to do it yourself before watching the answer below. <br><br>  <b>We fix the movement of light</b> <br><br>  As you remember from the first lesson, the y axis is inverted here.  Perhaps you are going to do the following: <br><br><pre> <code class="javascript hljs">light.y = res.y - light.y;</code> </pre><br><br>  This is true from a mathematical point of view, but the shader will not compile this way.  The fact is that uniform variables cannot be changed.  Remember: this code is executed in parallel for each pixel.  Imagine how all the processor cores simultaneously try to change a single variable.  Not good! <br><br>  You can fix the problem by creating a new variable, rather than trying to change this.  Better yet, do it before sending it to the shader: <br><br><img src="https://habrastorage.org/files/723/ccc/210/723ccc210edf4471b4bbdf9902138149.png"><br>  <a href="http://codepen.io/tutsplus/pen/ZGMzPZ">On CodePen,</a> you can create a source code branch and edit it. <br><br><pre> <code class="javascript hljs">uniforms.light.value.y = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight - event.clientY;</code> </pre><br><br>  We have successfully set the parameters for the visible part of the scene.  Now it would not hurt to slightly smooth the edges of this area. <br><br>  <b>Add a gradient</b> <br><br>  Instead of just cropping the visible area with black, try creating a smooth gradient.  For this we need a distance that we already calculate. <br><br>  Instead of returning the entire visible color of the texture, like this: <br><br><pre> <code class="javascript hljs">gl_FragColor = color;</code> </pre><br><br>  We can simply multiply the color by the distance factor: <br><br><pre> <code class="javascript hljs">gl_FragColor = color * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - dist/(light.z * res.x));</code> </pre><br><br><img src="https://habrastorage.org/files/aca/d9d/992/acad9d992d3b43df928855aeb7b7b22f.png"><br><br>  This works because dist is the distance in pixels between the given pixel and the light source.  The term of the expression (light.z * res.x) is the length of the radius.  Therefore, when we look at a pixel that is just at the source of light, dist is 0. As a result, we multiply color by 1, which corresponds to the full color of the pixel. <br><br><img src="https://habrastorage.org/files/6f2/9bd/a3a/6f29bda3aab14fff8c65c7c060cd3191.png"><br><br>  In this figure, dist is calculated for an arbitrary pixel.  The value of dist varies depending on which pixel we are on, while the value of light.z * res.x is constant. <br><br>  For a pixel that is on the edge of a circle, dist is equal to the radius of the circle, so we multiply color by 0, which corresponds to black color. <br><br>  <b>Step 2. Add depth</b> <br><br>  So, we have created a gradient mask for the texture.  But everything still looks flat.  To understand how to fix it, let's see what the lighting system is doing now and what it should do in principle. <br><br><img src="https://habrastorage.org/files/085/d6f/f1c/085d6ff1c9a84f0e89a4420eb99ba7ed.png"><br><br>  In this case, it is assumed that section A will be the most illuminated, since it is located directly under the light source, and sections B and C will be dark, because there is practically no light on them. <br>  However, this is how the lighting system behaves now: <br><br><img src="https://habrastorage.org/files/936/2ee/501/9362ee501f4b45498c84434dd726ac93.png"><br><br>  All sides are equally lit, since the only factor we take into account is the distance on the xy plane.  It may seem to you that to solve a problem we just need to know the height of each of these points, but this is not quite so.  Consider the following situation: <br><br><img src="https://habrastorage.org/files/572/7cf/d0f/5727cfd0f6e34e8da744ad6bc28bf846.png"><br><br>  Section A is the top of the block, and B and C are its sides.  D - the surface area next to the block.  As we can see, sections A and D should be the lightest, but D will be slightly darker as the light falls on it at an angle.  B and C, in turn, will be very dark, since the light hardly reaches them. <br><br>  It turns out that you need to know rather not the height, but the direction of the front side of the surface.  This is called a surface <a href="https://en.wikipedia.org/wiki/Normal_(geometry)">normal</a> . <br>  But how to transfer this data to the shader?  We can send a giant array with thousands of numbers for each pixel, right?  In fact, this is exactly what we are doing!  Only as an array is the texture. <br><br>  This is the normal map - the image, where the values ‚Äã‚Äãof r, g, b for each pixel indicate the direction instead of color. <br><br><img src="https://habrastorage.org/files/7aa/c6a/5f4/7aac6a5f43f749948994cfdfdee6fa00.png"><br><br>  Above is a simple normal map.  If you take the color palette, you can see that the standard ‚Äúflat‚Äù direction corresponds to the color (0.5, 0.5, 1) - that is, blue, which occupies most of the image.  Blue pixels look straight up.  All values ‚Äã‚Äãof r, g, b for each pixel are translated into values ‚Äã‚Äãof x, y, z. <br><br>  Take, for example, the beveled pink side.  It is directed to the right, respectively, its x value, corresponding to the red color, is higher than that of the others.  The same applies to other parties. <br><br>  Maybe it all looks weird.  But the normal map is not intended for rendering, but solely for converting normal values ‚Äã‚Äãto the surface. <br><br>  So, let's load a simple normal map: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normalURL = <span class="hljs-string"><span class="hljs-string">"https://raw.githubusercontent.com/tutsplus/Beginners-Guide-to-Shaders/master/Part3/normal_maps/normal_test.jpg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normal = THREE.ImageUtils.loadTexture(normalURL);</code> </pre><br><br>  And add it as one of the uniform variables: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> uniforms = { <span class="hljs-attr"><span class="hljs-attr">norm</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>:<span class="hljs-string"><span class="hljs-string">'t'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>:normal}, <span class="hljs-comment"><span class="hljs-comment">//.. the rest of our stuff here }</span></span></code> </pre><br><br>  To check that everything has loaded correctly, let's render the normal map instead of the texture, first modifying the GLSL code (note, while we use it as a background texture, and not as a normal map): <br><br><img src="https://habrastorage.org/files/a5f/c90/555/a5fc90555d424e16b32db7168b61926a.png"><br><br>  <b>Step 3. Apply a lighting model</b> <br><br>  Now that we have these surface normals, we need to implement a lighting model.  In other words, we need to tell the surface how to take into account all the factors available to calculate the final pixel brightness. <br><br>  The simplest option would be the Phong model lighting model.  Suppose there is such a surface with the given normals: <br><br><img src="https://habrastorage.org/files/674/381/b15/674381b155784be0a32cac3d125946c0.png"><br><br>  We can simply calculate the angle between the light source and the normal to the surface: <br><br><img src="https://habrastorage.org/files/a55/9a0/6db/a559a06db80f439888015ac224539d56.png"><br><br>  The smaller the angle, the brighter the pixel. <br>  That is, the pixels that are directly under the light source, where the angle is zero, will be the brightest.  And the darkest will be those pixels that are located on the back of the object. <br>  Now, since we are using a simple normal map for testing, let's apply a solid color to the texture.  Then we‚Äôll see if the lighting system works. <br><br>  Instead of this: <br><br><pre> <code class="javascript hljs">vec4 color = texture2D(...);</code> </pre><br><br>  Make a solid white color (or whatever you like): <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//solid white</span></span></code> </pre><br><br>  This GLSL abbreviation is needed to create vec4 with all components equal to 1.0. <br><br>  Here is the algorithm of actions: <br><br>  1. Get the normal vector in this pixel. <br>  2. Get the vector of the direction of light. <br>  3. Normalize the vectors. <br>  4. Consider the angle between the vectors. <br>  5. Multiply the final color by this factor. <br><br>  <b>1. Get the normal vector in this pixel.</b> <br>  We need to know the direction of the front side of the surface to determine how much light should fall on this pixel.  This direction is stored in the normal map, so you can get the normal vector by recognizing the color of a given pixel on the normal texture. <br><br><pre> <code class="javascript hljs">vec3 NormalVector = texture2D(norm,pixel).xyz;</code> </pre><br><br>  Since the alpha value is not responsible for anything in the normal map, we need only the first 3 components. <br><br>  <b>2. Get the vector of the direction of light</b> <br><br>  Now we need to know where the light source is.  Imagine it as a flashlight hanging in front of the screen where the mouse cursor is.  We can determine the vector of the direction of light using the distance between the light source and the pixel: <br><br><pre> <code class="javascript hljs">vec3 LightVector = vec3(light.x - gl_FragCoord.x,light.y - gl_FragCoord.y,<span class="hljs-number"><span class="hljs-number">60.0</span></span>);</code> </pre><br><br>  We also need the z coordinate to determine the angle to the three-dimensional normal vector.  Try changing its value, and you will see: the smaller it is, the sharper is the contrast between dark and bright areas.  Think of it as the height at which you hold the flashlight above the stage: the farther it is, the more evenly the light is distributed. <br><br>  <b>3. Normalize the vectors</b> <br><br><pre> <code class="javascript hljs">NormalVector = normalize(NormalVector); LightVector = normalize(LightVector);</code> </pre><br><br>  We use the built-in function <a href="http://www.shaderific.com/glsl-functions/">normalize</a> to make sure that the length of both vectors is 1.0.  This is necessary because we need to calculate the angle using a <a href="https://en.wikipedia.org/wiki/Dot_product">dot product</a> .  If you do not quite understand how it works, it's time to improve your knowledge of linear algebra.  But in this case we only need to know that the scalar product will return the cosine of the angle between two vectors of the same length. <br><br>  4. Consider the angle between the vectors <br><br>  For this we need the built-in <a href="http://www.shaderific.com/glsl-functions/">dot</a> function: <br><br><pre> <code class="javascript hljs">float diffuse = dot( NormalVector, LightVector );</code> </pre><br><br>  I called the variable diffuse because there is a concept of the diffuse component in the Phong light model, which is responsible for how much light hits the surface of the scene. <br><br>  <b>5. Multiply the final color by this factor.</b> <br><br>  That's all!  Now just multiply the color by the coefficient.  I went ahead and created a distanceFactor variable to improve the readability of the equation: <br><br><pre> <code class="javascript hljs">float distanceFactor = (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - dist/(light.z * res.x)); gl_FragColor = color * diffuse * distanceFactor;</code> </pre><br><br>  The result was a working light model!  You may want to increase the radius of the light source so that the result is more visible. <br><br><img src="https://habrastorage.org/files/cec/050/373/cec0503730414ddebdb13905de1873fa.png"><br><br>  Hmm, something worked wrong.  It seems to have shifted the center of the light source. <br><br>  Let's check the calculations again.  There is a vector: <br><br><pre> <code class="javascript hljs">vec3 LightVector = vec3(light.x - gl_FragCoord.x,light.y - gl_FragCoord.y,<span class="hljs-number"><span class="hljs-number">60.0</span></span>);</code> </pre><br><br>  Which, as we know, will return (0, 0, 60) if the light falls directly on this pixel.  After we normalize it, we get (0, 0, 1). <br>  Remember: to get the maximum brightness, you need a normal, which points directly to the light source.  The value of the normal to the surface pointing straight up is (0.5, 0.5, 1) by default. <br><br>  <b>Task:</b> Do you see a solution to the problem?  Can you fix it? <br><br>  The fact is that in the color values ‚Äã‚Äãof the texture can not be stored negative numbers.  For example, you can not set the vector pointing to the left, the values ‚Äã‚Äã(-0.5, 0, 0).  Therefore, creators of normal maps should add 0.5 to each value ‚Äî that is, shift the coordinate system.  Keep in mind that before using the map, you must subtract this 0.5 from each pixel. <br>  Here is the result obtained by subtracting 0.5 from the x and y values ‚Äã‚Äãin the normal vector: <br><br><img src="https://habrastorage.org/files/50f/aeb/3b7/50faeb3b7f274b16abb9cce7701cd349.png"><br><br>  It remains to fix only one thing.  Since the dot product returns the cosine of the angle, the resulting value can be from -1 to 1. But we do not need negative color values.  And although WebGL automatically rejects negative values, there may still be a problem somewhere else.  Let's use the built-in max function and change this: <br><br><pre> <code class="javascript hljs">float diffuse = dot( NormalVector, LightVector );</code> </pre><br><br>  On this: <br><br><pre> <code class="javascript hljs">float diffuse = max(dot( NormalVector, LightVector ),<span class="hljs-number"><span class="hljs-number">0.0</span></span>);</code> </pre><br><br>  Now you have a working lighting model! <br>  You can bring back the texture with stones.  The normal map for it is available <a href="https://github.com/tutsplus/Beginners-Guide-to-Shaders/">in the repository on GitHub</a> (or by direct link <a href="">here</a> ). <br><br>  You just need to fix this link in JavaScript code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normalURL = <span class="hljs-string"><span class="hljs-string">"https://raw.githubusercontent.com/tutsplus/Beginners-Guide-to-Shaders/master/Part3/normal_maps/normal_test.jpg"</span></span></code> </pre><br><br>  On this: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> normalURL = <span class="hljs-string"><span class="hljs-string">"https://raw.githubusercontent.com/tutsplus/Beginners-Guide-to-Shaders/master/Part3/normal_maps/blocks_normal.JPG"</span></span></code> </pre><br>  And this line of GLSL code: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>);<span class="hljs-comment"><span class="hljs-comment">//solid white</span></span></code> </pre><br><br>  Replacing the solid white color with a texture: <br><br><pre> <code class="javascript hljs">vec4 color = texture2D(tex,pixel);</code> </pre><br><br>  Finally, here is the result: <br><br>  <a href="http://prntscr.com/auy52h">prntscr.com/auy52h</a> <br>  <a href="http://codepen.io/tutsplus/pen/RPYbqp">On CodePen,</a> you can create a source code branch and edit it. <br><br>  <b>Optimization Tips</b> <br><br>  The GPU is very effective, but it will be helpful to know what factors may hinder its operation.  Here are some simple tips: <br><br>  <b>Branching</b> <br>  When working with shaders, it is better to avoid branching where possible.  When working with code for a CPU, you rarely have to worry about a lot of if statements.  But for the GPU, they can be a serious hindrance. <br><br>  To understand the reason, remember again that the GLSL code is executed in parallel for each individual pixel on the screen.  The operation of a video card can be significantly optimized, provided that all pixels require the same operations.  If there are many if statements in the code, the optimization may decrease, since different pixels will require the execution of different code.  Of course, it depends on the characteristics of those or other components, as well as on the features of using a video card.  But this is useful to keep in mind to speed up the shader. <br><br>  <b>Deferred rendering</b> <br><br>  This is a very useful technique for working with lighting.  Imagine if we wanted to make not 1 light source, but 2, 3 or even 10. We would have to calculate the angle between each normal to the surface and each light source.  This would very quickly reduce the speed of the shader.  Deferred rendering helps to correct this by dividing the work of the shader into many moves.  <a href="http://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342">This article</a> addresses this issue in detail.  Here I will give only a fragment on the topic of this lesson: <br><br>  ‚ÄúLighting is the main reason why we choose a particular development path.  In the standard visualization pipeline, all calculations related to lighting should be performed on each vertex and on each fragment of the visible scene, for each light source. " <br><br>  For example, instead of sending an array of points of light, you can put them on a texture as circles, where the color of each pixel will indicate the intensity of light.  This way you can calculate the total effect of all the light sources in the scene and send only this final texture (or buffer, as it is also called) and calculate the lighting based on it. <br><br>  Dividing a shader's work into multiple moves is a very useful technique.  It is widely used to create effects of blur, water and smoke.  Deferred rendering doesn‚Äôt fit in a bit with the topic of this lesson, but we‚Äôll look at it in more detail in the next lesson! <br><br>  <b>Further steps</b> <br><br>  Now that you have a working lighting shader, you can try the following: <br><br>  ‚Ä¢ Change the height (z value) of the light vector to see what effect it will have. <br>  ‚Ä¢ Change the light intensity.  This can be done by multiplying the diffuse component by the coefficient. <br>  ‚Ä¢ Add the ambient component to the light calculation equation.  This implies adding minimal (initial) lighting to the scene to create more realism.  In real life, there are no absolutely dark objects, because the minimum amount of light still falls on any surface. <br>  ‚Ä¢ Try to create one of the shaders discussed in this lesson on <a href="http://gamedevelopment.tutsplus.com/tutorials/building-shaders-with-babylonjs-and-webgl-theory-and-examples--cms-24146">WebGL.</a>  They are created based on Babylon.js, not Three.js, but you can go directly to the GLSL settings.  In particular, you might be interested in cel shading and Phong shading. <br>  ‚Ä¢ Check out the interesting work on the <a href="http://glslsandbox.com/">GLSL Sandbox</a> and <a href="https://www.shadertoy.com/">ShaderToy sites.</a> <br><br>  <b>Links</b> <br>  The texture with stones and the normal map used in this tutorial were taken from the <a href="http://opengameart.org/content/50-free-textures-4-normalmaps">OpenGameArt</a> site.  Among other things, there are many programs available for creating normal maps.  If you want to learn more about how normal maps are created, see <a href="http://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-a-normal-map--gamedev-3893">also this article.</a> <a href="http://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-a-normal-map--gamedev-3893"><br></a> </div><p>Source: <a href="https://habr.com/ru/post/282131/">https://habr.com/ru/post/282131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282121/index.html">The new cryptographer CryptoBit is distributed through exploit kits that affect the browser.</a></li>
<li><a href="../282123/index.html">Manage database structure without pain</a></li>
<li><a href="../282125/index.html">How I tried Microsoft Project Oxford + Telegram Bot API</a></li>
<li><a href="../282127/index.html">Striving for nil: how the prices for mobile communications have changed in a quarter of a century</a></li>
<li><a href="../282129/index.html">Work with geofences (geofences) in Android. Update</a></li>
<li><a href="../282133/index.html">SpyEye authors were given 24 years for two</a></li>
<li><a href="../282139/index.html">IT Center at the DUMP-2016 Conference</a></li>
<li><a href="../282141/index.html">Introduction to offline navigation for augmented reality</a></li>
<li><a href="../282143/index.html">How Google in London trained on Android N</a></li>
<li><a href="../282145/index.html">How to hope for the Ministry of Emergency Situations and disappear in the forests of Karelia - bad advice from an experienced tourist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>