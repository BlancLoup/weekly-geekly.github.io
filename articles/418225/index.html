<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 2</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <a name="habracut"></a><br><br>  <b>Audience:</b> why should the range of the memory capacity of the address space start from zero? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Professor:</b> because from the point of view of performance, it is more efficient to use a target jump if you know that a valid address is a continuous set of addresses starting from zero.  Because then you can do it with a single <b>AND</b> -mask, where all the high bits are one, and only a pair of low bits is zero. <br><br>  <b>Audience:</b> I thought <b>AND-</b> mask was supposed to provide alignment. <br><br>  <b>Prof:</b> right, the mask provides alignment, but why does it start from scratch?  I think they rely on segmented hardware segmentation hardware.  So, in principle, they could use it to move the area upwards, in terms of linear space.  Or maybe it is simply related to how the application ‚Äúsees‚Äù this range.  In fact, you can place it at different offsets in your virtual address space.  This will allow you to perform certain tricks with segmented hardware to run multiple modules in a single address space. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>Audience:</b> Is this possibly because they want to ‚Äúcatch‚Äù the point of reception of the null pointer? <br><br>  <b>Professor:</b> yes, because they want to catch all points of reception.  But you have a way to do it.  Because the null pointer refers to the segment that is being accessed.  And if you move a segment, you can display an unused zero page at the beginning of each segment.  So this will help to make several modules. <br><br>  I think that one of the reasons for this decision - to start the range from 0 - is related to their desire to port their program to the <b>x64</b> platform, which has a slightly different design.  But in their article this is not mentioned.  In 64-bit design, the hardware itself got rid of some segmentation hardware that they relied on for efficiency reasons, so they had to consider a software-based approach.  However, for <b>x32,</b> this is still not a sufficiently weighty reason for the space to start from scratch. <br><br>  So, we continue the main question - what do we want to provide from a security point of view  Let's get to this case a little "naively" and see how we can spoil everything, and then try to fix it. <br><br>  I believe that a naive plan is to look for prohibited instructions, simply by scanning the executable from the very beginning to the end.  So how can you discover these instructions?  You can simply take the program code and put it in a giant line that goes from zero to 256 megabytes, depending on how big your code is, and then start the search. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  This line can first contain the <b>NOP</b> module, then the <b>ADD</b> instruction module, <b>NOT</b> , <b>JUMP,</b> and so on.  You are simply looking for, and if you find bad instructions, then say that this is a bad module and discard it.  And if you do not see any system call to this instruction, then you can allow the launch of this module and do everything that is within the range of 0-256.  Do you think it will work or not?  What are they worried about?  Why is it so hard? <br><br>  <b>Audience:</b> Are they concerned about the size of the instructions? <br><br>  <b>Professor:</b> yes, the fact is that the <b>x86</b> platform has instructions of variable length.  This means that the specific size of the instruction depends on the first few bytes of this instruction.  In fact, you can look at the first byte to say that the instruction will be much larger, and then you may have to look at a couple more bytes, and then decide what kind of size it takes.  Some architectures, such as <b>Spark</b> , <b>ARM</b> , <b>MIPS,</b> have more fixed-length instructions.  <b>ARM</b> has two instruction lengths - either 2 or 4 bytes.  But in the <b>x86</b> platform <b>, the</b> length of instructions can be 1, and 5, and 10 bytes, and if you try, you can even get a rather long instruction of 15 bytes.  However, these are complex instructions. <br><br>  As a result, there may be a problem.  If you scan this line of software code linearly, everything will be fine.  But maybe at runtime you will go to the middle of some instruction, for example, <b>NOT</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  It is possible that this is a multibyte instruction, and if you interpret it, starting from the second byte, it will look completely different. <br><br>  Another example in which we will ‚Äúplay‚Äù with an assembler.  Suppose we have instruction <b>25 CD 80 00 00</b> .  Looking at the 2nd byte, you will interpret it as a five-byte instruction, that is, you will have to look 5 bytes forward and see that it is followed by the instruction <b>AND% EAX, 0x00 00 80 CD</b> , starting with the <b>AND</b> operator for the <b>EAX</b> register with some certain constants, for example, <b>00 00 80 CD</b> .  This is one of the safe instructions that the <b>Native Client</b> should simply allow according to the first rule for checking binary instructions.  But if during the execution of the program the <b>CPU</b> decides that it should start executing the code from the <b>CD</b> , I will mark this place of the instruction with an arrow, then the instruction <b>% EAX, 0x00 00 80 CD</b> , which is actually a 4-byte instruction, will mean execution <b>$ 0x80</b> , which is a way to make a system call on <b>Linux</b> . <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  So if you miss this fact, then let the unreliable module "jump" into the kernel and make system calls, that is, do what you wanted to prevent.  How can we avoid this? <br><br>  Perhaps we should try to look at the offset of each byte.  Since x86 can only begin to interpret the instruction in byte boundaries, not bit boundaries.  Thus, you will have to look at the offset of each byte to see where the instruction starts.  Do you think this is an expedient plan? <br><br>  <b>Audience:</b> I think that if someone actually uses <b>AND</b> , the processor will not jump to this place, but simply allow the program to run. <br><br>  <b>Professor:</b> yes, because basically he is not prone to false positives.  Now, if you really want it, you can change the code a bit to somehow avoid it.  If you know exactly what the test device is looking for, you could potentially change these instructions.  Maybe by setting <b>AND</b> first for one instruction, and then use the mask on another.  But it‚Äôs much easier to avoid these suspicious byte locations, although this seems rather inconvenient. <br><br>  It is possible that the architecture includes a compiler change.  In principle, they have some component that actually needs to compile the code correctly.  You cannot simply take <b>GCC</b> off the shelf and compile the code for the <b>Native Client</b> .  So basically it is doable.  But probably, they just think that it causes too much trouble, will not be a reliable or high-performance solution, and so on.  Plus, there are several <b>x86</b> instructions that are prohibited, or should be deemed unsafe and therefore should be prohibited.  But for the most part they are one byte in size, so they are quite difficult to search for or filter out. <br><br>  Therefore, if they cannot simply collect and sort unsafe instructions and hope for the best, they need to use another plan to disassemble it in a reliable way.  So what does the <b>Native Client do</b> to make sure that they do not ‚Äústumble‚Äù about this variable length encoding? <br><br>  In a sense, if we really scan the executable file forward from left to right and look for all possible incorrect codes, and if this is the way the code is executed, then we are in good shape.  Even if there are some strange instructions present and there is some offset, the processor is still not going to ‚Äújump‚Äù there, it will execute the program in the same order in which the instructions are scanned, that is, from left to right. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  Thus, the problem with reliable disassembling arises from the fact that ‚Äújumps‚Äù can take place somewhere in the application.  A processor may crash if it ‚Äújumps‚Äù to some kind of code instruction that it did not notice when scanning from left to right.  So this is a problem of reliable disassembling while it is in development.  And the basic plan is to check where all the ‚Äújumps‚Äù go.  In fact, it is quite simple at some level.  There are a lot of rules that we will consider in a second, but the approximate plan is that if you see the ‚Äújump‚Äù of the instruction, then you need to make sure that the goal of the ‚Äújump‚Äù was seen earlier.  To do this, in fact, it suffices to perform a scan from left to right, that is, the procedure that we described in our naive approach to the problem. <br><br>  In this case, if you see any ‚Äújump‚Äù instruction and the address that this instruction points to, then you must make sure that this is the same address that you already saw during the disassembly from left to right. <br><br>  If a jump instruction to this CD byte is found, then we must mark this jump as invalid, because we have never seen the instruction starting at the CD byte, but we have seen another instruction starting with the number 25. But if all the jump instructions order to proceed to the beginning of the instruction, in this case to 25, then everything is fine with us.  It's clear? <br><br>  The only problem is that you cannot check the goals of each jump in the program, because there may be indirect jumps.  For example, in <b>x86</b> you might have something like a jump to the value of this register <b>EAX</b> .  This is great for implementing function pointers. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  That is, the function pointer is somewhere in memory, you hold it in some register, and then go to any address in the move register. <br><br>  So how do these guys deal with indirect jumps?  Because, in fact, I have no idea whether this will be a ‚Äújump‚Äù to a <b>CD</b> byte or to byte 25. What do they do in this case? <br><br>  <b>Audience:</b> use tools? <br><br>  <b>Professor:</b> yes, instrumentation is their main gimmick.  Therefore, whenever they see that the compiler is ready to perform the generation, this is proof that this jump does not cause trouble.  To do this, they need to make sure that all jumps are performed with a multiplicity of 32 bytes.  How do they do it?  They change all the jump instructions for what they called ‚Äúpseudoinstructions‚Äù.  These are the same instructions, but prefixed, which clears the 5 low bits in the <b>EAX</b> register.  The fact that the instruction clears 5 low bits means that it causes the given value to be a multiple of 32, from two to five, and then a ‚Äújump‚Äù is made to this value. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  If you look at it during verification, then make sure that this instructional ‚Äúpair‚Äù will ‚Äújump‚Äù only with a multiplicity of 32 bytes.  And then, in order to make sure that there is no possibility of ‚Äújumping‚Äù into some strange instructions, you apply an additional rule.  It is that during disassembly, when you view your instructions from left to right, you ensure that the beginning of each valid instruction will also be a multiple of 32 bytes. <br><br>  Thus, in addition to this toolkit, you verify that every code that is a multiple of 32 is the correct instruction.  By correct, valid instruction, I understand the instruction that is being disassembled from left to right. <br><br>  <b>Audience:</b> why is the number 32 chosen? <br><br>  <b>Professor:</b> yes, why did they choose 32, not 1000 or 5?  Why is 5 a bad thing? <br><br>  <b>Audience:</b> because the number must be a power of 2. <br><br>  <b>Professor:</b> Yes, well, that's why.  Because otherwise, ensuring the use of something multiple of 5 will require additional instructions leading to overhead.  What about eight?  Eight - a good enough number? <br><br>  <b>Audience:</b> You may have instructions longer than eight bits. <br><br>  <b>Professor:</b> yes, that could be for the longest instruction allowed on the x86 platform.  If we have 10 byte instructions, and everything must be a multiple of 8, then we will not be able to insert it anywhere.  So the length should be sufficient for all cases, because the biggest instruction I saw was 15 bytes long.  So 32 bytes is quite enough. <br><br>  If you want to adapt the instruction to enter or exit from the process environment, you may need some nontrivial amount of code in one 32-byte slot.  For example, 31 bytes, because 1 byte contains the instruction.  Should it be much bigger?  Should we make it equal, say, 1024 bytes?  If you have a lot of function pointers or a lot of indirect jumps, then every time you want to create some place where you are going to jump, you must continue it to the next border, regardless of its value.  So with 32 bits, it's quite a normal size.  In the worst case, you will lose only 31 bytes if you need to quickly get to the next border.  But if you have a size that is a multiple of 1024 bytes, then it is possible to waste a whole kilobyte of memory for making an indirect jump.  If you have short functions or a lot of function pointers, such a large size of the multiplicity of the "jump" length will cause a significant memory overflow. <br><br>  I do not think that the number 32 is a stumbling block for the <b>Native Client</b> .  Some blocks could work with a multiplicity of 16 bits, some 64 or 128 bits are not important.  Just 32 bits seemed to them the most acceptable, optimal value. <br><br>  So let's make a reliable disassembly plan.  As a result, the compiler should be a bit careful when compiling <b>C</b> or <b>C ++ code</b> into a binary <b>Native Client</b> file and follow these rules. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  Therefore, whenever he has a jump, as shown in the top line, he must add these additional instructions given in the 2 bottom lines.  And regardless of the fact that it creates the function to which it is going to ‚Äújump,‚Äù our instruction will jump as indicated by this addition <b>AND $ 0xffffffe0,% eax</b> .  And it cannot simply add zeros to it, because all this must have the correct codes.  Thus, the addition is necessary in order to make sure that every possible instruction is valid.  And, fortunately, on the <b>x86</b> platform, not a single <b>noop</b> function is described by one byte, or at least there is no <b>noop</b> that is 1 byte in size.  Thus, you can always add things to the value of a constant. <br><br>  So what does this guarantee us?  Let's make sure that we always see what happens in the terminology of the instructions that will be executed.  That's what gives us this rule - the confidence that the system call will not be made by chance.  This is about jumping, but what about returns?  How do they cope with the return?  Can we perform a <b>return</b> to a function in the <b>Native Client</b> ?  What happens if you run the red-hot code? <br><br>  <b>Audience:</b> He can overflow the stack. <br><br>  <b>Professor:</b> it is true that he quite unexpectedly pops up on the stack.  But the fact is that the stack used by the <b>Native Client</b> modules actually contains some data inside.  Thus, when contacting the <b>Native Client</b> you should not be worried about stack overflow. <br><br>  <b>Audience:</b> wait, but you can put anything on the stack.  And when you take an indirect jump. <br><br>  <b>Professor:</b> that's true.  A return looks almost like an indirect jump from some place in memory that is at the top of the stack.  Therefore, I think that one thing they could do for the <b>return</b> function is to set the prefix in the same way that it was done in the previous check.  And this prefix checks for what floats at the top of the stack.  You check if it is valid, and when you write or use the <b>AND</b> operator, you check what is at the top of the stack.  This seems a bit unreliable due to the constant change of data.  Because, for example, if you look at the top of the stack and make sure everything is fine there, and then write something, the data flow in the same module can modify something at the top of the stack, after which you will refer to the wrong address. <br><br>  <b>Audience:</b> Isn‚Äôt this also true of jumping? <br><br>  <b>Professor:</b> yes, so what happens there with a jump?  Can our race conditions somehow invalidate this check? <br><br>  <b>Audience:</b> but the code is not available for recording? <br><br>  <b>Professor:</b> Yes, the code can not be written, it's true.  Thus, you cannot modify AND.  But can not some other stream change the purpose of the jump between these two instructions? <br><br>  <b>Audience:</b> this is in the register, so ... <br><br>  <b>Professor:</b> Yes, this is a cool thing.  Because if the stream modifies something in memory or in what is loaded from <b>EAX</b> (by itself, you do it before loading), in this case, this <b>EAX</b> will be in a bad state, but then clear the bad bits.  Or it may change memory after the pointer is already in <b>EAX</b> , so it doesn‚Äôt matter that it changes the location of the memory from which the <b>EAX</b> register was loaded. <br><br>  In fact, threads do not share sets of registers.  Therefore, if another thread changes the <b>EAX</b> register, it will not affect the <b>EAX</b> register of this thread.  Thus, other threads cannot invalidate this sequence of instructions. <br><br>  There is another interesting question.  Can we get around this <b>AND</b> ?           .      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : ¬´,    ,    !¬ª,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    ¬´¬ª . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     ¬´¬ª     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, they just want to make sure that there is no ambiguity in what happens if you continue to perform and do not jump, but simply follow to the end of the instructions screen. </font><font style="vertical-align: inherit;">So let's assume that the meaning of this rule is that if you continue execution, you will stop, get trapped during the execution of the process and interrupt the module. </font><font style="vertical-align: inherit;">So this rule concerns simplicity and safety of work. </font></font><br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55:20 min</font></font><br><br>  Continued: <br><br>  <a href="https://habr.com/company/ua-hosting/blog/418227/">MIT course "Computer Systems Security".</a> <a href="https://habr.com/company/ua-hosting/blog/418227/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture 7: "Sandbox Native Client", part 3</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>3 months for free</b> if you pay for new Dell R630 for half a year - <b>2 x Intel Deca-Core Xeon E5-2630 v4 / 128GB DDR4 / 4x1TB HDD or 2x240GB SSD / 1Gbps 10 TB - from $ 99.33 a month</b> , only until the end of August, order can be <a href="https://ua-hosting.company/serversnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/418225/">https://habr.com/ru/post/418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418215/index.html">MIT course "Computer Systems Security". Lecture 5: "Where Security Errors Come From", Part 2</a></li>
<li><a href="../418217/index.html">MIT course "Computer Systems Security". Lecture 6: "Opportunities", part 1</a></li>
<li><a href="../418219/index.html">MIT course "Computer Systems Security". Lecture 6: "Opportunities", part 2</a></li>
<li><a href="../418221/index.html">MIT course "Computer Systems Security". Lecture 6: "Opportunities", part 3</a></li>
<li><a href="../418223/index.html">MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 1</a></li>
<li><a href="../418227/index.html">MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 3</a></li>
<li><a href="../418229/index.html">MIT course "Computer Systems Security". Lecture 8: "Model of network security", part 1</a></li>
<li><a href="../418233/index.html">BMW Mnemonic for finding boundary values</a></li>
<li><a href="../418235/index.html">Orchestrated saga or how to build business transactions in services with the pattern database per service</a></li>
<li><a href="../418237/index.html">Development of multi-tenant applications on the SAP Cloud Platform in the Neo environment, part 2: authorization and authentication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>