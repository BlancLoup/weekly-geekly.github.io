<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microsoft Bot Framework + IBM Watson = ... bi-linguistic bot</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the started topic I would like to share the successful experience of creating a bilingual Node.JS bot on the Microsoft Bot Framework under ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microsoft Bot Framework + IBM Watson = ... bi-linguistic bot</h1><div class="post__text post__text-html js-mediator-article">  Continuing the <a href="https://habrahabr.ru/post/333824/">started topic I</a> would like to share the successful experience of creating a bilingual Node.JS bot on the <a href="https://dev.botframework.com/">Microsoft Bot Framework</a> under Linux.  The customer received the task to develop a simple social bot in a question-answer format for a large trading network, but the difficulty lay elsewhere - the bot must be bilingual: in English and Arabic.  Although, as will be shown below, the choice of tools for solving the problem made the development easy, pleasant and interesting. <br><a name="habracut"></a><br>  As before, the choice of the framework was made in favor of the Microsoft Bot Framework, which has a huge amount of functionality that greatly facilitates building and deploying the bot: managing the flow of dialogues, trigger actions, state preservation, colorful interactive messages, easy connection of channels such as Facebook Messenger, Skype , Webchat and much more.  As it turned out, it also has a very simple and convenient localization mechanism (about it below). <br><br>  To recognize the meaning of user messages, you can use an AI system, such as LUIS, IBM Watson, Google Dialogflow (Api.ai), etc. It is more natural and more convenient for BotBuilder to use LUIS: there are methods built in the Bot Framework, classes, etc.  However, there is no Arabic language in LUIS - the second language in which, at the request of the customer, the bot should work.  Therefore, the choice fell on IBM Watson, which, as it turned out, has a much more advanced functionality, stability and usability.  The customer initially thought about the possibility of creating 2 bots, but the huge variety of tools in the IBM Watson and Bot Framework made it easy to combine functionality into one.  Further we will tell about how this can be done. <br><br>  Select the new folder in which the project will be located and run: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="bash hljs">npm init</code> </pre> <br>  Install the necessary packages for building a bot, connecting to Watson and asynchronous requests: <br><br><pre> <code class="bash hljs">npm install dotenv npm install restify npm install botbuilder npm install watson-developer-cloud npm install request-promise</code> </pre> <br>  Create the <code>app.js</code> file and copy the following code: <br><br><div class="spoiler">  <b class="spoiler_title">Application code:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> restify = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'restify'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'botbuilder'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Conversation = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'watson-developer-cloud/conversation/v1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// watson sdk require('dotenv').config({ silent: true }); var contexts; var workspace = process.env.WORKSPACE_ID; // Setup Restify Server var server = restify.createServer(); server.listen(process.env.port || process.env.PORT || 3978, function() { console.log('%s listening to %s', server.name, server.url); }); // Create the service wrapper var conversation = new Conversation({ username: process.env.WATSON_USERNAME, password: process.env.WATSON_PASSWORD, url: process.env.WATSON_URL + process.env.WORKSPACE_ID + '/message?version=2017-05-26', version_date: Conversation.VERSION_DATE_2017_05_26 }); // Create chat connector for communicating with the Bot Framework Service var connector = new builder.ChatConnector({ appId: process.env.MICROSOFT_APP_ID, appPassword: process.env.MICROSOFT_APP_PASSWORD }); // Listen for messages from users server.post('/api/messages', connector.listen()); // Create your bot with a function to receive messages from the user var bot = new builder.UniversalBot(connector, function(session) { let payload = { workspace_id: workspace, context: [], input: { text: session.message.text } }; let conversationContext = { workspaceId: workspace, watsonContext: {} }; if (!conversationContext) { conversationContext = {}; } payload.context = conversationContext.watsonContext; conversation.message(payload, function(err, response) { if (err) { console.log(err); session.send(err); } else { console.log(JSON.stringify(response, null, 2)); session.send(response.output.text); conversationContext.watsonContext = response.context; } }); });</span></span></code> </pre> </div></div><br>  This is actually the base, from which you can build on.  Here, before creating the bot, we create a <b>Conversation</b> object with the user.  <b>Conversation is</b> used to transmit user responses to Watson, which recognizes an intent-entity pair in it.  The variables WATSON_URL and WORKSPACE_ID, as you probably already understood, are stored in the <code>.env</code> file: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Bot Framework Credentials MICROSOFT_APP_ID=... MICROSOFT_APP_PASSWORD=... #Watson Url WATSON_URL=https://gateway.watsonplatform.net/conversation/api/v1/workspaces/ WATSON_USERNAME=... WATSON_PASSWORD=... WORKSPACE_ID=&lt;UUID&gt;</span></span></code> </pre> <br>  Workspace (workspace) is associated with an instance of the <b>Conversation</b> with the user service, easier - with a trained model.  This model is created and trained for one language.  For another language, you must create a second <i>workspace</i> .  You can get a list of <i>workspaces</i> available to us and their identifiers by <a href="https://www.ibm.com/watson/developercloud/conversation/api/v1/">running a</a> simple script: <br><br><div class="spoiler">  <b class="spoiler_title">workspaces.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// This loads the environment variables from the .env file require('dotenv-extended').load(); var Conversation = require('watson-developer-cloud/conversation/v1'); // watson sdk var conversation = new Conversation({ username: process.env.WATSON_USERNAME, password: process.env.WATSON_PASSWORD, version_date: Conversation.VERSION_DATE_2017_05_26 }); conversation.listWorkspaces(function(err, response) { if (err) { console.error(err); } else { console.log(JSON.stringify(response, null, 2)); } });</span></span></code> </pre> </div></div><br><pre> <code class="bash hljs">node workspaces.js</code> </pre> <br>  To enable <a href="https://docs.microsoft.com/en-us/bot-framework/nodejs/bot-builder-nodejs-localization">the localization mechanism of the</a> Microsoft Bot Framework, we need to first find out what language the user refers to.  And here Watson comes to our rescue again, having in his arsenal a huge number of <a href="https://watson-api-explorer.mybluemix.net/">various APIs</a> for translation, recognition, classification, conversion, etc.  There is also an API to <a href="https://www.ibm.com/watson/developercloud/language-translator/api/v2/">identify the language</a> .  To use it, create a small module that will be responsible for requests to this API: <br><br><div class="spoiler">  <b class="spoiler_title">language.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"request-promise"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.Detect = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LanguageDetect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">baseUrl</span></span>: <span class="hljs-string"><span class="hljs-string">"https://watson-api-explorer.mybluemix.net"</span></span>, <span class="hljs-attr"><span class="hljs-attr">uri</span></span>: <span class="hljs-string"><span class="hljs-string">"/language-translator/api/v2/identify"</span></span>, <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">qs</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Query string like ?text=some text text: text }, json: true }; try { let result = await request(options); return result.languages[0].language; } catch (err) { console.error(err); } };</span></span></code> </pre> <br></div></div><br>  We connect this module in the main application: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> language = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./language'</span></span>);</code> </pre> <br>  Initially, the main function of the bot will insert lines to determine the current language and install the appropriate locale.  The BotBuilder SDK provides the <code>session.preferredLocale()</code> method to save or retrieve this property for each user: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Detect language en/ar first and set correspondent locale let locale = await language.Detect(session.message.text); session.preferredLocale(locale);</span></span></code> </pre> <br>  The list of recognizable languages ‚Äã‚Äãcan be viewed in the <a href="https://watson-api-explorer.mybluemix.net/apis/language-translator-v2">Watson API Explorer</a> , where you can test this API. <br><br>  For each language we create 2 separate Conversation objects: <br><br><div class="spoiler">  <b class="spoiler_title">English and Arabic Conversation objects</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Get Watson service wrapper for English var conversation_en = new Conversation({ username: process.env.WATSON_USERNAME, password: process.env.WATSON_PASSWORD, url: process.env.WATSON_URL + process.env.WORKSPACE_ID_EN + '/message?version=2017-05-26', version_date: Conversation.VERSION_DATE_2017_05_26 }); // Get Watson service wrapper for Arabic var conversation_ar = new Conversation({ username: process.env.WATSON_USERNAME, password: process.env.WATSON_PASSWORD, url: process.env.WATSON_URL + process.env.WORKSPACE_ID_AR + '/message?version=2017-05-26', version_date: Conversation.VERSION_DATE_2017_05_26 });</span></span></code> </pre> <br></div></div><br><blockquote>  <b>Note.</b>  Note: now in the <code>.env</code> file we have 2 variables <code>WORKSPACE_ID_EN</code> and <code>WORKSPACE_ID_AR</code> , instead of one <code>WORKSPACE_ID</code> . </blockquote><br>  These objects remain unchanged, so you can put them at the beginning of <b>app.js</b> or put them in a separate file.  Then, after the locale definition code, we insert a line that initializes our <i>conversation</i> variable, and we change the <i>workspace</i> variable - now it will also change dynamically depending on a certain language: <br><br><div class="spoiler">  <b class="spoiler_title">Modifications to app.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Detect language en/ar first and set correspondent locale let locale = await language.Detect(session.message.text); session.preferredLocale(locale); let workspace = (locale == "ar") ? process.env.WORKSPACE_ID_AR : process.env.WORKSPACE_ID_EN; // Get Watson service wrapper according to the locale let conversation = (locale == "ar") ? conversation_ar : conversation_en; // Prepare Watson request let payload = { workspace_id: workspace, context: [], input: { text: session.message.text } }; let conversationContext = { workspaceId: workspace, watsonContext: {} }; ...</span></span></code> </pre> </div></div><br>  By default, the Bot Builder SDK localization system is file-based and allows the bot to support several languages ‚Äã‚Äãusing JSON files stored on disk.  By default, the localization system when calling methods such as <code>builder.Prompts.choice()</code> or <code>session.send()</code> searches for the bot's messages in the <code>./locale/&lt;&gt;/index.json</code> file, where the <a href="https://en.wikipedia.org/wiki/IETF_language_tag">IETF language tag</a> represents the selected locale for which search posts.  The following screenshot shows the resulting structure of the project directories for the English and Arabic languages: <br><br><img src="https://habrastorage.org/webt/v1/am/ir/v1amirkl4i4emj5ye_zbdwgfsik.png" alt="image"><br><br>  The structure of this JSON file is a simple mapping (correspondence) of the message identifier to a localized text string.  The bot automatically extracts the localized version of the message if the message ID is passed to the <code>session.send()</code> method instead of the previously localized text string: <br><br><pre> <code class="javascript hljs">session.send(<span class="hljs-string"><span class="hljs-string">"greeting_message"</span></span>);</code> </pre> <br>  Another way to get a localized text string by message id is to call the <code>session.localizer.gettext()</code> method.  For ease of use, I wrote an extension of the <b>Session</b> class and wrote a wrapper like the <code>tr()</code> function from Qt (all the same, JavaScript is sometimes a very handy thing!).  Here you can also implement the substitution of tokens of the type {name}, {id}, {phone}, etc .: <br><br><div class="spoiler">  <b class="spoiler_title">tr () extension function</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Session } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'botbuilder'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Object extension function for strings localization (translation) Session.prototype.tr = function (text) { return this.localizer.gettext(this.preferredLocale(), text) .replace("{name}", this.userName()); }; // Object extension function to get user id Session.prototype.userId = function () { return this.message.address.user.id; }; // Object extension function to get user name Session.prototype.userName = function () { return this.message.address.user.name; };</span></span></code> </pre> </div></div><br>  Now we can easily implement the answer to the user in any language.  When implementing a simple bot in question-answer format, the undoubted advantage of Watson for us was that, <u>regardless of the</u> <i>workspace</i> <u>language</u> , it can return recognized intent-entity pairs in any language ( <a href="https://stephaneeyskens.wordpress.com/2017/07/16/ibm-watsons-conversation-service-vs-luisbot-framework-to-build-chatbots/">how to teach</a> ), in our case - in English.  Therefore, possible answers were conveniently organized as a <u>single</u> JS object <u>for both languages</u> , which works as an associative array of functions: <br><br><div class="spoiler">  <b class="spoiler_title">Response object</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> responses = { <span class="hljs-comment"><span class="hljs-comment">// Responses object "greeting": { "no_entities": async function (session) { session.send("greeting_message"); }, }, "purchase": { "sale-stop": async function (session) { session.send("3_sales_end_dates"); }, "product-sale": async function (session) { session.send("4_sale_still_running"); }, /** @param {Session} session */ "price-product": async function (session) { session.send(session.tr("6_product_prices")); }, "price": async function (session) { session.send(session.tr("6_product_prices")); }, }, "inquiry": { "job": async function (session) { session.send("5_job_opportunity"); }, ... }, ... }</span></span></code> </pre> </div></div><br>  Now we can rewrite the callback that is called after the request to Watson: <br><br><div class="spoiler">  <b class="spoiler_title">Watson request callback function</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Send request to Watson conversation.message(payload, async function (err, response) { if (err) { console.log(err); session.send(err); } else { // Generate response to user according to Watson intent-entity pairs let processed = false; // Get intent let intent = (response.intents[0]) ? response.intents[0].intent : undefined; for(i = 0; i &lt; response.entities.length; i++) { // Process single entity in response let entity = (response.entities[i]) ? response.entities[i].entity : undefined; // Process single entity in response if (responses[intent] &amp;&amp; responses[intent][entity]) { await responses[intent][entity](session, intent, [response.entities[i]]); processed = true; break; } } // Message was not recognized if(!processed) { session.send(session.tr("get_started")); } conversationContext.watsonContext = response.context; } });</span></span></code> </pre> </div></div><br>  Here is a simple version of this function; in a real project, of course, it is more complicated. <br><br>  That's all on the topic!  We got a bilingual bot.  After launch, we can enjoy the result - the bot's automatic responses: <br><br><img src="https://habrastorage.org/webt/-f/u5/q3/-fu5q3srxm3-j0gc6xdxm9vtsf8.png"></div><p>Source: <a href="https://habr.com/ru/post/340092/">https://habr.com/ru/post/340092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340074/index.html">Amazon EFS is faster when there is a lot of data.</a></li>
<li><a href="../340076/index.html">Nuances of encryption in git</a></li>
<li><a href="../340086/index.html">When to be kind is beneficial</a></li>
<li><a href="../340088/index.html">Caution! Angry dog! Or how to tame the registration form</a></li>
<li><a href="../340090/index.html">Simple loading animation in Material Design (CSS3)</a></li>
<li><a href="../340096/index.html">Another post "why Agile does not work" (with pictures)</a></li>
<li><a href="../340100/index.html">Hilbert curve vs Z-order</a></li>
<li><a href="../340104/index.html">Western Digital released the first 14 terabyte HDD</a></li>
<li><a href="../340106/index.html">How we drove drug dealers out of the runet</a></li>
<li><a href="../340108/index.html">Accelerate the vagrant shared-folder on the Windows host (UPD. Not everything is so smooth)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>