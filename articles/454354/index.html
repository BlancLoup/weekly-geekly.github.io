<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Internship at JetBrains and how I almost managed to get on it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Like many young developers, when there is a desire to find a job / internship - I look in the direction of the coolest IT companies. 

 Recently, I tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Internship at JetBrains and how I almost managed to get on it</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/d42/5b8/da4/d425b8da4aec5f7359e39503e9f1d700.jpg" alt="image"><br><br>  Like many young developers, when there is a desire to find a job / internship - I look in the direction of the coolest IT companies. <br><br>  Recently, I tried to get into the ranks of JetBrains and under the cut is ready to share my experience. <br><a name="habracut"></a><br><h3>  Why "almost" succeeded? </h3><br>  Surely you immediately have such a question. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In my opinion, I have a good resume with a bunch of achivok and a good skill, which I have been improving over the last 8-9 years, day after day. <br><br>  I completed the test task (and it seems to me well), had previously visited the JB office, which is good in my city, communicated with HH and some of the developers of the company, and as a result was refused an internship without any comments. <br><br>  Most likely the reason lies in the fact that JetBrains selects only students for an internship, and at the moment I just graduated from the 11th and pass exams one by one. <br><br>  Well, this is a reason for another year to train yourself and apply for the next year. <br><br><h3>  Test case analysis </h3><br>  The deadlines for submitting applications for internships and testing of test tasks are over, which means that everyone who solved them, including me, can lay out an analysis of these tasks so that next year any student can get acquainted with the approximate level of assignments with JB which he will have to face and in which case he will tighten up his knowledge. <br><br>  I applied for an internship in the development team of the Korutin debugger for Kotlin. <br><br>  The task of this team on internship for those who got it this year will be the refinement of this part of the debugger and its integration with the IDE. <br><br>  The task was a bit expected - to write a debugger for a small PL. <br><br>  I would not say that it is difficult, rather the opposite.  It does not require any deep knowledge of the theory of building translators and a cool skill.  But nevertheless, those who are applying for an internship in this area must at least have these basics and easily cope with this task.  I was surprised when I decided to search on github for the keywords of the solutions of my ‚Äúcompetitors‚Äù and found 1-2 more or less working-type solutions against about 6-7 empty repositories or with a couple of pieces of code, after which people gave up.  Maybe I was looking badly, but nevertheless the results did not please me.  If this post is read by people who have abandoned this task, do not do this in the future.  In extreme cases, it was enough to sit on the task for a couple of days and I am sure you would have coped with it. <br><br><div class="spoiler">  <b class="spoiler_title">Task text itself</b> <div class="spoiler_text">  Task: implement step-by-step execution of the code for the trivial programming language Guu. <br><br>  Attention: in the description below, some essential points are obviously omitted.  As a rule, they remain at your discretion.  If it is completely incomprehensible, write to (here the mail, which I decided to remove). <br><br>  The program on Guu consists of a set of procedures.  Each procedure begins with the line sub (subname) and ends with a declaration of another procedure (or the end of the file, if the procedure in the file is the last).  Execution begins with sub main. <br><br>  The body of the procedure is a set of instructions, each of which is on a separate line.  At the beginning of the line may appear insignificant tabs or spaces.  Blank lines are ignored.  There are no comments on Guu. <br><br>  In Guu, there are only three operators: - set (varname) (new value) - setting the new integer value of a variable.  - call (subname) - procedure call.  Calls can be recursive.  - print (varname) - print the value of the variable on the screen. <br><br>  Variables in Guu have a global scope.  The program below will display the string a = 2. <br><br>  sub main <br>  set a 1 <br>  call foo <br>  print a <br><br>  sub foo <br>  set a 2 <br><br>  But the simplest program with infinite recursion: <br><br>  sub main <br>  call main <br><br>  You must write a step-by-step interpreter for Guu.  When it is started, the debugger should stop at the line with the first instruction in sub main and wait for commands from the user.  The minimum required set of debugger commands: <br><br>  i - step into, the debugger comes in call (subname). <br>  o - step over, the debugger does not go inside the call. <br>  trace - print stack trace execution with line numbers starting from main ... <br>  var - print the values ‚Äã‚Äãof all declared variables. <br><br>  The format of the user's communication with the debugger remains at a higher discretion.  You can choose both minimalistic GDB-like interface and console or graphic UI.  The names of the debugger commands can be changed if desired. <br><br>  To solve this problem, you can use any programming language from TIOBE TOP 50 and open-source compiler / interpreter. <br><br>  In evaluating the work will be evaluated: <br><br>  The overall performance of the program; <br>  The quality of the source code and the availability of tests; <br>  Easy extension of functionality (for example, support for new language statements or debugger instructions). <br>  The solution with the instruction for its assembly should be published in the Git-repository (for example, on GitHub or BitBucket).  In the answer you need to specify a link to the repository.  The link to the private GitHub repository will do as well, only you will need to add me to it. <br></div></div><br>  I am writing in C ++, Java and Object Pascal. <br><br>  At first there were thoughts to write everything on my YaB (Mash), but I thought that it would not be very convenient for the JB employee to check, and I filed an application 2 days before the closing of the submission (exams still ...), and it was already evening outside the window - I decided to quickly write everything in more known languages. <br><br>  To solve the Pascal problem, in my opinion, it is most suitable, at least because of the most convenient implementation of strings ... <br><br>  At least for me.  In addition, it is in TIOBE TOP 50, so I boldly launched an IDE, namely, Lazarus, since  He is not commercial :) and started to solve the problem. <br><br>  Despite the fact that JB gives as many as 7 days, in total I spent about an hour in total, and the project turned out to be about 500 lines of code. <br><br><h3>  Where to begin? </h3><br>  First of all, you need to imagine how the debugging of the code will eventually work. <br><br>  We need to implement step-by-step code execution - each instruction should be represented as a structure / class and, in general, instructions should look like a list of these classes or, as in my implementation, refer to each other to form a sequence (later I will write down why I did so). <br><br>  To get this sequence, our debugger needs to process the code in the proposed language, which means we also need to implement a small parser, as well as syntactic and semantic analysis of the code. <br><br>  Let's start with the implementation of the parser.  Because  Guu language consists of a set of tokens, separated by a space, then it is logical first of all to write a small and simple tokenizer: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; tokenNum: word)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := Trim(s); s := StringReplace(s, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, [rfReplaceAll]); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokenNum &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, <span class="hljs-number"><span class="hljs-number">1</span></span>, p) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(tokenNum); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, p, Length(s)); Result := s; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Further we declare enum from tokens: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuToken = (opSub, opSet, opCall, opPrint, opUnknown); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GuuToken: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[opSub..opPrint] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ( <span class="hljs-string"><span class="hljs-string">'sub'</span></span>, <span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'call'</span></span>, <span class="hljs-string"><span class="hljs-string">'print'</span></span> );</code> </pre><br>  And the instruction class itself, into which we will parse the lines of code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpType : TGuuToken; OpArgs : TStringList; OpLine : Cardinal; OpUnChangedLine: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NextOp : TGuuOp; OpReg : Pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  The instruction will be stored in OpType, and the remaining parts of the structure in OpArgs. <br>  OpLine, OpUnChangedLine - information for the debugger. <br><br>  NextOp - pointer to the next instruction.  If it is equal to nil (null in Pascal), then there are no instructions and you need to complete the execution of the code, or return to the callback stack. <br><br>  OpReg is a small pointer-register that will be used later for a small optimization of code execution. <br><br>  After the class declaration was written - I decided that the most compact and beautiful solution would be to add a parser and a little syntax analysis in its constructor, which I further did: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * That method parse code line. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; w: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; OpArgs := TStringList.Create; OpLine := LineNum; OpUnChangedLine := Line; NextOp := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; OpReg := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; s := GetToken(Line, <span class="hljs-number"><span class="hljs-number">1</span></span>); OpType := TGuuToken(AnsiIndexStr(s, GuuToken)); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub : <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// sub &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "sub" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opSet : begin // set &lt;var&gt; &lt;value&gt; OpArgs.Add(GetToken(Line, 2)); OpArgs.Add(GetToken(Line, 3)); w := 1; while w &lt; Length(OpArgs[1]) + 1 do begin if not (OpArgs[1][w] in ['0'..'9']) then begin writeln('[Syntax error]: Invalid variable assigment "', Line, '" at line ', OpLine, '.'); halt; end; inc(w); end; if (Length(OpArgs[0]) = 0) or (Length(OpArgs[1]) = 0) or (Length(GetToken(Line, 4)) &gt; 0) then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end end; opCall : begin // call &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "call" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opPrint: begin // print &lt;var&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "print" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; else begin writeln('[Syntax error]: Invalid token "', s, '" at line ', OpLine, '.'); halt; end; end; end; destructor TGuuOp.Destroy; begin FreeAndNil(OpArgs); inherited; end;</span></span></code> </pre><br>  Here we essentially check the beginning of the construction (ie, the first word), and then we look at the other tokens and their number.  If something is clearly wrong with the code, then we display an error. <br><br>  In the main piece of code, we simply read the code from the file in TStringList, call the TGuuOp constructors line by line and store the pointers to the instances of the classes in GuuOps: TList. <br><br>  Ads: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LabelNames: TStringList; GuuOps, GuuVars: TList; SubMain: TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>;</code> </pre><br>  In conjunction with the code parsing, it would be nice to perform a couple more actions: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Parsing code lines and define variables and labels. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; GV: TGuuVar; c: cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Trim(Line) &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp.Create(LineNum, Line); GuuOps.Add(Op); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Op.OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// define variable and/or optimisation var calling GV := nil; c := 0; while c &lt; GuuVars.Count do begin if TGuuVar(GuuVars[c]).gvName = Op.OpArgs[0] then begin GV := TGuuVar(GuuVars[c]); break; end; inc(c); end; if GV = nil then begin GV := TGuuVar.Create(Op.OpArgs[0]); GuuVars.Add(GV); end; Op.OpReg := GV; end; opSub: begin // Check for label dublicade declaration if Op.OpArgs[0] = 'main' then SubMain := Op; if LabelNames.IndexOf(Op.OpArgs[0]) &lt;&gt; -1 then begin writeln('[Error]: Dublicate sub "', Op.OpArgs[0], '" declaration at line ', Op.OpLine, '.'); halt; end else LabelNames.Add(Op.OpArgs[0]); end; end; end; end;</span></span></code> </pre><br>  At this stage, you can check the entry points at the time of the override and recall OpReg - I used it to store a pointer to a Guu variable. <br><br>  Speaking of variables, this small piece of code was taken to a separate unit: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uVars; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuVar = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> gvName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; gvVal: variant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuVar</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; gvName := VarName; gvVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Now we have parsed code, which seems to be correct in syntax.  It remains to analyze it and you can proceed to the implementation and the most important thing - debugging. <br><br>  Next, you should implement a small semantic analysis and simultaneously prepare everything for the execution and debugging of the code: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSemantic</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Semantic analyse and calls optimisation. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c, x: cardinal; op: TGuuOp; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GuuOps.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpType &lt;&gt; opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Operation outside sub at line '</span></span>, TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; c := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> c &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TGuuOp(GuuOps[c]).OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub:; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; op := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpType = opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> op := TGuuOp(GuuOps[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> TGuuOp(GuuOps[c]).OpReg := op <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Calling to not exist sub "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuVars.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuVar(GuuVars[x]).gvName = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c]).OpReg := TGuuVar(GuuVars[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[c]).OpReg = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Variable "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" for print doesn''t exist at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(c); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In TGuuOp.NextOp of each token we write a pointer to the next token. <br>  For the call opcode, we do everything cleverly and simply - we write a pointer to the called entry point in NextOp. <br><br>  We also check the output variables using the print instruction ... <br><br>  Maybe they were not announced before the withdrawal? <br><br>  Now you need to implement code execution.  We return to the TGuuOp class and implement the Step method: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-comment"><span class="hljs-comment">(* * That method execute instruction. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; CBSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Trace.Add(<span class="hljs-string"><span class="hljs-string">'-&gt; Sub "'</span></span> + OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StepInto <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NextOp &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallBacks.Add(NextOp); Result := TGuuOp(OpReg); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(OpReg); CBSize := CallBacks.Count; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((Op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CallBacks.Count &gt; CBSize)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Op = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]); CallBacks.Delete(CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Trace.Delete(Trace.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Op := Op.Step(StepInto, CallBacks, Trace); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(TGuuVar(OpReg).gvName, <span class="hljs-string"><span class="hljs-string">' = '</span></span>, TGuuVar(OpReg).gvVal); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuVar(OpReg).gvVal := OpArgs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  To avoid access violation in case of looping, it is better to limit the stack, which I did. <br>  The constant STACK_SIZE = 2048, declared above, is just responsible for this. <br><br>  Now it's finally time to write the main code of our debugger: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code: TStringList; c: Cardinal; cmd: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; CallBacks: TList; Trace: TStringList; DebugMode: boolean = true; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ParamCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// Initialisation if not FileExists(ParamStr(1)) then begin writeln('[Error]: Can''t open file "', ParamStr(1), '".'); halt; end; if ParamCount &gt; 1 then if LowerCase(ParamStr(2)) = '/run' then DebugMode := false; code := TStringList.Create; code.LoadFromFile(ParamStr(1)); GuuOps := TList.Create; GuuVars := TList.Create; // Parsing and preparing LabelNames := TStringList.Create; c := 0; while c &lt; code.Count do begin ParseNext(c + 1, Trim(code[c])); inc(c); end; FreeAndNil(LabelNames); CheckSemantic; if SubMain = nil then begin writeln('[Error]: Sub "main" doesn''t exist!'); halt; end; // Start code execution CurrentOp := SubMain; CallBacks := TList.Create; Trace := TStringList.Create; if DebugMode then begin //Out code and features ClrScr; writeln('Code for debugging:'); writeln('.....'); c := 0; while c &lt; code.Count do begin writeln(FillSpaces(IntToStr(c + 1), 4), '| ', code[c]); inc(c); end; writeln('"""""'); FreeAndNil(code); writeln(sLineBreak, 'Features:', sLineBreak, '* i - step into.', sLineBreak, '* o - step over.', sLineBreak, '* trace - print stack trace.', sLineBreak, '* var - print variables list.', sLineBreak, '* x - exit.', sLineBreak); // Execution loop while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin write('Line ', CurrentOp.OpLine, ' ~&gt; '); readln(cmd); // Execute commands if cmd = 'i' then CurrentOp := CurrentOp.Step(true, CallBacks, Trace) else if cmd = 'o' then CurrentOp := CurrentOp.Step(false, CallBacks, Trace) else if cmd = 'trace' then begin writeln('| Trace:'); c := 0; while c &lt; Trace.Count do begin writeln('| ', Trace[c]); inc(c); end; writeln('| -&gt; Line ', CurrentOp.OpLine, ': "', CurrentOp.OpUnChangedLine, '".') end else if cmd = 'var' then begin writeln('| Variables list:'); c := 0; while c &lt; GuuVars.Count do begin writeln('| ', TGuuVar(GuuVars[c]).gvName, ' = ', TGuuVar(GuuVars[c]).gvVal); inc(c); end; end else if cmd = 'x' then halt; // Check for method end &amp; make callback if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end else begin // Only run mode (/run) FreeAndNil(code); while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin CurrentOp := CurrentOp.Step(false, CallBacks, Trace); if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end; if Trace.Count &gt;= STACK_SIZE then writeln('[Runtime error]: Stack overflow!'); FreeAndNil(CallBacks); FreeAndNil(Trace); end else writeln( 'Guu debugger v1.0.', sLineBreak, 'Author: Pavel Shiryaev (@RoPi0n).', sLineBreak, 'Run: svmc guu_debugger.vmc &lt;guu source file&gt; [arg]', sLineBreak, 'Args:', sLineBreak, ' /run - Run Guu code.' ); end.</span></span></code> </pre><br>  By the condition of the job, the interface can be implemented as you like. <br><br>  It would be possible to implement a full-fledged UI, to tie SynEdit to the project, but in my opinion, this is empty work, which will not reflect the skill, and besides, for which it will not be paid :) <br><br>  So I limited myself to a small console UI. <br><br>  The code above is not difficult, so you can leave it without comments.  In it, we take the finished TGuuOp's and call their Step. <br><br>  Screenshots of the solved problem: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/ad0/efa/33ead0efa3a07d77d1a6c07010847035.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e1/7eb/41e/3e17eb41e99abece612f09b146464f67.jpg" alt="image"><br><br>  Error information: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/1c5/ea4/6591c5ea44e67f5068bd7fb0e9c2341e.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a0/3f0/733/2a03f07336c5af1333f259d43e4a1396.jpg" alt="image"><br><br>  Link to the repository of my solution: <a href="https://github.com/RoPi0n/JB_InternshipTask_FPC">Klats</a> <br><br><h3>  Results </h3><br>  No special results.  I will have to devote most of the summer to intense rest and searching for a university (well, just in case I get a good exam, of course), instead of two months of work and training in the JetBrains team. <br><br>  Maybe next year a new post will appear on Habr√©, which already describes the internship process in JB or in another company that is interesting to me :) </div><p>Source: <a href="https://habr.com/ru/post/454354/">https://habr.com/ru/post/454354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454346/index.html">Efficiency Algorithms: Nobelic 2019 Surveillance Camera Review</a></li>
<li><a href="../454348/index.html">State control with React Hooks - without Redux and Context API</a></li>
<li><a href="../45435/index.html">Safari 3.2.1 Update</a></li>
<li><a href="../454350/index.html">‚ÄúThick and thin‚Äù or how I mastered neural networks</a></li>
<li><a href="../454352/index.html">Mathematical uncertainties on the example of Python</a></li>
<li><a href="../454356/index.html">3rd edition podcast. Runet vs TV, ARM vs Intel, state data unification, without a smartphone in 2019, Soviet dreams of the future</a></li>
<li><a href="../454358/index.html">Dual space model</a></li>
<li><a href="../45436/index.html">New Wide Screen Player on Youtube</a></li>
<li><a href="../454366/index.html">Victory on PHDays 9. We share life hacking in three parts. Part 2</a></li>
<li><a href="../454368/index.html">TeamCity plugin developer contest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>