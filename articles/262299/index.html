<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WPF pitfalls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anyone who has been developing applications using WPF for quite a long time probably noticed that this framework is not as easy to use as it might see...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WPF pitfalls</h1><div class="post__text post__text-html js-mediator-article">  Anyone who has been developing applications using WPF for quite a long time probably noticed that this framework is not as easy to use as it might seem at first glance.  In this article I tried to collect some of the most typical problems and ways to solve them. <br><a name="habracut"></a><br><ol><li>  <a href="https://habr.com/ru/post/262299/">ResourceDictionary clogged memory</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Memory leaks</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Inheritance of visual components and styles</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Buying errors</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Standard Validation Tools</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Incorrect use of the PropertyChanged event</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Overuse Dispatcher</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Modal dialogs</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Mapping performance analysis</a> </li><li>  <a href="https://habr.com/ru/post/262299/">And a little more about INotifyPropertyChanged</a> </li><li>  <a href="https://habr.com/ru/post/262299/">Instead of an afterword</a> </li></ol><br><a name="1"></a><h2>  ResourceDictionary clogged memory </h2><br>  Often, developers explicitly include the necessary resource dictionaries right in the XAML markup of user controls like this: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"SomeProject.SomeControl"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><span class="hljs-tag"> &lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">UserControl.Resources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary.MergedDictionaries</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Source</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/Styles/General.xaml"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary.MergedDictionaries</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl.Resources</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  At first glance, in this approach there is no problem - just for the control, we specify the minimum required set of styles.  Suppose in our application SomeControl exists in 10 instances on one of the windows.  The problem is that when creating each of these instances, the specified dictionary will be re-read, processed and stored in a separate copy in memory.  The more dictionaries are connected, the more copies - the more time it takes to initialize the view containing them and the more memory is wasted.  I had to deal in practice with an application in which the memory overrun due to the extra ResourceDictionary was about 200 megabytes. <br><br>  I know two options for solving this problem.  The first is to connect all the necessary style dictionaries only in App.xaml and nowhere else.  It may well be suitable for small applications, but for complex projects may be unacceptable.  The second - instead of the standard ResourceDictionary use his successor, which caches dictionaries in such a way that each of them is stored in memory only in one instance.  Unfortunately, WPF for some reason does not provide such an opportunity out of the box, but it is easy to implement on your own.  One of the most complete solutions can be found in the last answer here - <a href="http://stackoverflow.com/questions/6857355/memory-leak-when-using-sharedresourcedictionary">http://stackoverflow.com/questions/6857355/memory-leak-when-using-sharedresourcedictionary</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="2"></a><h2>  Memory leaks </h2><br><h3>  Event leaks </h3><br>  Even in an environment with automatic garbage collection, you can easily get memory leaks.  The most common cause of leaks, and not only in WPF projects, is subscription to events without subsequent removal of the handler.  Although this is not a problem of the technology itself, it is worthwhile to dwell on it, since WPF projects often use events and the probability of an error is high. <br><br>  For example, the application has a list of objects whose properties can be changed in the editing window.  To implement this window, it was necessary to set IsModified to true inside its view model when changing any property of the object being edited. <br><br>  Suppose the view model for editing is implemented like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EntityEditorViewModel</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... public EntityEditorViewModel(EntityViewModel entity) { Entity = entity; Entity.PropertyChanged += (s, e) =&gt; IsModified = true; } }</span></span></code> </pre><br>  Here the constructor establishes a ‚Äústrong‚Äù link between the business entity and the editor's view model.  If you create an instance of EntityEditorViewModel each time the window is displayed, such objects will be accumulated in memory and deleted only if the business entity that references them becomes ‚Äúgarbage‚Äù. <br><br>  One solution to the problem is to consider removing the handler.  For example, implement IDisposable and in the Dispose () method "unsubscribe" from the event.  But here it is right to say that the handlers specified by lambda expressions as in the example cannot be deleted in a simple way, i.e.  Here it does not work: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     ! entity.PropertyChanged -= (s, e) =&gt; IsModified = true;</span></span></code> </pre><br>  To solve the problem correctly, you need to declare a separate method, place the IsModified installation in it and use it as a handler, as always was done before the appearance of lambda expressions in C #. <br><br>  But the approach with explicit deletion does not guarantee the absence of memory leaks - you can simply forget to call Dispose ().  In addition, it can be very problematic to determine the moment when you need to call it.  Alternatively, you can consider a more cumbersome, but effective approach - Weak Events.  The general idea of ‚Äã‚Äãtheir implementation is that a ‚Äúweak‚Äù link is established between the source of the event and the subscriber, and the subscriber can be automatically deleted when there are no more ‚Äústrong‚Äù links to it. <br><br>  An explanation of the implementation of the Weak Events pattern is beyond the scope of this article, so I‚Äôll just point out a link where this topic is covered in great detail: <a href="http://www.codeproject.com/Articles/29922/Weak-Events-in-C">http://www.codeproject.com/Articles/29922/Weak-Events-in-C</a> . <br><br><h3>  Binding Leaks </h3><br>  In addition to the potential problem described above, WPF has at least two types of leaks that are specific to this technology. <br><br>  Suppose we have a simple object: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeModelEntity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  And we bind to this property from any control: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding Entity.Name, Mode=OneWay}"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  If the property to which the binding goes is not a DependencyProperty, or the object containing it does not implement INotifyPropertyChanged - the binding mechanism uses the ValueChanged event of the System.ComponentModel.PropertyDescriptor class to track changes.  The problem here is that the framework holds a link to the PropertyDescriptor instance, which in turn refers to the original object, and it is unclear when this instance can be deleted.  It should be noted that in the case of OneTime Bayding, the problem is not relevant, since it is not necessary to track changes. <br><br>  Information about this problem is also in the Microsoft Knowledge Base: <a href="https://support.microsoft.com/en-us/kb/938416">https://support.microsoft.com/en-us/kb/938416</a> , but it indicates one additional condition for the occurrence of a leak.  If we apply it to the previous example, we‚Äôll get that the SomeModelEntity instance must directly or indirectly refer to the TextBox for a leak to occur.  On the one hand, such a condition is rarely fulfilled in practice, but in reality it is better to always adhere to a more ‚Äúcleaner‚Äù approach ‚Äî either explicitly specify the OneDime buyding mode if you do not need to follow the changes, or implement INotifyPropertyChanged on the source object, or make the DependencyProperty property (makes sense for the properties of visual components). <br><br>  Another possible problem when installing banding is binding to collections that do not implement the INotifyCollectionChanged interface.  The mechanism of occurrence of leaks in this case is very similar to the previous one.  The way to fight is obvious - you must either explicitly specify the OneTime binding mode, or use collections that implement INotifyCollectionChanged ‚Äî for example, ObservableCollection. <br><br><a name="3"></a><h2>  Inheritance of visual components and styles </h2><br>  Sometimes it is necessary to inherit standard controls to extend their functionality, change behavior.  At first glance, this is elementary: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomComboBox</span></span> : <span class="hljs-title"><span class="hljs-title">ComboBox</span></span> { <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ }</span></span></code> </pre><br>  But if the application uses styles of elements other than the default styles, the problem with using such an inheritor will be immediately noticeable.  The following screenshot shows the difference in the display of the base control and the derivative with the PresentationFramework.Aero theme enabled. <br><br><img src="https://habrastorage.org/files/9d4/a47/212/9d4a47212cde4233a877e5fe8551e0cc.png"><br><br>  The easiest way to fix this is in the XAML file after including the theme resources to determine the style for the derived element, as inherited from the base element.  This is easily accomplished using the BasedOn attribute: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Application.Resources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary.MergedDictionaries</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Source</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/PresentationFramework.Aero;component/themes/Aero.NormalColor.xaml"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary.MergedDictionaries</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Style</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TargetType</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Type my:CustomComboBox}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BasedOn</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{StaticResource {x:Type ComboBox}}"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceDictionary</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Application.Resources</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  But it turns out that when using a derived control, you should always remember to add a style to the resources.  Or make a file with this derived style and connect it every time you need to use a new element. <br><br>  There is one way to do without changes in XAML - in the constructor of the derived element it is obvious to set the style taken from the base one: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomComboBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SetResourceReference(StyleProperty, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ComboBox)); }</code> </pre><br>  Thus, if you do not need to add any changes to the base style, this method will be the most optimal.  Otherwise, it is better to use the previous option. <br><br><a name="4"></a><h2>  Buying errors </h2><br>  The declarative binding of controls to the fields of the model, of course, has its advantages, but its integrity is not so easy to follow.  If for some reason the property specified in the binding is not found - the error will be written to the debug log ... And that's it.  By default, the user will not see any messages, when started without debugging, no logs of these errors will appear. <br><br>  To make such errors more noticeable to the developer, you can write a special Trace Listener, which will display them as messages: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BindingErrorTraceListener</span></span> : <span class="hljs-title"><span class="hljs-title">TraceListener</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StringBuilder _messageBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message</span></span></span><span class="hljs-function">)</span></span> { _messageBuilder.Append(message); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message</span></span></span><span class="hljs-function">)</span></span> { Write(message); MessageBox.Show(_messageBuilder.ToString(), <span class="hljs-string"><span class="hljs-string">"Binding error"</span></span>, MessageBoxButton.OK, MessageBoxImage.Warning); _messageBuilder.Clear(); } }</code> </pre><br>  And then activate it when the application starts: <br><br><pre> <code class="cs hljs">PresentationTraceSources.DataBindingSource.Listeners.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BindingErrorTraceListener()); PresentationTraceSources.DataBindingSource.Switch.Level = SourceLevels.Error;</code> </pre><br>  After these changes, each binding error will be displayed as a dialog message, <b>but only when started with debugging</b> , so it makes sense to use conditional compilation so that the release agent is not registered in the release versions. <br><br><a name="5"></a><h2>  Standard Validation Tools </h2><br>  There are several ways to validate data in WPF. <br><br>  ValidationRule ‚Äî By inheriting this class, you can create specialized validation rules that are then bound to fields in the XAML markup.  Of the ‚Äúconditional‚Äù advantages, no change in the model classes is required to perform validation, although in some cases this may not be the most optimal option.  But at the same time there is a significant drawback - the ValidationRule does not inherit a DependencyObject, respectively, in the heirs there is no possibility to create properties for which later it will be possible to link.  This means that there is no simple obvious way to validate properties in conjunction with each other ‚Äî for example, if the value of one cannot be greater than the value of the other.  A validation rule implemented in this way can deal only with the current field value and fixed property values ‚Äã‚Äãthat were specified when creating an instance of this rule. <br><br>  IDataErrorInfo, INotifyDataErrorInfo - by implementing these interfaces in the view model classes, you can easily validate both individual properties and several properties in conjunction with each other.  Usually, to reduce the amount of code, one of these interfaces is implemented in the base class of models and provides the means of a concise description of the rules in the heirs.  For example, through the registration of rules in a static constructor for each of the types: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeModelEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RegisterValidator(me =&gt; me.Name, me =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(me.Name), Resources.RequiredFieldMessage); }</code> </pre><br>  Or through attributes: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Required</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _name = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; NotifyPropertyChanged(); } }</code> </pre><br>  A good description of the second option can be found at <a href="http://www.codeproject.com/Articles/97564/Attributes-based-Validation-in-a-WPF-MVVM-Applicat">http://www.codeproject.com/Articles/97564/Attributes-based-Validation-in-a-WPF-MVVM-Applicat</a> . <br><br>  But the approach using the DataErrorInfo interfaces does not cover all validation tasks - in cases where checking a rule requires access to objects outside the validated entity, problems begin to arise.  For example, checking for uniqueness requires access to a complete collection of objects, which means that each element of such a collection must have a link to it, which greatly complicates the work with the object. <br><br>  Unfortunately, there are no standard tools to easily get around this problem in WPF, and you have to write something of your own.  In the simplest case, if its uniqueness should be verified before saving the record, this can be done explicitly in the code before the save is called and the message is shown in case of an error. <br><br>  This approach can actually be generalized too.  We use the idea mentioned above with registering validators in a static constructor.  Here is an example of a base class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ValidatableEntity</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TEntity</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IDataErrorInfo</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ""  protected static void RegisterValidator&lt;TProperty&gt;( Expression&lt;Func&lt;TProperty&gt;&gt; property, Func&lt;TEntity, bool&gt; validate, string message) { //... } // ,         - ,     protected static void RegisterValidatorWithState&lt;TProperty&gt;( Expression&lt;Func&lt;TProperty&gt;&gt; property, Func&lt;TEntity, object, bool&gt; validate, string message) { //... } public bool Validate(object state, out IEnumerable&lt;string&gt; errors) { //        .  ,   RegisterValidatorWithState,   state    . } // IDataErrorInfo,   ,   RegisterValidator }</span></span></code> </pre><br>  As well as an example of use: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeModelEntity</span></span> : <span class="hljs-title"><span class="hljs-title">ValidatableEntity</span></span>&lt;<span class="hljs-title"><span class="hljs-title">SomeModelEntity</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeModelEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RegisterValidator(me =&gt; me.Name, me =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(me.Name), Resources.RequiredFieldMessage); RegisterValidatorWithState(me =&gt; me.Name, (me, all) =&gt; ((IEnumerable&lt;SomeEntity&gt;)all).Any(e =&gt; e.Name == me.Name), Resources.UniqueNameMessage); } }</code> </pre><br>  Thus, all validation rules are within the entity itself.  Those that do not require "external" objects are used in the implementation of IDataErrorInfo from the base class.  To check the rest, it‚Äôs enough to call the Validate function in the right place and use the result to make decisions about further actions. <br><br><a name="6"></a><h2>  Incorrect use of the PropertyChanged event </h2><br>  I quite often had to meet code of this type in WPF projects: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someViewModel_PropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, PropertyChangedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.PropertyName == <span class="hljs-string"><span class="hljs-string">"Quantity"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//- ,  ,   ,    } }</span></span></code> </pre><br>  And in many cases it was a handler of its own events, i.e.  "Listened" to changes in properties of the same class, where it was declared. <br><br>  In this approach, there are several serious flaws, which ultimately lead to very difficult in terms of support and expansion of the code.  Some of them are obvious: for example, when renaming properties, you can forget to change the constants in the conditions, but this is a small and easily solved drawback.  A much more serious problem is that with this approach it is almost impossible to track all the scenarios in which this or that piece of logic is executed. <br><br>  We can formulate the following criterion for self-checking whether the PropertyChanged event handler is used correctly: if the algorithm inside the handler does not depend on the specific property names, then everything is fine.  Otherwise, you need to look for a better solution.  An example of the correct application can be, for example, setting the IsModified property to true when changing any property of the view model. <br><br><a name="7"></a><h2>  Overuse Dispatcher </h2><br>  Repeatedly encountered in WPF projects the enforcement of operations on the UI stream, even in cases where it is not necessary.  In order to describe the scale of the problem, I‚Äôll give a couple of numbers obtained using simple tests on a laptop with a Core i7-3630QM 2.4GHz processor: <br><br><ul><li>  The time spent by Dispatcher.Invoke in excess of the ‚Äúpayload‚Äù when calling from the same thread to which the Dispatcher belongs is 0.2 ¬µs per call. </li><li>  The same indicator, but when calling from another thread - 26 Œºs per call. </li></ul><br>  The first digit does not look terrible, but calling something through the Dispatcher, when it is known that the code will be executed on the UI thread as well, is also wrong.  But the second figure already looks noticeable.  It should be noted that in real complex applications, especially when dispatching from several parallel threads, this time can be much longer.  And on weaker devices - even more. <br><br>  To reduce harm to performance, it‚Äôs enough to follow simple rules: <br><br><ul><li>  Dispatch only what really cannot be done on the background thread.  For example, there is a piece of code that reads something from the WEB service, then does the calculation using some algorithm, then sets a couple of properties on the presentation model.  In this case, only the setting of properties should be dispatched (since, in turn, it calls the PropertyChanged handlers, among which there is code that works with the UI). </li><li>  Avoid loops within which there is a call to the Dispatcher.  For example, you need to read the list from the server, and make an update of the UI for each item.  In this case, it is better to first calculate on the background thread everything that needs to be updated on the UI, and only then with a single call to Dispatcher.Invoke to do the update.  Calling Invoke after processing each item in the list will be a highly non-optimal solution. </li></ul><br><br><a name="8"></a><h2>  Modal dialogs </h2><br>  The use of standard modal messages (MessageBox) in WPF projects is not welcome, since it is simply impossible to customize their appearance in accordance with the visual styles of the application.  Instead of standard messages, you have to write your own implementations, which can be divided into two types: <br><br><ul><li>  A separate modal window (Window.ShowDialog), styled as needed. </li><li>  "Emulation" of the modal window by adding a panel to the visual tree of the main window, which is "above" all the other contents, thereby overlapping it. </li></ul><br>  Each approach has its pros and cons.  The first option is simple to implement, but does not allow to achieve such effects as ‚Äúdarkening‚Äù of the entire contents of the window, above which a modal dialog is displayed.  In some applications, there may be a need for a dialogue of a non-standard form, which is not very easy to do with a regular window. <br><br>  The second option usually causes many problems in the implementation, which are caused by the fact that the display of such a window cannot be synchronous.  That is, it will not be possible to write as with familiar messages: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (MessageBox.Show(Resources.ResetSettingsQuestion, Resources.ResetSettings, MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes) {</code> </pre><br>  and expect that nothing can happen on the main thread until the user answers the question. <br><br>  Consider one of the most simple implementations of the "emulated" dialogue. <br><br>  First of all, we will declare the interface of the dialog box manager through which the view model will display the dialogs.  To begin with, we will not take into account the possibility of receiving a ‚Äúresponse‚Äù from the window - we simply show the dialog with the ‚ÄúClose‚Äù button. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IModalDialogHelper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Text { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } ICommand CloseCommand { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br>  Next, we implement a control that will be ‚Äútied‚Äù to the manager and show the window on top of the other elements, when necessary: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">x:Class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"TestDialog.ModalDialog"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:x</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/winfx/2006/xaml"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:mc</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.openxmlformats.org/markup-compatibility/2006"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:d</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.microsoft.com/expression/blend/2008"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mc:Ignorable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"d"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">d:DesignHeight</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">d:DesignWidth</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Panel.ZIndex</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1000"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl.Style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Style</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TargetType</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{x:Type UserControl}"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Setter</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Property</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Visibility"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Collapsed"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Style.Triggers</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">DataTrigger</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Binding</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"{Binding DialogHelper.IsVisible}"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"True"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Setter</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Property</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Visibility"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Visible"</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">DataTrigger</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Style.Triggers</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl.Style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Border</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">HorizontalAlignment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Stretch"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">VerticalAlignment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Stretch"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Background</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DarkGray"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Opacity</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".7"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">HorizontalAlignment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Stretch"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"200"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Background</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"AliceBlue"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid.RowDefinitions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RowDefinition</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RowDefinition</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Auto"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid.RowDefinitions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Grid.Row</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding DialogHelper.Text}"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Grid.Row</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Close"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Command</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{Binding DialogHelper.CloseCommand}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">HorizontalAlignment</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Right"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">UserControl</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, for simplicity, this control is designed for the fact that in the view model there is an instance of the implementation of IModalDialogHelper in the DialogHelper property. In a more universal solution, it should be possible to substitute any property. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not give here an example of the simplest IModalDialogHelper implementation, since it is obvious: the Show () and Close () methods set IsVisible appropriately, the CloseCommand command simply calls the Close () method. Show () still sets the Text property.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems to be simple: call the Show () method with the desired message text, it makes the panel with the message and the button visible, then clicking the Close button sets IsVisible to its original value and the ‚Äúdialog‚Äù will disappear from the screen. </font><font style="vertical-align: inherit;">But there is already the first problem - the sequential display of several messages leads to the fact that the user sees only the last, since the Show () method does not expect the closure of the previous dialog. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, let's slightly change the prototype of the Show method:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The ability to wait for the completion of this method through await gives the paste several advantages: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Showing multiple messages in a row from the same thread will work correctly, unlike the previous example. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can implement the method in such a way that even calling a message from different threads will work correctly and wait for the already shown dialog to close. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can return a modal result as in the ‚Äúold‚Äù MessageBox.Show (). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here I will give one of the options for implementing IModalDialogHelper interface with asynchronous Show, which corresponds to the above points (although this implementation always returns the same modal result, it will not be difficult to make it dependent on the pressed button). </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ModalDialogHelper</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span>, <span class="hljs-title"><span class="hljs-title">IModalDialogHelper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Queue&lt;TaskCompletionSource&lt;MessageBoxResult&gt;&gt; _waits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;TaskCompletionSource&lt;MessageBoxResult&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> syncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dispatcher _dispatcher = Dispatcher.CurrentDispatcher; <span class="hljs-comment"><span class="hljs-comment">//... public async Task Show(string text) { List&lt;TaskCompletionSource&lt;MessageBoxResult&gt;&gt; previousWaits; TaskCompletionSource&lt;MessageBoxResult&gt; currentWait; lock (syncObject) { //  ,    previousWaits = _waits.ToList(); //      currentWait = new TaskCompletionSource&lt;MessageBoxResult&gt;(); _waits.Enqueue(currentWait); } //  ,      foreach (var wait in previousWaits) { await wait.Task; } //        _dispatcher.Invoke(() =&gt; { Text = text; IsVisible = true; }); await currentWait.Task; } public void Close() { IsVisible = false; TaskCompletionSource&lt;MessageBoxResult&gt; wait; lock (syncObject) { //     wait = _waits.Dequeue(); } //            wait.SetResult(MessageBoxResult.OK); } //... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The basic idea behind this solution is that for each Show call, an instance of TaskCompletionSource is created. Waiting for a task created inside it will continue until the result is specified via a call to SetResult. Show, before displaying its message, waits for all the tasks that are already in the queue; after the display, it waits for its own, and Close sets the result of the current task, thereby completing it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And a few words should be said about the use of ‚Äúnew‚Äù dialogs in event handlers of the CancelEventHandler type. Confirmation of actions in such events will also need to be implemented a little differently from before.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     ! private async void Window_Closing(object sender, CancelEventArgs e) { e.Cancel = true; if(await dialogHelper.Show("Do you really want to close the window", MessageBoxButton.YesNo) == MessageBoxResult.Yes) { e.Cancel = false; } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem is that e.Cancel will always be true for the code that caused Window_Closing, since await does not stop the execution of the stream, but creates the ability to ‚Äúreturn‚Äù to the right place in the method after the completion of the asynchronous task. </font><font style="vertical-align: inherit;">For the calling code, Windows_Closing will exit immediately after setting e.Cancel to true. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The correct solution is that the condition body should no longer operate with e.Cancel, but explicitly call the ‚Äúcanceled‚Äù action in such a way that it is guaranteed to be executed without additional requests, bypassing the repeated call of this handler. </font><font style="vertical-align: inherit;">In the case of closing the main program window, for example, it can be an explicit call for the completion of the entire application.</font></font><br><br><a name="9"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapping performance analysis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many developers know what a profiler is and know what tools are available for analyzing application performance and analyzing memory consumption. But in WPF applications, part of the load on the processor comes, for example, from the XAML markup processing mechanism - parsing, markup, drawing. ‚ÄúStandard‚Äù profilers find it difficult to determine for which activity related to XAML resources are spent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not dwell on the possibilities of existing tools, just list the links to information about them. Dealing with how to use them is not difficult for any developer.</font></font><br><br><ul><li>        WPF    Visual Studio 2015 ‚Äî <a href="http://blogs.msdn.com/b/wpf/archive/2015/01/16/new-ui-performance-analysis-tool-for-wpf-applications.aspx">http://blogs.msdn.com/b/wpf/archive/2015/01/16/new-ui-performance-analysis-tool-for-wpf-applications.aspx</a> </li><li>     Visual Studio   WPF Performance Suite ‚Äî <a href="https://msdn.microsoft.com/en-us/library/aa969767%2528v%3Dvs.110%2529.aspx">https://msdn.microsoft.com/en-us/library/aa969767%28v=vs.110%29.aspx</a> </li></ul><br><br><a name="10"></a><h2>     INotifyPropertyChanged </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the most popular topics of controversy within the framework of the WPF technology is how to implement INotifyPropertyChanged in the most efficient way. </font><font style="vertical-align: inherit;">The most concise option is to use AOP, as I already described in one of the examples in the </font></font><a href="http://habrahabr.ru/post/246469/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article about Aspect Injector</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But not everyone likes this approach, and you can use snippets as an alternative. </font><font style="vertical-align: inherit;">But then the question arises about the optimal content of the snippet. </font><font style="vertical-align: inherit;">First, I will give examples of not the most successful options.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _name; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _name; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _name = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; NotifyPropertyChanged(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the property name is specified as a constant, and it does not matter if it is in the named constant or, as in the example, ‚Äúhardcoded‚Äù directly in the call to the alert method ‚Äî the problem remains the same: if you rename the property itself, there is a chance to leave the old value of the constant. </font><font style="vertical-align: inherit;">Many people solve this problem by changing the NotifyPropertyChanged method:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NotifyPropertyChanged&lt;T&gt;(Expression&lt;Func&lt;T&gt;&gt; property) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = PropertyChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = ((MemberExpression)property.Body).Member.Name; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyChangedEventArgs(propertyName)); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case, instead of the name, you can specify a lambda expression that returns the desired property: </font></font><br><br><pre> <code class="cs hljs">NotifyPropertyChanged(() =&gt; Name);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, this option also has drawbacks - calling this method is always associated with Reflection, which is a total of hundreds of times slower than calling the previous version of NotifyProperCChanged. </font><font style="vertical-align: inherit;">In the case of mobile applications, this can be critical. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET 4.5, the special attribute CallerMemberNameAttribute has become available, thanks to which the first of the above problems can be solved:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotifyPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[CallerMemberName] </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } public string Name { get { return _name; } set { _name = value; NotifyPropertyChanged(); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the parameter marked with this attribute is not explicitly specified, the compiler will substitute in it the name of the member of the class that calls the method. Thus, the call NotifyPropertyChanged () from the example above is equivalent to NotifyPropertyChanged (‚ÄúName‚Äù). But what to do if you need to report a change in some property ‚Äúoutside‚Äù, not from its setter? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we have a ‚Äúcalculation‚Äù property:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TotalPrice { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.Sum(i =&gt; i.Price); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When adding, removing, or changing items in the items collection, we need to report a change to TotalPrice so that the user interface always displays its current value. Given the shortcomings of the first two solutions given above, you can make the next move - still use Reflection to get the name of a property from a lambda expression, but store it in a static variable. Thus, for each individual property, a ‚Äúheavy‚Äù operation will be performed only once.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResultsViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TotalPricePropertyName = ExpressionUtils.GetPropertyName&lt;ResultsViewModel&gt;(m =&gt; m.TotalPrice); <span class="hljs-comment"><span class="hljs-comment">//... NotifyPropertyChanged(TotalPricePropertyName); //... } public static class ExpressionUtils { public static string GetPropertyName&lt;TEntity&gt;(Expression&lt;Func&lt;TEntity, object&gt;&gt; property) { var convertExpression = property.Body as UnaryExpression; if(convertExpression != null) { return ((MemberExpression)convertExpression.Operand).Member.Name; } return ((MemberExpression)property.Body).Member.Name; } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The very static function GetPropertyName can be put in the base class for all ‚Äúnotifiable‚Äù entities - it doesn‚Äôt matter. The check on UnaryExpression is needed so that the function normally processes the properties of significant types, since the compiler adds a boxing operation to bring the specified property to object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If your project already uses C # 6.0, then the same task of obtaining the name of another property can be solved much easier - with the help of the keyword nameof. There will be no need for a static variable that remembers the name. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, you can say that if the use of AOP for INotifyPropertyChanged for some reason does not suit you, you can use the following snippet:</font></font><br><br><ul><li>        .NET 4.5 ‚Äî      ,          GetPropertyName,   . A c,   ,    NotifyPropertyChanged   . </li><li>  .NET 4.5   ‚Äî         CallerMemberNameAttribute.    ,     ‚Äî        ,    nameof,     C# 6.0. </li></ul><br><br><a name="11"></a><h2>  Instead of an afterword </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WPF is a good technology that Microsoft still positions as the main framework for developing desktop applications. Unfortunately, when writing programs more difficult "calculator" reveals a number of problems that are not noticeable at first glance, but they are all solvable. According to recent Microsoft statements, they are investing in technology, and there are already a lot of improvements in the new version. First of all, they relate to tools and performance. Hopefully, in the future, new features will be added not only to the tools, but also to the framework itself, facilitating the work of the programmer and eliminating the ‚Äúhacks‚Äù and ‚Äúbicycles‚Äù that have to be done now. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD:</font></font></b>      ¬´    ¬ª           INotifyPropertyChanged   nameof()  C# 6.0 <br><br> <b>UPD2:</b>             TaskCompletionSource. </div><p>Source: <a href="https://habr.com/ru/post/262299/">https://habr.com/ru/post/262299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262283/index.html">From AutoCAD yes to nanoCAD: change of the main CAD system in the design institute</a></li>
<li><a href="../262285/index.html">Using configurable logic cells PIC microcontrollers to control WS2812</a></li>
<li><a href="../262287/index.html">Computer algebra systems for working with tensors</a></li>
<li><a href="../262289/index.html">The best reports of the DevCon 2015 conference - Top 10</a></li>
<li><a href="../262295/index.html">Evolution go</a></li>
<li><a href="../262301/index.html">Iron unlock iCloud on Apple iPad Air 2 Cellular A1567</a></li>
<li><a href="../262305/index.html">Black archeology of datamining: how dangerous are the ‚Äúplums‚Äù of big data</a></li>
<li><a href="../262309/index.html">Legends and myths of modern implementations of x265 / HEVC or x264 vs x265 in comparison of screenshots</a></li>
<li><a href="../262311/index.html">AGTH reverse to recreate an alternate GUI</a></li>
<li><a href="../262315/index.html">Yii 2.0.5 (security fix)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>