<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural level generation for MERC in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part two 
 In the first part of this article, I explained why we chose procedural level generation for the MERC game, and described the requirements f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural level generation for MERC in Unity</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2ad/38b/944/2ad38b94464a4933a9d77bc41aab7e64.jpg"><br><br><h2>  Part two </h2><br>  In the <a href="https://habrahabr.ru/post/321260/">first part of</a> this article, I explained why we chose procedural level generation for the <a href="http://store.steampowered.com/app/555010/">MERC</a> game, and described the requirements for it.  I also described the process of generating a procedural level structure and combining multiple fragments to create a complete level.  In the second part of the article, we will discuss the solution to the problems of lighting and NavMesh in Unity and creating an NPC based on tempo. <br><a name="habracut"></a><br><h2>  Lighting </h2><br>  When creating a procedurally generated route, it is very likely that in each level one fragment will be loaded several times.  Duplicate grids (meshes) of such fragments are stored in memory separately, but <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B0%25D1%2580%25D1%2582%25D0%25B0_%25D0%25BE%25D1%2581%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">lighting maps</a> can be shared by adding the code to merge all lighting maps by scene name into the level loader.  Then the indexes of the lighting maps are reassigned when loading, saving memory and do not duplicate the lighting maps for these fragments. <br><br>  To ensure that the coordinates of the level fragments match with baked lighting and shadows, we baked each scene in the same theme with the same lighting settings.  We found that using the <i>‚Äúskybox‚Äù</i> <i>ambient source</i> setting resulted in a slightly different lighting of each fragment and when joining the fragments, the seams were clearly visible.  Obviously, this did not suit us, so we experimented with different lighting parameters to find the best option.  It turned out that the best results are obtained when changing <i>‚Äúambient source‚Äù</i> to <i>‚Äúgradient‚Äù</i> .  The joints were almost perfect and the seams were invisible.  The image below shows the difference. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/724/50d/d5e/72450dd5eb54a4047311330b0e32d7e4.png" alt="image"><br><br>  When generating the procedural level for MERC, we had one ‚Äúparent‚Äù scene loaded in front of all the fragments.  In this scene there was one directional light source used for real-time lighting, baked with the same parameters as the fragments.  This scene also contained all the global objects and parameters needed for the final level.  When loading fragments, we make this parent scene an ‚Äúactive‚Äù scene in the Unity Scene Manager, so that its parameters are used for the entire scene. <br><br><h2>  Navmesh </h2><br>  We use the <a href="https://docs.unity3d.com/540/Documentation/ScriptReference/NavMesh.html">NavMesh</a> Unity system to route all mercenaries and NPCs.  When we developed this procedural system, the Unity engine did not yet support the dynamic bonding of several NavMeshs during the execution of the game.  In Unity, this feature has been added in the new beta since version 5.6, but at the time of this writing, it is not yet ready.  Therefore, we had to solve the problem by loading several random fragments of levels and applying them together with one NavMesh.  According to reviews from the developers of Unity, the only way to achieve this was to create a single large NavMesh area and cut it into each level fragment.  Therefore, in the parent scene, we created one large flat NavMesh, covering the entire game area.  Then we used Unity's ‚ÄúNavMeshObstacle‚Äù component and forced it to cut all the walls and prefabs.  Then, when they are loaded and placed on NavMesh, they are cut out of it, leaving only the main route for movement. <br><br>  This system works quite well and almost does not affect the loading time of the levels.  The main limitation is that it is impossible to vary the NavMesh lifts in level fragments, because they cut out parts of one flat NavMesh that is in the parent scene.  There is no way to know in advance which fragment will load, so we cannot embed lifts into NavMesh, because the structure of each level is random and dynamic.  After upgrading to Unity 5.6 in the future, we want to improve our system so that it supports the bonding of several NavMesh with different elevations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bfb/5a3/fc6/bfb5a3fc6459b6020a264c8d7bec4274.png" alt="image"><br><br>  After loading each fragment and laying the paths, we wanted to add variations to the fragments so that the duplicate fragments did not look the same.  To do this, we created <i>Procedural Obstacle Volumes</i> (procedural volumes of obstacles) that generate random objects of design and shelter in each level fragment. <br><br><h2>  Procedural Obstacle Volumes </h2><br>  <i>Procedural Obstacle Volume</i> is the amount of space in which randomly selected prefabs of shelter objects are generated.  They allow us to add variability to level fragments, even when loading duplicate fragments. <br><br>  First we created the <i>‚ÄúProceduralObstacle‚Äù</i> component added to each prefab, which can be downloaded through the system.  The component tracks the size of the boundaries of the prefab, labels and other settings.  Each time the prefab is updated in the editor, it is automatically updated in the global manifest <i>ScriptableObject</i> .  This manifest is then used to check prefabs when loading into procedural scope. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df3/a28/a77/df3a28a77a71d60e2b5c1ff49837bddd.png" alt="image"><br><br>  Then we place the <i>Procedural Obstacle Volume</i> game objects inside the level fragments.  These volumes have settings that allow you to select prefabs that can be generated based on labels and directions.  For example, we may need to fill the area only with prefabs designed for open spaces that are destructible and are shelters only in a certain direction.  When loading levels, these volumes are processed and randomly select the appropriate prefabs.  All this processing is based on the initial number (seed), which generates the level (therefore, the process is deterministic and suitable for playing together on a network).  Then we use the standard container packing (bin packing) to place the prefabs in a volume as tightly as possible with a small buffer around so that the mercenaries can make a path between them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/abb/bd3/fb4/abbbd3fb437f0d1e5a127dcd9679b8af.png" alt="image"><br><br>  Over time, we added other functions to the system that simplify the work of level designers.  For example, it is enough to press a button in the editor in order not even to start the game to find out which prefabs can be loaded into the volume.  So you can quickly test what you can load into the volume based on its settings. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e55/929/d74/e55929d7456da5edc734afa734abf896.gif" alt="image"><br><br>  Now that we‚Äôve finished with route generation at levels, obstacles, lighting settings, and NavMesh, we need to populate the levels with enemies! <br><br><h2>  NPC and tempo curves </h2><br>  When creating each level fragment for MERC, we strategically located the NPC creation points within each fragment.  However, we did not want all the enemies to be created during the game, it would be a real meat grinder.  Instead, when loading the procedural level, we determine which point to include based on the tempo curve ( <i>Tempo Curve</i> ). <br><br>  <i>The tempo curve</i> is a simple concept that we came up with to reflect the ‚Äúpulse‚Äù of the level tempo.  Using the graphs of Unity animation curves, we can control how simple or difficult the level will be.  An example is shown below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/819/3b9/c10/8193b9c10df279163ed14b269aa73b68.png" alt="image"><br><br>  When loading a procedural mission, it has the basic complexity of the mission.  We randomly select a tempo curve from the list and estimate the points of the curve relative to each other.  This means that no matter where the points are on the graph, our code finds the lowest one and considers it to be zero or the ‚ÄúDo not create enemies‚Äù level.  Then he finds the highest point and considers it the ‚ÄúMost Difficult‚Äù level.  It then distributes intermediate complexity modifiers with the same increment between the lowest and highest points as follows: <br><br><ul><li>  Do not create enemies (lowest point) </li><li>  The easiest (create the lightest NPC) </li><li>  Simple (create light npc) </li><li>  Basic (corresponds to the complexity of the mission) </li><li>  Difficult (create serious NPC) </li><li>  The most difficult (highest point) </li></ul><br>  For example, if the main route consists of 9 fragments, the points of the tempo curve shown above are distributed from beginning to end of the level.  The first fragment is assigned the ‚ÄúDo not create enemies‚Äù modifier, the fourth point (or the seventh fragment) is assigned the ‚ÄúMost difficult‚Äù modifier, and the last point (or last fragment) is assigned ‚ÄúDo not create enemies‚Äù.  All other fragments are distributed along the points of the curve and determine the pace of NPC creation in these fragments.  The result is a "pulse" of passing the level in relation to the complexity of the NPC.  The above graph slowly grows and gradually reaches a major battle before the end of the main path.  Almost in every fragment of this example, NPCs are created, with the exception of the first and last fragment, therefore there will always be enemies on the level. <br><br>  NPCs in MERC are created using a points system.  We have a complete table of points based on the current squad level and mission difficulty rating.  From it we determine how many points you need to spend when creating an NPC.  If the complexity modifier is ‚ÄúBasic‚Äù, then NPCs are created that correspond to the level of the squad for the selected mission complexity.  If the modifier is equal to ‚ÄúSimple‚Äù or ‚ÄúMost Simple‚Äù, then part of the points when creating an NPC is subtracted.  Likewise, "Complicated" and "Most Complicated" add points to create enemies.  At the points of creation, these points are used to determine the number and level of NPCs created. <br><br>  The main route is filled by the NPC based on the tempo curve, but we also randomly select tempo curves to control the paths to the dead ends.  Therefore, the passage of the level may vary depending on the path chosen by the player.  Such a mixture provides greater variability and replayability of the system of procedural levels. <br><br><h2>  Total </h2><br>  MERC is a recurring game.  Therefore, it greatly benefits from the use of a procedural level generation system. <br><br>  Starting with the creation of the main route and imposing layers taking into account the subsequent requirements, we built a reliable system that can be adjusted and built upon during the development process, as well as add new gameplay mechanics.  By using a single seed for all calculations of random values, we guarantee the deterministic generation of all the data that can be replicated for playing together on a network.  I will be happy to tell you more about the different aspects of this system and will gladly accept any suggestions and feedback.  You can contact me on <a href="https://twitter.com/velvetycouch">Twitter</a> . <br><br>  Now MERC is at the stage of early access to Steam, and we will appreciate your feedback and support. <br><br>  Example of loading the procedural level MERC, top view: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a30/909/b9e/a30909b9ed52c04099a70b77c4120850.gif" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/321602/">https://habr.com/ru/post/321602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321592/index.html">CloudFlare + nginx, or save with the help of the "coffee maker" (upd2: fast speakers dynamics!)</a></li>
<li><a href="../321594/index.html">Introduction to CDRS, Apache Cassandra driver fully written in Rust</a></li>
<li><a href="../321596/index.html">How IT professionals work. Dmitry Tsimoshko, director of information technology at Century 21</a></li>
<li><a href="../321598/index.html">Implementation of the procedure ‚ÄúPlanning Release Release by Product‚Äù by the tools of the Atlassian family</a></li>
<li><a href="../321600/index.html">Kotlin Video Tutorial Series</a></li>
<li><a href="../321604/index.html">Seminar "How much does the data center operation cost?", February 21, OST data center</a></li>
<li><a href="../321606/index.html">Home Assistant or another ‚Äúbrain‚Äù for a project like ‚ÄúSmart Home‚Äù</a></li>
<li><a href="../321612/index.html">Evening class: resizing elements to pure JS</a></li>
<li><a href="../321614/index.html">The tale of an internship in a small company or how Kontur and I competed [Part I]</a></li>
<li><a href="../321618/index.html">Motion Detection Based on OpenCV Bioinspired Module</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>