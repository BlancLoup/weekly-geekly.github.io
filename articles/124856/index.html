<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Game Theory and the Sprague-Grande Function</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear Habrasoobschestvo. 

 Recently, olympiad programming has become more and more widespread, an integral part of which is the knowledge of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Game Theory and the Sprague-Grande Function</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear Habrasoobschestvo. <br><br>  Recently, olympiad programming has become more and more widespread, an integral part of which is the knowledge of algorithms (and, of course, the ability to use them). <br><br>  I want to tell you the basics of the theory of the Games, prove the function of Sprag-Grande, analyze several classic impartial-problems and illustrate them with python code. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Instead of the preface </h4><br>  Search on Habrakhabr showed that about a function of Shprag-Grande <a href="http://habrahabr.ru/blogs/personal/101105/">already wrote</a> .  Unfortunately, very little and not very understandable for a person who has not come across the theory of the Games before.  I will try to open this topic wider. <br><br>  We should start with the fact that the theory developed by Roland Shprag and Patrick Grandi in the middle of the last century extends to games that can be called ‚Äúequal‚Äù (impartial).  This category includes games in which the following conditions are met: <br><ol><li>  the game is finite </li><li>  no draw is possible in the game </li><li>  players see all information about the state of the opponent </li></ol><br>  As examples of such games you can cite the <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B8%25D0%25BC_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">game Nim</a> , Bash and other games.  We will talk about them a bit later, but for now we will discuss what follows from the conditions. <br><br>  The main point, of course, is the finiteness of the game, from which it follows that the process itself can be represented as a movement along an acyclic oriented graph, the vertices of which are the game states, and the edges are transitions between them as a result of the player's turn. <br>  From the fact that the game is impossible to draw, it follows that the state of the game can be divided into winning and losing.  The first are those from which you can go to a losing state, and the second - from which you can not go anywhere, or you can, but only in a winning state. <br><br>  Thus, the solution of problems on the theory of Games related to ‚Äúequal rights‚Äù games can be reduced to studying the state graph of the game and determining the final result. <br><br><h4>  Game Nim </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/c2b/96d/586/c2b96d58691bcd6c2100b1d921a85aec.png" alt="image" align="right"><br>  Consider an example of finding a winning strategy on the example of the game Nimes.  Why?  Because later it will be possible to prove that the conditions of all "equal" games can be reduced to the conditions of the game by Him. <br>  So, we have N heaps, each of which has a positive amount of stones.  Players take turns picking up a positive amount of stones.  When all the heaps become empty, the game ends with the defeat of the player who cannot make a move.  Consequently, the state of the game can be described by a set of N <s>positive</s> positive <b><sup>0</sup></b> numbers, and the game ends when the sum of these numbers becomes zero. <br><br><h4>  Theorem # 1: </h4><br><blockquote>  For the current player, the strategy is winning if and only if the xor sum of <sup><b>1</b></sup> heap sizes is positive. </blockquote><br><br>  Let's prove it. <br>  Suppose we have two arrays of values ‚Äã‚Äã(before [], after []), in one of which (before []) the sizes of the heaps are stored before the player‚Äôs turn, and in the other (after []) - after the player‚Äôs move. <br>  We will store in variables bf and af xor-sums before and after the player‚Äôs turn (where ‚Äú^‚Äù is operation xor): <br>  bf = before [0] ^ before [1] ^ ... ^ before [N - 1] ^ before [N] <br>  af = after [0] ^ after [1] ^ ... ^ after [N - 1] ^ after [N] <br>  Then, using the corollary of the properties xor, we can write: <br>  af = bf ^ before [i] ^ after [i], where "i" is the number of the pile from which the player who made the move took the stones. <br><br>  Based on the above, we prove Theorem # 1 by induction (consider two cases: bf == 0 and bf! = 0): <br>  If bf == 0, then the current state is either losing (and so there are no transitions from it), or there are transitions, but for them the equality af == bf [i] ^ af [i] holds, but since before [i]! = after [i], then af! = 0, which means the transition leads to a winning state by induction. <br>  If bf! = 0, then you need to determine which move will lead to the losing state (ie, af == 0): <br>  Consider the bit record of the number bf.  Take the leading nonzero bit, denoting its number by q.  Let k be the number of that before [] number, in which the qth bit is nonzero (in other words, the number of the required handful). <br>  Suppose that after [k] = before [k] ^ bf (it is assumed that this is the desired move).  Why is it correct?  Because after [k] &lt;before [k].  This follows from the fact that all bits higher than the qth of the after [k] and before [k] are the same, and the qth bit of the before [k] contains a one, and that of the after [k] is zero. <br>  Then we calculate: <br>  af = bf ^ before [k] ^ after [k] = bf ^ before [k] ^ (bf ^ before [k]) = 0 <br>  Since during this move the xor-sum is zero, the theorem is proved. <br><br>  What follows from Theorem 1?  It follows from it that any state of a nim-like (‚Äúequal‚Äù) game can be replaced by an equivalent, but consisting of a single pile, the size of which is equal to the XOR-sum of the sizes of the piles in the old state. <br><br><h4>  Spraga Grande function </h4><br>  The state of any "equal" game can be depicted in the form of it-heaps.  If the heap size is zero, then the state is losing.  If not equal - winning. <br>  Suppose we have a certain state G [], equivalent to a certain heap of size X. This number can be found by induction.  If we know that the state G [i] corresponds to m [i], then m [] will be as follows: <br>  m = mex {m [1], ..., m [k]} <b><sup>2</sup></b> . <br><br>  This is precisely the function of the Spraga-Grandey: if we need to determine the winner of an ‚Äúequal‚Äù game, then we reduce it to them ‚Äî groups, consider G () for each of the heaps and find their xor sum. <br>  In other words, G (k, n, m) = G (k) ^ G (n) ^ G (m). <br><br><h4>  Tasks </h4><br>  Now let us analyze the Spraga-Grandi function by the example of the olympiad problem that I encountered in the qualifying round of the Summer Computer School.  The conditions of the problem were as follows: <br><blockquote>  On a certain island fires are raging.  The robot was able to extinguish all the cities except one. <br>  The flame spreads very quickly, so every day the fire consumes all the cities, <br>  connected by road with already burning cities.  Robot can not put out anything <br>  the only thing left for him is to escape from the fire.  The speed of the robot coincides with <br>  fire speed, so one day the robot can move to a nearby city. <br>  The robot is shifted by two pilots Nikolai and Vladimir, who are on <br>  natural satellite of the Earth.  Despite the fact that the robot is no longer save and benefit from it <br>  there is no, the pilots are very interested that it should not be destroyed in their shift.  Behind <br>  the loss of the robot relies a decent wage deduction. <br>  On the first day, the robot is in the capital (city number 1).  Nikolai controls the robot <br>  on the first day and can send it to an arbitrary city connected to 1. Then the pilots <br>  alternate.  Thus, every day the only thing that a robot can do is <br>  move to any city adjacent to its current location. <br>  On the first day only the capital burns.  Every next day <br>  all cities connected by roads with already burning light up. <br>  If the pilot leaves the robot in a burning city or sends it to an already burning one <br>  city, the robot does not hold up fire and is destroyed. <br></blockquote><br><br>  It is necessary to determine who in the optimal game will pay a fine for the robot.  Obviously, this game is similar to him: it is finite, a draw is impossible in it, and both players see information about the opponent‚Äôs progress. <br>  What does it boil down to?  That's right, to the definition of the G-function from the city with the number 1. <br><img src="http://s001.radikal.ru/i194/1107/ff/49ab088baa35.png" alt="image" align="right"><br>  Consider the example code.  We assume that we have an adjacency matrix with removed edges (we will delete the edge a -&gt; b if city b burns before city a). <br>  Then the Spray-Grande function for this problem will be calculated as follows: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grundy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(N): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> matrix[v][i] == <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Grundy(i) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> exit <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  If the function returns ‚Äú1‚Äù, then at the optimal game Vladimir will win. <br><br>  Now consider the situation with him-like game, but with many conditions.  Let there be a bunch of stones, the number of which is odd.  At a time, you can take no more than four stones from the pile.  The game continues until the stones run out.  The one who took an even amount of stones does not win. <br>  At first glance, the game is no longer analyzed using the Sprag-Grande function.  Why?  Because the state of the game determines not only the number of stones in the pile - the stones of the players are also important.  But it's easy to take into account, if you take as a game state <br>  G () of the numbers n, m and p, where n is the number of stones in the pile, and m and p are the parity of the stones of the players (0 is an odd number, 1 is an even number). <br><br>  There are two possible game end situations in which n == 0: <br>  G (0, 0, 1) and G (0, 1, 0). <br>  The first situation is a bit uncharacteristic for ordinary him-games - the player cannot make a move, but since the number of his stones is even, he did not lose.  To depict this on the graph, add a transition: <br>  (0, 0, 1) -&gt; (0, 1, 0) <br>  If we now draw the graph, we can note the following frequency: <br>  G (n, m, p) = G (a, m, p), <br>  where a = n mod 6 <br>  What does this give us?  Let the stones in the handful 27. Then G (27, 0, 0) = G (3, 0, 0) = 3. The beginner wins, and the move that creates a winning position must translate (3, 0, 0) -&gt; ( 100).  Therefore, to win a beginner need to take two stones. <br><br><h4>  Let's sum up </h4><br>  The Spraga-Grandi function is an integral part of the like-like (‚Äúequal‚Äù) games and the theory of the Games as a whole.  Solving problems with it is reduced to determining the function G () from each state of the game and finding their xor sum (this is also called the ‚Äúsum of the game‚Äù). <br>  For games in which the number of states is so large that it is considered resource intensive, it is possible to find certain patterns.  In addition, quite often the function Spraga-Grande is periodic. <br><br><h4>  Notes </h4><br>  <b><sup>0</sup></b> despite the <a href="http://en.wikipedia.org/wiki/Natural_number">controversial nature of this issue</a> , zero will also be considered a natural number. <br>  <sup><b>1</b></sup> xor-sum of a [N] is the expression a [1] ^ a [2] ^ ... ^ a [N]. <br>  <sup><b>2</b></sup> mex from the set of numbers is the smallest non-negative number not found in this set (from English minimum excludant). <br><br><h4>  Literature </h4><br>  For a more detailed study of this topic I recommend books: <br>  E. Berlekamp, ‚Äã‚ÄãJH Conway, R. Guy.  Winning Ways for your Mathematical Plays <br>  JH Conway.  On Numbers And Games. <br>  And <a href="http://www.math.ucla.edu/~tom/Game_Theory/Contents.html">quite an interesting course of lectures</a> . <br>  Unfortunately, all this is in English. <br><br><h4>  Tasks for self-study </h4><br>  If you want to solve tasks on this topic, then I recommend <a href="http://acm.timus.ru/problem.aspx%3Fspace%3D1%26num%3D1465">this</a> and <a href="http://acm.timus.ru/problemset.aspx%3Fspace%3D1%26tag%3Dgame">other similar tasks</a> . <br><br>  Successes! <br><br>  <b>UPD</b> : moved to "Sport Programming". </div><p>Source: <a href="https://habr.com/ru/post/124856/">https://habr.com/ru/post/124856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124847/index.html">More tools to improve the management of the organization!</a></li>
<li><a href="../124849/index.html">Digest Wanted.VC # 7</a></li>
<li><a href="../124851/index.html">Work with game controllers</a></li>
<li><a href="../124853/index.html">Tax-Free Shopping: nice euromeloch</a></li>
<li><a href="../124854/index.html">Productive and readable XSLT: a collection of tips</a></li>
<li><a href="../124860/index.html">PostSharp. Problem solving logging and auditing</a></li>
<li><a href="../124861/index.html">Working with the mind, not with your hands: an example of increased text editing performance in Emacs</a></li>
<li><a href="../124863/index.html">Collecting network equipment configuration and storing them in SVN</a></li>
<li><a href="../124864/index.html">Apache HTTP Server: Serving Multiple HTTPS Hosts on the Same IP Address</a></li>
<li><a href="../124866/index.html">Saving the "broken" portable hard drive with a TrueCrypt-container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>