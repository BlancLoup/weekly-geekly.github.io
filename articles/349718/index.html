<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a game on Lua and L√ñVE - 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


- Article 1 Part 1. Game cycle Part 2. Libraries Part 3. Rooms and areas Part 4. Exercises 
- Part 1. Game cycle 
- Part 2. Libra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a game on Lua and L√ñVE - 3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/305/a37/625305a37f81962551aed8611bab6bda.jpg" alt="image"></div><br><h2>  Table of contents </h2><br><ul><li>  <a href="https://habrahabr.ru/post/349276/">Article 1</a> <ul><li>  Part 1. Game cycle </li><li>  Part 2. Libraries </li><li>  Part 3. Rooms and areas </li><li>  Part 4. Exercises </li></ul></li><li>  <a href="https://habrahabr.ru/post/349440/">Article 2</a> <ul><li>  Part 5. Basics of the game </li><li>  Part 6. Basics of the Player Class </li></ul></li><li>  <a href="https://habrahabr.ru/post/349718/">Article 3</a> <ul><li>  Part 7. Player Parameters and Attacks </li><li>  Part 8. Enemies </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 4</a> <ul><li>  Part 9. Director and game cycle </li><li>  Part 10. Code Writing Practices </li><li>  Part 11. Passive skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 5</a> <ul><li>  Part 12. Other Passive Skills </li></ul></li></ul><br>  13. Skill Tree <br><br>  14. Console <br><br>  15. Final 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Part 7: Player Parameters and Attacks </h2><br><h2>  Introduction </h2><br>  In this part we will focus more on the part of the gameplay related to the player.  First we will add the most fundamental parameters: ammunition, acceleration, health (HP) and skill points.  These parameters will be used throughout the game and they are the main parameters that the player will use to perform all the actions available to him.  After that, we will proceed to creating Resource objects, that is, objects that a player can collect.  They contain the above parameters.  Finally, after this, we will add a system of attacks, as well as several different player attacks. <br><a name="habracut"></a><br><h2>  Draw order </h2><br>  Before moving on to the main parts of the game, we need to consider another important aspect that I missed: the order of rendering. <br><br>  The order of drawing determines which objects will be drawn on top, and which on the bottom.  For example, now we have several effects that are drawn when performing certain events.  If the effects are drawn under other objects, for example, under Player, then they either will not be visible, or they will look wrong.  Therefore, we need to make sure that they always draw on top of everything else.  To do this, we need to specify a certain order of drawing objects. <br><br>  The way to solve this problem will be fairly straightforward.  In the <code>GameObject</code> class, we define the <code>depth</code> attribute, which is initially 50 for all entities. Then, if we want to define the constructor of each class, we can set the <code>depth</code> attribute for each object class ourselves.  The idea is that objects with greater depth should be drawn from above, and smaller depth - at the bottom.  That is, for example, if we want all effects to be drawn on top of everything else, then we can simply assign them to the <code>depth</code> attribute, for example, the value 75. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TickEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> TickEffect.super.new(self, area, x, y, opts) self.depth = <span class="hljs-number"><span class="hljs-number">75</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Inside it will work like this: in each frame we will sort the <code>game_objects</code> list by the <code>depth</code> attribute of each object: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(self.game_objects, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.depth &lt; b.depth <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, game_object <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.game_objects) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> game_object:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here, before rendering, we simply use <code>table.sort</code> to sort entities by their <code>depth</code> attribute.  Entities with a smaller depth will move to the front of the table, that is, they will be drawn first (under the rest), and entities with greater depth will move to the end of the table and will be the last ones (on top of everything).  If you try to set different depth values ‚Äã‚Äãfor different types of objects, you will see that it works. <br><br>  With this approach, one small problem arises - some objects will have the same depth, and when this happens, then when constantly sorting the <code>game_objects</code> table, <code>game_objects</code> may occur.  Flickering occurs because if objects have the same depth, then in one frame one object may be on top of another, but in the next frame, go down below it.  The likelihood of this is small, but it can happen and we should prevent it. <br><br>  One solution is to define another sorting parameter in the case when objects have the same depth.  In our case, I chose the object creation time as another parameter: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(self.game_objects, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a.depth == b.depth <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.creation_time &lt; b.creation_time <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.depth &lt; b.depth <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, game_object <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.game_objects) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> game_object:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  That is, if the depths are the same, then the previously created object will be drawn earlier, and later created - later.  This is a logical decision, and if you test it, you will see that it works! <br><br><h3>  Exercises with drawing order </h3><br>  <strong>93.</strong> Change the order of objects so that objects with greater depth are drawn from behind, and from smaller depths - from front.  If objects have the same depth, they should be sorted by creation time.  Objects created earlier should be rendered last, and objects created later should be the first. <br><br>  <strong>94.</strong> In a 2.5D game with a top view, like the one shown below, you need to make sure that the entities are drawn in the appropriate order, that is, sorted by position <code>y</code> .  Entities with a larger value of y (that is, closer to the bottom of the screen) should be rendered last, and entities with a smaller value of y should be drawn first.  What will the sort function look like in this case? <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26c/5ce/8a1/26c5ce8a1a25951b7fb5e54a63e47205.gif"></div></div></div><br><h2>  Main settings </h2><br>  Now we will start building parameters.  The first parameter we consider is acceleration (boost).  It works as follows - when a player presses "up" or "down", the ship changes its speed depending on the key pressed.  Above this basic functionality, there should also be a resource that is exhausted by using acceleration and is gradually restored when acceleration is not used.  I will apply these values ‚Äã‚Äãand rules: <br><br><ol><li>  Initially, the player will have 100 units of acceleration. </li><li>  When using acceleration will decrease by 50 units of acceleration </li><li>  10 acceleration units are always generated per second. </li><li>  When the number of acceleration units reaches 0, this property takes 2 seconds to cool down before it can be used again. </li><li>  Acceleration can be performed only when ‚Äúcooling‚Äù is disabled and the resource of acceleration units is greater than 0 </li></ol><br>  The rules seem a bit complicated, but in fact everything is simple.  The first three are just the task of numerical values, the last two are needed to prevent infinite acceleration.  When a resource reaches 0, it will continuously recover to 1, and this can lead to a situation where the player will use acceleration all the time.  ‚ÄúCooling down‚Äù is needed to prevent such a situation. <br><br>  Now add this to the code: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.max_boost = <span class="hljs-number"><span class="hljs-number">100</span></span> self.boost = self.max_boost <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.boost = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(self.boost + <span class="hljs-number"><span class="hljs-number">10</span></span>*dt, self.max_boost) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This is how we implement rules 1 and 3. Initially, <code>boost</code> is set to <code>max_boost</code> , that is, 100, and then we add to <code>boost</code> by 10 per second until the value <code>max_boost</code> .  We can also implement rule 2 by simply subtracting 50 units per second when the player accelerates: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'up'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">1.5</span></span>*self.base_max_v self.boost = self.boost - <span class="hljs-number"><span class="hljs-number">50</span></span>*dt <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'down'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*self.base_max_v self.boost = self.boost - <span class="hljs-number"><span class="hljs-number">50</span></span>*dt <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  A part of this code was already here, that is, the only added lines are <code>self.boost -= 50*dt</code> .  Now, to check rule 4, we need to make sure that when <code>boost</code> reaches 0, the cooling will start for 2 seconds.  This is a bit more complicated, because more moving parts are used here.  The code looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.can_boost = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.boost_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> self.boost_cooldown = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  First we introduce three variables.  <code>can_boost</code> will be used to report when acceleration can be performed.  By default, it is true, because the player must be able to accelerate when starting the game.  It is set to false when <code>boost</code> reaches 0, and then true in <code>boost_cooldown</code> seconds.  The variable <code>boost_timer</code> will track how much time has passed after the <code>boost</code> reached 0, and when this variable exceeds <code>boost_cooldown</code> , <code>can_boost</code> will be set to true. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.boost = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(self.boost + <span class="hljs-number"><span class="hljs-number">10</span></span>*dt, self.max_boost) self.boost_timer = self.boost_timer + dt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.boost_timer &gt; self.boost_cooldown <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.can_boost = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.max_v = self.base_max_v self.boosting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'up'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.boost &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.can_boost <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">1.5</span></span>*self.base_max_v self.boost = self.boost - <span class="hljs-number"><span class="hljs-number">50</span></span>*dt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.boost &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.can_boost = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.boost_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'down'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.boost &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.can_boost <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*self.base_max_v self.boost = self.boost - <span class="hljs-number"><span class="hljs-number">50</span></span>*dt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.boost &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.can_boost = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.boost_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.trail_color = skill_point_color <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.trail_color = boost_color <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This seems complicated, but the code simply implements what we wanted to accomplish.  Instead of just checking if the key is pressed using <code>input:down</code> , we also check that <code>boost</code> above 1 (rule 5) and that <code>can_boost</code> is true (rule 5).  When <code>boost</code> reaches 0, we set the variables <code>boosting</code> and <code>can_boost</code> false, and then reset <code>boost_timer</code> to 0. Since <code>boost_timer</code> added to <code>boost_timer</code> , every two seconds it will set <code>can_boost</code> to true and we can accelerate again (rule 4). <br><br>  The above code is an acceleration mechanism in its completed state.  Here it is worth noting that this code can be called ugly, disordered and combining bad decisions.  But this is exactly what most of the code looks like that handles certain aspects of the gameplay.  Here you need to follow several rules and follow them at the same time.  It seems to me that you should start getting used to this code. <br><br>  Be that as it may, of all the main parameters, the acceleration is the only one that has such a complex logic.  There are two more important parameters: ammunition and HP, but both are much simpler.  Ammunition is simply spent on player attacks and recovered when resources are collected during the game, and HP drops when the player takes damage, and is also restored when resources are collected.  Now we can simply add them as basic parameters, as we did with acceleration: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.max_hp = <span class="hljs-number"><span class="hljs-number">100</span></span> self.hp = self.max_hp self.max_ammo = <span class="hljs-number"><span class="hljs-number">100</span></span> self.ammo = self.max_ammo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2>  Resources </h2><br>  I call resources small objects that affect one of the main parameters.  There will be five types of such objects in the game, and they will work as follows: <br><br><ul><li>  The ammunition resource recovers 5 units of ammunition for the player and is created when the enemy dies </li><li>  The acceleration resource recovers 25 acceleration units for the player and is randomly created by the Director </li><li>  The HP resource recovers 25 HP from the player and is randomly created by the Director. </li><li>  The SkillPoint resource adds 1 skill point to the player and is randomly created by the Director. </li><li>  The attack resource changes the current attack of the player and is randomly created by the Director. </li></ul><br>  Director (Director) is a piece of code that controls the creation of enemies and resources.  I called him that because he has that name in other games (for example, in L4D) and it seemed appropriate to me.  We are not going to work on this part of the code yet, so we will tie the creation of each resource to the key in order to simply test their work. <br><br><h3>  Ammo Resource (Ammo Resource) </h3><br>  Let's start with the ammunition.  The end result should be this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29f/de6/a3a/29fde6a3a478693d2991f360cc0faedd.gif"></div></div></div><br>  Small green rectangles are a resource of ammunition.  When a player touches him, the resource is destroyed, and the player receives 5 units of ammunition.  We can create a new <code>Ammo</code> class and begin with the definitions: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ammo:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.w, self.h = <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> self.collider = self.area.world:newRectangleCollider(self.x, self.y, self.w, self.h) self.collider:setObject(self) self.collider:setFixedRotation(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) self.r = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>) self.v = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) self.collider:applyAngularImpulse(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-24</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ammo:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(ammo_color) pushRotate(self.x, self.y, self.collider:getAngle()) draft:rhombus(self.x, self.y, self.w, self.h, <span class="hljs-string"><span class="hljs-string">'line'</span></span>) love.graphics.pop() love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Ammunition resources will be physical rectangles created at random slow speeds and turns, originally defined by <code>setLinearVelocity</code> and <code>applyAngularImpulse</code> .  In addition, this object is drawn using the <a href="https://github.com/pelevesque/draft"><code>draft</code></a> library.  This is a small library that allows you to draw all sorts of shapes more conveniently than you would have done it yourself.  In our case, we can simply draw the resource like any rectangle, but I decided to do it this way.  I will assume that you have already installed the library yourself and have read the documentation, having learned about its capabilities.  In addition, we will take into account the rotation of the physical object, using the <a href="https://love2d.org/wiki/Body:getAngle" rel="nofollow"><code>getAngle</code></a> result in <code>pushRotate</code> . <br><br>  To test all this, we can bind the creation of one of these objects to the key: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'p'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Ammo'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, gw), <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, gh)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  If you start the game now and click on P several times, then you will see how objects are created and move / rotate. <br><br>  The next thing we need to create is the interaction of collisions between the player and the resource.  This interaction will be used for all resources and will almost always be the same.  The first thing we want to do is intercept the event of the collision of a player‚Äôs physical object with the physical object of the ammunition.  The easiest way to do this is to use <a href="https://github.com/SSYGEA/windfield"><code>  (collision classes)</code></a> .  For a start, we can define three classes of collisions for already existing objects: the player, shells, and resources. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area = Area(self) self.area:addPhysicsWorld() self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>) self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>) self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And in each of these files (Player, Projectile and Ammo) we can set the collider collision class using <a href="https://github.com/SSYGEA/windfield"><code>setCollisionClass</code></a> (repeat this code in other files): <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.collider:setCollisionClass(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  By itself, it does not change anything, it creates a basis with which you can intercept collision events between physical objects.  For example, if we change the <code>Collectable</code> collision class so that it ignores the <code>Player</code> : <br><br><pre> <code class="lua hljs">self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>, {ignores = {<span class="hljs-string"><span class="hljs-string">'Player'</span></span>}})</code> </pre> <br>  then when you start the game, you will notice that the player physically ignores objects of ammunition resources.  We are not striving for this, but it serves as a good example of what can be done with collision classes.  We want these three classes of collisions to follow the following rules: <br><br><ol><li>  Projectile ignores Projectile </li><li>  Collectable ignores Collectable </li><li>  Collectable ignores Projectile </li><li>  Player generates collision events with Collectable </li></ol><br>  Rules 1, 2 and 3 can be implemented by making small changes to the calls to <code>addCollisionClass</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>) self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, {ignores = {<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>}}) self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>, {ignores = {<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>, <span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>}}) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  It is worth noting that the order of declaring clash classes is important.  For example, if we swap the declarations of the Projectile and Collectable classes, a bug will occur because the Collectable collision class creates a reference to the Projectile collision class, since the Projectile collision class has not yet been defined, an error occurs. <br><br>  The fourth rule can be implemented by calling <a href="https://github.com/SSYGEA/windfield"><code>enter</code></a> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider:enter(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  If you run the code, then at each player's collision with the ammunition resource, 1 is displayed in the console. <br><br>  Another element that needs to be added to the <code>Ammo</code> class is the slow motion of an object towards a player.  The easiest way to do this is to add the behavior of <a href="https://gamedevelopment.tutsplus.com/tutorials/understanding-steering-behaviors-seek--gamedev-849" rel="nofollow">Seek Behavior</a> .  My version of seek behavior is based on the book <a href="http://www.ai-junkie.com/books/toc_pgaibe.html" rel="nofollow">Programming Game AI by Example</a> , in which there is a very good selection of general control behaviors.  I will not explain the behavior in detail, because, frankly, I don‚Äôt remember how it works, so if you are interested, sort it out yourself: D <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ammo:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> target = current_room.player <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> target <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> projectile_heading = Vector(self.collider:getLinearVelocity()):normalized() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> angle = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(target.y - self.y, target.x - self.x) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> to_target_heading = Vector(<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle), <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle)):normalized() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> final_heading = (projectile_heading + <span class="hljs-number"><span class="hljs-number">0.1</span></span>*to_target_heading):normalized() self.collider:setLinearVelocity(self.v*final_heading.x, self.v*final_heading.y) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here the ammunition resource is directed towards the <code>target</code> , if it exists, otherwise the resource will move in the initially specified direction.  <code>target</code> contains a link to the player, which is set in the <code>Stage</code> as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.player = self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>, gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The only thing that remains is to process the actions that occur during the collection of ammunition resources.  In the above gif-animation, you can see that a small effect is played (similar to the effect of ‚Äúdeath‚Äù of a projectile) with particles, and then the player gets +5 ammunition. <br><br>  Let's start with the effect.  This effect uses the same logic as in the <code>ProjectileDeathEffect</code> object: a small white flash occurs, and then the actual color of the effect appears.  The only difference here is that instead of drawing a square, we will draw a rhombus, that is, the same shape that we used to draw the actual ammunition resource.  I will name this new object <code>AmmoEffect</code> .  We will not consider it in detail, because it is similar to <code>ProjectileDeathEffect</code> .  However, we call it as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ammo:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'AmmoEffect'</span></span>, self.x, self.y, {color = ammo_color, w = self.w, h = self.h}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ExplodeParticle'</span></span>, self.x, self.y, {s = <span class="hljs-number"><span class="hljs-number">3</span></span>, color = ammo_color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we create one <code>AmmoEffect</code> object and then from 4 to 8 <code>ExplodeParticle</code> objects, which we have already used in the effect of death Player.  The <code>die</code> function of the Ammo object will be called when it collides with the Player: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider:enter(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> collision_data = self.collider:getEnterCollisionData(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> object = collision_data.collider:getObject() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> object:is(Ammo) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> object:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we first use <a href="https://github.com/SSYGEA/windfield"><code>getEnterCollisionData</code></a> to retrieve collision data generated by the last enter collision event for the specified label.  Then we use <a href="https://github.com/SSYGEN/windfield"><code>getObject</code></a> to access the object attached to the collider participating in the collision event, which can be any object in the Collectable collision class.  In our case, we only have an Ammo object, but if we had others, then it would be here that the code would distinguish them.  And this is exactly what we do - to check if the object obtained from <code>getObject</code> is an <code>Ammo</code> class, we use the <a href="https://github.com/rxi/classic"><code>is</code></a> function from the classic library.  If this is actually an object of the Ammo class, then we call its function <code>die</code> .  All this should look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a63/4e0/4ec/a634e04ec4d7dc090a24adbb40bf5547.gif"></div></div></div><br>  The last thing we forgot is the addition of +5 ammunition to the player when collecting ammunition resources.  To do this, we define the <code>addAmmo</code> function, which simply adds a specific value to the <code>ammo</code> variable and checks that it does not exceed <code>max_ammo</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:addAmmo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amount)</span></span></span></span> self.ammo = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(self.ammo + amount, self.max_ammo) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And then we just call this function after <code>object:die()</code> in the newly added code. <br><br><h3>  Boost Resource (Boost) </h3><br>  Now let's do the acceleration.  The end result should look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d14/6c2/577/d146c25775abc5461c5a2eda26c1f4c0.gif"></div></div></div><br>  As you can see, the idea is about the same as with the ammunition resource, only the boost movement of the resource is slightly different, it looks a little different and the visual effect is different when it is picked up. <br><br>  Let's start with the main thing.  All resources, except for ammunition, will be created in the left or right side of the screen, and then slowly move in a straight line in the opposite direction.  The same applies to enemies.  This gives the player enough time to move to the resource and collect it if he wants. <br><br>  The basic starting code of the <code>Boost</code> class will be approximately the same as that of the <code>Ammo</code> class.  It looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.x = gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + direction*(gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span>) self.y = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">48</span></span>, gh - <span class="hljs-number"><span class="hljs-number">48</span></span>) self.w, self.h = <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span> self.collider = self.area.world:newRectangleCollider(self.x, self.y, self.w, self.h) self.collider:setObject(self) self.collider:setCollisionClass(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>) self.collider:setFixedRotation(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) self.v = -direction*<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) self.collider:setLinearVelocity(self.v, <span class="hljs-number"><span class="hljs-number">0</span></span>) self.collider:applyAngularImpulse(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-24</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.collider:setLinearVelocity(self.v, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there are some differences. The first three lines in the constructor get the starting position of the object. The function is </font></font><code>table.random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined </font></font><code>utils.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table.random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t[love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, #t)] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, it simply selects a random element from the table. In our case, we simply choose -1 or 1, indicating the side with which the object should be created. If the value is -1, then the object will be created on the left side of the screen, and if 1, then the object will be created on the right. Specific positions for this selected position will be equal </font></font><code>-48</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>gw+48</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, an object is created outside the screen, but close enough to its edge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, we define the object in almost the same way as Ammo, except for some differences in speed. If the object was created on the right, then we want it to move to the left, and if it is to the left, then we want it to move to the right. Therefore, the speed is assigned a random value from 20 to 40, and then multiplied by </font></font><code>-direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because if the object is on the right, then</font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equals 1; we want to move it to the left, so the speed must be negative (and vice versa for the opposite side). The component's velocity along the x axis is always assigned an attribute value </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the y component is </font><font style="vertical-align: inherit;">assigned a value of </font><font style="vertical-align: inherit;">0. We want the object to move along a horizontal line, so we set the velocity along y to 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last major difference is in the way it is drawn:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(boost_color) pushRotate(self.x, self.y, self.collider:getAngle()) draft:rhombus(self.x, self.y, <span class="hljs-number"><span class="hljs-number">1.5</span></span>*self.w, <span class="hljs-number"><span class="hljs-number">1.5</span></span>*self.h, <span class="hljs-string"><span class="hljs-string">'line'</span></span>) draft:rhombus(self.x, self.y, <span class="hljs-number"><span class="hljs-number">0.5</span></span>*self.w, <span class="hljs-number"><span class="hljs-number">0.5</span></span>*self.h, <span class="hljs-string"><span class="hljs-string">'fill'</span></span>) love.graphics.pop() love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of drawing a single diamond, we draw one internal and one external, which will be a kind of outline. Of course, you can draw objects as you like, but I personally chose this method. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the effects. It uses two objects: one is similar to </font></font><code>AmmoEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(however, it is a bit more complicated), and the second is used for text </font></font><code>+BOOST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We'll start with one that looks like AmmoEffect and name it </font></font><code>BoostEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This effect consists of two parts: a center with a white flash and a flicker effect after it disappears. The center works in the same way as the </font></font><code>AmmoEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only difference lies in the execution time of each phase: from 0.1 to 0.2 in the first phase and from 0.15 to 0.35 in the second:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoostEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.current_color = default_color self.timer:after(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.current_color = self.color self.timer:after(<span class="hljs-number"><span class="hljs-number">0.35</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second part of the effect is flickering before his death. </font><font style="vertical-align: inherit;">Flicker can be achieved by creating a variable </font></font><code>visible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if true, the effect will be drawn, and if false, it will not. </font><font style="vertical-align: inherit;">By changing the value of this variable, we will achieve the desired effect:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoostEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:every(<span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.visible = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.visible <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) self.timer:after(<span class="hljs-number"><span class="hljs-number">0.35</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, to switch between visibility / invisibility, we use a call six times </font></font><code>every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at intervals of 0.05 seconds, and after completion we finally make the effect visible. </font><font style="vertical-align: inherit;">The effect ‚Äúdies‚Äù after 0.55 seconds (because we set the </font></font><code>dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value to true after 0.55 when setting the current color), so making it visible at the end is not very important. </font><font style="vertical-align: inherit;">Now we can draw it as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoostEffect:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.visible <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.setColor(self.current_color) draft:rhombus(self.x, self.y, <span class="hljs-number"><span class="hljs-number">1.34</span></span>*self.w, <span class="hljs-number"><span class="hljs-number">1.34</span></span>*self.h, <span class="hljs-string"><span class="hljs-string">'fill'</span></span>) draft:rhombus(self.x, self.y, <span class="hljs-number"><span class="hljs-number">2</span></span>*self.w, <span class="hljs-number"><span class="hljs-number">2</span></span>*self.h, <span class="hljs-string"><span class="hljs-string">'line'</span></span>) love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We just draw the inner and outer diamonds of different sizes. </font><font style="vertical-align: inherit;">Specific values ‚Äã‚Äã(1.34, 2) are derived mainly by trial and error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing we need to do for this effect is to increase the external contour-rhombus during the life of the object. </font><font style="vertical-align: inherit;">We can do it like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoostEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.sx, self.sy = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.35</span></span>, self, {sx = <span class="hljs-number"><span class="hljs-number">2</span></span>, sy = <span class="hljs-number"><span class="hljs-number">2</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And then change the draw function to read: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BoostEffect:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... draft:rhombus(self.x, self.y, self.sx*<span class="hljs-number"><span class="hljs-number">2</span></span>*self.w, self.sy*<span class="hljs-number"><span class="hljs-number">2</span></span>*self.h, <span class="hljs-string"><span class="hljs-string">'line'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to this variable </font></font><code>sx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>sy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be increased to 2 for 0.35 seconds, that is, circuit, too, for the 0.35 second double. </font><font style="vertical-align: inherit;">In the end, the result will look like this (I assume that you have already linked the function of </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this object to the collision event with the Player, as we did with the ammunition resource):</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/c23/441/a54c2344171745040677c4dff60ba2aa.gif"></div></div></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's do another part of the effect - crazy text. This text effect will be used almost everywhere in the game, so we need to implement it correctly. Let me show you what it looks like:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d14/6c2/577/d146c25775abc5461c5a2eda26c1f4c0.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First let's split the effect into several parts. The first thing to notice is just a line that was originally drawn on the screen, but towards the end it starts flickering like an object </font></font><code>BoostEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Flicker uses the same logic as BoostEffect, that is, we have already considered it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, the letters of the line begin to randomly change to other letters, and the background of each character also randomly changes colors. This tells us that this effect processes each character separately, and does not operate on the entire line, that is, we will need to store all the characters in the table </font></font><code>characters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, process this table, and then draw each character from the table on the screen with all modifications and effects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Given all this, we can define the basics of a class </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We will call it like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boost:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'+BOOST'</span></span>, color = boost_color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, our string will be stored in the attribute </font></font><code>text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Then the definition of the base class will look like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.depth = <span class="hljs-number"><span class="hljs-number">80</span></span> self.characters = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, #self.text <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.characters, self.text:utf8sub(i, i)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we determine that the object will have a depth of 80 (higher than all other objects, that is, it will be drawn on top of everything), and then we divide the source row into table symbols. For this we use the library </font></font><a href="https://gist.github.com/markandgo/5776124"><code>utf8</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In general, it is a good idea to manipulate strings using a library that supports all types of characters, and as we will see soon, this is especially important for our object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The drawing of these characters must also be done individually, because, as we found out earlier, each character has its own background, changing at random. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The logic of drawing each character separately is to go through the symbol table and draw each character at position x, which is the sum of all the characters in front of it. That is, for example, drawing the first</font></font><code>O</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in line </font></font><code>+BOOST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means drawing at position </font></font><code>initial_x_position + widthOf('+B')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In our case, the problem with getting the width </font></font><code>+B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is that it depends on the font used, since we will use the function </font></font><a href="https://love2d.org/wiki/Font:getWidth" rel="nofollow"><code>Font:getWidth</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but have not yet set the font. However, we can easily solve this problem! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To this effect we use the font </font></font><a href="https://managore.itch.io/m5x7" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m5x7</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daniel Linssen. We can put this font in a folder </font></font><code>resources/fonts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and then upload it. I will leave the code needed to load it as an exercise for you, because it is somewhat similar to the code used to load class definitions from a folder </font></font><code>objects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Exercise 14). By the end of this download process, we will have a global table </font></font><code>fonts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will contain all the downloaded fonts in the format</font></font><code>fontname_fontsize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this example we will use </font></font><code>m5x7_16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.font = fonts.m5x7_16 ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this is how the rendering code will look like: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setFont(self.font) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, #self.characters <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> width = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>, i<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> width = width + self.font:getWidth(self.characters[j]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.setColor(self.color) love.graphics.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self.characters[i], self.x + width, self.y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, self.font:getHeight()/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we will use </font></font><a href="https://love2d.org/wiki/love.graphics.setFont" rel="nofollow"><code>love.graphics.setFont</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to specify the font that we want to use in the following drawing operations. Then we have to go through each of the characters, and then draw them. But first we need to calculate its position in x, which is the sum of the width of all characters before it. The internal loop that accumulates a variable </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does just that. It starts from 1 (the beginning of the line) to i-1 (the character before the current one) and adds the width of each character to the total </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, to the sum of all of them. Then we use </font></font><a href="https://love2d.org/wiki/love.graphics.print" rel="nofollow"><code>love.graphics.print</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to draw each individual character in its corresponding position. We also shift each character half the height of the font (so that the characters are centered relative to the position given by us y). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we test all this, we get the following:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa6/b56/998/fa6b56998a7246ed1fb54e14be14ea13.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just what we need! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can proceed to the flickering of the text before disappearing. </font><font style="vertical-align: inherit;">This effect uses the same logic as in the BoostEffect object, that is, we can simply copy it:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.70</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:every(<span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.visible = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.visible <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) self.timer:after(<span class="hljs-number"><span class="hljs-number">0.35</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) self.timer:after(<span class="hljs-number"><span class="hljs-number">1.10</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we run this, we see that the text remains normal for a while, then it starts to flicker and disappears. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now the most difficult thing is to make each character change randomly, and do the same with the main and background colors. </font><font style="vertical-align: inherit;">These changes begin approximately at the same time when the symbol starts to flicker, so we will put this part of the code inside the call </font></font><code>after</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for 0.7 seconds, which we defined above. </font><font style="vertical-align: inherit;">We will do this - every 0.035 seconds we will run a procedure that has a chance to change a character to another random character. </font><font style="vertical-align: inherit;">It looks like this:</font></font><br><br><pre> <code class="lua hljs">self.timer:after(<span class="hljs-number"><span class="hljs-number">0.70</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.035</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.characters) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">-- change character else -- leave character as it is end end end) end)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, every 0.035 seconds, each character has a 5% chance to change to something else. </font><font style="vertical-align: inherit;">We can complete this by adding a variable </font></font><code>random_characters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is a string containing all the characters that a character can change into. </font><font style="vertical-align: inherit;">When a character needs to change, we randomly select a character from this string:</font></font><br><br><pre> <code class="lua hljs">self.timer:after(<span class="hljs-number"><span class="hljs-number">0.70</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.035</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> random_characters = <span class="hljs-string"><span class="hljs-string">'0123456789!@#$%¬®&amp;*()-=+[]^~/;?&gt;&lt;.,|abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWYXZ'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.characters) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r = love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, #random_characters) self.characters[i] = random_characters:utf8sub(r, r) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.characters[i] = character <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When we run the code, it should look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19d/938/389/19d938389d1276aa5dc4a47b9cb36134.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use the same logic to change the main and background colors of a symbol. </font><font style="vertical-align: inherit;">To do this, we define two tables, </font></font><code>background_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>foreground_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Each table is the same size as the table </font></font><code>characters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and will simply contain the background and primary colors for each character. </font><font style="vertical-align: inherit;">If no symbol is specified for a symbol in this table, it will by default use the primary color ( </font></font><code>boost_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and a transparent background.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.background_colors = {} self.foreground_colors = {} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, #self.characters <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.background_colors[i] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(self.background_colors[i]) love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, self.x + width, self.y - self.font:getHeight()/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.font:getWidth(self.characters[i]), self.font:getHeight()) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.setColor(self.foreground_colors[i] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> self.color <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> default_color) love.graphics.<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(self.characters[i], self.x + width, self.y, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, self.font:getHeight()/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If defined </font></font><code>background_colors[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(background color for the current character), then for the background color we simply draw a rectangle in the appropriate position and the size of the current character. We change the main color by simply setting the </font></font><code>setColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">color of the current character </font><font style="vertical-align: inherit;">using the </font><font style="vertical-align: inherit;">color. If </font></font><code>foreground_colors[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not defined, then by default it is equal </font></font><code>self.color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which for this object is always equal </font></font><code>boost_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since we are the ones that we transmit when we call it from the Boost object. But if </font></font><code>self.color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not defined, then it defaults to white ( </font></font><code>default_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). By itself, this code fragment does nothing, because we have not defined the values ‚Äã‚Äãinside the tables </font></font><code>background_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>foreground_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, we can use the same logic that was used to randomly change characters:</font></font><br><br><pre> <code class="lua hljs">self.timer:after(<span class="hljs-number"><span class="hljs-number">0.70</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.035</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.characters) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">-- change background color else -- set background color to transparent end if love.math.random(1, 10) &lt;= 2 then -- change foreground color else -- set foreground color to boost_color end end end) end)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code replacing the colors should choose from a list of colors. </font><font style="vertical-align: inherit;">We have defined a global group of six colors, so we can simply put all of them in the list and then use one to randomly select one of them </font></font><code>table.random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In addition, beyond this, we will define six more colors, which will be negatives of the six original ones. </font><font style="vertical-align: inherit;">That is, if we have the original color </font></font><code>232, 48, 192</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then its negative can be defined as </font></font><code>255-232, 255-48, 255-192</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> default_colors = {default_color, hp_color, ammo_color, boost_color, skill_point_color} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> negative_colors = { {<span class="hljs-number"><span class="hljs-number">255</span></span>-default_color[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-default_color[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-default_color[<span class="hljs-number"><span class="hljs-number">3</span></span>]}, {<span class="hljs-number"><span class="hljs-number">255</span></span>-hp_color[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-hp_color[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-hp_color[<span class="hljs-number"><span class="hljs-number">3</span></span>]}, {<span class="hljs-number"><span class="hljs-number">255</span></span>-ammo_color[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-ammo_color[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-ammo_color[<span class="hljs-number"><span class="hljs-number">3</span></span>]}, {<span class="hljs-number"><span class="hljs-number">255</span></span>-boost_color[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-boost_color[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-boost_color[<span class="hljs-number"><span class="hljs-number">3</span></span>]}, {<span class="hljs-number"><span class="hljs-number">255</span></span>-skill_point_color[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-skill_point_color[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">255</span></span>-skill_point_color[<span class="hljs-number"><span class="hljs-number">3</span></span>]} } self.all_colors = fn.append(default_colors, negative_colors) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we define two tables containing the corresponding values ‚Äã‚Äãof each of the colors, and then use the function </font></font><a href=""><code>append</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to combine them. </font><font style="vertical-align: inherit;">Then now we can do something of a type </font></font><code>table.random(self.all_colors)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and get one random color out of ten defined in this table. </font><font style="vertical-align: inherit;">That is, we can do the following:</font></font><br><br><pre> <code class="lua hljs">self.timer:after(<span class="hljs-number"><span class="hljs-number">0.70</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.035</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.characters) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.background_colors[i] = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(self.all_colors) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.background_colors[i] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.foreground_colors[i] = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(self.all_colors) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.background_colors[i] = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If we start the game, we will see the following: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c01/91f/1ce/c0191f1ce4b3326500763494b0e0a6ba.gif"></div></div></div><br>  That's all.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Later we will improve this effect (including in exercises), but for now this is enough. </font><font style="vertical-align: inherit;">The last thing we need to do is to add +25 boost to the player when collecting acceleration resources. </font><font style="vertical-align: inherit;">It works exactly the same as with the ammunition resource, so we will skip the code.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resource Exercises </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">95.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Have the Projectile collision class ignore the collision class Player. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">96.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the function </font></font><code>addAmmo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it supports the addition of negative values ‚Äã‚Äãand does not allow the attribute </font></font><code>ammo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to fall below 0. Do the same for the functions </font></font><code>addBoost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>addHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(adding HP resource will be the task of another exercise). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">97.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Judging by the previous exercise, it is better to process the positive and negative values ‚Äã‚Äãin one function or to divide them into functions </font></font><code>addResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>removeResource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">98.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the object, </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">change the probability of changing the symbol by 20%, the probability of changing the primary color by 5%, and the probability of changing the background color by 30%. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">99.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Define the tables</font></font><code>default_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>negative_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And </font></font><code>all_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-locally and globally. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Randomize the position of an object </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it is created between </font></font><code>-self.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>self.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">over the x component, between </font></font><code>-self.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>self.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">over the y component. </font><font style="vertical-align: inherit;">Attributes </font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relate to the Boost object that creates the InfoText. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">101.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppose we have the following function:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:getAllGameObjectsThat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filter)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> out = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, game_object <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self.game_objects) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filter(game_object) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(out, game_object) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It returns all game objects inside the Area that the filter function passes. </font><font style="vertical-align: inherit;">Also assume that it is invoked in the InfoText constructor as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InfoText:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> all_info_texts = self.area:getAllGameObjectsThat(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> o:is(InfoText) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.id ~= self.id <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That returns all existing and live InfoText objects that are not current. Make sure that the InfoText object does not visually overlap with any other InfoText object, that is, does not occupy the same space on the screen and the text does not become unreadable. You can do it any way you want, as long as he performs the task. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">102. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add an HP resource with all the functionality and visual effects. It uses the exact same logic as the Boost resource, but adds +25 HP. Resource and effects should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3df/e93/565/3dfe93565fbb122b928232e5ee114dff.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">103. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add an SP resource with all the functionality and visual effects. </font><font style="vertical-align: inherit;">It uses the same logic as the resource, but adds +1 SP. </font><font style="vertical-align: inherit;">In addition, the SP resource must be defined as a global variable, and not as an internal variable of the Player object. </font><font style="vertical-align: inherit;">Resource and effect should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/5aa/56d/de95aa56db7d2e2c4a72688b7cd6eb5d.gif"></div></div></div><br><h2>  Attacks </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Great, now let's move on to the attacks. </font><font style="vertical-align: inherit;">First of all, we will change the way shells are drawn. </font><font style="vertical-align: inherit;">Now they are drawn as circles, but we want them to be lines. </font><font style="vertical-align: inherit;">This can be implemented like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(default_color) pushRotate(self.x, self.y, Vector(self.collider:getLinearVelocity()):angle()) love.graphics.setLineWidth(self.s - self.s/<span class="hljs-number"><span class="hljs-number">4</span></span>) love.graphics.line(self.x - <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y, self.x, self.y) love.graphics.line(self.x, self.y, self.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.pop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the function </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we use the speed of the projectile, so we can rotate it in accordance with the angle at which it moves. </font><font style="vertical-align: inherit;">Then inside we use </font></font><a href="https://love2d.org/wiki/love.graphics.setLineWidth" rel="nofollow"><code>love.graphics.setLineWidth</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and set a value roughly proportional to the attribute </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but slightly smaller. </font><font style="vertical-align: inherit;">This means that shells with </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a large overall will be thicker. </font><font style="vertical-align: inherit;">Then we draw the projectile with </font></font><a href="" rel="nofollow"><code>love.graphics.line</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It is also important that we draw one line from </font></font><code>-2*self.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the center, and then one more from the center to </font></font><code>2*self.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We do this because each attack will have its own color, and we will change the color of one of these lines, but not the second. </font><font style="vertical-align: inherit;">That is, for example, if we do this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(default_color) pushRotate(self.x, self.y, Vector(self.collider:getLinearVelocity()):angle()) love.graphics.setLineWidth(self.s - self.s/<span class="hljs-number"><span class="hljs-number">4</span></span>) love.graphics.line(self.x - <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y, self.x, self.y) love.graphics.setColor(hp_color) <span class="hljs-comment"><span class="hljs-comment">-- change half the projectile line to another color love.graphics.line(self.x, self.y, self.x + 2*self.s, self.y) love.graphics.setLineWidth(1) love.graphics.pop() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then it will look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/3c8/f52/cf53c8f5238b925f611f0fef4daa7356.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thus, we can assign each attack its own color, and allow the player to better understand what is happening on the screen. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the finished game will be 16 attacks, but now we consider only some of them. </font><font style="vertical-align: inherit;">The attack system is very simple and is based on the following rules:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attacks (with the exception of Neutral) use ammunition with each shot; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When ammunition drops to 0, the current attack changes to Neutral; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> New attacks can be obtained using randomly created resources; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When a new attack is received, the current attack is replaced, and the ammunition is fully restored; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each attack spends its amount of ammunition and has its own properties. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing we will do is define a table that will contain information about each of the attacks: the time they ‚Äúcool down‚Äù, the consumption of ammunition and the color. </font><font style="vertical-align: inherit;">We will define the table in </font></font><code>globals.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and for now it will look like this:</font></font><br><br><pre> <code class="lua hljs">attacks = { [<span class="hljs-string"><span class="hljs-string">'Neutral'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.24</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">0</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'N'</span></span>, color = default_color}, }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The standard attack that we have already defined is called </font></font><code>Neutral</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will use the attack parameters that we already have in the game. </font><font style="vertical-align: inherit;">Now we can define a function </font></font><code>setAttack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will replace one attack with another and use this global attack table:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:setAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(attack)</span></span></span></span> self.attack = attack self.shoot_cooldown = attacks[attack].cooldown self.ammo = self.max_ammo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We can call her like this: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self:setAttack(<span class="hljs-string"><span class="hljs-string">'Neutral'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we simply change the attribute </font></font><code>attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will contain the name of the current attack. </font><font style="vertical-align: inherit;">This attribute will be used in the function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to check the current active attack and determine how to create projectiles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also change the attribute </font></font><code>shoot_cooldown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We have not created this attribute yet, but it will be similar to the attributes </font></font><code>boost_timer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>boost_cooldown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will be used to control how often an action takes place, in our case an attack. </font><font style="vertical-align: inherit;">We will delete this line:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.24</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:shoot() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we will set the attack timings manually: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.shoot_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> self.shoot_cooldown = <span class="hljs-number"><span class="hljs-number">0.24</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.shoot_timer = self.shoot_timer + dt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shoot_timer &gt; self.shoot_cooldown <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.shoot_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> self:shoot() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of the function, we will also restore the amount of ammunition. </font><font style="vertical-align: inherit;">So we implement rule 4. The next thing to do is to slightly change the function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it starts to take into account the existence of various attacks:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ShootEffect'</span></span>, self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {player = self, d = d}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Neutral'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {r = self.r}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before launching the projectile, we check the </font></font><code>if self.attack == 'Neutral'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current attack </font><font style="vertical-align: inherit;">with a conventional design </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This function will gradually grow into a large chain of conditions, because we have to check all 16 attacks.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start by adding one attack to see what it looks like. </font><font style="vertical-align: inherit;">The attack we add will be called </font></font><code>Double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font> She looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d3/236/804/2d323680481ee839b2a5a1305964767b.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, she shoots at an angle with two shells instead of one. </font><font style="vertical-align: inherit;">First we need to add a description of the attack to the global attack table. </font><font style="vertical-align: inherit;">This attack will have a ‚Äúcooling down‚Äù time of 0.32 seconds, spend 2 ammunition, and its color will be </font></font><code>ammo_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(I obtained these values ‚Äã‚Äãby trial and error):</font></font><br><br><pre> <code class="lua hljs">attacks = { ... [<span class="hljs-string"><span class="hljs-string">'Double'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">2</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'2'</span></span>, color = ammo_color}, }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can add it to the function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Double'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.ammo = self.ammo - attacks[self.attack].ammo self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>), {r = self.r + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>, attack = self.attack}) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r - <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r - <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>), {r = self.r - <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>, attack = self.attack}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we create not one, but two projectiles, each of which is directed at an angle of math.pi / 12 radians, or 15 degrees. </font><font style="vertical-align: inherit;">We also made the projectile receive the attribute as the name of the attack </font></font><code>attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will do this for each type of projectile, because it will help us determine what type of attack the projectile belongs to. </font><font style="vertical-align: inherit;">This is useful for setting the appropriate color, as well as for changing behavior if necessary. </font><font style="vertical-align: inherit;">The Projectile object now looks like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.color = attacks[self.attack].color ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, Vector(self.collider:getLinearVelocity()):angle()) love.graphics.setLineWidth(self.s - self.s/<span class="hljs-number"><span class="hljs-number">4</span></span>) love.graphics.setColor(self.color) love.graphics.line(self.x - <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y, self.x, self.y) love.graphics.setColor(default_color) love.graphics.line(self.x, self.y, self.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*self.s, self.y) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.pop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the constructor, we set the </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">color defined for this attack in the global table </font></font><code>attacks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And in the draw function, we draw one part of the line with this color, which is an attribute </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the other, which is </font></font><code>default_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For most types of shells, the scheme will be the same. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing we forgot is to make this attack comply with rule 1, that is, we forgot to add a code that forces it to waste the necessary amount of ammunition. </font><font style="vertical-align: inherit;">It's pretty easy to fix:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Double'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.ammo = self.ammo - attacks[self.attack].ammo ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to this rule 1 will be executed (for the Double attack). </font><font style="vertical-align: inherit;">We can also add code that implements rule 2: when it </font></font><code>ammo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drops to 0, we change the current attack to </font></font><code>Neutral</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.ammo &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:setAttack(<span class="hljs-string"><span class="hljs-string">'Neutral'</span></span>) self.ammo = self.max_ammo <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have to go to the end of the function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because we do not want the player to shoot after the amount of ammunition drops to 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you do this and try to start the program, you will receive the following:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a87/887/3fc/a878873fc034d7e7103ce13176ada90c.gif"></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with attacks </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">104. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the attack </font></font><code>Triple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its definition in the attack table looks like this:</font></font><br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Triple'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">3</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'3'</span></span>, color = boost_color}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the attack itself will look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60e/789/fee/60e789fee5f37ae49ef6d7fb3e0e7898.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The angles of the shells are exactly the same as in </font></font><code>Double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but there is still an additional projectile, created in the middle (at the same angle as the attack projectile </font></font><code>Neutral</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Create this attack in the same way as Double. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">105. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the attack </font></font><code>Rapid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its definition in the attack table looks like this:</font></font><br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Rapid'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.12</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">1</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'R'</span></span>, color = default_color}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the attack itself looks like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e19/2d5/6d0/e192d56d0f3d656860e07e4420660c9d.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">106. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the attack </font></font><code>Spread</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its definition in the attack table:</font></font><br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Spread'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.16</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">1</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'RS'</span></span>, color = default_color}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the attack itself looks like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b81/24a/db2/b8124adb2afbbd92beaf85c6f0c79c74.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The angles used for the shots are a random value from -math.pi / 8 to + math.pi / 8. </font><font style="vertical-align: inherit;">The color of the shells of this attack also works a little differently. </font><font style="vertical-align: inherit;">Instead of having only one color, in each frame the color changes randomly to one of the list </font></font><code>all_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or through the frame, depending on how you feel better). </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">107. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the attack </font></font><code>Back</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its definition in the attack table looks like this:</font></font><br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Back'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">2</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'Ba'</span></span>, color = skill_point_color}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the attack itself looks like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/301/c71/611301c71871209ca0b1879d7255671b.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">108. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the attack </font></font><code>Side</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its definition in the attack table:</font></font><br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Side'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.32</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">2</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'Si'</span></span>, color = boost_color}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The attack itself: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36f/ffb/a5b/36fffba5ba9aeace3793eeb9f864e888.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">109. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a resource </font></font><code>Attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As </font></font><code>Boost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>SkillPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the Attack resource is created in the left or right edge of the screen, and then very slowly moves inward. </font><font style="vertical-align: inherit;">When a player interacts with an Attack resource, his attack with the function </font></font><code>setAttack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes to an attack that is contained in the resource. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Attack resource is slightly different in appearance from the Boost and SkillPoint resources, but the principle of it and its effects is almost the same. </font><font style="vertical-align: inherit;">The colors used for each resource are the same as that of their shells, and the name-identifier is the one we named </font></font><code>abbreviation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the table </font></font><code>attacks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is what they look like:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath71.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Do not forget to create InfoText objects when selecting a new attack by the player! </font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 8: Enemies </font></font></h2><br><h2>  Introduction </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, we will consider the creation of several enemies, as well as the EnemyProjectile class, that is, projectiles with which some enemies will be able to shoot the player. </font><font style="vertical-align: inherit;">This part will be a bit shorter than the others, because now I will not talk in detail about the creation of all enemies, but only about the general behavior, which will be almost the same for all of them.</font></font><br><br><h2>  The enemies </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The enemies in this game behave almost the same as the resources created in the previous part: they are created near the left or right border of the screen in a random position y, and then slowly move inward. </font><font style="vertical-align: inherit;">The code of their behavior will be almost the same that we have implemented for resources. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will start with the first enemy, which we call </font></font><code>Rock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font> It looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0c/2c4/da6/f0c2c4da68e2b2afa76e6d778386dc88.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The constructor code of this object will be very similar to the code </font></font><code>Boost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but with a few differences:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rock:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> Rock.super.new(self, area, x, y, opts) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.x = gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + direction*(gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span>) self.y = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>, gh - <span class="hljs-number"><span class="hljs-number">16</span></span>) self.w, self.h = <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> self.collider = self.area.world:newPolygonCollider(createIrregularPolygon(<span class="hljs-number"><span class="hljs-number">8</span></span>)) self.collider:setPosition(self.x, self.y) self.collider:setObject(self) self.collider:setCollisionClass(<span class="hljs-string"><span class="hljs-string">'Enemy'</span></span>) self.collider:setFixedRotation(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) self.v = -direction*<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) self.collider:setLinearVelocity(self.v, <span class="hljs-number"><span class="hljs-number">0</span></span>) self.collider:applyAngularImpulse(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, instead of a RectangleCollider, the object will use a PolygonCollider. We create the vertices of this polygon by the function </font></font><code>createIrregularPolygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to be defined in </font></font><code>utils.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This function should return a list of vertices that make up an irregular rectangle. By an irregular rectangle, I mean one that looks like a circle, but each vertex of which may be slightly closer or farther from the center, and in which the angles between each of the vertices may also be slightly random. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin the definition of a function, we can say that it will receive two arguments: </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>point_amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The first will relate to the radius of the circle, and the second to the number of points that make up the polygon (polygon):</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createIrregularPolygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size, point_amount)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> point_amount = point_amount <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we can also say that if </font></font><code>point_amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not defined, then the default is 8. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next thing we can do is define all points. This can be done in a cycle from 1 to </font></font><code>point_amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in each iteration of which we will determine the next vertex based on the interval of angles. For example, to determine the position of the second point, we can say that its angle will be in the interval </font></font><code>2*angle_interval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, where </font></font><code>angle_interval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the value </font></font><code>2*math.pi/point_amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, in this case it will be approximately equal to 90 degrees. It is more logical to write this code, so:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createIrregularPolygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size, point_amount)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> point_amount = point_amount <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> points = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, point_amount <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> angle_interval = <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/point_amount <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> distance = size + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(-size/<span class="hljs-number"><span class="hljs-number">4</span></span>, size/<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> angle = (i<span class="hljs-number"><span class="hljs-number">-1</span></span>)*angle_interval + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(-angle_interval/<span class="hljs-number"><span class="hljs-number">4</span></span>, angle_interval/<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(points, distance*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(angle)) <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(points, distance*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(angle)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we define </font></font><code>angle_interval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as explained above, but also define </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as being somewhere within the radius of a circle, but with a random offset from </font></font><code>-size/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>+size/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This means that each vertex will not be exactly on the circle of the circle, but somewhere nearby. We also randomly randomize a range of angles to create the same effect. Finally, we add the x and y components to the list of returned points. Notice that the polygon is created in local space (assuming that the center is at 0, 0), that is, to place the object in the right place, we will then have to use it </font></font><a href="https://love2d.org/wiki/Body:setPosition" rel="nofollow"><code>setPosition</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another difference between the constructor of this object is that it uses the collision class </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Like all other classes of collisions, this one must also be defined before use:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'Enemy'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, new classes of collisions should be added for types of objects that will have different collision behaviors between each other. For example, enemies will physically ignore the player, but not the shells. Since no other type of object uses this behavior, we need to create a new class of collisions for it. If the Projectile collision class ignored only the player and not other projectiles, then the Projectile collision class could also be used for enemies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing to do with the Rock object is to render it. Since this is just a polygon, we can simply draw its points with </font></font><a href="https://love2d.org/wiki/love.graphics.polygon" rel="nofollow"><code>love.graphics.polygon</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rock:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(hp_color) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> points = {self.collider:getWorldPoints(self.collider.shapes.main:getPoints())} love.graphics.polygon(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, points) love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we get these points with </font></font><a href="https://love2d.org/wiki/PolygonShape:getPoints" rel="nofollow"><code>PolygonShape:getPoints</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The points are returned in local coordinates, and we need global ones, so we have to use </font></font><a href="https://love2d.org/wiki/Body:getWorldPoints" rel="nofollow"><code>Body:getWorldPoints</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to convert local coordinates to global ones. </font><font style="vertical-align: inherit;">After that we can draw a polygon and it will behave as we expect. </font><font style="vertical-align: inherit;">Note that since we get points directly from the collider, and the collider is a rotating polygon, we do not need to use </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to rotate the object, as it did with the Boost object, because the resulting points already take into account the rotation of objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we do all this, the game will look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7e/742/298/a7e742298c936b2a183b8716480b84ae.gif"></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with enemies </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Complete the following tasks:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add an attribute </font></font><code>hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the </font><font style="vertical-align: inherit;">Rock class </font><font style="vertical-align: inherit;">with an initial value of 100</font></font></li><li>    Rock  <code>hit</code> .     : <br><br><ul><li>     <code>damage</code> ,    ,       100 </li><li> <code>damage</code>    <code>hp</code> ,   <code>hp</code>  0  ,   Rock ¬´¬ª </li><li>  <code>hp</code>    0  ,   <code>hit_flash</code>  true,   0,2  ‚Äî false.  <code>hit_flash</code>   true,           <code>default_color</code> ,   <code>hp_color</code> . </li></ul></li></ul><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a new class </font></font><code>EnemyDeathEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This effect is created when the enemy dies and behaves exactly like an object </font></font><code>ProjectileDeathEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, only it is larger and corresponds to the size of the Rock object. This object must be created when the attribute </font></font><code>hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the Rock object becomes 0 or lower. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">112.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a collision event between a Projectile collision class object and an Enemy collision class object. In our case, we need to implement it in the update function of the Projectile class. When a projectile hits an object of the Enemy class, it must call the enemy‚Äôs function </font></font><code>hit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the amount of damage the </font><font style="vertical-align: inherit;">projectile hits </font><font style="vertical-align: inherit;">(by default, the projectiles will have an attribute </font></font><code>damage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initially equal to 100). When hit, the projectile must also call its own function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">113.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a function to the Player class </font></font><code>hit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This function should do the following:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should receive an argument </font></font><code>damage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and in the case when it is not defined, the default value is 10</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function should do nothing but set the attribute </font></font><code>invincible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to true.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From 4 to 8 objects should be created. </font></font><code>ExplodeParticle</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>addHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or </font></font><code>removeHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if you decide to add it) should receive the attribute </font></font><code>damage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use it to reduce the HP of the Player object. </font><font style="vertical-align: inherit;">Inside the function </font></font><code>addHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or </font></font><code>removeHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), a method must be implemented to handle the situation when </font></font><code>hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it becomes equal to or less than 0 and the player dies.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, the following conditional operations should be fair: </font></font><br><br><ul><li>       30,  <code>invincible</code>    true,     ‚Äî  false.  ,   0,2       6,     ,      0,5    0,25. ,  <code>invisible</code>     true  false  0,04    ,  <code>invincible</code>   true.  <code>invisible</code>   true,   Player    . </li><li>     30,     0,1    6,       ,     0,25     0,75. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This function </font></font><code>hit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be called when a player collides with Enemy. </font><font style="vertical-align: inherit;">In the event of a conflict with the enemy, the player must be dealt damage 30.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After completing these four exercises, you should have everything you need for such interactions between Player, Projectile and the enemy of Rock, as they should be in the game. </font><font style="vertical-align: inherit;">These interactions will apply to other enemies. </font><font style="vertical-align: inherit;">All this should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/e0c/31b/c63e0c31b7b203560b00b85f0266f17e.gif"></div></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EnemyProjectile </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can focus on one more part of the work with the enemies - making enemies firing projectiles. Some of the enemies will have such an opportunity available, so we will need to create an object similar to Projectile, but which the enemies will use. To do this, we will create an object </font></font><code>EnemyProjectile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This object can first be created by simply copying and slightly changing the code </font></font><code>Projectile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Both of these objects will have a lot of common code. We can abstract into a general object of shells that have a common behavior, but in fact this is not necessary, because there will be only two types of shells in the game. After copying we must make the following changes:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyProjectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.collider:setCollisionClass(<span class="hljs-string"><span class="hljs-string">'EnemyProjectile'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The EnemyProjectile collision class should also be EnemyProjectile. </font><font style="vertical-align: inherit;">We want EnemyProjectile objects to ignore other EnemyProjectile, Projectile and Player. </font><font style="vertical-align: inherit;">Therefore, we add a collision class appropriate for this goal:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area.world:addCollisionClass(<span class="hljs-string"><span class="hljs-string">'EnemyProjectile'</span></span>, {ignores = {<span class="hljs-string"><span class="hljs-string">'EnemyProjectile'</span></span>, <span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, <span class="hljs-string"><span class="hljs-string">'Enemy'</span></span>}}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important aspect that needs to be changed is damage. </font><font style="vertical-align: inherit;">A normal projectile, fired by a player, deals 100 damage, and an enemy projectile must do 10 damage:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyProjectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.damage = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also need the shells fired by the enemies to collide with the Player, but not with other enemies. </font><font style="vertical-align: inherit;">Therefore, we take the collision code used by the Projectile object and wrap it against the Player itself:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyProjectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider:enter(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> collision_data = self.collider:getEnterCollisionData(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, we want this object to be completely red, not red and white, so that the player can distinguish their shells from enemy ones: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyProjectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(hp_color) ... love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having made all these small changes, we have successfully created an EnemyProjectile object. </font><font style="vertical-align: inherit;">Now we need to create an enemy that will use it!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shooting enemy </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is what the enemy Shooter looks like: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath81.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, a small effect is played first, and then a shell is fired. </font><font style="vertical-align: inherit;">The projectile looks the same as that of the player, only completely red. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can start creating this enemy by copying the code from the Rock object. </font><font style="vertical-align: inherit;">This enemy (and indeed all enemies) will have a common property - appearing to the left or right of the screen, and then slowly moving inwards. </font><font style="vertical-align: inherit;">Since the Rock object already has this code, we can start with it. </font><font style="vertical-align: inherit;">After copying the code, we need to make small changes:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shooter:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.w, self.h = <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> self.collider = self.area.world:newPolygonCollider( {self.w, <span class="hljs-number"><span class="hljs-number">0</span></span>, -self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.h, -self.w, <span class="hljs-number"><span class="hljs-number">0</span></span>, -self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, -self.h}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The width, height and top of the enemy Shooter differ in values ‚Äã‚Äãfrom Rock. We simply created an irregular polygon near the stone, but this enemy needs to be given a clearly distinguishable and pointed shape so that the player can instinctively understand where he will move. The task of the peaks here is similar to the design process of the ships, so if you wish, you can change the appearance of the enemy and make it more steep.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shooter:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.collider:setFixedRotation(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) self.collider:setAngle(direction == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>) self.collider:setFixedRotation(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also need to change the following: unlike a stone, it is not enough just to set the speed of an object. We also need to set its angle so that the physical collider points in the right direction. To do this, we first need to turn off its constant rotation (otherwise the angle setting will not work), change the angle, and then make a constant rotation true again. We make the turn constant again, because we don‚Äôt want the collider to rotate when something hits it. We need it to stay in the direction of movement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The string </font></font><code>direction == 1 and math.pi or 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the implementation of the ternary operator in Lua. In other languages, it may look like </font></font><code>(direction == 1) ? math.pi : 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. I think the exercises in parts 2 and 4 allowed you to examine them in detail. In essence, the following happens here: if</font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal to 1 (the enemy appears to the right and is directed to the left), then the first conventional design is true, that is, we get </font></font><code>true and math.pi or 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Because of the order of execution </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the first will be </font></font><code>true and math.pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, as a result we will have </font></font><code>math.pi or 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which returns math.pi, because when both elements are true, then the </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first </font><font style="vertical-align: inherit;">one </font><font style="vertical-align: inherit;">returns. On the other hand, if it </font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is -1, then the first conditional is spars to false and we succeed </font></font><code>false and math.pi or 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is </font></font><code>false or 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which leads us to 0, because when the first element is false, it </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the second. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Given all this, we can start creating objects in the game Shooter, and they will look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a4/aa0/7ba/5a4aa07baa54cbb6d41df61f4dbb5383.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to create a pre-attack effect. Usually in most games, when the enemy is about to attack, something happens that tells the player about it. Most often it is an animation, but it can also be an effect. In our case, we will use the simple effect of "charging", in which many particles are sucked into the point from which the projectile will fly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is how it will be implemented at a high level:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- spawn PreAttackEffect object with duration of 1 second self.timer:after(1, function() -- spawn EnemyProjectile end) end) end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that at intervals of 3 to 5 seconds, each enemy Shooter will fire a new projectile. This will occur after the effect has been completed </font></font><code>PreAttackEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for one second. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similar effects work with particles as follows: as is the case with traces of exhaust, in each frame or through a frame, particles of a certain type are created that make up this effect. In our case, particles will be created called </font></font><code>TargetParticle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. These particles will move to the point that we define as the target, and then die after some time, or when they reach the goal.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TargetParticle:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> TargetParticle.super.new(self, area, x, y, opts) self.r = opts.r <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) self.timer:tween(opts.d <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>), self, {r = <span class="hljs-number"><span class="hljs-number">0</span></span>, x = self.target_x, y = self.target_y}, <span class="hljs-string"><span class="hljs-string">'out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TargetParticle:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(self.color) draft:rhombus(self.x, self.y, <span class="hljs-number"><span class="hljs-number">2</span></span>*self.r, <span class="hljs-number"><span class="hljs-number">2</span></span>*self.r, <span class="hljs-string"><span class="hljs-string">'fill'</span></span>) love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, for each particle, over time </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(or a random value from 0.1 to 0.3 seconds), the transition is performed by the function tween k </font></font><code>target_x, target_y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and when the particle reaches this position, it dies. </font><font style="vertical-align: inherit;">The particle is also drawn as a rhombus (as in one of the effects created earlier), but it can also be drawn as a circle or square, because it is rather small and becomes even smaller with time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We create these objects </font></font><code>PreAttackEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreAttackEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'TargetParticle'</span></span>, self.x + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>), self.y + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>), {target_x = self.x, target_y = self.y, color = self.color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, here we create one particle every 0.02 seconds (almost every frame) in a random place around its position, and then set the attributes of the </font></font><code>target_x, target_y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value of the position of the effect itself (that is, on the nose of the ship). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><code>Shooter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we create PreAttackEffect like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shooter:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'PreAttackEffect'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.4</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.collider:getAngle()), self.y + <span class="hljs-number"><span class="hljs-number">1.4</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.collider:getAngle()), {shooter = self, color = hp_color, duration = <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.timer:after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initial position we specify should be on the nose of the Shooter object, so we can use the usual pattern with math.cos and math.sin, which we have already used, and take into account both possible angles (0 and math.pi). We can also pass an attribute </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that controls the lifetime of the PreAttackEffect object. Here we can do the following:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreAttackEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:after(self.duration - self.duration/<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do not use it ourselves </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">because this is the object that I myself call the ‚Äúcontroller object‚Äù. For example, it has nothing in the draw function, that is, we will never see it in the game. We see only the objects </font></font><code>TargetParticle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that he orders to create. These objects have a random lifetime, from 0.1 to 0.3 seconds, that is, if we want the last particles to end immediately when the shell is fired, then this object will die in 0.1-0.3 seconds later than its duration in 1 second. I decided to make it equal to 0.75 (duration - duration / 4), but you can instead use another number, closer to 0.9 seconds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we start the game now, it will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/268/5f4/c092685f411b013f4e10c28d59851ad5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And everything works quite well. </font><font style="vertical-align: inherit;">But if you look closely, you will notice that the target position of the particles (the position of the PreAttackEffect object) remains fixed, and does not follow the Shooter. </font><font style="vertical-align: inherit;">We can fix it just as we fixed the player's ShootEffect object. </font><font style="vertical-align: inherit;">We already have an attribute </font></font><code>shooter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointing to the Shooter object that created the PreAttackEffect object, so we can simply update the position of the PreAttackEffect based on the position of this parent object </font></font><code>shooter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreAttackEffect:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shooter <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.shooter.dead <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.x = self.shooter.x + <span class="hljs-number"><span class="hljs-number">1.4</span></span>*self.shooter.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.shooter.collider:getAngle()) self.y = self.shooter.y + <span class="hljs-number"><span class="hljs-number">1.4</span></span>*self.shooter.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.shooter.collider:getAngle()) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we each frame update the position of this object so that it is located on the nose of the object that created it Shooter. </font><font style="vertical-align: inherit;">If you start the game, it will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/db9/2df/103db92df9929be185004f2dfbc796ac.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important aspect of the update code is a part </font></font><code>not self.shooter.dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It may happen that when we refer to objects inside each other in a similar way, then when one object dies, another one will still keep a reference to it. For example, a PreAttackEffect object lives 0.75 seconds, but between its creation and disappearance, the Shooter object that created it can be killed by a player. If this happens, there may be a problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our case, the problem is that we have access to the </font></font><code>collider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shooter object </font><font style="vertical-align: inherit;">attribute </font><font style="vertical-align: inherit;">, which is destroyed when the Shooter object dies. And if this object is destroyed, we can do nothing with it, because it no longer exists. So when we try to execute</font></font><code>getAngle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then the game will fall out. We can work out a general system that solves such a problem, but in fact I don‚Äôt think it is necessary. For now, it is enough for us to simply be attentive to when we refer to objects in this way, so as not to try to gain access to objects that may already be dead. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, the last part in which we will create an EnemyProjectile object. For now we will work with it quite simply, creating it, as we usually create any other object, but with our own attributes:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shooter:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.timer:after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'EnemyProjectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.4</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.collider:getAngle()), self.y + <span class="hljs-number"><span class="hljs-number">1.4</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.collider:getAngle()), {r = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(current_room.player.y - self.y, current_room.player.x - self.x), v = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>), s = <span class="hljs-number"><span class="hljs-number">3.5</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we create a projectile in the same position in which we created PreAttackEffect, and then assign its speeds to a random value between 80 and 100. We also slightly increase its size relative to the default value. </font><font style="vertical-align: inherit;">The most important part is to have its angle ( </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attribute) pointing in the direction of the player. </font><font style="vertical-align: inherit;">In general, when we want to get the angle from </font></font><code>source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we need to do the following:</font></font><br><br><pre> <code class="lua hljs">angle = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(target.y - source.y, target.x - source.x)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we do. </font><font style="vertical-align: inherit;">After creating the object, it will be directed to the player and begin to move towards it. </font><font style="vertical-align: inherit;">It should look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb5/8a1/d8c/cb58a1d8ccf6798b5917fd8c429c3742.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you compare this animation with the animation from the beginning of this part of the tutorial, you will notice a slight difference. Projectiles have a period of time when they slowly turn towards the player, rather than fly directly to him. The same code fragment is used here as in the passive homing skill, which we will add over time, so I will leave it for later.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradually, we will fill the EnemyProjectile object with various functionalities so that it can be applied to many different enemies. However, all this functionality will be first implemented in the Projectile object, since it will serve as player passive skills. For example, there is a passive skill that causes projectiles to circle around the player. After we implement it, we can copy the code into the EnemyProjectile object and implement the enemy using the function. He will not fire shells - they will circle around him. In this way we will create many enemies, so when we create passive skills for the player, I will leave this part as an exercise.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For now, we‚Äôll focus on two enemies (Rock and Shooter), leave the EnemyProjectile as it is, and move on to other aspects. </font><font style="vertical-align: inherit;">But later, when we add more functionality to the game, we will return to create new enemies.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EnemyProjectile / Shooter Exercises </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">114.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a collision event between Projectile and EnemyProjectile. </font><font style="vertical-align: inherit;">In the EnemyProjectile class, make it so that when it gets into an object of the Projectile class, the function of </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">both objects is </font><font style="vertical-align: inherit;">called </font><font style="vertical-align: inherit;">and both are destroyed. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">115.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Does the name of an attribute </font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the class Shooter confuse us? </font><font style="vertical-align: inherit;">If so, how should it be renamed? </font><font style="vertical-align: inherit;">If not, why not?</font></font></div><p>Source: <a href="https://habr.com/ru/post/349718/">https://habr.com/ru/post/349718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349706/index.html">Kill the Dragon: The Thorny Path to Agile</a></li>
<li><a href="../349708/index.html">We focused on the client (and not on competitors) - and over the year received over a million new users</a></li>
<li><a href="../349710/index.html">How not to go crazy in the development of regulatory information management systems. From the history of our projects</a></li>
<li><a href="../349714/index.html">Using ReSwift: Writing the Memory Game Application</a></li>
<li><a href="../349716/index.html">A Cloud Guru portal interview with Kelsey Hightower: about DevOps, Kubernetes and serverless</a></li>
<li><a href="../349720/index.html">Authorization using ssl certificate on nginx + Let's Encrypt</a></li>
<li><a href="../349722/index.html">How we built VDI with 14,000 jobs for the VTB Group</a></li>
<li><a href="../349724/index.html">How we improved technical support with cohort analysis</a></li>
<li><a href="../349726/index.html">Basics of programming on the SAS Base. Lesson 2. Access to data</a></li>
<li><a href="../349728/index.html">Asynchronous HTTP requests in C ++: incoming through RESTinio, outgoing through libcurl. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>