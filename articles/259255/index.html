<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of weather effects. Precipitation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task of correctly simulating weather effects has been stretching from the very beginning of the gaming industry. The weather is an integral part o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of weather effects. Precipitation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b05/cfa/de8/b05cfade853947c295989e829854900a.png"><br><br>  The task of correctly simulating weather effects has been stretching from the very beginning of the gaming industry.  The weather is an integral part of our life, which means that games without weather effects are not quite complete.  That is why a rare game does without at least a very primitive weather simulation.  Since the task is very old, there are many outdated solutions that are still being used, despite the obviously low efficiency.  And if the usual fog is simple, then the implementation of precipitation causes some difficulties. <br><br>  So, what is rain or snow in the real world? <br><a name="habracut"></a><br>  These are billions of small particles that more or less evenly fill the space from the earth itself to the clouds.  In case we had unlimited computational resources - all that would have to be done to simulate precipitation - to process this billion particles, evenly distributed over the location.  However, our computing power is very limited and even a million particles in real time can be counted only if the location consists of only precipitation, no landscape, objects and everything else.  What to say about the billion. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this regard, in the process of implementing precipitation we face three separate tasks: <br><ul><li>  Reducing the number of particles from a billion to an acceptable 20-50 thousand. </li><li>  Reducing the amount of computation per particle to the minimum. </li><li>  Transfer all calculations to the GPU. </li></ul><br>  To begin, consider how we will achieve this: <br>  We will reduce the number of particles on the basis of a simple conclusion: the observer does not see the entire billion particles.  He does not see the particles behind him, too far below and above.  This already cuts the number of particles by 3-4 times.  But 200 million is a bit too much.  Here we come to the aid of a little trick.  The fact is that the particles are very small and in reality, at a distance of several meters, they turn into a uniform veil.  Therefore, ‚Äúhonestly‚Äù we need to draw only particles in front of an observer at a distance of about 10 meters.  50,000 particles in such conditions is enough to create the appearance of very dense snowfall.  Also, it is important to understand that in the real world, the particle size is measured in millimeters.  In the case of a computer simulation, we can safely increase the particle size to a few centimeters and it will still look good, because  the observer has no opportunity to examine the particles and compare their sizes with the objects around. <br><br>  Here is the location with precipitations in the form of snow with the following settings: The number of particles is 25,000 within 15 meters, the particle size is 10 centimeters, at a distance of 20 to 100 meters a white mist with a density of 80%. <br><br><img src="https://habrastorage.org/files/2fb/a4d/aca/2fba4dacaa6d44f998a604e15b83ddd7.png"><br><br>  Here is the same location with disabled rainfall: <br><br><img src="https://habrastorage.org/files/b40/804/1a2/b408041a2bd849ee984f91064f960a95.png"><br><br>  Despite the fact that the particle size is unnaturally large, the observer perceives this as absolutely normal - he cannot estimate the distance to the particle, and it seems that large particles are large because they are very close.  Although in reality it is not. <br><br>  The second important task is to reduce the calculations for each particle to a minimum.  Even 25,000 particles in each frame is a sizeable load.  Therefore, even a small optimization matters.  So, let us remember: what calculations we need to carry out over a particle, if we consider it honestly: <br><ul><li>  Appearance in random xy volume coordinates </li><li>  Acceleration due to gravity </li><li>  Z air resistance </li><li>  Air resistance X, Y (wind) </li><li>  Intersection with the geometry (so that the particles do not pass through obstacles, for example, the roof of the house where the observer is located). </li></ul><br>  These parameters are very important if we are working on an exact simulation.  However, in games, the visual component is important for us, not the accuracy of a physical simulation.  The observer does not have the ability to trace the behavior of one particular particle, so you can safely get rid of randomness and fair calculation.  Even if a particle goes from cycle to cycle the same way without changes - the observer will not notice this, since  24999 particles will move alongside their own paths (even if they are looped). <br>  Therefore: <br><ul><li>  Particles always appear in the same coordinates relative to the block.  These coordinates are the coordinates transmitted via the vertex buffer. </li><li>  Acceleration and resistance in Z, we ignore and believe that they overlap each other.  That is, the particle moves at a constant speed. </li><li>  Ignore honest calculations and simply add the wind speed * time to the initial XY coordinates of the particle. </li><li>  We bake all static geometry in the height map and simply check the Z-position of the particle and the height of the particle in the XY coordinates.  If the particle has dropped below the height at this point - we do not draw it. </li></ul><br>  It is worth noting that the simplified intersection with the geometry does not always work, and sometimes it can even create artifacts.  Visually, it looks like the appearance of particles from the void. <br><br><img src="https://habrastorage.org/files/845/761/fa5/845761fa52b84a3d987f2170f3cdbc66.png"><br><br>  Our particle begins its journey at point ‚ÄúA‚Äù located above the house, and as long as it descends to point ‚ÄúB‚Äù, everything is fine.  It is above geometry.  As soon as she crossed the height ‚ÄúB‚Äù, she became invisible, because  is under the roof.  This continues until it passes point ‚ÄúC‚Äù.  Due to the influence of the wind, the particle moved outside the house and again turned out to be higher than the geometry, as a result of which it again becomes visible.  Visually, it looks like the particles "appear" from the wall of the house.  This is a rather unpleasant artifact and it is worth bearing in mind that it exists.  If we try to ‚Äúhonestly‚Äù calculate the intersection of the particle vector with the geometry, we risk very much slowing down the operation of the precipitation system.  But there is a fairly simple hint: modify the height map in accordance with the deviation of particles due to wind: <br><img src="https://habrastorage.org/files/bd6/e82/193/bd6e8219320447ef8c95786342af1706.png"><br>  The only disadvantage of this solution is that you will have to rebuild the height map when the wind changes. <br><br>  Igrostroy has always been a compromise between artifacts and speed, and this case is just one of the examples of such a compromise.  The artifact is the more noticeable, the higher the wind speed. <br><br>  The last stage of optimization is the transfer of calculations to the GPU.  Actually, we didn‚Äôt have any special calculations after the previous step. <br><br>  XY coordinates are calculated from the origin coordinates plus the offset added by the wind: <br>  XY = Start.xy + Wind * Time; <br>  The Z coordinate is calculated by subtracting from the initial coordinate of the fall velocity multiplied by the time: <br>  Z = Start.z - Speed ‚Äã‚Äã* Time <br>  Well, and the last thing - the visibility of a particle is determined by comparing the obtained Z coordinate with the height of the geometry at this point: <br>  IsVisible = MapHeight (XY) &lt;Z <br><br>  All these three operations are easily transferred to the GPU.  There is also a calculation of transparency, taking into account the distance from the observer, the use of lighting, and other trifles.  But they are already used on the GPU and, obviously, will not become a problem during the transfer. <br><br>  Before proceeding to the description of the specific implementation of all of the above, it is worthwhile to dwell on another important aspect of the implementation.  Namely, on determining where in the world to draw the block of particles we created and what shape it should be. <br><br>  The first thing that comes to mind during implementation is part of a cylinder, centered on the coordinates of the observer and sliced ‚Äã‚Äãalong the edges of the frustum. <br><br><img src="https://habrastorage.org/files/ca9/a5b/586/ca9a5b58670b4d38bd64cdce9170368e.png"><br><br>  This is a very seductive option, because  generating particles only within the resulting piece of the cylinder, we can only work with the zone that the observer sees.  That is, almost all 50,000 generated particles will be on the screen!  Very economical!  But everything breaks down when we give the observer the opportunity to move and rotate the camera.  In order for the particles to remain inside the frustum, we will have to move the cylinder along with the observer.  That is, regardless of how the observer moves and turns - he always sees the same particles!  This is no good.  Therefore, we will dwell on another variant, there are quite a lot of degenerate particles in it, but at the same time the rotation and movement of the camera does not break the work of the particle system and when moving and rotating the camera it seems that we see new particles, although in reality this is all the same block particles. <br><br>  The idea is that we work with a zone in the form of a cube.  During initial initialization, particles are randomly placed on the XoY plane in accordance with the dimensions of the cube. <br><br>  The coordinates of the particles fill a square piece at the origin of the world the size of a block: <br><br><img src="https://habrastorage.org/files/990/f1f/fb8/990f1ffb81264d7a9931de4145076259.png"><br><br>  Black dots mark the coordinates of the particles as is.  Red - these are the same particles, only offset by the block size.  How it works: we have a frustum observer.  We take and enter our cube in frustum.  The main conditions for inscribing three: <br><br>  1) The block does not rotate.  Entry is carried out only by movement. <br>  2) The coordinates of the observer should be contained in the block. <br>  3) The distance from the observer to the intersection of both faces of the frustum with the sides of the block should be the same as possible. <br><br>  After fitting the block into the frustum, we get something like this: <br><br><img src="https://habrastorage.org/files/0e5/e8d/7e2/0e5e8d7e2b2d4b88835b57d1400ad492.png"><br><br>  Frustum is much bigger than our block, but it doesn't matter, because  particles must be only in the first few meters of the observer. <br><br>  After we have obtained the coordinates of the inscribed block, we assume the XY coordinates for each particle, taking into account the application of the wind.  For simplicity, in this example, I will assume that there is no wind and, accordingly, the coordinates of the particles have not changed their XY coordinates. <br><br><img src="https://habrastorage.org/files/314/3c2/0eb/3143c20eb39d4329ab62656f74f46cad.png"><br><br>  We displace each particle so that it falls into the inscribed block.  To do this, we shift the particles along X and Y, but do not shift them smoothly, but in increments equal to the size of the block. <br><br><img src="https://habrastorage.org/files/7c9/731/c9d/7c9731c9d32c48fa83542ad34037c987.png"><br><br>  It turns out that the particles do not move each by itself, but in blocks.  For example, particles trapped in block ‚Äú1‚Äù will move along X by 2 sizes, and along Y by 1. <br><br>  Thus, all particles will be inside the zone on their projections in accordance with the displacement on the grid. <br>  Moving, the observer will shift the zone and the particles, respectively, will move to new projections. <br>  For example, if the observer moves from X to the right from the current position, blocks ‚Äú4‚Äù and ‚Äú2‚Äù will decrease, and blocks ‚Äú3‚Äù and ‚Äú1‚Äù, on the contrary, will increase.  Particles that have fallen out of the zone to the left jump to the right.  As a result, moving, the observer will see all new particles, although in reality these are old particles that have fallen out of the zone.  The same situation with rotation, only the zone will change not because of a change in the position of the observer, but because of a change in the frustum boundaries. <br><br><h4>  Practical implementation </h4><br>  All precipitation particles are drawn in one DIP.  The vertex buffer is initialized once statically and no longer changes.  Each particle is represented by one vertex, with random XY within the block.  Geometric shader creates a particle from the vertex.  Made on the example of snow.  For a rain it is necessary to do not spherical billboards, but cylindrical.  And, accordingly, the particle is not square, but rectangular. <br><br>  Globally for all particles we need the following data: <br>  mat4 ModelViewProjectionMatrix;  - a projection-model-specific matrix for transferring coordinates from model space to camera space and projecting onto the screen plane; <br>  float time;  - global time in seconds; <br>  float speed;  - particle falling speed; <br>  float top;  - the height from which particles begin to fall; <br>  float bottom;  - the height at which the particles end to fall; <br>  float circleTime;  - time during which the particle moves from the highest point to the lowest; <br>  vec2 Wind;  - wind speed; <br>  float TileSize;  - block size; <br>  vec2 border;  - block coordinates.  The upper left corner of the block.  The bottom right is Border + vec2 (TileSize, TileSize); <br>  float ParticleSize;  - particle size; <br>  sampler2D Texture;  - particle texture. <br><br>  Attributes of each particle: <br>  vec2 Position;  - position.  This value is set randomly within the block.  Z-coordinate is not specified, because  it is calculated inside the shader; <br>  float TimeShift;  - particle displacement in time relative to 0. The value is set randomly within CircleTime. <br><br>  Adding this value to Time, we get a random starting position of the particle; <br>  float speedscale;  - random value ranging from 0.9 - 1.1.  Multiplying this Speed ‚Äã‚Äãvalue, we get a slightly different speed for each particle. <br>  Vertex shader: <br><br><pre><code class="hljs pgsql">uniform mat4 ModelViewProjectionMatrix; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">Time</span></span>; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> Speed; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> Top; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> Bottom; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> CircleTime; // (Top-Bottom)/Speed uniform vec2 Wind; uniform <span class="hljs-type"><span class="hljs-type">float</span></span> TileSize; uniform vec2 Border; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 Position; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> TimeShift; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> SpeedScale; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> vec4 Position3D; <span class="hljs-type"><span class="hljs-type">void</span></span> main(<span class="hljs-type"><span class="hljs-type">void</span></span>) { <span class="hljs-type"><span class="hljs-type">float</span></span> ParticleCircleTime = CircleTime / SpeedScale; <span class="hljs-type"><span class="hljs-type">float</span></span> CurrentProgress = mod(<span class="hljs-type"><span class="hljs-type">Time</span></span> + TimeShift, ParticleCircleTime); vec3 Pos = vec3(Position.xy + Wind*CurrentProgress , Top - Speed*SpeedScale*CurrentProgress); Pos.x = mod(Pos.x, TileSize); Pos.y = mod(Pos.y, TileSize); <span class="hljs-type"><span class="hljs-type">float</span></span> c; c = floor(Border.x/TileSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c*TileSize+Pos.x &lt; Border.x) Pos.x = Pos.x + (c+<span class="hljs-number"><span class="hljs-number">1</span></span>)*TileSize; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Pos.x = Pos.x + c*TileSize; c = floor(Border.y/TileSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c*TileSize+Pos.y &lt; Border.y) Pos.y = Pos.y + (c+<span class="hljs-number"><span class="hljs-number">1</span></span>)*TileSize; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Pos.y = Pos.y + c*TileSize; Position3D = ModelViewProjectionMatrix * vec4(Pos,<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Geometric Shader: <br><br><pre> <code class="hljs cs">layout(points) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>; layout(triangle_strip, max_vertices=<span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec3 up = vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec3 right = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>); uniform vec2 ParticleSize; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec4 Position3D []; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TexCoordX; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TexCoordY; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { vec3 u = up * vec3(ParticleSize.y); vec3 r = right * vec3(ParticleSize.x); vec3 p = Position3D[<span class="hljs-number"><span class="hljs-number">0</span></span>].xyz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w = Position3D[<span class="hljs-number"><span class="hljs-number">0</span></span>].w; gl_Position = vec4 ( p - u - r, w ); TexCoordX = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; TexCoordY = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; EmitVertex (); gl_Position = vec4 ( p - u + r, w ); TexCoordX = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; TexCoordY = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; EmitVertex (); gl_Position = vec4 ( p + u + r, w ); TexCoordX = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; TexCoordY = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; EmitVertex (); EndPrimitive (); <span class="hljs-comment"><span class="hljs-comment">// 1st triangle gl_Position = vec4 ( p + u + r, w ); TexCoordX = 1.0; TexCoordY = 0.0; EmitVertex (); gl_Position = vec4 ( p + u - r, w ); TexCoordX = 0.0; TexCoordY = 0.0; EmitVertex (); gl_Position = vec4 ( p - u - r, w ); TexCoordX = 0.0; TexCoordY = 1.0; EmitVertex (); EndPrimitive (); // 2nd triangle }</span></span></code> </pre><br>  Fragment Shader: <br><br><pre> <code class="hljs cs">uniform sampler2D Texture; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TexCoordX; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TexCoordY; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { color = texture(Texture, vec2(TexCoordX, TexCoordY)); }</code> </pre><br><br>  Let's take a closer look at what the given shaders do. <br>  All basic operations are performed in the vertex shader.  The geometric shader unpacks a point into a volume particle, and a fragmentary one simply applies a texture.  Due to the simplicity of the code, the geometry and fragment shader will not be considered. <br><br>  Consider the vertex shader: <br>  The first thing we need to do is find out what position the particle is in right now.  Our position is tied to time, so we must calculate time.  This is done by two operations: <br><br>  float ParticleCircleTime = CircleTime / SpeedScale; <br>  float CurrentProgress = mod (Time + TimeShift, ParticleCircleTime); <br>  The first line gives the total cycle time to the cycle of a particular particle.  Since  the cycle depends on the speed, and the speeds differ on SpeedScale, then all we need to do is to divide the total cycle time by the speed factor. <br><br>  The second line we get the current global time of the particle, divide by the time of one cycle and get the remainder of the CurrentProgress division.  This is the time elapsed from the start of the current cycle for a particular particle. <br><br>  The next stage is the calculation of the position in accordance with the past time.  To calculate XY, you need to add to the starting position the offset from the wind; for Z, subtract the speed of fall multiplied by time. <br>  vec3 Pos = vec3 (Position.xy + Wind * CurrentProgress, Top - Speed ‚Äã‚Äã* SpeedScale * CurrentProgress); <br>  Since the particle could fly out of the block because of the wind, we need to return it to the block: <br>  Pos.x = mod (Pos.x, TileSize); <br>  Pos.y = mod (Pos.y, TileSize); <br>  As a result, we get the coordinates of the particle within the block. <br><br><img src="https://habrastorage.org/files/314/3c2/0eb/3143c20eb39d4329ab62656f74f46cad.png"><br><br>  However, we need the particles to be not at the origin, but around the observer!  In this regard, we move the particles to the zone described around the frustum: <br><br>  c = floor (Border.x / TileSize); <br>  if (c * TileSize + Pos.x &lt;Border.x) <br>  Pos.x = Pos.x + (c + 1) * TileSize; <br>  else <br>  Pos.x = Pos.x + c * TileSize; <br><br>  c = floor (Border.y / TileSize); <br>  if (c * TileSize + Pos.y &lt;Border.y) <br>  Pos.y = Pos.y + (c + 1) * TileSize; <br>  else <br>  Pos.y = Pos.y + c * TileSize; <br><img src="https://habrastorage.org/files/7c9/731/c9d/7c9731c9d32c48fa83542ad34037c987.png"><br><br>  The resulting coordinates are projected onto the screen: Position3D = ModelViewProjectionMatrix * vec4 (Pos, 1.0); <br><br>  Next, the geometric shader will unpack the vertex into a particle. <br><br>  The code is the simplest implementation of snow.  Adding global illumination, point sources of light and intersection with geometry are quite simple tasks, I think you will cope with them yourself.  Also do not forget that particles alone are not enough to create rainfall or snowfall, since  not very many particles.  In this situation will help the fog, through which creates a feeling of snow or rain shroud. <br><br>  Note: <br>  <i>This article was written in the framework of the unpublished book several years ago.</i> <i><br></i>  <i>After completing work on a fairly large project, I looked back and saw that over the years of development there were tasks that could be interesting to talk about.</i>  <i>As a result, a book appeared.</i>  <i>The book was written and edited in 2012, but was not published anywhere, because</i>  <i>its target audience was not clear.</i> <i><br><br></i>  <i>Today I came across the text of this book and thought that maybe some chapters from it would be interesting for the Habr community.</i> <i><br><br></i>  <i>As a test, I publish a chapter on the implementation of weather effects.</i>  <i>If the article is positively received by the community, I will publish a couple more chapters later.</i> </div><p>Source: <a href="https://habr.com/ru/post/259255/">https://habr.com/ru/post/259255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259243/index.html">Smart Internet of Things - who is he and what does he eat with?</a></li>
<li><a href="../259247/index.html">Remote control for photography with geotags based on LinkIt One</a></li>
<li><a href="../259249/index.html">How we used design thinking when creating a new AdTrack</a></li>
<li><a href="../259251/index.html">Search for periodic security elements of the RF Passport using the Fourier transform</a></li>
<li><a href="../259253/index.html">10 ways to protect data in Office 365</a></li>
<li><a href="../259257/index.html">Record of the webinar "What's new in Kerio Connect 8.5"</a></li>
<li><a href="../259259/index.html">The largest small polyhedra: new solutions in combinatorial geometry</a></li>
<li><a href="../259261/index.html">Metalworking - 2015, part one: electro-erosion, water-jet, presses, lasers and router</a></li>
<li><a href="../259263/index.html">Questions to meet with Opera Software in Petersburg</a></li>
<li><a href="../259265/index.html">Lua, OOP and nothing more</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>