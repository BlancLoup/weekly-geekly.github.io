<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are struggling with Status 7. How does the OTA update mechanism work and why does it fail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quite often, users who are accustomed to rutting firmware, installing various kinds of system software, changing kernels and differently making fun of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are struggling with Status 7. How does the OTA update mechanism work and why does it fail</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/405/efa/d36/405efad3672d456fb54134f0639cd834.jpg"><br><br>  Quite often, users who are accustomed to rutting firmware, installing various kinds of system software, changing kernels and differently making fun of firmware, find that it is impossible to install an OTA update.  It simply does not rise, swearing at the changed system files, wrong digital keys, and everything else.  In this article I will talk about the mechanics of the update itself, the causes of problems, and how to solve them. <br><a name="habracut"></a><br><h4>  <b>How it works</b> </h4><br>  The first new versions of Android traditionally receive the latest of the Nexus devices.  When the new version of the firmware is ready for the general public, the full image is posted to developers.google.com/android/nexus/images.  Soon after, the distribution of the firmware through the air begins.  As one of Google developers Dan Morrill <a href="http://www.reddit.com/r/Android/comments/1r1dz4/44_kitkat_has_started_rolling_out_on_the_n4/cdiwt6f">tells</a> (Dan Morrill), at first OTA is sent to 1% of devices.  This happens randomly, regardless of the region or place of purchase of the phone / tablet.  At this time, bugs are caught, which allows you to suspend the update in the presence of critical errors among a large number of users. <br><br>  Then within a couple of weeks, the update is distributed for 25, 50, 100% of users.  That is, in the first stage, the chance to receive an update has one device out of a hundred.  If the update is not received, the device drops out of the list and repeated repeated clicking on the button ‚ÄúCheck for updates‚Äù automatically transfers the device to the end of the list.  When a new distribution stage is launched, clicking on the button gives the next chance to receive an update already 25%.  Since the device itself checks for updates once a day (or when rebooting), then pressing the button can ‚Äúshoot‚Äù before it happens by itself.  But again, there will be a check only once.  Further clicks will not help.  This is not the situation when "who first clicked, he first received."  In any case, the air update will come to everyone within a couple of weeks.  The most impatient can update the update with their hands (see below). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/3f9/dea/c82/3f9deac822d3475088c1bab32a335061.png"><br>  Update Notification <br><br><h4>  <b>We force update</b> </h4><br>  There are two ways to speed up getting updates.  The first is to clear the Google Services Framework data and then reboot the device.  Extremely not recommended method which <a href="http://www.reddit.com/r/Android/comments/1r1n5z/psa_do_not_clear_data_for_google_service_framework/cdiymrp">even Google engineers condemn</a> .  This method causes many negative effects, the main of which is the change of identifier for GCM (Google Cloud Messenger).  This identifier is needed in all Google programs and many other applications that use push notifications.  And if in some programs it is relatively easy to overcome the effects, for many others the consequences may be more sad.  All applications will simply stop accepting GCM-based push notifications until they receive a new identifier.  Some applications check frequently, some rarely.  For the part, cleaning the application data will help.  And those applications that use GCM ID as an identifier on their servers may have deeper problems. <br><br><img src="https://habrastorage.org/files/345/caa/649/345caa649dc146619e89eb2cea2f330e.jpg"><br>  Stock recovery <br><br>  The second is to install the update by hand through the recovery console.  Shortly after the launch of the OTA, files like.signed-hammerhead-LRX21O-from-KTU84P.c1a33561. which one with which).  On a computer, you must have a folder with utilities ADB and fastboot.  I am using the latest versions of the Android SDK.  In the same folder you need to put the downloaded archive with the OTA-update.  It is also necessary to have properly installed drivers for the device, which may conflict with previously installed drivers for other devices. <br><br>  The device itself should be put into recovery mode.  To do this, with the device turned off, we simultaneously hold down the &lt;Power + VolDown&gt; buttons and enter the bootloader, select Recovery mode with the volume button, enter the Power button with it.  A recumbent Android will appear with an exclamation point.  This is not a mistake, you should not be afraid.  It is necessary on this screen to briefly press &lt;Power + VolUp&gt;, after which the stock recovery will load.  In it, you must select the apply update from ADB button with the volume buttons and confirm with the power button.  Next, you need to connect your phone / tablet to your computer.  Start the console, go to the folder with the ADB and the update archive and enter the following command (for the file above): <br><br><pre><code class="bash hljs">$ adb sideload .signed-hammerhead-LRX21O-from-KTU84P.c1a33561.zip</code> </pre> <br>  After that, the phone will install OTA and it will reboot. <br><br><blockquote><h4>  Inset block: How to download the update via the cellular network </h4><br>  Notification of the availability of OTA can come when the device is not connected to Wi-Fi.  At that, a note will appear that the file is available for download via Wi-Fi before a certain date (about a week), and the Download button itself will be inactive.  This is done to save user money.  If a Wi-Fi connection is not foreseen in the near future, you can fool the phone and download the update via 3G / 4G, simply by moving the date in the phone forward, later than the date specified in the notification, and rebooting the device. </blockquote><br><blockquote><h4>  INFO </h4><br>  Stock (stock - from the store) firmware is understood to be the presence of a factory kernel, recovery, and the absence of modifications, including those obtained with the help of root. </blockquote><br><h4>  <b>Modified firmware</b> </h4><br>  If your bootloader is unlocked, custom recovery is installed, root is obtained, which various programs are actively using, and various modifications are applied, then with a 99% probability the update will not be installed.  Even when the stock recovery is returned when flashing via ADB, the Status 7 error will be issued. The custom recovery will also write an error, cursing the changed files.  You can overcome this problem by returning the smartphone to the factory firmware, but this is not our method.  We will deal with it, picking up the update file, find out where the installation stumbles, and fix the problem.  And all this is based on the example of the largest Nexus 5 update - from version 4.4.4 (KTU84P) to 5.0 (LRX21O). <br><br><h4>  OTA mechanics </h4><br>  So, the update from 4.4.4 to 5.0 was the largest one recently, with an archive weight of 491 MB.  In connection with the change of Dalvik to ART, almost all of the code has been modified.  So what does the archive contain?  As can be seen in the screenshot ‚ÄúFiles from the archive with the upgrade to 5.0‚Äù, inside the archive are images of the bootloader (various sections), META-INF, patch and system directories. <br><br><img src="https://habrastorage.org/files/793/434/a16/793434a165744c6fad493ed5a686c3a4.jpg"><br>  Files from archive with updating to 5.0 <br><br>  To minimize the amount of traffic and reduce server load, as well as to reduce the end-user costs, the update structure is structured so that files with a large number of changes or written from scratch are located in the system directory and are changed entirely.  And files with small changes by Google‚Äôs standards are not replaced, but patched, that is, pieces of code inside the file change.  These files are located inside the patch directory and have the extension .p.  This is clearly seen when comparing files in / system / bin and / patch / system / bin.  At the same time, the bsdiff, well-known to Unixoids, is used to create a patch, which allows you to get a delta (a file with a difference between the files) from two binaries. <br><br>  The very same magic occurs at the will of updater-script, which is located in / META-INF / com / google / android.  That is what we consider in more detail.  The file itself weighs 463 KB and contains lines of code responsible for the process of applying the OTA update (in fact, it is the script language Edify, the interpreter of which is located in the same directory and has the name update-binary. - Ed.).  This is what it contains in our case.  First, the / system partition is mounted (the standard mount line for Linux is quite similar to those found in / etc / fstab): <br><br><pre> <code class="bash hljs">mount(<span class="hljs-string"><span class="hljs-string">"ext4"</span></span>, <span class="hljs-string"><span class="hljs-string">"EMMC"</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/system"</span></span>, <span class="hljs-string"><span class="hljs-string">"/system"</span></span>, <span class="hljs-string"><span class="hljs-string">"max_batch_time=0,commit=1,data=ordered,barrier=1,errors=panic,nodelalloc"</span></span>);</code> </pre><br>  Next, the script checks the device model and firmware version by reading the ro.build.fingerprint system variable (note that it does not take it from the /system/build.prop file, but requests the recovery itself, so the updates cannot be installed using the custom console recovery, although up to 5.0 it was possible).  Hereinafter, the ellipsis is abbreviated lines: <br><br><pre> <code class="bash hljs">getprop(<span class="hljs-string"><span class="hljs-string">"ro.build.fingerprint"</span></span>) == <span class="hljs-string"><span class="hljs-string">"google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys"</span></span> || getprop(<span class="hljs-string"><span class="hljs-string">"ro.build.fingerprint"</span></span>) == <span class="hljs-string"><span class="hljs-string">"google/hammerhead/hammerhead:5.0/LRX21O/1570415:user/release-keys"</span></span> || abort(<span class="hljs-string"><span class="hljs-string">"Package expects build fingerprint of google/hammerhead/hammerhead:4.4.4 ..."</span></span>); getprop(<span class="hljs-string"><span class="hljs-string">"ro.product.device"</span></span>) == <span class="hljs-string"><span class="hljs-string">"hammerhead"</span></span> || abort(<span class="hljs-string"><span class="hljs-string">"This package is for \"hammerhead\" devices ..."</span></span>);</code> </pre><br>  As can be seen above, the update will not be added to the ‚Äúnon-native‚Äù device, but it can be re-rolled to version 5.0.  The script also checks if the firmware is signed with official Google keys (release-keys).  Because of this, many users have problems.  Next begins checking the availability and integrity of individual files using the SHA-1 hash check.  Two functions are used for this: sha1_check (), which takes as its arguments the file name and hash, and apply_patch_check (), which takes three arguments: the file name, and two hashes.  The first one is used simply to check the integrity of the file, the second one checks whether the file has already been patched.  For simplicity, the long hashes in the code below are replaced by ellipsis: <br><br><pre> <code class="bash hljs">sha1_check(read_file (<span class="hljs-string"><span class="hljs-string">"system/app/Drive/Drive.apk"</span></span>), ...) || apply_patch_check(<span class="hljs-string"><span class="hljs-string">"/system/app/Drive.apk"</span></span>, ...) || abort(<span class="hljs-string"><span class="hljs-string">"\"/system/app/Drive.apk\" has unexpected contents."</span></span>); sha1_check(read_file(<span class="hljs-string"><span class="hljs-string">"system/app/Drive/lib/arm/libdocsimageutils.so"</span></span>), ...) || apply_patch_check(<span class="hljs-string"><span class="hljs-string">"/system/lib/libdocsimageutils.so"</span></span>, ...) || abort (<span class="hljs-string"><span class="hljs-string">"\"/system/lib/libdocsimageutils.so\" has unexpected contents."</span></span>);</code> </pre><br>  For example, only two checks are shown.  In fact, all files that are to be replaced or modified by the patch are checked.  The code shows that the update will generate an error if, for example, the file /system/app/Drive.apk has been changed or deleted.  At the end of the check block, the script checks the kernel, the available space in / system and radio: <br><br><pre> <code class="bash hljs">apply_patch_check(<span class="hljs-string"><span class="hljs-string">"EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:8908800:..."</span></span>) || abort(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); apply_patch_space(23999236) || abort(<span class="hljs-string"><span class="hljs-string">"Not enough free space on /system to apply patches."</span></span>); apply_patch_check(<span class="hljs-string"><span class="hljs-string">"EMMC:/dev/block/platform/msm_sdcc.1/by-name/modem:46499328:..."</span></span>) || abort(<span class="hljs-string"><span class="hljs-string">"..."</span></span>);</code> </pre><br>  That is, this update will not arise if there is a custom core or a radio modification.  The next step is to delete old files from the device before replacing them with new ones and deleting files that are not needed on the new firmware: <br><br><pre> <code class="bash hljs">delete(<span class="hljs-string"><span class="hljs-string">"/system/app/BasicDreams/"</span></span>, <span class="hljs-string"><span class="hljs-string">"/system/app/BasicDreams/arm/"</span></span>, ...);</code> </pre><br>  Then all the necessary files are patched with a preliminary check of the SHA-1 hash.  Patching is performed using the apply_patch () function, which accepts file names for patching and several hashes: the original hash, patch hash and result hash.  The final argument is the name of the file with the patch.  As before, all the hashes in the code below are reduced to a dot: <br><br><pre> <code class="bash hljs">sha1_check(read_file(<span class="hljs-string"><span class="hljs-string">"system/app/Drive/Drive.apk"</span></span>), ...) || apply_patch(<span class="hljs-string"><span class="hljs-string">"/system/app/Drive.apk"</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>, ..., package_extract_file(<span class="hljs-string"><span class="hljs-string">"patch/system/app/Drive.apk.p"</span></span>));</code> </pre><br>  The latest patches are the kernel and RAM disk: <br><br><pre> <code class="bash hljs">apply_patch(<span class="hljs-string"><span class="hljs-string">"EMMC:/dev/block/platform/msm_sdcc.1/by-name/boot:..., package_extract_file("</span></span>patch/boot.img.p<span class="hljs-string"><span class="hljs-string">"));</span></span></code> </pre><br>  The next block transfers to the device files that are not under the patch and must be replaced entirely.  Some of them then move: <br><br><pre> <code class="bash hljs">package_extract_dir(<span class="hljs-string"><span class="hljs-string">"system"</span></span>, <span class="hljs-string"><span class="hljs-string">"/system"</span></span>); rename(<span class="hljs-string"><span class="hljs-string">"system/app/KoreanIME.apk"</span></span>, <span class="hljs-string"><span class="hljs-string">"system/app/KoreanIME/KoreanIME.apk"</span></span>); rename(<span class="hljs-string"><span class="hljs-string">"system/framework/wm.odex"</span></span>, <span class="hljs-string"><span class="hljs-string">"system/framework/arm/wm.odex"</span></span>); ...</code> </pre><br>  Unnecessary files are deleted, symlinks, access rights and flags are placed (here the access rights and flags are replaced with ellipsis): <br><br><pre> <code class="bash hljs">delete(<span class="hljs-string"><span class="hljs-string">"/system/etc/firmware/wcd9320/wcd9320_mbhc.bin"</span></span>, ...); symlink(<span class="hljs-string"><span class="hljs-string">"/data/misc/audio/mbhc.bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"/system/etc/firmware/wcd9320/wcd9320_mbhc.bin"</span></span>); symlink(<span class="hljs-string"><span class="hljs-string">"/data/misc/audio/wcd9320_anc.bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"/system/etc/firmware/wcd9320/wcd9320_anc.bin"</span></span>); ... set_metadata_recursive(<span class="hljs-string"><span class="hljs-string">"/system/bin"</span></span>, ...); set_metadata(<span class="hljs-string"><span class="hljs-string">"/system/bin/app_process32"</span></span>, ...);</code> </pre><br>  The bootloader and related sections are stitched: <br><br><pre> <code class="bash hljs">package_extract_file(<span class="hljs-string"><span class="hljs-string">"bootloader-flag.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/misc"</span></span>); package_extract_file(<span class="hljs-string"><span class="hljs-string">"bootloader.aboot.img"</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/aboot"</span></span>); package_extract_file(<span class="hljs-string"><span class="hljs-string">"bootloader.rpm.img"</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/rpm"</span></span>); ...</code> </pre><br>  Patches radio / modem: <br><br><pre> <code class="bash hljs">apply_patch(<span class="hljs-string"><span class="hljs-string">"EMMC:/dev/block/platform/msm_sdcc.1/by-name/modem:..., package_extract_file("</span></span>radio.img.p<span class="hljs-string"><span class="hljs-string">"));</span></span></code> </pre><br>  The latest change is build.prop, which is recorded including the new firmware version.  This is done so that when an error occurs at the very last stage, when almost all files have been transferred, interrupt the update and save the current firmware version number in a file on the device.  Then, when you click the Check for Update button, you can run it again. <br><br><pre> <code class="bash hljs">apply_patch(<span class="hljs-string"><span class="hljs-string">"/system/build.prop"</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>, ..., package_extract_file(<span class="hljs-string"><span class="hljs-string">"patch/system/build.prop.p"</span></span>)); set_metadata(<span class="hljs-string"><span class="hljs-string">"/system/build.prop"</span></span>, ...);</code> </pre><br>  At the end of the script, the / system partition is unmounted, and verification of the application update starts, the SHA-1 hash of the new files is checked and / system is unmounted: <br><br><pre> <code class="bash hljs">unmount(<span class="hljs-string"><span class="hljs-string">"/system"</span></span>); mount(<span class="hljs-string"><span class="hljs-string">"ext4"</span></span>, <span class="hljs-string"><span class="hljs-string">"EMMC"</span></span>, <span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/system"</span></span>, <span class="hljs-string"><span class="hljs-string">"/system"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); assert(sha1_check(read_file(<span class="hljs-string"><span class="hljs-string">"/system/app/CalendarGooglePrebuilt/CalendarGooglePrebuilt.apk"</span></span>), ...)); assert(sha1_check(read_file(<span class="hljs-string"><span class="hljs-string">"/system/app/CaptivePortalLogin/CaptivePortalLogin.apk"</span></span>), ...)); ... unmount(<span class="hljs-string"><span class="hljs-string">"/system"</span></span>);</code> </pre><br>  After that, the device is rebooted into a new system. <br><br><img src="https://habrastorage.org/files/9b2/9ce/d31/9b29ced319e84d768f2f67b65d8b4abf.jpg"><br>  Updater script as it is <br><br><blockquote><h4>  Custom recovery </h4><br>  Until recently, it was possible to flash the OTA update archive in most cases (if there was no recovery check to replace it) from the custom recovery by simply uploading the file to the device and selecting install zip.  But starting with the script for update 5.0, the script has changed.  Previous versions checked the /system/build.prop file: <br><br><pre> <code class="bash hljs">file_getprop(<span class="hljs-string"><span class="hljs-string">"/system/build.prop"</span></span>, <span class="hljs-string"><span class="hljs-string">"ro.build.fingerprint"</span></span>)</code> </pre><br>  Current scripts check not the file, but the value of the system variable directly, requesting it from recovery: <br><br><pre> <code class="bash hljs">getprop(<span class="hljs-string"><span class="hljs-string">"ro.build.fingerprint"</span></span>)</code> </pre><br>  And if you disassemble custom recovery (for example TWRP version 2.8.0.0), then you can see the following lines: <br><br><pre> <code class="bash hljs">ro.build.description=omni_hammerhead-eng 4.4.4 KTU84P eng.dees_troy.20140910.125240 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-keys ro.build.fingerprint=Android/omni_hammerhead/hammerhead:4.4.4/KTU84P/eng.dees_troy.20140910.125240:eng/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-keys</code> </pre><br>  Version TWRP 2.8.6.1 has the following lines in the code (pay attention to the word omni in the second line, the developer of TWRP with the nickname Dees Troy is also one of the active OmniROM developers): <br><br><pre> <code class="bash hljs">ro.build.id=LRX22G ro.build.display.id=omni_hammerhead-eng 5.0.2 LRX22G eng.dees_troy.20150403.145211 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-keys ro.build.version.incremental=eng.dees_troy.20150403.145211</code> </pre><br>  And the latest versions of CWM Touch and Philz are signed like this: <br><br><pre> <code class="bash hljs">ro.build.description=hammerhead-user 4.4 KRT16M 893803 release-keys ro.build.fingerprint=google/hammerhead/hammerhead:4.4/KRT16M/893803:user/release-keys</code> </pre><br>  It is these values ‚Äã‚Äãthat the script returns when checking, interrupting the update at the very beginning and giving an error about the non-compliance of the Android version on the device. <br><br><img src="https://habrastorage.org/files/316/ac7/ef9/316ac7ef9afb45a396ada7bb8795cce0.jpg"><br>  Here's the answer you get when trying to install update 5.0.2 on Nexus 7 from custom recovery </blockquote><br><h4>  Updates 4.4.3‚Äì4.4.4 </h4><br>  For comparison, you can bring the previous update from version KTU84M to KTU84P.  The update is small and weighs only 2.5 MB.  Mainly related to security enhancements.  If you open the archive, you can see that only a small number of system files and the radio are patched, respectively, the script and only checks them.  This update was normally installed with the root, the custom kernel and the working Xposed Framework, as this is not checked for any changes. <br><br><h4>  Update for Nexus 6 and Nexus 9 </h4><br>  The latest Google devices have a different script structure.  For these and (apparently) subsequent Nexus devices, Google has added a block-by-block generation function to the build script that forms the OTA update.  Such an update checks and updates not individual files, but blocks in the / system file system.  Further in the example ‚Äú66, ..., 524256‚Äù are the long lists of block addresses: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> range_sha1(<span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/system"</span></span>, <span class="hljs-string"><span class="hljs-string">"66,...,524256"</span></span>) == <span class="hljs-string"><span class="hljs-string">"..."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> block_image_update(<span class="hljs-string"><span class="hljs-string">"/dev/block/platform/msm_sdcc.1/by-name/system"</span></span>, package_extract_file(<span class="hljs-string"><span class="hljs-string">"system.transfer.list"</span></span>), <span class="hljs-string"><span class="hljs-string">"system.new.dat"</span></span>, <span class="hljs-string"><span class="hljs-string">"system.patch.dat"</span></span>);</code> </pre><br>  This allowed Google engineers to significantly simplify and speed up the use of the OTA update for the end devices, and the updater script itself now takes only 5 Kb.  But it turned into a headache for advanced users.  After all, now any changes in the system partition will cause a crash.  Including extra files.  Even the fact that the system is mounted as R / W will lead to a change in the hash of the superblock FS. <br><br><h4>  <b>Conclusion</b> </h4><br>  Summing up the article, we can draw the following conclusions: <br><br><ol><li>  Superuser rights do not in themselves affect the success of an update.  The changes that the user and programs make to the system, having these rights, affect.  Often these changes cannot be tracked and returned. </li><li>  Whether root and changes made to the system will affect a successful update depends every time on what exactly changes in the system during the update and what files the script checks.  If the system changed, unnecessary system applications were frozen / disconnected via Titanium Backup, kernels were changed, custom recovery, Xposed Framework, Lucky Patcher, freedom, franco.Kernel updater, dialer mods and all sorts of improvements for sound, other boot animation, system fonts and so on were set Further.  All this may affect the update. </li><li>  When modifying the system, always leave the original files for backup if you want to update via OTA.  Copy to the cloud, rename as you like.  You can make a Nandroid backup of the / system partition (read about the Nandroid in the previous issue). </li><li>  If you remember that you have changed in the system, you can almost always roll back.  Recovery always writes an error, what the update curses.  Googling the name of the file in the error, you can sometimes find which program changes it.  For example, / system / bin / thermal-engines-hh and /system/lib/power.msm8974.so replaces franco.Kernel updater and does not return it even when flashing the stock kernel and demolishing the application itself. </li><li>  For successful application of OTA, it is necessary to return the original files to the system.  The surest way is to flash the system.img, the stock kernel and recovery before installing the update (data and applications will not be lost). </li><li>  Well, the main conclusion.  If there is a root and many modifications - do not suffer, but immediately complete the full image of the new firmware by deleting the -w key in flash-all.bat to save the data.  Starting with the upgrade to version 5.0, there remains a very small chance to deceive the script.  Yes, and the next update may have a ‚Äúblock‚Äù structure, which implies the presence of only a full flow for use. </li></ol><br><blockquote><h4>  A couple of words from the editor </h4><br>  Until recently, OTA-updates in custom firmware (CyanogenMod, Paranoid) always came in the form of a zip with the full firmware version and it was absolutely unimportant what changes were made to the system before.  The firmware has always been reinstalled (preserving user data and gapps, of course), but in CyanogenMod 11 there was an incremental update feature, but much simpler than Google‚Äôs.  The update simply checks the integrity of the firmware and replaces those files that have changed from the previous version (usually the nightly build), without any patches.  Moreover, if you miss one of the updates, the next one in the old manner will come in the form of a full update.  Simple and convenient. <br><br>  A more interesting method is used in OmniROM.  It uses binary patches to update, but not at all the way Google does.  The first OTA update is always downloaded completely, after which it is saved on the memory card, stitched, but not deleted from the card.  The next OTA-update already comes in the form of a single binary patch, after which the patch is superimposed on the update saved last time on the memory card and it is already being stitched.  The highlight of this method is that the patch is not superimposed on the system, but on the file with the last update and the smartphone is flashed from zero every time (but with preservation of data and settings).  Almost perfect method - traffic is saved, and you don‚Äôt need to worry about conflicts with the modified system. <br><br><img src="https://habrastorage.org/files/12c/8b6/cbb/12c8b6cbbada4e66ad2a3186029fa2f9.png"><br>  Update Installation Screen in CyanogenMod 12 </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/153/c18/f7b153c18e47620075b1db37ae011fce.jpg" alt="image"><br><br>  <i>First published in Hacker Magazine # 196.</i> <i><br></i>  <i>Posted by: Dmitry ¬´BRADA¬ª Podkopaev</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/260379/">https://habr.com/ru/post/260379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260363/index.html">Interactive robot to control the smart home. Electronics Overview</a></li>
<li><a href="../26037/index.html">Cross Domain Authorization</a></li>
<li><a href="../260371/index.html">Settings of search engines, ‚Äúgoodbye, vyglaglazny color‚Äù and other improvements in Vivaldi 1.0.201.2</a></li>
<li><a href="../260373/index.html">Logging anything in Perl</a></li>
<li><a href="../260375/index.html">HostTrecker API: New Service Features</a></li>
<li><a href="../26038/index.html">Battery Steve Ballmer</a></li>
<li><a href="../260381/index.html">Report on ReactOS at RIF + OSDAY 2015 in Innopolis</a></li>
<li><a href="../260383/index.html">LastPass hacked, change your master password</a></li>
<li><a href="../260387/index.html">Complete CROC cloud translation to Violin Memory's All-Flash data storage.</a></li>
<li><a href="../260389/index.html">"Ajar data" / Notes on the traces of the open data board on June 15</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>