<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>User Attributes in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever thought about what happens when you put a dot in python? What does str (‚Äú\ u002E‚Äù) hide behind? What secrets does he keep? If without my...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>User Attributes in Python</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/199/d36/889/199d3688954a87fd7f1b8ee5a288a0b1.jpg">  Have you ever thought about what happens when you put a dot in python?  What does <i>str (‚Äú\ u002E‚Äù)</i> hide behind?  What secrets does he keep?  If without mysticism, do you know how to find and set custom attribute values ‚Äã‚Äãin python?  Would you like to know?  Then ... welcome! <a name="habracut"></a><br>  To make the time spent reading easy, pleasant, and useful, it would be nice to know a few basic concepts of the language.  In particular, the understanding of <em>type</em> and <em>object</em> will be extremely useful, as well as knowledge of several examples of both entities.  You can read about them, including <a href="http://www.cafepy.com/article/python_types_and_objects/">here</a> . <br>  A little bit about the terminology I use before we get down to what we have gathered for: <br><ul><li>  <strong>An object</strong> is any entity in python (function, number, string ... word, everything). </li><li>  <strong>A class</strong> is an object whose type is <em>type</em> (the type can be seen in the <strong>__class__</strong> attribute). </li><li>  <strong>An instance of</strong> some class <em>A</em> is an object that has a reference to class <em>A</em> in the <strong>__class__</strong> attribute. </li></ul><br>  Oh yes, all the examples in the article are written in <strong>python3</strong> !  This should definitely be considered. <br>  If none of the above could temper your desire to find out what happens next, let's get started! <br><br><h4>  __dict__ </h4><br>  Attributes of an object can be divided into two groups: certain python-ohms (such as <em>__class__</em> , <em>__bases__</em> ) and user-defined, I am going to tell about them.  <em>__dict__</em> according to this classification, refers to the ‚Äúsystem‚Äù (defined by python) attributes.  Its task is to store user attributes.  It is a dictionary, in which the key is the <em>name of the attribute</em> , the value, respectively, of the <em>value of the</em> <em>attribute</em> . <br>  To find an attribute of an object <em>o</em> , python scans: <ol><li>  The object itself ( <em>o .__ dict__</em> and its system attributes). </li><li>  Object Class ( <em>o .__ class __.__ dict__</em> ).  Only <em>__dict__</em> class, not system attributes. </li><li>  Classes from which the class of the object is set ( <em>o .__ class __.__ bases __.__ dict__</em> ). </li></ol>  Thus, using <em>__dict__,</em> an attribute can be defined both for a specific instance and for a class (that is, for all objects that are instances of a given class). <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StuffHolder</span></span></span><span class="hljs-class">:</span></span> stuff = <span class="hljs-string"><span class="hljs-string">"class stuff"</span></span> a = StuffHolder() b = StuffHolder() a.stuff <span class="hljs-comment"><span class="hljs-comment"># "class stuff" b.stuff # "class stuff" b.b_stuff = "b stuff" b.b_stuff # "b stuff" a.b_stuff # AttributeError</span></span></code> </pre> <br>  The example describes the class <em>StuffHolder</em> with one <em>stuff</em> attribute, which is inherited by both of its instances.  Adding <em>b</em> attribute <em>b_stuff to</em> object <em>b</em> does not affect <em>a</em> . <br>  Let's look at <em>__dict__</em> all the actors: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="python hljs">StuffHolder.__dict__ <span class="hljs-comment"><span class="hljs-comment"># {... 'stuff': 'class stuff' ...} a.__dict__ # {} b.__dict__ # {'b_stuff': 'b stuff'} a.__class__ # &lt;class '__main__.StuffHolder'&gt; b.__class__ # &lt;class '__main__.StuffHolder'&gt;</span></span></code> </pre>  <sub>(The class StuffHolder in <em>__dict__</em> stores an object of class dict_proxy with a bunch of different junk that you don‚Äôt need to pay attention to yet).</sub> <br><br>  Neither <em>a</em> nor <em>b</em> in <em>__dict__</em> has the <em>stuff</em> attribute, having not found it there, the search engine looks for it in the <em>__dict__</em> class ( <em>StuffHolder</em> ), successfully finds and returns the value assigned to it in the class.  The class reference is stored in the <em>__class__</em> attribute of the object. <br>  An attribute search occurs at run time, so even after creating instances, all changes to the <em>__dict__</em> class will be reflected in them: <br><br><pre> <code class="python hljs">a.new_stuff <span class="hljs-comment"><span class="hljs-comment"># AttributeError b.new_stuff # AttributeError StuffHolder.new_stuff = "new" StuffHolder.__dict__ # {... 'stuff': 'class stuff', 'new_stuff': 'new'...} a.new_stuff # "new" b.new_stuff # "new"</span></span></code> </pre><br>  In the case of assigning a value to an instance attribute, only the <em>__dict__</em> instance is <em>changed</em> , that is, the value in the <em>__dict__</em> class remains unchanged (if the value of the class attribute is not a data descriptor): <br><br><pre> <code class="python hljs">StuffHolder.__dict__ <span class="hljs-comment"><span class="hljs-comment"># {... 'stuff': 'class stuff' ...} c = StuffHolder() c.__dict__ # {} c.stuff = "more c stuff" c.__dict__ # {'stuff': 'more c stuff'} StuffHolder.__dict__ # {... 'stuff': 'class stuff' ...}</span></span></code> </pre><br>  If the attribute names in the class and the instance are the same, the interpreter will look up the instance when searching for the value (in case the value of the class attribute is not a data descriptor): <br><br><pre> <code class="python hljs">StuffHolder.__dict__ <span class="hljs-comment"><span class="hljs-comment"># {... 'stuff': 'class stuff' ...} d = StuffHolder() d.stuff # "class stuff" d.stuff = "d stuff" d.stuff # "d stuff"</span></span></code> </pre><br>  By and large this is all that can be said about <em>__dict__</em> .  This is a user-defined attribute store.  Search in it is made at run time and the search takes into account the <em>__dict__</em> object class and base classes.  It is also important to know that there are several ways to override this behavior.  One of them is a great and mighty Handle! <br><br><h4>  Descriptors </h4><br>  With simple types as attribute values, everything is clear.  Let's see how the function behaves in the same conditions: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncHolder</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> fh = FuncHolder() FuncHolder.func <span class="hljs-comment"><span class="hljs-comment"># &lt;function func at 0x8f806ac&gt; FuncHolder.__dict__ # {...'func': &lt;function func at 0x8f806ac&gt;...} fh.func # &lt;bound method FuncHolder.func of &lt;__main__.FuncHolder object at 0x900f08c&gt;&gt;</span></span></code> </pre><br>  WTF !?  You ask ... maybe.  I would ask.  How does the function in this case differ from what we have already seen?  The answer is simple: using the <em>__get__</em> method. <br><br><pre> <code class="python hljs">FuncHolder.func.__class__.__get__ <span class="hljs-comment"><span class="hljs-comment"># &lt;slot wrapper '__get__' of 'function' objects&gt;</span></span></code> </pre><br>  This method overrides the mechanism for obtaining the value of the <em>func</em> attribute of the <em>fh</em> instance, and the object that implements this method is untranslatablely called a <strong>non-data descriptor</strong> . <br><br>  From <a href="http://docs.python.org/howto/descriptor.html">howto</a> : <br><blockquote>  A descriptor is an object that is accessed by an attribute redefined by methods in a <em>protocol descriptor</em> : <br><pre> descr .__ get __ (self, obj, type = None) -&gt; value (overrides the way to get the attribute value)
 descr .__ set __ (self, obj, value) -&gt; None (overrides the method of assigning a value to an attribute)
 descr .__ delete __ (self, obj) -&gt; None (overrides the way the attribute is deleted)
</pre></blockquote><br>  Descriptors are of two types: <br><ol><li>  Data Descriptor (data descriptor) - an object that implements the <em>__get __ ()</em> and <em>__set __ ()</em> method </li><li>  Non-data Descriptor (no data descriptor?) - an object that implements the <em>__get __ ()</em> method </li></ol>  They differ in their behavior in relation to the entries in the <em>__ict__</em> instance.  If <em>__dict__</em> has an entry with the same name as the data descriptor, the descriptor has an advantage.  If the record name is the same as the ‚Äúno data descriptor‚Äù name, the record priority in <em>__dict__ is</em> higher. <br><br><h5>  Data descriptors </h5><br>  Consider the data descriptor more closely: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataDesc</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, cls)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Trying to access from {0} class {1}"</span></span>.format(obj, cls)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, val)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Trying to set {0} for {1}"</span></span>.format(val, obj)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__delete__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Trying to delete from {0}"</span></span>.format(obj)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataHolder</span></span></span><span class="hljs-class">:</span></span> data = DataDesc() d = DataHolder() DataHolder.data <span class="hljs-comment"><span class="hljs-comment"># Trying to access from None class &lt;class '__main__.DataHolder'&gt; d.data # Trying to access from &lt;__main__.DataHolder object at ...&gt; class &lt;class '__main__.DataHolder'&gt; d.data = 1 # Trying to set 1 for &lt;__main__.DataHolder object at ...&gt; del(d.data) # Trying to delete from &lt;__main__.DataHolder object at ...&gt;</span></span></code> </pre><br>  It should be noted that the call to <em>DataHolder.data</em> passes the <em>__get__</em> <em>None</em> method instead of an instance of the class. <br>  Let us check the statement that the date of the descriptors has an advantage over the entries in the <em>__dict__</em> instance: <br><br><pre> <code class="python hljs">d.__dict__[<span class="hljs-string"><span class="hljs-string">"data"</span></span>] = <span class="hljs-string"><span class="hljs-string">"override!"</span></span> d.__dict__ <span class="hljs-comment"><span class="hljs-comment"># {'data': 'override!'} d.data # Trying to access from &lt;__main__.DataHolder object at ...&gt; class &lt;class '__main__.DataHolder'&gt;</span></span></code> </pre><br>  <em>Indeed</em> , an entry in <em>__dict__ of an</em> instance is ignored if there is an <em>entry</em> in the <em>__dict__</em> class of the instance (or its base class) with the same name and value - a data descriptor. <br><br>  Another important point.  If you change the value of an attribute with a descriptor through a class, no descriptor methods will be called, the value will change in the <em>__dict__</em> class as if it were a regular attribute: <br><br><pre> <code class="python hljs">DataHolder.__dict__ <span class="hljs-comment"><span class="hljs-comment"># {...'data': &lt;__main__.DataDesc object at ...&gt;...} DataHolder.data = "kick descriptor out" DataHolder.__dict__ # {...'data': 'kick descriptor out'...} DataHolder.data # "kick descriptor out"</span></span></code> </pre><br><br><h5>  No data descriptors </h5><br>  Example of a data descriptor: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonDataDesc</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, cls)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Trying to access from {0} class {1}"</span></span>.format(obj, cls)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonDataHolder</span></span></span><span class="hljs-class">:</span></span> non_data = NonDataDesc() n = NonDataHolder() NonDataHolder.non_data <span class="hljs-comment"><span class="hljs-comment"># Trying to access from None class &lt;class '__main__.NonDataHolder'&gt; n.non_data # Trying to access from &lt;__main__.NonDataHolder object at ...&gt; class &lt;class '__main__.NonDataHolder'&gt; n.non_data = 1 n.non_data # 1 n.__dict__ # {'non_data': 1}</span></span></code> </pre><br>  Its behavior is slightly different from what the date handle got up to.  When trying to assign a value to the <em>non_data</em> attribute, it was recorded in the <em>__dict__</em> instance, thus hiding the descriptor that is stored in the <em>__dict__</em> class. <br><br><h5>  Examples of using </h5><br>  Descriptors are a powerful tool that allows you to control access to the attributes of a class instance.  One example of their use is functions, when called via an instance, they become methods (see the example above).  Also a common way to use descriptors is to create a <em>property</em> .  By property, I mean a certain value characterizing the state of an object, access to which is controlled using special methods (getters, setters).  Creating a property is simple using a handle: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Descriptor</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__get__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, type)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"getter used"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__set__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj, val)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"setter used"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__delete__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, obj)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"deleter used"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class">:</span></span> prop = Descriptor()</code> </pre><br>  Or you can use the built-in <strong>property</strong> class, it is a data descriptor.  The code presented above can be rewritten as follows: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"getter used"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_setter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"setter used"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_deleter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"deleter used"</span></span>) prop = property(_getter, _setter, _deleter, <span class="hljs-string"><span class="hljs-string">"doc string"</span></span>)</code> </pre><br>  In both cases, we get the same behavior: <br><br><pre> <code class="python hljs">m = MyClass() m.prop <span class="hljs-comment"><span class="hljs-comment"># getter used m.prop = 1 # setter used del(m.prop) # deleter used</span></span></code> </pre><br>  It is important to know that a <strong>property is</strong> always a data descriptor.  If one of the functions (getter, setter or deliter) is not transferred to its constructor, AttributeError will be thrown out if an attempt is made to perform an appropriate action on the attribute. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySecondClass</span></span></span><span class="hljs-class">:</span></span> prop = property() m2 = MySecondClass() m2.prop <span class="hljs-comment"><span class="hljs-comment"># AttributeError: unreadable attribute m2.prop = 1 # AttributeError: can't set attribute del(m2) # AttributeError: can't delete attribute</span></span></code> </pre><br>  The built-in descriptors also include: <br><ul><li>  <strong>staticmethod</strong> is the same as a function outside the class; it <strong>does not pass an</strong> instance as the first argument. </li><li>  <strong>The classmethod</strong> is the same as the class method, only the instance class is passed as the first argument. </li></ul><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAndClassMethodHolder</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"_method called with "</span></span>, args) static = staticmethod(_method) cls = classmethod(_method) s = StaticAndClassMethodHolder() s._method() <span class="hljs-comment"><span class="hljs-comment"># _method called with (&lt;__main__.StaticAndClassMethodHolder object at ...&gt;,) s.static() # _method called with () s.cls() # _method called with (&lt;class '__main__.StaticAndClassMethodHolder'&gt;,)</span></span></code> </pre><br><br><h4>  __getattr __ (), __setattr __ (), __delattr __ () and __getatttribute __ () </h4><br>  If you need to define the behavior of an object <strong>as an attribute</strong> , you should use descriptors (for example, <strong>property</strong> ).  The same is true for a family of objects (for example, <strong>functions</strong> ).  Another way to influence access to attributes is: <em>__getattr __ ()</em> , <em>__setattr __ ()</em> , <em>__delattr __ ()</em> and <em>__getatttribute __ () methods</em> .  Unlike descriptors, they should be defined for the object <strong>containing the attributes</strong> and they are called when accessing <strong>any</strong> attribute of this object. <br><br>  <em>__getattr __ (self, name)</em> will be called if the requested attribute is not found by the usual mechanism (in <em>__dict__ of an</em> instance, class, etc.): <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SmartyPants</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getattr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, attr)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"Yep, I know"</span></span>, attr) tellme = <span class="hljs-string"><span class="hljs-string">"It's a secret"</span></span> smarty = SmartyPants() smarty.name = <span class="hljs-string"><span class="hljs-string">"Smartinius Smart"</span></span> smarty.quicksort <span class="hljs-comment"><span class="hljs-comment"># Yep, I know quicksort smarty.python # Yep, I know python smarty.tellme # "It's a secret" smarty.name # "Smartinius Smart"</span></span></code> </pre><br>  <em>__getattribute __ (self, name)</em> will be called when trying to get the value of an attribute.  If this method is redefined, the standard attribute value search mechanism will not be used.  It should be borne in mind that calling special methods (for example, <em>__len __ ()</em> , <em>__str __ ()</em> ) through built-in functions or an implicit call using language syntax bypasses <em>__getattribute __ ()</em> . <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optimist</span></span></span><span class="hljs-class">:</span></span> attr = <span class="hljs-string"><span class="hljs-string">"class attribute"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getattribute__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"{0} is great!"</span></span>.format(name)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__len__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"__len__ is special"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> o = Optimist() o.instance_attr = <span class="hljs-string"><span class="hljs-string">"instance"</span></span> o.attr <span class="hljs-comment"><span class="hljs-comment"># attr is great! o.dark_beer # dark_beer is great! o.instance_attr # instance_attr is great! o.__len__ # __len__ is great! len(o) # __len__ is special\n 0</span></span></code> </pre><br>  <em>__setattr __ (self, name, value)</em> will be called when trying to set the value of an instance attribute.  Similar to <em>__getattribute __ ()</em> , if this method is redefined, the standard value setting mechanism will not be used: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NoSetters</span></span></span><span class="hljs-class">:</span></span> attr = <span class="hljs-string"><span class="hljs-string">"class attribute"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__setattr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, val)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"not setting {0}={1}"</span></span>.format(name,val)) no_setters = NoSetters() no_setters.a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># not setting a=1 no_setters.attr = 1 # not setting attr=1 no_setters.__dict__ # {} no_setters.attr # "class attribute" no_setters.a # AttributeError</span></span></code> </pre><br>  <em>__delattr __ (self, name)</em> is similar to <em>__setattr __ ()</em> , but is used when deleting an attribute. <br><br>  When overriding <em>__getattribute __ ()</em> , <em>__setattr __ ()</em> and <em>__delattr __ ()</em> it should be borne in mind that the standard way of accessing attributes can be called via <strong>object</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GentleGuy</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__getattribute__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> name.endswith(<span class="hljs-string"><span class="hljs-string">"_please"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object.__getattribute__(self, name.replace(<span class="hljs-string"><span class="hljs-string">"_please"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> AttributeError(<span class="hljs-string"><span class="hljs-string">"And the magic word!?"</span></span>) gentle = GentleGuy() gentle.coffee = <span class="hljs-string"><span class="hljs-string">"some coffee"</span></span> gentle.coffee <span class="hljs-comment"><span class="hljs-comment"># AttributeError gentle.coffee_please # "some coffee"</span></span></code> </pre><br><br><h4>  Salt </h4><br>  So, to get the value of the attribute <strong>attrname of</strong> instance <strong>a</strong> in python: <br><ol><li>  If <em>a .__ class __.__ getattribute __ ()</em> method is defined, then it is called and the resulting value is returned. </li><li>  If <strong>attrname</strong> is a special (python-defined) attribute, such as <em>__class__</em> or <em>__doc__</em> , its value is returned. </li><li>  It is checked <em>a .__ class __.__ dict__</em> for the presence of an entry with <strong>attrname</strong> .  If it exists and the value is a data descriptor, the result of calling the <em>__get __ ()</em> method of the descriptor is returned.  Also all base classes are checked. </li><li>  If <em>a</em> record with the name <strong>attrname</strong> exists in <em>a .__ dict__</em> , the value of that record is returned.  If <strong>a</strong> is a class, then the attribute is also searched among its base classes and, if there is <strong>a</strong> data descriptor there or in <em>__dict__</em> - the result of the descriptor <em>__get __ ()</em> is returned. </li><li>  It is checked <em>a .__ class __.__ dict__</em> , if there is an entry with <strong>attrname</strong> in it and this is ‚Äúno data descriptor‚Äù, the result is <em>__get __ ()</em> descriptor, if the entry exists and there is no descriptor, the value of the entry is returned.  Base classes are also searched. </li><li>  If there is <em>a .__ class __.__ getattr __ ()</em> method, it is called and its result is returned.  If there is no such method, <strong>AttributeError</strong> is thrown <strong>away</strong> . </li></ol><br>  To set the <strong>value of</strong> the <strong>attrname</strong> attribute of instance <strong>a</strong> : <br><ol><li>  If there is <em>a .__ class __.__ setattr __ ()</em> method, it is invoked. </li><li>  It is checked <em>a .__ class __.__ dict__</em> , if it has an entry with <strong>attrname</strong> and it is a data descriptor, the <em>__set __ ()</em> method of the descriptor is called.  Base classes are also checked. </li><li>  In <em>a .__ dict__</em> , a <em>value</em> entry is added with the <strong>attrname</strong> key. </li></ol><br><br><h4>  __slots__ </h4><br>  As <a href="http://www.python.org/~guido/">Guido</a> writes in his <a href="http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html">python history</a> about how the new-style classes were invented: <br><blockquote>  ... I was afraid that changes in the class system would have a bad effect on performance.  In particular, in order for the data descriptors to work correctly, all manipulations of the object's attributes began with checking the <em>__dict__</em> class that this attribute is a data descriptor ... <br></blockquote><br>  In case users get disappointed with the performance degradation, caring python developers come up with <em>__slots__</em> . <br>  The presence of <em>__slots__</em> limits the possible names of attributes of an object to those specified there.  Also, since all attribute names are now known in advance, removes the need to create <em>__dict__</em> instances. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Slotter</span></span></span><span class="hljs-class">:</span></span> __slots__ = [<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>] s = Slotter() s.__dict__ <span class="hljs-comment"><span class="hljs-comment"># AttributeError sc = 1 # AttributeError sa = 1 sa # 1 sb = 1 sb # 1 dir(s) # [ ... 'a', 'b' ... ]</span></span></code> </pre><br>  It turned out that Guido's fears were not justified, but by the time it became clear, it was already too late.  In addition, using <em>__slots__</em> can actually increase performance, especially by reducing the amount of memory used when creating many small objects. <br><br><h4>  Conclusion </h4><br>  Attribute access in python can be controlled in a huge number of ways.  Each of them solves his problem, and together they fit almost every conceivable scenario of using an object.  These mechanisms are the basis of language flexibility, along with multiple inheritance, metaclasses, and other goodies.  It took me some time to figure out, understand and, most importantly, accept these many options for the work of attributes.  At first glance, it seemed slightly redundant and not particularly logical, but given that it is rarely useful in daily programming, it is nice to have such powerful tools in your arsenal. <br>  I hope that this article also clarified a couple of moments to you that hands did not reach to understand.  And now, with fire in the eyes and confidence in the Point, you will write a huge amount of the cleanest, readable and resistant to changes in the requirements of the code!  Well, or a comment. <br><br>  Thank you for your time. <br><br><h4>  Links </h4><ol><li>  Shalabh Chaturvedi.  <a href="http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.html">Python Attributes and Methods</a> </li><li>  Guido Van Rossum.  <a href="http://python-history.blogspot.com/2010/06/inside-story-on-new-style-classes.html">The Inside Story on New-Style Classes</a> </li><li>  <a href="http://docs.python.org/py3k/">Python documentation</a> </li></ol>  UPD: Useful link from user <a href="http://habrahabr.ru/users/leron/" class="user_link">leron</a> : <a href="http://docs.python.org/py3k/reference/datamodel.html">Python Data Model</a> </div><p>Source: <a href="https://habr.com/ru/post/137415/">https://habr.com/ru/post/137415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137410/index.html">How do you usually unpack the archive through the context menu</a></li>
<li><a href="../137411/index.html">Without knowing the ford, do not go into the water. Part two</a></li>
<li><a href="../137412/index.html">Creating animated tooltips with CSS3</a></li>
<li><a href="../137413/index.html">It is finished! Website iCloud "spoke" in Russian</a></li>
<li><a href="../137414/index.html">Integration of the physics engine Box2D into the UIKit application for iOS</a></li>
<li><a href="../137416/index.html">Anonymization and de-anonymization on the Internet</a></li>
<li><a href="../137417/index.html">Because of the new law, popular torrent trackers of Kazakhstan have stopped working</a></li>
<li><a href="../137419/index.html">Vulnerability in ISPSystem Billmanager</a></li>
<li><a href="../137420/index.html">Linux head-end computer - collect it yourself!</a></li>
<li><a href="../137421/index.html">Create transitions for pages using CSS3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>