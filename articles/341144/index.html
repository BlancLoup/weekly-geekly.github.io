<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What every C programmer should know about Undefined Behavior. Part 2/3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Part 2 
 Part 3 

 In the first part of our cycle, we discussed what undefined behavior is and how it allows C and C ++ compilers to generate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What every C programmer should know about Undefined Behavior. Part 2/3</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/341048/">Part 1</a> <br>  <b>Part 2</b> <br>  <a href="https://habrahabr.ru/post/341154/">Part 3</a> <br><br>  In the first part of our cycle, we discussed what undefined behavior is and how it allows C and C ++ compilers to generate more high-performance applications than ‚Äúsafe‚Äù languages.  In this post we will discuss what ‚Äúunsafe‚Äù C really is, explaining some completely unexpected effects caused by undefined behavior.  In the third part, we will discuss how ‚Äúfriendly‚Äù compilers can mitigate some of these effects, even if they are not required to do so. <br><br>  I like to call it ‚ÄúWhy undefined behavior often scares and terrifies C programmers.‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/ye/6c/kq/ye6ckqam7sn2kuhrp9tqg3-knzo.jpeg" alt="image"><br><a name="habracut"></a><br><h3>  Compiler Optimization Interaction Produces Unexpected Results </h3><br>  A modern optimizing compiler contains many optimizations that work in a certain order, sometimes repeated several times, and this order may change as the compiler evolves (that is, when new releases are released). <br><br>  Also, different compilers have significantly different optimizers.  Since the optimizations work as different stages of code conversion, various effects can occur when the preceding stages change the code. <br><br>  Consider this stupid example (simplified from the real bug example in the Linux kernel) to make it more specific: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains_null_check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dead = *P; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (P == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; *P = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br>  In this example, the code "explicitly" checks for a null pointer.  If the compiler starts the pass of deleting an unreachable code (‚ÄúDead Code Elimination‚Äù) before passing the deletion of redundant checks for null (‚ÄúRedundant Null Check Elimination‚Äù), then we will see that two code transformations will be performed: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains_null_check_after_DCE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//int dead = *P; // deleted by the optimizer. if (P == 0) return; *P = 4; }</span></span></code> </pre> <br>  and then: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains_null_check_after_DCE_and_RNCE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (P == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Null check not redundant, and is kept. return; *P = 4; }</span></span></code> </pre> <br>  However, the optimizer may be structured differently, and may run the RNCE before the DCE.  Then the following two transformations will be performed: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains_null_check_after_RNCE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dead = *P; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">// P was dereferenced by this point, so it can't be null return; *P = 4; }</span></span></code> </pre> <br>  and then the redundant code is removed: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains_null_check_after_RNCE_and_DCE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//int dead = *P; //if (false) // return; *P = 4; }</span></span></code> </pre><br>  For many programmers, removing a null check from a function would be very unexpected (and they will blame the compiler for the bug).  However, both options, "contains_null_check_after_DCE_and_RNCE", and "contains_null_check_after_RNCE_and_DCE", are perfectly true optimized form of "contains_null_check" in accordance with the standard, and both optimizations are important for improving the performance of various applications. <br><br>  Although this is a rather simple and contrived example, such things happen all the time with inline functions.  Inline functions open up many possibilities for future optimizations.  This means that if the optimizer decides to inline the function, other local optimizations will be made that change the behavior of the code.  This is absolutely correct, both from the point of view of the standard, and from the practical point of view, to increase productivity. <br><br><h3>  Undefined behavior and security should not mix </h3><br>  The family of C-like programming languages ‚Äã‚Äãis used for a wide range of critical security code, such as kernels, setuid daemons, web browsers, etc. This code works with ‚Äúhostile‚Äù input data and bugs in it can lead to any sort of security problems.  One of the best known advantages of C is that it is relatively easy to understand what is happening just by reading the code. <br><br>  However, indefinite behavior deprives the language of this property.  For example, most programmers will assume that ‚Äúcontains_null_check‚Äù in the example above performs a null check.  Although this example is not so scary (this code can break something, if it is passed null, which is relatively easy to detect when debugging) there are a large number of quite reasonable looking C code fragments that are in fact completely wrong.  This issue affects many projects (including the Linux Kernel, OpenSSL, glibc, etc.) and even forced CERT to publish a <a href="http://www.kb.cert.org/vuls/id/162289">notification about the</a> GCC <a href="http://www.kb.cert.org/vuls/id/162289">vulnerability</a> (although I personally believe that all widely used optimizing C compilers are vulnerable, not just GCC). <br><br>  Consider an example.  Imagine carefully written C code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Catch integer overflow. if (size &gt; size+1) abort(); ... // Error checking from this code elided. char *string = malloc(size+1); read(fd, string, size); string[size] = 0; do_something(string); free(string); }</span></span></code> </pre> <br>  This code performs a check to make sure that enough memory is allocated for reading from the file (as you need to add a terminating null), and exits if an integer overflow occurs.  However, in this example, the compiler can (according to the standard) remove the check.  This means that the compiler can turn the code into this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(size+<span class="hljs-number"><span class="hljs-number">1</span></span>); read(fd, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, size); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[size] = <span class="hljs-number"><span class="hljs-number">0</span></span>; do_something(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); }</code> </pre> <br>  When compilation occurs on a 64-bit platform, there is a possibility of a bug when ‚Äúsize‚Äù equals INT_MAX (perhaps, this is the size of the file on the disk).  Let's see how awful it is: when checking the code, nothing is detected, since checking the variable for overflow looks reasonable.  When testing the code, there are no problems, unless you specifically test this execution path.  It seems the code can be considered safe until someone decides to exploit the vulnerability.  This is a very unexpected and rather awful class of bugs.  Fortunately, just fix it: just use "size == INT_MAX" or something similar. <br><br>  It turns out that overflowing the whole is a security issue for many reasons.  Even if you use fully qualified integer arithmetic (either using -fwrapv or using unsigned integers), there remains a class of possible bugs related to the overflow of integers.  Fortunately, these bugs are noticeable in the code and well known to security auditors. <br><br><h3>  Debugging optimized code may become pointless. </h3><br>  Some people (for example, low-level embedded-programmers who like to watch the generated machine code) work with constantly enabled optimization.  Since the code often has bugs at the beginning of development, these people observe a disproportionate amount of unexpected optimizations that can lead to difficult-to-manage problems during program execution.  For example, accidentally skipping ‚Äúi = 0‚Äù in the example ‚Äúzero_array‚Äù in the example from the first article, we allow the compiler to completely remove the loop (turning zero_array into ‚Äúreturn;‚Äù) because this would be using an uninitialized variable. <br><br>  Another interesting case may occur when there is a global function pointer.  A simplified example looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*FP)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"hello\n"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FP = impl; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FP(); }</code> </pre> <br>  which clang optimizes in: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"hello\n"</span></span>); }</code> </pre> <br>  It can do this because the null pointer call is not defined, which allows us to assume that set () should be called before call ().  In this case, the developer forgot to call set (), the program does not fall on null dereferencing, and the code will break if someone else does the debug build. <br><br>  Such bugs are tracked: if you suspect something suspicious, try building with -O0, and the compiler will most likely not perform optimizations. <br><br>  "Working" code that uses undefined behavior can break if something changes in the compiler. <br><br>  We have considered many cases in which code that ‚Äúseems to be working‚Äù suddenly breaks down when a newer version of LLVM is used for compilation, or when an application is ported from GCC to LLVM.  Although LLVM itself can have one or two bugs, this most often happens due to the fact that hidden bugs appeared in the application due to the compiler.  This can happen in many different cases, here are two examples: <br><br>  1. An uninitialized variable that previously accepted a zero value by luck, and now is placed in another register that does not contain a zero.  This behavior often manifests itself with changes in the allocator registers. <br><br>  2. An array overflow on the stack overwrites the actual variables instead of the ‚Äúdead‚Äù ones.  This happens when the compiler reorders variables on the stack, or more aggressively packs variables with a non-overlapping lifetime into stack space. <br><br>  An important and frightening thing to discover is that almost <i>any</i> optimization based on unspecified behavior can lead to bugs at any time in the future.  Inline functions, loop expansion, and other optimizations will work better, and a significant part of them is done through secondary optimizations, as shown above. <br><br>  This makes me very sad, in part because the compiler is almost inevitably being blamed, and also because a huge amount of C-code is a time bomb waiting to explode.  And it's even worse because ... <br><br><h3>  There is no reliable way to ensure that a large code base does not contain UB </h3><br>  This is a very bad situation, because in fact there is no reliable way to determine that there is no UB in a large-scale application and that it will not break down in the future.  There are many useful tools that can help you find some bugs, but nothing gives you complete confidence that your code will not break in the future.  Let's look at some of the options, their strengths and weaknesses. <br><br>  1. Valgrind is a fantastic tool for finding all kinds of uninitialized variables and other memory bugs.  Valgrind is limited by the fact that it is rather slow, and can only search for bugs that already exist in the generated machine code (and cannot find what was removed by the optimizer), and does not know that the source code was written in C (and therefore, <a href="https://blog.regehr.org/archives/519">it cannot find the</a> bugs of the shift type by an amount larger than the size of the variable or overflow of the signed integer number). <br><br>  2. Clang has an experimental mode -fcatch-undefined-behavior, which inserts runtime checks to look for violations, such as going beyond the limits of the shift range, some simple errors exceeding the boundaries of arrays, etc.  These checks are limited, because they slow down the application, and can not help with the dereference of an arbitrary pointer (and Valgrind can), but can find other important bugs.  Clang also fully supports the -ftrapv flag (not to be confused with -fwrapv), with which you can catch bugs in runtime with overflow of signed integers (GCC also has such a flag, but in my experience it is very unreliable and buggy).  Here is a little demo -fcatch-undefined-behavior: <br><br><pre> <code class="cpp hljs">$ <span class="hljs-function"><span class="hljs-function">cat tc </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[<span class="hljs-number"><span class="hljs-number">2</span></span>]; x[i] = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x[i]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(<span class="hljs-number"><span class="hljs-number">2</span></span>); } $ clang tc $ ./a.out $ clang tc -fcatch-undefined-behavior $ ./a.out Illegal instruction</code> </pre> <br>  3. Compiler messages are good for finding some classes of bugs, such as uninitialized variables and simple integer overflows.  There are two main limitations: 1) there is no dynamic information about the code execution and 2) the analysis must be very fast, because any analysis increases the compilation time. <br><br>  4. The Clang static analyzer performs a much more in-depth analysis, trying to find bugs, including using UB, such as null pointer dereferencing. <br><br>  You can think of it as an enhanced analysis tool compared to compiler warnings, since it does not have time constraints, like ordinary warnings.  The main drawback of the static analyzer is that it: 1) does not have dynamic information about the program‚Äôs workflow and 2) is not integrated into the normal development process (although its integration with XCode 3.2 and later is fiction). <br><br>  5. The LLVM ‚ÄúKlee‚Äù subproject uses symbolic analysis to ‚Äútry every possible path‚Äù through the code to find bugs in the code and generate a test.  This is a great little project that is mainly limited by the fact that it is impractical to run on large applications. <br><br>  6. Although I have never tried it, the <a href="https://code.google.com/archive/p/c-semantics/">C-Semantics</a> tool from Chucky Ellison and Grigori Rosa is very interesting because it can find some classes of bugs (such as violations of the following points).  It is still in the state of a research prototype, but may be useful for finding bugs in (small and limited) programs.  I recommend reading <a href="https://blog.regehr.org/archives/523">John Reger's post</a> to get more information. <br><br>  So, we have a lot of tools for finding bugs, but there is no good way to prove that there is no UB in the application.  Imagine that there are tons of bugs in real-world applications, and that C is used in a wide range of critical applications, and it scares.  In our last article, I will look at the various options that the C compiler has in order to handle UB, especially paying attention to Clang. </div><p>Source: <a href="https://habr.com/ru/post/341144/">https://habr.com/ru/post/341144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341132/index.html">Environment for developing TypeScript and React web applications: from 'hello world' to modern SPA. Part 2</a></li>
<li><a href="../341134/index.html">Design pattern "state" twenty years later</a></li>
<li><a href="../341138/index.html">Step-by-step tutorial on working with Antlr4 with Maven project for Java through Intellij Idea</a></li>
<li><a href="../341140/index.html">Bonus vs depreirovanie</a></li>
<li><a href="../341142/index.html">We look for typo names in PostgreSQL</a></li>
<li><a href="../341146/index.html">$ mol - the best cure for hemorrhoids</a></li>
<li><a href="../341148/index.html">Fuzzy string comparison: understand me if you can</a></li>
<li><a href="../341152/index.html">Development of 2D sandboxes on JavaScript from scratch</a></li>
<li><a href="../341154/index.html">What every C programmer should know about Undefined Behavior. Part 3/3</a></li>
<li><a href="../341156/index.html">Security Week 43: The Great IoT Reap Is Coming, Like NATO Cyberconf Hackers Flying, Bad Exception Rabbit Ears ExPetr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>