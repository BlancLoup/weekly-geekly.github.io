<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[DotNetBook] Type Instance Structure and VMT</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this article, I continue to publish a series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[DotNetBook] Type Instance Structure and VMT</h1><div class="post__text post__text-html js-mediator-article"><img width="350" src="https://habrastorage.org/webt/34/ua/e6/34uae6usmglyw10vxga3sgfgh8c.jpeg" align="left">  With this article, I continue to publish a series of articles, the result of which will be a book on the work of the .NET CLR, and .NET as a whole. <br><br>  The entire book will be available on GitHub: <a href="">CLR Book</a> .  So Issues and Pull Requests are welcome :) <br><br>  This is a squeeze out of the <a href="">chapter on type structure and their VMT</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Structure of objects in memory </h2><br>  Until now, <a href="">speaking of the difference between significant and reference types</a> , we touched on this topic from the height of the final developer.  Those.  we did not look at how they are in reality arranged at the level of the CLR, as these or other mechanics are made inside each of them.  We actually looked at the end result.  However, in order to understand the essence of things more deeply and in order to put aside the last remaining thoughts about any magic that happens inside the CLR, it is worth looking into its very implications. <br><br><blockquote><h3>  Note </h3><br>  The chapter published on Habr√© is not updated and it is possible that it is already somewhat outdated.  So, please ask for a more recent text to the original: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub, table of contents</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="">GitHub, chapter</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 of the book, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><br><a name="habracut"></a><br><h3>  Internal structure of type instances </h3><br>  If we speak of classes as data types, then in a conversation about their data types, it suffices to recall their basic device.  Let's start with the <code>object</code> type, which is the base type and forms the structure for all reference types: <br><br><h4>  System.Object </h4><br><pre> <code class="hljs ruby"> ---------------------------------------------- <span class="hljs-params"><span class="hljs-params">| SyncBlkIndx |</span></span> VMTPtr <span class="hljs-params"><span class="hljs-params">| Data |</span></span> ---------------------------------------------- <span class="hljs-params"><span class="hljs-params">| 4 / 8  |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>  <span class="hljs-params"><span class="hljs-params">| 4 / 8  |</span></span> ---------------------------------------------- <span class="hljs-params"><span class="hljs-params">| 0xFFF..FFF |</span></span> 0xXXX..XXX <span class="hljs-params"><span class="hljs-params">| 0 |</span></span> ---------------------------------------------- ^ <span class="hljs-params"><span class="hljs-params">|     . ..   ,   VMT Sum size = 12 (x86) .. 24 (x64)</span></span></code> </pre><br>  Those.  in fact, the size depends on the final platform on which the application will run. <br><br>  Now, to gain further insight into what we are dealing with, let's follow the <code>VMTPtr</code> pointer.  For the entire type system, this pointer is the most important: it is through it that both inheritance, and the implementation of interfaces and type conversion, and many other things work.  This pointer is a reference to the .NET CLR type system. <br><br><h4>  Virtual Methods Table </h4><br>  The description of the table itself is available at the address in <a href="">GitHub CoreCLR</a> and if you drop all unnecessary (and there are 4381 lines! The guys from the CoreCLR team are not shy), <a href="">it looks like this</a> : <br><br><blockquote>  This is a version of CoreCLR.  If you look at the structure of fields in the .NET Framework, then it will differ in the location of the fields. <br></blockquote><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Low WORD is component size for array and string types (HasComponentSize() returns true). // Used for flags otherwise. DWORD m_dwFlags; // Base size of instance of this class when allocated on the heap DWORD m_BaseSize; WORD m_wFlags2; // Class token if it fits into 16-bits. If this is (WORD)-1, the class token is stored in the TokenOverflow optional member. WORD m_wToken; // &lt;NICE&gt; In the normal cases we shouldn't need a full word for each of these &lt;/NICE&gt; WORD m_wNumVirtuals; WORD m_wNumInterfaces;</span></span></code> </pre><br>  Agree, it looks scary.  And it is scary not because there are only 6 fields (and where are all the rest?), But the fact that in order to get to them, we had to skip 4,100 lines of logic.  But let's not be discouraged and try to immediately get a benefit from this: we have no idea what we mean by other fields, but the `m_BaseSize` field looks tempting.  As the comment tells us, this is the actual size for the type instance.  Let's try in battle? <br><br>  To get the VMT address, we can go two ways: either go from the complex end, having received the address of the object, and therefore VMT (some of this code was already on the pages of this book, but do not scold me: I do not want you to look for it): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Union x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Union(); x.Reference.Value = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,   //   VMT // - (IntPtr*)x.Value.Value -     (   ) // - *(IntPtr*)x.Value.Value -      VMT // - (void *)*(IntPtr*)x.Value.Value -    void *vmt = (void *)*(IntPtr*)x.Value.Value; //     VMT; Console.WriteLine((ulong)vmt); } [StructLayout(LayoutKind.Explicit)] public class Union { public Union() { Value = new Holder&lt;IntPtr&gt;(); Reference = new Holder&lt;object&gt;(); } [FieldOffset(0)] public Holder&lt;IntPtr&gt; Value; [FieldOffset(0)] public Holder&lt;object&gt; Reference; } public class Holder&lt;T&gt; { public T Value; } }</span></span></code> </pre><br>  Or the same address is returned to the .NET FCL API: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vmt = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>).TypeHandle.Value;</code> </pre><br>  The second way is of course simpler (although it works longer).  However, knowledge of the first is very important from the point of view of understanding the structure of an instance of a type.  Using the second way, although it adds a sense of confidence: if we call the API method, it seems like we are using the documented way of working with VMT.  And if we get through pointers, then no.  But do not forget that `VMT *` storage is standard for almost any OOP language and for the .NET platform as a whole: it is always in the same place. <br><br>  Let's explore the issue of type structure in terms of the size of their instance.  We need not only to study them abstractly (this is just plain boring), but in addition we will try to derive from this such a benefit, which cannot be learned in the usual way. <br><br><blockquote>  <b>Why sizeof is for Value Type but not for Reference Type?</b>  In fact, the question is open because  No one bothers to calculate the size of the reference type.  The only thing you can stumble about is not the fixed size of two reference types: `Array` and` String`.  As well as the `Generic` group, which depends entirely on specific options.  Those.  With the `sizeof (..)` operator, we couldn‚Äôt get by: you need to work with specific instances.  However, no one bothers to make a method like `static int System.Object.SizeOf (object obj)`, which would easily and simply return to us what we need.  So why didn't Microsoft implement this method?  There is an idea that the .NET platform, in their understanding, is not the platform where the developer will be very worried about specific bytes.  In which case, you can simply deliver the bar to the motherboard.  Moreover, most of the data types that we implement do not occupy such large volumes.  However, those who need everything they need will calculate all the sizes as it should.  The latter, of course, is controversial. <br></blockquote><br>  But we will not be distracted.  So, to get the size of an instance of any class whose instances have a fixed size, it‚Äôs enough to write the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SizeOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { MethodTable *pvmt = (MethodTable *)type.TypeHandle.Value.ToPointer(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pvmt-&gt;Size; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MethodTable { [FieldOffset(<span class="hljs-number"><span class="hljs-number">4</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GenericSample</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { T fld; } <span class="hljs-comment"><span class="hljs-comment">// ... Console.WriteLine(SizeOf(typeof(Sample)));</span></span></code> </pre><br>  So what did we just do?  The first step was a pointer to a virtual method table.  Then we typed the type to a pointer to a table of virtual methods (a very simplified version of it).  After that we read the size and get `12` - this is the sum of the sizes of the fields` SyncBlockIndex + VMT_Ptr + field x` for a 32-bit platform.  If we play around with different types, we‚Äôll get something like the following table: <br><br><table><tbody><tr><td>  Type or its definition </td><td>  The size </td><td>  Comment </td></tr><tr><td>  Object </td><td>  12 </td><td>  SyncBlk + VMT + empty field <br></td></tr><tr><td>  Int16 </td><td>  12 </td><td>  Boxed Int16: SyncBlk + VMT + Data <br>  (aligned by 4 bytes on x86) <br></td></tr><tr><td>  Int32 </td><td>  12 </td><td>  Boxed Int32: SyncBlk + VMT + Data <br></td></tr><tr><td>  Int64 </td><td>  sixteen </td><td>  Boxed Int64: SyncBlk + VMT + Data <br></td></tr><tr><td>  Char </td><td>  12 </td><td>  Boxed Char: SyncBlk + VMT + Data <br>  (aligned by 4 bytes on x86) <br></td></tr><tr><td>  Double </td><td>  sixteen </td><td>  Boxed Double: SyncBlk + VMT + Data <br></td></tr><tr><td>  IEnumerable </td><td>  0 </td><td>  The interface has no size: you must take obj.GetType () <br></td></tr><tr><td>  List [T] </td><td>  24 </td><td>  It doesn't matter how many items in List [T], to occupy <br>  it will be the same  it stores data in an array that is not taken into account <br></td></tr><tr><td>  GenericSample [int] </td><td>  12 </td><td>  As you can see, generics are beautifully considered.  The size has not changed, <br>  because  data is in the same place as boxed int. <br>  Total: SyncBlk + VMT + data = 12 bytes (x86) <br></td></tr><tr><td>  GenericSample [Int64] </td><td>  sixteen </td><td>  Similarly <br></td></tr><tr><td>  GenericSample [IEnumerable] </td><td>  12 </td><td>  Similarly <br></td></tr><tr><td>  GenericSample [DateTime] </td><td>  sixteen </td><td>  Similarly <br></td></tr><tr><td>  string </td><td>  14 </td><td>  This value will be returned for any string. <br>  because  real size should be considered dynamically. <br>  However, it is suitable for the size of an empty line. <br>  Please note that the size is not aligned to <br>  bit depth: essentially this field is used <br>  should not <br></td></tr><tr><td>  int [] {1} </td><td>  24554 </td><td>  For arrays in this place are <br>  very different data plus their size is not <br>  fixed because it must be considered <br>  separately <br></td></tr></tbody></table><br>  As you can see, when the system stores data on the size of an instance of a type, it actually stores data for the reference type (including for the reference variant of the significant type).  Let's draw some conclusions: <br><br><ol><li>  If you want to know how much a value type will take as a value, use `sizeof (TType)` </li><li>  If you want to calculate what boxing will cost you, then you can round up `sizeof (TType)` up to the word size of the processor (4 or 8 bytes) and add 2 more words.  Or take this value from the `VMT` type. </li><li>  If it is necessary to understand how much heap memory allocation will cost us, we have three options: </li></ol><br><h4>  System.String </h4><br>  About the lines in practice, we will talk separately: this relatively small class can be divided into an entire chapter.  And in the framework of the chapter on the structure of VMT, we will talk about the structure of strings at a low level.  UTF16 is used to store strings.  This means that each character takes 2 bytes.  Additionally, a null terminator is stored at the end of each line (i.e., a value that identifies that the line has ended).  The length of the string is also stored in the form of an Int32 number ‚Äî so as not to count the length each time you need it.  We'll talk about encodings separately, but for now this information is enough for us. <br><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/  .NET Framework 4   ------------------------------------------------------------------------- | SyncBlkIndx | VMTPtr | Length | char | char | Term | ------------------------------------------------------------------------- | 4 /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>  <span class="hljs-params"><span class="hljs-params">| 4 / 8  |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-params"><span class="hljs-params">| 2 . |</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . <span class="hljs-params"><span class="hljs-params">| 2 . |</span></span> ------------------------------------------------------------------------- <span class="hljs-params"><span class="hljs-params">| -1 |</span></span> 0xXXXXXXXX <span class="hljs-params"><span class="hljs-params">| 2 |</span></span> a <span class="hljs-params"><span class="hljs-params">| b |</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-params"><span class="hljs-params">| ------------------------------------------------------------------------- Term - null terminator Sum size = (12 (24) + 2 + (Len*2)) -&gt;      . (20   ) //  .NET Framework 3.5   ------------------------------------------------------------------------------ |</span></span> SyncBlkIndx<span class="hljs-params"><span class="hljs-params">| VMTPtr |</span></span> ArrayLength <span class="hljs-params"><span class="hljs-params">| Length |</span></span> char <span class="hljs-params"><span class="hljs-params">| char |</span></span> Term <span class="hljs-params"><span class="hljs-params">| ------------------------------------------------------------------------------ |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>  <span class="hljs-params"><span class="hljs-params">| 4 / 8  |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-params"><span class="hljs-params">| 4  |</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . <span class="hljs-params"><span class="hljs-params">| 2 . |</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . <span class="hljs-params"><span class="hljs-params">| ------------------------------------------------------------------------------ |</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-params"><span class="hljs-params">| 0xXXXXXXXX |</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-params"><span class="hljs-params">| 2 |</span></span> a <span class="hljs-params"><span class="hljs-params">| b |</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-params"><span class="hljs-params">| ------------------------------------------------------------------------------ Term - null terminator Sum size = (16 (32) + 2 + (Len*2)) -&gt;      . (24   )</span></span></code> </pre><br>  Rewrite our method to teach it to count the size of lines: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SizeOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> majorNetVersion = Environment.Version.Major; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = obj.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> href = Union.GetRef(obj).ToInt64(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DWORD = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(IntPtr); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baseSize = <span class="hljs-number"><span class="hljs-number">3</span></span> * DWORD; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (majorNetVersion &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(href + DWORD <span class="hljs-comment"><span class="hljs-comment">/* skip vmt */</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DWORD * ((baseSize + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * length + (DWORD<span class="hljs-number"><span class="hljs-number">-1</span></span>)) / DWORD); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// on 1.0 -&gt; 3.5 string have additional RealLength field var arrlength = *(int*)(href + DWORD /* skip vmt */); var length = *(int*)(href + DWORD /* skip vmt */ + 4 /* skip length */); return DWORD * ((baseSize + 2 + 2 * length + (DWORD -1)) / DWORD); } } else if (type.BaseType == typeof(Array) || type == typeof(Array)) { return ((ArrayInfo*)href)-&gt;SizeOf(); } return SizeOf(type); }</span></span></code> </pre><br>  Where `SizeOf (type)` will call the old implementation - for fixed-length reference types. <br><br>  Let's check the code in practice: <br><br><pre> <code class="cs hljs"> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; stringWriter = (arg) =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Length of `</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{arg}</span></span></span><span class="hljs-string">` string: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{SizeOf(arg)}</span></span></span><span class="hljs-string">"</span></span>); }; stringWriter(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); stringWriter(<span class="hljs-string"><span class="hljs-string">"ab"</span></span>); stringWriter(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>); stringWriter(<span class="hljs-string"><span class="hljs-string">"abcd"</span></span>); stringWriter(<span class="hljs-string"><span class="hljs-string">"abcde"</span></span>); stringWriter(<span class="hljs-string"><span class="hljs-string">"abcdef"</span></span>); } ----- Length of `a` <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span> Length of `ab` <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> Length of `abc` <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> Length of `abcd` <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> Length of `abcde` <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> Length of `abcdef` <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre><br>  Calculations show that the size of the string does not increase linearly but in steps: every two characters.  This happens because the size of each character is 2 bytes, they follow each other.  But the final size should be divided without any rest by the processor width.  Those.  some lines will get another 2 bytes upwards.  The result of our work is wonderful: we can calculate the cost of this or that line.  The last step is left for us to find out how to calculate the size of the arrays in memory and to make the task even more practical, let's make a method that will answer us the question: what size should the array be taken so that we fit in the SOH.  It may seem that using the Length property would be more reasonable and faster: however, in reality it will work more slowly: additional costs. <br><br><h4>  Arrays </h4><br>  The structure of arrays is somewhat more complicated: after all, arrays can have variants of their structure: <br><br><ol><li>  They can store significant types, and they can store reference. </li><li>  Arrays can contain one or several dimensions. </li><li>  Each measurement can begin with either `0` or any other number (this is in my opinion a very controversial possibility: to save a programmer from being lazy to make` arr [i - startIndex] `at the FCL level) </li></ol><br>  Hence, some confusion in the implementation of arrays and the inability to accurately predict the size of a finite array: it is not enough to multiply the number of elements by their size.  Although, of course, for most cases it will be more or less sufficient.  Size becomes important when we are afraid to get into LOH.  However, here and there we have options: we can simply throw to the size calculated ‚Äúon the knee‚Äù some constant from above (for example, 100) in order to understand whether we have crossed the 85,000 border or not.  However, within this section, the task is somewhat different: to understand the structure of types.  We will look at it: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  -------------------------------------------------------------------------------- | SBI | VMTPtr |Total | Len_1 | Len_2 | .. | Len_N | Term | VMT_Child | --------------------------opt-------opt------------opt-------opt--------opt----- | 4 /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-params"><span class="hljs-params">| 4 / 8 |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-params"><span class="hljs-params">| 4 |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-params"><span class="hljs-params">| 4 |</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-params"><span class="hljs-params">| -------------------------------------------------------------------------------- |</span></span><span class="hljs-number"><span class="hljs-number">0xFF</span></span>.FF<span class="hljs-params"><span class="hljs-params">|0xXX.XX |</span></span> ? <span class="hljs-params"><span class="hljs-params">| ? |</span></span> ? <span class="hljs-params"><span class="hljs-params">| |</span></span> ? <span class="hljs-params"><span class="hljs-params">|0x00.00|</span></span> 0xXX..XX <span class="hljs-params"><span class="hljs-params">| -------------------------------------------------------------------------------- - opt:  - SBI: Sync Block Index - VMT_Child:         - Total:   .         - Len_2..Len_N + Term:       1 (   VMT-&gt;Flags)</span></span></code> </pre><br>  As we can see, the type header stores data about array dimensions: their number can be either 1 or large enough: in fact, their size is limited only by a null terminator, meaning that the enumeration is complete.  This example is fully available in the file [GettingInstanceSize] (./ samples / GettingInstanceSize.linq), and below I will only give you the most important part: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SizeOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementsize; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* entity = &amp;MethodTable) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = Union.GetObj&lt;Array&gt;((IntPtr)entity); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementType = arr.GetType().GetElementType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementType.IsValueType) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typecode = Type.GetTypeCode(elementType); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (typecode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Byte: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.SByte: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Boolean: elementsize = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Int16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.UInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Char: elementsize = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Int32: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.UInt32: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Single: elementsize = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Int64: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.UInt64: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Double: elementsize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TypeCode.Decimal: elementsize = <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> info = (MethodTable*)elementType.TypeHandle.Value; elementsize = info-&gt;Size - <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(IntPtr); <span class="hljs-comment"><span class="hljs-comment">// sync blk + vmt ptr break; } } else { elementsize = IntPtr.Size; } // Header total += 3 * sizeof(IntPtr); // sync blk + vmt ptr + total length total += elementType.IsValueType ? 0 : sizeof(IntPtr); // MethodsTable for refTypes total += IsMultidimentional ? Dimensions * sizeof(int) : 0; } // Contents total += (int)TotalLength * elementsize; // align size to IntPtr if ((total % sizeof(IntPtr)) != 0) { total += sizeof(IntPtr) - total % (sizeof(IntPtr)); } return total; }</span></span></code> </pre><br>  This code takes into account all variations of array types and can be used to calculate its size: <br><br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"size of int[]{{1,2}}: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{SizeOf(new </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-string"><span class="hljs-subst">[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">])}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"size of int[2,1]{{1,2}}: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{SizeOf(new </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-string"><span class="hljs-subst">[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">,</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">])}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"size of int[2,3,4,5]{{...}}: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{SizeOf(new </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-string"><span class="hljs-subst">[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">4</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">5</span></span></span></span><span class="hljs-string"><span class="hljs-subst">])}</span></span></span><span class="hljs-string">"</span></span>); --- size of <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">20</span></span> size of <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">32</span></span> size of <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]{...}: <span class="hljs-number"><span class="hljs-number">512</span></span></code> </pre><br><h4>  Conclusions to the section </h4><br>  At this stage, we learned a few fairly important things.  First, we have divided reference types into three groups: fixed-type reference types, generic types, and variable-size reference types.  We also learned to understand the structure of the final instance of any type (for the time being, I am silent about the structure of the VMT. We understood the whole field so far only one field: this is also a great achievement).  Whether it is a fixed-size reference type (everything is very simple there) or an indefinite-size reference type: an array or a string.  Indefinite because its size will be determined upon creation.  With generic types, in fact, everything is simple: for each specific generic type, its own VMT is created, which will contain a specific size. <br><br><h3>  Methods Table </h3><br><h4>  VMT classes </h4><br>  The explanation of the work of the Methods Table is mostly academic: after all, to crawl into such jungle is like digging a grave for yourself.  On the one hand, such bins conceal something exciting and interesting, they store certain data, which further reveal the understanding of what is happening.  However, on the other hand, we all understand that Microsoft will not give us any guarantees that they will leave their runtime unchanged and, for example, they will not suddenly move the table of methods one field forward. <br><br>  All right, warned.  Now let's dive into the world as they say through the mirror.  After all, until now, the whole looking glass was reduced to the knowledge of the structure of objects: and in theory we should already know about it.  And in essence, this knowledge is not through the looking glass, but rather as an entrance to the looking glass.  Returning to the `MethodTable` structure <a href="">described in CoreCLR</a> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Low WORD is component size for array and string types (HasComponentSize() returns true). // Used for flags otherwise. DWORD m_dwFlags; // Base size of instance of this class when allocated on the heap DWORD m_BaseSize; WORD m_wFlags2; // Class token if it fits into 16-bits. If this is (WORD)-1, the class token is stored in the TokenOverflow optional member. WORD m_wToken; // &lt;NICE&gt; In the normal cases we shouldn't need a full word for each of these &lt;/NICE&gt; WORD m_wNumVirtuals; WORD m_wNumInterfaces;</span></span></code> </pre><br>  Namely, to the fields `m_wNumVirtuals` and` m_wNumInterfaces`.  These two fields define the answer to the question ‚Äúhow many virtual methods and interfaces does the type have?‚Äù.  In this structure, there is no information about the usual methods, fields, properties (which combine the methods) and ** in no way connected with reflection **.  By its nature and purpose, this structure is created for the work of calling methods in the CLR (and in fact in any OOP: be it Java, C ++, Ruby, or something else. Just the location of the fields will be somewhat different).  Let's look at the code: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { _x = newValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _x; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OverridedSample</span></span> : <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">666</span></span>; } }</code> </pre><br>  No matter how meaningless these classes may seem, they will fit us perfectly to describe their VMT.  And for this we need to understand the difference between the base type and the `ChangeTo` and` GetValue` methods inherited from the question. <br><br>  The `ChangeTo` method is present in both types: it cannot be overridden.  This means that it can be rewritten as: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Sample self, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { self._x = newValue; } <span class="hljs-comment"><span class="hljs-comment">// ... } //        struct public struct Sample { public int _x; public static void ChangeTo(ref Sample self, int newValue) { self._x = newValue; } // ... }</span></span></code> </pre><br>  And at the same time, apart from the architectural meaning, nothing will change: believe me, when compiling, both options will work the same way, since  for instance methods, this is just the first parameter of the method, which is passed to us implicitly. <br><br><blockquote>  I will explain in advance why all explanations around inheritance are built around examples on static methods: in fact, all methods are static.  And the copy and no.  There is no instance of compiled methods for each class instance.  It would take a huge amount of memory: it's easier for the same method to pass a reference every time to an instance of the structure or class with which it works. <br></blockquote><br>  For the `GetValue` method, everything is completely different.  We cannot simply take and override the method by redefining the * static * `GetValue` in the inherited type: only those code sections that work with a variable as  ªOverridedSample` will get a new method, and if it work as a variable with a base type` Sample` you can only call the `GetValue` base type because you have no idea what type the object is.  In order to understand what type a variable is and, as a result, which method is specifically called, we can proceed as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sample = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sample(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overrided = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverridedSample(); Console.WriteLine(sample.Virtuals[Sample.GetValuePosition].DynamicInvoke(sample)); Console.WriteLine(overrided.Virtuals[Sample.GetValuePosition].DynamicInvoke(sample)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GetValuePosition = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Delegate[] Virtuals; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Virtuals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Delegate[<span class="hljs-number"><span class="hljs-number">1</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;Sample, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(GetValue) }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Sample self, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { self._x = newValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Sample self</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._x; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OverridedSample</span></span> : <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OverridedSample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Virtuals[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;Sample, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(GetValue); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Sample self</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">666</span></span>; } }</code> </pre><br>  In this example, we actually build a table of virtual methods manually, and make calls on the position of the method in this table.  If you understand the essence of the example, then you actually understand how inheritance is built at the level of compiled code: methods are called by their index in the virtual method table.  Just when you create an instance of a certain inherited type, then the places where the base type has virtual methods are located; the compiler will locate the pointers to the overridden methods.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the difference between our example and the real VMT is only that when the compiler builds this table, it knows in advance what it has to do and creates a table of the correct size: in our example, to build a table for the types that will make the table larger due to adding new methods will have to sweat a lot. </font><font style="vertical-align: inherit;">But our task is different, and therefore we will not engage in such perversions.</font></font><br><br><blockquote><h3>  Link to the whole book </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR Book: <a href="https://github.com/sidristij/dotnetbook/">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 books, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/344556/">https://habr.com/ru/post/344556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344542/index.html">The human factor in information security</a></li>
<li><a href="../344546/index.html">What hurts a business?</a></li>
<li><a href="../344548/index.html">Zabbix: LLD monitoring of disks without UserParameter and agent scripts</a></li>
<li><a href="../344550/index.html">The history of victory in the international competition for the recognition of documents of the SmartEngines company</a></li>
<li><a href="../344552/index.html">OSU! Relax (basics)</a></li>
<li><a href="../344558/index.html">Garland generation algorithm for the New Year puzzle</a></li>
<li><a href="../344560/index.html">IQ correlation with our life (Feature ranking)</a></li>
<li><a href="../344562/index.html">Lua and Corona SDK (3/3 part)</a></li>
<li><a href="../344564/index.html">Finite Element Programming</a></li>
<li><a href="../344566/index.html">We build in-app purchase into our app</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>