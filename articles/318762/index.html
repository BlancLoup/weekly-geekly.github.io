<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming multi-core DSP processors TMS320C66x using OpenMP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes the approach to programming multi-core signal processors based on OpenMP. OpenMP directives are considered, their meaning and us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming multi-core DSP processors TMS320C66x using OpenMP</h1><div class="post__text post__text-html js-mediator-article">  The article describes the approach to programming multi-core signal processors based on OpenMP.  OpenMP directives are considered, their meaning and use cases are analyzed.  The emphasis is on digital signal processors.  Examples of the use of OpenMP directives are chosen close to the tasks of digital signal processing.  The implementation is carried out on a TMS320C6678 processor by Texas Instruments, which includes 8 DSP cores.  Part I of the article discusses the basic OpenMP directives.  In Part II of the article, it is planned to supplement the list of directives, as well as consider the issues of the internal organization of OpenMP work and the issues of software optimization. <br><br>  This article reflects the lecture and practical material offered to students in the framework of refresher courses on the program "Multi-core processors of digital signal processing C66x company Texas Instruments" held annually in the Ryazan University of Radio Engineering.  The article was planned for publication in one of the scientific and technical journals, but due to the specifics of the issues under consideration, it was decided to accumulate material for a textbook on multi-core DSP-processors.  In the meantime, this material will accumulate, it may well lie on the Internet pages in the public domain.  Feedback and suggestions are welcome. <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  The modern industry of high-performance processor elements is currently experiencing a characteristic turn associated with the transition to multi-core architectures [1, 2].  This transition is a measure rather forced than the natural course of processor evolution.  Further development of semiconductor technology along the path of miniaturization and increase in clock frequencies with a corresponding increase in computational performance was impossible due to a sharp decrease in their energy efficiency.  The logical way out of the current situation is that the manufacturers of processor technology considered the transition to multi-core architectures, allowing the processor to increase the computing power not due to the faster operation of its elements, but due to the parallel operation of a large number of operating devices [1].  This turn is typical for processor technology in general, and, in particular, for digital signal processing processors with their specific applications and special requirements for computational efficiency, efficiency of internal and external data transmissions with simultaneous low power consumption, size and price. <br><br>  From the point of view of the developer of real-time signal processing systems, the transition to the use of multicore architectures of digital signal processors (DSP) can be expressed in three main problems.  The first is the development of the hardware platform, its capabilities, the purpose of certain units and their modes of operation, established by the manufacturer [1].  The second is the adaptation of the processing algorithm and the principle of system organization for implementation on a multi-core DSP (MSCP) [3].  The third is the development of software (software) for digital signal processing implemented on the MTSSP.  At the same time, software development for the MSCP has a number of fundamental differences from the development of traditional single-core applications, including the distribution of certain code fragments by core, data separation, core synchronization, data and service information exchange between cores, cache synchronization and others. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the most attractive solutions for porting existing ‚Äúsingle-core‚Äù software to a multi-core platform or for developing new ‚Äúparallel‚Äù software products is the Open Multi-Processing Toolkit (OpenMP).  OpenMP is a set of compiler directives, functions, and environment variables that can be embedded in standard programming languages, primarily in the most common C language, expanding its capabilities by organizing parallel computing.  This is the main advantage of the OpenMP approach.  No need to invent / learn new parallel programming languages.  A single-core program easily becomes multi-core by adding simple and clear directives to the compiler in standard code.  All that is needed is for the compiler of this processor to support OpenMP.  That is, processor manufacturers should take care that their compilers "understand" the OpenMP standard directives and translate them into appropriate assembler codes. <br><br>  The OpenMP standard is developed by an association of several large computer manufacturers and is regulated by the OpenMP Architecture Review Board (ARB) [4].  At the same time, it is universal, not intended for specific hardware platforms of specific manufacturers.  The ARB organization openly publishes the specification of the next versions of the standard [5].  Also of interest is the OpenMP quick reference [6]. <br><br>  Recently, an enormous number of papers [7‚Äì12] have been devoted to the use of OpenMP in various applications and on various platforms.  Of particular interest are books that allow you to fully get a basic knowledge of using OpenMP.  In the domestic literature, these are sources [13‚Äì16]. <br><br>  This paper is devoted to the description of OpenMP directives, functions and environment variables.  In this case, the specifics of the work is its focus on the tasks of digital signal processing.  Examples illustrating the meaning of certain directives are taken with an emphasis on implementation on the MTSSP.  As a hardware platform, MTSC TMS320C6678 processors from Texas Instruments [17] were selected, including 8 DSP cores.  This platform MTSSP is one of the best, enjoying wide demand in the domestic market.  In addition, the paper discusses a number of issues related to the internal organization of OpenMP mechanisms that are relevant to the tasks of processing real-time signals, as well as optimization issues. <br><br><h3>  Formulation of the problem </h3><br>  So, let the processing task is to form the output signal, as the sum of two input signals of the same length: <br><br><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">z</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">y</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">n</span></span></span><span class="hljs-function"> = 0, 1, ‚Ä¶, N-1</span></span></code> </pre> <br>  A ‚Äúsingle core‚Äù implementation of this task in the standard C / C ++ language might look like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vecsum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) z[i] = x[i] + y[i]; }</code> </pre> <br>  Suppose now we have an 8-core processor TMS320C6678.  The question arises, how to use the capabilities of a multi-core architecture for the implementation of this program? <br><br>  One solution is to develop 8 separate programs and independently load them into 8 cores.  This is fraught with the presence of 8 separate projects in which it is necessary to take into account joint rules of execution: the location of arrays in memory, the separation of parts of arrays between cores, and so on.  In addition, it will be necessary to write additional programs that synchronize the kernels: if one core has completed the formation of its part of the array, this does not mean that the entire array is ready;  it is necessary either to manually check the completion of all cores, or to send processing completion flags to one ‚Äúmain‚Äù core from all cores, which will issue a corresponding message about the output array readiness. <br><br>  The described approach can be correct and effective, however, it is rather difficult to implement and in any case requires the developer to significantly revise the existing software.  We would like to be able to go from single-core to multi-core implementation with minimal changes to the source code!  This is the task that OpenMP solves. <br><br><h3>  OpenMP Initial Settings </h3><br>  Before you start using OpenMP in your program, you obviously need to connect this functionality to your project.  For TMS320C6678 processors, this means modifying the project configuration file and the platform used, and including references to OpenMP components in the project properties.  We will not discuss such specific hardware-specific settings in the article.  Consider the more general initial OpenMP settings. <br><br>  Since OpenMP is an extension of the C language, the inclusion of its directives and functions in its program must be accompanied by the inclusion of a file describing this functionality: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ti/omp/omp.h&gt;</span></span></span></span></code> </pre> <br>  Next, you need to tell the compiler (and the OpenMP functionality) how many cores we are dealing with.  Note that OpenMP does not work with kernels, but with parallel threads.  Parallel flow is a logical concept, and the core is physical, hardware.  In particular, several parallel threads can be implemented on one core.  At the same time, truly parallel execution of the code naturally implies that the number of parallel threads coincides with the number of cores, and each thread is implemented on its own core.  In the future, we will assume that the situation looks exactly like this.  However, it should be borne in mind that the number of a parallel thread and the number of its core does not have to be the same! <br><br>  To the initial OpenMP settings, we assign the task of the number of parallel streams using the following OpenMP function: <br><br><pre> <code class="hljs lisp">omp_set_num_threads(<span class="hljs-number"><span class="hljs-number">8</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  We set the number of cores (threads) to 8. <br><br><h3>  Parallel directive </h3><br>  So, we want the program code above to run on 8 cores.  With OpenMP, it‚Äôs enough just to add the parallel directive to the code as follows: <br><br><pre> <code class="hljs mel">#include &lt;ti/omp/omp.h&gt; void vecsum (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * z, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N) { omp_set_num_threads(<span class="hljs-number"><span class="hljs-number">8</span></span>); #pragma omp parallel { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) z[i] = x[i] + y[i]; } }</code> </pre> <br>  All OpenMP directives are issued in the form of the following constructs: <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">omp</span></span> &lt;_&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[[(,)]</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[[(,)]</span></span>] ‚Ä¶].</code> </pre> <br>  In our case, we do not use any options, and the parallel directive means that the code snippet following it, marked with curly brackets, refers to a parallel region and must be executed not on one, but on the entire specified number of cores. <br><br>  We received a program that runs on one main or master core (master core), and those fragments allocated by the parallel directive run on a given number of cores, including both the master and slave cores.  In the resulting implementation, the same vector summation cycle will be executed immediately on 8 cores. <br><br>  A typical structure for the organization of parallel computing in OpenMP is shown in Figure 1. <br><br><div style="text-align:center;"><img src="http://www.dspa.ru/workshops/pic1_copy.jpg" alt="image"></div><br>  <i>Figure 1. The principle of parallel computing in OpenMP</i> <br><br>  The execution of a program code always begins with a sequential region, executed on a single core in a leading thread.  At the point of beginning of a parallel region, indicated by the corresponding OpenMP directive, the organization of parallel execution following the OpenMP directive of the code in the stream set (parallel region) occurs.  The figure shows only four parallel streams for simplicity.  At the end of a parallel region, the flows merge, waiting for each other‚Äôs work to finish, and then a successive region follows again. <br><br>  So, we managed to use 8 cores for the implementation of our program, however, there is no sense in such parallelization, since all cores do the same work.  8 cores 8 times formed the same output data array.  The processing time did not decrease.  Obviously, it is necessary to somehow divide the work between different cores. <br><br>  <i>Let's draw an analogy.</i>  <i>Let there be a team of 8 people.</i>  <i>One of them is paramount;</i>  <i>the rest are his assistants.</i>  <i>They receive requests for various works.</i>  <i>The main worker accepts and executes orders, connecting, whenever possible, his assistants.</i>  <i>The first job that our employees took up was to translate text from English into Russian.</i>  <i>The brigadier took up the work, took the source text, prepared the dictionaries, copied the text for each of his assistants and distributed to everyone the same text, without dividing the work between them.</i>  <i>The translation will be completed.</i>  <i>The task will be solved correctly.</i>  <i>However, there will be no gain from having 7 helpers.</i>  <i>Quite the contrary.</i>  <i>If they have to share the same dictionary, or a computer, or a sheet with the source text, the task execution time may be delayed.</i>  <i>OpenMP also works in our first example.</i>  <i>Requires separation of work.</i>  <i>Each employee should indicate which fragment of the general text he should translate.</i> <br><br>  An obvious way to divide work between kernels in the context of the task of summing arrays is to distribute loop iterations among the cores depending on the core number.  It is enough to find out inside which parallel code the code is running inside the parallel region, and specify a range of loop iterations depending on this number: <br><br><pre> <code class="hljs mel">#include &lt;ti/omp/omp.h&gt; void vecsum (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * z, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N) { omp_set_num_threads(<span class="hljs-number"><span class="hljs-number">8</span></span>); #pragma omp parallel { core_num = omp_get_thread_num(); a=(N/<span class="hljs-number"><span class="hljs-number">8</span></span>)*core_num; b=a+N/<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=a; i&lt;b; i++) z[i] = x[i] + y[i]; } }</code> </pre> <br>  The kernel number is read by the OpenMP function omp_get_thread_num () ;.  This function, being inside a parallel region, runs the same on all cores, but on different cores gives a different result.  Due to this, it becomes possible to further divide the work within the parallel region.  For simplicity, we assume that the number of iterations of the cycle N is a multiple of the number of kernels.  The reading of the core number can be hardware based on the presence in each core of a special register core number - the DNUM register on TMS320C6678 processors.  It can be accessed by various means, including assembler commands or CSL support library functions.  However, you can use the functionality provided by the OpenMP add-in.  Here, however, we must again pay attention to the fact that the kernel number and the number of the parallel OpenMP region are different concepts.  For example, the 3rd parallel thread may well run on, say, the 5th core.  Moreover, in the next parallel region or with the repetition of the same parallel region, the 3rd stream can already be executed on, for example, the 4th core.  And so on. <br><br>  We got a program running on 8 cores.  Each core processes its part of the input arrays and forms the corresponding area of ‚Äã‚Äãthe output array.  Each of our employees translates their 1/8 part of the text and, ideally, we get an 8-fold acceleration of the solution of the problem. <br><br><h3>  For and parallel for directives </h3><br>  We looked at the simplest parallel directive, which allows to extract fragments in code that should be executed on several cores in parallel.  This directive, however, implies that all cores execute the same code and no work separation is provided for.  We had to do it on our own, which looks a bit confusing. <br><br>  Automatic indication of how work within a parallel region is divided between the cores is possible using the additional for directive.  This directive is used inside a parallel region immediately before loops such as for and says that loop iterations should be distributed between the cores.  The parallel and for directives can be used separately: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp for</span></span></code> </pre> <br>  And can be used together in a single directive to reduce the record: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for</span></span></code> </pre> <br>  The use of the parallel for directive in our example of adding arrays leads to the following program code: <br><br><pre> <code class="hljs mel">#include &lt;ti/omp/omp.h&gt; void vecsum (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * x, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * y, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * z, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; omp_set_num_threads(<span class="hljs-number"><span class="hljs-number">8</span></span>); #pragma omp parallel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) z[i] = x[i] + y[i]; }</code> </pre> <br>  If we compare this program with the original single-core implementation, we will see that the differences are minimal.  We just connected the header file omp.h, set the number of parallel threads and added one line - the parallel for directive. <br><br><blockquote>  <b>Remark 1.</b> Another difference that we deliberately hide in our reasoning is the transfer of the declaration of the variable i from the loop to the section describing the variables of the function, or rather from the parallel to the sequential region of the code.  It is still too early to explain this action, however, it is crucial and will be explained later in the section on private and shared options. <br><br>  <b>Remark 2.</b> We say that the iterations of the cycle are divided between the cores, however, we do not say how exactly they are divided.  What are exactly loop iterations, which of the cores will be executed?  OpenMP has the ability to set the rules for the distribution of iterations across parallel threads, and we will look at these features later.  However, it is possible to precisely link a specific core to specific iterations only manually by the method discussed earlier.  The truth is usually such a binding is not necessary.  If the number of loop iterations is not a multiple of the number of cores, the distribution of iterations over the cores will be made so that the load is distributed as evenly as possible. </blockquote><br><h3>  Directives sections and parallel sections </h3><br>  Work sharing between cores can be done either on the basis of data sharing, or on the basis of task sharing.  Recall our analogy.  If all workers do the same thing - they are engaged in translating text - but each translates a different piece of text, then this refers to the first type of work sharing - data separation.  If workers perform various actions, for example, one translates the entire text, another searches for words in the dictionary, a third types the translation, and so on, then this refers to the second type of work division - task separation.  The parallel and for directives we considered allowed us to separate the work by dividing the data.  The separation of tasks between the cores allows you to execute the sections directive, which, as in the case of the for directive, can be used independently of the parallel directive or in conjunction with it to shorten the record: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp sections</span></span></code> </pre> <br>  and <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel sections</span></span></code> </pre> <br>  As an example, we present a program that uses 3 processor cores, and each of the cores performs its own algorithm for processing the input signal x: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#include &lt;ti/omp/omp.h&gt; void sect_example (float* x) { omp_set_num_threads(3); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel sections { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp section Algorithm1(x); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp section Algorithm2(x); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp section Algorithm3(x); } }</span></span></code> </pre> <br><h3>  Options shared, private and default </h3><br>  We choose to consider a new example.  Let us turn to the calculation of the scalar product of two vectors.  A simple C program that implements this procedure may look like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x[N]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dotp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum; sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;N; i++) sum = sum + x[i]*y[i]; }</code> </pre> <br>  The result of the execution (for test arrays of 16 elements) turned out to be equal to: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TMS320C66x_0</span></span>] sum = <span class="hljs-number"><span class="hljs-number">331.0</span></span></code> </pre> <br>  Let us turn to the parallel implementation of this program, using the parallel for directive: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x[N]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dotp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum; sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">#pragmaomp parallel for { for (i=0; i&lt;N; i++) sum = sum + x[i]*y[i]; } }</span></span></code> </pre> <br>  Result of performance: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TMS320C66x_0</span></span>] sum= <span class="hljs-number"><span class="hljs-number">6.0</span></span></code> </pre> <br>  The program gives the wrong result!  Why? <br><br>  To answer this question, it is necessary to understand how the values ‚Äã‚Äãof variables in the serial and parallel regions are related.  We describe the logic of OpenMP in more detail. <br>  The dotp () function starts to run as a sequential region on the 0th processor core.  At the same time, in the memory of the processor, arrays x and y are organized, as well as variables I and sum.  When the parallel directive is reached, the OpenMP utility functions come into play and organize the subsequent parallel operation of the kernels.  There is an initialization of the cores, their synchronization, data preparation and a general start.  What happens to variables and arrays? <br><br>  All objects in OpenMP (variables and arrays) can be divided into common (shared) and private (private).  Shared objects are located in shared memory and are used equally by all cores within a parallel region.  Common objects coincide with objects of the same name in a sequential region.  They move from sequential to parallel region and back unchanged, while maintaining their value.  Access to such objects within a parallel region is equal for all cores, and there may be conflicts of general access.  In our example, the x and y arrays, as well as the variable sum, turned out to be common by default.  It turns out that all cores use the same variable sum as a battery.  As a result, sometimes a situation arises in which several cores simultaneously read the same current value of the battery, add their partial contribution to it and write a new value to the battery.  In this case, the core that records last, erases the work of the other cores.  It is for this reason that our example gave the wrong result. <br><br>  The principle of working with public and private variables is illustrated in Figure 2. <br><br><div style="text-align:center;"><img src="http://www.dspa.ru/workshops/pic2_copy.jpg" alt="image"></div><br>  <i>Figure 2. Illustration of OpenMP operation with public and private variables</i> <br><br>  Private objects are copies of the original objects, created separately for each kernel.  These copies are created dynamically when initializing a parallel region.  In our example, the variable i as a loop iteration count is considered private by default.  When the parallel directive is reached, 8 copies (by the number of parallel threads) of this variable are created in the processor's memory.  Private variables are located in the private memory of each kernel (they can be located in local memory, or they can also be shared, depending on how we declared them and configured the memory).  Private copies by default are not related to the source objects of the sequential region.  By default, the values ‚Äã‚Äãof the source objects are not transferred to the parallel region.  What private copies of objects are at the beginning of a parallel region is unknown.  At the end of a parallel region, the values ‚Äã‚Äãof private copies are simply lost, unless special measures are taken to transfer these values ‚Äã‚Äãto a sequential region, which we will discuss later. <br><br>  To explicitly tell the compiler which objects should be considered private and which should be shared, the options shared and private are used in conjunction with the OpenMP directives.  The list of objects belonging to the public or private is indicated by a comma in brackets after the corresponding option.  In our case, the variables i and sum should be private, and the arrays x and y should be common.  Therefore, we will use the construction of the form: <br><br><pre> <code class="hljs lisp">#pragma omp parallel for private(<span class="hljs-name"><span class="hljs-name">i</span></span>, sum) shared(<span class="hljs-name"><span class="hljs-name">x</span></span>, y)</code> </pre> <br>  when opening a parallel region.  Now each core will have its own battery, and accumulations will go independently of each other.  Additionally, the batteries must now be reset, since their initial value is unknown.  In addition, the question arises how to combine the particular results obtained on each of the nuclei.  One option is to use a special common array of 8 cells, in which each core will place its result inside a parallel region, and after leaving the parallel region, the main core summarizes the elements of this array and forms the final result.  We get the following program code: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x[N]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y[N]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dotp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, core_num; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum; sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel private(i, sum, core_num) shared(x, y, z) { core_num = omp_get_thread_num(); sum = 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp for for (i=0; i&lt;N; i++) sum = sum + x[i]*y[i]; z[core_num] = sum; } for (i=0; i&lt;8; i++) sum = sum + z[i]; }</span></span></code> </pre> <br>  Result of performance: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TMS320C66x_0</span></span>] sum= <span class="hljs-number"><span class="hljs-number">331.0</span></span></code> </pre> <br>  The program works correctly, although it is a bit cumbersome.  We will discuss further how to simplify it. <br><br>  It is interesting that when specifying the names of OpenMP arrays as private objects during initialization of a parallel region, it acts the same way as with variables ‚Äî it dynamically creates private copies of these arrays.  You can verify this by conducting a simple experiment: declaring an array through the private option, print the values ‚Äã‚Äãof the pointers to this array in the sequential and parallel regions.  We will see 9 different addresses (with the number of cores - 8). <br><br>  Next, you can make sure that the values ‚Äã‚Äãof the elements of the arrays are not related to each other.  In addition, when you later enter the same parallel region, the addresses of private copies of the arrays may be different, and the default values ‚Äã‚Äãof the elements are not saved.  All this leads us to the fact that OpenMP directives that open and close a parallel region can be quite cumbersome and require a specific execution time. <br><br>  If there is no explicit indication of its type (common / private) for an object in the opening directive of a parallel region, then OpenMP ‚Äúacts‚Äù according to certain rules described in [5].  Undefined objects OpenMP refers to the default type.  What type it will be, private or shared, is determined by the environment variable ‚Äî one of the OpenMP operation parameters.         .   ,      .     .         for  parallel for,        . <br><br>         default.      ,      ‚Äì   .  ,        none,    ,         ,         ,    : <br><br><pre> <code class="hljs lisp">#pragma omp parallel private(<span class="hljs-name"><span class="hljs-name">sum</span></span>, core_num) shared(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, z) default(<span class="hljs-name"><span class="hljs-name">i</span></span>)</code> </pre> <br>  or: <br><br><pre> <code class="hljs lisp">#pragma omp parallel private(<span class="hljs-name"><span class="hljs-name">i</span></span>, sum, core_num) shared(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, z) default(<span class="hljs-name"><span class="hljs-name">none</span></span>)</code> </pre> <br><h3>  reduction </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the considered example of the implementation of the scalar product on 8 cores, we noted one drawback: combining the private results of the cores requires significant code modifications, which makes it cumbersome and inconvenient. At the same time, the openMP concept implies maximum transparency in the transition from single-core to multi-core implementation and vice versa. Simplify the program discussed in the previous section, allows the use of the reduction option. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reduction option allows the compiler to indicate that the results of the kernels should be combined, and sets the rules for such a combination. The reduction option is provided for a number of the most common situations. The option syntax is as follows:</font></font><br><br><pre> <code class="hljs lisp">reduction ( :  )</code> </pre> <br><blockquote>  ‚Äì ,       .      ,    . <br>   ‚Äì  ,        . </blockquote><br>      reduction,   OpenMP   ,    1. <br><br>   : +, *, -, &amp;, |, ^, &amp;&amp;, ||, max, min <br><br>    : 0, 1, 0, 0, 0, 0, 1, 0,     ,     . <br><br>         reduction c  ¬´+¬ª   sum: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x[N]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dotp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for private(i) shared(x, y) reduction(+:sum) for (i=0; i&lt;N; i++) sum += x[i]*y[i]; }</span></span></code> </pre> <br>  Result of performance: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TMS320C66x_0</span></span>] sum= <span class="hljs-number"><span class="hljs-number">331.0</span></span></code> </pre> <br>                  ¬´¬ª ! <br><br><h3>   OpenMP </h3><br>    ,     ,     .        ,  ,     .       ,  ,       .       ,         .      . <br><br>        ,               ,        ( )     ,         .    ,         ,   .  ,    (  ),        ,    .   -:  ,   ,   .    ,     OpenMP-      ,        .     ,   ,      -  -     () . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In OpenMP, two types of synchronization can be distinguished: implicit and explicit. </font><font style="vertical-align: inherit;">Implicit synchronization occurs automatically at the end of parallel regions, as well as at the end of a number of directives that can be applied within parallel regions, including omp for, omp sections, and so on. </font><font style="vertical-align: inherit;">This automatically synchronizes the cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the problem solving algorithm requires synchronizing the kernels in those points of the program inside a parallel region where automatic synchronization is not provided, the developer can use explicit synchronization ‚Äî tell the OpenMP compiler explicitly using special directives that synchronization is required at this point. </font><font style="vertical-align: inherit;">Consider the main of these guidelines.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrier directive </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The barrier directive is written as: </font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp barrier</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and explicitly sets the synchronization point for parallel OpenMP threads within a parallel region. Let's give the following example of using the directive:</font></font><br><br><pre> <code class="hljs mel">#define CORE_NUM <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z[CORE_NUM]; void arr_proc(void) { omp_set_num_threads(CORE_NUM); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, core_num; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum; #pragma omp parallel private(core_num, i, sum) { core_num=omp_get_thread_num(); z[core_num]=core_num; #pragma omp barrier sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;CORE_NUM;i++) sum=sum+z[i]; #pragma omp barrier z[core_num]=sum; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;CORE_NUM;i++) printf(<span class="hljs-string"><span class="hljs-string">"z[%d] = %f\n"</span></span>, i, z[i]); }</code> </pre> <br>       .           z,     z,      z.                 z,    .        :    .          z,   .        .    barrier   .    z       .       , ,    ,      .       ,        z,         ,    .     barrier              z.          ‚Äì  . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Critical directive </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The critical directive is written as: </font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp critical [ ]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And selects a code fragment inside a parallel region, which can be executed at a time by only one core. </font></font><br><br> <i>      ,          .            .          , ,   , ,  .  ,             .          ,       .     ,                     ,    : ,   ,  ;          .</i> <br><br>      .    ,          ,       critical.        : <br><br><pre> <code class="hljs vbscript">#define CORE_NUM <span class="hljs-number"><span class="hljs-number">8</span></span> #define N <span class="hljs-number"><span class="hljs-number">1000</span></span> #define M <span class="hljs-number"><span class="hljs-number">80</span></span> void crit_ex(void) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i, j; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> A[N]; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> Z[N] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; omp_set_num_threads(CORE_NUM); #pragma omp parallel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> (A) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; i++) { poc_A(A, N); #pragma omp critical <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;N; j++) Z[j] = Z[j] + A[j]; } }</code> </pre> <br>          ()         Z.           8 .       ,      .       ,      .           Z.        ,                .   ,         .  ,   (    ),    ,     .           . ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's replace the critical section in our code with the following construction. </font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp critical (Z1add) for (j=0; j&lt;N; j++) Z1[j] = Z1[j] + A[j]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp critical (Z2mult) for (j=0; j&lt;N; j++) Z2[j] = Z2[j] * A[j];</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have two critical sections. </font><font style="vertical-align: inherit;">In one, the results of the work of the nuclei are combined by summation; </font><font style="vertical-align: inherit;">in the other, by multiplication. </font><font style="vertical-align: inherit;">Both sections can run simultaneously on only one core, however, different sections can run simultaneously on different cores. </font><font style="vertical-align: inherit;">If you enter the name of a region into the construction of the directive critical, then the kernel will be denied access to the code only if another core works in this particular region. </font><font style="vertical-align: inherit;">If the names of the regions are not assigned, then the kernel will not be able to enter any of the critical regions if the other core works with any of them, even if they are not related to each other.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atomic directive </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The atomic directive is written as: </font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp atomic [read | write | update | capture]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous example, different kernels were forbidden to execute code from the same region at the same time. However, this may not seem rational on closer examination. After all, access conflicts to a shared resource consist in the fact that different cores can simultaneously access the same memory cells. If, within the same code, the call goes to different memory cells, the result will not be distorted. The atomic directive allows the synchronization of cores to memory elements. It indicates that in the next line of the memory operation is atomic - inseparable: if some core starts operation with a certain memory cell, access to this memory cell will be closed for all other cores until the first core finishes working with her. At the same time, the atomic directive is accompanied by options indicatingWhat type of operation is performed with memory: read / write / modify / capture. The above example when applying the atomic directive will look like this.</font></font><br><br><pre> <code class="hljs vbscript">#define CORE_NUM <span class="hljs-number"><span class="hljs-number">8</span></span> #define N <span class="hljs-number"><span class="hljs-number">1000</span></span> #define M <span class="hljs-number"><span class="hljs-number">80</span></span> void crit_ex(void) { <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i, j; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> A[N]; <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> Z[N] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; omp_set_num_threads(CORE_NUM); #pragma omp parallel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> (A) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; i++) { poc_A(A, N); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;N; j++) { #pragma omp atomic update Z[j] = Z[j] + A[j]; } }</code> </pre> <br> ,   atomic     ,                 ,         .            . , ,      atomic    ,    ,    ,       .  ,    critical     MxT1  ,   ‚Äì  ,  T1 ‚Äì     ;     atomic     2  .      atomic    ,   2   ,       1. <br><br><h3>   </h3><br>        OpenMP ‚Äì      (/++),   ,  ,        .                 8-  TMS320C6678  Texas Instruments.   OpenMP ‚Äì        .     ,     ,    OpenMP,    .         .     OpenMP      .     . <br><br>   ,  ,     OpenMP  ,      .         ,                ,     . <br><br>   ,   OpenMP   .   OpenMP     OpenMP    .   OpenMP 1  2,   Texas Instruments   TMS320C6678  .               .          OpenMP;   ,   ;       OpenMP;        . <br><br><div class="spoiler">  <b class="spoiler_title">Literature</b> <div class="spoiler_text"> 1. G. Blake, RG Dreslinski, T. Mudge, ¬´A survey of multicore processors,¬ª Signal Processing Magazine, vol. 26, no. 6, pp. 26-37, Nov. 2009. <br> 2. LJ Karam, I. AlKamal, A. Gatherer, GA Frantz, ¬´Trends in multicore DSP platforms,¬ª Signal Processing Magazine, vol. 26, no. 6, pp. 38-49, 2009. <br> 3. A. Jain, R. Shankar. Software Decomposition for Multicore Architectures, Dept. of Computer Science and Engineering, Florida Atlantic University, Boca Raton, FL, 33431. <br> 4. Web- OpenMP Architecture Review Board (ARB): <a href="http://openmp.org/">openmp.org</a> . <br> 5. OpenMP Application Programming Interface. Version 4.5 November 2015. OpenMP Architecture Review Board. P. 368. <br> 6. OpenMP 4.5 API C/C++ Syntax Reference Guide. OpenMP Architecture Review Board. 2015. <br> 7. J. Diaz, C. Mu√±oz-Caro, A. Ni√±o. A Survey of Parallel Programming Models and Tools in the Multi and Many-Core Era. IEEE Transactions on Parallel and Distributed Systems. ‚Äì 2012. ‚Äì Vol. 23, Is. 8, pp. 1369 ‚Äì 1386. <br> 8. A. Cilardo, L. Gallo, A. Mazzeo, N. Mazzocca. Efficient and scalable OpenMP-based system-level design. Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). ‚Äì 2013, pp. 988 ‚Äì 991. <br> 9. M. Chavarr√≠as, F. Pescador, M. Garrido, A. Sanchez, C. Sanz. Design of multicore HEVC decoders using actor-based dataflow models and OpenMP. IEEE Transactions on Consumer Electronics. ‚Äì 2016. ‚Äì Vol. 62. ‚Äì Is. 3, pp. 325 ‚Äì 333. <br> 10. M. Sever, E. √áavus. Parallelizing LDPC Decoding Using OpenMP on Multicore Digital Signal Processors. 45th International Conference on Parallel Processing Workshops (ICPPW). ‚Äì 2016, pp. 46 ‚Äì 51. <br> 11. A. Kharin, S. Vityazev, V. Vityazev, N. Dahnoun. Parallel FFT implementation on TMS320c66x multicore DSP. 6th European Embedded Design in Education and Research Conference (EDERC). ‚Äì 2014, pp. 46 ‚Äì 49. <br> 12. D. Wang, M. Ali, ‚ÄïSynthetic Aperture Radar on Low Power Multi-Core Digital Signal Processor,‚Äñ High Performance Extreme Computing (HPEC), IEEE Conference on, pp. 1 ‚Äì 6, 2012. <br> 13. . . , . . . -     . ., 2007, 138 . <br> 14. . . .        . . , 2006, 90 . <br> 15. .. .      OpenMP.   . 2009 , 78 . <br> 16. .. .     OpenMP. .: 2012, 121 . <br> 17. TMS320C6678 Multicore Fixed and Floating-Point Digital Signal Processor, Datasheet, SPRS691E, Texas Instruments, p. 248, 2014. </div></div></div><p>Source: <a href="https://habr.com/ru/post/318762/">https://habr.com/ru/post/318762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318752/index.html">Ada Lovelace. The first program in the world and a look into the future</a></li>
<li><a href="../318754/index.html">[Translation] How to correctly determine the size of the team for beta testing a mobile application</a></li>
<li><a href="../318756/index.html">How 10 years ago the project PVS-Studio started</a></li>
<li><a href="../318758/index.html">Why this winter we again invite everyone to play computer games using artificial intelligence</a></li>
<li><a href="../318760/index.html">3CX brings together Elastix and PBX in a Flash communities</a></li>
<li><a href="../318764/index.html">Roaming in Wi-Fi networks without using a controller</a></li>
<li><a href="../318766/index.html">Founder's advice. Evgeny Kobzev, technical director and co-founder of the company "Button"</a></li>
<li><a href="../318768/index.html">Second Coming GOST 28147-89: Honest Tests</a></li>
<li><a href="../318770/index.html">Cdr. Save and Grow</a></li>
<li><a href="../318772/index.html">Pimcore licensing FAQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>