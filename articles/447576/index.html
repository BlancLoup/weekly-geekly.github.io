<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Responsible approach to JavaScript development, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The numbers tell us that the growth in the volume of JavaScript-code is bad for the performance of web projects. If this continues in the future, then...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Responsible approach to JavaScript development, part 1</h1><div class="post__text post__text-html js-mediator-article">  The numbers tell us that the <a href="httparchive.org/reports/state-of-javascript">growth in the volume of</a> JavaScript-code is bad for the performance of web projects.  If this continues in the future, then very soon, when loading the average page, at least 400 KB of JS code will be transmitted.  And this is just the amount of data transferred.  Like other textual resources, JavaScript is almost always compressed.  Perhaps compression is the only thing that is usually done correctly when transferring code from the server to the client. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/447576/"><img src="https://habrastorage.org/getpro/habr/post_images/cbe/89c/0eb/cbe89c0eb2f6ea78726730bc7dfba6ed.jpg" alt="image"></a> <br><br>  Unfortunately, while reducing the transmission time of some resources makes a serious contribution to what we call "performance", compression does not affect how long the browser takes to parse and process the script after it is fully loaded . <br><a name="habracut"></a><br>  If the server sends the client 400 KB of compressed JS code, then the actual amount of code that the browser needs to process after decompression of the received data will be around a megabyte.  How well various devices cope with such work depends on the devices themselves.  <a href="https://habr.com/ru/company/ruvds/blog/419369/">Much has been</a> written about this, but one can only say with certainty that the time it takes even to parse the amount of code that is quite usual for its time varies greatly between different devices. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Take a look, for example, on <a href="https://devmode.jeremy.codes/">this</a> my simple project.  During the page load, about 23 KB of uncompressed JS code is transmitted to the client.  Chrome, running on a MacBook Pro, which was released in mid-2017, this rather small amount of code processes in about 25 ms.  On the Android-smartphone <a href="https://www.gsmarena.com/nokia_2-8513.php">Nokia 2</a> , however, a similar figure grows to 190 ms.  This is not to say that this is very small, but in any case, the page becomes interactive fairly quickly. <br><br>  Now - an important question.  How do you think a simple Nokia 2 smartphone handles average modern pages?  In fact - just awful.  Browsing the web, even on a fast internet connection, forces the user to exercise patience, since working with the pages loaded with JavaScript code becomes possible only after a hefty waiting period. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/eed/ec5/02feedec5d7773ad8a84b7160c77bbf7.png"></div><br>  <i><font color="#999999">Nokia 2 performance review when viewing a page that contains a large amount of JS code, processing of which blocks the main stream</font></i> <br><br>  Although the devices with which they view web pages and the networks over which data is transmitted have greatly improved in recent years, studies show that all these improvements are ‚Äúeaten up‚Äù by large amounts of JS code included in the pages.  We need to use JavaScript responsibly.  Responsibility begins with an understanding of what we create and how we do it. <br><br><h2>  <font color="#3AC1EF">Comparison of the ideology of "sites" and "applications"</font> </h2><br>  Strange things happen to inaccurate terms that we use to call something, although their meaning, on an intuitive level, is clear to everyone.  Sometimes we overload the meaning of the word "bee", calling it "bees" and wasps, even though the difference between bees and wasps is very significant.  Taking into account such differences can lead to the fact that with the "bees" and "wasps" will act differently.  For example, we are going to destroy the wasp nest, but if we are talking about bees, insects are much more useful and vulnerable, their nest, located in an unfortunate place, will probably be decided not to destroy, but to move somewhere. <br><br>  Similar freedom can be observed in the way we use the terms ‚Äúwebsite‚Äù and ‚Äúweb application‚Äù.  The differences between these concepts are much less obvious than the differences between real wasps and honeybees, but if these concepts are combined, this can lead to very unpleasant consequences.  Trouble begins when we allow ourselves to do something, depending on whether a certain project is ‚Äújust a website‚Äù or a ‚Äúfull-scale web application.‚Äù  If you create an informational site for a certain company, then most likely you will not rely on a powerful framework for managing DOM changes or for implementing routing on the client.  At a minimum, I hope so.  Using tools that are poorly suited for solving certain problems will not only harm those who will use the site, but will probably have a bad impact on the development process. <br><br>  When developing a web application, everything looks different.  We install packages, which is accompanied by adding hundreds, if not thousands, of dependencies to the project.  However, we are not even sure about the <a href="https://snyk.io/blog/malicious-code-found-in-npm-package-event-stream/">safety of</a> some of them.  We write complex configurations for bandlers.  When working in such an ubiquitous mad development environment, knowledge and attention are needed to make sure that what was collected was fast, that the project would work where it should work.  If you are in doubt, run the <a href="https://docs.npmjs.com/cli/ls.html">npm ls --prod command</a> in the root directory of your project and see if you can state the purpose of using <a href="https://gist.github.com/malchata/dae0a011033846e2cb44d315b0496f0d">everything</a> that this command displays.  Even if you can do this, it does not apply to third-party scripts.  I am sure that several such scripts are used in your project. <br><br>  We forget that both websites and web applications occupy the same ‚Äúecological niche‚Äù.  Both those and others are under the same influence of the environment, which consists of various networks and devices.  Such restrictions will not disappear if we decide to call what we are developing ‚Äúapplication‚Äù, and the devices of our users will not magically become much faster if we call the ‚Äúwebsite‚Äù ‚Äúapplication‚Äù. <br><br>  It is our responsibility to find out who uses what we create, we must take into account that the conditions in which different users connect to the Internet may differ from those we rely on.  When creating something, we must know the goal for the sake of which we create it, and after that we are engaged in the development of what helps to achieve this goal - even if the development turns out to be <a href="https://css-tricks.com/simple-boring/">not such a delightful occupation</a> . <br><br>  This means that we need to re-evaluate our dependence on JavaScript, and how its use, in particular at the expense of HTML and CSS, can lead us to use irrational patterns that are harmful to the performance and accessibility of web projects. <br><br><h2>  <font color="#3AC1EF">Don't let frameworks impose irrational patterns on you</font> </h2><br>  I witnessed the discovery of strange things in code bases when I worked with teams dependent on frameworks in order to help them be more productive.  Many similar finds have one thing in common, which is that the way they are written often leads to problems with the availability and performance of sites.  For example, consider the following React component: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { validateEmail } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"helpers/validation"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignupForm</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (props) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleSubmit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleSubmit.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateEmail = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.updateEmail.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.email = <span class="hljs-string"><span class="hljs-string">""</span></span>;  }  updateEmail (event) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({      <span class="hljs-attr"><span class="hljs-attr">email</span></span>: event.target.value    });  }  handleSubmit () {    <span class="hljs-comment"><span class="hljs-comment">//      -      if (validateEmail(this.state.email)) {      // ...    }  }  render () {    return (      &lt;div&gt;        &lt;span class="email-label"&gt;Enter your email:&lt;/span&gt;        &lt;input type="text" id="email" onChange={this.updateEmail} /&gt;        &lt;button onClick={this.handleSubmit}&gt;Sign Up&lt;/button&gt;      &lt;/div&gt;    );  } }</span></span></code> </pre> <br>  Here you can find several notable problems regarding the availability of the project: <br><br><ol><li>  A form that does not use the <code>&lt;form&gt;</code> element is no longer a form.  In fact, you can fix this by simply specifying the <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/Form_Role">role = "form" of</a> the parent <code>&lt;div&gt;</code> element, but if you create a form, and what we see definitely looks like a form, use the <code>&lt;form&gt;</code> element, adjusting it accordingly attributes <code>action</code> and <code>method</code> .  The <code>action</code> attribute plays an important role here, as it allows the form to do at least something, even if JavaScript is not available (of course, if the component was rendered on the server). </li><li>  The <code>&lt;span&gt;</code> not a substitute for the <code>&lt;label&gt;</code> , which provides some options regarding the availability of projects that <code>&lt;span&gt;</code> does not have. </li><li>  The <code>&lt;button&gt;</code> element without the <code>type="submit"</code> attribute is simply a button that, when clicked, invokes the event handler attached to it.  If we want to do something with the data before the form is <code>onSubmit</code> , the button needs to assign the <code>type="submit"</code> attribute, and move the code from the <code>onClick</code> event handler to the <code>onSubmit</code> form event handler. </li><li>  By the way, why use JavaScript to validate your email address, while HTML5 provides us with controls that support validation of entered data in almost all browsers - up to IE10?  Here we see the missed opportunity to use the functionality that already exists in the browser and apply the appropriate <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email">element type</a> , as well as the <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Forms/Form_validation">required</a> attribute.  However, when applying such constructions, keep in mind that adjusting their normal interaction with screen reading programs will require <a href="https://developer.paciellogroup.com/blog/2019/02/required-attribute-requirements/">some effort</a> . </li></ol><br>  Taking into account the above, we will refactor the component code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignupForm</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (props) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleSubmit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleSubmit.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } handleSubmit (event) {   <span class="hljs-comment"><span class="hljs-comment">//    ,         XHR   // (      ,     ,     JS).   event.preventDefault();   //  ‚Ä¶ } render () {   return (     &lt;form method="POST" action="/signup" onSubmit={this.handleSubmit}&gt;       &lt;label for="email" class="email-label"&gt;Enter your email:&lt;/label&gt;       &lt;input type="email" id="email" required /&gt;       &lt;button type="submit"&gt;Sign Up&lt;/button&gt;     &lt;/form&gt;   ); } }</span></span></code> </pre> <br>  Now that this component renders is not only more accessible, but also less JS code is used to implement the same functionality as before.  In a world that literally drowned in JavaScript, getting rid of a few lines of code should be perceived as something positive.  The browser gives us a <a href="https://alistapart.com/article/paint-the-picture-not-the-frame">lot of opportunities</a> , and we need to strive to use these opportunities as often as possible. <br><br>  I don‚Äôt want to say here that problems with accessibility of pages arise exclusively when using certain frameworks.  I mean that, overly relying on JavaScript, the developer will, in the end, simply miss out on a lot of important HTML and CSS features.  These gaps in knowledge often lead to mistakes, and, we are not even aware of these mistakes.  Frameworks can be useful tools that increase developer productivity, but continually exploring the capabilities of basic web technologies is extremely important in creating user-friendly, usable products, regardless of the supporting tools used in their development. <br><br><h2>  <font color="#3AC1EF">Rely on the capabilities of the web platform and ensure your projects a bright future.</font> </h2><br>  Since we are talking about frameworks, it should be noted that the web platform, in itself, is also a huge framework.  As was shown in the previous section, we find ourselves in a better position if we can rely on the established patterns of work with markup and on the capabilities of the browser.  The alternative to these standard features is to reinvent them.  Needless to say, such an ‚Äúinvention‚Äù is associated with considerable difficulties.  But what if such problems, each in its own way, would be solved by the authors of all the JavaScript packages we install? <br><br><h3>  <font color="#3AC1EF">‚ñçSingle-page applications</font> </h3><br>  One of the weaknesses of the developers, which they easily allow themselves, is to apply the Single Page Application (SPA) model even in those projects for which this model is not suitable.  Of course, such projects benefit from the fact that they are perceived by users as more productive due to the routing performed by the client‚Äôs means.  But what are the disadvantages of using the SPA model?  The browser‚Äôs built-in browsing capabilities, although built on a synchronous model, give the project a lot of advantages.  One of them is that the management of the history of visits is carried out through the implementation of <a href="https://html.spec.whatwg.org/">complex specifications</a> .  Users without JavaScript, <a href="https://kryogenix.org/code/browser/everyonehasjs.html">whether they have disabled it themselves or not</a> , will not lose the opportunity to work with the project.  In order for a one-page application to be available in browsers with disabled JavaScript, it suddenly turns out that you need to pay considerable attention to server rendering. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/522/b04/53d522b04f07c6c8e4fb377f620e5148.png"></div><br>  <i><font color="#999999">Comparison of different options for downloading an experimental application on a slow communication channel.</font></i>  <i><font color="#999999">The rendering of the application on the left is completely dependent on JavaScript.</font></i>  <i><font color="#999999">The application on the right is rendered on the server, but then it uses, on the client, the <a href="https://reactjs.org/docs/react-dom.html">hydrate ()</a> method to connect the components to the markup already created on the server.</font></i> <br><br>  Here you can see that the application, which is rendered on the client, shows the user a blank screen for a few seconds, and then displays the finished interface. <br><br>  An application that is rendered on the server and brought to a working state on the client rather quickly displays the main interface elements, but you can use it after about the same time as the application that is rendered entirely on the client. <br><br>  The availability of the application also suffers if the router located on the client cannot inform the user about what has changed on the page that he views.  This can force the user to rely on assistive technologies in order to find out about what exactly has changed on the page, as a result, the user‚Äôs work with the site becomes much more complicated. <br><br>  Further, here you can meet our old enemy - an excessive load on the system.  Some client routers are very small.  But if you make a project on <a href="https://bundlephobia.com/result%3Fp%3Dreact-dom%4016.8.2">React</a> , use a compatible <a href="https://bundlephobia.com/result%3Fp%3Dreact-router%404.3.1">router</a> , and, perhaps, a <a href="https://bundlephobia.com/result%3Fp%3Dredux%404.0.1">library</a> to manage the state of the application, this means that you have to accept that there will be a certain amount of service code in it, from which you can not escape.  Namely, in this case it is about 135 Kb of such code.  Carefully analyze the projects you create and whether client routing is worth the additional load on the system.  It usually happens that it is better to refuse client routing. <br><br>  If you are worried about the user's feelings, if you want the site to seem fast to him, then you can rely on the attribute of the links <a href="https://www.w3.org/TR/resource-hints/">rel = prefetch</a> , which allows you to organize early loading of documents from the same source.  Using this attribute has a tremendous impact on improving the performance of a project perceived by users, since the pages linked to this attribute, when clicked on these links, are instantly loaded from the cache.  In addition, since data preloading has a low priority, it is unlikely to compete for bandwidth with important resources. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/186/561/5a6/1865615a66b7643a81e2544c90b89644.png"></div><br>  <i><font color="#999999">The HTML code, which is written / written, is preloaded when visiting the main page of the site.</font></i>  <i><font color="#999999">When a user clicks on the appropriate link, the HTML code is instantly loaded from the browser's cache.</font></i> <br><br>  The main problem that may arise with the preloading of pages, and about which you need to know, is that such a load may be a waste of time and resources.  To solve it, you can, for example, use a small <a href="https://github.com/GoogleChromeLabs/quicklink">Quicklink</a> script from Google, which mitigates this problem.  It checks if the current client is using a slow connection, if the <a href="https://support.google.com/chrome/answer/2392284%3Fco%3DGENIE.Platform%253DAndroid%26hl%3Den">data-saving mode is on</a> , and, by default, avoids preloading materials from sources other than the page source. <br><br>  In order to make the site look fast in the eyes of users who repeatedly visit it, you can use <a href="https://adactio.com/articles/13796">service workers</a> .  They can be used regardless of whether the client is using a routing system or not, given that you are familiar with <a href="https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading">some of the features of</a> service workers.  By <a href="https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker">caching routes by</a> means of service workers, we get many of the same advantages that are typical for pre-loading materials of some links, but we have much more extensive possibilities for working with requests and responses.  Whether you perceive your site as an ‚Äúapplication‚Äù or not, equipping it with a service worker, perhaps an example of one of the most important options for using JavaScript from existing ones. <br><br><h3>  <font color="#3AC1EF">AvaJavaScript is not designed to generate layouts</font> </h3><br>  If we install a JS package designed for solving problems related to page layouts, then it‚Äôs time for us to exercise extreme caution and ask ourselves what we are trying to accomplish with this package.  CSS was created <a href="https://twitter.com/rachelandrew/status/1088870059240505344">specifically</a> for building page layouts, in order to use it effectively, no abstractions are needed.  Most of the tasks of building layouts that try to solve with JavaScript tools, like <a href="https://www.npmjs.com/package/flexibility">placing</a> elements, aligning them, adjusting their sizes, like <a href="https://www.npmjs.com/package/shave">managing text,</a> or even completely <a href="https://www.npmjs.com/package/lost">creating layouts</a> with JavaScript, these days can be solved using CSS.  Modern tools for creating layouts like Flexbox and Grid are well supported by browsers, so we do not need to develop projects based on frameworks for working with layouts.  By the way, CSS is after all a framework too.  When we have at our disposal such an opportunity as <a href="https://hacks.mozilla.org/2016/08/using-feature-queries-in-css/">property inquiries</a> , the progressive improvement of layouts to support new tools for their formation, as it turns out, is <a href="https://hacks.mozilla.org/2016/08/using-feature-queries-in-css/">not such a difficult task</a> . <br><br><pre> <code class="plaintext hljs">/*   , ,   ,        CSS Grid. */ /*  @supports  ,     CSS Grid,     . */ @supports (display: grid) { /*      */ @media (min-width: 40em) {   /*       CSS Grid */ } }</code> </pre> <br>  Using the capabilities of JavaScript to solve the problems of creating page layouts and customizing their appearance is not new.  This is what we did in 2009 when we lived in an atmosphere of self-deception, saying that each site should look the same in IE6 as in the more advanced browsers of the time.  If today, in 2019, we continue to develop websites so that they look the same in all browsers, this means that we need to revise our goals.  There will always be some browsers that need to be supported and that do not have the same capabilities as the most modern browsers.  The complete external similarity of projects on all platforms is not only a waste of energy, it is also the principal enemy of the idea of <a href="https://alistapart.com/article/understandingprogressiveenhancement">progressive improvements</a> . <br><br><h2>  <font color="#3AC1EF">Results: I'm not going to be a JavaScript killer</font> </h2><br>  Do not get me wrong, I do not belong to the enemies of JavaScript.  Thanks to this language, I built a career, and, frankly, JavaScript, for more than ten years, brings me a lot of pleasure.  As happens in any long-term relationship, the more time I spend working with JavaScript, the better I will know it.  This is a mature language with many possibilities, which is getting better every year. <br><br>  However, sometimes it seems to me that in our relationship with JavaScript something went wrong.  I criticize him.  Or, more precisely, I criticize the current tendency to consider JavaScript to be the main tool for site building, which is resorted to first of all, not looking at anything else.  When I analyzed another bundle that looked like a tangled Christmas garland, it became clear to me that the web was intoxicated with JavaScript.  We use this language for almost any reason, even in cases where circumstances do not require it.  Sometimes I think about how serious the consequences of such an attitude towards JS can be. <br><br>  I plan to keep writing about javascript and web development, and keep looking for ways to make better use of web technologies.  Hopefully together we will make the modern web better. <br><br>  <b>Dear readers!</b>  Do you think the modern web is really overloaded with JavaScript code? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/turbo_vps/"><img src="https://habrastorage.org/webt/b4/fn/f5/b4fnf52x9i3mn80tttdafqtvkfe.jpeg"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/447576/">https://habr.com/ru/post/447576/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447564/index.html">Changes to repository authorization on GitLab.com</a></li>
<li><a href="../447566/index.html">Scientists first showed the real "photo" of the black hole</a></li>
<li><a href="../447568/index.html">Interview with cosmonaut Alexander Laveykin about space cinema, overload in 20 units and soft landing</a></li>
<li><a href="../447570/index.html">GoLand 2019.1: Code Performance Analysis, Smart Step Into, Extract Interface Refactoring, Nilness Analyzer, and more</a></li>
<li><a href="../447574/index.html">Notes freelancer: the development of the first React Native-application</a></li>
<li><a href="../447578/index.html">Accelerate JavaScript using Set data type</a></li>
<li><a href="../447580/index.html">Threat Hunting, or How to defend against 5% of threats</a></li>
<li><a href="../447582/index.html">Rusatom: 3D metal printing in Russia</a></li>
<li><a href="../447584/index.html">Anatomy of the "Space Data Center". Sky-high server: look under the hood</a></li>
<li><a href="../447586/index.html">Advanced string interpolation in Swift 5.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>