<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write a simple solver tsumego</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About a year ago, a friend showed me what a go is and how it is played. I remember well how in one of the first games I proudly built a chain of stone...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write a simple solver tsumego</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/559/c01/0fd559c0131b7de24d690bd13652396a.jpg" alt="goban 2 by 2" align="left">  About a year ago, a friend showed me what a go is and how it is played.  I remember well how in one of the first games I proudly built a chain of stones that connected the bottom side of the board with the top one, as well as the chain connecting the left side with the right one, to which a friend told me that it was nice, but I lost.  It took me a long time to understand why.  Since then I have progressed to about the first dan of KGS, and a friend stopped playing with me. <br><a name="habracut"></a><br>  In order to play well go it is necessary to see several moves ahead, and this skill well develops a solution of which he has a lot of goproblems.  Naturally, once the thought came to me that it would be nice to write the solution to these things and, ideally, embed it in goproblems, especially since adum approves of this idea.  Since I myself solve tsumogo with a very unhurried search of more or less meaningful moves with a speed of somewhere 1 move in a couple of seconds, while regularly forgetting what the search began with (and this is enough to confidently solve problems 3 is given), I figured with what incredible speed and accuracy will work the simplest search in depth, I mean dfs, and I estimated the complexity of the task as ‚Äúfor a couple of days‚Äù.  Immediately, I tried to quickly write this reshalker "on the forehead" through the simplest dfs and came across a minor nuisance: in the process of searching, the same positions were encountered many times and recounting them again was somehow completely non-optimal, even for a quick solver.  Without thinking, I started a cache to store already resolved positions and immediately came across another nuisance: the solution found once may be wrong if another position comes in this position with a sequence of moves.  I hung up here, not knowing what to do, but I decided that this trouble was easily solved - I just had to think a little.  I thought for quite a long time and decided that it makes sense to look at what is already ready on this topic - articles, algorithms, etc.  First of all, I came across a kind of ‚Äúlambda depth first proof number search‚Äù and seeing that the size of the article was only a few pages, I began to read with delight.  The article contained references to other similar articles by Martin Muller and Akiro Kishimoto, in those articles there are more links, there appeared a link to the 200-page dissertation of Kishimoto, and then I realized the scale of the problem: the solution of even very simple ones was so algorithmically complex that in most cases, the question is not even about how to sort through all the options, but how to find the total on the board (what even a novice player does in a second), how to understand what needs to be captured or defended (also trivial for a person) and what moves have  The value (also in most cases obvious), and if it came to actually sorting through the options, then we can say that it‚Äôs decided (although the efficient brute force algorithm is extremely intricate).  In general, I realized that my IQ is clearly not enough to solve this problem on the move and I decided that it would be nice if I could at least write a solver for the simplest case when all meaningful moves and goals are set in advance - even this will be very useful on goproblems. <br><br>  As far as I know, there are quite a few programs that solve the problem: <br><br>  - Thomas Wolf GoTools: up to 15 possible moves, closed code, rectilinear dfs with very advanced static analysis. <br>  - Tsumego Explorer Martin M√ºller (which, by the way, is 7 dan): up to 30 possible moves, open source Java (although it‚Äôs not clear where to get), advanced l-df-pn-r search with very advanced static analysis described in the articles by Muller and thesis Kishimoto. <br>  - Martin M√ºller's Fuego: a full 2+ bot is given (I can‚Äôt appreciate its power because it‚Äôs obviously stronger than me) with open source in C ++ (available on SourceForge). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Neither Muller nor adum heard about any js solvers (and the solver should be on js so that it can be embedded in goproblems), and if so, then it makes sense to try to write it ‚Äî especially since Muller and Kishimoto wrote many articles and even programs on this topic. <br><br> <a href="http://www.goproblems.com/18629"><img src="https://habrastorage.org/files/ac0/b09/5b0/ac0b095b015b49b1b64e09cff0d75f5f.png" alt="Problem number 18629, 1st dan" align="left"></a>  Left typical tsumego.  In the general case, the task is to find the best move (and if it is needed at all) for both black and white.  Obviously, if whites go first, they capture the corner.  If black goes first, they can keep the corner, but one of the decisions leads to ko and if black loses ko, they lose the angle, and the other solution keeps the angle without any ko, which is generally preferable. <br><br>  For simplicity, we will assume that there is a certain way to look at the board and find out all meaningful moves that need to be searched for a solution (in fact, this means that all such moves will be set manually).  We define the function R which says who wins on the board b: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/cc6/320/972/cc63209721b471ebec4c1b52705d0583.png">  if black starts and wins. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/4e3/ea4/8854e3ea49e5c08bc583aa8a6328f30a.png">  if black starts and loses. </li></ul><br><br>  By definition, R, black is obliged to make the first move, even if he breaks the balance in the seki - this allows you to eliminate the situation in which white and black constantly fold.  Similarly for whites.  If both black and white are losing, these are seki.  Then this function can be recursively defined as: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce7/ad2/32c/ce7ad232cb3d7c932e892a3fe4c43cd1.png"><br><br>  It looks a bit confusing, but its essence is simple: <br><br><ol><li>  By definition R, blacks are forced to make some kind of move, so they choose the best among all possible moves.  Hence the maximum in all moves m. </li><li>  Then the move goes to white and they can decide to make a move or not to do - hence the minimum.  If White makes a move, the result will be <img src="https://habrastorage.org/getpro/habr/post_images/317/2fb/e73/3172fbe73531d3e0f2ead9f0c93a5a53.png">  where b + m is the b board to which was added a black stone m. </li><li>  If White misses a move (and this does not contradict the definition of R), then Black has a choice: to make a move or also to fold, which will complete the game - hence the second maximum.  If black makes a move, it turns out <img src="https://habrastorage.org/getpro/habr/post_images/66b/7a0/a2c/66b7a0a2c2aebfe328268b3afa90bed6.png">  if they pass, then R (b + m) determines who won (in practice, this is just a check to see if there is a stone on the board that should have been captured). </li></ol><br><br>  Symmetric formula is obtained for whites.  If you count it ‚Äúin the forehead,‚Äù you will get a straight dfs with an enumeration of all the options, which even for the simplest of 5 points works very slowly.  You can write it like this: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board: Board, color: Color</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = -color; <span class="hljs-comment"><span class="hljs-comment">// that's a loss for (const move of board.getMovesFor(color)) { const nextBoard = board.fork().play(move); result = bestFor(color, // it's +color's turn, so he chooses result, bestFor(-color, // now it's -color's turn solve(nextBoard, -color), // -color makes a move bestFor(color, // -color can pass, but then it's +color's turn again solve(nextBoard, color), // +color makes two moves in a row estimate(nextBoard)))); // neither player makes a move } return result; }</span></span></code> </pre> <br><br>  Please note that this algorithm will waste a lot of time on proving that the simplest seki is seki.  If the white and black groups have only common freedoms and there are many of these freedoms, then this algorithm will first try to play on the first freedom, find out what to win does not work, then play on the second freedom and find out again what cannot be won, etc.  You can even make up a simple recursive formula for the number of moves that this algorithm makes to sort through all the options.  Growth is more than exponential.  This problem can probably be solved only by static analysis. <br><br>  Now we need to make sure that the same board is not solved twice.  For example, having found once a solution for a 5-point nakad, you can reuse it if another position comes down to that nakad.  Such a solution cache is usually called a transposition table (tt).  The key in this table is the hash of the board + the color of the one who goes first.  At first, I naively implemented it something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tt: { [key: string]: Result } = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">board: Board, color: Color</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = color + board.hash(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = -color; <span class="hljs-comment"><span class="hljs-comment">// that's a loss if (key in tt) return tt[key]; for (const move of board.getMovesFor(color)) { const nextBoard = board.fork().play(move); result = bestFor(color, // it's +color's turn, so he chooses result, bestFor(-color, // now it's -color's turn solve(nextBoard, -color), // -color makes a move bestFor(color, // -color can pass, but then it's +color's turn again solve(nextBoard, color), // +color makes two moves in a row estimate(nextBoard)))); // neither player makes a move } return tt[key] = result; }</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/b2a/25e/964/b2a25e964920413684bbd875cf9bc3bb" align="left">  The problem with this code is that there are positions whose solution cannot be determined simply by looking at the location of the stones.  For example, on the left, White‚Äôs move, but it is impossible to understand who wins, because it is unclear whether White can capture the black stone (ie, a typical ko or a two-stroke cycle).  This minor amendment to the rules - you cannot repeat the position - is taken for granted during the game and does not cause any difficulties, and the super-ko rule (i.e., prohibiting cycles of several moves in length) was invented to resolve a situation that might not meet in your life even if you play ten games every day.  Strangely enough, even the hypothetical possibility of the existence of cycles with a length of several moves (moves that way in 5-7) is certainly realized during an algorithmic search and if this is not taken into account, then either the result will be wrong or the algorithm will loop.  So this seemingly virtual problem won Kisimoto‚Äôs thesis ‚ÄúThe Correct and Efficient Search Algorithms in The Presence of Repetitions‚Äù by as much as 200 pages (I‚Äôm trying to master it myself). <br><br>  The solution to this problem is mentioned many times in the articles by Muller and Kishimoto and it sounds like this: if there were no repetitions in the search for a solution, then it does not depend on the way in which you came to this position.  If you think about it, the statement is not at all obvious.  When I got tired of inventing evidence, I wrote to Muller and he said that yes, this is a very strong and universal statement and his proof seemed to be somewhere in the dissertation.  I couldn‚Äôt find this evidence there, but I thought of my own, which works if we assume that all already-decided and independent solutions are never deleted (due to lack of memory). <br><br><img src="https://habrastorage.org/files/458/556/d06/458556d06b774bc39ae7ae51a65862d6" align="left">  For illustration, I shamelessly copied a picture from someone :) The graph of possible moves usually looks like this tree in the picture.  The top in this graph is the location of the stones on the board, and the color indicates who makes the move.  For simplicity (and without breaking the generality), we assume that position 13 was solved earlier and it turned out that Black starts and wins, while no cycles were found in the search process.  The solution is a tree (because there is no), in which from each black vertex it leads one move (more is not necessary because the essence of the decision is to show the correct move in any position), and from each white vertex all possible moves lead (solution must prove that for every move of whites there is a move of black which leads to the victory of black).  Now suppose that the statement is not true and the solution found for position 13 depends on the way in which it gets into it, i.e.  there is some way that somehow makes the decision wrong.  If such a path did not intersect with the decision tree, then it would not be able to influence it - then this hypothetical path contains at least one vertex of the tree.  Take this top of some kind and try to go along this path to the top of 13 without forgetting that <br><br><ol><li>  the solution for 13 is already stored in the cache and what </li><li>  all intermediate solutions that were also found without detecting the cycles remained in the cache. </li></ol><br><br>  Suppose that we start from vertex 17 and try to get to 13. The essence of the proof is that since there are no cycles in the decision tree, then for connecting 17 to 13 you need to go beyond the tree, which is impossible.  Vertex 17 is white (well, yes, it is red, but we will assume that it is white) and therefore all the moves from it are in the tree: we make any move from 17 and still remain in the decision tree.  Suppose we hit the 25 - black peak.  Since the vertex is black, the solution (the right move) for it is written in the cache (from which nothing is ever removed), and since we are following this hypothetical path after the solution for 25 was found, we have to take the ready solution from the cache and get to the white top which is still in the tree.  So we go on this hypothetical way until we find ourselves at an impasse where there are no moves. <br><br>  As you can see, in order to solve the problem with cycles, you need quite a bit: <br><br><ol><li>  Search for a solution for the path, not for the position: solve (path: Board [], color: Color). </li><li>  If in the process of searching we stumble upon a repetition, we consider it as a defeat, but at the same time we point to the peak in the path that repeats (just remember the index in the path).  The meaning of the pair (result, index) is that the decision is not unconditional, but depends on repetition with a certain position. </li><li>  If among all possible moves, all lead to defeat, we find the minimum among all indices indicating repetition and return this minimum. </li><li>  If there are winning moves, then it is preferable to choose one with a repetition index as high as possible.  At best, the gain will be unconditional, i.e.  do not depend on the way. </li></ol><br><br>  This (and simple heuristics that maximizes the freedom of its stones and minimizes the freedom of others) is enough to solve the simplest carpenter square. <br><br>  To solve something more interesting, like the first one, you need to be able to take into account ko.  One possible approach is to take the ‚Äúdynamically‚Äù into account, i.e.  if a repetition occurs in the search process, branch the search into two cases (when there is a threat to and when it is not), but for this you have to thoroughly shovel the whole code.  Another approach is ‚Äústatic‚Äù accounting for: <br><br><ol><li>  The new parameter is the number of external threats.  Let's say if this parameter equals +3, then Black has three ko more threats, and if -2, then White has two ko more threats. </li><li>  If there is a repetition in the decision process and there is a threat to this repetition, it is wasted, the path is reset (in fact, the goal of the threat is to clear the path and start the search as if from scratch). </li><li>  Decisions in the cache are not written as a single number (+1 or -1), but an infinite array of numbers in both sides, where for each number of threats there is a result: for -2 kos, whites win, if White only has 1 k threat, then it turns out the seki, and if ko there are no threats, then black wins.  Obviously, if black wins with N co-threats, then with N + 1 they will also win.  Similarly for whites.  This shows that the solution can be written in the form of two numbers: the number of co-threats that is black enough to win (maxb), and the number of co-threats that is white enough to win (minw).  Then if we are looking for a solution for position b with k k threats and minw and maxb are known for b from previous solution attempts, then we can immediately return the answer for k &lt;minw (white win) and for k&gt; maxb (black win), and for minw &lt;k &lt;maxb need to look for a solution. </li></ol><br><br><pre> <code class="javascript hljs">interface Results { <span class="hljs-attr"><span class="hljs-attr">minw</span></span>: number; <span class="hljs-comment"><span class="hljs-comment">// white wins if nkt &lt;= minw maxb: number; // black wins if nkt &gt;= maxb } const tt: { [key: string]: Results } = {}; function solve(path: Board[], color: Color, nkt: number): Result { function solveFor(color: Color, nkt: number): Result { const board = path[path.length - 1]; const key = color + board; const cached = tt[key] || { minw: -Infinity, maxb: +Infinity }; if (color &gt; 0 &amp;&amp; nkt &gt;= cached.maxb) return +1; // black has enough ko treats to win if (color &lt; 0 &amp;&amp; nkt &lt;= cached.minw) return -1; // white has enough ko treats to win var result = -color; // that's a loss var depth = Infinity; // where repetition occured /* ... */ if (color &gt; 0 &amp;&amp; nkt &lt; cached.maxb) cached.maxb = nkt; if (color &lt; 0 &amp;&amp; nkt &gt; cached.minw) cached.minw = nkt; tt[key] = cached; return [result, depth]; } return solveFor(color, nkt); }</span></span></code> </pre><br><br>  Now, to solve the problem taking into account external threats, we must first solve it under the assumption that there are no threats (nkt = 0) and continue to increase or decrease this parameter as long as this can change the result.  This, theoretically, can be determined by a solution graph: if the solution found depends on the lost ko, then it makes sense to add one external threat and then solve it again.  Practically, I did not do this, and the number of necessary threats is extremely rarely more than 1, i.e.  there are problems in which you need to win two co to solve, but this is exotic, so if you solve tomgogo for | nk2 | &lt;2, then you can say that the problem has been solved.  It should be noted that 99% of the time it takes to find the first solution (usually for nkt = 0) which fills the cache (tt) after which the solutions for the other nkt are found almost instantly (even on JS). <br><br>  That's all.  Such a simple solver on JS without any optimizations that creates temporary objects for every sneeze (which it loads with GC), and before each move it copies the entire board, is able to quickly, in a few seconds, solve a sum with 10 free cells (like what I showed at the beginning).  On a bit larger, it just hangs and will load the GC most of the time.  However, in optimizations of this kind, I still do not see the point, because there are a lot of ways to make the algorithm itself faster: <br><br><ul><li>  Apply advanced depth search: dfpn, dfpnr, ldfpnr.  Muller writes that ldfpnr can overpower a sum with 27 free cells, which is a lot. </li><li>  Write static analysis algorithms - I haven't even implemented the Benson algorithm yet.  This will stop the search when it is already clear who won.  This is probably the main reason for the fact that we can solve this problem so quickly: usually the search for a solution in the mind looks like a search of several short sequences completed by the assessment ‚Äúwell, well, here, obviously, White is captured.‚Äù </li><li>  Think of how to look for the summit on the board and where to make the moves.  To do this, it is necessary to ‚Äúonly‚Äù carefully observe our own thinking and understand exactly how we find the sum.  The key to such a search, of course, is the assessment of the survivability of the group (a handful of closely spaced stones) which is based on determining whether the group can make two eyes: the sum is always near a weak and relatively large group (so that it makes sense to capture or save). </li><li>  Make a certain library of tricks (tesuji): squeeze, wedge, snapback, ladder, net, etc.  These tricks play a huge role in finding a solution in the mind: we don‚Äôt count every time all possible options to find a snapback - we just notice a characteristic combination of stones and check whether something can be ‚Äúsqueezed out of this trick.‚Äù </li></ul><br><br>  Who <a href="">cares</a> , you can see the code on <a href="">github</a> .  There, frankly, everything needs to be rewritten as soon as I understand how to organize the solver code so that it is broken into modules without sacrificing speed, and so that later it can be connected to modules responsible for static analysis, for recognizing seki, for different tricks etc.  Well, so that you can write unit tests - otherwise, after each change, I think ‚Äúdoes this crap still work?‚Äù </div><p>Source: <a href="https://habr.com/ru/post/260935/">https://habr.com/ru/post/260935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260923/index.html">Access rights - the owner can do anything</a></li>
<li><a href="../260927/index.html">What is Master Data and why is it needed?</a></li>
<li><a href="../260929/index.html">7 web design trends in the near future</a></li>
<li><a href="../260931/index.html">Jii - a JavaScript framework with architecture from Yii 2</a></li>
<li><a href="../260933/index.html">Zombie hunt from the cloud</a></li>
<li><a href="../260941/index.html">Google broke GCM in Chrome</a></li>
<li><a href="../260943/index.html">Intel Edison on guard of health. Experience "FRUIT MD"</a></li>
<li><a href="../260945/index.html">What you need to know about working with text preview emails</a></li>
<li><a href="../260947/index.html">Monitoring and alerting about events in Windows logs: sending to E-mail in Windows Server 2012 R2</a></li>
<li><a href="../260949/index.html">Why is programming so hard?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>