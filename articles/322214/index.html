<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of transactional microservices using Aggregates, Event Sourcing and CQRS (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the completion of a translation article on the development of transactional applications using the microservice architecture. Start 

 In the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of transactional microservices using Aggregates, Event Sourcing and CQRS (Part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/7a2/e79/788/7a2e797887c746849ef5091e2fd7c15f.jpg"><br><br>  <i>This is the completion of a translation article on the development of transactional applications using the microservice architecture.</i>  <i><a href="https://habrahabr.ru/company/nixsolutions/blog/321686/">Start</a></i> <br><br>  In the first part of the article, we said that the main obstacle in using the microservice architecture is that domain model (domain model), transactions and requests are surprisingly resistant to separation according to a functional basis.  It was shown that the solution is to implement the business logic of each service in the form of a set of DDD units.  Each transaction updates or creates a single aggregate.  Events are used to maintain data integrity between aggregates (and services). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the second part of the article we will see that the key task in using events is the atomic change of the state of the aggregate and the simultaneous publication of the event.  Let's see how to solve this problem using Event Sourcing - using an event-oriented approach to designing business logic and state saving systems.  After that, we describe how the microservice architecture makes it difficult to implement queries to the database, and how the approach, called Command Query Responsibility Segregation (CQRS), helps implement scalable and productive queries. <br><a name="habracut"></a><br>  Key points: <br><br><ul><li>  Event sourcing is a mechanism for reliably changing state and publishing events that allows you to overcome the limitations of other solutions. </li><li>  Event-oriented approach using Event Sourcing, is in good agreement with the microservice architecture. </li><li>  Snapshots can improve the performance of requests for the state of aggregates by combining all the events that occurred before a certain point in time. </li><li>  Event sourcing can create problems for queries, but they are overcome with the help of CQRS and materialized views. </li><li>  Event sourcing and CQRS do not require any special tools or software; many existing frameworks can take on some of the necessary low-level functionality. </li></ul><br><h2>  Reliable status update and event publishing </h2><br>  At first glance, ensuring consistency between the aggregates through events seems a fairly simple task.  A service, creating or updating an aggregate in a database, simply publishes an event.  But there is a problem: updating the database and publishing the event must be done atomically.  For example, if something broke after updating the database, but before the event was published, the system would be in an unstable state.  The traditional solution in this case are distributed transactions involving a database and a message broker.  But, for the reasons described in the first part of the article, distributed transactions are not a viable option. <br><br>  There are several ways to solve this problem without using distributed transactions.  For example, you can use a message broker (like <a href="https://kafka.apache.org/">Apache Kafka</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/114/bb8/124/114bb8124ed2411886e7ab2574608976.png"></div><br>  A separate recipient of messages subscribes to the broker's messages, and upon receiving them, updates the database.  This approach ensures that both the database is updated and the event is published.  Its disadvantage is that it is a much more complex consistency model, in which the application cannot immediately read what it sent itself to write to the database. <br><br>  Another solution can be the <a href="http://microservices.io/patterns/data/transaction-log-tailing.html">Transaction log tailing pattern</a> : take entries from the transaction log, convert them to events, and send them to the message broker.  An important advantage of this approach is that it does not require any changes to the application.  The disadvantage, however, is that this can make it difficult to reverse-engineer high-level business events ‚Äî the reason for updating the database ‚Äî from low-level changes to rows in tables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c7c/500/40a/c7c50040a1434cb5ad5ca2501a026a27.png"></div><br>  The third solution is to use a database table as a temporary message queue.  When a service updates an aggregate, it adds an event to a special table in the EVENTS database within a local transaction.  A separate process periodically scans the EVENTS table and publishes events by sending them to a message broker. <br><br>  A nice feature of this solution is that the service can publish high-level business events.  Disadvantage: this approach is potentially error prone since the event publishing code must be synchronized with the business logic. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aba/d46/3a6/abad463a6fec40f087bfdcef4e0d6b96.png"></div><br>  All three options have significant drawbacks.  Publishing events through a message broker with a pending database update does not provide the conditions for the Read-your-writes model.  Publishing events based on the transaction log provides consistency in reading data, but it cannot always publish high-level business events.  Using a database table as a message queue ensures consistency in reading and publishing high-level business events, but implies that the developer must remember to publish the event when the state changes. <br><br>  Fortunately, there is another solution.  This is an event-oriented approach to state preservation and business logic, known as Event Sourcing. <br><br><h2>  Development of microservices using Event Sourcing </h2><br>  Event sourcing is an event-oriented approach to state preservation.  This is not a new idea.  I first learned about Event Sourcing more than five years ago, but it remained a wonder until I started developing microservices.  Event sourcing was a great way to implement an event-oriented microservice architecture. <br><br>  A service that uses Event Sourcing stores the state of the aggregates as a sequence of events.  When an aggregate is created or updated, the service stores one or more events in a special event store in the database. <br><br>  To get the current state of the unit, the events are downloaded and played back.  In terms of functional programming, the service reconstructs the current state of the aggregate by performing the fold / reduce functionality on events.  Since events are now a state, we no longer have problems with the atomicity of state updates and the publication of events. <br><br>  Consider, for example, the service Order.  Instead of storing each order as lines in the ORDERS table, it stores each unit Order as a sequence of events, such as <i>Order Created</i> , <i>Order Approved</i> , <i>Order Submitted</i> , etc.  Here's how it could be stored in an online store on a SQL database. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ea4/47d/1af/ea447d1afb604711809df68e579d1ff3.png"></div><br>  The columns entity_type and entity_id columns are aggregate identifiers. <br>  event_id is the event identifier. <br>  event_type is an event type. <br>  event_data - serialized event attributes in JSON format. <br><br>  Some events contain a lot of data.  For example, the <i>OrderCreated</i> event contains order composition information, billing information, and shipping information.  The <i>Order</i> event <i>sent</i> contains a minimum of information and is simply a transition between states. <br><br><h2>  Event Sourcing and Event Publishing </h2><br>  Strictly speaking, Event Sourcing simply stores the state of the aggregates as events.  It is very easy to use as a reliable mechanism for publishing events.  Preserving an event is by its nature an atomic operation, which ensures that the event repository will provide access to events to all interested services.  For example, if events are stored in the EVENTS table mentioned above, then subscribers can simply periodically poll the table for new events.  More complex event repositories will use a different approach, which gives similar guarantees, but is more productive and scalable.  For example, <a href="https://github.com/eventuate-local">Eventuate Local</a> uses the Transaction log tailing pattern.  It reads events inserted into the EVENTS table from the MySQL replication stream, and publishes them using Apache Kafka. <br><br><h2>  Using state snapshots to improve performance </h2><br>  The <i>Order</i> unit is characterized by a relatively small number of transitions between states, and therefore it has only a small number of events.  In this case, the request from the event storage and the reconstruction of the current state of the <i>Order</i> aggregate will be effective.  However, some units have a large number of events.  For example, a <i>Client</i> unit may potentially have multiple Credit Reserved events.  Over time, their loading and processing would become inefficient. <br><br>  A common solution is to periodically save the state of the aggregate snapshot.  The application restores the state of the aggregate by loading the last snapshot and only those events that have occurred since its creation.  In terms of functional programming, the snapshot is the initial value for fold / reduce.  If the aggregate has a simple, easily serializable structure, then the snapshot may be, for example, in JSON format.  Pictures of more complex units can be made using the <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Memento</a> pattern. <br><br>  For example, the <i>Client</i> unit in an online store has a very simple structure: customer information, its credit limit, and data on the reservation of its loan funds.  A <i>Client</i> snapshot is simply a collection of its state data in JSON format.  The figure shows how to recreate the state of the <i>Client</i> from the snapshot corresponding to the state of the <i>Client</i> at the time of receipt of the event 103. The client service simply needs to load the snapshot and process the events that occurred after the 103rd. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/643/1b7/84e/6431b784ebe2488882dbbb92e5da2d0f.png"></div><br>  <i>The client service recreates the state of the client, deserializing the snapshot JSON, and then loading and processing events 104 through 106.</i> <br><br><h2>  Implementing Event Sourcing </h2><br>  The event store is a hybrid database and message broker.  It is a database because it has an API for inserting and retrieving event aggregates using the primary key, but it also has a message broker because it has an API for subscribing to events. <br><br>  There are several different ways to implement an event store.  One of them is to create your own event sourcing framework.  You can, for example, save events to RDBMS.  This is a simple, albeit low-performing way to post events.  Subscribers simply periodically poll the table EVENTS for new events. <br><br>  Another option: use a special event repository, which, as a rule, provides a rich set of functions, higher performance and scalability.  Greg Young, a pioneer in event sourcing, created an .NET open source event repository called the Event Store (https://geteventstore.com).  <a href="http://www.lightbend.com/">Lightbend</a> , formerly known as Typesafe, developed the <a href="https://www.lightbend.com/lagom">Lagom</a> microservice framework based on event sourcing.  It is possible to note the startup <a href="http://eventuate.io/">Eventuate</a> , which has an event sourcing framework, which is available as a cloud service, is an open source project and uses Kafka and RDBMS. <br><br><h2>  Advantages and disadvantages of Event Sourcing </h2><br>  Event sourcing has both advantages and disadvantages.  The main advantage of the approach is that events are guaranteed to be published whenever the state of the aggregate changes.  This is a good foundation for an event-driven microservice architecture.  In addition, since each event can record the identity of the user who made the changes, event sourcing provides an audit log that is guaranteed to be accurate.  The event flow can be used for other purposes, including sending notifications to users. <br><br>  Another advantage of event sourcing is the storage of the entire history of each unit.  You can easily implement temporary requests that return the state of the aggregate to the past.  In order to determine the state of the aggregate at a particular point in time, you simply need to handle the events that occurred before that moment.  For example, you can easily calculate a client's available credit at some point in the past. <br><br>  By saving the event rather than the aggregate itself, Event sourcing usually avoids the problem of ‚Äúloss of compliance‚Äù (impedance mismatch).  Events tend to have a simple, easily-serializable structure.  Through serialization, a service can take a snapshot of the state of a complex aggregate.  The Memento pattern adds a level of indirection between an aggregate and its serialized representation. <br><br>  However, in event sourcing technology, not everything is so smooth, and it has some drawbacks.  This is another, unusual programming model that needs to be studied.  In order for an existing application to start using event sourcing, you need to rewrite its business logic.  Fortunately, this is quite a mechanical transformation that can be done when transferring an application to a microservice structure. <br><br>  Another disadvantage of event sourcing is that the message broker usually guarantees at least one delivery.  Event handlers that are not idempotent should independently detect and reject repetitive events.  In this case, event sourcing framework can help by assigning an auto-incrementing identifier to each event.  The event handler can then detect duplicates by tracking the maximum identifier for the events it has already processed. <br><br>  Another problem of event sourcing is that the pattern of events (and snapshots!) Will evolve over time.  Since events are saved forever, the service may need to process events corresponding to several different versions of the circuit to reconstruct the state of the aggregate.  One way to simplify the service is to force the event sourcing framework to bring all events to the latest version of the schema when it loads them from the event store.  As a result, the service will only need to process only the latest version of events. <br><br>  Another disadvantage of event sourcing is that querying an event store can be a complex task by itself.  Imagine that you need to find customers who are worthy of a loan with a low credit limit.  You can‚Äôt just write SELECT * FROM CUSTOMER WHERE CREDIT_LIMIT &lt;?  AND CREATION_DATE&gt;? .. There is no column containing a credit limit.  Instead, you should use a more complex and potentially inefficient query containing nested SELECTs to calculate the credit limit by processing the event, setting the initial credit limit and then changing it.  To make matters worse, NoSQL event repositories usually support searching only by the primary key.  Therefore, you must implement queries using the Command Query Responsibility Segregation (CQRS) approach. <br><br><h2>  Implementing Queries with CQRS </h2><br>  Event sourcing is one of the main obstacles to the implementation of effective queries in the microservice architecture.  However, this is not the only problem.  Consider, for example, a SQL query that finds new customers who have placed expensive orders. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> CUSTOMER c, <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> o <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.id = o.ID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> o.ORDER_TOTAL &gt; <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> o.STATE = <span class="hljs-string"><span class="hljs-string">'SHIPPED'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.CREATION_DATE &gt; ?</code> </pre> <br>  In the microservice architecture, you cannot join the CUSTOMER and ORDER tables in one query.  Each table belongs to its own service and is available only through the API of this service.  You cannot write traditional queries that join tables belonging to different services.  Event sourcing exacerbates the situation by making it difficult to write simple direct requests.  Let's look at the method of implementing requests in the microservice architecture. <br><br><h2>  Use CQRS </h2><br>  A good way to implement queries is to use an architectural pattern known as Command Query Responsibility Segregation ( <a href="http://microservices.io/patterns/data/cqrs.html">CQRS</a> ).  The application is divided into two parts: <br><br><ol><li>  the command part processes commands (for example, HTTP POST, PUT, DELETE) to create, update and delete aggregates.  Of course, these units are implemented using Event sourcing. </li><li>  The request part of the application processes requests (for example, HTTP GET), requesting one or more materialized views of the aggregates.  The request part maintains views synchronized with aggregates by subscribing to events published by the command part. </li></ol><br>  Depending on the requirements, the request part of the application may use one or more of the following databases: <br><table><tbody><tr><th>  If you need </th><th>  Then use </th><th>  for example </th></tr><tr><td>  Search JSON objects by primary key </td><td>  A document- <a href="https://www.mongodb.com/">oriented</a> database, for example, <a href="https://www.mongodb.com/">MongoGB</a> , or a key-value data repository, for example, <a href="https://redis.io/">Redis</a> . </td><td>  Implementing an order history using a MongoDB customer document containing all of its orders. </td></tr><tr><td>  Regular search for JSON objects </td><td>  Document-oriented database, for example, MongoGB. </td><td>  Implementing a view for clients using MongoDB. </td></tr><tr><td>  Full text search </td><td>  Full-text search engine, for example, <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a> . </td><td>  Implement full-text search in orders using Elasticsearch documents for each order. </td></tr><tr><td>  Graph query </td><td>  Graph database management system, for example, <a href="https://neo4j.com/">Neo4j</a> . </td><td>  Implement a fraud detection system using customer graph, orders and other data. </td></tr><tr><td>  Traditional SQL Queries </td><td>  RDBMS </td><td>  Standard business reports and analytics. </td></tr></tbody></table><br>  In many ways, CQRS is a more general event-oriented version of the widely used approach of using RDBMS as a data warehouse and search engine for full-text search (like Elasticsearch).  CQRS uses a wider range of database types, rather than full-text search engines.  In addition, by subscribing to events, it updates the views of the request part of the application in almost real time. <br><br>  The following illustration shows the CQRS scheme for an online store. <br>  <i>Customer Service</i> and <i>Order Service</i> are included in the command part of the application.  They provide APIs for creating and updating customers and orders.  Customer View Service is included in the request part.  It provides an API for retrieving customer data using queries. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e11/54f/161/e1154f161ad642efa63b58314391c7b3.png"></div><br>  <i>The Customer View Service</i> subscribes to events posted by the command part of the application, and updates the view repository implemented in MongoDB.  The MongoDB collection contains documents, one for each client.  Each document has attributes that describe a particular customer, as well as an attribute with the latest customer orders.  This collection supports a variety of requests, including the above. <br><br><h2>  Advantages and disadvantages of CQRS </h2><br>  The main advantage of CQRS is that thanks to it, it is possible to implement requests in the microservice architecture, especially those using event sourcing.  This allows the application to efficiently support a diverse set of requests.  Another advantage is that the division of responsibility often simplifies the command and request part of the application. <br><br>  One of the drawbacks is that CQRS requires additional efforts to develop and operate the system.  It is necessary to create and deploy a request part service that can update views and query them.  In addition, you need to deploy a repository of views. <br><br>  Another disadvantage of CQRS is related to the time lag between teams and requests.  As one would expect, there is a delay between the moment when the command part updates the aggregate and when the views of the request part are ready to reflect these changes.  The client application that updates the aggregate and then immediately makes a request using views can see the previous version of the aggregate.  Therefore, the application must be written in such a way as to prevent the user from receiving this potential inconsistency. <br><br><h2>  Summary </h2><br>  One of the main problems in using events to maintain data integrity between services is the atomic update of the database and the simultaneous publication of events.  The traditional solution is to use distributed transactions using a database and message broker.  However, this approach is not viable for modern applications.  The best solution is to use Event sourcing, an event-oriented approach to designing business logic and state preservation systems. <br><br>  Another problem in the microservice architecture are requests.  They often need to combine data belonging to several services.  However, joins are no longer so easy to use, since the data is private for each service.  Event sourcing makes it even more difficult to effectively implement queries, since the current state is not stored by itself.  The solution is to use CQRS and keep one or more materialized views up to date, which you can easily query. </div><p>Source: <a href="https://habr.com/ru/post/322214/">https://habr.com/ru/post/322214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322200/index.html">Go global strategies for startups</a></li>
<li><a href="../322202/index.html">WCF REST services and UWP applications</a></li>
<li><a href="../322206/index.html">61 ways to improve your site's SEO</a></li>
<li><a href="../322208/index.html">Immunitable data in C ++</a></li>
<li><a href="../322212/index.html">Dagaz: Architecture</a></li>
<li><a href="../322216/index.html">How to develop a cross-platform application using only JSON markup</a></li>
<li><a href="../322218/index.html">How to tame autotests</a></li>
<li><a href="../322220/index.html">Is it safe to use the absolute path in * nix systems, as we used to think?</a></li>
<li><a href="../322222/index.html">Russian startups do not succeed because of laziness</a></li>
<li><a href="../322224/index.html">How IT professionals work. Andrey Smirnov, Development Team Leader at Rambler Digital Solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>