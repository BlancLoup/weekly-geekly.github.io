<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Image Optimization for the web</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are enough articles and projects on the Internet for resizing images. Why is another one needed? In this article I will tell why we were not sat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Image Optimization for the web</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/872/27f/3ea87227f2733db9651357bf3fb293ce.png" alt="image"></div><br>  There are enough articles and projects on the Internet for resizing images.  Why is another one needed?  In this article I will tell why we were not satisfied with the current decisions and had to cut our own. <br><a name="habracut"></a><br><h3>  Problem </h3><br>  Let's first understand why we did resize pictures.  We, as a web service, are interested in the fastest possible loading of pages by the user.  Users like this and increase conversion.  If the user has a slow or mobile Internet, then it is extremely important that the pages are light, not waste the user's traffic and processor resources.  One of the points that helps with this is the resizing of images. <br><br>  We solve two problems.  The first problem is that the images are often not compressed for the necessary resolution, that is, the client has to not only download unnecessary data, but also spend CPU resources on resizing the images by the browser.  Solution: give the user pictures in the resolution in which they will be shown in the browser. <br><br>  The second problem is that the images are usually not well compressed enough, that is, you can encode them more optimally, which will increase the page loading speed without subjective loss of image quality.  Solution: optimize the pictures before returning to the client. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As an example, how to do it is not necessary to look at the main page of such a famous site like <a href="https://github.com/">github.com</a> .  With a weight of 2 MB pages, 1.2 of them are occupied by useless images that can be optimized and not downloaded. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/7fc/f8e/6387fcf8ea674b63a01ef9c293222a0d.png" alt="image"></div><br><br>  The second example is our Habr.  I will not give a screenshot, so as not to stretch the article, the results <a href="https%253A%252F%252Fhabrahabr.ru%252Ftop%252F%26tab%3Ddesktop">of the link</a> .  On Habr√© pictures change the resolution to the right, but do not optimize them.  This would reduce their size by 650 Kb (50%). <br><br>  In many places on the site, smaller versions of images are needed, for example, to show a smaller version of a news picture in the news feed.  We implement this as follows - on our server only the picture in the maximum quality is stored, and, if necessary, insert its resolved version you need to add the required resolution through the "@" to the end of the URL.  Then the request will not be sent for the file, but on our resizing backend and will return the optimized and optimized version of the image. <br><br><h3>  Common Solutions </h3><br>  All that will be said below relates to JPEG and PNG images, since  These are the most popular formats on the Internet. <br><br>  Having driven something like ‚Äúimage resize backend‚Äù into google you will see that in half of the cases Nginx is suggested to be used, the other part is various self-written services, most often Node.js. <br><br>  From nginx, or rather from libgd, which is used in the nginx module, we were able to squeeze 63 RPS on the <a href="">test image</a> , which is not bad, but I would like to have faster and more flexibility.  Graphicsmagick is also not suitable, because  its speed is too low.  In addition, both of these solutions produce non-optimized images.  Most other solutions, such as Node, suggest using Sharp for resizing, MozJPEG for optimizing JPEG images, and pngquant for optimizing PNG. <br><br>  For quite a long time we ourselves used a handwritten bunch of Nods, Libvips and MozJPEG with pngquant, but one day we wondered - ‚ÄúCan we make the resize faster and less demanding of resources?‚Äù. <br><br>  Spoiler: you can.  ;) <br><br>  Now it would be nice to find out how to speed up our application.  After examining the application code, we found out that imagemin, which was used for optimization, and in particular its MozJPEG and pngquant plug-ins, work with the same-name utilities through os.Exec.  We will unequivocally cut out this business and use only bindings for the CI's.  For resizing, the Sharp module was used, which is a binding to the Libvips C library. <br><br><h3>  Our implementation </h3><br>  Guglezh showed that Libvips is still the leader in speed and only OpenCV can compete with it.  So we will use Libvips and in our implementation, this is a proven solution and it has a ready binding for Go.  It's time to try to write a prototype and see what comes of it. <br><br>  A few words about why Golang was chosen to attempt this problem.  Firstly, it is fast enough, you still remember that we want to make a quick resize.  The code on it is easy to read and maintain.  The last requirement was the ability to work with the C library, it will be useful to us. <br><br>  We quickly wrote a prototype, tested it and realized that despite the larger number of internal spins, Libvips still delivers non-optimized images for output.  With this we need to do something.  Again, we turn to all-powerful Google and find out that the best option is still MozJPEG.  This is where doubts start to creep in, that we now write the same thing that was on Node, only on Go.  But carefully reading the description of MoZJPEG, we learn that it is a fork of libjpeg-turbo and is compatible with it. <br><br>  Looks very promising.  Things are easy - to assemble your version of Libvips, in which jpeg-turbo is replaced by the version from Mozila.  To build, we chose Alpine Linux, because  the application still planned to publish with the help of Docker and Alpine has a very nice package config format, very similar to that used in Arch Linux. <br><table><caption>  <i>Optimization of the image reduced its size by 4 times without apparent loss of quality.</i> </caption><tbody><tr><th>  Original jpeg <br>  351x527 <br>  79 Kb </th><th>  Optimized <br>  351x527 <br>  17 Kb </th></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/d62/96d/b3b/d6296db3bc73d70100f6103e26e3acf9.jpg" alt="greece_origin"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/89b/fe5/c46/89bfe5c46e7e82a9a1672fcac8496b8c.jpg" alt="greece_optimized"></td></tr></tbody></table><br>  Collected, tested.  Now Libvips immediately when resizing produces an optimized version.  That is, in the Node version of the version, we first resized, and then once again passed the picture through the decoder-encoder.  Now we are only doing a resize. <br><br>  With JPEG figured out, and what to do with png.  To solve this problem was found library libpngquant.  It is not very popular, despite the fact that the pngquant console utility, which is based on it, is used in many solutions.  It was also found for her binding on Go, a little abandoned and with a memory leak, I had to fork it to fix, add documentation and everything else that befits a decent project.  Libpngquant we also assembled as an Alpine package for easy installation. <br><br>  Due to the fact that the image is no longer required to be saved to a file for processing using pngquant, we can optimize the process a little.  For example, do not compress the image when resizing in Libvips, but only after processing in pngquant.  This will save some precious CPU time.  Needless to say, we are also very saving due to the fact that calling the C library is much faster than running a console utility. <br><br><table><caption>  <i>The difference in the size of 3 times, but the appearance of artifacts (depending on the picture).</i> </caption><tbody><tr><th>  Original PNG <br>  450x300 <br>  200 Kb </th><th>  Optimized <br>  450x300 <br>  61 KB </th></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/00c/a2f/19c/00ca2f19c7f8a1de2a6698b731cb3f8f.png" alt="bird_origin"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/26d/a1a/a3e/26da1aa3e8a155d45ad7ac0b539e2c20.png" alt="bird_optimized"></td></tr></tbody></table><br><table><caption>  <i>An example of a not very successful image in which artifacts appear during compression.</i> </caption><tbody><tr><th>  Original PNG <br>  351x527 <br>  270 Kb </th><th>  Optimized <br>  351x527 <br>  40 Kb </th></tr><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/25f/048/027/25f0480275c9340693e144ea507e1578.png" alt="greece_origin"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/b49/629/812/b49629812d242cf7badf1dbf6208cb1f.png" alt="greece_optimized"></td></tr></tbody></table><br>  After the prototype was written, tested on my PC and gave a decent 25 RPS on the mobile two nuclear process, devouring the entire CPU, I wanted to see how much you can squeeze out of it on a normal hardware.  Run the code on the six nuclear machine, set Jmeter and WTF ???  We get 30 RPS.  We try to figure out what the garbage. <br><br>  Libvips itself implements multithreading, that is, we only need to initialize the library and in the future we can safely access it from any thread.  But for some reason, Libvips works in one thread for us, which limits us to one core.  Another 1 core takes pngquant.  In total, it turns out that our super fast resizing is working fine only on a developer‚Äôs laptop, and on other machines it cannot utilize all the resources.  ;) <br><br>  We look at the source code for the Libvips binding and see that there CONCURRENCY is set to 1 by default because of the data races in Libvips.  But judging by the bug tracker, these problems have long been fixed.  Exposed CONCURRENCY back, we test.  Nothing has changed, Libvips still refused to resize images multithreadedly.  All attempts to overcome this problem failed and to tell the truth, I was tired of solving it and decided to work around the problem at a different level. <br><br>  All more or less modern Linux kernels (3.9+ and 2.6.32-417 + on CentOS 6) support the SO_REUSE option, which allows one port to be used by several instances of an application.  This approach is more convenient than balancing by means of third-party software, such as HAProxy, because  does not require configuration and allows you to quickly add and remove instances. <br>  Therefore, we used the SO_REUSE and the "--scale" option in Docker compose, which allows you to specify the number of running instances. <br><br><h3>  Time to measure </h3><br>  It's time to evaluate the result of our labors. <br><br>  Configuration: <br><br><ul><li>  CPU: Intel Xeon E5-1650 v3 @ 3.50GHz 6 cores (12 vCPU) </li><li>  RAM: 64 Gb (used about 1-2 Gb) </li><li>  Number of workers: 12 </li></ul><br>  Results: <br><table><tbody><tr><th>  FIle </th><th>  Output resolution </th><th>  Node RPS </th><th>  Go rps </th></tr><tr><td>  <a href="">bird_1920x1279.jpg</a> </td><td>  800x533 </td><td>  34 </td><td>  73 </td></tr><tr><td>  <a href="">clock_1280x853.jpg</a> </td><td>  400x267 </td><td>  69 </td><td>  206 </td></tr><tr><td>  <a href="">clock_6000x4000.jpg</a> </td><td>  4000x2667 </td><td>  1.9 </td><td>  5.6 </td></tr><tr><td>  <a href="">fireworks_640x426.jpg</a> </td><td>  100x67 </td><td>  114 </td><td>  532 </td></tr><tr><td>  <a href="">cc_705x453.png</a> </td><td>  405x260 </td><td>  21 </td><td>  33 </td></tr><tr><td>  <a href="">penguin_380x793.png</a> </td><td>  280x584 </td><td>  28 </td><td>  69 </td></tr><tr><td>  <a href="">wine_800x800.png</a> </td><td>  600x600 </td><td>  27 </td><td>  49 </td></tr><tr><td>  <a href="">wine_800x800.png</a> </td><td>  200x200 </td><td>  55 </td><td>  114 </td></tr></tbody></table><br>  More benchmarks (but no comparison with the Node version) on the <a href="https://github.com/ultimate-guitar/reImage/wiki/Benchmark">wiki page</a> . <br>  As you can see, we did not change the resize in vain, the speed increase was from 30 to 400% (in some cases).  If you need to resize even faster, then you can twist the "speed" and "quality" knobs in libimagequant.  They will make it possible to further reduce the size or increase the coding speed at the price of a loss in image quality. <br><br>  Project <a href="https://github.com/ultimate-guitar/reImage">ID</a> on <a href="https://github.com/ultimate-guitar/reImage">github</a> . <br>  Binding Go to libimagequant also on <a href="https://github.com/ultimate-guitar/go-imagequant">GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/351246/">https://habr.com/ru/post/351246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351234/index.html">5 errors when developing WebRTC calls from the browser</a></li>
<li><a href="../351238/index.html">5 prioritization techniques for IT teams</a></li>
<li><a href="../351240/index.html">ZalgoFuzzing: Using non-standard payload blurring methods</a></li>
<li><a href="../351242/index.html">The origins of motivation in the management of Agile and SCRUM</a></li>
<li><a href="../351244/index.html">Mobile 3D game on Unity3D in less than 90 hours</a></li>
<li><a href="../351248/index.html">Trends of retail at the international exhibition EuroCIS 2018</a></li>
<li><a href="../351250/index.html">Introduction to Postman</a></li>
<li><a href="../351252/index.html">Let's Encrypt began issuing wildcard certificates</a></li>
<li><a href="../351254/index.html">Using environment variables in Node.js</a></li>
<li><a href="../351256/index.html">How JS Works: Tracking DOM Changes with MutationObserver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>