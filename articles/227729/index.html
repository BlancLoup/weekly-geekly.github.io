<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about Ethernet frames, but were afraid to ask, and for good reason</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article turned out to be quite voluminous, the topics covered were Ethenet frame formats, L3 Payload size limits, the evolution of Ethernet header...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about Ethernet frames, but were afraid to ask, and for good reason</h1><div class="post__text post__text-html js-mediator-article">  The article turned out to be quite voluminous, the topics covered were Ethenet frame formats, L3 Payload size limits, the evolution of Ethernet header sizes, Jumbo Frame, Baby-Giant, and a lot of things offended by the way.  Something you have already seen in the review literature on data networks, but with many, clearly, did not come across, if not deeply engaged in research. <br><br>  We begin by considering the format of the Ethernet frame headers in the queue of their birth. <br><br><h4>  Formats Ehternet frames. <br></h4><br><h5>  1) Ethernet II <br></h5>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/913/b51/612/913b516122a6c0252b2a445f42e8f697.jpg"><br>  Fig.  one <br><a name="habracut"></a><br>  <b>Preamble</b> - a sequence of bits, in fact, not part of the ETH header that defines the beginning of an Ethernet frame. <br><br>  <b>DA (Destination Address)</b> - the destination MAC address, it can be a unicast, multicast, broadcast. <br><br>  <b>SA (Source Address)</b> - MAC address of the sender.  Always unicast. <br><br>  <b>E-TYPE (EtherType)</b> - Identifies the L3 protocol (for example, 0x0800 - Ipv4, 0x86DD - IPv6, 0x8100- indicates that the frame is tagged with an 802.1q header, etc. A list of all EtherType - <a href="http://standards.ieee.org/develop/regauth/ethertype/eth.txt">standards.ieee.org/develop/regauth/ ethertype / eth.txt</a> ) <br><br>  <b>Payload</b> - L3 packet size from 46 to 1500 bytes <br><br>  <b>FCS (Frame Check Sequences)</b> - 4 byte CRC value used to detect transmission errors.  Calculated by the sending side, and placed in the FCS field.  The receiving party calculates this value independently and compares it with the received one. <br><br>  This format was created in collaboration with 3 companies - DEC, Intel and Xerox.  In this regard, the standard is also called <b>DIX Ethernet standard</b> .  This version of the standard was published in 1982 (the first version, Ehernet I - in 1980. The differences in the versions are small, the format as a whole has remained unchanged).  In 1997  This standard was added by IEEE to the 802.3 standard, and at the moment, the vast majority of packets on Ethernet networks are encapsulated according to this standard. <br><br><h5>  2) Ethernet_802.3 / 802.2 (802.3 with LLC header) </h5><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dba/006/ddc/dba006ddcb2a1c696367e92d06a4d5a7.jpg"><br>  Fig.  2 <br><br>  As you understand, the IEEE Committee could not watch calmly, as power, money and women literally slip away.  Therefore, busy with more pressing problems, the standardization of the Ethernet technology came up with some delay (in 1980 they got down to business, in 1983 they gave the world a draft, and in 1985 the standard itself), but with great enthusiasm.  By proclaiming innovation and optimization as its main principles, the committee issued the following frame format, which you can see in Figure 2. <br><br>  First of all, we draw attention to the fact that the ‚Äúunnecessary‚Äù E-TYPE field is converted to the Length field, which indicates the number of bytes following this field before the FCS field.  Now, it was possible to understand who was longer at the second level of the OSI system.  Life has become better.  Life has become more fun. <br><br>  But, a pointer to the type of protocol of the 3rd level was needed, and IEEE gave the world the following innovation - two fields of 1 byte each - Source Service Access Point ( <b>SSAP</b> ) and Destination Service Access Point ( <b>DSAP</b> ).  The goal, the same, is to identify the superior protocol, but what is the implementation!  Now, due to the presence of two fields within one session, the packet could be transferred between different protocols, or the same protocol could be called differently at the two ends of the same session.  BUT?  What is it like?  Where is your Skolkovo? <br><br>  Note: In real life, this is of little use and SSAP / DSAP values ‚Äã‚Äãusually coincide.  For example, SAP for IP - 6, for STP - 42 (full list of values ‚Äã‚Äã- <a href="http://standards.ieee.org/develop/regauth/llc/public.html">standards.ieee.org/develop/regauth/llc/public.html</a> ) <br><br>  Without giving themselves a break, IEEE reserved 1 bit in SSAP and DSAP.  In SSAP under the instruction of the command or response of the packet, in DSAP under the indication of the group or individual address (see Fig. 6).  On Ethernet networks, these things did not get distribution, but the number of bits in the SAP fields was reduced to 7, which left only 128 possible numbers under the instruction of the higher protocol.  We remember this fact, we will come back to it. <br><br>  It was already difficult to stop in the desire to make the best frame format on earth, and in IEEE frame format appears 1 byte field <b>Control</b> .  Responsible, not much, not enough, for a Connection-less or Connection-oriented connection! <br><br>  After exhaling and examining their offspring, IEEE decided to take a break. <br><br>  <b>Note</b> : The 3 fields considered are DSAP, SNAP and Control and are the LLC header. <br><br><h5>  3) Raw 802.3 </h5><br><br><img src="https://habrastorage.org/getpro/habr/post_images/324/2d1/248/3242d124827393c6f0221283f0a99a17.jpg"><br>  Fig.  3 <br><br>  This "lack of standard" revealed to the world of Novell.  It was the dashing 80s, everyone survived as they could, and Novell was no exception.  Having obtained the 802.3 / 802.2 specification in the process of developing the specification and throwing out the LLC header with a slight movement of the hand, Novell got quite a good frame format (with the ability to measure length at the second level!), But with one major drawback - the lack of the possibility of specifying a higher protocol.  But, as you might have guessed, the guys who worked there were not stupid, and due to common thinking they worked out a solution - ‚Äúbut let us turn our shortcomings into our own merits,‚Äù and limited this frame format to the IPX protocol, which we supported.  And the idea is good, and the plan was strategically correct, but, as history has shown, it was not fortanulo. <br><br><h5>  4) 802.3 with SNAP Header. </h5><br>  As time went.  The IEEE committee realized that protocol numbers and money were running out.  Grateful users bombarded the editors with letters, where the 3-byte LLC header was placed on a par with such great innovations of humanity as the equipment of a dog with the 5th leg, or with a sleeve that can be used to optimize female anatomy.  It was impossible to wait any longer, it was time to declare itself to the world again. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18b/9c4/871/18b9c487197e2495dee186a36f0798a4.jpg"><br>  Fig.  four <br><br>  And to help those suffering from a shortage of protocol numbers (there could be 128 of them in total, we mentioned), IEEE introduces a new standard for the Ethernet SNAP frame (Figure 4).  The main innovation is the addition of a 5-byte field of the Subnetwork Access Protocol (SNAP), which in turn consists of two parts - a 3-byte field Organizationally Unique Identifier (OUI) and a 2-byte Protocol ID (PID) - Fig.  five. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e50/451/b74/e50451b74a25fd1cddda7e55102508c0.jpg"><br>  Fig.  five <br><br>  OUI or vendor code - allows you to identify proprietary protocols by specifying the vendor.  For example, if you catch WireShark with the PVST + package, then in the OUI field you will see the code 0x00000c, which is the identifier of Cisco Systems (Fig. 6). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/830/611/5fa83061161b6f5098428a21ac409ad3.jpg"><br>  Fig.  6 <br><br>  <b>Note: It is</b> quite easy to meet a packet with encapsulation in the frame format 802.3 SNAP and now these are all protocols of the STP family, protocols CDP, VTP, DTP. <br><br>  The PID field is essentially the same EtherType field from DIX Ethernet II - 2 bytes under the indication of a higher-level protocol.  Since earlier DSAP and SSAP fields of the LLC header field were used for this, to indicate that the type of the upstream protocol should be viewed in the SNAP field, the DSAP and SSAP fields take the fixed value 0xAA (also seen in Fig. 6) <br><br>  <b>Note:</b> When using the LLC / SNAP frame format for transferring IP packets, the IP MTU is reduced from 1,500 to 1,497 and 1,492 bytes, respectively. <br><br>  According to the headings in the frame format, in principle, everything.  I would like to draw attention to another point in the frame format - the size of the payload.  Where did this range come from - from 46 to 1500 bytes? <br><br><h4>  Size L3 Payload. </h4><br>  From where did the lower limit come from, perhaps everyone who at least read the first CCNA curriculum knows.  This restriction is a consequence of the frame size limit of 64 bytes (64 bytes - 14 bytes of the L2 header - 4 bytes of FCS = 46 bytes) imposed by the CSMA / CD method - the time required to transmit 64 bytes of the network interface is necessary and sufficient to determine collisions in the environment Ethernet <br>  <b>Note:</b> In modern networks, where the occurrence of collisions is excluded, this restriction is no longer relevant, but the requirement remains.  This is not the only "appendix" left over from those times, but we'll talk about them in another article. <br><br>  But where did these notorious 1500 bytes come from, the question is more complicated.  I found the following explanation - there were several prerequisites for the introduction of the upper frame size limit: <br><ul><li>  Transmission delay - the larger the frame, the longer the transmission lasts.  For early networks, where the Collision domain was not limited to the port, and all stations had to wait for the transfer to complete, this was a serious problem. </li><li>  The larger the frame, the greater the likelihood that the frame will be damaged during transmission, which will result in the need for retransmission, and all devices in the collision domain will have to wait again. </li><li>  The restrictions imposed by the memory used by the interface buffers - at that time (1979) an increase in buffers significantly increased the cost of the interface. </li><li>  The restriction imposed by the field Length / Type - the standard stipulates that all values ‚Äã‚Äãabove 1536 (from 05-DD to 05-FF.) Indicate the EtherType, respectively, the length must be less than 05-DC.  (I really have a suspicion that this is more a consequence than a prerequisite, but it seems to be infa from 802.3 developers) </li></ul><br>  In total, in the 802.3 standard, the frame size was limited to 1518 bytes from the top, and payload to 1500 bytes (hence the default MTU size for the Ethernet interface). <br><br>  <b>Note:</b> Frames smaller than 64 bytes are called Runts, frames larger than 1,518 bytes are called Giants.  You can view the number of such frames received on the interface using the <code>show interface gigabitEthernet module/number</code> and <code>show interface gigabitEthernet module/number counters errors.</code>  And up to IOS 12.1 (19), the counters were sent as frames with incorrect and correct CRS (although the latter were not always dropped, depending on the platform and conditions).  But starting from 12.1. (19), only those runt and giant frames that have incorrect CRS are displayed in these counters, frames are less than 64 bytes, but with correct CRS (the cause is usually associated with 802.1Q detection or source of frames, not problems physical level) from this version fall into the Undersize counter, they drop, or forward further, depends on the platform. <br><br><h5>  The evolution of Ethernet header sizes. </h5><br>  With the development of technology and specifications of the IEEE 802 line, the frame size has also changed.  Basic further frame resizing (not MTU!): <br><ul><li>  802.3AC - increases the maximum frame size to 1522 - adds a Q-tag - carrying information about 802.1Q (VLAN tag) and 802.1p (bits for COS) </li><li>  802.1AD - increases the maximum frame size to 1526, support for QinQ </li><li>  802.1AH (MIM) - Provider Bridge Backbone Mac in Mac + 30 bytes to frame size </li><li>  MPLS - we increase the size of the frame on the stack of labels 1518 + n * 4, where n is the number of labels in the stack. </li><li>  802.1AE - Mac Security; Security Tag and Message Authentication Code + 68 bytes to the frame size are added to the standard fields. </li></ul><br><br>  All these frames of the increased size are grouped under one name - <b>Baby-Giant</b> frames.  The silent upper size limit for a Baby-Giant is 1600 bytes.  Modern network interfaces will forward these frames, often without even changing the value of the HW MTU. <br><br>  Separately, pay attention to the specifications of 802.3AS - increases the maximum frame size to 2000 (but retains the MTU size of 1500 bytes!).  The increase accounted for the title and trailer.  Initially, the increase was planned for 128 bytes - for native support by the standard 802.3 of the extensions listed above, but eventually they agreed on 2 thousand, apparently not to be collected twice (or as IEEE says - this frame size will support the future of future).  The standard was approved in 2006, but except at the IEEE presentations, I did not meet it.  If anyone has anything to add here (and not only here) - welcome to the comments.  In general, the tendency to increase the size of the frame while maintaining the size of PAYLOAD, creates in my head vague doubts about the correctness of the chosen direction of movement. <br><br>  <b>Note: The</b> FCoE frame is located a little away from the above - the frame size is up to 2500 bytes, often these frames are called mini-jumbo.  For their support, you need to enable jumbo-frame support. <br><br>  And the last Ethernet ‚Äúbastard‚Äù is the Jumbo Frame (although if you translate the Jumbo, then Hodor appears more likely - a reference to the Game of Thrones).  This description includes all frames exceeding the standard size of 1518 bytes, with the exception of those discussed above.  Jumbo packages are not reflected in the 802.3 specifications at all and therefore the implementation remains on the conscience of each particular vendor.  However, jumbo frames exist just as much as ethernet exists.  It is defined as follows: <br><ol><li>  Benefit of payload ratio to headers.  The greater this ratio, the more efficiently we can use communication lines.  Of course, the gap here will not be the same as in comparison with the use of packets of 64 bytes and 1,518 bytes for TCP sessions.  But you can win your own 3-8 percent, depending on the type of traffic. </li><li>  A significantly smaller number of headers generates less load on the Forwading Engine, as well as on the service Engine.  For example, the frame rate for a 10G link loaded with 1,500 byte frames is 812,744 frames per second, while the same link loaded with Jumbo frames of 9,000 bytes generates a frame rate of only 138,587 frames per second.  Figure 7 shows the graph from the Alteon Networks report (link will be at the bottom of the article) of utilization of the CPU and gigabit link, depending on the type of frame size used. </li><li>  Increase TCP Throughput when resizing MTU - <a href="http://staff.psc.edu/rreddy/networking/mtu.html">staff.psc.edu/rreddy/networking/mtu.html</a> </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/5a0/279/e86/5a0279e8640d0e6e308f62ff6fc10c36.jpg"><br>  Fig.  7 <br><br>  This medal has a reverse side: <br><ol><li>  The larger the frame, the longer it will be transmitted (Fig. 8): </li><li>  Buffers in the memory of network devices are filled faster, which can cause undesirable consequences.  In essence, it can be solved at the equipment design stage, but it increases the cost. </li><li>  The proprietary implementation of each manufacturer - all devices must support either the same size of the Jumbo frame, or sets of sizes. </li><li>  It is essentially impossible to use networks that are under different administrative control over large parts of the network, due to the lack of a Jumbo Frame Discovery mechanism ‚Äî the intermediate node may not support Jumbo Frame at all or a certain size. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/4d7/ec6/6ae/4d7ec66ae8db5fa8c679eb19bb32f6d6.jpg"><br>  Fig.8 <br><br>  In sum, the pros and cons of using jumbo frames give us an unequivocal indication of where we can use this frame size.  And so, in which applications in the data center can we use the Jumbo Frame to everyone's advantage?  It turns out such a list (additions are welcome): <br><ul><li>  In server clusters </li><li>  When backing up </li><li>  Network File System (NFS) Protocol </li><li>  iSCSI SANs </li><li>  FCoE SANs </li></ul><br><br>  <b>Note:</b> Jumbo MTU has an upper size limit.  It is determined by the size of the FCS field (4 bytes) and the Cyclic Redundancy Check algorithm and is 11,455 bytes.  In practice, Jumbo MTU is usually limited to 9216 bytes in size, on some platforms 9000 bytes, on older hardware 8092 bytes (this is Cisco). <br><br>  Fuh, basically everything.  What I wanted to consider in theory, considered.  For the MTU size configuration and the theory with the feints behind these three letters, I ask in my last article - <a href="http://habrahabr.ru/post/226807/">‚ÄúMaximum Transmission Unit (MTU).</a>  <a href="http://habrahabr.ru/post/226807/">Myths and reefs.</a> <br><br>  In conclusion, the promised link to the Alteon Networks "Extended Frame Sizes for Next Generation Ethernets" <a href="http://staff.psc.edu/mathis/MTU/AlteonExtendedFrames_W0601.pdf">report</a> - <a href="http://staff.psc.edu/mathis/MTU/AlteonExtendedFrames_W0601.pdf">staff.psc.edu/mathis/MTU/AlteonExtendedFrames_W0601.pdf</a> , and a small announcement for the next article - in it we will fall even lower - to the physical level, and we will deal with the heavy legacy of CSMA / CD, encoding, and, in passing, we will hook on something else from the topical. </div><p>Source: <a href="https://habr.com/ru/post/227729/">https://habr.com/ru/post/227729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227717/index.html">Email marketing as a product</a></li>
<li><a href="../227719/index.html">Launched beta version of online document editor in Mail.Ru Cloud</a></li>
<li><a href="../227721/index.html">Yandex closes Ya.ru blog hosting site and Yandex.Video hosting</a></li>
<li><a href="../227723/index.html">Android Data Processor library for easy building of REST requests and their processing</a></li>
<li><a href="../227727/index.html">Hackathon as a way to expand coder consciousness. Photo correspondent report</a></li>
<li><a href="../227731/index.html">As I rewrote the project with JavaScript on Scala</a></li>
<li><a href="../227733/index.html">Record of the webinar "Migration to Kerio Connect"</a></li>
<li><a href="../227735/index.html">We study C #. 3rd ed</a></li>
<li><a href="../227737/index.html">Increase new customs limit by 6, (6) times</a></li>
<li><a href="../227739/index.html">New Opera Mini 8 for iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>