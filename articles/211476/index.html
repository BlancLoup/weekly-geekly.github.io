<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About liberties in the links or the simplest messaging</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Messaging is quite a fundamental thing in Computer Science . We will consider it in an approximation to event-oriented programming ( event-driven ). T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About liberties in the links or the simplest messaging</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/3af/b64/7c53afb6411c2a10594277606c07f09a.jpg" align="right">  Messaging is quite a <a href="http://en.wikipedia.org/wiki/Message_passing">fundamental thing</a> in <i>Computer Science</i> .  We will consider it in an approximation to event-oriented programming ( <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5"><i>event-driven</i></a> ).  Terminology, capabilities and implementations may differ: events ( <i>events</i> ), messages ( <i>messages</i> ), signals / slots ( <i>signals / slots</i> ) and <i>callbacks</i> .  In general, the essence is that with the arrival of an event, a response is launched. <br>  The messaging system itself in the article served as a demonstration of a free, but acceptable interpretation of links / pointers, simplifying the code.  The resulting system is trivial and can only register a handler for a specific message code and send messages with such a code. <br>  Suppose that the handlers are non-trivial, and there are few messages.  And that we ourselves generate messages and they do not come to us on the network, for example.  In this case, I want to have something more convenient with explicit variable declarations in the message.  For example, something like: <br><pre><code class="cpp hljs">StringMessage* str_message = ...; send(my_message); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Message* message)</span></span></span><span class="hljs-function"> </span></span>{ assert(message); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StringMessage* str_message = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StringMessage*&gt;(message); assert(str_message); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; str_message-&gt;message ... }</code> </pre> <br>  But I want to remove the verification code that is not related to the logic of work, under the hood.  Therefore, we replace the pointer to the link, showing that the object just arrives at the handler, and not <s>NULL</s> nullptr.  And let the handler immediately accept the required message type. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> StringMessage&amp; message)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  How to implement your plans and support other possible message classes? <br><a name="habracut"></a><br>  The idea is simple.  During the handler registration, we will know the type of the argument it accepts and write it.  And when sending a message, check that the message type matches the type of the handler argument.  For each new type of message, look at the base message class <code>Message</code> . <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Message(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> code) : code(code) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Message() {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> code; }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Code { STRING = <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringMessage</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Message { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: StringMessage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; msg) : Message(STRING), message(msg) {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> message; };</code> </pre><br><br><h2>  Solution with delegates </h2><br>  Good old delegates work in C ++ 03.  One of examples of implementation is described on Habr√© <a href="http://habrahabr.ru/post/78299/">here</a> .  Delegates in this case are only a functional wrapper over member functions.  This is a subscription handler. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Messenger</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageDerived</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribe</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">code</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">:</span></span>:* method)(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MessageDerived&amp;)) { <span class="hljs-comment"><span class="hljs-comment">//   ,    -  const std::type_index&amp; arg_type = typeid(const MessageDerived); //   ,      (const Message&amp;) void (T::* sign)(const Message&amp;) = (void (T::*)(const MessageDerived&amp;)) method; //    subscribers_.push_back(Subscriber(code, object, NewDelegate(object, sign), arg_type)); } }</span></span></code> </pre><br>  Correctness.  As soon as the device of the derived message class becomes less trivial, there is a problem of <a href="http://en.wikipedia.org/wiki/Object_slicing">cutting objects</a> .  Upon entering the send method, the object is cut to the base type by moving the passed reference to the base object.  The handler does not know about this and uses an invalid link.  Let's inform if we meet such an object. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_sliced</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">der</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) der != (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base*) der; }</code> </pre><br>  But it's best to write a compile-time check.  The compiler will cut the base type according to the inherited one.  And if the pointer increased from 1, then the object was cut. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_sliced2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, ((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)((Base*)((Derived*) <span class="hljs-number"><span class="hljs-number">1</span></span>))) != (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">1</span></span>&gt; {}; ... <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!is_sliced2&lt;Message, Arg&gt;::value, <span class="hljs-string"><span class="hljs-string">"Message object should not be sliced"</span></span>);</code> </pre><br>  Unfortunately, the MSVS 2013 compiler does not cope with the compilation of the condition, but gcc-4.8.1 <a href="https://ideone.com/XBLb4l">is complete</a> . <br><br>  Sending a message is easy.  We check that the message is not cut off.  Run through all handlers.  If the codes of the message and the handler match, then check the types for compliance.  If everything is the same, then we call the handler. <br><div class="spoiler">  <b class="spoiler_title">Posting a message</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Messenger</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikeMessage</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">send</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LikeMessage</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">) {</span></span> assert((!is_sliced&lt;Message, LikeMessage&gt;(&amp;msg))); send_impl(msg); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Message&amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::type_info&amp; arg = <span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(msg); <span class="hljs-comment"><span class="hljs-comment">//     for (SubscribersCI i = subscribers_.begin(); i != subscribers_.end(); ++i) { if (i-&gt;code == msg.code) { //    if (arg != i-&gt;arg_type) // ,        throw std::logic_error("Bad message cast"); i-&gt;method-&gt;call(msg); //  -  } } } }</span></span></code> </pre><br></div></div><br>  It is important not to forget to add a check that <code>MessageDerived</code> indeed inherited from <code>Message</code> .  In C ++ 11, there is <code>std::is_base_of</code> in the <code>&lt;type_traits&gt;</code> <code>std::is_base_of</code> .  In C ++ 03, the compile time check will have to be written by hand. <br>  The delegate example is simple.  Handler class, delegate subscription, and message sending: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Printer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> StringMessage&amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Printer received: "</span></span> &lt;&lt; msg.message &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Messenger messenger; Printer print; messenger.subscribe(STRING, &amp;print, &amp;Printer::print); messenger.send(StringMessage(<span class="hljs-string"><span class="hljs-string">"Hello, messages!"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  <a href="">Code with delegates</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  C ++ 11 </h2><br>  In C ++ 11, lambdas appeared.  Our goal is to make the subscription process look very simple: <br><pre> <code class="cpp hljs">messenger.subscribe(STRING, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StringMessage&amp; msg) {...});</code> </pre><br>  Lambda can be wrapped in <code>std::function</code> , but for this you need to know the type of lambda without losing the type of the input argument.  And then convert the lambda into something universal like <code>std::function&lt;void (const Message&amp;)&gt;</code> .  But you can not just take and learn the type of C ++ lambda. <br><div class="spoiler">  <b class="spoiler_title">Figure out the lambda type</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Function&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> function_traits&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;Function::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>())&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ClassType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ReturnType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function_traits</span></span></span><span class="hljs-class">&lt;ReturnType(ClassType::*)(Args...) const&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pointer)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;ReturnType(Args...)&gt; function; };</code> </pre><br>  Borrowed <a href="http://meh.schizofreni.co/programming/magic/2013/01/23/function-pointer-from-lambda.html">from here</a> .  Incomprehensible, recursively inherited thing, so even with partial specialization!  But the point is that each lambda has <code>operator()</code> , which is used for the call.  <code>decltype(&amp;Function::operator())</code> expands this to the type of the member function corresponding to the lambda.  The arguments are passed to the partially specialized template, where the corresponding synonyms for the type of the function pointer and the <code>std::function</code> for the <code>std::function</code> pointer are set. <br></div></div><br>  The code is similar to the delegates variant.  Complicated only the logic of working with lambda. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Function&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Messenger</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> code, Function func)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      function_traits typedef typename function_traits&lt;Function&gt;::function FType; //  std::function    argument_type (  ) typedef typename FType::argument_type Arg; //  typeid  auto&amp; arg_type = typeid(Arg); // ,     Message //  Arg  .   ,     . typedef std::remove_reference&lt;Arg&gt;::type ArgNoRef; //    static_assert(std::is_base_of&lt;Message, ArgNoRef&gt;::value, "Argument type not derived from base Message"); //         auto ptr = to_function_pointer(func); //        ,    auto pass = (void(*) (const Message&amp;)) ptr; subscribers_.emplace_back(std::move(Subscriber(code, pass, arg_type))); } }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">What's inside to_function_pointer?</b> <div class="spoiler_text">  Lambda is statically converted to a pointer type to a function of the corresponding type. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Function&gt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> function_traits&lt;Function&gt;::<span class="hljs-function"><span class="hljs-function">pointer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_function_pointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function&amp; lambda)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> function_traits&lt;Function&gt;::pointer&gt;(lambda); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">On a note</b> <div class="spoiler_text">  It is worth noting that make the cast in the opposite direction is much easier. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Message&amp;)&gt; msg_func = ...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StringMessage&amp;)&gt; str_func = msg_func; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  This is a logical behavior because <i>public inheritance</i> is the realization of the is relationship ( <i>is a</i> ).  Specifically, <code>StringMessage</code> is a <code>Message</code> .  But not vice versa. <br></div></div><br>  The sending code almost literally repeats the parsed code with delegates.  <a href="">All code with lambdas</a> . <br>  Here is the final of our work.  You can simply register, send a message and process it. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Messenger messenger; messenger.subscribe(STRING, [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> StringMessage&amp; msg) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Received: "</span></span> &lt;&lt; msg.message &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }); messenger.send(StringMessage(<span class="hljs-string"><span class="hljs-string">"Hello, messages!"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  I will also provide a link to an article with a more general implementation of a <a href="http://meh.schizofreni.co/programming/magic/2013/01/23/function-pointer-from-lambda.html"><i>callback</i></a> for several arguments. <br><br><h2>  Performance drawdown </h2><br>  Let's see how much sagged in performance.  We take only one handler for two <i>messengers</i> , one of which is ours and can accept any type inherited from <code>Message</code> .  And the second, which can only accept a message with the string <code>StringMessage</code> .  We will send one set message <s>many</s> 500,000,000 times. <br><pre> <code class="bash hljs">Msg: 13955ms Str: 1176ms Ratio: 12.0</code> </pre><br>  12 times slower.  The whole difference is spent on taking the <code>typeid</code> type of the argument when sending to one message and checking for type matching.  The figure is depressing, we will remember it, but still not the most important.  Because most likely in the program there will be a bottleneck not in the process of sending messages, but in their processing.  And in the most extreme case, you can remove the check for the type in the release mode, aligning the performance. <br>  <a href="">Measurement Code</a> <br><div class="spoiler">  <b class="spoiler_title">What did I keep silent about</b> <div class="spoiler_text">  I did not touch on the removal of lambda.  In the delegate version, we kept a pointer to the object, and when we delete the object, we can delete all the information about the subscriber.  Here I do not see any other solutions, except how to do the same and add another argument of the object pointer to the subscription method. <br></div></div><br><h2>  Results </h2><br>  As a result, we got a simple and quite convenient prototype of the messaging system.  All code is available <a href="http://github.com/aptakhin/ArticlesCode/tree/master/simple_messages">on GitHub</a> . </div><p>Source: <a href="https://habr.com/ru/post/211476/">https://habr.com/ru/post/211476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211466/index.html">A simple Python script to learn English words or why I don‚Äôt use flashcards</a></li>
<li><a href="../211468/index.html">VLC stereo player</a></li>
<li><a href="../211470/index.html">How to run a program without an operating system: part 5. Accessing the BIOS from the OS</a></li>
<li><a href="../211472/index.html">Basics of creating a 2D character in Unity 3D 4.3. Part 1: character preparation and animation of rest</a></li>
<li><a href="../211474/index.html">The easiest cross-platform server with ssl support</a></li>
<li><a href="../211478/index.html">Experience of implementing caching in a small project with a strong social component</a></li>
<li><a href="../211480/index.html">Playing MIDI sounds in JAVA</a></li>
<li><a href="../211482/index.html">Unity3D WWW Wrapper</a></li>
<li><a href="../211486/index.html">Olympic widgets for your site: live broadcast from social media</a></li>
<li><a href="../211488/index.html">Flexible cms for bold projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>