<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The most dangerous feature in the C / C ++ world</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testing various C / C ++ projects for many years, I declare: the most unfortunate and dangerous function is memset (). When using the function memset ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The most dangerous feature in the C / C ++ world</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/250/12c/9eb/25012c9ebc7d812b1592a0f5a6f6da86.png" alt="memset ()" align="left"><br>  Testing various C / C ++ projects for many years, I declare: the most unfortunate and dangerous function is memset ().  When using the function memset () allow the greatest number of errors in comparison with the use of other functions.  I understand that my conclusion is unlikely to shake the foundations of the universe or is incredibly valuable.  However, I think readers will be interested to know why I came to this conclusion. <br><br><h2>  Hello </h2><br>  My name is Andrey Karpov.  I combine many positions and occupations.  But the main thing that I do is tell programmers about the benefits that static code analysis can bring.  Naturally, I do it with a mercenary purpose, trying to interest readers in the PVS-Studio analyzer.  However, this does not reduce the interestingness and usefulness of my articles. <br><br>  The only type of advertising that programmers can penetrate with scaly armor is a demonstration of examples of errors that PVS-Studio can find.  To this end, I check a large number of open source projects and write articles about research results.  Universal Benefit.  Open projects are getting a little better, and our company has new customers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now it will become clear to what I am leading.  Being engaged in checking open projects, I have accumulated a large <a href="http://www.viva64.com/ru/examples/V501/">base of</a> examples of errors.  And now, based on it, I can find interesting patterns. <br><br>  For example, one of the interesting observations was that programmers make mistakes during Copy-Paste most often at the very end.  On this topic, I offer the article " <a href="http://www.viva64.com/ru/b/0260/">The effect of the last line</a> ". <br><a name="habracut"></a><br><h2>  New observation </h2><br>  Now I have another interesting observation.  Using these or other functions, programmers can make mistakes.  In this case, the probability of making an error depends on the function used.  In other words, some functions provoke errors, while others do not. <br><br>  So, I am ready to name the function, which, when used, is the most likely to sit in a puddle. <br><br>  So, the winner on glyuchnost - memset function! <br><br>  How it happened - it's hard to say.  Apparently she has a bad interface.  Plus, its very use is quite laborious and easy to make a mistake by calculating the values ‚Äã‚Äãof the actual arguments. <br><br>  The honorable second place is taken by the printf () function and its varieties.  I think it will not surprise anyone.  About the danger of the function printf () did not write just lazy.  Perhaps because of the well-known problems associated with printf (), she got into second place. <br><br>  I have a total of 9055 errors in my database.  These are the errors that the PVS-Studio analyzer is able to find.  It is clear that he can not all.  However, the large number of errors found allows me to be confident in my conclusions.  So, I decided that using the memset () function involves 329 errors. <br><br>  Total, about 3.6% of errors in the database is associated with the memset () function.  It's a lot! <br><br><h2>  Examples </h2><br>  Let's look at some typical examples of errors.  Looking at them, I think you will agree that something is wrong with the memset () function.  It attracts evil. <br><br>  First, let's refresh in memory how this function is declared: <br><br>  void * memset (void * ptr, int value, size_t num); <ul><li>  ptr - pointer to memory. </li><li>  value - Value to be set.  The value of the fills is what the block of memory uses. </li><li>  num - Number to by value.  'size_t' is an unsigned integral type. </li></ul><br>  <b>Example N1 (ReactOS project)</b> <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Mapdesc::identify( REAL dest[MAXCOORDS][MAXCOORDS] ) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( dest, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( dest ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i != hcoords; i++ ) dest[i][i] = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; }</code> </pre> <br>  The error is that in C and in C ++ it is impossible to pass arrays by value ( <a href="http://cpphints.com/hints/38">more</a> ).  The argument 'dest' is nothing more than an ordinary pointer.  Therefore, the sizeof () operator calculates the size of a pointer, not an array. <br><br>  Like memset () and not guilty.  But on the other hand, this function will fill only 4 or 8 bytes with zeros (exotic architectures do not count).  There is an error and it occurred when calling the memset () function. <br><br>  <b>Example N2 (project Wolfenstein 3D)</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cvar_s</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cvar_s</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">hashNext</span></span></span><span class="hljs-class">;</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">cvar_t</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cvar_Restart_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">cvar_t</span></span> *var; ... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>( var, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( var ) ); ... }</code> </pre> <br>  A similar error.  It is admitted most likely due to inattention.  The variable 'var' is a pointer.  So memset () will only reset part of the structure.  In practice, only the 'name' member will be zeroed out. <br><br>  <b>Sample N3 (SMTP Client project)</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MD5::finalize () { ... uint1 buffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; ... <span class="hljs-comment"><span class="hljs-comment">// Zeroize sensitive information memset (buffer, 0, sizeof(*buffer)); ... }</span></span></code> </pre> <br>  A very common error pattern, about which few programmers are nonetheless aware.  The fact is that the memset () function will be deleted by the compiler.  The buffer after calling memset () is no longer used.  And the compiler removes the function call for optimization.  From the point of view of the C / C ++ language, this has no effect on the behavior of the program.  It really is.  The fact that private information will remain in memory will not affect the operation of the program. <br><br>  This is not a compiler error.  And this is not my fantasy.  The compiler really deletes memset () calls.  Every time I describe this vulnerability error, I get emails where they start arguing with me.  I'm already tired of responding to these emails.  Therefore, I ask all doubters, before starting the discussion, carefully get acquainted with the following materials: <ul><li>  PVS-Studio documentation.  <a href="http://www.viva64.com/ru/d/0208/">V597</a> . </li><li>  Mansour Moufid.  <a href="http://www.eliteraspberries.com/blog/2012/10/zero-and-forget--caveats-of-zeroing-memory-in-c.html">Zero and forget - caveats of zeroing memory in C.</a> </li><li>  SEI CERT C Coding Standard.  <a href="https:/www.securecoding.cert.org/confluence/display/c/MSC06-C.%2BBeware%2Bof%2Bcompiler%2Boptimizations">MSC06-C</a> . </li><li>  <a href="http://www.viva64.com/ru/k/0041/">Overwrite memory - why?</a> </li></ul><br>  <b>Example N4 (project Notepad ++)</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONT_MAP_MAX 50 int _iContMap[CONT_MAP_MAX]; ... DockingManager::DockingManager() { ... memset(_iContMap, -1, CONT_MAP_MAX); ... }</span></span></code> </pre> <br>  It is often forgotten that the third argument of the memset () function is not the number of elements, but the size of the buffer in bytes.  This is exactly what happened in the above code snippet.  As a result, only a quarter of the buffer will be filled (provided that the size of the 'int' type is 4 bytes). <br><br>  <b>Example N5 (Newton Game Dynamics project)</b> <br><pre> <code class="cpp hljs">dgCollisionCompoundBreakable::dgCollisionCompoundBreakable(....) { ... dgInt32 faceOffsetHitogram[<span class="hljs-number"><span class="hljs-number">256</span></span>]; dgSubMesh* mainSegmenst[<span class="hljs-number"><span class="hljs-number">256</span></span>]; ... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(faceOffsetHitogram, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(faceOffsetHitogram)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(mainSegmenst, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(faceOffsetHitogram)); ... }</code> </pre> <br>  We are dealing with a typo.  Most likely someone was too lazy to dial the memset () function twice.  Duplicate line.  In one place, they replaced 'faceOffsetHitogram' with 'mainSegmenst', and in the other they forgot. <br><br>  It turns out that sizeof () calculates the size of the wrong array, which is filled with zeros.  It seems like the memset () function is not to blame.  But it will be wrong to work it. <br><br>  <b>Example N6 (CxImage project)</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> jpc_enc_tcmpt_t *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tcmpt_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tcmpt-&gt;stepsizes, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tcmpt-&gt;numstepsizes * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint_fast16_t</span></span>))); ... }</code> </pre> <br>  Here there is an extra sizeof () operator.  The correct size is calculated as follows: <br><pre> <code class="cpp hljs">tcmpt-&gt;<span class="hljs-function"><span class="hljs-function">numstepsizes * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sizeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint_fast16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  But they wrote an extra sizeof () and it turned out stupid: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tcmpt-&gt;numstepsizes * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint_fast16_t</span></span>))</code> </pre> <br>  Here the sizeof () operator calculates the size type of size_t.  It is this type that has an expression. <br><br>  I know that I want to argue.  This is not the first time the error has been associated with the sizeof () operator.  Those.  the programmer is mistaken when calculating the buffer size.  However, the cause of these errors is still the memset () function.  It is designed so that you have to do these various calculations, in which it is so easy to make a mistake. <br><br>  <b>Example N7 (WinSCP project)</b> <br><pre> <code class="cpp hljs">TForm * __fastcall TMessageForm::Create(....) { .... LOGFONT AFont; .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;AFont, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(AFont), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  The memset () function is omnivorous.  Therefore, calmly react, if you mix up the 2nd and 3rd arguments.  This is exactly what happened here.  This function fills 0 bytes. <br><br>  <b>Example N8 (Multi Theft Auto project)</b> <br><br>  And here is another similar error.  It seems that the Win32 API developers joked when they created this macro: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RtlFillMemory(Destination,Length,Fill) \ memset((Destination),(Fill),(Length))</span></span></code> </pre> <br>  By meaning, this is an alternative to memset ().  But you have to be careful.  Note that the 2 and 3 argument are swapped. <br><br>  When they start using RtlFillMemory (), they treat it as memset ().  And they think that their parameters are the same.  As a result, errors occur. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FillMemory RtlFillMemory LPCTSTR __stdcall GetFaultReason ( EXCEPTION_POINTERS * pExPtrs ) { .... PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL)&amp;g_stSymbol ; FillMemory ( pSym , NULL , SYM_BUFF_SIZE ) ; .... }</span></span></code> </pre> <br>  NULL is nothing like 0. Therefore, the memset () function has filled 0 bytes. <br><br>  <b>Sample N9 (IPP Samples project)</b> <br><br>  I think you understand that I can give examples of errors for a long time.  But this is not very interesting, since they will be very monotonous and similar to those already shown in the article.  But one more case let's consider. <br><br>  Although some of the above errors were found in C ++ code, they have nothing to do with C ++.  In other words, these errors occur when programming in C. style. <br><br>  The next error is related to the incorrect use of memset () in the C ++ program.  The example is quite long, so you can not peer into it.  Read the description below and everything will become clear. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaDataEx</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryStrongCasting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDynamicCastFunction pCandidateFunction)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryWeakCasting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDynamicCastFunction pCandidateFunction)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; Status VC1Splitter::Init(SplitterParams&amp; rInit) { MediaDataEx::_MediaDataEx *m_stCodes; ... m_stCodes = (MediaDataEx::_MediaDataEx *) ippsMalloc_8u(START_CODE_NUMBER*<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Ipp32s)+ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MediaDataEx::_MediaDataEx)); ... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(m_stCodes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (START_CODE_NUMBER*<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Ipp32s)+ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MediaDataEx::_MediaDataEx))); ... }</code> </pre> <br>  The memset () function is used to initialize an array consisting of class objects.  The biggest trouble is that the class contains virtual functions.  Accordingly, the memset () function not only clears the class fields, but also a pointer to a virtual method table (vptr).  What this will lead to is unknown.  But there is nothing good about this.  You can't handle classes like this. <br><br><h2>  Conclusion </h2><br>  As you can see, the memset () function has a very bad interface.  As a result, the memset () function more than any other provokes errors.  Be carefull! <br><br>  I am not ready to say now how to use my observation.  But I hope you were interested to get acquainted with this article.  Perhaps now, using memset (), you will be more attentive.  And this is good. <br><br>  Thank you all for your attention and subscribe to my <a href="https://twitter.com/Code_Analysis">@ <u>Code_Analysis twitter</u></a> . <br><br>  I also lead the <a href="http://cpphints.com/">C ++ Hints</a> resource, where I share various useful tips that come to my mind.  Subscribe. </div><p>Source: <a href="https://habr.com/ru/post/272243/">https://habr.com/ru/post/272243/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272233/index.html">2D shadows on WebGL in 4 easy steps</a></li>
<li><a href="../272235/index.html">Data Modeling and Databases for a Freshman</a></li>
<li><a href="../272237/index.html">Master class by Boris Wolfson. Agile basics</a></li>
<li><a href="../272239/index.html">Bug with GPU and Canvas in Google Chrome under Windows</a></li>
<li><a href="../272241/index.html">Elasticweb - the first adaptive virtual hosting</a></li>
<li><a href="../272245/index.html">Sparrow - perl framework for testing and monitoring web applications</a></li>
<li><a href="../272249/index.html">Proxmox 4.0: Root partition on ZFS RAID1 or how to increase fault tolerance if the server has only 2 disks</a></li>
<li><a href="../272251/index.html">Alternative to the IEEE754 standard</a></li>
<li><a href="../272253/index.html">Let's Encrypt go public beta: HTTPS everywhere, to everyone, from now on and forever free</a></li>
<li><a href="../272255/index.html">The news called for the road: a super-fast, energy-efficient optical coprocessor for big data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>