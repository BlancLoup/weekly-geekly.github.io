<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebRTC PeerConnection and DataChannel: Browser Data Exchange</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have heard about the project WebRTC , so I will not delve into the description. The other day I wanted to try sending messages between browsers, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebRTC PeerConnection and DataChannel: Browser Data Exchange</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/deb/a57/dfd/deba57dfd758e340ea294ff81d1fbc61.png" alt="image"><br><br>  Many have heard about the project <a href="http://webrtc.org/">WebRTC</a> , so I will not delve into the description.  The other day I wanted to try sending messages between browsers, and to figure this out, I decided to write a primitive P2P chat.  The experiment was deleted, and based on the reasons I decided to write this post.  On Habr√© there were already articles covering the use of WebRTC for video transmission, but I was interested in the possibility of exchanging text or binary data for the first (and last) turn. <br><a name="habracut"></a><br>  For communication between clients, we will use RTCPeerConnection (to establish a connection) and RTCDataChannel (for data transfer).  In the process, we will also need RTCIceCandidate and RTCSessionDescription, but more on that later. <br><br>  DataChannel protocol support has recently appeared in browsers, so for all this to work, you need Firefox 19+ or Chrome 25+.  However, in Firefox, &lt;22 WebRTC is disabled by default (the media.peerconnection.enabled parameter is set to true), and Chrome 25 needs to be launched with the - enable-data-channels flag.  I did not look at them, and this post is focused on Firefox 22+ and Chrome 26+.  Opera 15 does not support WebRTC. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Go </h4><br>  Since all this is in development and the designers in Firefox and Chrome have the prefixes moz and webkit respectively, let's put things in order: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>._RTCPeerConnection = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitPeerConnection00 || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitRTCPeerConnection || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.mozRTCPeerConnection || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.RTCPeerConnection || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.PeerConnection; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>._RTCIceCandidate = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitRTCIceCandidate || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.mozRTCIceCandidate || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.RTCIceCandidate; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>._RTCSessionDescription = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.webkitRTCSessionDescription || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.mozRTCSessionDescription || <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.RTCSessionDescription;</code> </pre> <br>  Implementations in Firefox and Chrome today are different, so we will need to define a browser. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browser = { <span class="hljs-attr"><span class="hljs-attr">mozilla</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/firefox/i</span></span>.test(navigator.userAgent), <span class="hljs-attr"><span class="hljs-attr">chrome</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/chrom(e|ium)/i</span></span>.test(navigator.userAgent) };</code> </pre><br>  In order for clients to know about each other, it is proposed to use a ‚Äúsignaling‚Äù mechanism, the implementation of which WebRTC leaves to the developer.  Usually this is a server through which clients learn about each other and exchange information, after which they establish a direct connection.  This diagram is well illustrated in the illustration I borrowed <a href="http://habrahabr.ru/post/163527/">from here</a> : <br><br><img src="https://habrastorage.org/storage2/75f/fad/9d2/75ffad9d2bfa22aff07d8460f477ef8f.png" alt="image"><br><br><ul><li>  the first client sends an Offer to the second client via the server; </li><li>  the second client sends the Answer to the first via the server; </li><li>  customers now know about each other and can connect. </li></ul><br>  In my case, I used WebSocket to communicate with the server on node.js.  If this is a chat, then our server remembers every connected client, knows how to transfer data from the client to the client and return a list of connected clients (for newly arrived users). <br><br>  Here I will not give the server code, since  this is beyond the scope of the article.  Let the client-side communication interface with our server be: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = { <span class="hljs-comment"><span class="hljs-comment">// ... send: function(evt, data) { //       this._send(evt, data); }, on: function(evt, callback) { //    ("ICE"  "SDP",     ) // ... } // ... }</span></span></code> </pre><br><h4>  Making a connection </h4><br>  Imagine that there are two users - Alice and Bob.  Bob went into the chat when there was no one there, and Alice went in a minute later and found out from the signal server that Bob was online and waiting for her.  In this case, Alice will send a connection request to Bob, and Bob will respond to her. <br><br>  To start the connection, Alice creates an RTCPeerConnection object (as you remember, we did a cross-browser _RTCPeerConnection just above).  The constructor needs to pass two arguments with parameters, which I will discuss below. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pc, channel; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = { <span class="hljs-attr"><span class="hljs-attr">iceServers</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: !browser.mozilla ? <span class="hljs-string"><span class="hljs-string">"stun:stun.l.google.com:19302"</span></span> : <span class="hljs-string"><span class="hljs-string">"stun:23.21.150.121"</span></span> }] }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> constrains = { <span class="hljs-attr"><span class="hljs-attr">options</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">DtlsSrtpKeyAgreement</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">RtpDataChannels</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }] }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isOffer</span></span></span><span class="hljs-function">) </span></span>{ pc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _RTCPeerConnection(config, constrains); <span class="hljs-comment"><span class="hljs-comment">//     pc.onicecandidate = function(evt) { if(evt.candidate) { //  ICE-         observer.send('ICE', evt.candidate); } }; pc.onconnection = function() { //      Firefox console.log('Connection established'); }; pc.onclosedconnection = function() { //   .  Chrome        console.log('Disconnected'); }; if(isOffer) { openOfferChannel(); createOffer(); } else { openAnswerChannel(); } }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    createPC(true);</span></span></code> </pre><br>  Since in the real world many users are behind provider <a href="http://ru.wikipedia.org/wiki/NAT">NAT</a> , WebRTC provides ways to bypass it ( <a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment">ICE</a> , <a href="http://en.wikipedia.org/wiki/STUN">STUN</a> , <a href="http://en.wikipedia.org/wiki/TURN">TURN</a> ).  The first parameter of the <i>config</i> is an object with an array of STUN and / or TURN servers.  You can use public, you can raise your own.  I used the STUN server from google.  By the way, if I understand correctly, today Firefox has problems using domain STUN servers, so it recommends using others. <br>  The <i>constrains</i> parameter is optional; it passes the connection settings.  About the option <i>DtlsSrtpKeyAgreement</i> can be read <a href="http://www.webrtc.org/interop">here</a> , and the option <i>RtpDataChannels</i> , <a href="http://www.webrtc.org/chrome">apparently</a> , is needed for Chrome 25 (and, perhaps, even some versions).  At 28 I worked without it. <br><br>  To establish a connection, participants need to exchange ICE candidates through a signaling server (they contain data about the network interface, address, etc.).  When each candidate appears, the pc.onicecandidate event will be triggered (it will start to work after the local session is set using the setLocalDescription method, which will be discussed below). <br><br>  We are preparing to accept candidates of another participant: <br><br><pre> <code class="javascript hljs">observer.on(<span class="hljs-string"><span class="hljs-string">'ICE'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ice</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ICE- pc.addIceCandidate(new _RTCIceCandidate(ice)); });</span></span></code> </pre><br>  Next, Alice creates a channel.  This channel will be used for data transmission: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openOfferChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ‚Äì  ,  - .    Chrome   UDP- (non-reliable),  Firefox ‚Äì  UDP,  TCP (reliable) channel = pc.createDataChannel('RTCDataChannel', browser.chrome ? {reliable: false} : {}); //  ,       binaryType  "blob",      Firefox (Chrome  ) if(browser.mozilla) channel.binaryType = 'blob'; setChannelEvents(); } function setChannelEvents() { channel.onopen = function() { console.log('Channel opened'); }; channel.onclose = function() { console.log('Channel closed'); }; channel.onerror = function(err) { console.log('Channel error:', err); }; channel.onmessage = function(e) { console.log('Incoming message:', e.data); }; }</span></span></code> </pre><br>  In the next step, Alice creates and sends ‚ÄúOffer‚Äù to Bob (session description with various service information, <a href="http://tools.ietf.org/html/rfc3264">SDP</a> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createOffer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ pc.createOffer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">offer</span></span></span><span class="hljs-function">) </span></span>{ pc.setLocalDescription(offer, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       observer.send('SDP', offer); //        pc.onicecandidate }, function(err) { console.log('Failed to setLocalDescription():', err); }); }, function(err) { console.log('Failed to createOffer():', err); }); }</span></span></code> </pre><br>  Now Alice is waiting for Bob‚Äôs session from the signaling server.  When this happens, the setRemoteSDP function is called. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRemoteSDP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sdp</span></span></span><span class="hljs-function">) </span></span>{ pc.setRemoteDescription(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _RTCSessionDescription(sdp), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pc.remoteDescription.type == <span class="hljs-string"><span class="hljs-string">'offer'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     createAnswer(); } }, function(err) { console.log('Failed to setRemoteDescription():', err); }); } observer.on('SDP', function(sdp) { if(!pc) { //  Offer    //    createPC(false); } setRemoteSDP(sdp); });</span></span></code> </pre><br>  Meanwhile, Bob receives Alice‚Äôs session from the signaling server, for his part, creates an RTCPeerConnection object and is preparing to accept the channel (this is called from the createPC function). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openAnswerChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ pc.ondatachannel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ channel = e.channel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(browser.mozilla) channel.binaryType = <span class="hljs-string"><span class="hljs-string">'blob'</span></span>; setChannelEvents(); }; }</code> </pre><br>  Finally, Bob saves Alice‚Äôs session, creates his own and sends it to Alice. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAnswer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ pc.createAnswer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">offer</span></span></span><span class="hljs-function">) </span></span>{ pc.setLocalDescription(offer, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       observer.send('SDP', offer); }, function(err) { console.log('Failed to setLocalDescription():', err); }); }, function(err) { console.log('Failed to createAnswer():', err); }); }</span></span></code> </pre><br><h4>  Message exchange </h4><br>  After the successful implementation of setRemoteDescription () for both participants and the exchange of ICE candidates, the connection between Alice and Bob should be established.  In this case, the channel.onopen event fires in Chrome and Firefox, and in pc.onconnection also fires in Firefox. <br><br>  Now Alice and Bob can exchange messages using the channel.send () method: <br><br><pre> <code class="javascript hljs">channel.send(<span class="hljs-string"><span class="hljs-string">"Hi there!"</span></span>);</code> </pre><br>  When a message arrives, the channel.onmessage event fires. <br><br><h4>  Disconnect definition </h4><br>  When another participant completes the connection, two events fire up in Firefox at once: pc.onclosedconnection and channel.onclose. <br>  But in Chrome nothing works, but for the pc object, the value of the iceConnectionState property changes to ‚Äúdisconnected‚Äù (according to my observations, it does not change immediately, but after a few seconds).  Therefore, you will have to make a small crutch until the developers have fixed the event call. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(browser.chrome) { setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pc.iceConnectionState == <span class="hljs-string"><span class="hljs-string">"disconnected"</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Disconnected"</span></span>); } }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre><br><h4>  Current issues </h4><br><ul><li>  I want to pay attention that today Chrome can send data no more than ~ 1100 bytes in length.  Therefore, in order to send something more, you will have to divide the message and send it in parts.  Firefox can already send large messages, it has no such problems. </li><li>  Another serious drawback is that while Chrome and Firefox are incompatible with each other (setRemoteDescription () with another browser session throws an error, the connection will not be established). </li><li>  Theoretically, this way you can send both text and binary data.  In Firefox, there are no problems with this, and the situation with Chrome is incomprehensible: they write on the Internet that binary data is not sent, and they wait for the developers to fix it, but I managed to send and receive them in Chrome 28 as well.  Maybe I do not understand something. </li></ul><br><h4>  Conclusion </h4><br>  The technology seems to me very promising, and now you can start experimenting with its implementation, albeit with significant limitations. <br>  And here is a <a href="http://luethus.org/chat/">link</a> to a simple chat, the creation of which inspired me to this article.  I wrote it exclusively for training and studying WebRTC, and in Chrome it will not be able to send more than ~ 1100 bytes (I did not do the breakdown). <br><br>  Information sources: <br><ul><li>  <a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html">draft specification</a> (there are also a couple of examples) </li><li>  <a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">cognitive HTML5 Rocks article</a> </li><li>  also helped the source of <a href="https://github.com/muaz-khan/WebRTC-Experiment">this project</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/187270/">https://habr.com/ru/post/187270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187256/index.html">Why is QA still not stackoverflow?</a></li>
<li><a href="../187258/index.html">My version of the reader for Habra</a></li>
<li><a href="../187260/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ66 (July 14 - 20, 2013)</a></li>
<li><a href="../187264/index.html">PopulateJS: don't repeat yourself in HTML markup</a></li>
<li><a href="../187266/index.html">How I studied in Informzaschita</a></li>
<li><a href="../187272/index.html">Type Family and Pokemon</a></li>
<li><a href="../187274/index.html">Danger! This mission to Mars will bore you to death!</a></li>
<li><a href="../187278/index.html">Computer generated efficient, but incomprehensible to man, TCP acceleration algorithms</a></li>
<li><a href="../187280/index.html">In Belarus, problems with access to Google</a></li>
<li><a href="../187282/index.html">The simplest implementation of cross-platform multiplayer on the example of the evolution of a single .NET game. Part two, more technical</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>