<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Separate interfaces for unit testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="According to the blog of our company, one may get the impression that we are only engaged in data mining and networks. Therefore, I, as a representati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Separate interfaces for unit testing</h1><div class="post__text post__text-html js-mediator-article">  According to the blog of our company, one may get the impression that we are only engaged in data mining and networks.  Therefore, I, as a representative of the developer shop, could not deny myself the pleasure of writing an article about how unit-testing and the division of code into modules are organized in our front end. <br><br> <a href="http://habrahabr.ru/company/ivi/blog/256517/"><img src="https://habrastorage.org/files/0ce/3da/7e1/0ce3da7e1ddd4d93af61694f10b7555a.jpg"></a> <br><a name="habracut"></a><br><h2>  <font color="#fd004c">A little about yourself</font> </h2><br>  I am engaged in the company Ivi.ru frontend-development.  We use the same API as mobile applications, so the implementation of all the basic logic of behavior and display rests on the client side.  If we consider that we have quite a lot of screens, we have a rather large code base, the quality of which needs to be monitored somehow.  Therefore, we are actively practicing TDD.  Well, and since we are all OOP maniacs, tests are organized in accordance with strict object-oriented canons. <br><br>  About the pain we experienced in organizing the unit-tests, and how we managed to cope with it and we‚Äôll go further. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#fd004c">Some theory</font> </h2><br>  <i><b>NB!</b></i>  <i>Hereinafter, the words ‚Äúmodule‚Äù, ‚Äúclass‚Äù and ‚Äúsubsystem‚Äù are used interchangeably, although in reality this is not always the case.</i> <br><br><h3>  Module connectivity </h3><br>  In the design of software, you can often find two characteristics that describe the quality of code splitting into modules ‚Äî Coupling and Cohesion.  Usually they talk about the principles of "Low Coupling" and "High Cohesion".  So what does this mean? <br><br><ul><li>  <b>Low Coupling</b> , or <b>low pairing</b> , means that the application module is minimally dependent on others and is only aware of the functionality it needs.  This means that with the right design, with a change in one module, we will not have to edit others or these changes will be minimal. <br><br></li><li>  <b>High Cohesion</b> , or <b>high connectivity,</b> says that inside the module, all functionality is coordinated and focused on solving some narrow problem.  This means that with proper design, the modules are compact and clear, do not contain ‚Äúextra‚Äù code and side effects. <br></li></ul><br><h3>  Unit testing </h3><br>  <b>Unit testing</b> is testing of individual modules of the system according to the black box principle.  That is, a class or set of classes responsible for a certain function is taken, test data is input to it, and the result of the work is compared with the reference one. <br><br>  To implement Unit-tests, instead of real external dependencies of the module, so-called mock-objects are used, that is, objects that replace the ‚Äúreal‚Äù functionality with a test one. <br><br>  Often used techniques ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25BA%25D0%25B0_%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B7_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">TDD</a> , <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a> ), in which tests are first written on a code that does not yet exist, and then the module itself that implements the tested functionality.  This is useful not only from the point of view of test coverage, but also from the point of view of the correct architectural organization of the modules, because first we design the external interfaces of the ‚Äúblack box‚Äù and then plunge into the implementation. <br><br>  Many architectural errors can be identified at the stage of writing tests, because, with a high degree of probability, if the code is convenient to test, then it just has a low pairing and high connectivity.  If the code under test has a high conjugation, then the implementation of the tests will result in complex, logic-rich mock objects, and if low connectivity, then many similar or complex cases and combinations of input and output data. <br><br><h2>  <font color="#fd004c">Lot of practice</font> </h2><br>  The main problem that we will solve in this article is the question of how to organize the code in such a way that the unit testing is simple and the code is accurate. <br><br>  Examples are given in TypeScript, but the approach is valid for any strongly typed object-oriented language (Java, C ++, ObjC). <br><br>  So, we will consider the elementary applied task: <br><br>  Suppose we have a helloworld-class A. Its code looks like this: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { greeting(): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b.getName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> b: B = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); }</code> </pre> <br>  As you can see, this class has an external dependency - B. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ getName(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Habr'</span></span>; } }</code> </pre><br>  Our task is to cover all the functionality of class A with tests. <br><br><h3>  <font color="#fd004c">Testing all</font> </h3><br>  The simplest method is ‚Äúhead on‚Äù, that is, to test all logic at once: <br><br><pre> <code class="javascript hljs"> it(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, ()=&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: A = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); expect(a.greeting()).toBe(<span class="hljs-string"><span class="hljs-string">'Hello, Habr!'</span></span>); });</code> </pre><br>  The pros and cons of this approach are quite obvious: <br><br><ul><li>  + Such code is easy to write. </li><li>  + It is convenient in cases when there are few tests in the project and they are used for catching complex bugs. </li><li>  - It is not the class A itself that is being tested, but a whole layer of functionality.  If the reservoir is large and the functionality is complex, the tests will be too voluminous and complicated.  By and large, this is not a unit test, but an <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2582%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">I &amp; T.</a> </li><li>  - If you change the code B, you have to edit all the tests of the modules using it. </li><li>  - Such tests do not encourage the developer to properly break the code into modules. </li></ul><br><h2>  <font color="#fd004c">Redefining the method on the fly</font> </h2><br>  ‚ÄúOkay,‚Äù you say, ‚Äúthen let's just redefine the field we need and that's it.‚Äù For example, like this: <br><br><pre> <code class="hljs coffeescript"> it(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ var a: A = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); a[<span class="hljs-string"><span class="hljs-string">'b'</span></span>] = { getName: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span><span class="hljs-string"><span class="hljs-string">'Test'</span></span> }; expect(a.greeting()).toBe(<span class="hljs-string"><span class="hljs-string">'Hello, Test!'</span></span>); });</code> </pre><br>  It would seem that the problem is solved, but no: if the field b is created inside the class dynamically, then we must constantly monitor this and slip our test value.  Eventually: <br><br><ul><li>  + No need to test external dependencies. </li><li>  - The principle of ‚Äúblack box‚Äù is violated - you need to edit the private field of the class. </li><li>  - It is necessary to ensure in the test that the replaced field is always relevant, that is, the class implementation itself does not overwrite its value. </li><li>  - It is impossible to do this in ‚Äúreal‚Äù strictly typed languages. </li><li>  - All this does not add readability tests </li></ul><br><h3>  <font color="#fd004c">Inheriting from class under test.</font> </h3><br>  In fact, this is the same method as in the previous example, only adapted for languages ‚Äã‚Äãwith strong typing.  First, we make the field b in class A not private, but protected, and create a mock class, a wrapper over A: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockA</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ constructor() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = { getName: ()=&gt;<span class="hljs-symbol"><span class="hljs-symbol">'Tes</span></span>t' }; } }</code> </pre><br>  We will test this new class: <br><br><pre> <code class="hljs coffeescript"> it(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ var a: A = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockA(); expect(a.greeting()).toBe(<span class="hljs-string"><span class="hljs-string">'Hello, Test!'</span></span>); });</code> </pre><br><ul><li>  + Strongly typed version of the previous approach. </li><li>  - It did not solve the problem. </li></ul><br><h3>  <font color="#fd004c">Dependency injection</font> </h3><br>  Of course, the problem of dependency management is not new, and its solution exists.  You, probably, have already heard about <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Dependency Injection</a> , if briefly - this is an approach in which the module does not manage its own dependencies, and they themselves come to it from outside (for example, through the constructor). <br><br>  In our case, it looks like this: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> b: B) {} greeting(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b.getName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span>; } }</code> </pre><br>  Then in the test itself we can wrap class B already: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockB</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ public getName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Tes</span></span>t'; } }</code> </pre><br>  And pass our white wrapper to A: <br><br><pre> <code class="hljs coffeescript"> it(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ var a: A = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockB()); expect(a.greeting()).toBe(<span class="hljs-string"><span class="hljs-string">'Hello, Test!'</span></span>); });</code> </pre><br><ul><li>  + Testing is honestly conducted according to the ‚Äúblack box‚Äù principle. </li><li>  + The code is correctly divided into modules. </li><li>  - It‚Äôs not always convenient to inherit from the real class (more on this later). </li></ul><br><h3>  <font color="#fd004c">Dependency injection using an interface</font> </h3><br>  It is not always easy to extend from a class, and the functionality that is implemented in it can have parasitic (for a given test) side effects.  The declaration of the interface of the module that we use as a dependency will help us solve this problem: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IB</span></span> { getName(): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; }</code> </pre><br>  Then instead of inheriting from the real class B, we simply implement its interface: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockB</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IB</span></span></span><span class="hljs-class"> </span></span>{ getName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Test'</span></span>; } }</code> </pre><br>  Testing will look the same as in the previous example: <br><br><pre> <code class="hljs coffeescript"> it(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ var a: A = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockB()); expect(a.greeting()).toBe(<span class="hljs-string"><span class="hljs-string">'Hello, Test!'</span></span>); });</code> </pre><br><ul><li>  + Tests test only one module and depend only on its implementation </li><li>  - Works only as long as the project is small and the subsystems are small </li></ul><br><h3>  <font color="#fd004c">We separate interfaces</font> </h3><br>  We proceed directly to the purpose for which this article was started, namely, to the separation of interfaces of one subsystem.  In foreign literature, this is sometimes called "Interface Decoupling" <br><br>  Let's now imagine that we have a large project with a large number of modules.  Let class A still use only one method from B, but it and other methods (of which there may be many) actively use other modules.  In this case, the IB interface is quite voluminous: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IB</span></span> { getName(): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; getLastName(): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; getBirthDate(): Date; }</code> </pre><br>  Now, in order to make a mock object for class A being tested, we will need to define a few more unnecessary methods: <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockB</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IB</span></span></span><span class="hljs-class"> </span></span>{ getName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Test'</span></span>; } getLastName():string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } getBirthDate():Date { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; } }</code> </pre><br>  Imagine what kind of wall of text we get if the module depends on a couple of other modules with 10+ methods.  Moreover, because of this, we get a high pairing, due to the fact that the module "knows" about the methods of another module that it does not use.  This leads to the fact that when changing the signature of one of the methods, the code will have to be changed in all tests, and not only in those that use the modified method. <br><br>  In order to avoid this excessive awareness, we will <i>separate the interfaces for specific subsystems</i> .  Select the sets of methods that each module uses from the IB interface and group them into separate interfaces.  In our case, it looks like this: <br><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBForA</span></span> { getName(): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; } export <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBForSomeOtherModule</span></span> { getLastName(): <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; getBirthDate(): Date; }</code> </pre><br>  Combining all of these interfaces and must implement class B: <br><br><pre> <code class="hljs java">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IB</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBForA</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBForSomeOtherModule</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IB</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: string </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Habr'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:string </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'last'</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBirthDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:Date </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); } }</code> </pre><br>  Class A, in turn, does not depend on the entire IB interface, but only on its own: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> b: IBForA) { } greeting(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b.getName() + <span class="hljs-string"><span class="hljs-string">'!'</span></span>; } }</code> </pre><br>  Thus, each module for each of its dependencies has an interface that describes what and only that is used in this module. <br><br><ul><li>  + Each module knows only what it needs to know about others. </li><li>  + Any local changes of one of the modules will affect only the tests for this module. </li><li>  + Changing one of the methods will only change the modules that directly use this interface. </li><li>  - A large number of interfaces and macro classes make it difficult to navigate in code. </li></ul><br><h2>  <font color="#fd004c">Instead of conclusion</font> </h2><br>  As always it turns out in practice, it is most convenient to use some kind of hybrid approach.  For example, on our project we use interface separation only for large subsystems, and inside them for classes we make mock-objects a simple extend. <br><br>  In any case, the patterns described make life easier when working on TDD.  As I wrote above, properly organized tests help identify the architectural problem <i>prior to its implementation</i> , and this is saved man-hours of developers and nerves of managers. <br><br>  <i>All the examples described here can be viewed on <a href="https://github.com/koroandr/decoupling_habr">github</a></i> . <br><br>  <b><i>Many thanks to <a href="https://habrahabr.ru/users/darkartur/" class="user_link">darkartur</a> for help in writing this article.</i></b> </div><p>Source: <a href="https://habr.com/ru/post/256517/">https://habr.com/ru/post/256517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256503/index.html">Write under that, I don‚Äôt know what: development features for Apple Watch using Mail.Ru Mail as an example</a></li>
<li><a href="../256505/index.html">Webix. The first acquaintance with the JavaScript framework</a></li>
<li><a href="../256509/index.html">Subject-event approach to modeling complex systems</a></li>
<li><a href="../256513/index.html">The challenge of a hundred boxes and the rescue of prisoners - the final chord</a></li>
<li><a href="../256515/index.html">Script to backup EC2-instance to AMI</a></li>
<li><a href="../256521/index.html">Scientifically looking for errors in the cloud: an unexpected CEO adventure</a></li>
<li><a href="../256523/index.html">Sprockets 3 encoding problem when working with HTML files</a></li>
<li><a href="../256525/index.html">Checking the Haiku operating system (BeOS family) with PVS-Studio. Part 2</a></li>
<li><a href="../256527/index.html">Prototype this Or useful functionality faster than a cup of coffee</a></li>
<li><a href="../256529/index.html">Overview of add-ons for Blender 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>