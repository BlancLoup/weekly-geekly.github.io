<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Browsers and app specific security mitigation. Part 3. Google Chrome</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the series of articles on exploit protection mechanisms for browsers: 


- Introduction 
- Internet Explorer & Edge 


 Let's take a look ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Browsers and app specific security mitigation. Part 3. Google Chrome</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/2c5/f0a/3ad/2c5f0a3ad34345fba9fbe9b14f81c7b3.jpg" alt="image"></p><br><p>  We continue the series of articles on exploit protection mechanisms for browsers: </p><br><ul><li>  <a href="https://habrahabr.ru/company/dsec/blog/310676/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/company/dsec/blog/311616/">Internet Explorer &amp; Edge</a> </li></ul><br><p>  Let's take a look under the hood of the Chrome browser and find out what is in its anti-exploit arsenal. </p><br><a name="habracut"></a><br><p>  Involves the common mechanisms provided by modern versions of Windows and compilers: </p><br><ul><li>  Randomization of module databases (Image ASLR); </li><li>  HighEntropy ASLR (uses 64-bit addresses, Windows 8+); </li><li>  Force ASLR (forced randomization of module databases); </li><li>  Randomization of allocations (HeapAlloc, VirtualAlloc; Windows 8+): <br>  Memory allocation functions select the base of the returned memory in three ways: <br><ul><li>  choosing the lowest address; </li><li>  choosing the topmost address; </li><li>  choosing an address relative to a given base. <br>  On systems prior to Windows 8, the first two methods were not randomized at all, and therefore <br>  allowed to allocate memory at predictable addresses. </li></ul></li><li>  Data Execution Prevention: <br>  non-executable memory (stacks, heaps, sections of these modules, etc.). </li><li>  Stack cookies (canaries): <br>  in the function prologue, a random value is placed on the stack before the return address, which is checked before returning control.  Complicates the operation of buffer overflows in a stack. </li><li>  Safe Structured Exception Handling (SAFESEH): <br>  Prevents control taking over by rewriting the contents of the SEH_EXCEPTION_REGISTRATION_RECORD control structures.  Before you transfer control to the handler specified in this structure, it is checked.  If the executable module to which the handler belongs is built with / SAFESEH, then the address is checked using the SEH table of the handlers of this module (they are stitched into the binary during linking). </li><li>  Structured Exception Handler Overwrite Protection (SEHOP): <br>  complements the previous technique, because by itself it was far from perfect.  Firstly, it required the application to be recompiled, and secondly, if the processor was located in a module without / SAFESEH or even outside of any module, it simply did not work.  Therefore, Microsoft has added the OS-SEHOP technique.  Its essence lies in verifying the integrity of the SEH chain: when starting a stream, a canary was added to the chain of SEH handlers, which was checked before calling any handlers.  As a rule, when rewriting the address of an exception handler, the pointer is also overwritten with the following structure in the chain, which breaks the chain and makes the canary inaccessible. </li><li>  Control Flow Guard (CFG): <br>  prevents the control flow from being intercepted by rewriting addresses in program data, including virtual function tables, by checking addresses on indirect jump instructions.  Valid addresses of module functions are stored in a bitmap that is built by the compiler.  <a href="https://habrahabr.ru/company/dsec/blog/305960/">More details</a> . </li><li>  Windows mitigation policies: <br>  a number of restrictions applied by Windows 8+ to processes, of which Chrome uses the following for its sandbox: <br><ul><li>  Relocate Images </li><li>  Heap terminate </li><li>  Bottom-up ASLR </li><li>  High-entropy ASLR </li><li>  Strict handle checks </li><li>  Disable Font Loading </li><li>  Disable Image Load from Remote Devices </li><li>  Disable Image Load of "mandatory low" (low integrity level) </li><li>  Extra Disable Child Process Creation </li></ul></li></ul><br><p>  We consider the internal mechanisms of the browser: </p><br><ul><li>  Allocator PartitionAlloc: <br>  allows you to spread objects of different sizes and types to different heaps, thereby cutting off the attacker's ability to select candidate objects for freed memory.  Helps to catch heap over / underflows both inside the hip itself and at its borders.  Read more - next. </li><li>  Tracing garbage collector for C ++ - Oilpan; </li><li>  JavaScript jit compiler: <br>  includes a number of mechanisms that make it difficult to use to generate elements of the exploit. </li><li>  Sandbox: <br>  browser security system designed to reduce damage from compromising its components. </li></ul><br><h2 id="vvedenie-pro-uaf-i-povrezhdeniya-pamyati">  Introduction to UaF and Memory Damage </h2><br><p>  The browser provides some API for managing the document's component objects ‚Äî web pages.  The content of this document is represented as a tree of nodes, each node of which ‚Äî an element, attribute, text, graphic, or any other object ‚Äî is a representation of the DOM.  The nodes of this tree - "nodes" - can be created, destroyed and modified by JavaScript.  The existence of many interdependent complex objects is a prerequisite for the presence of bugs, and the convenience of managing these objects using JavaScript is a way to use these bugs. </p><br><p>  The bugs that cause damage to objects in the heap are very often the starting point for the entire sequence of actions that the browser exploit performs.  The vulnerabilities caused by them can be divided into two broad categories: </p><br><ol><li>  temporary (temporary) - arising from an attempt to use an object outside its period of existence (calling an object method after its release, for example); </li><li>  spatial (spatial) - generated by erroneous access beyond the location of an object in memory (accessing an array element at an invalid index, for example). </li></ol><br><p>  To prevent a targeted impact on other objects in memory, using a vulnerable object, it is proposed to consider a number of mechanisms implemented in the allocator - heap managers. </p><br><p>  Blink, the Chrome renderer, uses two of its own allocators: PartitionAlloc and Oilpan (aka BlinkGC).  There are two separate rare cases: </p><br><ul><li>  discardable memory - paged memory, which is used for caching large graphic objects;  is released when the free memory on the device is exhausted; </li><li>  malloc, from which they want to completely get rid of. </li></ul><br><h3 id="partitionalloc">  PartitionAlloc </h3><br><p>  PartitionAlloc is used for objects for which <strong>automatic garbage collection</strong> is <strong>not supposed</strong> .  This is his key difference from Oilpan, about which later. </p><br><p>  PartitionAlloc design includes elements related to the security of objects in memory: </p><br><ul><li>  partitioning the allocation of objects of different types.  This isolation allows you to reduce the opportunities that an attacker will have in the event of exploitation of bugs leading to reading or writing data outside the vulnerable object to another type of object, for example, a linear buffer overflow in this heap. <br><ol><li>  LayoutObjects - objects closely associated with DOM nodes that are used by the renderer to display page elements. </li><li>  Buffers - buffers for arrays, strings, bitvectors. </li><li>  FastMalloc - here is a fairly extensive list of various objects. </li></ol></li><li>  storing heap metadata in a separate region ‚Äî i.e.  they are also insulated to prevent damage; </li><li>  pointer to freelist (list of free memory blocks) is protected from partial overwriting or dereferencing; </li><li>  large allocations are placed separately and framed by guard pages - pages of memory before and after the end of the selected block, when accessed by the process, it is immediately interrupted. </li></ul><br><p>  You can illustrate this development by looking at the Pinkie Pie <a href="https://repo.zenk-security.com/Techniques%2520d.attaques%2520%2520.%2520%2520Failles/Mobile%2520Pwn2Own%2520Autumn%25202013%2520-%2520Chrome%2520on%2520Android%2520-%2520Exploit%2520Writeup.pdf">exploit</a> demonstrated on Mobile Pwn2Own 2013. Here the author uses integer overflow, which occurs in the constructor of a typed array.  The conditions are as follows: the buffer of the array Float64 is allocated, while the sequential initialization of all its elements goes beyond its end and the recording of arbitrary values ‚Äã‚Äãof the type Float64 can be continued indefinitely further every 8 bytes of memory after the allocated buffer.  For an array of suitable length, you need a large buffer, PartitionAlloc delegates its allocation to the system allocator - dlmalloc on Android.  Pinkie Pie rewrote the header of the next allocation in the heap, changing its size, releasing the object placed there (adding a block of the required size to the freelist) and thus achieving the selection of the next object of a given size at this place ‚Äî where you can continue to write arbitrary values. <br>  From here we see what the developers are protecting the metadata of the allocator, why large locations are framed by guard pages, which will not allow to go beyond the buffer in such a way that the buffers of typed arrays are isolated from other objects. </p><br><h3 id="oilpan">  Oilpan </h3><br><p>  Oilpan offers automatic garbage collection.  This system removes from developers the need for manual memory management, which is the cause of use-after-free class errors.  Let us briefly recall the essence of the vulnerabilities caused by such errors: the premature release of the object occurs, that is, the release, after which it can be used. </p><br><p>  As an example, let's take a look at what we managed to find on the project‚Äôs bug tracker: <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D69965">https://bugs.chromium.org/p/chromium/issues/detail?id=69965</a> This is a UaF bug related to the Geolocation class.  The following happens: objects of the Geolocation class are destroyed when the page is updated, however, the associated requests for permission of geolocation were not previously canceled, because of which there are hanging pointers in the request manager, and an attempt to cancel them when the tab is closed in the future ends with erroneous access to the released geolocation object.  The patch for this bug adds the pageDestroyed method to the Geolocation class, which apparently should have arranged the correct order for releasing page objects.  Since then, the Geolocation class has undergone changes due to the introduction of Oilpan, it is now automatically controlled by this system. </p><br><p> The operation of such bugs consists of the following stages: fulfillment of conditions in which the vulnerable object will be removed from the heap, placement of monitored data on the memory freed from this object - thus creating a "fake object" and fulfilling the conditions leading to using elements of this fake object as its own members .  In order to prevent the second part of this action - making a fake object by placing it on the free memory - the Chrome developers isolate regions of memory in which objects of different types live.  Let's see how this is done: </p><br><pre><code class="hljs pgsql">// Override <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> allocate Node subtype objects onto // a dedicated heap. GC_PLUGIN_IGNORE("crbug.com/443854") <span class="hljs-type"><span class="hljs-type">void</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(size_t size) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> allocateObject(size, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } static <span class="hljs-type"><span class="hljs-type">void</span></span>* allocateObject(size_t size, <span class="hljs-type"><span class="hljs-type">bool</span></span> isEager) { ThreadState* state = ThreadStateFor&lt;ThreadingTrait&lt;Node&gt;::Affinity&gt;::state(); const <span class="hljs-type"><span class="hljs-type">char</span></span> typeName[] = "blink::Node"; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ThreadHeap::allocateOnArenaIndex( state, size, isEager ? BlinkGC::EagerSweepArenaIndex : BlinkGC::NodeArenaIndex, GCInfoTrait&lt;EventTarget&gt;::<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(), typeName); }</code> </pre> <br><p>  <em>chromium // src / third_party / WebKit / Source / core / dom / Node.h</em> </p><br><p>  In the overridden new, allocateObject is called, the argument isEager == false, so - next, the ThreadHeap :: allocateOnArenaIndex takes the third argument arenaIndex BlinkGC :: NodeArenaIndex - the index of the "arena" (region of memory) in which we will allocate the object: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Address ThreadHeap::allocateOnArenaIndex(ThreadState* state, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arenaIndex, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> gcInfoIndex, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* typeName) { ASSERT(state-&gt;isAllocationAllowed()); ASSERT(arenaIndex != BlinkGC::LargeObjectArenaIndex); NormalPageArena* arena = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;NormalPageArena*&gt;(state-&gt;arena(arenaIndex)); Address address = arena-&gt;allocateObject(allocationSizeFromSize(size), gcInfoIndex); HeapAllocHooks::allocationHookIfEnabled(address, size, typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address; }</code> </pre> <br><p>  <em>chromium // src / third_party / WebKit / Source / platform / heap / Heap.h</em> </p><br><p>  What other regions are defined? </p><br><pre> <code class="hljs pgsql"> enum HeapIndices { EagerSweepArenaIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>, NormalPage1ArenaIndex, NormalPage2ArenaIndex, NormalPage3ArenaIndex, NormalPage4ArenaIndex, Vector1ArenaIndex, Vector2ArenaIndex, Vector3ArenaIndex, Vector4ArenaIndex, InlineVectorArenaIndex, HashTableArenaIndex, FOR_EACH_TYPED_ARENA(TypedArenaEnumName) LargeObjectArenaIndex, // <span class="hljs-keyword"><span class="hljs-keyword">Values</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> iteration <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> heap segments. NumberOfArenas, }; * * * // List <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> typed arenas. The list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> used <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> generate the implementation // <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> typed arena related methods. // // <span class="hljs-keyword"><span class="hljs-keyword">To</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> a <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> typed arena <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> a H(&lt;ClassName&gt;) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the // FOR_EACH_TYPED_ARENA macro below. #define FOR_EACH_TYPED_ARENA(H) \ H(Node) \ H(CSSValue) #define TypedArenaEnumName(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>##ArenaIndex,</code> </pre> <br><p>  <em>chromium // src / third_party / WebKit / Source / platform / heap / BlinkGC.h</em> </p><br><p>  Here we see: objects of the Node, CSSValue, HashTables, Vectors classes will be divided into memory;  The remaining objects are distributed by region by size. </p><br><p>  Let us turn to the consideration of the key property of Oilpan / BlinkGC - automatic garbage collection.  Objects that should be managed by this system are inherited from the <strong>GarbageCollected</strong> , <strong>GarbageCollectedFinalized</strong> or <strong>GarbageCollectedMixin</strong> template class.  Heap member objects of these classes are represented by the <strong>Member</strong> or <strong>WeakMember</strong> template classes, depending on the semantics required. </p><br><p>  The garbage collection algorithm is the mark-and-sweep algorithm, and consists of two main steps: </p><br><ol><li>  mark - traversing the object graph is performed; for this, the trace () method of each is called, marking all of the reachable objects from the given one;  The starting points for such a tour can be selected depending on the current state of the program in two variations: <br><ul><li>  precise - is selected when the program threads are stopped at the end of the message processing cycles.  This ensures the absence of "raw" (raw) pointers in the stacks of threads means that you can proceed from the special global pointers "persistent handles"; </li><li>  conservative - implemented when there is a need to go through the stacks of streams and take from there possible pointers. </li></ul></li><li>  sweep - unreachable objects detected in the previous step are marked for release and will be destroyed when memory is needed.  Due to the nondeterministic order of deferred removal of objects from the heap, at the time of the call of a destructor of an object, it is no longer possible to rely on the presence of related objects in the heap.  Therefore, developers add a special method - pre-finalizer, called between these stages for unreachable objects when they are still alive. </li></ol><br><h1 id="jit-hardening">  JIT Hardening </h1><br><p>  If the instructions received during the assembly of dynamically generated code did not change, the attacker would receive a powerful primitive that allows you to create shellcode in executable memory.  To avoid this, a series of counter measures were introduced: </p><br><ul><li><p>  NOPs </p><br><p>  NOPs (instructions that do not change the state of the environment, the only purpose of which is to take up space) of various sizes - from one to eight bytes - are randomly inserted into the program body.  They are needed to eliminate the possibility of the appearance of constant sequences of bytes in the assembled code. </p><br><pre> <code class="hljs ruby">void Assembler::Nop(int n) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> The recommended muti-byte sequences of NOP instructions from the Intel <span class="hljs-number"><span class="hljs-number">64</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ and IA-32 Architectures Software Developer's Manual. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Length Assembly Byte Sequence /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 bytes 66 NOP 66 90H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3 bytes NOP DWORD ptr [EAX] 0F 1F 00H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4 bytes NOP DWORD ptr [EAX + 00H] 0F 1F 40 00H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5 bytes NOP DWORD ptr [EAX + EAX*1 + 00H] 0F 1F 44 00 00H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 6 bytes 66 NOP DWORD ptr [EAX + EAX*1 + 00H] 66 0F 1F 44 00 00H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 7 bytes NOP DWORD ptr [EAX + 00000000H] 0F 1F 80 00 00 00 00H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 8 bytes NOP DWORD ptr [EAX + EAX*1 + 00000000H] 0F 1F 84 00 00 00 00 00H /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 9 bytes 66 NOP DWORD ptr [EAX + EAX*1 + 66 0F 1F 84 00 00 00 00 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 00000000H] 00H ... }</span></span></code> </pre> <br></li><li><p>  Constant folding </p><br><p>  Arithmetic expressions are counted (collapsed) during code assembly: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> x = </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0x123</span></span></span><span class="actionscript"> + </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0x567</span></span></span><span class="actionscript">; </span><span class="hljs-comment"><span class="actionscript"><span class="hljs-comment">// == 0x68A </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> rax,68A00000000h</code> </pre> <br></li><li><p>  Constant blinding </p><br><p>  Only values ‚Äã‚Äãup to two bytes are stored unchanged in the code.  For example: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> a = 0x1234; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Will be compiled in: </p><br><pre> <code class="hljs erlang">... mov rax,<span class="hljs-number"><span class="hljs-number">123400000000</span></span>h ...</code> </pre> <br><p>  Larger constants conquer random numbers (jit_cookie): </p><br><pre> <code class="hljs ruby">void MacroAssembler::SafeMove(Register dst, Smi* src) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsUnsafeInt(src-&gt;value()) &amp;&amp; jit_cookie() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SmiValuesAre32Bits()) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> JIT cookie can be converted to Smi. Move(dst, Smi::FromInt(src-&gt;value() ^ jit_cookie())); Move(kScratchRegister, Smi::FromInt(jit_cookie())); xorp(dst, kScratchRegister); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { DCHECK(SmiValuesAre31Bits()); int32_t value = static_cast&lt;int32_t&gt;(reinterpret_cast&lt;intptr_t&gt;(src)); movp(dst, Immediate(value ^ jit_cookie())); xorp(dst, Immediate(jit_cookie())); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Move(dst, src); } }</code> </pre> <br></li><li><p>  Guard pages </p><br><p>  The buffer containing the compiled JIT code is framed by PAGE_NOACCESS pages to prevent it from being overwritten if heap overflows in nearby locations. </p><br></li><li><p>  JIT Page Randomization </p><br><p>  The memory location where the collected JIT code will be located is often (but not always) randomized.  If the free address is not guessed from three attempts, Chrome lets the system allocator choose the address for the created buffer. </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RandomizedVirtualAlloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> protection)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (use_aslr &amp;&amp; (protection == PAGE_EXECUTE_READWRITE || protection == PAGE_NOACCESS)) { <span class="hljs-comment"><span class="hljs-comment">// For executable pages try and randomize the allocation address for (size_t attempts = 0; base == NULL &amp;&amp; attempts &lt; 3; ++attempts) { base = VirtualAlloc(OS::GetRandomMmapAddr(), size, action, protection); ... } void* OS::GetRandomMmapAddr() { ... static const uintptr_t kAllocationRandomAddressMin = 0x0000000080000000; static const uintptr_t kAllocationRandomAddressMax = 0x000003FFFFFF0000; ... uintptr_t address; platform_random_number_generator.Pointer()-&gt;NextBytes(&amp;address, sizeof(address)); address &lt;&lt;= kPageSizeBits; address += kAllocationRandomAddressMin; address &amp;= kAllocationRandomAddressMax; return reinterpret_cast&lt;void *&gt;(address); }</span></span></code> </pre> <br></li></ul><br><h1 id="sandboxing">  Sandboxing </h1><br><p>  Chrome implements a multi-process architecture that allows you to assign different privileges and restrictions for different parts of the browser.  The unit that the sandbox operates on is a process.  The minimum configuration of the Chrome sandbox includes two processes: one privileged, called a <em>broker</em> , and one (or more) <em>isolated</em> .  For example, how isolated processes stand out renderers - Blink engine instances that render HTML documents.  Renderers are launched for tabs of web pages and for browser extensions.  The risk of compromise of the renderer is high, because inside it there is an interpretation of heterogeneous code downloaded from any sources that the user will surf.  In addition to renderers, separate processes are containers of plug-ins (flash), auxiliary ones are crash reporter, gpu accelerator for graphics.  Renderers and others use IPC (inter-process communication) to request access to resources from a broker.  They delegate such API calls to the broker via IPC, the broker checks the delegated call with the policy specified for each isolated process, the allowed calls are executed, and the result is returned back through the same IPC mechanism. </p><br><p><img src="https://habrastorage.org/files/db6/1d4/274/db61d4274a194873b7cd0ed5ed0f6e06.PNG" alt="sbox_top_diagram"><br>  <em>Chrome sandbox model, <a href="https://www.chromium.org/developers/design-documents/sandbox">source</a></em> </p><br><p>  Windows tools on which Chrome process isolation is based: </p><br><ul><li>  Access token (access token) </li><li>  Job object </li><li>  Desktop object </li><li>  Integrity Levels </li><li>  Appcontainer </li><li>  Windows Mitigation Policies </li></ul><br><p>  It is worth noting once again that there is an interaction between isolated processes and a preferred broker, which means exit from the sandbox can be accomplished not only through the weaknesses of the above-listed system mechanisms, but also through exploiting the broker's vulnerability that is achievable through IPC.  This approach was demonstrated by Pinkie Pie on Mobile Pwn2Own 2013, in conjunction with RCE, which we have already discussed earlier in this article: see Part II, <a href="https://repo.zenk-security.com/Techniques%2520d.attaques%2520%2520.%2520%2520Failles/Mobile%2520Pwn2Own%2520Autumn%25202013%2520-%2520Chrome%2520on%2520Android%2520-%2520Exploit%2520Writeup.pdf">link</a> . </p><br><h2 id="access-token">  Access token </h2><br><p>  The access token contains SIDs - identifiers of the subjects of access: users and groups.  Isolated processes are assigned a token containing a NULL SID (S-1-0-0), for which the system will hardly detect an object with an ACL that can be obtained. </p><br><p><img src="https://habrastorage.org/files/003/f00/ab6/003f00ab61a44d0c8ab1cd148eb43cf8.png" alt="nullsid"></p><br><p>  How does such a process get the handle of a file?  On API functions (here - ZwCreateFile), normal hooks are installed, the call is redirected through the sandbox modules to the broker, the broker opens the file and duplicates the handle back. </p><br><p><img src="https://habrastorage.org/files/d95/027/b62/d95027b62d304d9e9f346b2c2fa45ac3.png" alt="ntdllhook"></p><br><h2 id="job-object">  Job object </h2><br><p>  Includes some special restrictions related to non-ACL managed resources.  This entity prohibits the creation of child processes, reading / writing clipboard and so on.  <a href="https://www.microsoft.com/msj/0399/jobkernelobj/jobkernelobj.aspx">More details</a> . </p><br><p><img src="https://habrastorage.org/files/4cb/35a/c6c/4cb35ac6c4de4d489604c1f7b50139b5.png" alt="jobobj"></p><br><h2 id="desktop-object">  Desktop object </h2><br><p>  For isolated processes, Chrome creates a separate desktop object in order to prevent interaction with other processes by passing messages to their windows. </p><br><p>  Why is this interaction dangerous?  This is the old weakness of the Windows architecture that was used to execute the so-called.  <a href="http://security.tombom.co.uk/shatter.html">Shatter Attack</a> .  Window messages up to Vista were anonymous and could be sent to any process.  A particularly piquant opportunity was given by the WM_TIMER message with the address of the function to which the target process will transfer control without any participation on its part. </p><br><p>  In Vista and later versions, the transfer of messages between processes was limited based on their Integrity level (power of attorney): User Interface Privilege Escalation.  Less privileged processes can no longer send messages to more privileged ones. </p><br><h2 id="integrity-levels-appcontainer">  Integrity levels, AppContainer </h2><br><p>  Windows access control mechanisms, we wrote about them in the previous <a href="https://habrahabr.ru/company/dsec/blog/311616/">article</a> . </p><br><h2 id="windows-mitigation-policieshttpsmsdnmicrosoftcomen-uslibrarywindowsdesktophh769088vvs85aspx">  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh769088(v%3Dvs.85).aspx">Windows Mitigation Policies</a> </h2><br><p>  A set of new Windows security features that can be enabled for processes partially overlap the capabilities of the <a href="https://support.microsoft.com/ru-ru/kb/2458544">EMET (Enhanced Mitigation Experience Tool Tool)</a> .  Here are features such as disabling font loading (parsing in the Windows kernel), modules in your process, and also creating processes. </p><br><p>  The ban on creating processes intersects with what has already been done in the Job object for isolated Chrome processes, but there was one funny gap in the Job object.  The workaround is to call the AllocConsole API, which creates a console window for the program, and the host process conhost.exe will be launched for the console window.  Read more about these policies and their weaknesses in the <a href="http://www.slideshare.net/JamesForshaw1/the-joy-of-sandbox-mitigations">presentation</a> by the researcher James Forshaw. </p><br><h3 id="processsystemcalldisablepolicy--win32ksys-lockdown">  ProcessSystemCallDisablePolicy / Win32k.sys Lockdown </h3><br><p>  We will consider this policy separately. </p><br><p>  The Windows graphics subsystem has been delivering LPE vulnerabilities for many years.  In the case of browser attacks, they are used after RCE.  Having received the execution of the code in the render process, the exploit elevates privileges through the vulnerability of the Windows component, thereby gaining full access to the system.  This can be illustrated with a well-documented exploit for the win32k kernel pool corruption vulnerability, which was demonstrated by researchers at MWR Labs at Pwn2Own 2013 in conjunction with RCE in Chrome: <a href="https://labs.mwrinfosecurity.com/blog/mwr-labs-pwn2own-2013-write-up-kernel-exploit/">article</a> <a href="https://labs.mwrinfosecurity.com/assets/BlogFiles/MWR-PolishingChrome-NSC-slides.pdf">presentation</a> . </p><br><p>  The vulnerability was found in the call handler, which is used to transfer messages between windows:  .  The last bAnsi parameter determines the encoding of the message text that is copied from the process that caused the service to the kernel memory: WCHAR or ASCII - 2 or 1 byte per character.  And this parameter was interpreted differently when the buffer was allocated in the kernel pool and when the message was copied to the buffer - first as bool, then as bitmask.  This made it possible to overflow the buffer by copying twice as many bytes into it.  Thus, by manipulating the data in the kernel, we achieved the execution of shellcode in ring0, the shellcode reset the ACL of the privileged process winlogon.exe, that is, left it vulnerable to trivial code injection.  Profit! </p><br><p><img src="https://habrastorage.org/files/3e4/735/76f/3e473576fc404648998ba80d583f9695.png" alt="win32ksys"><br>  <em>Win32k problem</em> </p><br><p>  The development of this simple, at first glance, countermeasure took a lot of time and effort, as it required modification not only of the Chrome code itself, but also coordination with the Adobe Flash Player and Pdfium development teams (lockdown is needed not only for rendering processes, but also for PPAPI processes where plugins are executed).  Google engineers have added their broker to the Flash stack with win32k.  Currently, a full-fledged lockdown implementation exists only for Windows 10, since the operating system itself provides <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh871472(v%3Dvs.85).aspx">filtering</a> capabilities <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh871472(v%3Dvs.85).aspx">for system calls</a> .  It is highly recommended to read the <a href="https://googleprojectzero.blogspot.ru/2016/11/breaking-chain.html">document</a> describing the problems and solutions of this remedy. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Chrome's strength is, of course, the sandbox.  Here we see a wide range of ways to limit the authority to mitigate the effects of exploiting vulnerabilities in the renderer code base.  The set of these methods depends on what the operating system offers us; in newer versions of Windows, many new and interesting things have been added.  In addition, much attention is paid to managing dynamic memory, which remains in the background when creating new browser features for the modern web, but is of paramount importance from a security point of view.  The developers have implemented a progressive garbage collection system and obtained new properties of the environment in which the browser components are executed, which are not typical for ordinary C ++ applications. </p><br><h1 id="avtory">  The authors </h1><br><ul><li>  Dmitry Turchenkov / <a href="https://habrahabr.ru/users/d-t/">@dt</a> </li><li>  Bourbygin Igor / <a href="https://habrahabr.ru/users/igor1024/">@ igor1024</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/319234/">https://habr.com/ru/post/319234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319222/index.html">Reducing the amount of PostgreSQL data on disk</a></li>
<li><a href="../319226/index.html">Simple and fast terrain generation algorithm</a></li>
<li><a href="../319228/index.html">Saving and loading the game in the Unreal Engine</a></li>
<li><a href="../319230/index.html">A little bit about programming trends in 2016: a series of conferences #ITsubbotnik</a></li>
<li><a href="../319232/index.html">The reverse side of Agile</a></li>
<li><a href="../319238/index.html">FloatingActionMode - contextual action panel for Android</a></li>
<li><a href="../319240/index.html">iOS: Work with the gallery (Photos framework). Part 2</a></li>
<li><a href="../319242/index.html">Mobile OCR. How it all began (part 2)</a></li>
<li><a href="../319244/index.html">BLE under the microscope</a></li>
<li><a href="../319246/index.html">How can I save on taxes 13.3 times</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>