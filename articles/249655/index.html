<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple techniques of reverse engineering UEFI PEI-modules on a useful example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear readers of Habr. 

 After a long break with you again, I and we continue to delve into the guts of UEFI . This time I decided to show a fe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple techniques of reverse engineering UEFI PEI-modules on a useful example</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear readers of Habr. <br><br>  After a long break with you again, I and we continue to delve into the <abbr title="Unified Extensible Firmware Interface">guts of UEFI</abbr> .  This time I decided to show a few techniques that simplify the reverse and debugging of the executable components of UEFI using the example of the outdated but still-popular <abbr title="Pre-EFI Initialization">PEI</abbr> module SecureUpdating, which is designed to protect the firmware of some HP laptops from modification. <br><br>  The background is as follows: one evening a laptop repairman from Belarus wrote to me and asked me to see why the laptop with the replaced VideoBIOS does not want to start, although it starts exactly the same.  The answer was on the surface - the laptop that did not start after modification had a newer version of UEFI, in which kind people from HP integrated protection against modification of the <abbr title="Driver Execution Environment">DXE</abbr> -tom (and there we have the VideoBIOS we need along with 80% of the UEFI code), so that malicious viruses and less vicious users didn't accidentally break anything there.  Then the problem was solved by transferring the SecureUpdating PEI module from the old UEFI version to the new one, but after two weeks the same person turned again, this time the old version of the module refused to work on a similar laptop, and my help was needed again. <br>  If you are interested in my further adventures in the world of UEFI PEI-modules with disassembler and patched transitions - welcome under the cat. <br><a name="habracut"></a><br><h2>  A couple of links to educational program </h2>  If you almost understand nothing - do not worry, I have a few articles explaining the terminology: <a href="http://habrahabr.ru/post/185704/">1</a> , <a href="http://habrahabr.ru/post/185764/">2</a> , <a href="http://habrahabr.ru/post/185774/">3</a> , read and come back.  For fans of the original documentation, <a href="http://uefi.org/specifications">the</a> UEFI <abbr title="Platform Initialization">PI</abbr> <a href="http://uefi.org/specifications">specification is</a> always available; everything is written there in much more detail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Required files and tools </h2>  To disassemble the above firmware, we need: <br><ol><li>  Actually the file with the firmware, <a href="">I was sent this one</a> . </li><li>  Any utility for working with UEFI images, I will use <a href="https://github.com/LongSoft/UEFITool/releases/latest">UEFITool</a> as its author, but you can use any one you like, for example, <a href="https://github.com/theopolis/uefi-firmware-parser">uefi-firmware-parser</a> or <a href="http://forums.mydigitallife.info/threads/13194-Tool-to-Insert-Replace-SLIC-in-Phoenix-Insyde-Dell-EFI-BIOSes">PhoenixTool</a> is not important. </li><li>  Hex editor of your choice, I will use <a href="http://mh-nexus.de/en/hxd/">HxD</a> . </li><li>  Disassembler with support for PE32-files, here <a href="https://www.hex-rays.com/products/ida/support/download_demo.shtml">IDA 6.6 Demo</a> is ideal for us, because  In the overwhelming majority of cases, PEI modules are 32-bit and the limitations of the demo version do not interfere too much.  If a respected <a href="https://habr.com/users/xvilka/" class="user_link">xvilka</a> can show how to load structures from a C-file in <a href="https://github.com/radare/radare2">radare2</a> , I will try to do the next mod in it, but for now IDA is our everything. </li><li>  From the <a href="https://github.com/snare/ida-efiutils">efi-utils</a> suite, you need a hefty behemoth.h file containing the definitions of almost all possible data structures used in UEFI.  In our case, we need only a couple of three. </li></ol><br><h2>  A starting point </h2>  So, from the words of a fellow repairman, we know the following: any change in the DXE-volume leads to a dead laptop, blinking Caps-lock, and changes in other parts of the image do not lead to such an outcome.  This means that somewhere there is either a checksum or an EDS that is checked by the code of one of the PEI modules, and if it converges, control is transferred to the DXE phase, and if not, it is transferred somewhere to where we don‚Äôt happy to <br><br>  We need to figure out the following: <br><ol><li>  Where exactly is the COP / EDS stored? </li><li>  Who checks it? </li><li>  And, most importantly, how to make sure that the check always ends successfully? </li></ol><br><h2>  Go! </h2><br><h3>  Do it once! </h3>  Open the file with the firmware in UEFITool and look carefully: <br><img src="https://habrastorage.org/files/097/6ae/159/0976ae15908a45be8f06ec8b58ad90f1.png"><br>  It looks nothing unusual, except for the message that inside the free space of one of the UEFI volumes there was data, which according to the specification should not be there.  This is how manufacturers (of those who do not really believe in the specification) usually hide their checksums or digital signatures.  Double click on the message to select the volume in which these same data was found, and we get it entirely into the <i>dxe.vol</i> file for analysis.  UEFITool is not necessary to close - still useful. <br><br>  We open the received file with the Hex-editor and consider, starting from the end, because the free space in the volume can only be there: <br><img src="https://habrastorage.org/files/062/3c1/b8f/0623c1b8f6df43bab8c8ce6a5148b47e.png"><br>  There is also a very suspicious piece of data with a size of 100h (marked in red), followed by the signature <i>$ SIG</i> , firmware version <i>F.50</i> and platform code name <i>68CPK</i> .  Thus, the answer to the first question, presumably, is received. <br><br><h3>  Do two! </h3>  To answer the second, you need to look for PEI-modules that access this block of data.  This is quite difficult and often have to try several options.  The easiest thing is to look for other occurrences of the $ SIG signature, but in this case we are immediately unsuccessful - there are no other occurrences of such a string in the image.  But if the block is not searched by signature, then it is searched either by offset or by absolute address.  Its offset inside the volume is 12FEE0h.  Switch to UEFITool and search for Hex pattern E0FF12 without considering headers (Intel processors are still LittleEndian, so the order of bytes had to be changed): <br><img src="https://habrastorage.org/files/598/e7b/70c/598e7b70c61d4570b18c496a0e0ea2d0.png"><br><br>  Iiii ... BINGO, only 2 entries, and both - in the same PEI module with the promising name SecureUpdating.  We take it out without headers to the file <i>su.bin</i> for further analysis: <br><img src="https://habrastorage.org/files/b9a/f6d/356/b9af6d3560d240318cd25d80b95548e6.png"><br>  Thus, presumably, an answer was received to the second question. <br><br><h3>  Do three! </h3> It remains to deal with the third.  To do this, you need a disassembler, a little knowledge about the device PEI-modules and a lot of patience.  Run IDA, agree with the terms of the demo mode and open the file received earlier. <br>  Go to <i>Options -&gt; Compiler ...</i> and set them like this: <br><img src="https://habrastorage.org/files/293/365/e43/293365e43e3b48989970def2bbff205c.png"><br><br>  Then go to <i>File -&gt; Load File -&gt; Parse C header file ...</i> and load the behemoth.h file mentioned above in the list with the definitions of the UEFI structures: <br><img src="https://habrastorage.org/files/f2f/10b/06b/f2f10b06bed94bc095faacaeb04ce5a5.png"><br>  You should not pay attention to errors of analysis - they in this case will not harm. <br><br>  Now open the Structures tab, go to <i>Edit -&gt; Add structure type ...</i> (or press Insert, it's faster), click <i>Add standard structure</i> and in the list that appears we find the most important structure for PEI files - <a href="http://feishare.com/edk2doxygen/dd/daa/struct___e_f_i___p_e_i___s_e_r_v_i_c_e_s.html">EFI_PEI_SERVICES</a> , which we add: <br><img src="https://habrastorage.org/files/bff/8e1/02e/bff8e102e5494bb798a97328e77b73be.png"><br>  At the same time we add EFI_GUID and EFI_FFS_FILE_HEADER - they will be useful. <br><br>  The EFI_PEI_SERVICES structure (to be exact, a double pointer to its instance created by the PEI core) is passed as a parameter to the entry point of each PEI module and to almost all of its functions.  This is done because part of PEI is forced to be executed directly from flash memory, which is read-only at that moment, so global variables in such PEI modules are not available and you have to carry everything with you.  This is an unpleasant restriction for a programmer, but it helps a lot in researching and debugging PEI modules, since  double pointer dereferencing is not a very popular procedure in normal code, and therefore most of the calls to PEI services can be traced with the eyes directly in the listing.  We‚Äôll go back to it, but start to remember (or find out) what the entry point to the PEI module looks like.  Do not rush to google, it looks like this: <br><pre><code class="hljs pgsql">EFI_STATUS EFIAPI PeimEntry( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> EFI_FFS_FILE_HEADER *FfsFileHeader, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> EFI_PEI_SERVICES **PeiServices );</code> </pre> <br>  EFI_STATUS is a typedef for an unsigned int, EFIAPI is a typedef for stdcall, the first parameter points to the FFS file in which the PEI module is called (in case the module stores some data next to it and it needs access to it) ), and the second is the above double pointer to the table of PEI services.  Armed with this knowledge, we boldly change the type of the start function (by selecting it and pressing the <i>Y</i> key), it turns out something like this: <br><img src="https://habrastorage.org/files/b54/7af/629/b547af629f034546a9466392c7fafccb.png"><br><br>  Now the listing shows the following: first comes a series of function calls for which PeiServices is not needed.  Most often, they are engaged in input-output to / from IO-ports and other magic of this kind, we check this assumption, moving to the first in order: <br><img src="https://habrastorage.org/files/187/638/b7f/187638b7f9df43e28429296dc57d2007.png"><br><br>  Indeed, the function performs data output to port 24Eh.  I will omit the next few (they are very similar, we write-read IO-ports) and move on to those that PeiServices use. <br>  The first is trivial and simply saves PeiServices to a global variable (which indicates that our PEI module is already running from RAM, but the keen eye of a specialist would notice this from the information about the PE file in UEFITool): <br><img src="https://habrastorage.org/files/bca/a32/55b/bcaa3255b65f4620a38b2086b9b6d73d.png"><br><br>  The next one is much bigger and much more interesting, especially if you put the correct parameter and return value types to it: <br><img src="https://habrastorage.org/files/eeb/ae6/37d/eebae637dc4e47c2a04a5911310eadd5.png"><br><br>  The fragment highlighted in red immediately after the prologue and zeroing of local variables is the most noticeable pattern with dereferencing a double pointer, which I mentioned above.  To understand what kind of PEI service was called, we needed all these dances around the structures, now you can set the cursor to [eax + 28h], press <i>T</i> and select EFI_PEI_SERVICES.GetBootMode in the window that appears: <br><img src="https://habrastorage.org/files/23c/b91/669/23cb9166948a4879a081f23dafb2cc94.png"><br><br>  Looking at <a href="http://feishare.com/edk2doxygen/db/dc5/_pi_pei_cis_8h.html">its signature</a> , we can conclude that var_134 is actually a variable on the stack, in which the value of the current load mode will be written.  Then this value is compared with 11h and if it is not equal, the calculations go further, and if it is still equal, we put zero in eax and go to return.  11h in this case is <a href="http://feishare.com/edk2doxygen/d9/d44/_include_2_boot_mode_8h_source.html">BOOT_ON_S3_RESUME</a> , i.e.  if the system wakes up from ACPI Sleep Mode, then the function always returns 0 (and this is in the local dialect EFI_SUCCESS).  If the system is loaded from another state, then the execution goes further, and as a result it passes through such an interesting place: <br><img src="https://habrastorage.org/files/8ac/69f/a5a/8ac69fa5a6ba4cd9934f0234d28e6b6c.png"><br><br>  Bah, old acquaintances!  Those are the 12FEE0h entries by which we found this module.  First, the CopyMem and the suspicious QS / EDS are copied to the buffer, and then the original place is overwritten by the FFh byte, which is empty at the DXE volume and filled initially, and then the function call that checks the same KS / EDS follows. <br>  You can, of course, start to investigate it now, but this part of the code is not executed at all if the system wakes up from S3 (which is logical, since nothing from the DXE volume for S3 is needed, but you need to wake up as soon as possible), and everything it works less, so for a start we will make sure that this particular PEI module thinks we have eternal summer and always S3_RESUME, and skip any checks. <br>  To do this, it is enough to change cmp [ebp + BootMode], 11h to xor eax, eax, then the jnz following it will never be executed, but if it should never be executed, then it is easier to replace the transition with a couple of NOPs: <br><img src="https://habrastorage.org/files/81e/150/ec9/81e150ec97524e9bb9b0f9ae64215bb7.png"><br><br>  Change the selection in the Hex editor to 90 90 and everything is ready. <br><br><h2>  UPD </h2><br>  Suddenly, some new circumstances emerged.  It turns out that in this ‚Äúold‚Äù version of protection there is a copy of the PEI-volume, which can be used by the system to restore the original state of the PEI-volume, and in this copy you also need to replace the SecureUpdating module with the patched one.  The copy is stored in a file with a GUID 05B3AFFD-F7CC-4C0A-A19A-A9774E2675D7 of the RAW type, so the contents of this file are not displayed in current versions of UEFITool: <br><img src="https://habrastorage.org/files/85a/abe/222/85aabe222d154186b3ce088f4b45b760"><br>  In fact, it is a file of the Freeform type, and in order to get access to its content, you need to extract it through <i>Extract as is ...</i> , replace the extracted file with the byte at offset 12h (File type) from 01 to 02 and insert the resulting file instead of the original <i>Replace as is ...</i> : <br><img src="https://habrastorage.org/files/db9/895/93a/db989593ab7d4f989a75207aa3134f38"><br>  Inside this file is a compressed section with a copy of the PEI-volume, this is where another instance of SecureUpdating is located, which also needs a patch.  Now everything works exactly where it didn‚Äôt want to before. <br><br><h2>  Conclusion </h2><br>  Further - the matter of technology.  <i>Replace Body</i> through <i>‚Ä¶ Replace the</i> contents of the original PE32 section with the modified file, make the necessary changes to the DXE volume, save the changes and flash the resulting image on the programmer.  I did not have this laptop, made a modification and sent the results to the applicant.  A couple of hours later, the answer was received: ‚Äúthank you so much, everything is working, the client is satisfied,‚Äù and I went with a clear conscience to write the article you just read. <br>  Thank you for your attention and successful modifications to you. </div><p>Source: <a href="https://habr.com/ru/post/249655/">https://habr.com/ru/post/249655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249645/index.html">Kernel .Net (GC, JIT, interop, ...) in Open Source</a></li>
<li><a href="../249647/index.html">Making a queue of incoming calls with the callback function</a></li>
<li><a href="../249649/index.html">Configuring Kerio Control Firewall for 3CX Phone System</a></li>
<li><a href="../249651/index.html">1987 - Exhibition "Computer Science in the Life of the United States"</a></li>
<li><a href="../249653/index.html">Isomorphic BEM</a></li>
<li><a href="../249657/index.html">Let's reinvent the wheel</a></li>
<li><a href="../249659/index.html">Weekly build Vivaldi 1.0.94.2</a></li>
<li><a href="../249661/index.html">To recognize the pictures, you do not need to recognize the pictures.</a></li>
<li><a href="../249663/index.html">Attempt to reincarnation and stuffing in Open-Source Yandex.Following</a></li>
<li><a href="../249665/index.html">Mobile app security, or ‚ÄúWho will check the reviewers?‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>