<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why in 2017 to write your own engine for mobile games?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="These days there are a lot of game engines. Two-dimensional, three-dimensional, native and on scripts. At first glance, everything that has been done ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why in 2017 to write your own engine for mobile games?</h1><div class="post__text post__text-html js-mediator-article">  These days there are a lot of game engines.  Two-dimensional, three-dimensional, native and on scripts.  At first glance, everything that has been done has already been done and you can just make a game.  However, according to statistics, about half of the top 100 mobile games are made on their engines.  Why do many large studios do projects exclusively on their technology?  What does not suit them in those engines that now have?  To answer this question you need to understand why you need an engine, what they generally are and how they differ. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/eb5/0df/e54/eb50dfe5467e4ad6aeba89ede8f670a3.jpg"></div><a name="habracut"></a><br>  The game engine for the developer is a tool.  Like a hammer for a carpenter or a racing car for a pilot, the tool influences success.  Of course, not always.  It happens that on weak technologies they make masterpieces, and on high-end engines they make frankly failed projects.  But ‚Äúon average in the hospital‚Äù, the choice of instrument rather significantly influences success.  To understand how much, you need to understand why and how the games are made. <br><br><h1>  Big goal </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/web/40d/176/4b3/40d1764b3a72451ab5819f1869a71b20.jpg"></div><br>  So why do we make games?  Everyone has different goals, someone makes just for fun, someone to make a lot of money.  But still, in most cases they want to make money on the game.  Consider exactly how the engine affects the achievement of this goal.  For this, it is necessary to recall the elementary formula of how that very money is obtained, or, more correctly speaking, profit. <br><br>  <i>Profit = Income - Expense</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we will consider in detail each component and how the engine affects them.  And then we will define some metrics by which we will briefly evaluate the existing engines. <br><br><h1>  Costs </h1><br>  Any developers seek to reduce these costs.  For small developers, costs can be fatal, and the project won't even see the light.  Big developers are also interested in reducing costs, because you can make a project faster, check it out, go to the market before others, or just try a lot more ideas for the same money. <br><br>  We analyze the development costs in more detail.  They include a lot of things, such as marketing, payment for equipment, wages, and so on.  In different projects in different ways, but as a rule, wages are one of the largest items of the project budget.  How does the engine affect the cost of development?  Again a small formula: <br><br>  <i>Remuneration = (Cost of a specialist 1 + Cost of a specialist 2 + ...) * Development time</i> <br><br>  It looks easy.  Based on the formula, it is clear that there are actually two values ‚Äã‚Äãthat can be influenced: the cost of specialists and the development time.  We reduce the cost of a specialist, reduce development time - and our project has fallen in price!  But how to make a specialist cheaper?  How to make it work faster?  The answer is the right choice of technology and the right formulation of work. <br><br>  The right set of tools allows you to find the right specialist for a particular job.  Ideally, the artist draws, the programmer writes the code, the typesetter makes up, the animator animates, the technical designer adjusts the content, in general, everyone is busy with his own business.  However, in reality, it often happens that programmers are busy with everything - layout, animation, setting up resources.  And not even because there is no one to do it, but because only he can assemble the interface and zanify it through code.  Specific tools are still required for certain works. <br><br>  Hence the first metric of the engine - the <b>toolkit</b> .  Availability of tools allows you to hire the appropriate specialist who will be better and faster to cope with their work.  Naturally, completely different tools are needed for different games, but there are common ones that are necessary for everyone: resource tuners, animations, effects, graphics, physics, sound, and interfaces.  All this can be done by code, but, as practice shows, it is rather inefficient. <br><br>  In addition to general tools, almost every game has some specific features that require special tools, such as a level editor or a configuration editor for game objects.  Here you can highlight this metric as the engine's <b>flexibility</b> - it is an opportunity to tailor it to your specific needs with minimal cost. <br><br>  Next, the development time.  I propose to decompose it into two components: the time of the operation and the number of repetitions.  Consider the example of interfaces.  If you have a special interface editor, then the layout in it will be much faster than in a text file or in code.  Accordingly, the time for the layout operation will be less.  If there is an opportunity to work with templates, then the number of operations of the same type will be less.  Simply put, the simpler, more convenient and thoughtful the tool, the faster the development will take place.  And this is the next metric - the convenience of the toolkit or <b>usiability</b> , as it is often called.  Here many may notice that in many indie teams there are no specialized people and still the programmer does everything.  Which is more convenient to write code.  The topic is quite controversial, but I have seen a bunch of examples where the same programmers make content much better and faster in special editors than with the help of code. <br><br>  Naturally, even if you remove the maximum unnecessary tasks from the programmer, he still needs to write code.  From the experience of game development, I can say that 80% of all time is a boring routine that needs to be done quickly and without much concern for performance.  Dialogues, client-server interactions, scripts and stuff like that.  Here you can highlight another metric - the <b>complexity of the development of game logic</b> .  It describes how complex the development of most of the code will be, those same 80% of the routine.  Usually scripts are best suited for this.  And the remaining 20% ‚Äã‚Äãare precisely those bottlenecks that require flexible optimization and tuning.  What, in fact, also applies to the metric of <b>flexibility</b> . <br><br>  The price of a specialist is also influenced by the <b>input threshold</b> of engine complexity.  The easier it is to use it, the more specialists, the cheaper and easier to find them.  However, too low a threshold often means that the engine is limited. <br><br>  Also by the time of development can be attributed to such a metric as <b>portability</b> - the ability to apply the same solution on different platforms, instead of implementing on each separately.  If you make a game on several platforms at once, time costs are reduced in proportion to the number of platforms covered. <br><br><h1>  Income </h1><br>  Everything here is not as obvious as with expenses.  For a start, let's look at what is the income from the game.  And again the formula, very simplified, but to a greater extent reflects the result: <br><br>  <i>Revenue = Average User Revenue * Number of Users</i> <br><br>  Again, two quantities that can be influenced.  So, how does the engine affect the average revenue per user?  There is a rather indirect connection, and often there is none at all.  But we are considering the "hospital average", so we will not reject. <br><br>  There are many factors that make up this income: the involvement of the player, the interest of the game, the need to pay for the promotion, the ability to pay, the time spent in the game and so on.  There are a lot of factors, they are always different, at least to say something about the amount of income is very difficult and very few people know how to do it well. <br><br>  One of the factors affecting the success and profitability of the game is its quality.  Beautiful art, smooth animations, good effects, interesting gameplay - all this influences the player‚Äôs opinion, his desire to stay in the game.  And this is directly affected by the engine.  We have already considered that the <b>toolkit is</b> necessary for effective development, but it is also necessary for developing high-quality content.  Beautiful animations, interfaces, effects, scenes: all this is difficult to do without good tools.  A bad tool is like a bicycle with oval wheels, on which it is quite difficult to go somewhere.  However, quite often developers ride such bicycles: the programmer makes awkward animations on his favorite sines and cosines, the designer imposes a level in a text file, and so on.  All this does not lead to quality results.  Therefore, the toolbox is important. <br><br>  In addition to tools, quality is affected <b>by</b> engine <b>performance</b> .  Let the game have great content, beautiful art and great effects, but all this disappears when the game starts to slow down.  The player is not comfortable to play, the interface becomes non-responsive, animations do not produce the proper effect.  Performance also affects how rich the game will be.  With a non-optimal approach, we can show N sprites and X animations, and with an optimized engine we can show more.  It does not always produce the desired effect and sometimes unnecessarily, but it gives more freedom of action, more opportunities to realize your ideas. <br><br>  Performance also affects player retention.  On average, a new player installs the game and decides on its removal within 20-30 seconds.  Making it wait for the game to load at this time is not a good decision.  Also the size of the game affects the threshold of entry.  Few people want to download the game size of 200MB on the mobile Internet.  Energy costs in the game also affect.  Many players run the game on the phone on the way home, and if the battery level is low and your game spends it much, the player would rather stay connected than play your game.  Actually, the time that he chooses to spend in the game will decrease if he knows that the device battery will inevitably sit down.  The conclusion from this one - you need to try to save resources. <br><br>  Let's move on to the next part of the formula - audience reach.  Here the metrics are quite understandable.  This is <b>performance</b> and <b>portability</b> .  The more platforms, the more devices are covered, and accordingly users.  The better the performance, the weaker the devices support the game and more players can play your game.  You can hope that your players have a new Apple product in their pockets, but statistics show that there are few new devices, everyone goes with the outdated ‚Äúmiddling‚Äù.  Approximately the same situation on Android. <br><br><h1>  Preliminary result </h1><br>  Now we have a rough idea of ‚Äã‚Äãwhat metrics engines have and how they affect the success of the game: <br><br><ul><li>  Input threshold </li><li>  Tools </li><li>  Usability </li><li>  The complexity of the development of game logic </li><li>  Flexibility </li><li>  Portability </li><li>  Performance </li></ul><br>  Based on this list, we estimate the existing engines.  I propose to consider only the most significant, based on the statistics collected by Unity3D, with a few of my additions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/4d2/fcc/d464d2fcc9c7c7f2e42f98362f6470d3.jpg" alt="image"></div><br>  <i>The opinion below should not be considered as 100% true, it is compiled by me and may not fully reflect reality</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/b38/48d/145/b3848d1454e54eabb8a35ef721ac1bfe.png"></div><br>  Perhaps so far, few people have tasted this engine, but it is developing and getting better.  It has a good all-in-one editor in which you will find everything you need.  The game code is written in an internal scripting language similar to Python.  The developers claim that it is possible to optimize parts of the game in C ++, or to make additions for the editor. <br><br><ul><li>  <u>Input threshold</u> <br>  despite the simplicity of the engine, it is quite high.  Firstly, it has its own scripting engine.  Secondly there is little documentation and examples. </li><li>  <u>Tools</u> <br>  there is everything you need, as well as you can do your </li><li>  <u>Usability</u> <br>  there is also bad documentation and a small number of examples.  But in general, the toolkit leaves the impression of lack of thought and inconvenience. </li><li>  <u>The complexity of the development of game logic</u> <br>  scripts are similar to Python, which means it is easy to write them, but nevertheless, it‚Äôs your own language, so it‚Äôs unlikely that you can simply find a solution </li><li>  <u>Flexibility</u> <br>  game logic is written in scripts, the original native code is open.  In theory, you can do anything, but in practice, as far as I heard, they are difficult to combine </li><li>  <u>Portability</u> <br>  ported to all necessary platforms </li><li>  <u>Performance</u> <br>  considering the scripts, you should not expect high performance </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/1b5/015/2e4/1b50152e490e45ad98e79813d24cb28d.jpg"></div><br>  Internal corporate engine from King, which they decided to bring to the light.  Appeared in the public domain relatively recently, the community is developing rapidly.  Under the hood, he, according to the developers, everything is optimized as much as possible.  Game logic is written in LUA scripts.  There is an all-in-one editor, but rather limited in functionality. <br><br><ul><li>  <u>Input threshold</u> <br>  quite low due to LUA scripts and fast-developing community </li><li>  <u>Tools</u> <br>  there is a single editor, but a lot is missing, for example, animations, a full-fledged component system </li><li>  <u>Usability</u> <br>  This engine has grown as a corporate engine for King Studio, so it was not originally aimed at a wide audience.  Therefore, the tools are somewhat specific and limited. </li><li>  <u>The complexity of the development of game logic</u> <br>  LUA is one of the best scripting languages, is very common and easy to learn.  However, in my experience, it is difficult to write large projects on pure LUA scripts. </li><li>  <u>Flexibility</u> <br>  the engine is rather limited to the paradigms given by the creators.  One of them - the game logic is written in LUA.  Although there is an opportunity to include native code, the emphasis is precisely on the fact that the game is written in LUA, but this language does not allow making truly quick decisions.  Another paradigm is eternal full backward compatibility.  Certainly it is good that the project on the first version of the engine will work without problems on the latter.  However, in this way it is necessary to support old solutions, which slows down the introduction of new ones and, accordingly, slows down </li><li>  <u>Portability</u> <br>  Perfectly ported to all platforms.  And even on the Web </li><li>  <u>Performance</u> <br>  LUA is a very fast scripting language, but, nevertheless, remains a scripting language, which directly affects the performance of the game code.  However, the other components of the engine, according to the creators, are made as efficiently as possible. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/317/10b/0d5/31710b0d5f7e462faca7769952b91037.png"></div><br>  Professional game engine at the height of technology.  Excellent picture, performance, tool for real professionals.  However, it is difficult to use it in mobile development.  Yet it is more designed for three-dimensional AAA games.  Doing mobile 2D games on it is like a cannon on sparrows. <br><br><ul><li>  <u>Input threshold</u> <br>  very tall.  You need real experts in your business, both from the gaming content and from the programmers </li><li>  <u>Tools</u> <br>  the set of tools is truly impressive, from the particle editor to the animation of the characters </li><li>  <u>Usability</u> <br>  sure for professionals it is super optimal.  However, in the hands of non-professionals, the result is not very high quality and long </li><li>  <u>The complexity of the development of game logic</u> <br>  in Unreal, game logic is written either in C ++ or Blueprints.  In fact, you can't write the whole game on BluePrints, it‚Äôs really very voluminous and tangled, but I think you shouldn‚Äôt tell about C ++.  According to the developers, everything works like this: C ++ programmers write the core and ‚Äúblocks‚Äù for Blueprints, and the designers of these blocks make up game mechanics.  I'm sure this is a great approach for a 3D shooter, but it is unlikely to just put a bunch of logic, for example, on interfaces.  And sometimes most of the game is interfaces. </li><li>  <u>Flexibility</u> <br>  Architecture and C ++ provide endless possibilities in development, but again, the bias in three-dimensional projects.  2D games for creators have never been a priority </li><li>  <u>Portability</u> <br>  Unreal now runs on all mobile platforms, but there are many rumors about numerous problems, such as application size. </li><li>  <u>Performance</u> <br>  Some of the best engineers in the gaming industry have developed a native engine, all of which suggests that you can squeeze every last bit out of iron. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/524/6bb/09c/5246bb09cbda495195455b2f590e2b48.png"></div><br>  Completely free and open source engine.  There is an all-in-one editor, documentation and a bunch of examples.  Game logic is written in C ++, or in JavaScript.  A lot of projects on it are released, a distinctive feature of these projects is a good optimization.  However, upon closer examination, the editor is not as convenient as it seems at first glance, there are a lot of shortcomings in the source code and you have to finish a lot of things. <br><br><ul><li>  <u>Input threshold</u> <br>  quite high, because for high-quality development you need knowledge of C ++ and a fairly good understanding of how games are made </li><li>  <u>Tools</u> <br>  there is almost everything you need </li><li>  <u>Usability</u> <br>  very doubtful in my opinion.  Much copied from other technologies, but without much thought why and why.  In the end, it is very specific and a bit divorced from real tasks.  A bunch of console utilities are also not associated with convenience. </li><li>  <u>The complexity of the development of game logic</u> <br>  C ++ is mainly used, but it is also possible to use JavaScript.  However, using them together is somewhat difficult. </li><li>  <u>Flexibility</u> <br>  open source and C ++ allow you to do anything </li><li>  <u>Portability</u> <br>  all mobile platforms </li><li>  <u>Performance</u> <br>  because of its simplicity and flexibility it allows to achieve very good results </li></ul><br><h3>  Game maker / Construct and related </h3><br>  The engines of this kind were created so that anyone could make their own game, without any knowledge of the development.  Everything is as simple and straightforward as possible, these engines do great with this.  However, for large or even medium-sized projects, they are poorly suited. <br><br><ul><li>  <u>Input threshold</u> <br>  minimal </li><li>  <u>Tools</u> <br>  has everything you need to create small or simple games.  The most convenient way for them to do games in the style of pixel-art. </li><li>  <u>Usability</u> <br>  worth watching Game Maker 2 editor!  Perhaps the best solution for the engine in this category.  Very thoughtful and designed for the target audience </li><li>  <u>The complexity of the development of game logic</u> <br>  either an elementary script, or no scripts at all.  Instead of scripts, a reaction-action system is used in which all game interaction is described. </li><li>  <u>Flexibility</u> <br>  very limited functionality, but enough for simple games </li><li>  <u>Portability</u> <br>  all mobile platforms </li><li>  <u>Performance</u> <br>  naturally, the paradigm of developing such simple projects requires a lot of additional resources.  As a rule, developers leave such engines to lower levels precisely when faced with poor performance. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/a55/019/ec5/a55019ec5e4644648e0e47935f3ffe46.png"></div><br>  The most common in our days engine.  And this is the reason - it is very convenient.  Great editor, almost unlimited possibilities, 2D, 3D graphics, anything you want.  And of course, C #, with which development is pretty easy.  However, he also has skeletons in the closet.  Often productivity leaves much to be desired.  I agree, if you make an effort, you can do a lot, but the price is high.  In addition, sometimes incomprehensible plans for the development of developers engine.  The most necessary things remain at the bottom of the roadmap, but in new and new versions there appears something that sounds great on the selling page, but not everyone needs to be developed. <br><br><ul><li>  <u>Input threshold</u> <br>  very low.  You will make your first game in a couple of tutorials.  Huge community, lots of available solutions. </li><li>  <u>Tools</u> <br>  there is absolutely everything, some even too much on most projects.  And if you don‚Äôt need it in the engine, you‚Äôll probably find it in the store. </li><li>  <u>Usability</u> <br>  This is the biggest plus engine.  Excellent tools speed development at times.  However, with deeper use, flaws come up, for example: in some places there is no obvious logic of the UI, not very well-designed animations.  Some things people ask for a very long time, but the developers still can‚Äôt do it.  In general, for the development of mobile games - the best that can be found </li><li>  <u>The complexity of the development of game logic</u> <br>  C #, although somewhat specific in Unity, is a very convenient language.  Very often I hear from C ++ programmers the opinion that this is a "breath of fresh air."  From personal experience I want to note that developing in C # is several times faster than in C ++ </li><li>  <u>Flexibility</u> <br>  very flexible tools and architecture of the engine as a whole.  However, in many things it remains unavailable for change.  Closed code gives a black box effect that is often impossible to influence.  There is freedom for optimizations, but subtle optimizations cannot be done as a result of their secrecy. </li><li>  <u>Portability</u> <br>  ported to all that is possible, rumor is coming soon on vacuum cleaners can be run </li><li>  <u>Performance</u> <br>  In general, the engine is very well optimized, and with due diligence you can make a productive game on it.  However, C # is pretty tight.  Sometimes you think about C # code much more about its performance than you do C ++.  And as a rule in the game there is a place where the performance sags.  In such cases, a lot of resources are spent on optimization.  Similarly, performance problems associated with UI almost always occur.  Difficult dialogues, long lists without optimizations load the system quite heavily. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/web/796/27f/eb8/79627feb8dfe46efa426bdf6e727f995.png"></div><br><h3>  Own engines, C ++ </h3><br>  The choice of either large studios or madmen.  For this, we need cool specialists, but they are few and costly.  And as a result, Frankinstein from technology is obtained, which is constantly falling apart.  It turns out a very wrong development, most often it is those expensive programmers who do everything.  But it turns out the most ideal product.  All that the designers want is implemented, works as smoothly as possible and runs on ancient devices.  But the price for such technology is high. <br><br><ul><li>  <u>Input threshold</u> <br>  very high, no documentation, the only way to find out how everything works through colleagues </li><li>  <u>Tools</u> <br>  as a rule, there are either no tools in such engines, or there are elementary editors that satisfy some specific needs.  It is on these engines, as a rule, programmers do everything.  After all, an ordinary designer is extremely difficult to understand all these technical jungle. </li><li>  <u>Usability</u> <br>  even if there are tools, they work outright badly.  It is understandable, because such engines are written to make the game, and the game needs to be done quickly, hence the poor quality of the tools, a lot of bugs, console utilities and all of this.  But even if there are some tools, they are written by programmers without taking into account that they will not be used by programmers, as a result, the effect editor turns into a space shuttle launch panel, and not into a beautiful interface with three buttons. </li><li>  <u>The complexity of the development of game logic</u> <br>  starting with such engines is very difficult, because first you need to understand his device, all his hacks and rakes.  But then it plays only on hand.  As a rule, these engines are made with a bias for the game, on which they are made, so over time it is easier and easier to write code.  Especially if any scripting language is bolted. </li><li>  <u>Flexibility</u> <br>  actually the most important advantage of such engines.  The developer is limited only by himself, he can do anything. </li><li>  <u>Portability</u> <br>  As a rule, such engines are ported only to those platforms on which the game is released.  It is understandable, why waste time on supporting the platform, if you do not plan to release the game on it.  However, with experience, I have noticed that in such engines operations with platforms are very slow, assemblies are very complex and long </li><li>  <u>Performance</u> <br>  obviously, those who are able to write their own engine are pretty well versed in their subject.  However, there are no restrictions.  Accordingly, you can do anything for the sake of performance and achieve the perfect result. </li></ul><br><h2>  So still, why do we need another one? </h2><br>  According to a brief description of those above, it becomes clear that there is no solution that will satisfy all needs.  Each of them has some disadvantages, be it convenience or performance.  Let's try to imagine the very ideal that will satisfy all our needs, it will turn out to be the very ‚Äúsilver bullet‚Äù. <br><br>  Obviously, he must combine qualities that are very difficult to combine.  It should be simple, but at the same time flexible.  This can be solved by building a system where top-level components are based on low-level ones.  For example, there is some very flexible low-level framework, and on top of it are some top-level things like an editor and scripts.  That is, the upper level provides convenience and is designed for most tasks, and you can resort to the lower one in search of more efficient solutions. <br><br>  Moreover, the low level should be really low, and not just provide a good API.  Here everything should be as transparent as possible for the developer.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If there is even a small black box effect, the developer will not be able to absolutely control the system, and accordingly achieve the maximum result. The only way to this, in my opinion, is open source.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The top level should be well thought out enough to perform its function well. Many developers of In-house engines here make the same mistake; they put different technologies together and build connections between them. However, as practice shows, this leads to the fact that they interact poorly. A more specific example: importing animations from a third-party editor and particle effects from another. As soon as it becomes necessary to use the effect in animation, problems begin. Particles are not played in the animation editor and vice versa. Accordingly, the final result is achieved by the designer rather hard. Therefore, everything should be in one system so that the designer can animate, superimpose sound, effects, and all at once, in one place.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, the ideal can be described in colors for a long time, so let's return to the specifics and analyze in order according to our metrics: </font></font><br><br><ul><li> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entry threshold</font></font></u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as low as possible. </font><font style="vertical-align: inherit;">The system, where the ‚Äúupper‚Äù level is kept on the ‚Äúlower‚Äù level, makes it possible to completely lower the input threshold, while not limiting in flexibility</font></font></li><li>  <u>Tools</u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there must be everything you need: work with resources, graphics, animations, interfaces, effects, physics, competent layout of the scene. </font><font style="vertical-align: inherit;">Ideally, all this should be in the same system so that each of the components ideally fits together.</font></font></li><li> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usability of</font></font></u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> each tool should be thought out from the side of real use. </font><font style="vertical-align: inherit;">It is not enough just to make a particle editor, interface or animation. </font><font style="vertical-align: inherit;">All this should be clear and convenient to those who specialize in this.</font></font></li><li> <u>   </u> <br>    ,      . ,        ,   20%  .  80%    ,    ,       .        </li><li> <u></u> <br>       .      ‚Äî   API     </li><li> <u></u> <br>         ,           .         web-.   WebAssembly                   </li><li>  <u>Performance</u> <br>        ‚Äî , ,    .         -    .         ,        </li></ul><br><h2>  Total </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the end, there may still be a better engine nowadays. </font><font style="vertical-align: inherit;">But this is only one opinion, me. </font><font style="vertical-align: inherit;">Although the experience of developing on different engines gives me an idea of ‚Äã‚Äãthe tool that I would consider ideal, I would like to know the opinion of others on this matter. </font><font style="vertical-align: inherit;">I think it will be interesting to many if someone else in the comments writes his opinion on some kind of engine. </font><font style="vertical-align: inherit;">It may even be useful to those who still choose the engine on which they want to make the game.</font></font></div><p>Source: <a href="https://habr.com/ru/post/338214/">https://habr.com/ru/post/338214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338202/index.html">Playing with a quantum coin</a></li>
<li><a href="../338204/index.html">New test: Crucial BX300 SSD</a></li>
<li><a href="../338206/index.html">Overview of foreign and Russian domain name registrars. Comparing marketing tricks with us and with them</a></li>
<li><a href="../338208/index.html">RailsClub 2017. Interview with Nikita Shilnikov, Dry-rb and Rom-rb core developer</a></li>
<li><a href="../338212/index.html">The first supercomputer DGX-1 based on Tesla V100 will be used in medicine</a></li>
<li><a href="../338216/index.html">AStA: we collect APK on the device itself</a></li>
<li><a href="../338218/index.html">Broadcast of the conference ‚ÄúHPE Genesis: Future Computing Infrastructure‚Äù</a></li>
<li><a href="../338220/index.html">The philosophy of static code analysis: three simple steps</a></li>
<li><a href="../338222/index.html">How to translate cryptocurrency into another blockchain: a little about sidechains</a></li>
<li><a href="../338226/index.html">Optimize web servers for increased bandwidth and reduced latency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>