<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Everything you wanted to know about stack traces and hip dumps. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everything you wanted to know about stack traces and hip dumps. Part 1 
 Here is the second part of the decryption of the report by Andrey Pangin aka ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Everything you wanted to know about stack traces and hip dumps. Part 2</h1><div class="post__text post__text-html js-mediator-article"><hr>  <a href="https://habrahabr.ru/company/jugru/blog/324932/">Everything you wanted to know about stack traces and hip dumps.</a>  <a href="https://habrahabr.ru/company/jugru/blog/324932/">Part 1</a> <br><hr>  Here is the second part of the decryption of the report by Andrey Pangin aka <a href="https://habrahabr.ru/users/apangin/" class="user_link">apangin</a> from Odnoklassniki from one of the JUGs (a doped and extended version of his report from JPoint 2016).  This time we‚Äôll finish the talk about stack-traces, and also talk about thread dumps and hip dumps. <br><br>  So, we continue ... <br><br> <a href="https://habrahabr.ru/company/jugru/blog/325064/"><img src="https://habrastorage.org/files/775/1fd/490/7751fd49013b4479be5eb4a9a4a78431.jpg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  Since we are talking about recursion, what will happen if I launch such a recursive method that never returns anywhere: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ depth++; recursion(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ recursion(); }</code> </pre> <br>  How many calls pass before StackOverflowError appears (with standard stack size)? <br>  Let's measure: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo4; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recursion</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depth;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       depth++;       recursion();   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {           recursion();       } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (StackOverflowError e) {           System.out.println(depth);       }   } }</code> </pre> <br>  Same code, just added catch StackOverflowError. <br>  On a 64-bit system with a 1 MB stack size, the result varies from 22 to 35 thousand calls.  Why such a big difference?  The point is JIT: methods are compiled in the compiler's background thread in parallel with the execution of java-code.  At some point (after the recursion method has already been called several times) the compilation of this method is started, and at that time execution continues in the interpreter.  As soon as the compiler finishes its work, the next call will go to the compiled code. <br><br>  Starting from Java 8, we have 2 compilers in one VM by default - ‚Äúlight‚Äù C1 and ‚Äúheavy‚Äù C2, i.e.  it is possible that we will have three types of frames on the stack: interpreted, compiled C1 and compiled C2.  Frame size can vary greatly.  The interpreter has the most cumbersome frames, because everything is stored on the stack (all arguments, local variables, current bytecode pointer, etc.).  In the compiled code, much of this is not needed, and the more optimal the compiler is, the less it should be stored on the stack.  C2, for example, generally will not make room on the stack for local variables - everything pushes through the registers, but also zainlineit one level. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af5/0a9/c73/af50a9c734274bb9156f24f2dfcb3f68.png"><br><br>  If the same code is executed in a purely interpreted mode with a key <br><br> <code>-Xint <br></code> <br>  The result is almost always 12,500 (¬± several frames). <br>  Now the same thing, but after the C1 compiler. <br><br> <code>-Xcomp -XX:TieredStopAtLevel=1 <br></code> <br>  In the case of the C1 compiler, the results are also quite stable - about 25 thousand. <br>  If you compile everything in C2 right away: <br><br> <code>-Xcomp -XX:-TieredCompilation <br></code> <br>  All this will work longer, but the result is 62 thousand frames. <br>  If you divide the standard stack size (1 MB) by 62 thousand, it turns out that about 16 bytes go to 1 frame.  I checked by compiled code - it is.  The frame size is actually not 16 bytes, but 32, but in 1 frame there are 2 levels of nesting at once. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c8/5f9/72d/2c85f972d888468052723f0ad1480391.png"><br><br>  By default, on a 64-bit architecture, the stack size is 1 MB, but it can be adjusted.  These 2 keys are synonymous. <br><br> <code>-Xss, -XX:ThreadStackSize <br></code> <br>  A less well-known fact is that you can change the stack size of one particular thread: <br><br> <code>Thread(ThreadGroup, target, name, stackSize) <br></code> <br>  But when creating large stacks, we must not forget that they take up space in the memory, and it may happen that many threads with a large stack size will result in out of memory: <br><br> <code>java.lang.OutOfMemoryError: Unable to create new native thread <br></code> <br>  Interesting fact: if you look at the jvm <code>-XX:+PrintFlagsFinal</code> key <code>-XX:+PrintFlagsFinal</code> on Linux, it will really show that it has a ThreadStackSize of 1 MB, and if you look at Windows, the default value of the key of the ThreadStackSize is 0. Where does 1 MB come from? <br>  For myself, it was a revelation that the default stack size is set in the exe-shnik (the default size for the application is specified in the exe-format attributes). <br><br>  The minimum stack size on a 64-bit system is approximately 228 KB (it may vary from version to version JDK).  How does the stack work and where does this minimum size come from? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/665/54c/a9f66554c188061f5e114349948a7b9e.png"><br><br>  On the stack, besides the frames of your Java methods, there is still some reserved space.  This is at least always 1 red zone (1 page size - 4 KB) at the very top of the stack and several pages of the yellow zone. <br><br>  Red and yellow zones are needed to check the stack overflow.  At the beginning, both zones are write protected.  Each Java method, through an attempt to write to the address of the current point-stack, checks whether the red or yellow zone is reached (when attempting to write, the operating system generates an exception that the virtual machine intercepts and processes).  When the yellow zone is reached, it is unlocked to allow enough space to start the stack overflow handler, and control is passed to a special method that creates a StackOverflowError instance and passes it on.  When it enters the red zone, an unrecoverable error occurs and the virtual machine is fatally terminated. <br><br>  There is also a so-called shadow zone.  It has a rather strange size: on Windows - 6 pages, on Linux, Solaris and other OS - 20 pages.  This space is reserved for native methods inside the JDK and the needs of the virtual machine itself. <br><br>  When I was preparing the presentation, I ran my recursive testik both in Java 8 and in Java 9. At the last, I got such a wonderful virtual machine crash (output fragment): <br><br> <code># <br> # A fatal error has been detected by the Java Runtime Environment: <br> # <br> #  EXCEPTION_STACK_OVERFLOW (0xc00000fd) at pc=0x0000019507acb5e0, pid=9048, tid=10544 <br> # <br> # JRE version: Java(TM) SE Runtime Environment (9.0+119) (build 9-ea+119) <br> # Java VM: Java HotSpot(TM) 64-Bit Server VM (9-ea+119, mixed mode, tiered, compressed oops, g1 gc, windows-amd64) <br> # Problematic frame: <br> # J 155 C2 demo4.Recursion.recursion()V (12 bytes) @ 0x0000019507acb5e0 [0x0000019507acb5e0+0x0000000000000000] <br> # <br> # No core dump will be written. Minidumps are not enabled by default on client versions of Windows <br> # <br> # If you would like to submit a bug report, please visit: <br> #   http://bugreport.java.com/bugreport/crash.jsp <br> # <br> ... <br></code> <br>  Naturally, I downloaded the latest available build (at the time of the report it was 9.0 + 119), this problem is also reproduced on it. <br>  This is a very good case for crash dump analysis (Andrey Pangin - <a href="https://jug.ru/2014/04/%25D0%25B0%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B5%25D0%25B9-%25D0%25BF%25D0%25B0%25D0%25BD%25D1%258C%25D0%25B3%25D0%25B8%25D0%25BD-%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7-%25D0%25B0%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B9%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B4%25D0%25B0%25D0%25BC/">JVM</a> crash dump <a href="https://jug.ru/2014/04/%25D0%25B0%25D0%25BD%25D0%25B4%25D1%2580%25D0%25B5%25D0%25B9-%25D0%25BF%25D0%25B0%25D0%25BD%25D1%258C%25D0%25B3%25D0%25B8%25D0%25BD-%25D0%25B0%25D0%25BD%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7-%25D0%25B0%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B9%25D0%25BD%25D1%258B%25D1%2585-%25D0%25B4%25D0%25B0%25D0%25BC/">analysis</a> ).  Here all the skills were useful, in particular, disassembly. <br>  Here is a statement that writes the value relative to the current point stack.  Crash occurred just on this instruction: <br><br> <code>Instructions: <br> 00000000: 89 84 24 00 a0 ff ff             mov    DWORD PTR [rsp-0x6000],eax <br> 00000007: 55                               push   rbp <br> 00000008: 48 83 ec 10                      sub    rsp,0x10 <br> 0000000c: 49 ba 78 71 88 8d 00 00 00 00    movabs r10,0x8d887178 <br> 00000016: 41 83 42 70 02                   add    DWORD PTR [r10+0x70],0x2 <br> 0000001b: e8 e0 ff ff ff                   call   0x00000000 <br> <br> Registers: <br> RSP=0x0000007632e00ff8 <br> <br> Java Threads: <br> =&gt;0x0000019571d71800 JavaThread "main" [_thread_in_Java, id=10544, <br> <br> stack(0x0000007632e00000,0x0000007632f00000)] <br> 0x0000007632e00ff8 <br></code> <br>  Using the value of the RSP register, you can calculate the address to which we write.  It is necessary to subtract 6000 in HEX from this address, you get some such value: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcb/f77/ae8/bcbf77ae8fc14dc1a5454b824302845b.png"><br><br>  We write by this value.  In the same place in the crash dump, the stack ranges of the current thread are specified: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a5/868/886/7a5868886fcb6318894621fb1c008166.png"><br><br>  We see that this value falls at the end of the very first (highest) page of this stack, i.e.  just in the red zone. <br><br>  Indeed, there is such a bug.  I analyzed it and found the reason: for some JVM functions, there are not enough 6 shadow pages available on Windows (they take up more when executed).  The developers of the virtual machine have been cheated. <br>  By the way, the size of these zones can be changed with JVM keys. <br><br>  Why do we need big stacks at all?  For Java EE, not otherwise. <br>  Here is one of my favorite pictures on this topic. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/19f/db3/eb319fdb3cf445f585d912d37b9ff6fd.png"><br><br>  On 2 lines of business logic hundreds of frames from various frameworks and application-servers are generated. <br><br><h4>  Stack traces for measuring performance </h4><br>  Profiling is an integral part of measuring the performance of your system.  All profilators can be divided into 2 large groups: sampling and instrumentation. <br>  The instrumentation profiler simply marks the methods: it adds some kind of signaling about entering the method to the beginning, and finally - signaling about leaving it.  It is clear that if we instruct each method in such a way, all this will create a large overhead, although the measurement will be fairly accurate. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ Profiler.onMethodEnter(<span class="hljs-string"><span class="hljs-string">"myClass.someMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// method body Profiler.onMethodExit("myClass.someMethod"); }</span></span></code> </pre> <br>  In production, a different approach is most often used - sampling profiler.  He periodically (10-100 times per second) removes a dump of streams and looks at which threads with which traces are currently running.  The methods that most often fall into these stack traces are hot. <br><br>  Let's take a look at an example of how this works.  I wrote a small program.  Despite the fact that it is small, you can‚Äôt tell it at once that it can slow down. <br>  First, it generates 2 random geographic coordinates.  Then, in a cycle, it calculates the distance from a randomly generated coordinate to another given point (Moscow) - i.e.  There is a distanceTo function in which there is a lot of math. <br>  The results are added to the hash map. <br><br>  All this in a cycle runs many, many times: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo5; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.IdentityHashMap; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ThreadLocalRandom; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Location</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> R = <span class="hljs-number"><span class="hljs-number">6371009</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lat;   <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lng;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lng)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lat = lat;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lng = lng;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Location </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lat = ThreadLocalRandom.current().nextDouble() * <span class="hljs-number"><span class="hljs-number">30</span></span> + <span class="hljs-number"><span class="hljs-number">40</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lng = ThreadLocalRandom.current().nextDouble() * <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">35</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(lat, lng);   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toRadians</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * Math.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distanceTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Location other)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dlat = toRadians(other.lat - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lat);       <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dlng = toRadians(other.lng - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lng);       <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mlat = toRadians((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lat + other.lat) / <span class="hljs-number"><span class="hljs-number">2</span></span>);       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> R * Math.sqrt(Math.pow(dlat, <span class="hljs-number"><span class="hljs-number">2</span></span>) + Math.pow(Math.cos(mlat) * dlng, <span class="hljs-number"><span class="hljs-number">2</span></span>));   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Map&lt;Location, Double&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcDistances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Location target)</span></span></span><span class="hljs-function"> </span></span>{       Map&lt;Location, Double&gt; distances = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdentityHashMap&lt;&gt;();       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) {           Location location = Location.random();           distances.put(location, location.distanceTo(target));       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distances;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{       Location moscow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(<span class="hljs-number"><span class="hljs-number">55.755773</span></span>, <span class="hljs-number"><span class="hljs-number">37.617761</span></span>);       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10000000</span></span>; i++) {           calcDistances(moscow);       }   } }</code> </pre> <br>  Here everything can slow down: the generation of a random coordinate, and the measurement of distance (there is a lot of math here), and unfolding on a map.  Let's run the profiler and see what exactly the time is spent on. <br><br>  I'll take Java VisualVM (included in the standard JDK package - there is nothing easier), I find our process on the Sampler tab, click the CPU - we start the measurements (let's give half a minute to work).  The default measurement interval is once every 100 ms. <br><br>  What happened: <br><br><img src="https://habrastorage.org/files/f0c/81d/26e/f0c81d26e4b14e7abb04ea5a172ba0ad.png"><br><br>  Slightly less than completely (according to the VisualVM Java Profiler) we spend time on IdentiryHashMap.put. <br><br>  If you look at the flat table by methods, sorted by SelfTime: <br><br><img src="https://habrastorage.org/files/f0c/81d/26e/f0c81d26e4b14e7abb04ea5a172ba0ad.png"><br><br>  As if nothing else is being done. <br>  The same can be measured with other profilers (JProfiler, YourKit, etc.), I assure you, the result will be the same. <br><br>  Is HashMap so brake?  Not.  Just profilers are lying. <br>  They are arranged in the same way: with a given periodicity, they call the JMX or JVMTI method, which receives a dump of all the threads.  For example, in JVMTI there is a method <a href="http://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html">GetAllStackTraces</a> .  What the virtual machine says, they summarize and print here. <br><br>  Hand on heart, these are not profilers lying, but JVM - it gives the wrong stack-traces.  All profilers have one big problem: thread stack traces can only be removed at safepoint moments, and these are certain points in the code that the virtual machine knows that the thread can be safely stopped.  And there are actually a few such points: they are inside the cycles and at the exit points of the methods.  If you have a large canvas of code - the same mathematics;  without cycles - there may not be a safepoint at all, which means that this canvas will never get into stack-traces. <br><br>  Another problem is that the threads that are sleeping, and the threads that are working, are sampled the same way, because  we take a dump from all threads.  This is not very good, because  sleeping streams are not interesting for us to see in stack traces. <br><br>  Also, most profilers cannot distinguish native methods that sleep on some kind of blocking system call.  For example, when waiting for data from a socket, the thread will be in the RUNNABLE state and the profiler will indicate that the stream is eating 100% CPU.  And he does not eat CPU, just the virtual machine can not distinguish the working native method from the blocking system call. <br><br>  What to do? <br><br>  The OS provides features for profiling native code.  If we talk about Linux, there is a <a href="http://man7.org/linux/man-pages/man2/setitimer.2.html">setittimer</a> system call, which sets a timer and generates a special OS signal (SIGPROF) for profiling with a given periodicity.  Receive it will be the thread that is currently being executed.  It would be good for us to be able to use the capabilities of the OS and in the SIGPROF signal processor to collect stack traces of the current thread, even if it is not in a safepoint.  And in the HotSpot virtual machine such an opportunity is provided.  There is an undocumented private API: AsyncGetCallTrace, which can be called to get the current stack of threads not in safepoint. <br>  This hole was propylene specifically for Oracle Developer Studio.  This is almost the only proflator who receives an honest stack trace. <br>  While I was preparing this report, I looked, and is there anyone else who uses these methods.  I found literally 2 projects: one is old and already abandoned, and the other appeared relatively recently (in 2015) and is called honest-profiler. <br><br>  The API here is pretty simple: prepare the place where we will stack the stack, and call the method: <br><br><img src="https://habrastorage.org/files/118/4ca/9d4/1184ca9d4f894d3d8aed669962f41097.png"><br><br>  The third parameter of this method is the current context, which comes to us in the signal handler. <br><br>  Link to my own open source profiler: <a href="https://github.com/apangin/async-profiler">https://github.com/apangin/async-profiler</a> .  Take - use.  Now he is already in a state where he is not ashamed to show people.  True, it is now implemented only for Linux (Note: support for macOS has been added since the report). <br><br>  Let's check on the same example. <br>  We say which process we are profiling. <br><br><img src="https://habrastorage.org/files/f3d/42c/62d/f3d42c62d23444baac269d964d3ed9c6.png"><br><br>  Our pid is 3202. <br>  The peculiarity of my profiler (which I have never seen before) is that it can connect on the fly (the honest-profiler mentioned must be started as a Java agent when the application starts). <br><br>  Let's give a few seconds to the profiling.  This is what we get as a result: <br><br><img src="https://habrastorage.org/files/6cc/c94/03b/6ccc9403ba7d44f99946a17100a70c75.png"><br><br>  At the end is a flat list of methods;  a little higher - separate details (all stacks of threads).  The picture is completely different.  Almost a third of all time is spent on math - calculating the distance.  IdentityHashMap.put - generally below with the result of 2% (according to the first profiler it occupied 100%).  But it really takes time to calculate the identityHashCode of the object.  And a lot of time is spent on put and resize itself.  By the way, random location generation is also not free (at least 12%). <br>  Feel the difference. <br><br>  The overhead of this profiler is much less.  It can be run at least 1000 times per second, and this will be normal, since it removes the stack-trace of only the active thread.  And it puts the results into a very compact structure - it does not generate all these method names, classes.  This is all calculated only when printing.  And during the profiling, only jmethodIDs are added (in fact, method pointers). <br><br><h3>  Thread dumps </h3><br>  There are many ways to do stream dumps: from Java code or from native, from within the process itself or from the outside. <br>  If we talk about the analysis of the process from the inside, that is, the Java API getAllStackTraces, which gives us the StackTraceElement array with all the consequences. <br><br><img src="https://habrastorage.org/files/926/c12/1ea/926c121ea8f84db6a1f98be58e6592c7.png"><br><br>  When we tried to use it in production, for a case with 2 thousand threads, each of which has a stack depth of 50-60 frames, this array alone occupied about 50 MB. <br>  There is a similar method for JMX (it is useful because you can pull it remotely).  It provides the same StackTraceElement array, as well as information about captured monitors. <br><br>  If we talk about generating stack-traces from the application itself, the JVMTI (Tool Interface) method is much better - a native interface for developing tools, profilers, analyzers, etc. <br><br><img src="https://habrastorage.org/files/761/67a/c8d/76167ac8d8fd4642ba41bcfd1f536e83.png"><br><br>  There is a method GetAllStackTraces, which is usually used just profilers.  Compared to the Java API, it has a very compact view. <br><br>  When dumping outside, the easiest way is to send the SIGQUIT process (either kill -3 or the appropriate combination to the console): <br><br><img src="https://habrastorage.org/files/930/e4b/8b3/930e4b8b3ea94c87812a9e21c5d3e8dd.png"><br><br>  The advantage of the method is that the stack traces will be printed by the Java machine itself.  This is done with maximum speed.  It still happens during a safepoint, but we do not need to create any intermediate structures. <br>  The alternative path is the jstack utility.  It works through the dynamic attach mechanism (I‚Äôll dwell on it). <br><br>  It is important to understand that the jstack and jmap utilities have 2 modes of operation.  They differ in only one key -F, but in fact they are 2 different utilities that serve the same thing, but work in two completely different ways. <br>  Let me explain what is the difference between them. <br>  Dynamic attach is a utility communication mechanism with a JVM through a special interface.  How does this happen (using Linux as an example)? <br><br><img src="https://habrastorage.org/files/159/cd1/502/159cd1502c2b416bb3e709e9204bb09b.png"><br><br>  The jstack utility creates a certain file in the current directory - a signal that the utility wants to connect to the JVM, and sends a SIGQUIT signal to the virtual machine.  The virtual machine processes this signal, sees the .attach_pid signal file in the current directory and, in response, starts a special stream, AttachListener (if it is already running, it does nothing).  And in this thread, a UNIX domain socket is opened for communication between the jstack utility and the JVM.  When the utility connects to this socket, the JVM checks the user's rights on that side so that foreign users cannot connect to the virtual machine and get some private information.  But checking there is very simple - only the exact correspondence of the effective UID and GID is checked (as a result, there is such a popular problem that when running jstack from under another user, even root, you cannot get a dump exactly because of this check). <br><br>  After the connection on the UNIX socket is established, the utility sends the command, and the virtual machine itself executes this command, and sends the response back to the utility on the same socket. <br><br>  In Window, everything is somewhat different (I don‚Äôt know why it couldn‚Äôt have been done the same; in Windows there is no UNIX socket, but there are named pipes) - there is another nice API that I like, so I could not fail to mention it here. <br><br>  The beginning is about the same - the named pipe is created.  Further, the Windows API has a function WriteProcessMemory, which can write some data directly into the memory of another process, if it has rights to it.  Through this function, a temporary auxiliary memory page is created in the address space of the java-process, the command to be executed is written there, the arguments and the name of the pipe where the response will go.  Another not less wonderful function that allows you to embed a thread in an alien process is CreateRemoteThread.  The jstack utility starts a remote thread ‚Äî it is already running in the context of the virtual machine process.  And as an argument to this thread, a pointer is passed to the previously created memory area, where all the information about the command is available. <br><br>  Then everything is the same: the JVM itself executes the command and sends the result back. <br><br><img src="https://habrastorage.org/files/908/7eb/89b/9087eb89b8114c6d922f7c76be051739.png"><br><br>  Advantages of this approach: <br><br><ul><li>  all operations are performed directly by the virtual machine in the most efficient way; <br><br></li><li>  Since the interface is independent of the VM version, you can take dumps from different processes with one jstack utility, regardless of which Java version these VMs are running. <br></li></ul><br>  The disadvantages include: <br><br><ul><li>  the already mentioned restriction on user inconsistency; <br><br></li><li>  this can only be executed on a live virtual machine, since commands are executed by the virtual machine itself; <br><br></li><li>  This mechanism can be disabled (for example, for security reasons) with a special JVM option. <br><br>  <code>-XX:+DisableAttachMechanism</code> . <br></li></ul><br>  As a ‚Äúproof of concept‚Äù, I decided to write a simple C utility, which in this way connects to a remote Java process and executes the command passed there on the command line ( <a href="https://github.com/apangin/jattach">https://github.com/apangin/jattach</a> ). <br><br>  The virtual machine supports the following commands: <br><br><img src="https://habrastorage.org/files/092/3d0/77d/0923d077d19a4028855e9780febae595.png"><br><br>   ,  ,   ,      ,  ,     jcmd,  load ‚Äî ,   ,     JVMTI-    .    load    async  (     JVM). <br><br>  ,   .  - , , tomcat. <br> pid  ‚Äî 8856. <br><br><img src="https://habrastorage.org/files/ad4/d9f/9c3/ad4d9f9c3a6947e1b449f40707ff4b9e.png"><br><br>       .    java-,  ,        Java.    ‚Äî  100   Windows   Linux.   GitHub. <br><br>        jstack,    jmap, jinfo  jcmd (    jattach     ). <br><br>   ‚Äî  jstack -F.   ,      JVM    ‚Äî    . <br><br>  Linux    PTRACE_ATTACH ( Windows  )   ,   ,   .    API,       ,  jstack  ,  ,   JVM .      JVM    ,   . <br><br>   PTRACE_PEEKDATA  1        1  ,     ,      (,  ,  ). <br><br><img src="https://habrastorage.org/files/81f/705/f31/81f705f3126846f2ad13d14743e48057.png"><br><br>    , : <br><br><ul><li>        ‚Äî   jstack -F       VM; <br><br></li><li>  root     ,   . <br></li></ul><br>   : <br><br><ul><li>   ,        ; <br><br></li><li>   jstack    ,   ,   ,    jstack       JVM,    . <br></li></ul><br><img src="https://habrastorage.org/files/43a/d31/7c3/43ad317c30f5471980b25f45427ae0f0.png"><br><br>  What is it for? ,  ,     -         .      (,  thread pool),   ,      ,       ,    . <br><br>        Java API    ,        .        Dynamic Attach ‚Äî    Java API,        jstack.   pid   ,      Dynamic Attach        . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> AttachNonSupportedException, IOException </span></span>{ String vmName = ManagementFactory.getRuntimeMXBean().getName(); String pid = vmName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, vmName.indexOf(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)); HotSpotVirtualMachine vm = (HotSpotvirtualMachine) VirtualMachine.attach(pid); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { vm.localDataDump(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { vm.detach(); } }</code> </pre> <br><br>   GitHub : <a href="https://github.com/odnoklassniki/one-nio/blob/master/src/one/nio/mgt/">https://github.com/odnoklassniki/one-nio/blob/master/src/one/nio/mgt/</a> <br><br><h3> - </h3><br>  jmap     . <br><br> <code>jmap -dump:live,format=b,file=heap.bin PID</code> <br>       ,      ,    : <br><br><img src="https://habrastorage.org/files/cb4/ff9/37b/cb4ff937b0c6476380a59ffd6462a281.png"><br><br>       ,      .   ,    .     ,       . <br><br>  jmap   2  :  Dynamic Attach   Serviceability Agent (     ). <br><br><img src="https://habrastorage.org/files/a8a/871/85b/a8a87185b011423f8ac84bdcf465a7a6.png"><br><br> jmap  -F  ,       ,      JVM.    jmap -F       ,    . <br><br>       jmap?      ,   - . ,  -   , VM       ‚Äî        ,  ,   .            ,     Dynamic Attach   .     ,     ,  -   ,    -F.      .     ,      .   jmap   ,        - . <br><br>  ,   ,           forced-. <br><br> <code>$ sudo gcore 1234 <br> $ jmap -dump:format=b,file=heap.bin /path/to/java core.1234 <br></code> <br>      ,   ‚Äî     ,     ‚Äî core dump.    .   ,          .      . <br>  jmap  ¬´¬ª   core dump. <br><br>    . <br>    tomcat  pid 2362.   jmap  forced-: <br><br><img src="https://habrastorage.org/files/284/23b/aea/28423baea20a47fe8c3f970bee5c3340.png"><br><br>   .     .    ,    gcore, core dump   .   227 . <br>   :     ,  tomcat     . <br><br>  jmap     core-. <br><br><img src="https://habrastorage.org/files/40c/3f4/591/40c3f4591f3c4b65ad80a3da53558ed3.png"><br><br>     , ..     ,      ,   ,      (   ,  jmap -F,       ,    1        ). ,   , jmap -F        . <br><br>   ,  -  ,   - .      : <br><br> <code>-XX:+HeapDumpOnOutOfMemoryError <br></code> <br>       ‚Äî     out of memory.  GC   ,          . <br><br>          : <br><br><img src="https://habrastorage.org/files/382/47c/2f2/38247c2f26b54da7b8a455a32ad8b171.png"><br><br>        ,     . <br><br><img src="https://habrastorage.org/files/b3d/c42/3fc/b3dc423fc0bb479482c93848c5c09598.png"><br><br> ,      manageable, ..        ,     jinfo,     JMX-. <br><br><img src="https://habrastorage.org/files/c4c/8a6/cfb/c4c8a6cfb8754bb9ac63dc0aaa2c5bd4.png"><br><br>  Java 8 update 92   2     - (   downtime    ): <br><br><img src="https://habrastorage.org/files/10c/48a/579/10c48a579fed431ea7044b6857ed2301.png"><br><br>  , , , ,       .       2  (   out of memory      ): <br><br><img src="https://habrastorage.org/files/94a/633/c79/94a633c7942c4347a4d552530f477cb0.png"><br><br>      ? <br><br>     java,  native,  ,  . <br>       MXBean: <br><br><pre> <code class="java hljs">HotSpotDiagnosticMXBean bean = ManagementFactory.newPlatformMXBeanProxy( ManagementFactory.getPlatformMBeanServer(), <span class="hljs-string"><span class="hljs-string">"com.sun.management:type=HotSpotDiagnostic"</span></span>, HotSpotDiagnosticMXBean.class); bean.dumpHeap(<span class="hljs-string"><span class="hljs-string">"/tmp/heap.bin"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre> <br><br>       JMX remote interface,            . <br>  : jmap      ,        ssh  - ,    ,     ‚Äî  JMX remote interface. <br><br>             JVMTI.     <a href="http://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html">IterateOverInstancesOfClass</a> . <br><br><img src="https://habrastorage.org/files/d35/b79/738/d35b797382444dad86cca39569aa8816.png"><br><br>     ,      -    . ,        ,      16 . <br><br>  ,        .       ,     ,     .     <a href="http://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html">GetObjectsWithTags</a>       jobject. <br><br>    ‚Äî  serviceability agent ‚Äî API,    HotSpot.      JDK  JVM,       Java-. <br><br><img src="https://habrastorage.org/files/cb9/afd/668/cb9afd6681214ed3b4e9da569c5ef3d9.png"><br><br>   Java   sa-jdi.jar ‚Äî    API serviceability agent.       :     JVM,     ,   Java API,    .  ,      VM     . <br><br>    . <br> ,   ‚Äî ,       .     - , ,  .       ,    , ..      .    serviceability agent           . <br> API  . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo6; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.DefaultHeapVisitor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.Klass; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.Oop; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.runtime.VM; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.tools.Tool; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyScanner</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tool</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       Klass klass = VM.getVM().getSystemDictionary().find(<span class="hljs-string"><span class="hljs-string">"java/security/PrivateKey"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);       VM.getVM().getObjectHeap().iterateObjectsOfKlass(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHeapVisitor() {           <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>           <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doObj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Oop oop)</span></span></span><span class="hljs-function"> </span></span>{               oop.iterate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FieldPrinter(<span class="hljs-string"><span class="hljs-string">"key"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           }       }, klass);   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyScanner().execute(args);   } }</code> </pre> <br>     (   Tool),            execute   (      ).     run  . <br><br>      serviceability agent,               Java-.       . <br>    tomcat  . <br><br>        ‚Äî     ,    . <br><br><img src="https://habrastorage.org/files/f58/d99/5d5/f58d995d5b5c4fa7a2aa9de717dd4677.png"><br><br> , ,  . Print    ,       . <br><br><img src="https://habrastorage.org/files/5f2/1f8/5f9/5f21f85f93014520aa92078378df15ef.png"><br><br>       .        FieldPrinter,     ,       fieldName,       . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo6; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.DefaultOopVisitor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.OopField; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.TypeArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldPrinter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultOopVisitor</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String fieldName;   FieldPrinter(String fieldName) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fieldName = fieldName;   }   <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OopField field, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isVMField)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.getID().getName().equals(fieldName)) {           TypeArray array = (TypeArray) field.getValue(getObj());           <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length = array.getLength();           System.out.print(fieldName + <span class="hljs-string"><span class="hljs-string">": "</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) {               System.out.printf(<span class="hljs-string"><span class="hljs-string">"%02x"</span></span>, array.getByteAt(i));           }           System.out.println();       }   } }</code> </pre> <br>       private key  . <br><br>  serviceability agent    ,     API  . ,   :      ,   ,   oldGen.  serviceability agent     ,      API.       Java-       oldGen,          ,       oldGen,      . <br>        tomcat,    oldGen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> demo6; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.gc_implementation.parallelScavenge.PSOldGen; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.gc_implementation.parallelScavenge.ParallelScavengeHeap; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.gc_interface.CollectedHeap; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.DefaultHeapVisitor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.Klass; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.oops.Oop; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.runtime.VM; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.jvm.hotspot.tools.Tool; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OldGen</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tool</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       CollectedHeap heap = VM.getVM().getUniverse().heap();       PSOldGen oldGen = ((ParallelScavengeHeap) heap).oldGen();       Klass klass = VM.getVM().getSystemDictionary().find(<span class="hljs-string"><span class="hljs-string">"java/lang/String"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);       VM.getVM().getObjectHeap().iterateObjectsOfKlass(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultHeapVisitor() {           <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>           <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doObj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Oop oop)</span></span></span><span class="hljs-function"> </span></span>{               <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldGen.isIn(oop.getHandle())) {                   oop.printValue();                   System.out.println();               }               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           }       }, klass);   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OldGen().execute(args);   } }</code> </pre> <br>  : <br><br><ul><li>        ; <br><br></li><li> , ,  .      API (      ,   JVM    ). </li></ul><br><hr><br> <i>      . <br><br>            ‚Äî 7-8   <a href="https://jpoint.ru/">JPoint 2017</a> .        ¬´ <a href="https://jpoint.ru/talks/the-art-of-jvm-profiling/">JVM-   </a> ¬ª,   ,       ,     .   ¬´¬ª ,              ! <br><br>  ,  JPoint           Java ‚Äî      <a href="https://habrahabr.ru/company/jugru/blog/323040/">  </a> ,        <a href="https://jpoint.ru/"></a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/325064/">https://habr.com/ru/post/325064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325052/index.html">Technocup: results of the final round and task analysis</a></li>
<li><a href="../325054/index.html">25 interesting books for designers in the public domain</a></li>
<li><a href="../325056/index.html">‚ÄúIt is expensive for us‚Äù - retail about acquiring</a></li>
<li><a href="../325058/index.html">User Interface Cards</a></li>
<li><a href="../325062/index.html">How to collect statistics from the website and not to fill yourself cones</a></li>
<li><a href="../325066/index.html">Release DataGrip 2017.1</a></li>
<li><a href="../325068/index.html">[Translation of the article] 4 tips that we received while talking to business representatives on 4YFN 2017</a></li>
<li><a href="../325070/index.html">Myths about Spark, or Can a Sparkle Java Developer Use Spark?</a></li>
<li><a href="../325072/index.html">Runtyper - a tool for checking types when executing JavaScript code</a></li>
<li><a href="../325074/index.html">Machine Design Tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>