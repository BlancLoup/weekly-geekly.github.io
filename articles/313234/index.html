<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript 2016, and can be easier?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The last six months they have been writing a lot about the unjustified complexity of client-side JavaScript. A recent article How it feels to learn Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript 2016, and can be easier?</h1><div class="post__text post__text-html js-mediator-article"><p>  The last six months they have been writing a lot about the unjustified complexity of client-side JavaScript.  A recent article <a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f">How it feels to learn JavaScript in 2016</a> and its <a href="https://habrahabr.ru/post/312022/">Habr√© translation</a> has received much attention, criticism is largely fair, but ... </p><br><p>  Complicate is simple, difficult to simplify.  (One of the laws of Murphy) </p><br><p>  In this article, I will give practical advice on how you can easily make a front-end application using modern technologies.  Initially, the practical implementation details, and at the end of the article there will be an analysis of the selected stack. </p><br><p>  As an example, the application is used to work with the collection of films.  Movies are displayed in a list with page selection, search, sorting, editing, and deletion. </p><br><p>  Used stack: create-react-app as a client build, React, bootstrap, API with json-server or json-stub. </p><br><p> <a href="https://yegor-sytnyk.github.io/movies-list/"><img src="https://habrastorage.org/files/eae/740/199/eae740199d914154832bd9902208ba63.PNG"></a> </p><br><p>  The running demo is here: <a href="https://yegor-sytnyk.github.io/movies-list/">Movies List</a> . <a name="habracut"></a><br>  In the already mentioned article, there is a dialogue between an experienced front-end developer and a back-end developer who knows a little front-end and wants to write a simple client application using modern technologies.  The front-end "guru" throws out all the variety of technologies that can be used, and so perplexes his colleague that he refuses his idea in general or decides to write everything in the old way with JQuery. </p><br><p>  I will try to give more practical advice on how to do this, moreover, I will show the code of the finished application so that you can use it as an example. </p><br><p>  GitHub repository is <a href="https://github.com/yegor-sytnyk/movies-list">here</a> . </p><br><h2 id="klientskaya-sborka-s-react-scripts">  Client build with React Scripts </h2><br><p>  The first problem in modern front-end development is the need for client builds.  We will use a ready-made build system, where everything immediately works out of the box. </p><br><p>  <a href="https://github.com/facebookincubator/create-react-app">Create-react-app</a> or React Scripts is a young project (first committee in June 2016) created by Dan Abramov, the creator of Redux, who now works on facebook. </p><br><p>  To start </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  create-react-app  npm i -g create-react-app #      my-app create-react-app my-app</span></span></code> </pre> <br><p>  React-scripts builds a client application, without the need for additional configuration.  2 development and production modes are supported. </p><br><p>  In development mode, client assemblies are used in memory (with WebPack dev-server), hot-reload works immediately (you change the code, the page is reloaded), the code is checked with a linker (for example, if you have an unused variable, there will be a corresponding warning) and other. </p><br><p>  To run in development mode, simply: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#cd my-app npm start</span></span></code> </pre> <br><p>  If you need to make a production assembly: </p><br><pre> <code class="bash hljs">npm run build</code> </pre> <br><p>  This will create the application build in the "/ build" folder, where there will be a minimized and scan-ready version. </p><br><p>  For importing styles and paths to images, the WebPack method is used, just import for the necessary resources. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// bootstrap    npm  import '../node_modules/bootstrap/dist/css/bootstrap.css'; //     ,  somePicture    import somePicture from '../media/picture.png';</span></span></code> </pre> <br><p>  Read more about working with react-scripts on the project's <a href="https://github.com/facebookincubator/create-react-app">GitHub page</a> . </p><br><h2 id="react">  React </h2><br><p>  We choose React as the JS framework.  There are other good options (VueJS, Angular2), but unlike them, React has the most stable ecosystem.  This means the stability of the API (does not change much from version to version), support in the IDE, a well-established set of additional libraries (Redux, react-router), a set of ready-made components (react-bootstrap, material-ui). </p><br><p>  In this case, the syntax itself React JSX is not easy for a beginner and this is probably the most difficult thing to deal with in the selected stack. </p><br><p>  The movies-list application itself is intentionally written simply to make it easier to understand for beginners (for example, in a real application you can make a more detailed breakdown into components). </p><br><p>  There are a huge number of various React tutorials, for the selected stack, you need to use the ES6 syntax in the tutorial (components are declared through the class), and you do not need to learn Redux or React Router.  You can deal with them later if need be. </p><br><p>  An example of such a textbook can be <a href="https://egghead.io/courses/react-fundamentals">React Fundamentals on Eggheads</a> , you should also read the <a href="https://facebook.github.io/react/docs/getting-started.html">official documentation</a> . </p><br><h2 id="dopolnitelnye-moduli">  Additional modules </h2><br><p>  Modules are used as npm packages.  As a CSS frame, ‚Äúbootstrap‚Äù is used.  Reeact-bootstrap components are used to integrate with React (well described on the project website). </p><br><p>  The "toastr" package is used for pop-up error messages or notification of a successful operation (for example: the movie was saved).  This package requires the inclusion of "jquery" and for a real project it may make sense to find an analogue on React, in order not to include jQuery and reduce the size of the packaged application. </p><br><p>  To select multiple values ‚Äã‚Äãfor the movie genre, use "react-select" - an advanced version of the component for the drop-down list. </p><br><p>  When using ES6 classes, you need to do a bind for functions.  The "react-autobind" package simplifies this task, it can potentially affect performance (you bind all methods, not only those where it is needed), but it makes development easier.  Read more about bind in React <a href="http://blog.andrewray.me/react-es6-autobinding-and-createclass/">here</a> . </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//: constructor() { super() this.update = this.update.bind(this); //...    } //c autobind import autoBind from 'react-autobind'; ... constructor() { super() autoBind(this); }</span></span></code> </pre> <br><p>  For more convenient manipulation of css classes, the "classnames" package is used. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> classnames <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'classnames'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oneClass = classnames(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "foo bar" let isActive = true; let anotherClass = classnames({ 'foo': true, 'bar': false, 'active': isActive }) //  "foo active"</span></span></code> </pre> <br><h2 id="api">  API </h2><br><p>  If you do not have the ability or desire to use the server part for the client application, then there are several alternative possibilities: </p><br><p>  <strong>JSON stubs</strong> - the initial application data is stored in a JSON file that is imported as an external resource. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jsonData <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../myJsonFile.json'</span></span>;</code> </pre> <br><p>  In the future, all operations take place already with the loaded data.  You implement search, edit, delete operations yourself, working with initial data from JSON. </p><br><p>  In the movie-list, this approach is used by default, the logic in the 'movieServiceStubs' file. </p><br><p>  <strong>Using json-server</strong> ‚Äî the <a href="https://github.com/typicode/json-server">json-server</a> package on startup gives access to the API set based on the JSON file structure. </p><br><p>  For example, if you have db.json in which there is an array of movies, the following APIs will automatically be available: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /movies <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /movies/<span class="hljs-number"><span class="hljs-number">1</span></span> POST /movies PUT /movies/<span class="hljs-number"><span class="hljs-number">1</span></span> PATCH /movies/<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> /movies/<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  At the same time, the API changes the source db.json file; for GET requests, search, paging, sorting is supported. </p><br><p>  In addition, json-server supports many additional options - custom routes, auto-generation of test data, support for connections between different elements. </p><br><p>  In the movie-list there is an opportunity to work with json-server, you need to use movieService instead of movieServiceStub, except for this: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># json-server  npm i -g json-server ## json-server  npm-scripts npm run server</span></span></code> </pre> <br><p>  For AJAX requests in React Scripts it is suggested to use the fetch API.  This is a new browser standard, which is more convenient than XMLHttpRequest.  React Scripts uses a poly file to support older browsers. </p><br><p>  Unlike jQuery, axios and other client libraries, Fetch is a standard that you can use now and that will be serious and for a long time. </p><br><h2 id="yazykovye-funkcii">  Language functions </h2><br><p>  In order not to complicate the code with additional libraries, in the movie-list I use only ES6 features (without lodash) </p><br><p>  In addition to the switch functions ((x) =&gt; ...), you should pay attention to such as: </p><br><p>  ¬ª <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals">Template lines</a> <br>  ¬ª <a href="">Iteration of the for ... of ... collection</a> <br>  ¬ª <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Cloning an Object with Object.assign</a> <br>  ¬ª <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Methods of arrays map, filter, reduce</a> </p><br><p>  Thanks to the new features of ES6, Lodash and similar libraries no longer have such an urgent need, although their use may still be useful. </p><br><p>  The project does not use ES2016 + features, they are supported by <em>React Scripts</em> , but APIs are less reliable and worse supported (documentation, examples, support in IDE, etc.).  If you're still interested, you can try using async / await instead of Promise and static properties in React components. </p><br><h2 id="publikaciya">  Publication </h2><br><p>  There are many sites on which you can lay out static resources (HTML / CSS / JS).  React Scripts suggests using GitHub pages for this, the documentation describes how to do this and after 5 minutes of setup you can publish a demo version of your application.  At the same time, it is necessary to use json stubs, which means the application will lose its state after the page is completely overloaded, which is even better for the demo. </p><br><h1 id="analiz-vybrannogo-steka">  Analysis of the selected stack </h1><br><p>  The article already mentioned indicates several problems of the modern front-end: </p><br><h2 id="neobhodimost-klientskih-bildov">  The need for client builds </h2><br><p>  First, why are they needed at all?  Why it is impossible as before to just include the script in the HTML pages and just start writing code. </p><br><p>  Basically, due to the fact that some browsers implement new standards very slowly (we will not point with our fingers, but mostly this concerns IE).  Until these browsers go down in history (which is at least a couple of years), there will be a need for client builds, at least in order to use the new features of the ES6 language.  In addition, if you have a large application, then you should minify your code, and if it is split into many files, merge them into one assembly, taking into account the links (if module A uses module B, then module B must be included before module A). </p><br><p>  It is difficult to customize the client build.  You need to connect the webpack, babel, with a dozen webpack loaders, to support the dev / prod assembly.  This can take a lot of time and nervous experiences, even when using a boilerplate, it will not be easy for you to choose it, and then maintain it.  Fortunately, there are collectors (not many yet) for the client application, in which everything is hidden inside a separate package and all you need is to connect this collector and write your application with certain features. </p><br><p>  There are already analogs of React Scripts, for VueJS this is <a href="https://github.com/egoist/vbuild">vbuild</a> , for Angular2 I haven‚Äôt yet seen an alternative, but there is a build system for Ionic2 which is built on Angular2.  These projects are not yet so run-in, but the emergence of such tools is only a matter of time. </p><br><p>  Some doubt that this is suitable for serious applications.  This is quite possible, but when using a ready-made client-side system, you must abide by some agreements, for example, the entry point is one and is in src / index.js, CSS preprocessors are not used, the code is checked by a certain set of linter rules.  At the same time, the application itself can be either a simple "hello world" or a complex client on many pages.  For example, in the project <a href="https://github.com/yegor-sytnyk/contoso-express">Contoso Express,</a> react scripts are used for a much more complex application. </p><br><p>  In the end, if after a few months you need something that cannot be achieved by a ready-made collector, you can make your custom decision, but you don‚Äôt have to do it at the very beginning. </p><br><h2 id="problema-bystrogo-ustarevaniya-tehnologiy">  The problem of rapid obsolescence of technology </h2><br><p>  You learn a new technology, spend a lot of time, and it becomes obsolete after six months or the new version of the API is changing dramatically and you have to figure it out again. </p><br><p>  This is true for many technologies, the price of progress, but not for all.  If you do not want to face a similar situation, you just need to choose the right stack.  In our stack, most technologies have long existed, they work reliably and will not change much in the future. </p><br><p>  It is impossible to speak with full confidence about React (although after switching to the ES6 syntax, for the components there were no significant changes in the basic syntax).  But as for ES6, Fetch, Promises - this is something that is already the JS standard and will be relevant for many years, and is already supported in most browsers. </p><br><h2 id="problema-slishkom-bolshogo-vybora">  The problem of too much choice </h2><br><p>  The ability to choose the right tools is important not only in programming.  The problem with JS is that there is no mainstream approach for most cases, like for example in .NET.  And the choice is much more complicated.  In this regard, the React ecosystem is fairly well established, for example, if at the beginning there were many Flux implementations for React, now most applications use Redux, there is only one popular version for client routing React Router, etc. </p><br><p>  It is important not to use unnecessary tools using a progressive development process.  Start with the necessary minimum, adding new components only when it is really necessary.  For example, in the aforementioned article, for a simple one-page application, some technologies were proposed that did not make sense at all: </p><br><ul><li>  <em>ES2016 +</em> is a nice addition, but no special need. </li><li>  <em>TypeScript / Flow</em> - gives the advantages of strict typing, but requires additional efforts when setting up and using, for beginners it will be only an extra challenge (in React Scripts you can connect Flow). </li><li>  <em>Functional programming</em> is for a simple application, there is no need for it at all, and for a complex application it is quite possible to do without it. </li><li>  <em>Lodash / Rumda</em> - using ES6, many useful functions became available at the language level, you can start without them. </li><li>  <em>Flux (Redux)</em> - for a complex application, a method of sharing the state (data) of an application for various components is necessary; for a simple application, abandoning them will facilitate initial development. </li><li>  <em>Testing UI</em> - for a simple application, you can do without them (React Scripts has Jest support for testing React components). </li></ul><br><p>  Thanks to those who read to the end. </p><br><p>  Happy coding!  Stay tuned. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313234/">https://habr.com/ru/post/313234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313216/index.html">Neural networks for beginners. Part 2</a></li>
<li><a href="../313218/index.html">Architecture and programming computer Vectrex</a></li>
<li><a href="../313224/index.html">Sudoku: so how many of them? Part 1/2</a></li>
<li><a href="../313226/index.html">Donald Knut: about his wife, kisses, "Concrete math" and a look at teaching at the university</a></li>
<li><a href="../313232/index.html">Will Microsoft HoloLens ignite or not?</a></li>
<li><a href="../313236/index.html">ZeroNights 2016 program + HackQuest announcement</a></li>
<li><a href="../313238/index.html">Golden Pistols or Why couldn‚Äôt Aeroflot be tricked?</a></li>
<li><a href="../313240/index.html">HPE Synergy Pro - Part IV. Our networks</a></li>
<li><a href="../313242/index.html">Why do we need Delegate in iOS and WatchOS?</a></li>
<li><a href="../313246/index.html">Servers in the Netherlands in premium-data center become cheaper low-cost when entering into a contract with ua-hosting.company</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>