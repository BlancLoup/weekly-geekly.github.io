<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm for building cover sets</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Frankly, before, I had never seriously studied software testing methods. However, I understand that for complete confidence that the program will work...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithm for building cover sets</h1><div class="post__text post__text-html js-mediator-article">  Frankly, before, I had never seriously studied software testing methods.  However, I understand that for complete confidence that the program will work, you need to try all sorts of options for its use.  The fact that it is not always possible to do this is also obvious to me.  If there are specific uses, but it is impossible to check them all because of their number, try to build a set that will cover all the most used options.  But what if the use of all options is equally likely?  How in the minimum amount of time to detect all errors that are more likely to stumble?  This task is really known, and it is often encountered, well, at least, in <a href="http://habrahabr.ru/company/yandex/blog/193918/">Yandex</a> . <br><br>  To make it clear what is at stake, imagine that we need to test any program or site.  A very good example is testing a web form, say, for registration or for searching.  The question arises, what errors will the user most likely encounter in it?  Let us in the form there are 6 questions, for each of which there are 10 possible answers.  Let's say a million users came to the page, and each of them answered uniquely.  Now imagine that there is an error in the response form.  If an error is detected only with a certain combination of answers to all 6 questions, then only one person will come across it.  If the error takes off when typing certain answers to some 3 questions, then the number of people who discovered the error will increase to a thousand.  Obviously, the fewer elements in the combination required for an error, the more people will meet with it.  Accordingly, we now have a task: if we cannot detect all the errors, then let's at least find the most critical ones, that is, those that most users will stumble upon. <br>  Thus, we must form test cases (and the smaller, the better), during the enumeration of which we will come across the most easily accessible errors.  Suppose we have a lot of questions <b>A</b> , which we ask by the number of answers for each of them: A = {2, 3, 5, 2, ...}.  Let <b>n</b> be the number of questions, and 1‚â§ <b>m</b> ‚â§n be the degree of error criticality, it is also the degree of coverage or the depth of the covering set.  The smaller the value of m, the more critical the error.  By setting the coverage level, we build a test suite that will detect all errors whose severity is less than a given m.  If m = n, then the search for errors is reduced to the enumeration of all the options.  The less we set the degree, the less test cases will be formed and the less errors we will find. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/b7d/6c5/ab2/b7d6c5ab2451c613e620764b38760293.jpg" align="right"><br>  It is convenient to present the covering test suite in the form of a matrix, where the lines correspond to the test itself, and the columns represent the choice of answers to the questions.  For example, take the list of questions A = {3, 3, 3, 3} and a set of eleven tests as in the picture to the right.  Such a set is excellent for covering the degree m = 2, since when choosing any two columns in this set, various combinations will be sorted out between them. <br>  How to minimize the number of lines?  The first thing that occurred to me was to form a set with coverage n, that is, all test cases, and then eagerly select from it those that remove the greatest number of combinations not yet covered with m elements.  So I came up with something like a greedy search for covering sets.  Having decided that it was not so interesting, and, perhaps, it would turn out to be not practical, I did not follow this path. <br>  Probably, many of you are already familiar with this task, I have never had to deal with a similar problem, and considering that the deadline was given a week, I had to seriously strain the convolutions.  But it's never too late to learn.  For three days and three nights, I tried to come up with an algorithm that would work best, or at least better, than Yandex <a href="http://burtleburtle.net/bob/math/jenny.html">Jenny</a> .  Do not think that I did not contact the search engines, I simply could not even guess what query to google.  After much agony and various searches, I somehow miraculously gave birth to a method from nowhere, which was based on the consistent addition of combinations when adding a new question.  Apparently, I still have a bit of a programmer mindset, since it didn‚Äôt occur to me to use any genetic algorithms, stochastic methods or anything like that, but a non-trivial, but still greedy algorithm appeared. <br>  What was my surprise when a few days later I learned that the idea I had invented and based on, and a similar sequence of actions already exist, and the corresponding algorithm In Parameter Order is called, in other words, an algorithm based on adding a new parameter .  Moreover, there are some quite good <a href="http://csrc.nist.gov/groups/SNS/acts/documents/grindal-offutt-andler.pdf">articles</a> and even a whole book called <a href="http://panda.ispras.ru/~kuliamin/docs/CovArrays-2010-rus.pdf">‚ÄúReview of methods for constructing covering sets‚Äù</a> , which consider such tasks. <br><br>  Here's how to classify the most famous strategies: <br><img src="https://habrastorage.org/getpro/habr/post_images/406/a57/106/406a5710611772401f2d277138584a5d.jpg"><br>  As you probably guessed, the algorithm described in my article is a deterministic parameterized IPO with my personal modifications.  The input is A and m, the output - the minimum number of tests.  The IPO strategy is divided into two consecutive parts: horizontal and vertical growth.  First we add a column corresponding to the new question, then we add rows corresponding to the missing tests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Step one. </h4><br>  To begin with, we take the first m questions and sort through all the combinations between them.  The output will be a matrix of m columns and the number of lines equal to A (1) * A (2) * ... A (m).  Since, in any case, all combinations must be enumerated between these m columns, we cannot get a smaller number of lines.  In this regard, for the best result, you just need to sort the questions by the number of options in descending order.  Why?  This will become clear in the future. <br><br><h4>  Step two.  Horizontal height </h4><br>  Let k - iteration number + m - 1. That is, the initial k = m.  We now have a coverage of depth m for the first k columns.  Add the following column k + 1 as follows: <br><ol><li>  Create a set B - the set of all unused combinations between column k + 1 and columns 1, ..., k.  Combinations within this set should be classified according to the columns to which they correspond.  Consider the first line. </li><li>  What element should be added to column k + 1 in the row in question?  As I said, my algorithm is greedy, and therefore we add one that will cross out as many combinations as possible from the set B.  We do this: we substitute the first answer in a line and find out how many combinations from B can be crossed out with such a line.  If their number is k, then the option is appropriate; if it is less, we proceed to the next one.  The option that will give the largest number of deleted from B combinations and choose.  From myself I would add that if several options claim to be optimal, then preference should be given to the one that will cross out the combinations with those columns with which the number of combinations not yet covered is the greatest.  Then the probability of crossing out more combinations on the following lines will increase. </li><li>  Remove the covered combinations from B and go to the second paragraph, where we consider the next line.  If there are no more lines, we exit. </li></ol><br>  Now, if all combinations are covered, then we go back to the second step, to a new horizontal growth, that is, we add a new question / column.  If the number of questions is over, the algorithm ends. <br><br><h5>  An example of the work of the algorithm for the situation is A = {2, 2, 2}, m = 2. </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/914/177/ce1/914177ce179eb6e2a70531e6f6a1fcb7.gif"><br>  Large numbers - a set of tests, small - a set of B aka uncovered combinations (on the left - between the first and third columns, on the right - between the second and third).  First the first two columns are formed, then the third is added to them.  For comparison, even for such a simple example, the Jenny algorithm will build one more lines than an IPO. <br>  However, the situation may arise more difficult when horizontal growth is not enough, and you will have to add new lines to cover the remaining combinations. <br><br><h4>  Step three.  Vertical growth </h4><br>  Greed in horizontal growth really gives excellent results if you sort the columns by the number of options in descending order.  If you add a column with fewer options, respectively, with a smaller number of combinations with other columns, the greater the likelihood of covering these combinations in horizontal growth and avoiding vertical or at least reducing it. <br>  Similarly, we work with vertical growth - we add a line that removes the greatest number of combinations from B.  It is much more difficult to search for them here, since not one element, but a whole line changes, and this is the most difficult part of the algorithm.  Therefore, as a rule, this part is avoided and add as many lines as possible, but in polynomial time.  How justified the search for locally the best string is, I can‚Äôt say for sure, but in practice it gives good results. <br>  I acted as follows: sorted in descending order of power of the set b (1), b (2), ..., b (k) are nonintersecting subsets of B, in which uncovered combinations are entered in the corresponding columns.  For clarity: if B = {_11, 1_1, 1_2}, then b (1) = {1_1, 1_2}, b (2) = {_11}.  This ordering is done in order to prioritize the sets with the largest number of remaining combinations.  Then I took the first combination of b (1), then - any combination that does not contradict the previous combination in b (2), then - any combination that suits b (3), etc.  In this example, _11 of b (2) contradicts 1_2 of b (1), but does not contradict 1_1.  The search was similar to the search in depth, when it reached b (k), memorized the number taken from B combinations, returned to b (k-1), took another combination and again to b (k).  The end of the search was, as in the case of horizontal growth, either the achievement of k combinations or a complete search.  Then a similar search began with b (2), then with b (3) and so on until the end.  Moreover, it is obvious that if it was already possible to cross out at least r combinations, then starting the search with b (kr) does not make sense.  The line corresponding to the largest number of combinations taken was inserted into the list of tests, and the new one is to look for the next one. <br>  I do not pretend to the optimality and speed of this search, but this was the only thing I invented then. <br>  Another important modification is that if we have added not all combinations of b (1) ... b (k) to the string, that is, in one of these sets a combination was found that does not contradict the previous one, then empty ones will be formed in the string places.  For example, if it does not matter to us what to insert - line 111 or 121, since the combinations _11 and _21 are already covered, then we can insert any acceptable value, but it is best to leave empty space.  Why?  When all combinations are accurately covered, we return to the second step or, if k = n - 1, we exit.  So, in case we have to grow horizontally, we can take advantage of this empty space by inserting a value that allows you to remove any combination with a column with an empty space. <br><br><h5>  An example of the operation of the algorithm for the situation is A = {3, 3, 3, 3}, m = 2. </h5><br><h6>  The first iteration.  To the first two columns formed, a third is added.  Then two lines are added to cover the remaining combinations _23 and _31 </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/f4f/54c/d40/f4f54cd40e028c3b5023e3985c889fbc.gif"><br><h6>  The second iteration.  Add the fourth column.  Empty places are filled with random numbers. </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/e28/db0/74e/e28db074e274b8ea30a9e2ee8e56383c.gif"><br><br><h4>  Conclusion </h4><br>  Having implemented this algorithm, I was immensely happy, since it worked better and faster than Jenny.  The only, but rather big, minus IPO is that it is theoretically extremely difficult to determine in advance the exact number of rows received.  That is, it works from a given depth, which should be calculated depending on the maximum number of tests.  In my article I give an approximate estimate of the size of the test sets, equal to the largest number of answers to the question in the square.  However, it is true only in a few cases and only with m = 2, moreover, it does not take into account the number of questions, and in fact the scatter of the real size is too large so that we can restrict ourselves to such a scanty estimate.  In the case of m = 1, the number of tests coincides with the largest number of response options, for example, A (k), and for m = n - A (1) * ... * A (n).  Therefore, this question remains open to me. </div><p>Source: <a href="https://habr.com/ru/post/187882/">https://habr.com/ru/post/187882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187870/index.html">Google chromecast</a></li>
<li><a href="../187874/index.html">Congratulations on the Day of the system administrator!</a></li>
<li><a href="../187876/index.html">[NES] Writing level editor for Prince of Persia. Chapter one. Acquaintance</a></li>
<li><a href="../187878/index.html">B1 Basis Band: watch-bioregistrar. Gamification of a healthy lifestyle (first review in Russian)</a></li>
<li><a href="../187880/index.html">KINS - new crimeware toolkit</a></li>
<li><a href="../187886/index.html">Computer vision helps to search for lost dogs.</a></li>
<li><a href="../187888/index.html">Developing a single game - a rewarding experience, some money and a lot of mistakes, P1</a></li>
<li><a href="../187890/index.html">Podcast: 10 formulas about power, motivation, influence and freedom from Mikhail Zavileisky</a></li>
<li><a href="../187892/index.html">Happy System Administrator!</a></li>
<li><a href="../187894/index.html">What can you learn about the candidate for the test task</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>