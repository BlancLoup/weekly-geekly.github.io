<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Abnormal functional python programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After reviewing the Programming Languages course and reading Functional JavaScript, I wanted to repeat all these cool things in python. Some things tu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Abnormal functional python programming</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage3/e6a/b6b/275/e6ab6b2751326e14cce18b1ece778198.png" align="right"><br>  After reviewing the <a href="https://www.coursera.org/course/proglang">Programming Languages</a> course and reading <a href="http://shop.oreilly.com/product/0636920028857.do">Functional JavaScript, I</a> wanted to repeat all these cool things in python.  Some things turned out to be done beautifully and easily, the rest came out scary and unusable. <br><br>  The article includes: <br><ul><li>  few incomprehensible words; </li><li>  currying; </li><li>  pattern matching; </li><li>  recursion (including tail). </li></ul><br><br>  The article is designed for python 3.3+. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Few incomprehensible words </h3><br>  In python, you can write in a functional style, because it has anonymous functions: <br><pre><code class="python hljs">sum_x_y = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x + y print(sum_x_y(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 3</span></span></code> </pre> <br>  Higher-order functions (accepting or returning other functions): <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_and_twice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fnc, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fnc(x, y) * <span class="hljs-number"><span class="hljs-number">2</span></span> print(call_and_twice(sum_x_y, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 14</span></span></code> </pre><br>  Closures: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closure_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> fnc = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> y: x + y <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fnc sum_with_3 = closure_sum(<span class="hljs-number"><span class="hljs-number">3</span></span>) print(sum_with_3(<span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 15</span></span></code> </pre><br>  Tuple unpacking (almost pattern matching): <br><pre> <code class="python hljs">a, b, c = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] print(a, b, c) <span class="hljs-comment"><span class="hljs-comment"># 1 2 3 hd, *tl = range(5) print(hd, 'tl:', *tl) # 0 tl: 1 2 3 4</span></span></code> </pre><br>  And cool modules of <a href="http://docs.python.org/3.3/library/functools.html">functools</a> and <a href="http://docs.python.org/3.3/library/itertools.html">itertools</a> . <br><br><h2>  Currying </h2><br><blockquote>  Convert a function from many arguments to a function that takes its arguments one by one. </blockquote><br>  Consider the simplest case, we curry the function <code>sum_x_y</code> : <br><pre> <code class="python hljs">sum_x_y_carry = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> y: sum_x_y(x, y) print(sum_x_y_carry(<span class="hljs-number"><span class="hljs-number">5</span></span>)(<span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 17</span></span></code> </pre><br>  Something is not cool at all, try this: <br><pre> <code class="python hljs">sum_with_12 = sum_x_y_carry(<span class="hljs-number"><span class="hljs-number">12</span></span>) print(sum_with_12(<span class="hljs-number"><span class="hljs-number">1</span></span>), sum_with_12(<span class="hljs-number"><span class="hljs-number">12</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 13 24 sum_with_5 = sum_x_y_carry(5) print(sum_with_5(10), sum_with_5(17)) # 15 22</span></span></code> </pre><br>  Already more interesting, now let's make a universal function for currying functions with two arguments, because each time writing <code>lambda x: lambda y: zzzz</code> is not at all cool: <br><pre> <code class="python hljs">curry_2 = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> fn: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> y: fn(x, y)</code> </pre><br>  And apply it to the <code>map</code> function used in real projects: <br><pre> <code class="python hljs">curry_map_2 = curry_2(map) @curry_map_2 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twice_or_increase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: n += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n % <span class="hljs-number"><span class="hljs-number">3</span></span>: n *= <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n print(*twice_or_increase(range(<span class="hljs-number"><span class="hljs-number">10</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># 2 2 3 3 10 10 14 14 9 9 print(*twice_or_increase(range(30))) # 2 2 3 3 10 10 14 14 9 9 22 22 26 26 15 15 34 34 38...</span></span></code> </pre><br>  Yes, yes, I used a curried <code>map</code> as a decorator and this eliminated the lack of multi-line lambda. <br><br>  But not all functions take 2 arguments, so <code>curry_n</code> make the function <code>curry_n</code> , using <a href="http://docs.python.org/3.3/library/functools.html">partial</a> , closures and a little recursion: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> partial <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry_n</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, n=None, args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   args = args + [x] #       return partial(aux, n=n - 1, args=args) if n &gt; 1 else fn(*args) #     ,   aux       return partial(aux, n=n, args=[])</span></span></code> </pre><br>  And once again we apply to the <code>map</code> , but with 3 arguments: <br><pre> <code class="python hljs">curry_3_map = curry_n(map, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  And we will make a function for adding list items with list items 1..10: <br><pre> <code class="python hljs">sum_arrays = curry_3_map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x, y: x + y) sum_with_range_10 = sum_arrays(range(<span class="hljs-number"><span class="hljs-number">10</span></span>)) print(*sum_with_range_10(range(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># 100 91 82 73 64 55 46 37 28 19 print(*sum_with_range_10(range(10))) # 0 2 4 6 8 10 12 14 16 18</span></span></code> </pre><br>  Since <code>curry_2</code> is a special case of <code>curry_n</code> , you can do: <br><pre> <code class="python hljs">curry_2 = partial(curry_n, n=<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  And for example, apply it to the <code>filter</code> : <br><pre> <code class="python hljs">curry_filter = curry_2(filter) only_odd = curry_filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> n: n % <span class="hljs-number"><span class="hljs-number">2</span></span>) print(*only_odd(range(<span class="hljs-number"><span class="hljs-number">10</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># 1 3 5 7 9 print(*only_odd(range(-10, 0, 1))) # -9 -7 -5 -3 -1</span></span></code> </pre><br><h2>  Pattern matching </h2><br><blockquote>  A method for analyzing lists or other data structures for the presence of specified samples. </blockquote><br>  Pattern matching is what I liked most about sml and worst of all about python. <br>  We will invent our goal - to write a function that: <br><ul><li>  if it accepts a list of numbers, returns their product; </li><li>  if it accepts a list of strings, returns one large concatenated string </li></ul><br>  Create an auxiliary exception and a function for its ‚Äúthrowing‚Äù, which we will use when the match fails: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotMatch</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Not match"""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">not_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotMatch(x)</code> </pre><br>  And the function that does the checking and returns the object, or throws an exception: <br><pre> <code class="python hljs">match = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> check, obj: obj <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> check(obj) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> not_match(obj) match_curry = curry_n(match, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Now we can create a type check: <br><pre> <code class="python hljs">instance_of = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> type_: match_curry(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> obj: isinstance(obj, type_))</code> </pre><br>  Then for <code>int</code> : <br><pre> <code class="python hljs">is_int = instance_of(int) print(is_int(<span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 2 try: is_int('str') except NotMatch: print('not int') # not int</span></span></code> </pre><br>  Create a type check for the list, checking its each element: <br><pre> <code class="python hljs">is_array_of = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> matcher: match_curry(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> obj: all(map(matcher, obj)))</code> </pre><br>  And then for <code>int</code> : <br><pre> <code class="python hljs">is_array_of_int = is_array_of(is_int) print(is_array_of_int([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])) <span class="hljs-comment"><span class="hljs-comment"># 1 2 3 try: is_array_of_int('str') except NotMatch: print('not int') # not int</span></span></code> </pre><br>  And now, similarly for <code>str</code> : <br><pre> <code class="python hljs">is_str = instance_of(str) is_array_of_str = is_array_of(is_str)</code> </pre><br>  Also add a function that returns its argument, idempotent =) <br><pre> <code class="python hljs">identity = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x print(identity(<span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># 10 print(identity(20)) # 20</span></span></code> </pre><br>  And checking for an empty list: <br><pre> <code class="python hljs">is_blank = match_curry(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> xs: len(xs) == <span class="hljs-number"><span class="hljs-number">0</span></span>) print(is_blank([])) <span class="hljs-comment"><span class="hljs-comment"># [] try: is_blank([1, 2, 3]) except NotMatch: print('not blank') # not blank</span></span></code> </pre><br>  Now we will create a function to divide the list into the first element and the remainder, applying ‚Äúchecks‚Äù to them: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hd_tl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(match_x, match_xs, arr)</span></span></span><span class="hljs-function">:</span></span> x, *xs = arr <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> match_x(x), match_xs(xs) hd_tl_partial = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> match_x, match_xs: partial(hd_tl, match_x, match_xs)</code> </pre><br>  And consider the simplest example with <code>identity</code> : <br><pre> <code class="python hljs">hd_tl_identity = hd_tl_partial(identity, identity) print(hd_tl_identity(range(<span class="hljs-number"><span class="hljs-number">5</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># 0 [1, 2, 3, 4]</span></span></code> </pre><br>  And now with the numbers: <br><pre> <code class="python hljs">hd_tl_ints = hd_tl_partial(is_int, is_array_of_int) print(hd_tl_ints(range(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># 2 [3, 4, 5] try: hd_tl_ints(['str', 1, 2]) except NotMatch: print('not ints') # not ints</span></span></code> </pre><br><br>  And now the function itself, which will go through all the checks.  It is very simple: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pattern_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(patterns, args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pattern, fnc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> patterns: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fnc(pattern(args)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NotMatch: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotMatch(args) pattern_match_curry = curry_n(pattern_match, <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br> <a href="http://xkcd.com/297/"><img src="https://habrastorage.org/getpro/habr/post_images/1b1/ade/0cb/1b1ade0cbebf09ac91c81921b0fe4728.png"></a> <br><br>  But it is inconvenient to use and requires a whole world of brackets, for example, the function we need will look like this: <br><pre> <code class="python hljs">sum_or_multiply = pattern_match_curry(( (hd_tl_partial(identity, is_blank), <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> arr: arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]), <span class="hljs-comment"><span class="hljs-comment"># x::[] -&gt; x (hd_tl_ints, lambda arr: arr[0] * sum_or_multiply(arr[1])), # x::xs -&gt; x * sum_or_multiply (xs)  type(x) == int (hd_tl_partial(is_str, is_array_of_str), lambda arr: arr[0] + sum_or_multiply(arr[1])), # x::xs -&gt; x + sum_or_multiply (xs)  type(x) == str ))</span></span></code> </pre><br>  Now let's check it in action: <br><pre> <code class="python hljs">print(sum_or_multiply(range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># 362880 print(sum_or_multiply(['a', 'b', 'c'])) # abc</span></span></code> </pre><br>  Hooray!  It works =) <br><br><h2>  Recursion </h2><br>  In all cool programming languages, cool guys implement a <code>map</code> through recursion, why are we worse?  Moreover, we are already able to pattern matching: <br><pre> <code class="python hljs">r_map = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> fn, arg: pattern_match(( (hd_tl_partial(identity, is_blank), <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> arr: [fn(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>])]), <span class="hljs-comment"><span class="hljs-comment"># x::[] -&gt; fn(x) ( hd_tl_partial(identity, identity), lambda arr: [fn(arr[0])] + r_map(fn, arr[1]) # x::xs -&gt; fn(x)::r_map(fn, xs) ), ), arg) print(r_map(lambda x: x**2, range(10))) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span></code> </pre><br>  Now we curry: <br><pre> <code class="python hljs">r_map_curry = curry_n(r_map, <span class="hljs-number"><span class="hljs-number">2</span></span>) twice = r_map_curry(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * <span class="hljs-number"><span class="hljs-number">2</span></span>) print(twice(range(<span class="hljs-number"><span class="hljs-number">10</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] try: print(twice(range(1000))) except RuntimeError as e: print(e) # maximum recursion depth exceeded in comparison</span></span></code> </pre><br>  Something went wrong, try tail recursion. <br>  To do this, create a "check" on <code>None</code> : <br><pre> <code class="python hljs">is_none = match_curry(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> obj: obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre><br>  And checking the pair: <br><pre> <code class="python hljs">pair = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> match_x, match_y: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> arr: (match_x(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]), match_y(arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre><br>  And now the <code>map</code> itself: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r_map_tail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, arg)</span></span></span><span class="hljs-function">:</span></span> aux = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> arg: pattern_match(( (pair(identity, is_none), <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> arr: aux([arr[<span class="hljs-number"><span class="hljs-number">0</span></span>], []])), <span class="hljs-comment"><span class="hljs-comment">#   None,   [] ( pair(hd_tl_partial(identity, is_blank), identity), lambda arr: arr[1] + [fn(arr[0][0])] #  (x::[], acc),     fn(x)    ), ( pair(hd_tl_partial(identity, identity), identity), lambda arr: aux([arr[0][1], arr[1] + [fn(arr[0][0])]]) #  (x::xs, acc),      xs   + fn(x) ), ), arg) return aux([arg, None])</span></span></code> </pre><br>  Now let's try our miracle: <br><pre> <code class="python hljs">r_map_tail_curry = curry_n(r_map_tail, <span class="hljs-number"><span class="hljs-number">2</span></span>) twice_tail = r_map_tail_curry(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x * <span class="hljs-number"><span class="hljs-number">2</span></span>) print(twice_tail(range(<span class="hljs-number"><span class="hljs-number">10</span></span>))) <span class="hljs-comment"><span class="hljs-comment"># [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] try: print(twice_tail(range(10000))) except RuntimeError as e: print(e) # maximum recursion depth exceeded</span></span></code> </pre><br>  That's bad luck - python does not optimize tail recursion.  But now crutches will come to our aid: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tail_fnc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn)</span></span></span><span class="hljs-function">:</span></span> called = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> calls = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> len(calls): <span class="hljs-comment"><span class="hljs-comment">#       res = fn(*calls.pop()) return res def call(*args): nonlocal called calls.append(args) #     if not called: #    ,   -   called = True return run() return call</span></span></code> </pre><br>  Now we implement with this <code>map</code> : <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r_map_really_tail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, arg)</span></span></span><span class="hljs-function">:</span></span> aux = tail_fnc(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> arg: pattern_match(( <span class="hljs-comment"><span class="hljs-comment">#    (pair(identity, is_none), lambda arr: aux([arr[0], []])), #   None,   [] ( pair(hd_tl_partial(identity, is_blank), identity), lambda arr: arr[1] + [fn(arr[0][0])] #  (x::[], acc),     fn(x)    ), ( pair(hd_tl_partial(identity, identity), identity), lambda arr: aux([arr[0][1], arr[1] + [fn(arr[0][0])]]) #  (x::xs, acc),      xs   + fn(x) ), ), arg)) return aux([arg, None]) r_map_really_tail_curry = curry_n(r_map_really_tail, 2) twice_really_tail = r_map_really_tail_curry(lambda x: x * 2) print(twice_really_tail(range(1000))) # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18...</span></span></code> </pre><br>  Now it worked =) <br><br><h2>  Not so scary </h2><br> <a href="http://xkcd.com/244/"><img src="https://habrastorage.org/storage3/386/2df/949/3862df94980d7c02f31243ae8b3b93fa.png" align="left"></a>  If we forget about our awful pattern matching, then the recursive <code>map</code> can be implemented quite neatly: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tail_r_map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn, arr_)</span></span></span><span class="hljs-function">:</span></span> @tail_fnc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aux</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arr, acc=None)</span></span></span><span class="hljs-function">:</span></span> x, *xs = arr <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> xs: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aux(xs, acc + [fn(x)]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc + [fn(x)] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aux(arr_, []) curry_tail_r_map = curry_2(tail_r_map)</code> </pre><br><br>  And we will make on it multiplication of all odd numbers in the list by 2: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@curry_tail_r_map def twice_if_odd(x): if x % 2 == 0: return x * 2 else: return x print(twice_if_odd(range(10000))) # [0, 1, 4, 3, 8, 5, 12, 7, 16, 9, 20, 11, 24, 13, 28, 15, 32, 17, 36, 19...</span></span></code> </pre><br>  It turned out quite neatly, albeit slowly and unnecessarily.  At least because of the speed.  Compare the performance of different <code>map</code> options: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time checker = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x ** <span class="hljs-number"><span class="hljs-number">2</span></span> + x limit = <span class="hljs-number"><span class="hljs-number">10000</span></span> start = time() xs = [checker(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(limit)][::<span class="hljs-number"><span class="hljs-number">-1</span></span>] print(<span class="hljs-string"><span class="hljs-string">'inline for:'</span></span>, time() - start) start = time() xs = list(map(checker, range(limit)))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] print(<span class="hljs-string"><span class="hljs-string">'map:'</span></span>, time() - start) calculate = curry_tail_r_map(checker) start = time() xs = calculate(range(limit))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] print(<span class="hljs-string"><span class="hljs-string">'r_map without pattern matching:'</span></span>, time() - start) calculate = r_map_really_tail_curry(checker) start = time() xs = calculate(range(limit))[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] print(<span class="hljs-string"><span class="hljs-string">'r_map with pattern matching:'</span></span>, time() - start)</code> </pre><br>  Then get: <br>  <strong>inline for:</strong> 0.011110067367553711 <br>  <strong>map:</strong> 0.011012554168701172 <br>  <strong>r_map without pattern matching:</strong> 3.7527310848236084 <br>  <strong>r_map with pattern matching:</strong> 5.926968812942505 <br>  The pattern matching option was the slowest, and the built-in map and for were the fastest. <br><br><h2>  Conclusion </h2><br>  From this article in real applications you can only use currying.  The rest is either unreadable or brake bike =) <br>  <a href="https://github.com/nvbn/pyfunc">All examples are available on github.</a> </div><p>Source: <a href="https://habr.com/ru/post/193920/">https://habr.com/ru/post/193920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193910/index.html">The history of a single template or backdoor from myopencart.net</a></li>
<li><a href="../193912/index.html">What do IT people really dream?</a></li>
<li><a href="../193914/index.html">7 popular errors when connecting equipment</a></li>
<li><a href="../193916/index.html">Next-generation laptops from Asus, Dell, HP, Lenovo will show a 3D camera with gesture recognition</a></li>
<li><a href="../193918/index.html">More about testing in Yandex with robots</a></li>
<li><a href="../193922/index.html">We connect Communigate Pro with PSTN gateways and SIP providers</a></li>
<li><a href="../193924/index.html">Perfect smartphone. Moto X Review</a></li>
<li><a href="../193928/index.html">Django Dash 2013</a></li>
<li><a href="../193930/index.html">Scala Training at JetBrains: How It Was</a></li>
<li><a href="../193932/index.html">Customer advice to the tenderer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>