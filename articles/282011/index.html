<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Explaining the inexplicable. Part 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to prepare for PG Day'16 and introduce you to the interesting features of PostgreSQL. 

 In previous posts in this series, I talked about ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Explaining the inexplicable. Part 5</h1><div class="post__text post__text-html js-mediator-article">  <i>We continue to prepare for PG Day'16 and introduce you to the interesting features of PostgreSQL.</i> <br><br>  In <a href="https://habrahabr.ru/post/275851/">previous</a> <a href="https://habrahabr.ru/post/276973/">posts in</a> <a href="https://habrahabr.ru/post/279255/">this</a> <a href="https://habrahabr.ru/post/281036/">series,</a> I talked about how to read EXPLAIN output and what each line (operation / node) means. <br><br>  In the final post I will try to explain why Postgres chooses ‚ÄúOperation X‚Äù rather than ‚ÄúOperation Y‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/432/20b/3dc/43220b3dc23746abb0b2c49999a700dc.jpg"><br><a name="habracut"></a><br>  You may have heard that the PostgreSQL scheduler selects operations based on statistics.  What statistics? <br><br>  Let's imagine the simplest scenario possible: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> = some_value;</code> </pre> <br>  If all the rows in the tables have the same value, some_value, then applying to the column an ‚Äã‚Äãindex (potentially existing) makes no sense. <br><br>  On the other hand, if the values ‚Äã‚Äãin the column are unique (or nearly unique), using an index is a great idea. <br><br>  Let's see what happens: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> ( all_the_same int4, almost_unique int4 ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> ( all_the_same, almost_unique ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span>, random() * <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre><br>  So, I have a table with 100,000 rows, in which the column ‚Äúall_the_same‚Äù always has the same values ‚Äã‚Äã(123), and the column almost_unique, as the name implies, is almost unique: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*), <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> almost_unique) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>; count | count <span class="hljs-comment"><span class="hljs-comment">--------+------- 100000 | 95142 (1 row)</span></span></code> </pre><br>  Now, to make them equal, I'll create two simple indexes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> i1 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (all_the_same); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> i2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> (almost_unique); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span></code> </pre><br>  Ok, test configuration is ready.  What about plans? <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> all_the_same = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------ Seq Scan on test (cost=0.00..1693.00 rows=100000 width=8) Filter: (all_the_same = 123) (2 rows) explain select * from test where almost_unique = 123; QUERY PLAN --------------------------------------------------------------- Index Scan using i2 on test (cost=0.29..8.31 rows=1 width=8) Index Cond: (almost_unique = 123) (2 rows)</span></span></code> </pre><br>  As you can see, Postgres made a wise choice.  But here the estimated value of "rows =" is of interest.  How does he know how many rows the query can return? <br>  The answer lies in the <a href="http://www.postgresql.org/docs/current/interactive/sql-analyze.html">ANALYZE</a> or <a href="http://www.postgresql.org/docs/current/interactive/sql-vacuum.html">VACUUM ANALYZE</a> team. <br><br>  When you apply an ANALYZE to the table, Postgres takes a kind of ‚Äúrandom sample‚Äù (I‚Äôll tell you more about this in a second) and get some statistics.  What is this statistic, where is it, and can we see it?  Of course we can: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_statistic <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> starelid = <span class="hljs-string"><span class="hljs-string">'test'</span></span>::regclass; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------- starelid | 16882 staattnum | 1 stainherit | f stanullfrac | 0 stawidth | 4 stadistinct | 1 stakind1 | 1 stakind2 | 3 stakind3 | 0 stakind4 | 0 stakind5 | 0 staop1 | 96 staop2 | 97 staop3 | 0 staop4 | 0 staop5 | 0 stanumbers1 | {1} stanumbers2 | {1} stanumbers3 | [null] stanumbers4 | [null] stanumbers5 | [null] stavalues1 | {123} stavalues2 | [null] stavalues3 | [null] stavalues4 | [null] stavalues5 | [null] -[ RECORD 2 ]----------------------------------------------------------------------------- starelid | 16882 staattnum | 2 stainherit | f stanullfrac | 0 stawidth | 4 stadistinct | -0.92146 stakind1 | 1 stakind2 | 2 stakind3 | 3 stakind4 | 0 stakind5 | 0 staop1 | 96 staop2 | 97 staop3 | 97 staop4 | 0 staop5 | 0 stanumbers1 | {0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05} stanumbers2 | [null] stanumbers3 | {-0.000468686} stanumbers4 | [null] stanumbers5 | [null] stavalues1 | {21606,27889,120502,289914,417495,951355,283,1812,3774,6028,6229,10372,12234,13291,18309,18443,21758,22565,26634,28392,28413,31208,32890,36563,39277,40574,44527,49954,53344,53863,56492,56715,60856,62993,64294,65275,65355,68353,71194,74718,77205,82096,82783,84764,85301,87498,90990,94043,97304,98779,101181,103700,103889,106288,108562,110796,113154,117850,121578,122643,123874,126299,129236,129332,129512,134430,134980,136987,137368,138175,139001,141519,142934,143432,143707,144501,148633,152481,154327,157067,157799,162437,164072,164337,165942,167611,170319,171047,177383,184134,188702,189005,191786,192718,196330,197851,199457,202652,202689,205983} stavalues2 | {2,10560,20266,31061,40804,50080,59234,69240,79094,89371,99470,109557,119578,130454,140809,152052,162656,173855,183914,194263,204593,214876,224596,233758,243246,253552,264145,273855,283780,294475,303972,314544,324929,335008,346169,356505,367395,376639,387302,397004,407093,416615,426646,436146,445701,455588,466463,475910,485228,495434,505425,515853,525374,534824,545387,554794,563591,573721,584021,593368,602935,613238,623317,633947,643431,653397,664177,673976,684042,694791,703922,714113,724602,735848,745596,754477,764171,772535,781924,791652,801703,812487,822196,831618,841665,850722,861532,872067,881570,891654,901595,910975,921698,931785,940716,950623,960551,970261,979855,989540,999993} stavalues3 | [null] stavalues4 | [null] stavalues5 | [null]</span></span></code> </pre><br>  This table (pg_statistic) is, of course, described <a href="http://www.postgresql.org/docs/current/interactive/catalog-pg-statistic.html">in the documentation</a> , but still quite mysterious.  Of course, you can find a very accurate explanation <a href="http://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dblob%3Bf%3Dsrc/include/catalog/pg_statistic.h">in the source code</a> , but this is (usually) not the best solution. <br><br>  Fortunately, there is a view for this table that contains the same data in a more ‚Äúreadable‚Äù view: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'test'</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----------+------------------------------------------------------------------ schemaname | public tablename | test attname | all_the_same inherited | f null_frac | 0 avg_width | 4 n_distinct | 1 most_common_vals | {123} most_common_freqs | {1} histogram_bounds | [null] correlation | 1 most_common_elems | [null] most_common_elem_freqs | [null] elem_count_histogram | [null] -[ RECORD 2 ]----------+------------------------------------------------------------------ schemaname | public tablename | test attname | almost_unique inherited | f null_frac | 0 avg_width | 4 n_distinct | -0.92146 most_common_vals | {21606,27889,120502,289914,417495,951355,283,1812,3774,6028,6229,10372,12234,13291,18309,18443,21758,22565,26634,28392,28413,31208,32890,36563,39277,40574,44527,49954,53344,53863,56492,56715,60856,62993,64294,65275,65355,68353,71194,74718,77205,82096,82783,84764,85301,87498,90990,94043,97304,98779,101181,103700,103889,106288,108562,110796,113154,117850,121578,122643,123874,126299,129236,129332,129512,134430,134980,136987,137368,138175,139001,141519,142934,143432,143707,144501,148633,152481,154327,157067,157799,162437,164072,164337,165942,167611,170319,171047,177383,184134,188702,189005,191786,192718,196330,197851,199457,202652,202689,205983} most_common_freqs | {0.0001,0.0001,0.0001,0.0001,0.0001,0.0001,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05} histogram_bounds | {2,10560,20266,31061,40804,50080,59234,69240,79094,89371,99470,109557,119578,130454,140809,152052,162656,173855,183914,194263,204593,214876,224596,233758,243246,253552,264145,273855,283780,294475,303972,314544,324929,335008,346169,356505,367395,376639,387302,397004,407093,416615,426646,436146,445701,455588,466463,475910,485228,495434,505425,515853,525374,534824,545387,554794,563591,573721,584021,593368,602935,613238,623317,633947,643431,653397,664177,673976,684042,694791,703922,714113,724602,735848,745596,754477,764171,772535,781924,791652,801703,812487,822196,831618,841665,850722,861532,872067,881570,891654,901595,910975,921698,931785,940716,950623,960551,970261,979855,989540,999993} correlation | -0.000468686 most_common_elems | [null] most_common_elem_freqs | [null] elem_count_histogram | [null]</span></span></code> </pre><br>  Fine.  So what knowledge can we learn from here? <br><br>  The columns schemaname, tablename and attname seem obvious.  Inherited simply reports whether the values ‚Äã‚Äãin this table contain values ‚Äã‚Äãfrom any tables that inherit this column. <br><br>  So, if I created a table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> z () inherits (<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>);</code> </pre><br>  And then I added some data to this table z, then the statistics of the test table would show ‚Äúinherited = true‚Äù. <br><br>  The remaining columns mean the following: <br><ul><li>  null_frac - how many rows are null in this column.  This is a fraction, so the value will be from 0 to 1. </li><li>  avg_width - the average width (approx. lane: size) of the data in this column.  This is not very interesting if the width is constant (as in int4 in this example), but in the case of any data types with variable width (as in text / varchar / numeric) this may be useful. </li><li>  n_distinct is a very interesting value.  If it is positive (1+), then it will be just an indicative number (not a fraction!) Of different values, as we see in the case of the column all_the_same, where n_distinct is just 1. And if it is negative, then the meaning changes: n_distinct shows which the proportion of lines is unique.  Therefore, in the case of almost_unique, statistics assume that 92.146% of the lines have a unique value (which is slightly less than 95.142%, which I showed earlier).  The values ‚Äã‚Äãmay be incorrect due to the ‚Äúrandom sample‚Äù piece that I mentioned and will explain in detail later. </li><li>  most_common_vals - an array of the most common values ‚Äã‚Äãin this table. </li><li>  most_common_freqs - how often the values ‚Äã‚Äãfrom the most_common_vals occur - this is also a fraction, so the maximum value is 1 (but this will mean that we have only one value in the most_common_vals).  Here, in almost_unique, we see that Postgres "thinks" that the values ‚Äã‚Äã21606, 27889, 120502, 289914, 417495, 951355 occur most often, but this is not the case.  Again, the ‚Äúrandom pattern‚Äù effect is to blame. </li><li>  histogram_bounds is an array of values ‚Äã‚Äãthat divides (or should divide - again everything rests on a ‚Äúrandom sample‚Äù) the entire data set into groups with the same number of rows.  That is, the number of lines almost_unique between 2 and 10560 is the same (more or less) as the number of lines almost_unique between 931785 and 940716. </li><li>  correlation is a very interesting statistic, it shows whether there is a correlation between the physical sorting of the strings on the disk and the values.  This value can vary from -1 to 1, and the closer it is to -1/1, the greater the correlation.  For example, after running ‚ÄúCLUSTER test using i2‚Äù, which re-sorts the table in almost_unique order, I got a correlation of 0.919358 - much better than the previous value of -0.000468686. <br>  most_common_elems, most_common_elem_freqs and elem_count_histogram are the same as most_common_vals, most_common_freqs and histogram_bounds, but for non-scalar data types (that is, arrays, tsvectors and alike). </li></ul><br>  Based on this data, PostgreSQL can estimate how many rows will be returned by any selected part of the query, and based on this information, decide which is better to use: seq scan, index scan or bitmap index scan.  And when combined, which operation should be faster: Hash Join, Merge Join or, perhaps, Nested Loop. <br><br>  If you have carefully studied the data presented above, you might be wondering: this is a fairly extensive set of output data, the arrays of most_common_vals / most_common_freqs / histogram_bounds contain many values.  Why are there so many of them? <br><br>  The reason is simple - it's all about the settings.  In postgresql.conf you can find the variable default_statistics_target.  This variable tells Postgres how many values ‚Äã‚Äãto store in these arrays.  In my case (the default), this number is 100. But you can easily change it.  Make a change to postgresql.conf, or even for each individual column like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> almost_unique <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><br>  After applying ALTER (and ANALYZE), the data in pg_stats is significantly shortened: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> inherited <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> attname = <span class="hljs-string"><span class="hljs-string">'almost_unique'</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----------+--------------------------------------------------------- schemaname | public tablename | test attname | almost_unique inherited | f null_frac | 0 avg_width | 4 n_distinct | -0.92112 most_common_vals | {114832,3185,3774,6642,11984} most_common_freqs | {0.0001,6.66667e-05,6.66667e-05,6.66667e-05,6.66667e-05} histogram_bounds | {2,199470,401018,596414,798994,999964} correlation | 1 most_common_elems | [null] most_common_elem_freqs | [null] elem_count_histogram | [null]</span></span></code> </pre><br>  Changing the statistic target also has another effect. <br><br>  Let me show you.  First, I‚Äôll roll back the changes in statistics that I made with ALTER TABLE: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> almost_unique <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre><br>  Now do the following: <br><br><pre> <code class="sql hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> verbose <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>; INFO: analyzing "public.test" INFO: "test": scanned 443 of 443 pages, containing 100000 live rows and 0 dead rows; 30000 rows in sample, 100000 estimated total rows <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> almost_unique <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> all_the_same <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> verbose <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>; INFO: analyzing "public.test" INFO: "test": scanned 443 of 443 pages, containing 100000 live rows and 0 dead rows; 3000 rows in sample, 100000 estimated total rows <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span></code> </pre><br>  Notice that the second analyze tested only 3000 lines, and not 30,000 as the first. <br><br>  This is the "random pattern." <br><br>  Analysis of all rows will be prohibitively expensive for any medium or large table. <br><br>  Therefore Postgres is smarter. <br><br>  First of all, it reads a random part of the pages in the table (I remind you: each page is 8kB of data).  How much?  300 * statistics_target. <br><br>  This means that in my case with default_statistics_target = 100 it will read 30,000 pages (in my table there is not so much, so Postgres will read them all). <br><br>  From these pages ANALYZE takes only information about living and dead lines.  It then receives data on a random sample of rows ‚Äî again 300 * statistics target ‚Äî and counts the column statistics based on that data. <br><br>  In my case, the table had 100,000 rows, but with default_statistics_target = 100, only a third was analyzed.  And, taking into account the value of statistics target, the number of lines analyzed is even smaller - only 3000. <br><br>  You might say: OK, but in this case, the statistics are inaccurate.  It may happen that some super-widespread meaning is not found in any of the scanned lines.  Of course you're right.  This is possible.  Although not very likely.  You take a random piece of data.  The chances that you will get x% of a table that does not have a single row with some value that is present in all the other rows are negligible. <br><br>  It also means that in some cases, the start of the analysis will ‚Äúbreak‚Äù your requests.  For example, you will receive statistics on other pages, and it will turn out that some values ‚Äã‚Äãwill be skipped (or vice versa - you will get not so common values ‚Äã‚Äãin most_common_vals, it just so happened that Postgres selected the appropriate pages / lines to see them).  And based on such statistics, Pg will generate non-optimal plans. <br><br>  If you encounter such a situation, simply solve it - increase the statistics target.  This will make the analyze work harder and scan more lines, so the chances that this will happen again will become even smaller. <br><br>  But there are some drawbacks to setting large statistics target values.  Firstly, ANALYZE has to work more, but it is a question of exploitation, so it doesn‚Äôt worry us too much (usually).  The main problem is that the more data in pg_statistic, the more data must be taken into account by the Pg scheduler.  Therefore, no matter how tempting it is to set default_statistics_target to a maximum of 10,000, in reality I have not met databases in which this value would be so high. <br><br>  The current 100 are installed by default, starting with version 8.4.  In previous versions, the default value was 10, and on irc there were often tips to increase it.  Now with a value of 100, everything is more or less configured. <br><br>  The last thing I have to tell you about, although I don‚Äôt really want to, is the settings that make the Postgres scheduler use different operations. <br><br>  First, I will explain why I do not want to talk about it: I know for sure that this can be easily abused.  So remember: these settings are needed to search for problems, not to solve them.  An application that will use them during operation can be suspected at least that it is broken.  And yes, I know that sometimes you have to do that.  But this ‚Äúsometimes‚Äù happens extremely rarely. <br><br>  Now that I have warned you, let's see what can be done. <br><br>  In postgresql.conf you have several settings: <br><br><pre> <code class="sql hljs">enable_bitmapscan = on enable_hashagg = on enable_hashjoin = on enable_indexscan = on enable_indexonlyscan = on enable_material = on enable_mergejoin = on enable_nestloop = on enable_seqscan = on enable_sort = on enable_tidscan = on</code> </pre><br>  These settings are needed to disable selected operations. <br><br>  For example, switching enable_seqscan to false (this can be done using the SET command in an SQL session, you do not need to change postgresql.conf) will cause the scheduler to use everything that is possible to avoid sequential scanning. <br><br>  And, since sometimes it is impossible to avoid sequential scanning (for example, if there are no indexes in the table), these settings do not actually turn off operations, but simply attach huge costs to their use. <br><br>  Let's give an example.  Regarding our test pattern, we know that searching with ‚Äúall_the_same = 123‚Äù will use sequential scanning, because it doesn‚Äôt cost much: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> all_the_same = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------ Seq Scan on test (cost=0.00..1693.00 rows=100000 width=8) Filter: (all_the_same = 123) (2 rows)</span></span></code> </pre><br>  But if we disable seq scan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> all_the_same = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------- Index Scan using i1 on test (cost=0.29..3300.29 rows=100000 width=8) Index Cond: (all_the_same = 123) (2 rows)</span></span></code> </pre><br>  We see that the estimated cost of obtaining the same data using the index scan ~ is twice as high (3300.29 versus 1693). <br><br>  If I remove the i1 index: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> i1; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> all_the_same = <span class="hljs-number"><span class="hljs-number">123</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">----------------------------------------------------------------------------- Seq Scan on test (cost=10000000000.00..10000001693.00 rows=100000 width=8) Filter: (all_the_same = 123) (2 rows)</span></span></code> </pre><br>  And we see that when there are no other possibilities besides sequential scans (interestingly, Postgres did not choose to conduct an i2 scan scan, although this index has pointers to all the rows in the table), the costs soared to 10,000,000,000 ‚Äî that is enable_ * = false and does. <br><br>  I think that's all.  If you have read the entire series, now you should have enough knowledge to understand what is happening and, more important, why. </div><p>Source: <a href="https://habr.com/ru/post/282011/">https://habr.com/ru/post/282011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281999/index.html">The experience of automating difficult correspondence (Part 2. Outgoing)</a></li>
<li><a href="../282001/index.html">New course on microcontrollers - a joint project of industry and universities</a></li>
<li><a href="../282003/index.html">Setting up PhpStorm for layout on Windows</a></li>
<li><a href="../282005/index.html">How to become an IT princess</a></li>
<li><a href="../282009/index.html">RUVDS will provide BCS clients with virtual servers in the heart of the Moscow Exchange</a></li>
<li><a href="../282015/index.html">Callbacks in JavaScript using the example of minions</a></li>
<li><a href="../282017/index.html">Cloud Digest # 4: OS, Infrastructure, and Virtualization</a></li>
<li><a href="../282019/index.html">About conferences</a></li>
<li><a href="../282021/index.html">Why should a book engineer when there is internet</a></li>
<li><a href="../282023/index.html">Microsoft Edge Web Summit 2016 Entries Available - Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>