<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write on Spring in 2017</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the classic articles for newbies who recently flashed on Habr√©, it was told about creating a basic Web application in Java. It all started w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write on Spring in 2017</h1><div class="post__text post__text-html js-mediator-article"><p>  In one of the classic articles for newbies who recently flashed on Habr√©, it was told about creating a basic Web application in Java.  It all started with a servlet, then creating a JSP page, and finally deploying it to a container.  Looking at it with a fresh look, I realized that for just for beginners it probably looks absolutely creepy - against the background of simple and understandable PHP or Node.js, where everything is simple - the controller wrote, returned the object, it became JSON or HTML.  In order to dispel this feeling a bit, I decided to write a "Guide for beginners in Spring".  The purpose of this article is to show that building Web applications in Java, moreover, on the <em>Spring Framework</em> is not painful and painful wading through the web.xml, persistence.xml, beans.xml, and picking up the application as a house of cards piece by piece, but quite to itself fast and comfortable process.  Audience - novice developers, developers in other languages, well, and those who have seen Spring in its not the best times. </p><a name="habracut"></a><br><h1 id="vvedenie">  Introduction </h1><br><p>  In this article, we will look at what modern Spring includes, how to set up a local environment for developing Web applications, and create a simple web application that takes data from the database and renders the HTML page and JSON.  Strangely enough, most articles (in Russian) for beginners that I found in the search top describe both manual context creation, application launch, and configuration via XML - of course, it is not necessary to do any of this in the modern Spring. </p><br><h1 id="chto-takoe-spring">  What is Spring? </h1><br><p>  For a start, a couple of words, what is Spring.  Nowadays, the term "Spring" often means a whole family of projects.  For the most part, they are developed and supervised by Pivotal and community forces.  The key (but not all) Spring family projects are: </p><br><ul><li><p>  <strong>Spring Framework</strong> (or Spring Core) <br>  The core of the platform provides the basic tools for creating applications - managing components (beans, <strong>beans</strong> ), dependency injection, MVC framework, transactions, basic database access.  These are mainly low-level components and abstractions.  In essence, it is implicitly used by all other components. </p><br></li><li><p>  <strong>Spring MVC</strong> (part of the Spring Framework) <br>  It is worth mentioning separately, because  we will be talking mainly about web applications.  Operates with the concepts of controllers, request mappings, various HTTP abstractions, etc.  Normal template engines such as Thymeleaf, Freemaker, Mustache are integrated with Spring MVC, plus there are third-party integrations with a bunch of others.  So no horror like JSP or JSF is needed. </p><br></li><li><p>  <strong>Spring data</strong> <br>  Data access: relational and non-relational databases, KV storages, etc. </p><br></li><li><p>  <strong>Spring cloud</strong> <br>  Many useful for microservice architecture - service discovery, tracing and diagnostics, query balancers, circuit breakers, routers, etc. </p><br></li><li><p>  <strong>Spring security</strong> <br>  Authorization and authentication, access to data, methods, etc.  OAuth, LDAP, and a bunch of different providers. </p><br></li><li>  <strong>Spring integration</strong> <br>  Processing data from different sources.  If you need to take a file with FTP every hour, break it into lines, which you then filter, and then send it to some queue - this is to Spring Integration. </li></ul><br><p>  A typical web application will most likely include a suite like Spring MVC, Data, Security.  Below we will see how this all works together. </p><br><p>  A special note is <strong>Spring Boot</strong> - this is the cherry on the cake (and some people <a href="">think</a> that the cake itself), which allows you to avoid all the horror of the XML configuration.  Boot allows you to quickly create and configure (i.e., configure dependencies between components) an application, package it into a self-sufficient artifact being executed.  This is the link that brings together a set of components into a ready-made application.  A couple of things you need to know about Spring Boot: </p><br><ul><li>  It does not use code generation.  From the code that is generated, only the main method is present.  If you are looking for a utility to generate applications - rather JHipster </li><li>  Does not use XML for configuration.  All configurable through annotations </li><li> Autoconfiguration to the maximum is used.  If you add a dependency on Mongo, and do not specify where to connect - Boot will try <code>localhost:27017</code> </li><li>  Used <em>convention over configuration</em> .  Most configurations do not need to configure anything. </li><li>  It is easy to push aside and override the default configuration.  For example, if in the settings you specify a host to connect to Mongo - it will automatically block <code>localhost</code> </li></ul><br><h1 id="nastroyka-okruzheniya">  Setting up the environment </h1><br><p>  To create a simple application, to know how to create a Maven project from scratch, how to configure plugins, to create a JAR, what are some layouts in a JAR, how to configure Surefire to run tests, how to install and run Tomcat locally, and even more, how DispatcherServlet works is completely unnecessary. </p><br><p>  A modern Spring application is created in two steps: </p><br><ol><li>  Go to the <a href="https://start.spring.io/">Spring Initializr</a> . </li><li>  ... and everything, there is no second step </li></ol><br><p>  Spring Initializr allows you to "type" in your application the necessary components, which then Spring Boot (it is automatically included in all projects created at Initializr) will put together. </p><br><p>  Anything can be used as a development environment, for example, the free IntelliJ IDEA CE does a great job - just import the created pom.xml (Maven) or build.gradle (Gradle) file into the IDE. </p><br><p>  It is worth mentioning the Spring Boot component called <em>DevTools</em> .  It solves the problem of the local development cycle, which previously looked like: </p><br><ol><li>  Build a WAR locally </li><li>  Apply it to a Very Cool Enterprise Application Server on a test server, because setting up WAEA locally requires remarkable dexterity </li><li>  Drink a cup of coffee, i.e.  OKEAAS restart the application at best in a few minutes </li><li>  Copy the error bars </li><li>  Go to step 1 </li></ol><br><blockquote>  In those ancient times, a saying was born that Spring is a DSL for converting XML configs into spectra. </blockquote><p>  With <strong>Spring Boot DevTools enabled,</strong> the development cycle is shortened to: </p><br><ol><li>  Run the application through the green triangle in IDEA </li></ol><br><p>  <em>DevTools</em> will automatically check for changes in the compiled code or templates, and very quickly restart (hot reload) only the "combat" part of the application (like nodemon, if you are familiar with the world of node.js).  Moreover, DevTools includes integration with <em>Live Reload</em> and after installing the extension in the browser, it is enough to compile the project in IDEA so that it is automatically updated in the browser. </p><br><h1 id="razrabotka">  Development </h1><br><p>  Okay, it's time to get down to the practical part.  So, our goal is to create a web application that gives the welcome page, accesses its own API, receives JSON with data from the database and displays them in a table. </p><br><h2 id="novyy-proekt">  New project </h2><br><p>  To start, go to <a href="https://start.spring.io/">start.spring.io</a> and create a project with <em>Web</em> dependencies, <em>DevTools</em> , <em>JPA</em> (access to relational databases), <em>H2</em> (simple in-memory database), <em>Mustache</em> (template engine).  The generated <code>pom.xml</code> imported into IDEA.  That's it, the app is ready to launch!  You can run it from the command line with the command <code>./mvnw spring-boot:run</code> or directly from IDEA by running the main method.  Yes, application servers, containers and deployment are not needed. </p><br><blockquote>  More precisely, the container is needed - only it is provided and configured by the Spring Boot - using Embedded Tomcat </blockquote><br><h2 id="kontroller">  Controller </h2><br><p>  So, our next step is to create a controller and return the "home" page.  The controller code looks as simple as expected: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ModelAndView </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, String&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); model.put(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alexey"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelAndView(<span class="hljs-string"><span class="hljs-string">"index"</span></span>, model); } }</code> </pre> <br><p>  A couple of things worth paying attention to. </p><br><ol><li>  The method returns <code>ModelAndView</code> - then Spring knows that you need to take a view of <code>index.html</code> from the <code>resources/templates</code> folder (this is the default agreement) and pass the model there </li><li>  In our case, the model is just a dictionary, but it can also be a strongly-typed model (object) </li></ol><br><blockquote>  With Kotlin, this would have looked even better and simpler, but this would require the introduction of a large number of new concepts at once - language, framework.  It‚Äôs better to start small. </blockquote><p>  The class marked as <code>@Controller</code> automatically registered in the MVC router, and using the annotations <code>@(Get|Post|Put|Patch)Mapping</code> you can register different paths. </p><br><blockquote>  All files from the <code>resources/static/</code> directory are considered static, you can store CSS and images there. </blockquote><br><h2 id="shablon">  Template </h2><br><p>  We use <em>Mustache (Handlebar)</em> syntax, so the template is very similar to plain HTML. </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to Spring, {{ name }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  After compiling the project (‚åò / Ctrl + F9) - you can immediately go to <code>http://localhost:8080</code> and see the created page. </p><br><h2 id="dostup-k-baze">  Access to database </h2><br><p>  To begin with, we describe our subject area.  We will collect visitor statistics - every time someone visits the main page, we will write this into the database.  The model looks extremely primitive: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Long id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String description; }</code> </pre> <br><blockquote>  Anticipating the sequence of comments "As without getters and setters" and "Where is equals / hashCode", these elements are deliberately omitted in order to simplify the code.  A completely monstrous mistake in Java design that makes writing this nonsense (getters and comparison methods) is, of course, a separate conversation.  Kotlin this problem, by the way, solves. </blockquote><p>  We again very actively use annotations - this time from <strong>Spring Data</strong> (more precisely, JPA is a dense specification for data access).  This class describes a model with two fields, one of which is automatically generated.  This class will automatically create a data model (table) in the database. </p><br><p>  Now it's time to create a repository for this model.  It is even easier than the controller. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Repository</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VisitsRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visit</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p>  All, the repository can be used to work with the database - read and write notes.  An attentive reader should work WTF detector - what happens here at all?  We define the <strong>interface</strong> and suddenly it starts working with the base?  It's like that.  Thanks to the magic of <em>Spring Boot</em> and <em>Spring Data</em> "under the hood", the following happens: </p><br><ul><li>  Upon seeing the <em>H2</em> dependencies (embedded database), Boot will automatically configure the <code>DataSource</code> (this is the key component for connecting to the database) so that the application works with this database </li><li>  <em>Spring Data</em> searches for all the heirs of the <code>CrudRepository</code> and automatically generates default implementations for them, which include the basic methods of the repository, such as <code>findOne</code> , <code>findAll</code> , <code>save</code> etc. </li><li>  Spring automatically configures the data access layer ‚Äî <em>JPA</em> (more precisely, its <em>Hibernate</em> implementation) </li><li>  Thanks to the <code>@Repository</code> annotation <code>@Repository</code> this component becomes available in our application (and we use it in a couple of minutes) </li></ul><br><p>  To use the repository in the controller, we use the <strong>dependency injection</strong> mechanism provided by the Spring Framework.  To do this, oddly enough, you just need to declare a dependency in our controller. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> VisitsRepository visitsRepository; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VisitsRepository visitsRepository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visitsRepository = visitsRepository; } ... }</code> </pre> <br><p>  Having seen the <code>VisitRepository</code> type parameter in our constructor, Spring will find the repository created by <em>Spring Data</em> and transfer it to the constructor. </p><br><p>  Now you can write to the database in the controller method. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ModelAndView </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, String&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); model.put(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alexey"</span></span>); Visit visit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Visit(); visit.description = String.format(<span class="hljs-string"><span class="hljs-string">"Visited at %s"</span></span>, LocalDateTime.now()); visitsRepository.save(visit); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModelAndView(<span class="hljs-string"><span class="hljs-string">"index"</span></span>, model); }</code> </pre> <br><h2 id="rest-kontroller">  REST controller </h2><br><p>  The next step is to return all records from the database in JSON format, so that they can be read later on the client. </p><br><p>  For REST, Spring has a separate type of controller called <code>@RestController</code> , whose code is not much different from a regular controller. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/api"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> VisitsRepository visitsRepository; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ApiController(VisitsRepository visitsRepository) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visitsRepository = visitsRepository; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/visits"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Iterable&lt;Visit&gt; getVisits() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visitsRepository.findAll(); } }</code> </pre> <br><p>  What to look for: </p><br><ul><li>  This time we define the "prefix" for all controller methods using the base <code>@RequestMapping</code> </li><li>  Dependency injection works the same way as for regular controllers (as well as for everything in Spring in general) </li><li>  The method now returns not the name of the template, but the model.  Spring automatically converts this to an array of JSON objects. </li><li>  We use persistence model for serialization in JSON, which is generally not the best practice. </li></ul><br><p>  Now, when you request <code>http://localhost:8080/api/visits</code> (after having compiled the project and letting <em>DevTools</em> update the application), we will get JSON with the necessary data. </p><br><h2 id="klientskiy-kod">  Client Code </h2><br><p>  Leaving outside the scope of this article, an example can be seen in the source code.  The purpose of this code is to demonstrate how to get JSON data from the server, integration with client frameworks React, Angular etc is intentionally left outside the scope of this article. </p><br><h1 id="testirovanie">  Testing </h1><br><p>  Spring also provides powerful tools for <em>Integration</em> and <em>Unit</em> testing applications.  An example of code that checks the controller: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexControllerShouldReturnHtmlPage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ mockMvc.perform(get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) .andExpect(status().isOk()) .andExpect(content().string(containsString(<span class="hljs-string"><span class="hljs-string">"Welcome to Spring"</span></span>))); }</code> </pre> <br><p>  Using abstractions such as <code>MockMvc</code> you can easily test the external interface of an application, while at the same time having access to its internals.  For example, you can completely replace the components of the application for moki (stub). </p><br><p>  Similarly, for the test APIs, there is a set of helpers for testing <em>JsonPath</em> expressions. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiControllerShouldReturnVisits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ mockMvc.perform(get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); mockMvc.perform(get(<span class="hljs-string"><span class="hljs-string">"/api/visits"</span></span>)) .andExpect(jsonPath(<span class="hljs-string"><span class="hljs-string">"$.*.description"</span></span>, iterableWithSize(<span class="hljs-number"><span class="hljs-number">1</span></span>))); }</code> </pre> <br><p>  Testing in Spring is still a separate topic, so we will not dwell on it much now. </p><br><h1 id="deployment">  Deployment </h1><br><p>  There are several options for building and running our application in production. </p><br><ol><li>  Enclose the received JAR (or even WAR) into a servlet container, for example Tomcat.  This is not the easiest way; you only need to choose it if you already have a working servlet container or application server. </li><li>  Use <strong>Spring Boot</strong> magic.  A JAR file compiled using the Spring Boot plugin (which is automatically added to projects created through Spring Initializr) is completely self-contained. </li></ol><br><p>  Thus, building and running the application looks like: </p><br><ol><li> <code>./mvnw package</code> </li> <li> <code>java -jar ./target/demo-0.0.1-SNAPSHOT.jar</code> </li> </ol><br><p>  Deploying this JAR file does not require anything other than installed Java (JRE).  This is the so-called <em>fat JAR</em> - it includes the built-in servlet container (Tomcat by default) and the framework, and all the dependency libraries.  In fact, it is the only deployment artifact - it can simply be copied to the target server and run there. </p><br><p>  Moreover, the file can be made <em>"executable"</em> and run it simply from the command line (Java, of course, is still needed). </p><br><p>  On the basis of this file, you can easily create a Docker image or install it as a daemon.  More details are available in the <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment-install.html">official documentation</a> . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  It turned out, nevertheless, very concisely - but to put even the simplest introductory course on Spring into the framework of one article is not very simple.  I hope this helps someone to take the first steps in Spring, and at least understand their fundamental concepts. </p><br><p>  As you have noticed, the word "Magic Spring" sounded many times in the text of the article.  In essence, this is a very "magical" framework - even having looked at the very tip of the iceberg, we have already seen that Spring does a lot of things in the background.  This is both a plus and a minus of the framework.  Plus, undoubtedly, many <em>complex</em> things (very many) can be made with one annotation or dependence.  The minus is the hidden complexity - to solve some difficult problems, to make the framework work in extreme cases or understand all the subtleties and aspects you need to know it well. </p><br><p>  To make the ‚Äúknow‚Äù stage as easy as possible, Spring has excellent documentation, a huge community, and clean sources that can be read.  If you place Spring on the Rich Hickey scale, it (Spring) will undoubtedly fall into easy, but certainly not simple.  But for a modern enterprise (and not just an enterprise), it provides incredible opportunities to get a production-ready application very quickly and focus on the logic of the application, rather than the infrastructure around it. </p><br><h1 id="ssylki">  Links </h1><br><ul><li>  Github source code </li><li>  Spring main site with a bunch of different spring.io <a href="https://spring.io/guides">guides</a> </li><li>  Spring Framework Official <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Documentation</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/333756/">https://habr.com/ru/post/333756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333746/index.html">How to please the viewer and not lose money: make up a procurement plan with the help of ML</a></li>
<li><a href="../333748/index.html">ICO: Basic Jurisdictions and Issues</a></li>
<li><a href="../333750/index.html">VAX - a tool for visual programming, or how to write SQL with a mouse</a></li>
<li><a href="../333752/index.html">World markets: how to succeed in India and Brazil</a></li>
<li><a href="../333754/index.html">Critical vulnerability in multityg Parity wallet, hackers withdrew $ 31 million in ethereum (updated)</a></li>
<li><a href="../333762/index.html">Automatic creation of Liquibase migrations for PostgreSQL</a></li>
<li><a href="../333766/index.html">Fast data recovery. Regeneration butterfly pattern</a></li>
<li><a href="../333768/index.html">Automation IP-network. Part 3 - Monitoring TCP Anomalies</a></li>
<li><a href="../333772/index.html">We copy the human brain: operation "Convolution"</a></li>
<li><a href="../333774/index.html">How to work with UX contractors? Experience messenger "Answer"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>