<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book Algorithms and Data Structures. Extracting Java Information</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Learn how to implement efficient algorithms based on the most important data structures in Java, and how to measure the performance of these...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book Algorithms and Data Structures. Extracting Java Information</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habr.com/company/piter/blog/419503/"><img src="https://habrastorage.org/webt/ul/ci/2m/ulci2miltdytubvrcl0sem1gltk.jpeg" align="left" alt="image"></a>  Hi, Habr!  Learn how to implement efficient algorithms based on the most important data structures in Java, and how to measure the performance of these algorithms.  Each chapter is accompanied by exercises that help to consolidate the material. <br><br><ul><li>  Learn how to work with data structures, such as lists and dictionaries, understand how they work. </li><li>  Write an application that reads Wikipedia pages, parses and navigates through the resulting data tree. </li><li>  Analyze the code and learn how to predict how fast it will work and how much memory to consume. </li><li>  Write classes that implement the Map interface, use the hash table and binary search tree. </li><li>  Create a simple web search engine with your own search robot: it will index the web pages, save their contents and return the desired results. </li></ul><a name="habracut"></a><br><h3>  Excerpt "Walk the tree" </h3><br>  In this chapter, we will look at a search engine application that we will develop throughout the remainder of the book.  I (the author) describe the elements of a search engine and present the first application, a search robot, that loads and analyzes pages from Wikipedia.  This chapter also presents a recursive implementation of the depth search and an iterative implementation that uses Deque from Java to implement the ‚Äúlast entered, first out‚Äù stack. <br><br><h3>  Search engines </h3><br>  A search engine such as Google Search or Bing takes a set of search terms and returns a list of web pages that are relevant to these terms.  On <a href="http://thinkdast.com/searcheng">thinkdast.com</a> you can read more, but I will explain what you need as you progress. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider the main components of a search engine. <br><br><ul><li>  Crawling data.  You need a program that can load a web page, analyze it and extract text and any links to other pages. </li><li>  Indexing.  We need an index that will allow you to find a search query and the pages containing it. </li><li>  Search (retrieval).  A way to collect results from an index and identify pages that are most relevant to search terms is needed. </li></ul><br>  Let's start with the search robot.  Its purpose is to detect and download a collection of web pages.  For search engines such as Google and Bing, the challenge is to find all the web pages, but often these robots are limited to a smaller domain.  In our case, we will only read pages from Wikipedia. <br><br>  As a first step, we will create a search robot that reads the Wikipedia page, finds the first link, navigates to another page, and repeats the previous steps.  We will use this search engine to test the Getting to Philosophy hypothesis (‚ÄúPath to Philosophy‚Äù).  It says: <br><br><blockquote>  ‚ÄúClicking on the first link in lower case, in the main text of the Wikipedia article and then repeating this action for subsequent articles, you will most likely be taken to the page with the article on philosophy.‚Äù <br></blockquote><br>  You can <a href="http://thinkdast.com/getphil">view</a> this hypothesis and its history at <a href="http://thinkdast.com/getphil">thinkdast.com/getphil</a> . <br>  Testing the hypothesis will allow you to create the main parts of the search robot, without needing to bypass the entire Internet or even the entire Wikipedia.  And I think this exercise is quite interesting! <br><br>  In several chapters we will work on an indexer, and then proceed to the search engine. <br><br><h3>  HTML parsing </h3><br>  When you load a webpage, its content is written in HyperText Markup Language (HTML).  For example, the following is the simplest HTML document: <br><br><pre><code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>This is a title<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello world!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  The phrases This is a title (‚ÄúThis is the title‚Äù) and Hello world!  ("Hello world!") - text that is actually displayed on the page;  other elements are tags indicating how the text should be displayed. <br><br>  When loading the page, our robot needs to analyze the HTML code in order to extract text and find links.  To do this, we will use jsoup, an open source Java library for loading and parsing (parsing) HTML. <br>  The result of HTML parsing is a DOM (Document Object Model) tree containing document elements, including text and tags. <br><br>  A tree is a related data structure consisting of vertices that represent text, tags, and other document elements. <br><br>  The relationship between the vertices is determined by the structure of the document.  In the previous example, the first node, called the root, is a tag that includes references to the two vertices it contains and;  these nodes are children of the root node. <br><br>  A node has one child node and a node has one child node. <p>  (paragraph, from the English. paragraph).  In fig.  6.1 presents a graphic image of the tree. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/r7/07/uu/r707uude4_ixfv0kd4laaafp9zu.png" alt="image"></div><br>  Each vertex includes links to its child nodes;  In addition, each node contains a link to its parent, so you can move up and down the tree from any node.  A DOM tree for real pages is usually more complicated than the example described. <br><br>  Most browsers have tools for checking the DOM of the page you are viewing.  In Chrome, you can right-click on any part of the webpage and select View Code from the menu that appears.  In Firefox, you can right-click and select Explore item from the context menu.  Safari provides a Web Inspector tool, which is located on the site <a href="http://thinkdast.com/safari">thinkdast.com/safari</a> .  Instructions for Internet Explorer can be found by clicking on the link: <a href="http://thinkdast.com/explorer">thinkdast.com/explorer</a> . <br><br>  In fig.  6.2 shows a screenshot showing a DOM tree for the Wikipedia page on <a href="http://thinkdast.com/java">Java</a> .  The selected element is the first paragraph of the main text of the article, which is contained in the &lt;div&gt; element with id = "mw-content-text".  We will use this item identifier to determine the main text of each article we download. <br><br><h3>  Jsoup application </h3><br>  The jsoup library makes it easy to load and analyze web pages and navigate the DOM tree.  For example: <br><br><pre> <code class="hljs pgsql">String url = "http://en.wikipedia.org/wiki/Java_(programming_language)"; //     <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span> conn = Jsoup.<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(url); Document doc = conn.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); //         Element content = doc.getElementById("mw-content-text"); Elements paragraphs = content.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>("p");</code> </pre> <br>  The Jsoup.connect element accepts a URL as a string and establishes a connection to a web server;  The get method loads HTML code, parses it, and returns a Document object, which is a DOM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/ez/xu/gbezxuae9aggcurdydsoilnshpo.png" alt="image"></div><br>  This object includes methods for navigating the tree and selecting nodes.  In fact, it provides so many methods that it can be confusing.  The following example demonstrates two ways to select nodes. <br><br><ul><li>  getElementByld accepts a string type parameter and searches for a tree for an element with the corresponding id field.  When he finds it, he chooses a node &lt;div id = "mw-content-text" lang = "en" dir = "ltr" class = "mw-content-ltr"&gt; that appears on every Wikipedia page to identify the element &lt;div&gt; containing the main text of the page, unlike the side navigation bar and other elements. </li><li>  select accepts a String, traverses the tree, and returns all elements with tags matching the String.  In this example, it returns all the paragraph tags that appear in the content.  The return value is an object of type Elements. </li></ul><br>  Before proceeding, you must review the documentation for these classes to know what actions they can perform.  The most important classes are Element, Elements and Node, which you can read about by clicking on the links <a href="http://thinkdast.com/jsoupelt">thinkdast.com/jsoupelt</a> , <a href="http://thinkdast.com/jsoupelts">thinkdast.com/jsoupelts</a> and <a href="http://thinkdast.com/jsoupnode">thinkdast.com/jsoupnode</a> . <br><br>  The Node class is a vertex in the DOM tree.  There are several subclasses that extend Node, including Element, TextNode, DataNode, and Comment.  The Elements class is a collection of Element type objects. <br><br>  In fig.  Figure 6.3 is a UML class diagram showing the relationships between them.  A line with an empty arrow indicates the expansion of one class to another.  For example, this diagram indicates that Elements extends an ArrayList.  We will return to the UML class diagrams in the section of chapter 11 of the same name. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/29/ys/p_/29ysp__8jqplpznbyty3y6mqmgi.png" alt="image"></div><br><h3>  DOM iteration </h3><br>  In order to make life easier for you, I provide a WikiNodelterable class that allows you to walk through the DOM tree.  Below is an example that shows how to use this class: <br><br><pre> <code class="hljs pgsql">Elements paragraphs = content.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>("p"); Element firstPara = paragraphs.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); Iterable&lt;Node&gt; iter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> WikiNodeIterable(firstPara); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node node: iter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(node); } }</code> </pre> <br>  This example starts from the point at which the previous one stopped.  It selects the first paragraph in paragraphs and then creates a WikiNodeIterable class that implements the Iterable interface.  This class performs a depth search, creating nodes in the order in which they appear on the page. <br><br>  In the current example, we display the Node only if it is a TextNode, and ignore its other types, in particular, objects of type Element that represent tags.  The result is simple HTML paragraph text without any markup.  His conclusion: <br><br><blockquote>  Java is a concurrent, class-based, object-oriented, [13] and specifically designed ... <br><br>  Java is a universal computer programming language that is an object-oriented language based on classes, with the possibility of parallel programming [13] and specially designed ... </blockquote><br><h3>  Depth search </h3><br>  There are several ways to intelligently traverse a tree.  We start with depth search (depth-first search, DFS).  The search starts from the root of the tree and selects the first child node.  If the latter has children, then the first child node is selected again.  When a peak without children comes across, you need to return, moving up the tree to the parent node, where the next child is selected, if there is one.  Otherwise, you need to return again.  When the last child of the root is examined, the traversal is completed. <br><br>  There are two generally accepted ways to implement depth-first search: recursive and iterative.  Recursive implementation is simple and elegant: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursiveDFS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Node node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { System.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(node); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node child: node.childNodes()) { recursiveDFS(child); } }</code> </pre> <br>  This method is called for each Node in the tree, starting from the root.  If the Node is a TextNode, then its contents are printed.  If Node has children, it calls the recursiveDFS for each of them in order. <br><br>  In the current example, we print the contents of each TextNode before visiting its child nodes, that is, it is an example of a direct (pre-order) walk.  You can read about direct, reverse (post-order) and symmetrical (in-order) traversal by clicking on the link <a href="http://thinkdast.com/treetrav">thinkdast.com/treetrav</a> .  The traversal order does not matter for this application. <br><br>  When performing recursive calls, recursiveDFS uses a call stack (see <a href="http://thinkdast.com/callstack">thinkdast.com/callstack</a> ) to track the child vertices and process them in the correct order.  Alternatively, you can use the stack data structure to track the nodes yourself;  this will avoid recursion and iterate around the tree. <br><br><h3>  Java stacks </h3><br>  Before explaining the iterative version of the depth search, I‚Äôll look at the stack data structure.  We begin with a general stack concept, and then talk about two Java interfaces that define stack methods: Stack and Deque. <br><br>  A stack is a list-like data structure: a collection that maintains the order of the elements.  The main difference between the stack and the list is that the first includes fewer methods.  By convention, the stack provides methods: <br><br><ul><li>  push, which adds an element to the top of the stack; </li><li>  pop, which deletes and returns the value of the topmost item in the stack; </li><li>  peek, which returns the topmost element of the stack without changing the stack itself; </li><li>  isEmpty, which indicates whether the stack is empty. </li></ul><br>  Since pop always returns the topmost element, the stack is also called LIFO, which means ‚Äúlast entered, first out‚Äù (last in, first out).  An alternative to a stack is a queue that returns items in the same order in which they were added, that is, ‚Äúfirst in, first out,‚Äù or FIFO. <br><br>  At first glance, it is not clear why stacks and queues are useful: they do not provide any special features that could not be obtained from the lists;  in fact, they have even fewer opportunities.  So why not always use lists?  There are two reasons justifying the use of stacks and queues. <br><br>  1. If you limit yourself to a small set of methods (that is, a small API), then your code will be more readable and less error prone.  For example, when using a list to represent a stack, you can accidentally delete an item in the wrong order.  With the stack API, this error is literally impossible.  And the best way to avoid mistakes is to make them impossible. <br><br>  2. If the data structure provides a small API, then it is easier to implement effectively.  For example, a simple way to implement a stack is a single list.  Pushing an element onto the stack, we add it to the top of the list;  pushing an element, we remove it from the very beginning.  For a linked list, adding and removing from the beginning are operations of constant time, therefore this implementation is effective.  Conversely, larger APIs are more difficult to implement effectively. <br><br>  Implement the stack in Java in three ways. <br><br>  1. Apply ArrayList or LinkedList.  When using an ArrayList, you need to remember to add and remove from the end so that these operations are performed in constant time.  You should avoid adding items to the wrong place or removing them in the wrong order. <br><br>  2. Java has a Stack class that provides a standard set of stack methods.  But this class is the old part of Java: it is incompatible with the Java Collections Framework, which appeared later. <br><br>  3. Probably the best choice is to use one of the implementations of the Deque interface, for example, ArrayDeque. <br><br>  Deque is derived from double-ended queue, which means "two-way queue."  In Java, Deque provides push, pop, peek, and isEmpty methods, so you can use it as a stack.  It contains other methods that are available on <a href="http://thinkdast.com/deque">thinkdast.com/deque</a> , but for now we will not use them. <br><br><h3>  Iterative depth search </h3><br>  The following is an iterative version of DFS, using ArrayDeque to represent a stack of Node objects: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterativeDFS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ Deque&lt;Node&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;Node&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(root); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.isEmpty()) { Node node = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { System.out.print(node); } List&lt;Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Node&gt;(node. chiidNodesQ); Collections.reverse(nodes); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node child: nodes) { <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(chiid); } } }</code> </pre> <br>  The root parameter is the root of the tree that we want to go around, so we start by creating a stack and adding this parameter to it. <br><br>  The cycle continues until the stack is empty.  On each pass, a Node is pushed out of the stack.  If TextNode is received, its contents are printed.  Then the child vertices are added to the stack.  To process descendants in the correct order, you need to push them onto the stack in the reverse order;  this is done by copying the child vertices in an ArrayList, rearranging the elements in place, and then iterating the reversed ArrayList. <br>  One of the advantages of an iterative version of depth search is that it is easier to implement it as an Iterator in Java;  how to do this is described in the next chapter. <br><br>  But first, a final note about the Deque interface: in addition to ArrayDeque, Java provides another implementation of Deque, our old friend LinkedList.  The latter implements both interfaces: List and Deque.  The resulting interface depends on its use.  For example, when assigning a LinkedList object to a Deque variable: <br><br><pre> <code class="hljs xml">Deqeue<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  You can apply methods from the Deque interface, but not all methods from the List interface.  Assigning it to a List variable: <br><br><pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  List methods can be used, but not all Deque methods.  And assigning them as follows: <br><br><pre> <code class="hljs xml">LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  all methods can be used.  But when combining methods from different interfaces, the code will be less readable and more error prone. <br><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/new/product/algoritmy-i-struktury-dannyh-izvlechenie-informatsii-na-yazyke-java">the publisher site.</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610572/978544610572_X.pdf">Table of Contents</a> <br>  ¬ª <a href="https://storage.piter.com/upload/contents/978544610572/978544610572_p.pdf">Excerpt</a> <br><br>  For Habrozhiteley a 20% discount on coupon - <b>Java</b> </div><p>Source: <a href="https://habr.com/ru/post/419503/">https://habr.com/ru/post/419503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419489/index.html">Trailer? Electric car? Needed! If it's with batteries</a></li>
<li><a href="../419491/index.html">STP operation principle</a></li>
<li><a href="../419495/index.html">Who "invented" bone conduction, why it is used and how it is safe for hearing</a></li>
<li><a href="../419497/index.html">Review of a large Hercules Strong 3D printer</a></li>
<li><a href="../419501/index.html">Deep Learning: Recognizing Scenes and Points of Interest in Images</a></li>
<li><a href="../419505/index.html">Receive parcels without notifications and passports can now be by mail across the country</a></li>
<li><a href="../419507/index.html">Overview of the Russian 3D-printer PICASO 3D Designer X from 3Dtool</a></li>
<li><a href="../419509/index.html">Photon Artificial Neural Network</a></li>
<li><a href="../419511/index.html">typeof (T) vs. TypeOf‚ü®T‚ü©</a></li>
<li><a href="../419513/index.html">Setting a password security policy in Zimbra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>