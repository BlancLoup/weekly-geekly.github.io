<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2D Collision Handling Using LibCanvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In most modern games, it is impossible to do without detecting and further processing collisions (shot, jump, banal rebound from an obstacle). At firs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2D Collision Handling Using LibCanvas</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/9079d13d/43c43308/dbc8d5ea/f22927d8.png"><br>  In most modern games, it is impossible to do without detecting and further processing collisions (shot, jump, banal rebound from an obstacle).  At first glance, their implementation seems quite simple, but is it really so?  I will try to briefly explain the essence of the problems that I encountered. <br>  By tradition, after reading a few articles, you begin to feel like a god, capable of doing anything.  I think many people have encountered a similar problem and can imagine what follows it ... correctly, a series of big problems.  But first things first. <br><a name="habracut"></a><br><h4>  Preparation of the "landscape" </h4><br>  So where to start?  It seems to me that it is best to start with static objects, because it is much easier to work with them (no need to worry about redrawing, changing position / shape and other things). <br><blockquote><code><font color="black"><font color="#0000ff">var</font> background = <font color="#0000ff">new</font> LibCanvas( <font color="#A31515">'#canv'</font> ) .size(512, 512).start(); <font color="#008000">//  LibCanvas</font> <br> background.createShaper({ <font color="#008000">//     </font> <br> shape : shape, <br> stroke: <font color="#A31515">'#00f'</font> , <br> fill : <font color="#A31515">'#004'</font> <br> });</font></code> </blockquote>  that's all, the background is complete.  Ideally, we should not touch him anymore. <br><br><h4>  Creating an object concept </h4><br>  Then you can consider, in fact, the ‚Äúobject‚Äù <i>(that which moves along the canvas and will bounce off obstacles)</i> .  I believe that the consideration of the object should start from the end, namely, from what it should be able to do in the end. <br>  Everyone will have their own list, but for me it looks like this: <br><ol><li>  the object must know its position and size </li><li>  the object must know the direction and speed of its movement </li><li>  the object must know how it looks </li><li>  the object must be able to be printed on the canvas, as well as ‚Äúreprinted‚Äù (removed from one place and appear in another) </li><li>  the object must be able to define collisions with the edges of the canvas </li><li>  the object must be able to identify and handle collisions with obstacles </li></ol>  With the list of "possibilities" of the object, we are now more or less familiar.  We start implementation. <br><br><h4>  Object implementation </h4><br>  First, we need to create a separate layer for the objects being moved <i>(so as not to redraw other layers each time, for example, background)</i> : <br><blockquote> <code><font color="black"><font color="#0000ff">var</font> cont = background.createLayer( <font color="#A31515">'cont'</font> );</font></code> </blockquote> <br>  Now it is necessary to place an object on this layer, which will be defined as follows: <br><blockquote> <code><font color="black"><font color="#0000ff">var</font> <font color="#0000ff">object</font> = { <br> center: {x, y}, <font color="#008000">//  </font> <br> speed: {x, y}, <font color="#008000">// </font> <br> size, <font color="#008000">//  </font> <br> buffer, <font color="#008000">//   </font> <br> redrawBuffer(), <font color="#008000">// ,   object.buffer</font> <br> print(), <font color="#008000">//      </font> <br> redraw(), <font color="#008000">//        </font> <br> animate(), <font color="#008000">//     </font> <br> findBounce() <font color="#008000">//      </font> <br> };</font></code> </blockquote> <br>  The following question arises: how to fill the attributes of this object?  Let's go in order. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Center, speed and size </h5><br>  Let us catch 2 clicks on the canvas - the coordinates of the first are the center of the object, and using the coordinates of the second, it will be easy to calculate the components 'x' and 'y' of the velocity of the object. <br>  No sooner said than done.  We implement: <br><blockquote> <code><font color="black">cont.listenMouse(); <font color="#008000">//  ‚Äú‚Äù </font> <br> <font color="#0000ff">var</font> mouse = cont.mouse; <br> <font color="#0000ff">var</font> flag = <font color="#0000ff">false</font> ; <font color="#008000">//     ‚Äì   </font> <br> mouse.addEvent( <font color="#A31515">'mousedown'</font> , <font color="#0000ff">function</font> () { <br> flag = !flag; <br> }); <br> <br> cont.addRender( <font color="#0000ff">function</font> () { <br> <font color="#0000ff">if</font> (mouse.inCanvas) { <br> <font color="#0000ff">if</font> (flag) { <br> <font color="#0000ff">object</font> .size = size; <font color="#008000">//   </font> <br> <font color="#0000ff">object</font> .center.center.moveTo( mouse.point ); <br> <font color="#0000ff">object</font> .speed.x = 0; <font color="#008000">//      </font> <br> <font color="#0000ff">object</font> .speed.y = 0; <br> } <br> <font color="#0000ff">else</font> { <font color="#008000">//   </font> <br> <font color="#0000ff">object</font> .speed.x = mouse.point.x ‚Äì <font color="#0000ff">object</font> .center.x; <font color="#008000">//      </font> <br> <font color="#0000ff">object</font> .speed.y = mouse.point.y - <font color="#0000ff">object</font> .center.y; <br> } <br> } <br> });</font></code> </blockquote> <br>  So, let's go further. <br><br><h5>  What is object.buffer, object.redrawBuffer, object.redraw and why are they actually needed? </h5><br>  A bit of theory - when you call the <b>cont.update ()</b> function, a request for redrawing is sent to the next rendering stage <i>(if you synchronously call ‚Äúupdate‚Äù five times in a row, the redraw will be done only once - when the next frame is rendered)</i> .  But, anyway, the whole canvas will be redrawn, which is rather inefficient <i>(a bit of math: canvas (512 * 512) = 262144 points, object size - even 50 * 50 = 2500 points, which is about 10 times smaller than the entire canvas )</i> . <br>  Since we will move our object, which means redrawing the canvas many times, it will be much more efficient to just cut the image from one place and paste it into another.  This is the easiest way, for those who do not want to think, but want to solve problems right in the forehead.  The following option is much more interesting, at least for me: we do not cut an image of an object from the canvas and save it to the buffer with each move, but have two functions - <b>redrawBuffer ()</b> and <b>redraw (fromX, fromY, toX, toY)</b> .  In case of changing the type of object, the first one is suitable: redrawBuffer (), which changes the contents of the buffer.  To move, you can use the redraw function (fromX, fromY, toX, toY), which ‚Äúcleans‚Äù the space under the object in the ‚Äúold‚Äù space and inserts the image from the buffer into the ‚Äúnew‚Äù: <br><blockquote> <code><font color="black">redraw: <font color="#0000ff">function</font> (canvas, beforeX, beforeY, afterX, afterY) { <br> <font color="#0000ff">var</font> <font color="#0000ff">params</font> = { <br> fromX: (beforeX - <font color="#0000ff">this</font> .size), <br> fromY: (beforeY - <font color="#0000ff">this</font> .size), <br> size: ( <font color="#0000ff">this</font> .size*2), <br> toX:  (afterX - <font color="#0000ff">this</font> .size), <br> toY:  (afterY - <font color="#0000ff">this</font> .size) <br> } <br> canvas.ctx.clearRect( <font color="#0000ff">params</font> .fromX - 1, <font color="#0000ff">params</font> .fromY - 1, <font color="#0000ff">params</font> .size + 2, <font color="#0000ff">params</font> .size + 2); <br> canvas.ctx.drawImage( <font color="#0000ff">this</font> .buffer, <font color="#0000ff">params</font> .toX, <font color="#0000ff">params</font> .toY); <br> }</font></code> </blockquote> <br><h5>  Object reaction to collisions with canvas borders </h5><br>  This is realized to the horror simply - if the object has reached the top or bottom edge, then: <br><blockquote> <code><font color="black"><font color="#0000ff">object</font> .speed.y = - <font color="#0000ff">object</font> .speed.y;</font></code> </blockquote> <br>  if right or left: <br><blockquote> <code><font color="black"><font color="#0000ff">object</font> .speed.x = - <font color="#0000ff">object</font> .speed.x;</font></code> </blockquote> <br><h5>  Identify and handle obstacles </h5><br>  How to understand where an object should bounce after a collision with an obstacle of arbitrary shape?  The answer to this question can be given by old school textbooks with a physics / geometry course - ‚Äúthe angle of incidence is equal to the angle of reflection‚Äù.  Since physics and geometry can remember not everything, I think it is worth recalling that these angles are counted from the normal (perpendicular) to the surface at the point: <br><img src="https://habrastorage.org/storage1/c994545f/b9006fbd/08e257b7/aeba1b69.gif"><br>  <i>Here, 'H' and 'G' are normals.</i>  <i>'A' and 'D' are the speeds before the collision.</i>  <i>'C' and 'F' - speeds after a collision.</i> <br><br>  But, as is often the case, in words everything is quite simple, but in practice, alas, no. <br>  So, let's start with a fairly general algorithm: <br><ol><li>  Move the object until it encounters an obstacle </li><li>  Find the normal </li><li>  Change speed </li><li>  Returning to p.1 </li></ol>  Let's start to sort this algorithm on points: <br><br><h6>  Move the object until it encounters an obstacle </h6><br>  With the movement, everything is simple: we draw an object, change the position of its center, erase the old one, draw a new one ‚Äî that's all the movement.  But how to understand that two objects (object and background) collided?  For this I want to remind that now the canvas canvas consists of two layers <i>(‚Äúbackground‚Äù - static and ‚Äúobject‚Äù - dynamic)</i> , and we need to understand that 2 objects intersected (or just touched).  After reading <a href="http://bitbybit.ru/tutorial/JavaScript/lesson/219/">this</a> article, I more or less imagined the algorithm for finding the intersection: <br><ol><li>  get the image of the layer with the object and the image of the layer with an obstacle </li><li>  recall that: ‚Äú <i>Pixels are stored in objects of type ImageData.</i>  <i>Each object has three properties: width, height, and data.</i>  <i>The data property is of type CanvasPixelArray and contains an array of elements of width * height * 4 bytes in size;</i>  <i>that means each pixel contains an RGBA color. ‚Äù</i> </li><li>  we write a simple cycle in which there is only one condition </li></ol><blockquote> <code><font color="black"><font color="#0000ff">var</font> pixels1 = background.ctx.getImageData( x,y,size,size); <br> <font color="#0000ff">var</font> pixels2 = cont.ctx.getImageData( x,y,size,size); <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0; i &lt; pixels2.length; i += 4 ) { <br> <font color="#0000ff">if</font> ((pixels1[i+3] != 0) &amp;&amp; (pixels2[i+3] != 0)) { <br> <font color="#008000">/*   */</font> <br> <font color="#0000ff">break</font> ; <br> } <br> }</font></code> </blockquote> <br>  At this stage, I would again advise to ask about efficiency - is it worth it to run 2 * 512 * 512 pixels with each object movement?  Of course not.  You can, without any consequences, reduce the ‚Äúsearch zone‚Äù to a square in which you can fit an object <i>(of course, if the object to be moved is only one)</i> .  But is it possible to reduce this area even more, say, to 1 pixel?  Yes you can.  But this further ‚Äúreduction‚Äù will affect the accuracy of finding the collision.  As an example, I will give a picture where the green circle is an object, and the blue bar is an obstacle: <br><img src="https://habrastorage.org/storage1/0a5449d7/b2af5aac/13cf95d7/544096fa.png"><br>  If for calculation we took the ‚Äúsearch zone‚Äù equal to (object.size * 2) * (object.size * 2) <i>(object.size is the radius)</i> , then a collision would be set, but if only 1 pixel was selected for the calculation (center ), then the collision is not defined. <br>  How to do to you is a purely personal matter, but I decided to sacrifice accuracy and began working with the center of the object. <br>  The collision is established, but what next?  How to deal with the scary word ‚Äúnormal‚Äù? <br><br><h6>  Find the normal </h6><br>  There are two ways - right and mine. <br>  <b>Method 1. Correct:</b> <ol><li>  find the ‚Äúzone‚Äù of touch </li><li>  find the boundary point of the obstacle from this zone </li><li>  interpolate them and find the normal equation at the tangency point </li></ol><img src="https://habrastorage.org/storage1/e884e412/b90cc855/0c195816/f55e4dd0.png"><br><br>  <b>Method 2: Incorrect:</b> <ol><li>  get the zone of intersection of the object and obstacles. </li><li>  find the center of this zone: <br><blockquote> <code><font color="black"><font color="#0000ff">var</font> avgPoint{x:0, y:0, number:0}; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">var</font> i = 0; i &lt; pixels2.length; i += 4 ) { <br> <font color="#0000ff">if</font> ((pixels1[i+3] != 0) &amp;&amp; (pixels2[i+3] != 0)) { <br> avgPoint.x += (i/4)%( <font color="#0000ff">this</font> .size*2); <br> avgPoint.x += Math.round((i/4)/( <font color="#0000ff">this</font> .size*2)); <br> } <br> } <br> avgPoint.x = Math.round((avgPoint.x / avgPoint.number) + <font color="#0000ff">this</font> .center.x - <font color="#0000ff">this</font> .size); <br> avgPoint.y = Math.round((avgPoint.y / avgPoint.number) + <font color="#0000ff">this</font> .center.y - <font color="#0000ff">this</font> .size);</font></code> </blockquote> </li><li>  connect the found center of the ‚Äúintersection zone‚Äù (avgPoint.x, avgPoint.y) with the center of the object.  This will be normal. </li></ol><img src="https://habrastorage.org/storage1/bb552541/7fa10fe2/503a11c8/e83ca2bb.png"><br><br><h6>  Change speed </h6><br>  So, open the textbooks again and find out that upon reflection the normal component of the velocity changes sign, and the tangential (perpendicular normal) remains unchanged. <br>  Therefore, we have the task of decomposing the velocities from the (x, y) coordinate system into (n, t) coordinate system.  Here comes the usual geometry from the upper classes: <br><blockquote> <code><font color="black"><font color="#0000ff">var</font> hyp = Math.hypotenuse((avgPoint.y - <font color="#0000ff">object</font> .center.y),(avgPoint.x - <font color="#0000ff">object</font> .center.x)) <br> <font color="#0000ff">var</font> sinNA = (avgPoint.y ‚Äì <font color="#0000ff">object</font> .center.y)/hyp; <br> <font color="#0000ff">var</font> cosNA = ( <font color="#0000ff">object</font> .center.x - avgPoint.x)/hyp; <br> <font color="#0000ff">var</font> nSpeed = <font color="#0000ff">this</font> .speed.x * cosNA - <font color="#0000ff">this</font> .speed.y * sinNA; <br> <font color="#0000ff">var</font> tSpeed = <font color="#0000ff">this</font> .speed.x * sinNA + <font color="#0000ff">this</font> .speed.y * cosNA; <br> nSpeed = -nSpeed; <br> <font color="#0000ff">object</font> .speed.x = (tSpeed * sinNA + nSpeed * cosNA); <br> <font color="#0000ff">object</font> .speed.y = (tSpeed * cosNA - nSpeed * sinNA);</font></code> </blockquote> <br><br>  That's all, our object is able to change the directions of speeds depending on the form of the encountered obstacle.  It remains to combine all the functions and objects in the final script and see <br>  <a href="http://aloner.github.com/canvas/bouncing/">the result</a> . <br>  At this my article is finished, thank you for your attention! </div><p>Source: <a href="https://habr.com/ru/post/124869/">https://habr.com/ru/post/124869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124861/index.html">Working with the mind, not with your hands: an example of increased text editing performance in Emacs</a></li>
<li><a href="../124863/index.html">Collecting network equipment configuration and storing them in SVN</a></li>
<li><a href="../124864/index.html">Apache HTTP Server: Serving Multiple HTTPS Hosts on the Same IP Address</a></li>
<li><a href="../124866/index.html">Saving the "broken" portable hard drive with a TrueCrypt-container</a></li>
<li><a href="../124867/index.html">Firefox 6 will support a number of properties from the draft CSS3 Text module</a></li>
<li><a href="../124871/index.html">Task complexity assessment</a></li>
<li><a href="../124872/index.html">Neighbors - will the IM + geosocial network take off?</a></li>
<li><a href="../124873/index.html">OpenCL under C # is easy</a></li>
<li><a href="../124874/index.html">Premiere! Droider Show - video cassette about mobile technologies and gadgets</a></li>
<li><a href="../124875/index.html">OOP wrapper for PHP lib_curl</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>