<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pseudo-toning of images: eleven algorithms and sources</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pseudotoning: Review 

 About today's theme for programming graphics - pseudo-tinting (dithering, pseudo-mixing colors) - I get a lot of letters, whic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pseudo-toning of images: eleven algorithms and sources</h1><div class="post__text post__text-html js-mediator-article"><h3>  Pseudotoning: Review </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b47/09d/6dc/b4709d6dc9394296bf47d22907e6eaaa.png"></div><br>  About today's theme for programming graphics - pseudo-tinting (dithering, pseudo-mixing colors) - I get a lot of letters, which may seem surprising.  You might think that pseudo-toning is not something that programmers should do in 2012.  Is pseudo-mixing not an artifact of technology history, an archaism of times, when a display with 16 million colors for programmers and users could only dream about?  Why am I writing an article about pseudo-toning in an era when cheap mobile phones work with the brilliance of 32-bit graphics? <br><br>  In fact, pseudo-toning is still a unique method, not only for practical reasons (for example, preparing a full-color image for printing on a black-and-white printer), but also for an artistic one.  Dithering is also used in web design, where this useful method is used to reduce the number of colors in an image, which reduces file size (and traffic) without sacrificing quality.  It is also used when reducing digital photos in the RAW format to 48 or 64 bits per pixel to RGB to 24 bits per pixel for editing. <br><br>  And these are applications only in the field of images.  In sound, dithering also plays a key role, but I'm afraid I will not discuss dithering audio here.  Only psevdotonirovaniya images. <br><a name="habracut"></a><br>  In this article I am going to focus on three points: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Highlights of image dithering </li><li>  Eleven specific two-dimensional dithering formulas, including the well-known level of the Floyd-Steinberg algorithm. </li><li>  How to write a general purpose pseudo-mixing engine </li></ul><br><h3>  Pseudotoning: examples </h3><br>  Consider the following full-color image, wallpaper with the famous <a href="https://theportalwiki.com/wiki/Weighted_Companion_Cube/ru">Companion Cube</a> from the <a href="https://ru.wikipedia.org/wiki/Portal">Portal</a> game: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ac2/ca1/3a5/ac2ca13a5d9f4ef6bf22722b9417634e.jpg"></div><br>  <font color="gray">This picture will be the test image for this article.</font>  <font color="gray">I chose her because she has great combinations of soft gradients and hard edges.</font> <br><br>  On a modern LCD or LED display - whether it be a computer monitor, smartphone or TV - this full-color image can be output without problems.  But let's imagine a PC with more support for a limited color palette.  If we try to display our image on such a PC, it might look something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/726/7fe/3af/7267fe3afae640669921212ebc2a8b96.png"></div><br>  <font color="gray">This is the same image as above, but limited to a web palette of safe colors.</font> <br><br>  Pretty nasty, isn't it?  Consider an even more vivid example in which we want to print an image of a cube on a black and white printer.  Then we get something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a6f/4b4/8cc/a6f4b48cc10d4473a8dfdadb302b78f7.png"></div><br>  <font color="gray">Here the image is barely recognizable.</font> <br><br>  Problems arise every time an image is displayed on a device that supports fewer colors than the image contains.  Subtle gradients in the original image may be replaced by patches of uniform color, and depending on the limitations of the device, the original image may become unrecognizable. <br><br>  Pseudotoning (or dithering) is an attempt to solve this problem.  Psevdotonirovanie works through the approximate expression of inaccessible colors available, for which available colors are mixed so as to simulate inaccessible.  As an example, here is an image of a cube, again degraded to the colors of an imaginary old PC, only this time pseudo-toning is applied: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/28b/81b/3a3/28b81b3a3c454151a362196896d5b2bd.png"></div><br>  <font color="gray">Much better than the non-pseudo-toning version!</font> <br><br>  If you look closely, you will see that this image uses the same colors as its copy without pseudo-toning.  But these few colors are arranged so that it seems as if there are many other colors. <br><br>  As another example: here is a black and white version of our image with similar pseudo-toning: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1e5/6cf/74c/1e56cf74cb3743148729d1f419f7640e.png"></div><br>  <font color="gray">Specifically, pseudo-toning using the Sierra two-row algorithm (2-row Sierra) is applied here.</font> <br><br>  Despite the presence of only black and white colors, we can still discern the shape of the cube down to the hearts on both sides.  Dithering is an extremely powerful method and can be used in ANY situation where the data must be presented at a lower resolution than the one for which it was created.  This article will focus on images, but the same methods can be applied to any two-dimensional data (or to one-dimensional data, which is even easier!). <br><br><h3>  The basic concept of pseudo toning </h3><br>  In short, pseudo-toning is fundamentally associated with <em>error dissipation</em> . <br><br>  Error dispersion works as follows: Suppose we need to reduce the photo in grayscale to black and white colors so that we can print it on a printer that only supports pure black (ink) or pure white (paper without ink) color.  The first pixel in the image is dark gray, with a value of 96 on a scale from 0 to 255, where 0 is pure black, 255 is pure white. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/792/7f2/edc/7927f2edc00042d5ae427e1bff499900.png"></div><br>  <font color="gray">Visualization of RGB values ‚Äã‚Äãin our example.</font> <br><br>  When converting such a pixel to black or white, we use a simple formula: is the color value closer to 0 (black) or 255 (white)?  96 is closer to 0 than to 255, so we make the pixel black. <br><br>  At this stage, the standard approach is to simply move to the next pixel and perform the same comparison.  But the problem arises if we have a bunch of similar gray pixels with a value of 96 - they all turn into black.  We have a huge piece of empty black pixels that do not represent the original gray color. <br><br>  Error dispersion follows a smarter approach to the problem.  As you might suggest, error dissipation works by ‚Äúdispersing‚Äù - or spreading - the error of each calculation into adjacent pixels.  If the algorithm finds a gray pixel with a value of 96, it also determines that 96 is closer to 0 than to 255 - and therefore turns the pixel black.  But then the algorithm takes into account the ‚Äúerror‚Äù in its conversion.  In particular, the error is that the gray pixel that we made black, in fact, was 96 steps away from black. <br><br>  When it moves to the next pixel, the error dissipation algorithm adds the error of the previous pixel to the current pixel.  If the next pixel is also gray 96, instead of turning it black, the algorithm adds error 96 from the previous pixel.  This leads to a value of 192, which is actually closer to 255 - and therefore closer to white!  Thus, the algorithm makes this pixel white and again takes into account the error.  In this case, the error is ‚àí63, because 192 is 63 less than 255 ‚Äî the value by which this pixel was changed. <br><br>  As the algorithm continues, error dissipation leads to alternation of black and white pixels, which simulates the gray color of the value 96 of this segment quite well.  This is much better than coloring all the pixels in a row with black.  As a rule, when we finish processing the image string, we discard the error value that we were tracking, and start again with the error ‚Äú0‚Äù from the next image line. <br><br>  Below is an example of the image of our cube using the described algorithm.  In particular, each pixel is converted to black or white, the conversion error is noted and transmitted to the next pixel on the right: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9ea/ee6/071/9eaee60717c7409c89febb08c9e8d07b.png"></div><br>  <font color="gray">This is the easiest application of pseudo-toning with error dispersion.</font> <br><br>  Unfortunately, pseudo-toning with error dispersion has its own problems.  Be that as it may, psevdotonirovanie always leads to prominent points or to the dotted form.  This is an inevitable side effect of working with a small number of available colors ‚Äî because of their number, these colors will repeat again and again. <br><br>  In the above simple example of the error dissipation algorithm, another problem is obvious - if you have a block of very similar colors and you push the error just to the right, all the ‚Äúdots‚Äù end up in the same place!  This leads to funny dot lines that are almost as distracting as the original pseudo-toning version. <br><br>  The problem is that we only use one-dimensional error dissipation.  Spreading an error only in one direction (to the right), we do not distribute it very well.  Since the image has two dimensions (horizontal and vertical), why not direct the error in several directions?  This will distribute the error more evenly, which, in turn, will allow to avoid the strange lines of the points considered in the example of the error dispersion above. <br><br><h3>  Pseudo-tinting with two-dimensional error dissipation </h3><br>  There are many ways to dispel errors in two dimensions.  For example, we can spread an error by one or more pixels to the right, left, up, and down. <br><br>  For ease of calculation, all standard dithering formulas push the error forward only.  If you go around pixel by pixel, starting from the upper left corner and moving to the right, there will be no need to take errors back (for example, to the left and / or upward) into account.  The reason for this is obvious - if you throw an error back, you have to go back to the pixels that have already been processed, which leads to more errors when moving backwards.  The result is an endless cycle of error propagation. <br><br>  Thus, for the standard cycle behavior (starting from the upper left corner of the image and moving to the right), we want the movement of the pixels to go only to the right and down. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cb7/c8f/2bb/cb7c8f2bb851497abb30988071ad2f1f.png"></div><br>  <font color="gray">I apologize for the lousy image - but I hope this helps illustrate the essence of correct error propagation.</font> <br><br>  As for the specific ways of spreading the error, a lot of people were beating smarter than me.  Let me share these formulas with you. <br><br>  (Note: these dither formulas are available on several sites on the Internet, but the most comprehensive reference book I have found is <a href="http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT">this one</a> .) <br><br><h3>  Floyd-Steinberg Error Scatter Algorithm </h3><br>  The first and perhaps most well-known error dispersion formula was published by Robert Floyd and Louis Steinberg in 1976.  Dispersion of errors occurs as follows: <br><br><pre><code class="cpp hljs">X <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br>  In the above notation, X denotes the current pixel.  The fraction at the bottom is the divisor for error.  In other words, the Floyd-Steinberg formula can be written as: <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br>  But such a designation is long and inaccurate, so I will stick to the original. <br><br>  Let's return to our original example of converting a pixel value from 96 to 0 (black) or to 255 (white).  When we color a pixel in black, we get error 96. We spread this error to surrounding pixels, divide 96 by 16 (= 6), then multiply it by the corresponding values, for example: <br><br><pre> <code class="cpp hljs"> X +<span class="hljs-number"><span class="hljs-number">42</span></span> +<span class="hljs-number"><span class="hljs-number">18</span></span> +<span class="hljs-number"><span class="hljs-number">30</span></span> +<span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  By spreading the error to several pixels, each with a different value, we minimize all the distracting dotted stripes that are noticeable in the original example of the error dissipation algorithm.  Here is an image of a cube using the Floyd-Steinberg algorithm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/248/95c/a8e/24895ca8e48e4fa9b4d5bb7ffe1cfcc4.png"></div><br>  <font color="gray">Floyd-Steinberg Error Scatter Algorithm</font> <br><br>  Not bad, huh? <br><br>  The Floyd-Steinberg error dissipation algorithm is probably the most well known error dissipation algorithm.  It gives fairly good quality, and also requires only one front array (a one-dimensional array of image width, where error values ‚Äã‚Äãare distributed, distributed to the next line).  In addition, since its divider is 16, bit shifts can be used instead of division.  So the algorithm achieves high speed operation even on old equipment. <br><br>  As for the 1/3/5/7 values ‚Äã‚Äãused to propagate the error, they were specially chosen because they create a uniform checkered pattern for the gray image.  Clever! <br><br>  One warning about the Floyd-Steinberg algorithm - some programs may use other, simpler pseudo-toning formulas and call them Floyd-Steinberg, hoping that people do not know the difference.  <a href="http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT">Here's a great dithering article</a> that describes one of these ‚Äúfalse Floyd-Steinberg algorithms‚Äù: <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>)</code> </pre><br>  This simplification of the original Floyd-Steinberg algorithm gives not only a noticeably worse result, but also does it without any significant advantages in terms of speed (or memory, as an array for storing error values ‚Äã‚Äãfor the next line is still required). <br><br>  But if you're interested, here is an image of the cube after the passage of the ‚Äúfalse Floyd-Steinberg‚Äù: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/19e/a67/227/19ea672273284f819b5e58c03dd1d0ef.png"></div><br>  <font color="gray">There are far more clusters of points than in the real Floyd-Steinberg algorithm ‚Äî so don't use this formula!</font> <br><br><h3>  Algorithm of Jarvis, Judis and Ninke (Jarvis, Judice, Ninke) </h3><br>  In the year when Floyd and Steinberg published their famous dithering algorithm, a less well-known, but much more powerful algorithm was published.  The Jarvis, Judith and Ninke filter is much more complicated than the Floyd-Steinberg: <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">48</span></span>)</code> </pre><br>  With this algorithm, the error is distributed to three times more pixels than that of Floyd-Steinberg, which leads to a smoother and more subtle result.  Unfortunately, divisor 48 is not a power of two, so bit shifts cannot be applied.  Only 1/48, 3/48, 5/48, and 7/48 values ‚Äã‚Äãare used, so these values ‚Äã‚Äãcan be calculated once and then replicated several times for a small increase in speed. <br><br>  Another disadvantage of the JJN filter is that it pushes the error down not one line, but two.  This means that we need two arrays - one for the next row, the second for the row after it.  This was a problem at the time when the algorithm was first published, but on modern PCs and smartphones this additional requirement is irrelevant.  Honestly, it may be better to use a single array of image-size errors, rather than erasing two single-row grids over and over again. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/978/34d/edc/97834dedcf674823bb749dda5aa010c1.png"></div><br>  <font color="gray">Psevdotonirovaniya Jarvis, Judis and Ninke</font> <br><br><h3>  Dithering Pieces (Stucki) </h3><br>  Five years after the publication of the Jarvis, Judis and Ninke dithering formulas, Peter Stuki published a revised version with minor changes to improve processing time: <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre><br>  The divisor 42 is not a power of two, but the error dissipation value is yes.  Therefore, the error is divided into 42, bit shifts can be used to obtain specific values ‚Äã‚Äãfor dispersion. <br><br>  For most images, the difference between the Stuck and JJN algorithms will be minimal.  Therefore, the former is more often used because of its small speed advantage. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/103/534/082/1035340820964a30af70540c624002fa.png"></div><br>  <font color="gray">Pseudo-toning Pieces</font> <br><br><h3>  Dithering atkinson </h3><br>  In the mid-1980s, pseudo-toning became increasingly popular as computer hardware grew to support more powerful video and display drivers.  One of the best dithering algorithms of that era was developed by Bill Atkinson, an Apple employee who worked on everything from MacPaint (which he wrote from scratch for the original Macintosh) to HyperCard and QuickDraw. <br><br>  Atkinson's formula is slightly different from the others on this list, because it spreads only part of the error, not all of it.  In modern graphical applications, this method is found under the name "reduce fading."  Scattering only part of the error helps to reduce graininess, but continuous light and dark areas of the image can lose color. <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>)</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/files/96e/b7c/6a3/96eb7c6a3340417da95793c5cf1321ef.png"></div><br>  <font color="gray">Psevdotonirovaniya Atkinson</font> <br><br><h3>  Psevdotonirovaniya Burkes (Burkes) </h3><br>  Seven years after Stucki published improvements to the Jarvis, Judith, and Ninke algorithm, Daniel Burkes suggested further development: <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre><br>  Burkes' proposal was to omit the lower row of the matrix in the Stuck algorithm.  This not only eliminated the need for two arrays, but also resulted in a divisor again a multiple of 2. This change meant that all the mathematics involved in the error calculation could be performed by a simple bit shift, and with a slight loss of quality. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c7e/cb4/eec/c7ecb4eeca844952a6e0cfdf85bbfc7d.png"></div><br>  <font color="gray">Pseudotoning burkes</font> <br><br><h3>  Psevdotonirovaniya Sierra (Sierra) </h3><br>  The last three dithering algorithms were created by Frank Sierra, who published the following matrices in 1989 and 1990: <br><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br><pre> <code class="cpp hljs"> X <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  These three filters are commonly referred to as Sierra, Two-Row Sierra (two-row Sierra algorithm) and Sierra Lite.  Their final image on the test picture of the cube is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/657/b10/337/657b10337a054f43ba08afb974559db3.png"></div><br>  <font color="gray">Sierra (sometimes called Sierra-3)</font> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52e/345/b0d/52e345b0d49941f49a6f4908c44f8230.png"></div><br>  <font color="gray">Two-row Sierra (Sierra's two-row algorithm)</font> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0f6/b35/8ee/0f6b358ee0ed4acc8172120e50380f6c.png"></div><br>  <font color="gray">Sierra lite</font> <br><br><h3>  Other pseudo-toning considerations </h3><br>  If you compare the images above with the pseudo-toning results of another program, you may find small differences.  Similar expected.  There are surprisingly many variables that can affect the accuracy of the output of the pseudo-toning algorithm.  Among them: <br><br><ul><li>  Tracking errors with floating point or integer numbers.  Integer methods lose some resolution due to quantization errors. <br></li><li>  Reduce bleaching.  Some software reduces the error for a given value (perhaps 50% or 75%) to reduce the amount of discoloration of neighboring pixels. <br></li><li>  Cut-off threshold for black or white.  Values ‚Äã‚Äã127 or 128 are common, but in some images it may be useful to use other values. <br></li><li>  For color images, how brightness is calculated is important.  I use the HSL brightness formula ([max (R, G, B) + min (R, G, B)] / 2).  Others use ([r + g + b] / 3) or one of the <a href="http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/">ITU formulas</a> .  YUV or CIELAB will achieve even better results. <br></li><li>  Gamma correction or other preliminary modifications.  It is often useful to normalize an image before converting it to black and white.  The choice of method for this will obviously affect the result. <br></li><li>  The direction of the cycle.  I have discussed the standard approach ‚Äúfrom left to right, from top to bottom,‚Äù but some smart dithering algorithms will follow a snake-like path, where the direction from left to right is reversed.  So you can reduce the spots of homogeneous points and give a more diverse appearance, but they are more difficult to implement. <br></li></ul><br>  For the sample images in this article, I did not pre-process the original image.  All color matches are performed in RGB space with a cutoff of 127 (values ‚Äã‚Äã&lt;= 127 are set to 0).  The cycle direction is standard from left to right from top to bottom. <br><br>  What specific methods you can use depends on your programming language, processing limitations and the desired result. <br><br><h3>  I counted 9 algorithms, but you promised 11!  Where are the other two? </h3><br>  So far, I have focused exclusively on pseudo-toning on error dissipation, since this method offers better results than static non-diffusion algorithms. <br><br>  But for the sake of completeness, here are two standard pseudo-toning methods with an ordered blur.  Psevdotonirovanie with an orderly blurring leads to a much larger number of points (and worse results) than psevdotonirovanie with the dispersion of errors, but it does not require arrays of the following lines and works very quickly.  For more information on pseudo-toning with an ordered blur, see the <a href="http://en.wikipedia.org/wiki/Ordered_dithering">corresponding article in Wikipedia</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/121/f18/e59/121f18e59aa2428fbdf25ed595ee4cd2.png"></div><br>  <font color="gray">Pseudotoning with ordered blur with 4 √ó 4 matrix</font> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/550/a2c/a5f/550a2ca5fb1943f3b9b21e2e212551e7.png"></div><br>  <font color="gray">Psevdotonirovanie with an orderly blur with 8 √ó 8 matrix</font> <br><br>  Considering these methods, the article describes 11 different pseudo-toning algorithms. <br><br><h3>  Writing your own general purpose pseudo-toning algorithm </h3><br>  Earlier this year, I wrote a fully functional pseudo- <a href="http://www.tannerhelland.com/photodemon/">toning</a> general-purpose generator for <a href="http://www.tannerhelland.com/photodemon/">PhotoDemon</a> (an open source photo editor).  Instead of posting all the code here, let me direct you to the <a href="">appropriate page on GitHub</a> .  The black-and-white image conversion engine starts on line 350. If you have questions about the code that covers the algorithms described on this page, please <a href="http://www.tannerhelland.com/contact/">let me know</a> and I will post additional explanations. <br><br>  This engine works by allowing you to pre-specify any pseudo-toning matrix in the same way as in this article.  Then you pass this matrix to the pseudo-toning engine, and it does the rest. <br><br>  The engine is designed on the basis of monochrome conversion, but it can be easily modified to work with color palettes.  The biggest difference between the color palette situation is that you have to track individual errors for red, green, and blue, and not for one luminance error.  Otherwise, all the math is the same. </div><p>Source: <a href="https://habr.com/ru/post/326936/">https://habr.com/ru/post/326936/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326920/index.html">Yii 1.1.18</a></li>
<li><a href="../326926/index.html">Where to start programming in add. education? Or SmallBasic and all-all-all</a></li>
<li><a href="../326928/index.html">Universal work with VCS / SCM within the framework of automation with FutoIn CID</a></li>
<li><a href="../326930/index.html">Recovering data from a damaged RAID 50 array</a></li>
<li><a href="../326932/index.html">How often the light is chopped, and how does it end for business</a></li>
<li><a href="../326940/index.html">Development of a component for creating collages</a></li>
<li><a href="../326942/index.html">Connect to the webinar: "Azure Stack TP3 Technical Overview." Beginning April 27 at 11:00 (Moscow time)</a></li>
<li><a href="../326944/index.html">Video marketing in social networks: the most important indicators in 2017</a></li>
<li><a href="../326946/index.html">Microsoft and Rambus cool memory to cryogenic temperature</a></li>
<li><a href="../326948/index.html">Bad advice on setting up a backup and a few tales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>