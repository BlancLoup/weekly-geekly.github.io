<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[CodinGame] Back to the Code: Recar and Olaf69 share their strategies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Back to the Code competition is over and we really enjoyed watching various replays of games and learning strategies in each. We saw a fair amount...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[CodinGame] Back to the Code: Recar and Olaf69 share their strategies</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f38/ddc/2d8/f38ddc2d826b363048904afa01f9c8fe.png" alt="image"><br><br>  The Back to the Code competition is over and we really enjoyed watching various replays of games and learning strategies in each.  We saw a fair amount of good ideas and we hope you enjoyed the game as much as we did. <br><br>  Recar and Olaf69 both developed an excellent strategy that allowed them to reach the top of the tournament table and they agreed to share it, so you can discover the secret ingredients of their secret ingredient soup. <br><a name="habracut"></a><br><h2>  Recar </h2><br>  To play with 3 or 4: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We assume that the opponents will move in a straight line for at least 4 more moves, or until they rest in a occupied cage.  This helps us to start turning earlier, so as not to give the enemy a chance to spoil the filling plan.  Also, when sending in the past, we take into account the future of each of the opponents and we hope that they will walk the same way. <br><br>  After 20 moves, we look to see if our path is largely the perimeter of the area we want to fill on the 20th move, then we return the time to the 1st move, so that maybe everything went better this time. <br><br>  We are looking for the best course to fill: <br><br>  We iterate over all the rectangles starting from 3 by 3 and choose the best one on points.  Calculate points for a rectangular area.  We get the number of neutral cells in the rectangle.  If the number of neutral cells is greater than we need to win, then we consider the minimum necessary to win.  Why risk and be greedy. <br><br>  If there are enemy cells in the rectangle, then points = 0 and exit. <br><br>  For an area of ‚Äã‚Äãless than 3 on any of the axes points = 1 / distance to the upper left point <br>  We look, where there are our cells on the perimeter, and we find the cell with which we need to go in a circle so that the number of steps until the region is painted over is minimal. <br><br>  To motivate the bot to paint over the current rectangle, rather than move to a new, beautiful and distant, the distance that we need to go to the point from which we will paint over multiply by 2. opponents.  In the current version, this increase is equal to the number of players. <br><br>  Points count as (number of neutral cells / number of steps) <br><br>  Points * 2 if there are enough neutral cells to win. <br><br>  For two players: <br>  Points * 2 for the fact that the rectangle touches the edge through x = 17 and this middle line is still a little filled - there are more than 10 neutral cells. <br>  Points / 2 if the size of the rectangle is greater than 14 on any of the axes. <br><br>  For three or four players: <br>  Points * 1.1 if the rectangle touches the edge of the field. <br>  Points / 2 if the size of the rectangle is greater than 13, 12 on any of the axes for 3 and 4 players, respectively. <br>  Points / 2 if for each of the opponents is closer than 2 cells to the rectangle. <br>  Points / 10 if information from the future reports that rivals claim this rectangle. <br>  For a more stable behavior of the selected rectangle from the previous frame, we give a bonus to the estimate 1.1. <br><br>  If you have not found a single rectangle with a score of&gt; 1, then we are looking for the nearest single cell.  At the same time, we ignore all neutral neighbors with opponents.  This allows us to avoid the fuss in two adjacent cells in an attempt to capture them simultaneously with the opponent. <br><br>  We are looking for a non-rectangular area to capture when moving "corner" from the current position.  We check all possible angles up to 20 cells long. <br><br>  As a result, we get a point to which we are optimal now to go in order to fill the ‚Äúoptimal‚Äù selected area. <br><br>  Now, if we have two players see what area he is trying to fill, just like they chose their own.  If his area is better than ours and he finishes it faster, then we interfere with it.  To do this, look for a point in the area that the opponent wants to fill.  We select the nearest point inside, which borders on the wall already created by it.  So it will be harder for him to just reduce the area to be filled. <br><br>  After that we have a point where we want to go, either to close our area, or to interfere with the enemy.  If this point is located diagonally from our current position, then it is advisable to pass as many neutral cells as possible along the way.  It would be better to solve with the help of dynamic programming, but I have a rougher version with a simple check, how many neutral cells will be unavailable to us after the step horizontally and how many after the step vertically. <br><br><h2>  Olaf69 </h2><br>  I have just uploaded the <a href="https://github.com/clement-nardi/CodinGame-BackToTheCode">repository</a> I created for the game to GutHub.  In it, you can, among other things, find a list of <a href="https://github.com/clement-nardi/CodinGame-BackToTheCode/commits/master">commit notes</a> . <br><br>  In general, my AI was based on a wide search algorithm.  I realized that if I want to achieve efficiency, I must evaluate in each round the return on all possible directions within the limit of 100ms. <br><br>  The tree of all possible states was impressively large (close to 5 ^ number of players ^ 350 nodes), so it was necessary to come up with several rules that would limit the field of state options.  By the end of the game, the tree expansion rules were: <br><ul><li>  If there is at least one neutral cell around me, I consider each neutral cell, but skip the busy ones. </li><li>  If there are no neutral cells around, I leave this area, along the first computed path, without considering all the rest </li></ul><br><br>  And finally, if I did not find a path that would allow me to increase the score, I moved to the nearest neutral cell.  This could be due to the way I evaluated my rivals' paths. <br><br>  In the course of advancement, I also had to evaluate the most likely course of each of the opponents.  Ideally, I should use the alpha-beta algorithm, which involves evaluating each possible opponent's move and assigning him a point, but this would be very far from reality in the light of the incredible number of possible states that would have to be generated (and calculated everything in just 100 ms ).  So I had to be content with a much simpler, but risky solution, which was to move opponents in a deterministic way according to the following rules: <br><br><ul><li>  If the cell in front of it is neutral, it will move to it (it is assumed that you know where it is going) </li><li>  Otherwise, if if he turned to the right with the last move, then on the next move he will try to stand on the neutral cell on the right and then on the left.  Conversely, if the last move was to the right. </li><li>  If there is no neutral cell nearby, then it will move to the nearest one. </li></ul><br><br>  These rules assumed that the opponent would not act aggressively and would give preference to increasing his account, instead of trying to hinder my progress. <br><br>  At the very beginning, my strategy was aimed more at defense, assuming that my opponents would recursively move to each cell to which they would have access.  This allowed me to assess areas that I was more likely to close, but they were much smaller ‚Äî and therefore less interesting ‚Äî than those I could get with the help of my final code. <br><br>  In fact, with those expansion rules, I was still too limited in the available time, I could only evaluate shallow depths (close to 10-12, approximately 60,000 branches).  A scant 12 cells was not enough to form a large rectangle on a grid of 35x20 cells.  In fact, it made me move more along a spiral path. <br><br>  The idea that helped me make significant progress was to further limit the number of possible directions by moving three cells per turn (only neutral).  Thus, I could estimate the direction of 30 cells forward, and sometimes more. <br><br>  If I could see the whole tree (often during the game), then I tried to reduce the step to 2 cells, and then - to one. <br><br>  Another big problem was the assessment of each direction.  Initially, the criterion was simple: the number of points.  But it was not very satisfying to me and this grid shows why: <br><br>  00000000001111111111222222222233333 <br>  01234567890123456789012345678901234 <br>  + ----------------------------------- + <br>  0 | xxxxxxxxxxxx ................ ooooooo | 0 o: cells belonging to me <br>  1 | xxxxxxxxxxxx.  oo | 1 O: My position <br>  2 | xxxxxxxxxxxx.  oo o | 2.: Best calculated path <br>  3 | xxxxxxxxxxxx.  oo | 3 <br>  4 | xxxxxxxxxxxx.  oo | 4 Problem, I will close the area in only 22 rounds ... <br>  5 | xxxxxxxxxxxx..Ooooooo oo | 5 <br>  6 | xxxxxxxxxxxx oo oo | 6 <br>  7 | xxxxxxxxxxxx o oo o | 7 <br>  8 | xxxxxxxxxxxx ooo o | 8 <br>  9 | xxxxxxxxxxxx oo o | 9 <br>  10 | xxxxxxxxxxxx oo | 10 <br>  11 | xxxxxxxxxxxx oo | 11 <br>  12 |  xxoo | 12 <br>  13 |  xoo | 13 <br>  14 |  xo ooooooooo | 14 <br>  15 |  x ooo | 15 <br>  16 |  x | 16 <br>  17 |  x | 17 <br>  18 |  x | 18 <br>  19 |  Xxxxxxx | 19 <br>  + ----------------------------------- + <br>  00000000001111111111222222222233333 <br>  01234567890123456789012345678901234 <br><br>  With a single criterion in the form of points, capturing more and more areas is the most interesting behavior.  And in the end your plans are thwarted by your opponents.  I decided to use two different formulas: <br><ul><li>  The number of additional points / the remaining number of steps ‚Üí it becomes more interesting to close small areas </li><li>  Total points / total steps ‚Üí optimizes areas a little, but they remain too large </li></ul><br><br>  In the end, I decided to focus on the following: The number of extra points + 20 / the remaining number of steps + 20 <br><br>  In addition, there were a few more improvements that helped me move forward.  For example: <br><ul><li>  Limit the number of requests to the filling function; </li><li>  Optimize the calculation of the account; </li><li>  Optimize the search for the nearest neutral cell; </li><li>  Efficient memory management branches of the search tree; </li></ul><br>  And yet, I regret that I did not have enough time to apply all my ideas, namely, to use the opportunity to go back in time! </div><p>Source: <a href="https://habr.com/ru/post/269107/">https://habr.com/ru/post/269107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269089/index.html">Browser Development Design ‚ÄúSocial Browser Bar‚Äù</a></li>
<li><a href="../269095/index.html">iOs debug master</a></li>
<li><a href="../269097/index.html">Position - team lead</a></li>
<li><a href="../269099/index.html">Russian hackers hacked Dow Jones and seized insider information</a></li>
<li><a href="../269103/index.html">Big hakaton on VDNH</a></li>
<li><a href="../269111/index.html">How to write RFP for software development</a></li>
<li><a href="../269113/index.html">Illusion of time</a></li>
<li><a href="../269115/index.html">Admin as unit test for HTTP API</a></li>
<li><a href="../269117/index.html">Network technology in higher education. Sad experience in finding young professionals</a></li>
<li><a href="../269119/index.html">Balancing 70 thousand requests per second on HighLoad ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>