<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>eSSL - SSL Certificates for Embedded Systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nowadays, network technologies are developing so rapidly that the recently seemed delusional slogan " Internet in every refrigerator " no longer seems...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>eSSL - SSL Certificates for Embedded Systems</h1><div class="post__text post__text-html js-mediator-article">  Nowadays, network technologies are developing so rapidly that the recently seemed delusional slogan " <em>Internet in every refrigerator</em> " no longer seems fantastic.  But at the same time, the security issues of embedded devices having a WEB interface with access to the local and, God forbid, the global network are becoming relevant.  SSL technology is designed to help this by allowing you to work with the WEB interface using the HTTPS protocol, but <strong>embedded systems</strong> have their own characteristics here. <br><a name="habracut"></a><br><h3>  Silent general information about SSL </h3><br>  SSL technology allows you to encrypt traffic between two devices.  You probably know that SSL certificates are issued to websites and bound to domains or subdomains.  Certificates are issued by trusted <em>Certification Authorities</em> and signed with electronic signatures.  Certificates are confirmed in browsers by checking the certificate chain ( <em>Certification Path</em> ), the root certificates of these centers are already distributed along with the distributions of the main browsers, and such verification occurs unnoticed by the user.  If the trusted root certificate is not found by the browser, a page is issued to the user with a warning that the connection to the server is not secure. <br><img src="https://habrastorage.org/getpro/habr/post_images/0a0/f3d/79c/0a0f3d79cefa0d1111cfb259e00883e0.png"><br>  The problem with <strong>embedded systems</strong> is that <br><ul><li>  Firstly, this is not a web site in the general sense of the word (remember, for example, the web interface of a Wi-Fi router), at the time the product is released, it does not have a final IP address, and it is even less likely that it will have some kind of domain. </li><li>  secondly, the end user can change both the IP and the domain, if there was one, at least for the purposes of security. </li><li>  thirdly, to buy a certificate is quite expensive, and the question of cost reduction is always worth it. </li></ul><br>  How to solve these problems? <br><br><h3>  eSSL - embedded Secure Socket Layer </h3><br>  Then I will present to your court the results of my research on this issue verified by experiment.  The term <strong>eSSL</strong> came to my mind in the process of writing this article, so please use any references with the link to <a href="http://embedders.org/">embedders.org</a> . <br>  So, I will cover a few <strong>important aspects of the structure of certificates</strong> that allow us to use them in the way we need.  Any certificate is a collection of string fields signed by a <em>private key</em> .  The certificate also contains a public key to verify the authenticity of the data contained in these string fields.  The list of fields is defined in the format X.509 v3 and described in <em><a href="http://www.ietf.org/rfc/rfc5280.txt">RFC 5280</a></em> (this is the latest edition of the document at the moment, <em>RFC 3280 was</em> valid before).  The certificate contains the <em>commomName</em> field that describes the name of the certification subject, usually it coincides with the domain of the website for which the certificate is issued, but the standard does not prohibit what is written on this line, for example, the line "Vasya Pupkin" will also be valid for From the point of view of the standard, this field is the <strong>first aspect</strong> .  But web browsers check this field for compliance with the name of the site that presents the certificate.  Fortunately for us in the X509 v3 format, additional extensions are defined, one of which is <em>subjectAltName</em> , which allows you to add identifiers associated with the main name of the certification entity ( <em>commomName</em> ).  These identifiers can be: <br><ul><li>  E-mail address </li><li>  DNS </li><li>  IP address </li><li>  and URI </li></ul><br>  and this is the <strong>second</strong> and perhaps most important <strong>aspect of the</strong> structure of certificates of the 3rd version of the standard.  The fact is that there are several such identifiers, i.e.  You can enter several IP addresses for which the issued certificate will be valid.  And this is what we need if a device has two Ethernet interfaces to work in different sub-networks, and even the ability to connect to the network through different types of modems, if the connection is via PPP, then this will be the third interface with its IP address.  Experimentally, I established <strong>one important point</strong> in the assignment of alternative IP addresses.  Internet Explorer and FireFox browsers check alternate names in different ways.  FireFox verifies the address specified in the <strong>IP</strong> identifier, and IE verifies the address with the <strong>DNS</strong> identifier.  Therefore, to verify the certificate in both browsers, each required IP address <strong>must be specified both as IP and as DNS</strong> .  About how to do this will be discussed next. <br><br><h3>  Scenario for using SSL in embedded systems </h3><br>  I will give for example one of the possible scenarios for the use of certificates in embedded systems.  This scenario does not require the purchase of certificates, but has limitations in use.  So, <br><ol><li>  We will need to create a self-signed root certificate, in which case we will become our own certificate authority. </li><li>  Next, we need to create a certificate for our web interface and sign it with the root certificate created in the first step. </li><li>  We put this certificate in the memory of our <strong>embedded system</strong> where it can be found by the <strong>embedded web server</strong> . </li><li>  To all users of the web interface, we must issue our root certificate, but <strong>not the private key</strong> . </li><li>  Frontend users must import our root certificate into their web browsers on all computers from which they are supposed to log into the web interface. </li></ol><br>  <strong>I would especially like to note</strong> that this scenario is <strong>not secure</strong> , router manufacturers use this method, and smart hackers retrieve keys from the firmware and add them to the <a href="http://code.google.com/p/littleblackbox/">code.google.com/p/littleblackbox</a> database.  This method is not convenient either, because we have to pass the root certificate to the end user.  And we also need to keep the root certificate and private key to it in a safe place.  Ideally, both of these functions are provided by one of the trusted certificate authorities, but they charge a fee for this. <br>  Next, I will tell you how to implement the proposed scenario in practice.  All actions will be performed on a computer running Linux (Debian) and openssl programs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Creating a root certificate </h3><br><ol><li>  Install openssl-1.0 </li><li>  Edit the file '/etc/ssl/openssl.cnf' (or rather copy it to your home folder) by changing the following lines there: <br><br><pre><code class="bash hljs">[ CA_default ] dir = . <span class="hljs-comment"><span class="hljs-comment"># Where everything is kept unique_subject = no # Set to 'no' to allow creation of # several ctificates with same subject.</span></span></code> </pre> <br>  Here <em>dir</em> is the base directory in which our own Certificate Authority will be located.  Create it in the current directory. <br>  Because  Our devices can have the same name (the commonName parameter when creating a certificate), so with the <em>unique_subject</em> parameter, we allow to create many certificates for one subject. <br>  Let's set the key length to 2048 (or maybe 4096) bits. <br><pre> <code class="bash hljs">[ req ] default_bits = 2048</code> </pre><br>  Further, you can specify default parameters in order not to enter them manually every time, although for the root certificate they will need to be entered only once, if you are not going to make a hundred or two root certificates. <br><pre> <code class="bash hljs">[ req_distinguished_name ] countryName = Country Name (2 letter code) countryName_default = RU countryName_min = 2 countryName_max = 2 stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = Saint-Petersburg localityName = Locality Name (eg, city) localityName_default = Saint-Petersburg 0.organizationName = Organization Name (eg, company) 0.organizationName_default = My Cool Company <span class="hljs-comment"><span class="hljs-comment"># we can do this but it is not needed normally :-) #1.organizationName = Second Organization Name (eg, company) #1.organizationName_default = World Wide Web Pty Ltd organizationalUnitName = Organizational Unit Name (eg, section) #organizationalUnitName_default = commonName = Common Name (eg, YOUR name) commonName_default = My Device commonName_max = 64</span></span></code> </pre><br></li><li>  Create a directory <em>my-certs</em> where our Certification Center will be.  Create a <em>conf</em> subdirectory and place our configuration file there. </li><li>  Edit the following lines in the file '/usr/lib/ssl/misc/CA.pl': <br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$SSLEAY_CONFIG</span></span>=<span class="hljs-string"><span class="hljs-string">"-config /home/user/my-certs/conf/openssl.cnf"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$CADAYS</span></span>=<span class="hljs-string"><span class="hljs-string">"-days 3650"</span></span>; <span class="hljs-comment"><span class="hljs-comment"># 10 years $CATOP=".";</span></span></code> </pre><br>  Here <em>$ SSLEAY_CONFIG</em> sets the path to the configuration file. <br>  <em>$ CADAYS</em> indicates how many days the root certificate will be valid. <br>  <em>$ CATOP</em> indicates in which directory we will work.  This parameter must match the one we specified in <em>dir</em> in the configuration file in step 2. <br></li><li>  Execute the command <br><pre> <code class="bash hljs">/usr/lib/ssl/misc/CA.pl -newca</code> </pre><br>  It will create the necessary directory structure and root certificate, and sign it with itself. <br>  Upon request, you must enter a password for the future root certificate and then repeat it. <br><pre> <code class="bash hljs">Enter PEM pass phrase: Verifying - Enter PEM pass phrase:</code> </pre><br></li><li>  Enter the required information about you as a Certification Authority: country, region, city, company.  In the field 'common name' you should enter something like 'My Device root Certificate', this line will be displayed later in the certificate verification path in the user's browser.  To view the contents of the newly created certificate, run the command (here, in the example, a certificate with a 1024 bit key) <br><pre> <code class="bash hljs">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cacert.pem -noout -text Certificate: Data: Version: 3 (0x2) Serial Number: d9:98:4f:55:e0:bb:b3:3c Signature Algorithm: sha1WithRSAEncryption Issuer: C=RU, ST=Saint-Petersburg, O=My Cool Company, CN=My Device root Certificate Validity Not Before: Oct 11 12:16:26 2011 GMT Not After : Oct&amp;nbsp; 8 12:16:26 2021 GMT Subject: C=RU, ST=Saint-Petersburg, O=My Cool Company, CN=My Device root Certificate Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d1:d1:0a:11:a3:1e:67:2b:d2:39:3e:ea:bf:44: 04:f9:2a:ae:c4:37:a2:76:8b:<span class="hljs-built_in"><span class="hljs-built_in">fc</span></span>:de:6c:04:5a:56: 35:0b:12:8e:e6:31:62:5a:88:b4:53:a5:bf:9f:63: ea:6d:33:f9:4a:84:a5:8b:b1:f3:0b:9e:56:f8:27: 0d:8c:be:1d:76:be:6c:e5:c9:f3:f1:b0:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:df:79: b4:0b:05:db:25:15:c1:e5:b3:08:17:af:67:e9:be: 44:a2:ce:ed:9a:6c:16:bb:f6:8c:73:ab:dd:86:5a: 82:73:6c:5e:03:fa:6e:8e:06:07:dd:8e:fb:95:51: 16:4b:91:87:be:15:9e:12:21 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 1F:1:A6:43:A2:49:E7:16:49:EC:FD:73:71:72:D7:7F:24:6D:AC:17 X509v3 Authority Key Identifier: keyid:1F:1:A6:43:A2:49:E7:16:49:EC:FD:73:71:72:D7:7F:24:6D:AC:17 X509v3 Basic Constraints: CA:TRUE Signature Algorithm: sha1WithRSAEncryption 60:f2:cf:c7:52:11:83:c7:ea:b7:ae:68:8a:63:7a:89:5b:d6: 4e:ae:ba:0d:9d:a3:e6:86:07:db:54:77:59:b1:f9:dc:38:bd: a2:31:b6:18:80:80:3d:e1:20:13:23:28:26:b8:b0:aa:4f:a8: f7:92:89:13:2a:48:62:29:fb:3c:b7:ab:23:cb:97:ae:7c:21: 15:8e:23:e3:13:a1:e1:0d:85:dc:d0:8d:f7:<span class="hljs-built_in"><span class="hljs-built_in">fc</span></span>:a5:60:0e:bc: 5d:ea:31:d1:b4:ac:f6:24:b2:7e:4e:27:88:67:16:94:6e:5d: 4b:b4:ef:fa:8a:49:71:23:62:81:78:2c:03:a3:3d:ae:c9:7b: 5c:f8</code> </pre><br></li><li>  Then make an RSA key without a password. <br><pre> <code class="bash hljs">~/my-certs$ openssl rsa -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> private/cakey.pem -out private/ca.key Enter pass phrase <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> private/cakey.pem: writing RSA key</code> </pre><br>  It must be specified in the configuration file ( <em>/home/user/my-certs/conf/openssl.cnf</em> ), then when creating user certificates you will not need to enter the password for the root certificate every time. <br><pre> <code class="bash hljs">private_key = <span class="hljs-variable"><span class="hljs-variable">$dir</span></span>/private/ca.key <span class="hljs-comment"><span class="hljs-comment"># The private key</span></span></code> </pre><br></li><li>  Create a certificate in x509 format <br><pre> <code class="bash hljs">~/my-certs$ openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cacert.pem -out ca.crt</code> </pre><br>  It must be specified in the configuration file, then when creating user certificates you will not need to enter the password for the root certificate every time. <br><pre> <code class="bash hljs">certificate = <span class="hljs-variable"><span class="hljs-variable">$dir</span></span>/ca.crt <span class="hljs-comment"><span class="hljs-comment"># The CA certificate</span></span></code> </pre><br></li><li>  As a result, we will have 4 files. <br><pre> <code class="bash hljs">private/ca.key private/cakey.pem ca.crt cacert.pem</code> </pre><br>  These files must be "cherished" for they will sign all certificates for end users.  But <em>ca.crt</em> will be transferred to end users for import into browsers. </li></ol><br><h3>  Certificates for devices </h3><br>  Now we need to create an end-user or server certificate and sign it with a root certificate that we created in the previous section.  The main problem for me was that my device has several network interfaces that connect to different networks and, accordingly, have different IP addresses. <br><ol><li>  Let's edit our openssl.cnf configuration file and add to the end of the <em>[usr_cert]</em> section and before the <em>[v3_req]</em> section the next, perhaps the most important lines that will solve our problems. <br><br><pre> <code class="bash hljs">subjectAltName=@alt_names [alt_names] <span class="hljs-comment"><span class="hljs-comment"># .    ,       . IP.0 = 192.168.10.1 IP.1 = 192.168.1.1 DNS.0 = 192.168.10.1 DNS.1 = 192.168.1.1</span></span></code> </pre><br>  Here you can add alternative names that appear in the x509 standard v3 extensions and can be a <em>DNS</em> name, <em>IP</em> address or <em>URI</em> address.  There may be several of them, as long as the number after the point is different.  Experienced, I found that FireFox swallows <strong>IP</strong> names, and IE8 swallows <strong>DNS</strong> names.  Therefore, we need the IP addresses to be duplicated as <strong><em>IP</em></strong> for FireFox and as <strong><em>DNS</em></strong> for IE8, if, of course, we want to work in IE and in FireFox. </li><li>  Now you can create certificates.  Here you need to perform a sequence of openssl calls with different parameters, in order to simplify your life, I wrote the following simple script: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash echo "*** Create request for sign ***" openssl req -config conf/openssl.cnf -new -keyout certs/$1.pem -out tmp.pem let ret=$? if let "$ret!=0" then rm tmp.pem echo $ret exit 1 fi echo "*** Create RSA key without password ***" openssl rsa -in certs/$1.pem -out certs/$1.key let ret=$? if let "$ret!=0" then rm tmp.pem echo $ret exit 1 fi echo "*** Sign certificate by our own trusted key ***" openssl ca -config conf/openssl.cnf -policy policy_anything -out certs/$1.pem -infiles tmp.pem let ret=$? if let "$ret!=0" then rm tmp.pem echo $ret exit 1 fi rm tmp.pem echo "*** Create certificate ***" openssl x509 -in certs/$1.pem -out certs/$1.crt let ret=$? if let "$ret!=0" then echo $ret exit 1 fi</span></span></code> </pre><br>  At startup, it needs to pass as a parameter the name of the new certificate, for example <br><pre> <code class="bash hljs">newcert.sh device</code> </pre><br>  Such a call will create 2 files <em>device.crt</em> and <em>device.key</em> , i.e.  certificate and key to it.  During the execution of the script, questions will be asked about the password for the new certificate, as well as the country, city, company for whom the certificate is issued.  In the <em>commonName</em> field, you can specify any string, for example, <em>My cool device</em> , in the usual practice, the domain for which the certificate is issued is recorded here, but we record the IP addresses (and domains) in the alternative name razor, so browsers don't swear by dreadful words, but when viewing the certificate show a beautiful way to check. <br><img src="https://habrastorage.org/getpro/habr/post_images/20f/18b/34e/20f18b34ef28443b89fce916d310210e.png"></li></ol><br><h3>  How to apply all this? </h3><br>  So, we have created 2 types of certificates, root certificate and user certificate.  The root certificate is usually created once and then used to sign user certificates, which we distribute to users, i.e.  put on our devices.  We will understand how to use them. <br>  The user certificate and the key to it need to be placed on the target device, I have some kind of board with an ARM controller and Linux on board.  I will not describe this process, because  it depends on the WEB server that we have installed there. <br>  But the root certificate must be imported as the root certificate of a trusted certificate authority in each user's browser.  Only in this case, the browser will not show warnings when entering the page of your embedded WEB-server. <br><br><h4>  Import a root certificate into FireFox 6 (Linux) </h4><br>  In FireFox 6, this is done through the <em>Preferences</em> -&gt; <em>Encryption</em> -&gt; <em>View Certificates</em> menu, select the <em>Authorities</em> tab. <br><img src="https://habrastorage.org/getpro/habr/post_images/dc3/0d2/396/dc30d23966dc93e1aa82164fff575c29.png"><br>  Next, click <em>Import</em> and open the file of our root certificate <em>ca.crt</em> , to the question of use, put a tick on the identification of WEB-servers. <br><img src="https://habrastorage.org/getpro/habr/post_images/379/7c8/da0/3797c8da0063c1b6a0e8dacd04a8ec7e.png"><br>  And we can see our certificate in the list of trusted centers <br><img src="https://habrastorage.org/getpro/habr/post_images/8a5/2f0/27d/8a52f027d013657e2a7652de02d6c59a.png"><br><br><h4>  Import Root Certificate in IE8 (Windows 7 64bit) </h4><br>  In the Start menu, in the search bar, type certmgr and press the key combination Ctrl + Shift + Enter, answer affirmatively to the administrator rights request.  You will start the certificate manager. <br>  Double click on the Trusted Root Certification Authorities section <br>  Right click on Certificates -&gt; All Tasks -&gt; Import ... <br><img src="https://habrastorage.org/getpro/habr/post_images/9c1/48d/a23/9c148da23b80d75d596a1d618f01ecae.png"><br>  The certificate import wizard will start, follow its instructions and specify ca.crt as the certificate.  If the result is an error <br><img src="https://habrastorage.org/getpro/habr/post_images/02f/0fc/707/02f0fc707bc73b2dc4bb812314d2ae1f.png"><br>  Then correct the <em>registry</em> key in <em>HKEY_LOCAL_MACHINE \ SOFTWARE \ Policies \ Microsoft \ SystemCertificates \ Root \ ProtectedRoots \ Flags,</em> set it to <em>0</em> and restart the certificate manager. <br><br><h2>  Conclusion </h2><br>  We considered some features of SSL certificates that allow identifying a system with several IP addresses and / or Domain names, as well as considered the simplest scenario for using certificates in embedded systems.  Is it possible to improve this scenario?  Sure you may.  For example, you can make the root certificate be generated directly on the device and given to the user upon request, for example, on a USB Stick.  In this case, the theft of the root certificate will not entail danger for similar devices from other buyers.  Using self-signed certificates is certainly not the best practice, but sometimes for embedded system manufacturers this is the only way to ensure the minimum security of their devices. <br>  Some of the information relating to user certificates can also be used when purchasing certificates signed by trusted certificate authorities.  In this case, it provides the highest level of security that SSL technology can provide. <br><br><h4>  Matrials used: </h4><br><ul><li>  <a href="http://semenushkin.ru/2010/05/25/%25D1%2581%25D0%25BE%25D0%25B7%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5-%25D1%2581%25D0%25B0%25D0%25BC%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE-ssl-%25D1%2581%25D0%25B5%25D1%2580%25D1%2582%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA/">Creating a self-signed SSL certificate for multiple domain names using openssl</a> </li><li>  <a href="http://freessl.ru/page-apach.html">Fast lifting SSL for Apache under FreeBSD</a> </li><li>  <a href="http://freessl.ru/page-apach.html">http://www.openssl.org/docs/</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/136543/">https://habr.com/ru/post/136543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136536/index.html">Reflections on Foggy Computing</a></li>
<li><a href="../136537/index.html">Centralized collection, storage and viewing of Syslog on Debian Linux</a></li>
<li><a href="../136538/index.html">Review System in the Windows Phone Marketplace</a></li>
<li><a href="../136540/index.html">Universal cell reading in PHPExcel</a></li>
<li><a href="../136542/index.html">Transfer of corporate mail to mail for a domain from Yandex</a></li>
<li><a href="../136545/index.html">Orangutans have mastered the iPad and started calling relatives</a></li>
<li><a href="../136546/index.html">Medicine: electronic medical records - a view from the doctor</a></li>
<li><a href="../136549/index.html">IT development for the next 15-20 years: carriers can be forgotten</a></li>
<li><a href="../136551/index.html">Unhappy hours are not observed. Mode of operation on the site</a></li>
<li><a href="../136552/index.html">Excellent visual video lecture about the essence of SOPA / PIPA and possible problems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>