<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Google's beacon platform. Part 2 - Nearby meassages API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Google's beacon platform is a solution for working with Bluetooth beacons. The platform works with different beacons from different manufacturers, pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Google's beacon platform. Part 2 - Nearby meassages API</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://developers.google.com/beacons/overview"><strong>Google's beacon platform</strong></a> is a solution for working with Bluetooth beacons.  The platform works with different beacons from different manufacturers, providing developers with a single, simple and flexible tool. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dcb/a44/996/dcba449969c544329ddd92b68f27e5f0.png"></div><br><p>  Before reading this article, I recommend to get acquainted with the concept of <strong>Physical Web</strong> about which I spoke in my last article: <a href="https://habrahabr.ru/post/278443/">The Concept of Physical web.</a>  <a href="https://habrahabr.ru/post/278443/">Bluetooth beacons.</a>  <a href="https://habrahabr.ru/post/278443/">Comparison of iBeacon, AltBeacon and Eddystone standards</a> . </p><br><p>  <a href="https://habrahabr.ru/post/279381/">Google's beacon platform.</a>  <a href="https://habrahabr.ru/post/279381/">Part 1 - Proximity beacon API</a> <br>  <a href="https://habrahabr.ru/post/279379/">Google's beacon platform.</a>  <a href="https://habrahabr.ru/post/279379/">Part 2 - Nearby meassages API</a> </p><br><p>  The main tool, within <strong>Google's beacon platform</strong> , to work on the client side with bluetooth beacons is the <a href="https://developers.google.com/nearby/messages/overview"><strong>Nearby Messages API</strong></a> .  In this article I will tell you how to set up projects on Android and iOS platforms, and add to the application the ability to receive and parse messages from ble-beacons. </p><a name="habracut"></a><br><h1>  Nearby Messages API </h1><br><p>  <strong>Nearby Messages API</strong> is an API that implements the publish-subscribe paradigm and allows different devices to publish and subscribe to messages, thus sharing data.  <strong>Nearby Messages API</strong> is part of <a href="https://developers.google.com/nearby/">Nearby</a> .  For messaging, devices do not have to be on the same network, but must be connected to the Internet.  In our case, the Internet connection should be in that smartphone or tablet on which we want to receive messages.  Beacons do not need internet connection!  <strong>The Nearby Messages API</strong> allows you to exchange messages using Bluetooth, Bluetooth Low Energy, Wi-Fi and even ultrasound, but we will only use Bluetooth Low Energy to minimize energy consumption. </p><br><h1>  Nearby Messages API on Android </h1><br><p>  The Nearby Messages API is available on Android devices in the Google Play services version 7.8.0 or higher. <br>  Ensure that you have the latest version of the client library for Google Play installed on your development host: </p><br><ul><li>  Open Android SDK Manager. </li><li>  Go to A ppearance &amp; Behavior&gt; System Settings&gt; Android SDK&gt; SDK Tools and make sure the following packages are installed: <br><ul><li>  Google Play services </li><li>  Google Repository </li></ul></li></ul><br><p>  To use the Nearby Messages API, of course, you need a Google Account.  You also need to get the <a href="https://developers.google.com/nearby/messages/android/get-started">API key</a> .  Keys for Android, iOS and Proximity Beacon API must be created within the same project of the Google Developers Console.  I <a href="https://support.google.com/cloud/answer/6310037"><strong>strongly</strong></a> advise you to familiarize yourself with <a href="https://support.google.com/cloud/answer/6310037"><strong>Best practices for securely using API keys</strong></a> </p><br><div class="spoiler">  <b class="spoiler_title">Caution gif.</b>  <b class="spoiler_title">An example of how to get an API key:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/9e4/2c7/043/9e42c7043012470486498e77e56baec7.gif" alt="image"></p></div></div><br><p> <strong>Customize the project:</strong> <br>  Open or create a new project, open the <code>build.gradle</code> file and add the Google Play services client library to it as a dependency. </p><br><div class="spoiler">  <b class="spoiler_title">Contents of the build.gradle file</b> <div class="spoiler_text"><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">apply</span></span> plugin: <span class="hljs-string"><span class="hljs-string">'android'</span></span> ... dependencies { <span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'com.google.android.gms:play-services-nearby:8.4.0'</span></span> }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Configure the manifest file to which we add the previously generated API key:</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.google.sample.app"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.google.android.nearby.messages.API_KEY"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"API_KEY"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Create in our application GoogleApiClient and add Nearby Messages API <br>  An example of code that shows how to add the Nearby Messages API: </p><br><div class="spoiler">  <b class="spoiler_title">Create in GoogleApiClient application:</b> <div class="spoiler_text"><pre> <code class="java hljs">mGoogleApiClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GoogleApiClient.Builder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .addApi(Nearby.MESSAGES_API) .addConnectionCallbacks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .addOnConnectionFailedListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .build();</code> </pre> </div></div><br><h2>  Receive messages </h2><br><p>  To receive messages from beacons, we need to first subscribe to them, there are two ways how our application can do this: </p><br><ul><li>  In the active mode of the application, in response to user actions or events. </li><li>  In the background, i.e.  when the application is inactive </li></ul><br><p>  The Nearby Messages API requires user permission to <code>publish()</code> and <code>subscribe()</code> requests.  Therefore, the application must check for what the user has already given his consent, and if this is not the case, then call the permission request dialog. </p><br><p>  To implement a request for permission from the user during the execution of your application, you can: </p><br><ul><li>  Attach <code>result callback</code> to <code>publish()</code> and <code>subscribe()</code> calls. </li><li>  Use <code>Nearby.Messages.getPermissionStatus()</code> to check permission status just before calling <code>publish()</code> or <code>subscribe()</code> </li></ul><br><h3>  Implement result callback </h3><br><p>  To check the status of the error code in the <code>result callback</code> you must call <code>status.getStatusCode()</code> .  If the status code <code>APP_NOT_OPTED_IN</code> display the permission request dialog with a call to <code>status.startResolutionForResult()</code> and use <code>onActivityResult()</code> to re-initiate any outstanding subscription or publication requests. </p><br><p>  The following example demonstrates a simple result callback that checks which user has granted permissions.  If the user has not granted permissions, <code>status.startResolutionForResult()</code> is called to prompt the user to allow Nearby Messages.  In this example, the <code>boolean mResolvingError</code> used to avoid repeatedly running such sentences: </p><br><div class="spoiler">  <b class="spoiler_title">An example implementation of the result callback:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleUnsuccessfulNearbyResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Status status)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(TAG, <span class="hljs-string"><span class="hljs-string">"Processing error, status = "</span></span> + status); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mResolvingError) { <span class="hljs-comment"><span class="hljs-comment">// Already attempting to resolve an error. return; } else if (status.hasResolution()) { try { mResolvingError = true; status.startResolutionForResult(getActivity(), Constants.REQUEST_RESOLVE_ERROR); } catch (IntentSender.SendIntentException e) { mResolvingError = false; Log.i(TAG, "Failed to resolve error status.", e); } } else { if (status.getStatusCode() == CommonStatusCodes.NETWORK_ERROR) { Toast.makeText(getActivity().getApplicationContext(), "No connectivity, cannot proceed. Fix in 'Settings' and try again.", Toast.LENGTH_LONG).show(); } else { // To keep things simple, pop a toast for all other error messages. Toast.makeText(getActivity().getApplicationContext(), "Unsuccessful: " + status.getStatusMessage(), Toast.LENGTH_LONG).show(); } } }</span></span></code> </pre> </div></div><br><p>  You can also use this handler to process any other <code>NearbyMessageStatusCodes</code> received from operations or, for example, the status of a <code>CommonStatusCodes.NETWORK_ERROR.</code> code <code>CommonStatusCodes.NETWORK_ERROR.</code> </p><br><h4>  Re-implementing failed requests </h4><br><p>  The following example shows an implementation of the <code>onActivityResult()</code> method, which is called after the user responds to the permission request dialog.  If the user agrees, any pending subscription or publication requests will be honored.  In this example, the <code>executePendingTasks()</code> method is <code>executePendingTasks()</code> </p><br><div class="spoiler">  <b class="spoiler_title">Reinstatement of failed requests:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requestCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultCode, Intent data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onActivityResult(requestCode, resultCode, data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (requestCode == Constants.REQUEST_RESOLVE_ERROR) { <span class="hljs-comment"><span class="hljs-comment">// User was presented with the Nearby opt-in dialog and pressed "Allow". mResolvingError = false; if (resultCode == Activity.RESULT_OK) { // Execute the pending subscription and publication tasks here. mMainFragment.executePendingTasks(); } else if (resultCode == Activity.RESULT_CANCELED) { // User declined to opt-in. Reset application state here. } else { Toast.makeText(this, "Failed to resolve error with code " + resultCode, Toast.LENGTH_LONG).show(); } }</span></span></code> </pre> </div></div><br><p>  Also, in order to reduce the delay in scanning beacons, we recommend using Strategy.BLE_ONLY when calling Nearby.Messages.subscribe ().  When this option is set, the Nearby Messages API does not enable Wi-Fi scanning or classic Bluetooth scans.  This reduces the detection delay of beacons, because the system does not cycle through all possible scan types, and also reduces power consumption. </p><br><h3>  Active subscription: </h3><br><p>  When your application subscribes to messages from beacons while in active mode, scanning is performed continuously until the application is unsubscribed.  Such a subscription is recommended to be used only when your application is active, usually in response to some kind of user action. </p><br><p>  An application can initiate a subscription in active mode by calling the <code>Nearby.Messages.subscribe(GoogleApiClient, MessageListener, SubscribeOptions)</code> method <code>Nearby.Messages.subscribe(GoogleApiClient, MessageListener, SubscribeOptions)</code> and setting the <code>Strategy</code> parameter to <code>BLE_ONLY</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Code snippet showing the initiation of a subscription in active mode:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Create a new message listener. mMessageListener = new MessageListener() { @Override public void onFound(Message message) { // Do something with the message. Log.i(TAG, "Found message: " + message); } // Called when a message is no longer detectable nearby. public void onLost(Message message) { // Take appropriate action here (update UI, etc.) } } // Subscribe to receive messages. Log.i(TAG, "Trying to subscribe."); // Connect the GoogleApiClient. if (!mGoogleApiClient.isConnected()) { if (!mGoogleApiClient.isConnecting()) { mGoogleApiClient.connect(); } } else { SubscribeOptions options = new SubscribeOptions.Builder() .setStrategy(Strategy.BLE_ONLY) .setCallback(new SubscribeCallback() { @Override public void onExpired() { Log.i(TAG, "No longer subscribing."); } }).build(); Nearby.Messages.subscribe(mGoogleApiClient, mMessageListener, options) .setResultCallback(new ResultCallback&lt;Status&gt;() { @Override public void onResult(Status status) { if (status.isSuccess()) { Log.i(TAG, "Subscribed successfully."); } else { Log.i(TAG, "Could not subscribe."); // Check whether consent was given; // if not, prompt the user for consent. handleUnsuccessfulNearbyResult(status); } } }); }</span></span></code> </pre> </div></div><br><p>  To reduce energy consumption and consequently prolong battery life, call <code>Nearby.Messages.unsubscribe()</code> in the <code>OnStop()</code> method of your application. <br>  When a subscription to messages is no longer needed, the application should unsubscribe by calling the <code>Nearby.Messages.unsubscribe(GoogleApiClient, MessageListener)</code> method <code>Nearby.Messages.unsubscribe(GoogleApiClient, MessageListener)</code> . </p><br><h3>  Subscription in the background </h3><br><p>  When an application subscribes to messages in the background, a low-power scan is triggered when the screen is turned on, even when the application is not currently active.  You can use these background low-power scanning events to wake up the application in response to a specific message.  Background subscriptions consume less power than an active subscription, but have higher latency and lower reliability. </p><br><p>  A subscription in the background is initiated by calling the <code>Nearby.Messages.subscribe(GoogleApiClient, PendingIntent,SubscribeOptions)</code> method <code>Nearby.Messages.subscribe(GoogleApiClient, PendingIntent,SubscribeOptions)</code> and setting the <code>Strategy</code> parameter to <code>BLE_ONLY</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Code snippet showing the initiation of a subscription in the background:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to messages in the background. private void backgroundSubscribe() { // Connect the GoogleApiClient. if (!mGoogleApiClient.isConnected()) { if (!mGoogleApiClient.isConnecting()) { mGoogleApiClient.connect(); } } else { Log.i(TAG, "Subscribing for background updates."); SubscribeOptions options = new SubscribeOptions.Builder() .setStrategy(Strategy.BLE_ONLY) .build(); Nearby.Messages.subscribe(mGoogleApiClient, getPendingIntent(), options) .setResultCallback(new ResultCallback&lt;Status&gt;() { @Override public void onResult(Status status) { if (status.isSuccess()) { Log.i(TAG, "Subscribed successfully."); } else { Log.i(TAG, "Could not subscribe."); handleUnsuccessfulNearbyResult(status); } } }); } } private PendingIntent getPendingIntent() { return PendingIntent.getService(getApplicationContext(), 0, getBackgroundSubscribeServiceIntent(), PendingIntent.FLAG_UPDATE_CURRENT); } private Intent getBackgroundSubscribeServiceIntent() { return new Intent(getApplicationContext(), BackgroundSubscribeIntentService.class); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">A snippet of code demonstrating intent processing in the BackgroundSubscribeIntentService class:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onHandleIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Nearby.Messages.handleIntent(intent, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message message)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(TAG, <span class="hljs-string"><span class="hljs-string">"Found message via PendingIntent: "</span></span> + message); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onLost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message message)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(TAG, <span class="hljs-string"><span class="hljs-string">"Lost message via PendingIntent: "</span></span> + message); } }); }</code> </pre> </div></div><br><p>  And of course, if we no longer need a subscription, we must unsubscribe by calling <code>Nearby.Messages.unsubscribe(GoogleApiClient, PendingIntent)</code> . </p><br><h2>  Parsing messages </h2><br><p>  As we already know from the first part, each attachment consists of the following parts: <br>  - <strong>Namespace</strong> : <strong>Namespace</strong> ID. <br>  - <strong>Type</strong> : Type of data. <br>  - <strong>Data</strong> : The value of the attachment data. </p><br><div class="spoiler">  <b class="spoiler_title">A snippet of code demonstrating the use of MessageListener () to parse messages:</b> <div class="spoiler_text"><pre> <code class="java hljs">mMessageListener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageListener() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Message message)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Do something with the message here. Log.i(TAG, "Message found: " + message); Log.i(TAG, "Message string: " + new String(message.getContent())); Log.i(TAG, "Message namespaced type: " + message.getNamespace() + "/" + message.getType()); } ... };</span></span></code> </pre> </div></div><br><p>  It is worth considering that the analysis of the content depends on the format of bytes.  This example assumes that messages are encoded in a UTF-8 string, but your messages from beacons can be encoded in a different format. <br>  To find out which namespaces are associated with your project, you can call namespaces.list. </p><br><h1>  Nearby meassages API on iOS </h1><br><p>  To create a project using Nearby Messages API for iOS, we need Xcode version 6.3 or later. </p><br><p>  The Google Nearby Messages API for iOS is available as a <strong>CocoaPods</strong> pod <strong>package</strong> .  <strong>CocoaPods</strong> is an open source dependency manager for Swift and Objective-C Cocoa projects.  For more information, I advise you to familiarize yourself with the <a href="https://guides.cocoapods.org/using/getting-started.html">CocoaPods Getting Started guide</a> .  If you have not installed it, you can do this by running the following command in the terminal: </p><br><pre> <code class="bash hljs">$ sudo gem install cocoapods</code> </pre> <br><p>  <strong>Install the Nearby messages API using CocoaPods:</strong> </p><br><ul><li>  Open a project or create a new one; you should make sure that the Use Automatic Reference Counting option is turned on. </li><li>  Create a file called Podfile in the project directory.  This file will define the dependencies of the project. </li><li>  Add dependencies to the Podfile.  An example of a simple Podspec containing the name of the package that is to be installed. <br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">source</span></span> <span class="hljs-string"><span class="hljs-string">'https://github.com/CocoaPods/Specs.git'</span></span> platform :ios, <span class="hljs-string"><span class="hljs-string">'7.0'</span></span> pod <span class="hljs-string"><span class="hljs-string">'NearbyMessages'</span></span></code> </pre> </li><li>  In the terminal, go to the director in which the Podfile is located. </li><li>  To install along with the dependencies of the API specified in the Podfile, you need to run the command: <br><pre> <code class="bash hljs">$ pod install</code> </pre> </li></ul><br><p>  After that, close Xcode and then double-click on the .xcworkspace project and launch Xcode.  From now on, you must use the .xcworkspace file to open the project. </p><br><p>  As with Android, we need to get an <a href="https://developers.google.com/nearby/messages/ios/get-started">API key</a> .  Keys for Android, iOS and Proximity Beacon API must be created within the same project of the Google Developers Console.  I <a href="https://support.google.com/cloud/answer/6310037"><strong>strongly</strong></a> advise you to familiarize yourself with <a href="https://support.google.com/cloud/answer/6310037"><strong>Best practices for securely using API keys</strong></a> </p><br><div class="spoiler">  <b class="spoiler_title">Caution gif.</b>  <b class="spoiler_title">An example of getting the API key:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/files/9e4/2c7/043/9e42c7043012470486498e77e56baec7.gif" alt="image"></p></div></div><br><p>  Now that everything is set up, we can create a <code>messageManager</code> object and use the API key previously created. </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;GNSMessages.h&gt;</span></span></span><span class="hljs-meta"> GNSMessageManager *messageManager = [[GNSMessageManager alloc] initWithAPIKey:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"API_KEY"</span></span></span><span class="hljs-meta">];</span></span></code> </pre> <br><h2>  IOS Subscription </h2><br><p>  In iOS, beacon scanning occurs only when the application is active.  Scanning beacons in the background is not available for iOS.  To subscribe only to the BLE beacons, you need to set the <code>deviceTypesToDiscover</code> in the subscription parameters <code>kGNSDeviceBLEBeacon</code> . </p><br><div class="spoiler">  <b class="spoiler_title">A snippet of code that shows how to do it:</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">_beaconSubscription = [_messageManager subscriptionWithMessageFoundHandler:myMessageFoundHandler messageLostHandler:myMessageLostHandler paramsBlock:^(GNSSubscriptionParams *params) { params.deviceTypesToDiscover = kGNSDeviceBLEBeacon; }];</code> </pre> </div></div><br><p>  This sample code subscribes only to the beacons of our project and receives all messages from them. </p><br><p>  If we want to receive messages from beacons registered with a different namespace, we can pass the namespace to the subscription parameters.  Similarly, we can do with the type of messages that we want to receive by passing a specific type of message for filtering.  To do this, you need to enable device scanning in <code>GNSStrategy</code> and <code>GNSStrategy</code> namespace and subscription type values ‚Äã‚Äãto the subscription parameters. </p><br><div class="spoiler">  <b class="spoiler_title">A snippet of code that shows how to do it:</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">_beaconSubscription = [_messageManager subscriptionWithMessageFoundHandler:myMessageFoundHandler messageLostHandler:myMessageLostHandler paramsBlock:^(GNSSubscriptionParams *params) { params.deviceTypesToDiscover = kGNSDeviceBLEBeacon; params.messageNamespace = <span class="hljs-string"><span class="hljs-string">@"com.mycompany.mybeaconservice"</span></span>; params.type = <span class="hljs-string"><span class="hljs-string">@"mybeacontype"</span></span>; }];</code> </pre> </div></div><br><p>  By default, with a subscription, we scan both types of beacons at once, Eddystone and iBeacon.  If we are involved in scanning beacons iBeacon, the user will receive a request to use geolocation.  The application's Info.plist must include the <code>NSLocationAlwaysUsageDescription</code> key with a shortcut explaining why geolocation is used.  I advise you to read <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html">Apple documentation</a> for details. </p><br><p>  If we want to scan only Eddystone beacons, we can disable the iBeacon <code>GNSBeaconStrategy</code> scanning in <code>GNSBeaconStrategy</code> .  In this case, iOS will not ask the user for permission to use geolocation. </p><br><div class="spoiler">  <b class="spoiler_title">A snippet of code that shows how to disable iBeacon beacon scanning for the previous example:</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">_beaconSubscription = [_messageManager subscriptionWithMessageFoundHandler:myMessageFoundHandler messageLostHandler:myMessageLostHandler paramsBlock:^(GNSSubscriptionParams *params) { params.deviceTypesToDiscover = kGNSDeviceBLEBeacon; params.messageNamespace = <span class="hljs-string"><span class="hljs-string">@"com.mycompany.mybeaconservice"</span></span>; params.type = <span class="hljs-string"><span class="hljs-string">@"mybeacontype"</span></span>; params.beaconStrategy = [GNSBeaconStrategy strategyWithParamsBlock:^(GNSBeaconStrategyParams *params) { params.includeIBeacons = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; }; }];</code> </pre></div></div><br><p>  When scanning iBeacon beacons, the geolocation permissions request dialog precedes the Nearby permissions dialog.  We can override this dialog, for example, in order to bind the user for what permission for geolocation is requested.  To do this, you must set the <code>permissionRequestHandler</code> in a separate block in the subscription parameters. </p><br><div class="spoiler">  <b class="spoiler_title">Code snippet showing how to do it:</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">_beaconSubscription = [_messageManager subscriptionWithMessageFoundHandler:myMessageFoundHandler messageLostHandler:myMessageLostHandler paramsBlock:^(GNSSubscriptionParams *params) { params.deviceTypesToDiscover = kGNSDeviceBLEBeacon; params.messageNamespace = <span class="hljs-string"><span class="hljs-string">@"com.mycompany.mybeaconservice"</span></span>; params.type = <span class="hljs-string"><span class="hljs-string">@"mybeacontype"</span></span>; params.beaconStrategy = [GNSBeaconStrategy strategyWithParamsBlock:^(GNSBeaconStrategyParams *params) { params.includeIBeacons = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; }; params.permissionRequestHandler = ^(GNSPermissionHandler permissionHandler) { <span class="hljs-comment"><span class="hljs-comment">// Show your custom dialog here, and don't forget to call permissionHandler after it is dismissed permissionHandler(userGavePermission); }; }];</span></span></code> </pre> </div></div><br><h1>  Conclusion </h1><br><p>  I hope that this material will be useful to someone, save time and effort. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/279379/">https://habr.com/ru/post/279379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279369/index.html">AirPlay server and Time Machine backup on MTK routers (and not only)</a></li>
<li><a href="../279371/index.html">Just another bike encryption</a></li>
<li><a href="../279373/index.html">Creating a draft interface form and dialog box map in PLANTUML</a></li>
<li><a href="../279375/index.html">CodingFuture + Puppet. Part IV: Centralized Management (cftotalcontrol)</a></li>
<li><a href="../279377/index.html">Recall all: Java JET conference. September 28, 2015. Report</a></li>
<li><a href="../279381/index.html">Google's beacon platform. Part 1 - Proximity beacon API</a></li>
<li><a href="../279383/index.html">Work with VK API when creating a game for VKontakte</a></li>
<li><a href="../279385/index.html">Work with events in Laravel. Sending push notifications when publishing an article</a></li>
<li><a href="../279389/index.html">Azure-IaaS-Digest number 3 (March)</a></li>
<li><a href="../279393/index.html">Parallel noise and random number functions for OpenCL cores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>