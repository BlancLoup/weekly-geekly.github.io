<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New life old synthesizer. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuation of the story about the old burned synthesizer, into which I am trying to breathe new life by completely replacing the hardware responsibl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New life old synthesizer. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Continuation of the <a href="http://habrahabr.ru/post/214147/">story</a> about the old burned synthesizer, into which I am trying to breathe new life by completely replacing the hardware responsible for sound generation with a software synthesizer built on the base of the EmbedSky E8 mini-computer with Linux on board.  As is often the case, much more time passed between the publication of the first and second part of the article than planned, but, nevertheless, we will continue. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ea/afe/c88/7eaafec883eda0dca0adce08642d0110.jpg"><br><br>  The previous part outlined the process of choosing a hardware platform for the new ‚Äúbrain‚Äù of the synthesizer with a description of the technical characteristics of the solution, briefly highlighted the process of assembling the necessary libraries and the problems encountered in the process.  Now, with regard to hardware, we will see how the keyboard matrix of the synthesizer is arranged, and then there will be more details on the software part. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Keyboard matrix </h5><br>  The keyboard matrix of the synthesizer is very similar to the usual keyboard matrix, which many fans of microcontrollers have probably already connected to their Arduino.  For each synthesizer key, it provides from one (in the cheapest models) to two (in the bulk of the models) switches.  Using two adjacent switches, one of which, when a key is pressed, closes a little before the other, the microcontroller can determine the conventional force, or rather the speed with which the key was pressed, so that the sound of the corresponding volume could be subsequently played.  It looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/78c/812/c52/78c812c5202cf0eb8587d1a679fd4c98.jpg"><br>  On the reverse side of the board are placed diodes that prevent the ‚Äúfalse‚Äù reading of keystrokes while simultaneously pressing several keys.  Here is a fragment of the concept of the keyboard matrix, on which these two switches and the diodes connected to them are visible: <br><img src="https://habrastorage.org/getpro/habr/post_images/ca5/eef/5d1/ca5eef5d191c1c5d4e3207de541cde66.png"><br><br>  To scan the matrix, the microcontroller sequentially pulls the columns (pins labeled N) to power, and checks the level on the rows (pins labeled B).  If the level of a row is high, the key corresponding to the currently active column-row combination is pressed.  The diagram shows only a part of the keyboard - there are 76 keys on it (13 lines and 6 x 2 columns, which gives a total of 156 possible options when scanning the matrix and 25 used microcontroller pins).  Scanning the entire keyboard is carried out several dozen times per second and unnoticed by the performer. <br><br>  In my synthesizer, the microcontroller responsible for scanning the keyboard was originally an 8-bit, one-time programmable Hitachi HD63B05V0 microcontroller, operating at 8 MHz and having 4 KB of ROM and 192 bytes of RAM memory.  Unfortunately, this controller turned out to be inoperable after the power incident described at the beginning of the first article.  But, fortunately, it turned out to be almost pin-compatible with the ATmega162 controller I had, to which I replaced it, cutting and re-soldering only 2 tracks on the board, one of which was the RESET pin, which turned out to be in the wrong place like the HD63B05V0. <br><br>  Since the inclusion of the controller did not allow me to use the built-in UART (since it was also on the other outputs), I used <a href="http://www.avrfreaks.net/index.php%3Fname%3DPNphpBB2%26file%3Dviewtopic%26t%3D58886">this</a> one-way (write only) implementation of the serial port to display information about the keys pressed.  Also, the <a href="http://jtxp.org/tech/tinysafeboot_en.htm">TinySafeBoot</a> bootloader, also using the serial port software implementation, was flooded into the microcontroller to enable future firmware updates.  Since I chose Python + Qt5 as the language for the rapid development of all high-level synthesizer software, I also wrote a Python module for TinySafeBoot that allows you to read and write firmware to the AVR microcontroller.  The AVR microcontroller itself is connected to the UART1 serial port on the EmbedSky E8 board and is powered by 3.3V to avoid the need for level conversion. <br><br><div class="spoiler">  <b class="spoiler_title">Source code for AVR firmware</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;util/delay.h&gt; #include &lt;string.h&gt; #include "dbg_putchar.h" #define MIDI_BASE 18 #define ZERO_BASE 28 #define KEYS_COUNT 76 #define hiz(port, dir) do { \ (dir) = 0; \ (port) = 0; \ } while(0) #define alow(port, dir) do { \ (dir) = 0xff; \ (port) = 0; \ } while(0) uint8_t keys[KEYS_COUNT]; /* Get state of a row by its index * starting from 1 to 13 */ uint8_t getRow(uint8_t idx) { if (idx &lt;= 8) { return (PINC &amp; (1 &lt;&lt; (8 - idx))); } else if (idx &gt;= 9 &amp;&amp; idx &lt;= 11) { return (PINE &amp; (1 &lt;&lt; (11 - idx))); } else if (idx == 12) { return (PINA &amp; (1 &lt;&lt; PIN6)); } else if (idx == 13) { return (PINA &amp; (1 &lt;&lt; PIN4)); } return 0; } inline void activateColumn1(uint8_t idx) { PORTD = 0x00 | (1 &lt;&lt; (8 - idx)); PORTB = 0x00; } void activateColumn2(uint8_t idx) { if (idx &lt;= 3) { PORTB = 0x00 | (1 &lt;&lt; (idx + 4)); PORTD = 0x00; } else if (idx == 4) { PORTB = 0x00 | (1 &lt;&lt; PIN4); PORTD = 0x00; } else if (idx == 5 || idx == 6) { PORTD = 0x00 | (1 &lt;&lt; (idx - 5)); PORTB = 0x00; } } inline void deactivateColumns(void) { PORTD = 0x00; PORTB = 0x00; } inline void initPorts(void) { hiz(PORTA, DDRA); hiz(PORTC, DDRC); hiz(PORTE, DDRE); PORTB = 0x00; DDRB = 0xfe; DDRD = 0xff; } void resetRows(void) { /* output low */ alow(PORTC, DDRC); alow(PORTE, DDRE); /* don't touch PA7 &amp; PA5 */ DDRA |= 0x5f; PORTA &amp;= ~0x5f; _delay_us(10); /* back to floating input */ hiz(PORTC, DDRC); hiz(PORTE, DDRE); DDRA &amp;= ~0x5f; } /* base MIDI note number is 25: C#0 */ int main(void) { uint8_t row, col, layer; uint8_t note, offset; initPorts(); memset(keys, 0, sizeof(keys)); dbg_tx_init(); dbg_putchar('O'); dbg_putchar('K'); while(1) { for (layer = 0; layer &lt; 2; layer++) { for (col = 1; col &lt;= 6; col++) { if (!layer) activateColumn1(col); else activateColumn2(col); for (row = 1; row &lt;= 13; row++) { note = 6 * row + col + MIDI_BASE; offset = note - ZERO_BASE; if (getRow(row)) { if (!layer) { /* increase velocity counter */ if (keys[offset] &lt; 254 &amp;&amp; !(keys[offset] &amp; 0x80)) keys[offset]++; } else { if (!(keys[offset] &amp; 0x80)) { /* generate note-on event */ dbg_putchar(0x90); dbg_putchar(note); /*dbg_putchar(keys[offset]);*/ dbg_putchar(0x7f); /* stop counting */ keys[offset] |= 0x80; } } } else { if (layer) continue; if (keys[offset] &amp; 0x80) { /* generate note off event */ dbg_putchar(0x90); dbg_putchar(note); dbg_putchar(0x00); /* reset key state */ keys[offset] = 0x00; } } } deactivateColumns(); resetRows(); } } } return 0; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Python module for TinySafeBoot</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serial <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> binascii <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> intelhex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSB</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> CONFIRM = <span class="hljs-string"><span class="hljs-string">'!'</span></span> REQUEST = <span class="hljs-string"><span class="hljs-string">'?'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, port)</span></span></span><span class="hljs-function">:</span></span> self.port = serial.Serial(port, baudrate=<span class="hljs-number"><span class="hljs-number">9600</span></span>, timeout=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.flashsz = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.flashsz: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Not activated"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.port.write(<span class="hljs-string"><span class="hljs-string">"@@@"</span></span>) (self.tsb, self.version, self.status, self.sign, self.pagesz, self.flashsz, self.eepsz) = \ struct.unpack(<span class="hljs-string"><span class="hljs-string">"&lt;3sHB3sBHH"</span></span>, self.port.read(<span class="hljs-number"><span class="hljs-number">14</span></span>)) self.port.read(<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pagesz *= <span class="hljs-number"><span class="hljs-number">2</span></span> self.flashsz *= <span class="hljs-number"><span class="hljs-number">2</span></span> self.eepsz += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(self.port.read() == self.CONFIRM) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rflash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, progress=None, size=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> self.check() self.port.write(<span class="hljs-string"><span class="hljs-string">"f"</span></span>) self.addr = <span class="hljs-number"><span class="hljs-number">0</span></span> self.flash = <span class="hljs-string"><span class="hljs-string">""</span></span> size = self.flashsz <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> size <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> size <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.addr &lt; size: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> progress <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: progress(<span class="hljs-string"><span class="hljs-string">"read"</span></span>, self.addr, size) self.port.write(self.CONFIRM) page = self.port.read(self.pagesz) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(page) != self.pagesz: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Received page too short: %d"</span></span> % len(page)) self.addr += len(page) self.flash += page <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.flash.rstrip(<span class="hljs-string"><span class="hljs-string">'\xff'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wflash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, progress=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(data) % self.pagesz != <span class="hljs-number"><span class="hljs-number">0</span></span>: data = data + <span class="hljs-string"><span class="hljs-string">"\xff"</span></span> * (self.pagesz - (len(data) % self.pagesz)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(len(data) % self.pagesz == <span class="hljs-number"><span class="hljs-number">0</span></span>) self.check() self.port.write(<span class="hljs-string"><span class="hljs-string">"F"</span></span>) self.addr = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(self.port.read() == self.REQUEST) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.addr &lt; len(data): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> progress <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: progress(<span class="hljs-string"><span class="hljs-string">"write"</span></span>, self.addr, len(data)) self.port.write(self.CONFIRM) self.port.write(data[self.addr:self.addr + self.pagesz]) self.addr += self.pagesz <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(self.port.read() == self.REQUEST) self.port.write(self.REQUEST) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.port.read() == self.CONFIRM <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vflash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data, progress=None)</span></span></span><span class="hljs-function">:</span></span> fw = self.rflash(progress, len(data)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fw == data <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Tiny Safe Bootloader: %s"</span></span> % self.tsb <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Page size: %d"</span></span> % self.pagesz <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Flash size: %d"</span></span> % self.flashsz <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"EEPROM size: %d"</span></span> % self.eepsz <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">progress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op, addr, total)</span></span></span><span class="hljs-function">:</span></span> sys.stdout.write(<span class="hljs-string"><span class="hljs-string">"\r%s address: $%0.4x/$%0.4x"</span></span> % (op, addr, total)) sys.stdout.flush() parser = argparse.ArgumentParser() parser.add_argument(<span class="hljs-string"><span class="hljs-string">"filename"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"firmware file in Intel HEX format"</span></span>) parser.add_argument(<span class="hljs-string"><span class="hljs-string">"--device"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Serial port to use for programming"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"/dev/ttyUSB0"</span></span>) args = parser.parse_args() tsb = TSB(args.device) tsb.activate() tsb.info() fw = intelhex.IntelHex(args.filename) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(tsb.wflash(fw.tobinstr(), progress)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(tsb.vflash(fw.tobinstr(), progress)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"\nOK\n"</span></span></code> </pre><br></div></div><br>  As a programmer for the AVR, I first used <a href="http://gpio.kaltpost.de/%3Fp%3D1148">a Launchpad MSP430 programmer</a> , of which I have several pieces, and then this self-made miracle (not bad working, by the way), gave way to the TL866CS MiniPro programmer from China.  The sensations from the new programmer are extremely positive. <br><br>  A very detailed description of the synthesizer's keyboard device and methods for scanning it, including one very original way of scanning via the AVR microcontroller interface for connecting an external RAM chip, is described on the <a href="http://www.openmusiclabs.com/learning/digital/input-matrix-scanning/xmem/">OpenMusicLabs</a> website <br><br><h5>  Realtime Preemption Core Cooking </h5><br>  Partly to get more control over the scheduler and reduce latency when playing a sound, and partly from sports interest, I decided to use the <a href="https://rt.wiki.kernel.org/index.php/RT_PREEMPT_HOWTO">PREEPMT RT kernel</a> , one of the main features of which is that interruptions also become ‚Äúprocesses‚Äù that can be preempted by the scheduler given priority.  The original core, supplied by Samsung for the processor S5PV210, on the basis of which the system is built, is based on the kernel version 3.0.8, apparently from Android.  None of the RT_PREEMPT patches available on the project site intended for this kernel version (3.0.8), did not want to overlap the source without conflicts, but in the end, by resolving all conflicts manually, we managed to patch the version 3.0.8-rt23. <br><br>  Due to the fact that the basic structures such as spinlock and mutex were also modified in the kernel modified in this way, the proprietary drivers of some peripheral devices, such as a video camera, a capacitive touchscreen controller, and, most terrible, were ceased to be linked to it. audio codec.  Let us return to them later, and now turn them off and try for the first time to start the board with a freshly assembled real-time kernel and ... get an instant kernel panic.  It occurred even before running the kgdb debugger (which, as it turned out later, would not have worked anyway, even if it had started), so for debugging I had to insert printfs into the <code>init/main.c</code> file, the <code>start_kernel</code> function, to determine the location, in which everything collapses.  Thus, it turned out that the last thing the kernel <code>hrtimers_init()</code> do was call the <code>hrtimers_init()</code> function, which initializes the high-resolution timers and interrupts them.  This code depends on the specific platform, and in our case is in <code>arch/arm/plat-s5p/hr-time-rtc.c</code> .  As I said, one of the main features of the kernel with the PREEMPT RT patch is that interrupts become threads.  This is also possible in a regular kernel, but the kernel with PREEMPT RT by default tries to do almost all interrupts.  Further analysis of the code showed that the kthreadd_task task is used for these threads, which is initialized at the very end of the <code>start_kernel</code> function ‚Äî much later than the initialization of the timers occurs.  The fall occurred due to the fact that the kernel interrupted the timer interrupt and made it threaded, while kthreadd_task was still NULL.  This is solved by setting for individual interrupts that should not be streamed under any circumstances, the IRQF_NO_THREAD flag which was added to the timer interrupt flags in <code>hr-time-rtc.c</code> .  Hooray!  The kernel has booted, but this is just the beginning ... <br><br>  As I mentioned above, one of the side effects was that the module responsible for audio I / O stopped linking to the new kernel.  This was partly because the kernel with PREEMPT RT supports (in version 3.0.8) only the SLAB memory management mechanism, and the module was originally compiled with the SLUB mechanism turned on, which is not supported by the new kernel.  However, I was lucky to work at Kaspersky Lab, and I persuaded a colleague to decompile the driver and codec files for me using the Hex-Rays decompiler for ARM, after which they managed to almost completely recreate their source code.  Practically, because as a result, with the ‚Äúnew‚Äù driver, the audio interface was determined, however, due to some differences in the low-level register initialization procedure of the WM8960 chip, the sound was played with artifacts.  For some time I tried to fix my driver, but then I chose an easier way - I sent a technical support to EmbedSky Tech, a Chinese company, where I bought a mini-computer, my PREEMPT_RT patch, and asked them to compile for me and send the audio driver files.  The guys quickly responded and sent me files, with which the sound finally worked as expected. <br><br>  By the way, while I was messing with my decompiled driver, I found that the kgdb debugger does not work with either my or the original kernel.  As it turned out, his work requires the support of synchronous (polling) polling of the serial port, which was absent in the Samsung serial port driver ( <code>drivers/tty/serial/samsung.c</code> ).  I added the required support to the driver based on <a href="https://lkml.org/lkml/2012/9/22/11">this</a> patch, after which the debugger started working. <br><br>  We dig further.  The second side effect of the new core was extremely low, with large ‚Äúlags‚Äù, the speed of all four long-suffering serial ports of the system on the S5PV210 chip, as a result of which normal operation in the terminal through the serial port was impossible, and also did not work as it should be done by flashing the AVR controller, Keyboard Keyboard synthesizer.  For a long time I tried to understand the reason, but noticed only that the input of each character in the terminal led to the generation of several million serial port interrupts - the kernel did not seem to be in a hurry to process them.  In the end, I solved this problem by using the above-mentioned IRQF_NO_THREAD flag to make all interrupt on serial ports non-streaming.  This decision was not very beautiful, because in addition to the Samsung driver had to make changes to the files <code>serial_core.c</code> and <code>serial_core.h</code> , affecting in general all serial ports.  Because in the PREEMPT RT kernel, you cannot use spin_lock_t in drivers that are NO_THREAD, but you must use raw_spinlock_t. <br><br>  In the original core, which, as I said above, supports various peripheral devices, such as video cameras, hardware codecs, HDMI, etc., only about 390 MB of 512 MB of RAM were available and the rest was reserved for the above devices , and always (even if they were disabled during the kernel configuration process).  It is very wasteful, especially considering that the extra 120 MB of RAM will not even interfere with the synthesizer for storing samples.  Memory was reserved in the file <code>arch/arm/mach-s5pv210/mach-tq210.c</code> , which is the main collection point for all the information about the configuration and devices of a particular machine (in our case, the boards).  We comment on the allocation of memory - a call to the function <code>s5p_reserve_bootmem</code> , and we get 120 MB of additional memory for the synthesizer to work. <br><br>  The last change that was made to the core concerned the minimum buffer size for audio data, which in the original was equal to one memory page, which at a sampling frequency of 44100 Hz, 2 channels of 16 bits each gave about 20 ms ‚Äî a bit too much.  This value was changed in the <code>sound/soc/samsung/dma.c</code> to 128 bytes, after which the minimum buffer size was reduced to a few milliseconds without compromising stability and performance. <br><br>  <a href="https://github.com/madprogrammer/linux-e8-rt/tree/synth">Kernel source code with PREEMPT RT and all modifications on GitHub</a> <br><br><h5>  How does the AVR microcontroller communicate with LinuxSampler </h5><br>  The AVR is connected to the minicomputer's serial port, and spits out ready-made MIDI messages to its software UART.  In order to rid himself of the need to write drivers, it was decided to use the JACK server as a transport for all audio and MIDI data.  A small C application connects to the serial port, registers itself with JACK as MIDI-OUT and starts redirecting all received MIDI messages, and JACK already delivers them to LinuxSampler.  Cheap and angry. <br><br><div class="spoiler">  <b class="spoiler_title">Source code of the bridge application between the serial port and JACK</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;assert.h&gt; #include &lt;string.h&gt; #include &lt;sysexits.h&gt; #include &lt;errno.h&gt; #include &lt;signal.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;jack/jack.h&gt; #include &lt;jack/midiport.h&gt; #define UART_SPEED B9600 jack_port_t *output_port; jack_client_t *jack_client = NULL; int input_fd; void init_serial(int fd) { struct termios termios; int res; res = tcgetattr (fd, &amp;termios); if (res &lt; 0) { fprintf (stderr, "Termios get error: %s\n", strerror(errno)); exit (EXIT_FAILURE); } cfsetispeed (&amp;termios, UART_SPEED); cfsetospeed (&amp;termios, UART_SPEED); termios.c_iflag &amp;= ~(IGNPAR | IXON | IXOFF); termios.c_iflag |= IGNPAR; termios.c_cflag &amp;= ~(CSIZE | PARENB | CSTOPB | CREAD | CLOCAL); termios.c_cflag |= CS8; termios.c_cflag |= CREAD; termios.c_cflag |= CLOCAL; termios.c_lflag &amp;= ~(ICANON | ECHO); termios.c_cc[VMIN] = 3; termios.c_cc[VTIME] = 0; res = tcsetattr (fd, TCSANOW, &amp;termios); if (res &lt; 0) { fprintf (stderr, "Termios set error: %s\n", strerror(errno)); exit (EXIT_FAILURE); } } double get_time(void) { double seconds; int ret; struct timeval tv; ret = gettimeofday(&amp;tv, NULL); if (ret) { perror("gettimeofday"); exit(EX_OSERR); } seconds = tv.tv_sec + tv.tv_usec / 1000000.0; return seconds; } double get_delta_time(void) { static double previously = -1.0; double now; double delta; now = get_time(); if (previously == -1.0) { previously = now; return 0; } delta = now - previously; previously = now; assert(delta &gt;= 0.0); return delta; } static double nframes_to_ms(jack_nframes_t nframes) { jack_nframes_t sr; sr = jack_get_sample_rate(jack_client); assert(sr &gt; 0); return (nframes * 1000.0) / (double)sr; } static double nframes_to_seconds(jack_nframes_t nframes) { return nframes_to_ms(nframes) / 1000.0; } static jack_nframes_t ms_to_nframes(double ms) { jack_nframes_t sr; sr = jack_get_sample_rate(jack_client); assert(sr &gt; 0); return ((double)sr * ms) / 1000.0; } static jack_nframes_t seconds_to_nframes(double seconds) { return ms_to_nframes(seconds * 1000.0); } static void process_midi_output(jack_nframes_t nframes) { int t, res; void *port_buffer; char midi_buffer[3]; jack_nframes_t last_frame_time; port_buffer = jack_port_get_buffer(output_port, nframes); if (port_buffer == NULL) { printf("jack_port_get_buffer failed, cannot send anything.\n"); return; } jack_midi_clear_buffer(port_buffer); last_frame_time = jack_last_frame_time(jack_client); t = seconds_to_nframes(get_delta_time()); res = read(input_fd, midi_buffer, sizeof(midi_buffer)); if (res &lt; 0 &amp;&amp; errno == EAGAIN) return; res = jack_midi_event_write(port_buffer, t, midi_buffer, 3); if (res != 0) { printf("jack_midi_event_write failed, NOTE LOST."); } } static int process_callback(jack_nframes_t nframes, void *notused) { if (nframes &lt;= 0) { printf("Process callback called with nframes = 0; bug in JACK?"); return 0; } process_midi_output(nframes); return 0; } int connect_to_input_port(const char *port) { int ret; ret = jack_port_disconnect(jack_client, output_port); if (ret) { printf("Cannot disconnect MIDI port."); return -3; } ret = jack_connect(jack_client, jack_port_name(output_port), port); if (ret) { printf("Cannot connect to %s.", port); return -4; } printf("Connected to %s.", port); return 0; } static void init_jack(void) { int i, err; jack_client = jack_client_open("midibridge", JackNullOption, NULL); if (jack_client == NULL) { printf("Could not connect to the JACK server; run jackd first?"); exit(EXIT_FAILURE); } err = jack_set_process_callback(jack_client, process_callback, 0); if (err) { printf("Could not register JACK process callback."); exit(EXIT_FAILURE); } char port_name[32]; snprintf(port_name, sizeof(port_name), "midi_out"); output_port = jack_port_register(jack_client, port_name, JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0); if (output_port == NULL) { printf("Could not register JACK output port '%s'.", port_name); exit(EXIT_FAILURE); } if (jack_activate(jack_client)) { printf("Cannot activate JACK client."); exit(EXIT_FAILURE); } } static void usage(void) { fprintf(stderr, "usage: midibridge -a &lt;input port&gt;\n"); exit(EXIT_FAILURE); } int main(int argc, char *argv[]) { int ch; char *autoconnect_port_name = NULL; while ((ch = getopt(argc, argv, "a:")) != -1) { switch (ch) { case 'a': autoconnect_port_name = strdup(optarg); break; default: usage(); } } input_fd = open("/dev/ttySAC1", O_RDWR | O_NOCTTY | O_NDELAY | O_NONBLOCK); if (input_fd &lt; 0) { fprintf(stderr, "Cannot open serial port %s\n", strerror(errno)); return EXIT_FAILURE; } init_serial (input_fd); init_jack(); if (autoconnect_port_name) { if (connect_to_input_port(autoconnect_port_name)) { printf("Couldn't connect to '%s', exiting.", autoconnect_port_name); exit(EXIT_FAILURE); } } getc(stdin); return 0; }</span></span></span></span></code> </pre><br></div></div><br><br>  This solution also allows you to play MIDI files via JACK using <code>jack-smf-player</code> , which I compiled for ARM and WAV / MP3 via mplayer with support for audio output in JACK. <br><br><h5>  Bonus </h5><br>  Thanks to the <a href="https://habrahabr.ru/users/nefelim4ag/" class="user_link">nefelim4ag</a> comment to the previous post, I learned about the existence of libhybris, a library that allows using Android drivers in a regular Linux system.  After some dances with tambourines, all the details of which I, unfortunately, no longer remember, I managed to get libhybris in my system and rebuild Qt 5 and PyQt5 with support for OpenGL ES 2.0, EGLFS and Qt Quick 2.0.  Now my user interface is using Qt Quick and <s>looks in accordance with the latest fashion trends</s> mowed under Android 4.0. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/662/6e8/dd9/6626e8dd950794cef42ff300f752b068.png"><br><br><h5>  At last </h5><br>  A small <a href="https://soundcloud.com/sergey-anufrienko/linuxsampler-demo">demo</a> is only audio for now, since the synthesizer is now in a half-disassembled state.  The video will be in the next post, which will most likely be born in August, after the board ordered in China arrives, bringing together all the parts of the synthesizer.  In addition, the next post will most likely be devoted not to such a low-level manipulation of the kernel, but to the process of bringing to the mind the user part of the software on PyQt5 and QtQuick and, of course, demonstrating the resulting <br><br>  If anyone is interested: <br><div class="spoiler">  <b class="spoiler_title">List of all software that was cross-compiled for ARM</b> <div class="spoiler_text"><ul><li>  alsa-lib-1.0.27.2 </li><li>  alsa-utils-1.0.27.2 </li><li>  libaudiofile-0.3.6 </li><li>  dbus-1.8.0 </li><li>  dropbear-2014.63 </li><li>  fftw-3.3.3 </li><li>  fluidsynth-1.1.6 </li><li>  fontconfig-2.11.0 </li><li>  freetype-2.5.3 </li><li>  glib-2.34.3 </li><li>  libicu-52.1 </li><li>  jack-audio-connection-kit-0.121.3 </li><li>  jack-smf-utils-1.0 </li><li>  libffi-3.0.13 </li><li>  libgig-3.3.0 </li><li>  libgig-svn </li><li>  libhybris </li><li>  libsamplerate-0.1.8 </li><li>  libsndfile-1.0.25 </li><li>  linuxsampler-1.0.0 </li><li>  linuxsampler-svn </li><li>  mplayer SVN-r36900-4.4.6 </li><li>  openssl-1.0.0l </li><li>  psutil-1.2.1 </li><li>  pyjack-0.5.2 </li><li>  PyQt-gpl-5.2 </li><li>  pyserial-2.7 </li><li>  Python-2.7.6 </li><li>  strace-4.8 </li><li>  tslib-1.4.1 </li></ul><br></div></div><br>  If you need to collect something from this list and have any problems, I will be happy to share my experience.  In addition, much of what has been said here is true for another popular platform called FriendlyARM Tiny210, which is based on the same S5PV210 processor and maybe someone will need to use a real-time kernel with it. </div><p>Source: <a href="https://habr.com/ru/post/224987/">https://habr.com/ru/post/224987/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224975/index.html">Experience of offline / online courses in Ruby on Rails with mandatory RE</a></li>
<li><a href="../224977/index.html">Android monster named FunLib</a></li>
<li><a href="../224979/index.html">VIM as an IDE for Python development</a></li>
<li><a href="../224981/index.html">Practical application of Master Data Services in MS SQL Server 2012</a></li>
<li><a href="../224983/index.html">WWDC 2014: iOS 8 and OS X Yosemite (10.10)</a></li>
<li><a href="../224991/index.html">Yandex will place its shares on the Moscow Exchange</a></li>
<li><a href="../224993/index.html">Capsule Audio System</a></li>
<li><a href="../224999/index.html">The latest addition to Visual Studio for creating cross-platform applications in HTML and JavaScript</a></li>
<li><a href="../225001/index.html">Solar Impulse 2 successfully completed its first flight</a></li>
<li><a href="../225003/index.html">Comparing Rust and C ++ with examples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>