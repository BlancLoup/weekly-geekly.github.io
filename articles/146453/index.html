<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Develop sms blacklist for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habrasoobschestvu! 

 Based on the answers to my question , I publish this topic. ‚ÄúAntispam‚Äù is a somewhat loud name for the application m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Develop sms blacklist for Android</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habrasoobschestvu! <br><br>  Based on the answers to my <a href="http://habrahabr.ru/qa/19750/">question</a> , I publish this topic.  ‚ÄúAntispam‚Äù is a somewhat loud name for the application made, since at this stage it represents only the black list of senders.  However, in the future I plan to make really antispam with automatic filtering.  The material below is designed for those who are at least a little familiar with developing for Android and have taken at least some steps to develop their own application, since I will not talk about creating an entire application from scratch, but only tell about the most interesting and important points.  Who cares, welcome under cat. <br><br><a name="habracut"></a><br><h4>  Do you remember how it all started? </h4><br>  A small lyrical digression.  It all started with the fact that I somewhere leaked my mobile phone number.  I even suspect exactly where, because my friends who registered on the same site as me receive the same spam messages at the same time.  But now is not about that.  On Fridays, ads for various clubs began to come to me, and every week the flow of messages only increased.  Since I became the owner of the phone based on the Android OS, I decided to make an application that will fight against this disgrace.  Programmers never look for easy ways - I didn‚Äôt want to go to a mobile operator, and besides, I had long wanted to start developing for Android. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The architecture and layout of the application </h4><br>  The application consists of three parts: <br><ol><li>  Actually a filter that receives and filters SMS messages; </li><li>  A database that stores the black list of senders and messages received from them; </li><li>  User interface. </li></ol><br>  How does all this work?  The user adds to the black list of senders either from the "Inbox" or from the "Contacts".  Turns on the filter and closes the application.  When a message is received, the application analyzes its sender, and if it is in the black list, it places the message in the so-called repository, so that the user can later see the filtered messages.  If the sender is ‚Äúclean‚Äù, then the SMS will go to the Inbox. <br><br><h4>  First prototype </h4><br>  No sooner said than done.  However, the implementation of the first prototype did not last a day.  The fact is that I tried to catch an event about receiving a text message, and in the event handler for this event, delete from the Inbox folder all messages whose senders were blacklisted.  The problem is that the owner of the phone would still hear a signal informing you that the SMS was received, and when opening the inbox, you would not see anything new there!  And this is somehow not good.  Therefore, I began to look for a way to intercept a message, even before it goes to the Inbox. <br><br><h4>  Interception of messages </h4><br>  Android OS is designed so that about such events as receiving SMS, turning on WI-FI, connecting the charging and the like, the system informs applications via broadcasting.  More information about this mechanism and the whole architecture of Android can be read <a href="http://habrahabr.ru/post/141504/">here (4 translations)</a> .  To create a recipient (listener) for such a system broadcast, you must: <br><ol><li>  Create your own class inherited from BroadcastReceiver and overload the onReceive method; </li><li>  Register it in the system and specify which types of mailings we want to receive. </li></ol><br><br><h4>  Creating a listener </h4><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SMSReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ Bundle bundle = intent.getExtras(); Object[] pdus = (Object[]) bundle.get(<span class="hljs-string"><span class="hljs-string">"pdus"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pdus.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Sms sms = Sms.fromPdus(pdus, context); SmsDatabase db = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { db = SmsDatabase.open(context); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Filter.filter(context).isSpam(sms, db)) { abortBroadcast(); db.messages().save(sms); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (db != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) db.close(); } } }</code> </pre> <br><br>  The onReceive method works every time an SMS message arrives on the phone.  You can extract all the necessary information from the intent parameter.  <b>Attention</b> , according to the documentation, the class inherited from BroadcastReceiver is relevant only during the execution of the onReceive method.  This means that the system can destroy an instance of the class as soon as the execution of the specified method ends.  It also means that you should not store any information in non-static class fields. <br><br>  In the first two lines, we extract the <a href="http://en.wikipedia.org/wiki/Protocol_data_unit">PDU</a> information.  Roughly speaking, it is SMS in "raw" form.  After checking for emptiness, we are trying to extract information about the message using the static fromPdus () method in the sms class, which will be described later. <br><br>  Then we use the Filter class to check if the sender of the newly received SMS is in the black list.  If it is found that we are saving the message in the database and using the abortBroadcast () method, we interrupt the newsletter.  This means that all recipients with a lower priority who are registered to receive SMS notification will not even know that such an event took place.  We will set our recipient the highest priority (even higher than the recipient, which makes sounds and vibrates with the device) so as not to disturb the user in case of receiving a spam message.  Read about priorities below. <br><br>  In the previous version of the application, in the onReceive method, the database connection was opened twice: the first time in the Filter class when checking a message, and the second time directly when writing sms to the database.  However, I refused such an approach and made the code ‚Äúslightly more incorrect‚Äù from the point of view of the ‚Äúprettiness‚Äù of the code, since the execution time of the onReceive method is limited to 10 seconds and it makes no sense to open two connections in a row.  After all, if our method does not meet the allotted time, then Android will call the method of the next recipient and then the user will be informed about receiving SMS. <br><br><h4>  Registration of the listener </h4><br>  We wrote a listener.  It remains to register his system.  This can be done in two ways: <br><ol><li>  Programmatically using the registerReceiver () method.  In this case, the recipient will live only as long as the component that registered it is alive (as a rule, this is the Activity); </li><li>  Using AndroidManifest.  In this case, the recipient will live, even if the application is closed, and moreover, even if the phone is restarted! </li></ol><br><br>  Obviously, the 2nd option is more acceptable.  Let's see how it can be implemented: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@drawable/app_icon"</span></span></span><span class="hljs-tag">&gt;</span></span> ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶.    ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶.. <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">receiver</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".SMSReceiver"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:enabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:priority</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1000"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.provider.Telephony.SMS_RECEIVED"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">receiver</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Everything is very simple here.  Specify the recipient's class name (android: name), and then use the intent-filter tag to specify the priority (android: priority, 1000 is the maximum value; for the standard recipient that vibrates and makes sounds, priority 999) and which events we subscribe to ( android.provider.Telephony.SMS_RECEIVED). <br><br><h4>  Turning the listener on and off </h4><br>  It should be said that the recipient is off by default.  From this it follows that the user has the ability to turn the filter on and off by activating and deactivating the recipient of the SMS.  In the Filter class, there are corresponding on (), off () and enabled () methods for this. <br><br>  The Filter class, by the way, is a singleton class, since we must have one filter for the entire application, despite the fact that it depends on the context (Context).  In the SMSReceiver class, you could see how a filter instance is accessed through the static filter () method, which accepts an instance of the Context class as a parameter. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Filter _filter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Filter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_filter == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !_filter._context.equals(context)) { _filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Filter(context); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _filter; }</code> </pre><br><br>  I am by no means arguing that such a implementation is the only true one.  If you can offer a better solution, then I will consider it with pleasure. <br><br>  In the Filter class constructor, initialize the necessary work data: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ComponentName componentName; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PackageManager packageManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Context _context; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ _context = context; String packageName = context.getPackageName(); String receiverComponent = packageName + <span class="hljs-string"><span class="hljs-string">".SMSReceiver"</span></span>; componentName = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComponentName(packageName, receiverComponent); packageManager = context.getPackageManager(); }</code> </pre><br><br>  componentName is the full name of the application component, in this case, the recipient, which includes the package name and class name (SMSReceiver). <br>  packageManager - it is clear from the title that this is a class for managing application components. <br><br>  Consider a method that includes a filter: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!enabled()) { packageManager.setComponentEnabledSetting(componentName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Util.showMessage(_context.getString(R.string.alreadyStarted), _context); } }</code> </pre><br><br>  It's simple.  If the component is already enabled (enabled () is a self-written method, we will consider it a bit later), then we inform the user about it, but if it is disabled, we enable it.  The static class Util is self-written and includes various auxiliary functions.  In this case, the showMessage method uses the standard Toast class to display messages on the screen. <br><br>  The off () method, which disables the filter, is completely similar to the on () method, except that the PackageManager.COMPONENT_ENABLED_STATE_DISABLED flag is used, and if the filter is already turned off, a corresponding message is displayed. <br><br>  The method that checks the state of the filter is even simpler: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enabled = packageManager.getComponentEnabledSetting(componentName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (enabled == PackageManager.COMPONENT_ENABLED_STATE_ENABLED); }</code> </pre><br><br><h4>  Check for lice </h4><br>  In the Filter class, there is another method that has not been described.  This is the isSpam () method, which, in fact, performs the main task of the application.  The method is extremely simple.  It extracts messages from the sender from the SMS and tries to find it in the database.  If there is one, the message is considered spam. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isSpam</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sms sms, SmsDatabase db)</span></span></span><span class="hljs-function"> </span></span>{ Sender sender = sms.sender(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.senders().exists(sender); }</code> </pre><br><br><h4>  Sms class </h4><br>  Sms class has already been mentioned twice.  It would be necessary to tell about it in more detail.  This class serves as a representation of SMS messages in the application.  It contains the following fields: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String _body; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Sender _sender; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> _timestamp;</code> </pre><br><br>  where _body is the message body, _sender is the sender of the message _timestamp is the time when the message was received as a UNIX timestamp. <br><br>  Sender class is not standard for Android.  It is handwritten and can store the sender's phone, and also, if necessary, extract the sender's name from the phone book.  We will not consider it in detail. <br><br>  We already know that the Sms class has a static fromPdus () method that retrieves message information from the PDU.  Let's look at its code: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Sms </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromPdus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object[] pdus, Context context)</span></span></span><span class="hljs-function"> </span></span>{ Sms result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sms(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pdus.length; i++) { SmsMessage sms = SmsMessage.createFromPdu((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]) pdus[i]); result._body += sms.getMessageBody(); } SmsMessage first = SmsMessage.createFromPdu((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]) pdus[<span class="hljs-number"><span class="hljs-number">0</span></span>]); result._sender = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sender(first.getOriginatingAddress(), context); result._timestamp = first.getTimestampMillis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  At first glance, the method may seem complicated.  However, it is not.  The only difficulty is that one logical SMS message can be split into several physical ones.  I think that in this respect I have not discovered America for you.  This special effect is familiar to all who always write without spaces, to shove as much information as possible into one SMS and save their money. <br><br>  Thus, we in a cycle collect the message body piece by piece, and then extract the necessary information from the very first SMS message.  In general, with the Sms class you can finish it. <br><br><h4>  A little bit about the database </h4><br>  Blacklisted arrogant spammers, as well as the results of their unrecognized creativity are stored in a database.  This is necessary so that the user can see what he saw there.  After all, theoretically, the user can add to the blacklist and phone number from his contacts, and after reconciling with its owner, he may want to read the SMS received from him. <br><br>  We were lucky, because in Android, SQLite goes straight out of the box.  I implemented all the logic of working with the database using standard JAVA classes and SQL queries.  According to the law of meanness, after I finished this part of the application, I read <a href="http://habrahabr.ru/post/143431/">an</a> ORM <a href="http://habrahabr.ru/post/143431/">article</a> for Android on Habr√©. <br><br>  Working with the database I have built on the principle: opened the connection - worked with the data - closed the connection.  This practice is especially good for SQLite, since this DBMS is file-based and blocking may occur during a read or write operation.  Therefore, I try not to keep long-lived connections. <br><br>  I wouldn‚Äôt like to consider all the wrapper methods for the database, as there are many of them, and the article is not rubber.  In addition, they are all of the same type, so to understand the essence, we consider only the method that we saw in the onReceive method of the SMSReceiver class. <br><br>  The record ‚Äúdb.messages (). Save (sms)‚Äù tells us that within the db connection we refer to the Messages table, which stores the filtered messages, and add a new sms message to it using the save () method.  I repeat that all classes and methods are self-written. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sms sms)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Preferences.get(_context).storeSms()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxCount = Preferences.get(_context).storedSmsAmount(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count() &gt;= maxCount) trim(maxCount - <span class="hljs-number"><span class="hljs-number">1</span></span>); SQLiteStatement insert = _db.compileStatement( <span class="hljs-string"><span class="hljs-string">"INSERT INTO Messages(Phone, Timestamp, Body)"</span></span> + <span class="hljs-string"><span class="hljs-string">"VALUES (?, ?, ?)"</span></span>); insert.bindString(<span class="hljs-number"><span class="hljs-number">1</span></span>, sms.sender().phone()); insert.bindLong(<span class="hljs-number"><span class="hljs-number">2</span></span>, sms.timestamp()); insert.bindString(<span class="hljs-number"><span class="hljs-number">3</span></span>, sms.body()); insert.execute(); }</code> </pre><br><br>  The first line of code we get access to the settings of the application and check the flag responsible for the user's desire to store the filtered messages.  If the user refused to store, then just exit. <br><br>  Then, again, from the settings, we retrieve the size of the filtered SMS storage set by the user.  And if the current number of messages is larger than this size, we delete the old messages from the storage, taking into account the order in which they were received.  That is, the first messages to be deleted will be deleted first.  Classic lineup. <br><br>  After these gestures, we form a request to insert data into the Messages table and, using typed bind () methods, bind the data to the generated query.  At the end we execute the request. <br><br><h4>  Testing and debugging </h4><br>  It seems everything is ready.  It remains a small step.  The question is, how can we make sure that the application functions correctly?  What does the recipient get at all, but does the database save something?  I will not tell you about the Unit-testing of applications for Android, since this is a topic for a separate large topic.  I'll tell you only about how to simulate receiving SMS on the emulator. <br><br>  To do this, open any telnet client.  Depending on my mood, I use either Putty or the standard client in Windows 7 (which you must first turn on).  Connect to localhost, and specify the port displayed in the window title with the emulator as the port.  As a rule, it is 5554. It goes without saying that in this case the emulator should be running.  After reading the greeting, you can begin to enter commands. <br><br>  There are a lot of teams.  Their list can be obtained by typing the command ‚Äúhelp‚Äù.  With the help of these commands you can simulate many events that can occur with the phone.  However, we are only interested in imitation of receiving SMS messages. <br><br>  To simulate this, just type the command <br><pre> <code class="dos hljs">sms send _ _</code> </pre><br>  where telephone_number is any sequence of digits that may begin with a ‚Äú+‚Äù sign, and text_mouse is the content of the message, including spaces and other characters that we usually write in SMS. <br><br>  In case of successful simulation, we will see the message ‚ÄúOK‚Äù in the telnet client terminal. <br><br><h4>  Conclusion </h4><br>  In this topic, I tried to reveal the main technical details of my application, pay attention to the pitfalls and some features of the Android platform.  The latest version of the application can be <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.dpforge.spamkiller">downloaded</a> for <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.dpforge.spamkiller">free</a> from Google Play. <br><br>  If you have any questions or you have any suggestions, I will be grateful if you write about it in the comments or in private messages.  Constructive criticism is welcome.  Thanks for attention! <br><br>  PS: I am sorry that I did not insert screenshots.  And so it turned out quite a lot of material, and I don‚Äôt know what needs to be explained from the above.  If you do not agree with me, then I will definitely correct the topic. </div><p>Source: <a href="https://habr.com/ru/post/146453/">https://habr.com/ru/post/146453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146448/index.html">Five useful services for social integration of your site</a></li>
<li><a href="../146449/index.html">Unit testing in Qt</a></li>
<li><a href="../146450/index.html">OpenVPN server on CentOS</a></li>
<li><a href="../146451/index.html">Droider Show # 46. Fak Yu, Siri!</a></li>
<li><a href="../146452/index.html">Create and delete shortcuts</a></li>
<li><a href="../146454/index.html">Management of a network of online stores in 1C 8.2 through PHPShop "1C-Monitor"</a></li>
<li><a href="../146455/index.html">Mass add / remove hosts in Zabbix using API</a></li>
<li><a href="../146456/index.html">IT Compote # 11 Programming and Technology Podcast</a></li>
<li><a href="../146457/index.html">Microsoft has blocked the donation site FSF as "gambling"</a></li>
<li><a href="../146458/index.html">Russian Code Cup 2012: detailed analysis of tasks from the qualifying round (semi-final)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>