<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Raytracer javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do you know what is raytracer? This is a program that draws a three-dimensional scene on the screen as you would see it. Of course, not quite so, but ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Raytracer javascript</h1><div class="post__text post__text-html js-mediator-article"><img alt="TitleImage" src="https://habrastorage.org/storage/be79e6a6/235601ef/deccc690/9e5ceffb.png"><br><br>  Do you know what is raytracer?  This is a program that draws a three-dimensional scene on the screen as you would see it.  Of course, not quite so, but some raytracers can draw very realistic images, for example, as in <a href="http://www.nvidia.com/object/wetadigital_avatar.html">Avatar</a> . <br><br>  The idea of ‚Äã‚Äãa raytracer is very simple and in this article I will tell you how this algorithm works and even write it in JavaScript.  Pictures and an example are attached. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  How to draw three-dimensional scenes? </h4><br><br>  Today, as far as I know, there are two methods for designing three-dimensional scenes on a flat screen.  The first method is based on matrix transformations.  His idea is also simple, it works quickly, but what he draws is not like a photo and is suitable only for games.  The second method is raytracing.  It is simply arranged, it makes it easy to depict shadows, reflections, refraction and other lighting effects, but it works very slowly and therefore is not suitable for games.  In addition, the raytracing algorithm is easily parallelized: how many processors there are, exactly as many times there will be acceleration. <br><br><h4>  The idea of ‚Äã‚Äãthe algorithm </h4><br><br>  Imagine that the monitor behind which you are sitting is this window, and outside the window is some sort of scene.  The color of each pixel on the monitor is the color of the beam that comes out of the eye, passes through that pixel and collides with the scene.  To find out the color of each pixel, you need to launch a ray through each pixel and find out where this ray collides with the scene.  Hence the name of the algorithm: ray-tracing - ray tracing. <br><br>  It turns out that it is enough to write a function that, by the coordinates of the ray - two points in space - calculates the color of the surface where that ray falls.  What situations need to be considered?  There are at least three: <br><br><ol><li>  <b>Normal surface.</b>  When a beam collides with such, it can be said that the color of the beam is the color of this surface.  This is the easiest case. </li><li>  <b>Reflection.</b>  The beam can get into the mirror and reflect at the same angle.  To handle this situation, you must be able to reflect the beam. </li><li>  <b>Refraction.</b>  The beam can pass through the edge of two media, for example, from air to water.  When moving from one medium to another, the beam is refracted.  This phenomenon is called refraction. </li></ol><br><br>  Each of these situations is easily handled, so writing a reystrayser is not difficult. <br><br><h4>  Scene </h4><br><br>  On the stage there are two types of objects: objects that need to be drawn on the screen and light sources.  For simplicity, there will be only spheres, cubes (parallelepipeds) and point sources of light that shine evenly in all directions around them.  Any subject should be able to do three things or, in other words, have three methods: <br><br><ol><li>  <b>norm</b> (p) finds the normal to the surface of the object at point p.  The normal is outward and has a length of 1. </li><li>  <b>color</b> (p) says what color is on the surface of the object at point p. </li><li>  <b>trace</b> (ray) goes along the ray of ray and stops where the ray crosses the surface of the object.  This method returns the intersection coordinates and the distance from the beginning of the ray to the intersection point. </li></ol><br><br>  These are the methods of the sphere: <br><br><pre><code class="javascript hljs">sphere.norm = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">at</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec.mul(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.r, vec.sub(at, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q)) } sphere.trace = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ray</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = ray.from <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aq = vec.sub(a, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.q) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ba = ray.dir <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aqba = vec.dot(aq, ba) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aqba &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aq2 = vec.dot(aq, aq) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> qd = aq2 - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.r * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.r <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> D = aqba * aqba - qd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (D &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = qd &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -aqba - <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(D) : -aqba + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(D) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqrdist = t * t <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> at = vec.add(a, vec.mul(t, ba)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">at</span></span>:at, <span class="hljs-attr"><span class="hljs-attr">sqrdist</span></span>:sqrdist} } sphere.color = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">// red color }</span></span></code> </pre> <br><br>  The meaning of the individual notation, like this.q, is not important now: you can easily write your function sphere.trace.  The only important thing is that writing these three methods is quite simple.  Similarly described cube. <br><br><h4>  Raytracer </h4><br><br>  We now turn to the raytracer code.  It has several basic functions: <br><br><ul><li>  <b>trace</b> (ray) goes along the ray of ray and stops where the ray crosses an object.  In other words, this function finds the nearest intersection of the beam with the object.  trace returns the intersection coordinates and the distance to it, as well as a link to the item with whom they crossed.  I wrote the eu function like this: <br><br><pre> <code class="javascript hljs">rt.trace = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ray</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rt.objects) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = rt.objects[i] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ep = obj.trace(ray) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ep &amp;&amp; (!p || ep.sqrdist &lt; p.sqrdist)) { p = ep p.owner = obj } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p }</code> </pre><br></li><li>  <b>inshadow</b> (p, lightpos) checks whether the point p is in the shade from the light source at the point lightpos.  In other words, this function checks if the lightpos shines on p.  Here is its code: <br><br><pre> <code class="javascript hljs">rt.inshadow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, lightpos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> q = rt.trace(rt.ray(lightpos, p)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !q || vec.sqrdist(q.at, p) &gt; math.eps }</code> </pre><br><br>  In the first step, the function releases a ray from lightpos to point p and looks where this ray crosses objects.  In the second step, the function checks whether the intersection point coincides with the point p.  If it does not match, then the ray of light did not get to p. <br></li><li>  <b>color</b> (ray) releases a ray of ray and looks at where it encounters objects.  At the collision point, it recognizes the color of the surface and returns it.  Here is its code: <br><br><pre> <code class="javascript hljs">rt.color = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> r </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hit = rt.trace( r ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hit) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rt.bgcolor hit.norm = hit.owner.norm(hit.at) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> surfcol = rt.diffuse(r, hit) || [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reflcol = rt.reflection(r, hit) || [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refrcol = rt.refraction(r, hit) || [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = hit.owner.mat <span class="hljs-comment"><span class="hljs-comment">// material return vec.sum ( vec.mul(m.reflection, reflcol), vec.mul(m.transparency, refrcol), vec.mul(m.surface, surfcol) ) }</span></span></code> </pre><br><br>  First, the function finds the point of collision of the beam with the nearest object and calculates the normal to the surface at this point (if no such point was found, then the beam passed by all the objects and you can return the background color, say black).  At the collision point, the color is summed up in three parts: <br><br><ol><li>  <b>diffuse</b> - the color of the surface itself, taking into account the angles at which this point is illuminated by light sources and the angle at which the ray r fell on it. </li><li>  <b>reflection</b> - the color of the reflected beam. </li><li>  <b>refraction</b> - color of the refracted ray. </li></ol><br><br>  These three parts are summed up with weighting factors: the color of the surface of the surfcol has a weight of m.surface, the color of the reflected beam reflcol is m.reflection, the color of the refracted ray is m.transparency.  The sum of the weight coefficients is equal to 1. For example, if the transparency is m.transparency = 0, then there is no point in considering refraction. <br></li></ul><br><br>  It remains to consider ways to calculate the color at a point.  There are different approaches to the implementation of the functions diffuse, reflection and refraction.  I will review a few of them. <br><br><h4>  Lambert model </h4><br><br>  This is a model for calculating the color of the surface, depending on how the source of color shines on it.  According to this model, the illumination of a point is equal to the product of the power of the light source and the cosine of the angle at which it shines by the point.  Let's write the diffuse function using the Lambert model: <br><br><pre> <code class="javascript hljs">rt.diffuse = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r, hit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = hit.owner <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = obj.mat <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sumlight = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rt.lights) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> light = rt.lights[j] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rt.inshadow(hit.at, light.at)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = vec.norm(vec.sub(hit.at, light.at)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cos = -vec.dot(dir, hit.norm) sumlight += light.power * cos } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec.mul(sumlight, obj.color) }</code> </pre><br><br>  The function iterates over all light sources and checks if the hit point is in the shadow.  If it is in the illuminated area, then the vector dir is calculated - the direction from the light source to the hit point.  The function then finds the cosine of the angle between the normal hit.norm to the surface at hit and the direction dir.  This cosine is equal to the scalar product dir ‚Ä¢ hit.norm.  Finally, the function finds the illumination according to Lambert: light.power ‚Ä¢ cos. <br><br>  This is what happens if you apply only this lighting model: <br><br><img alt="LambertModelExample" src="https://habrastorage.org/storage/3f975197/c8b8f572/c2717bdc/1ea5dd83.png"><br><br><h4>  Phong model </h4><br><br>  The Phong model, like the Lambert model, describes the point lighting.  Unlike the Lambert model, this model takes into account the angle at which we look at the surface.  Phong illumination is calculated as follows: <br><br><ol><li>  We draw a beam from a light source to the point in question on the surface and reflect this beam from the surface. </li><li>  Find the cosine of the angle between the reflected beam and the direction in which we are looking at the surface. </li><li>  We build this cosine to a certain degree and multiply the resulting number by the power of the light source. </li></ol><br><br>  According to this model, the apparent illumination of a point on the surface will be maximum if we see a reflection of a light source in this surface, i.e.  It is reflected directly in the eyes.  Corresponding diffuse code: <br><br><pre> <code class="javascript hljs">rt.diffuse = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r, hit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = hit.owner <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = obj.mat <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sumlight = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rt.lights) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> light = rt.lights[j] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rt.inshadow(hit.at, light.at)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = vec.norm(vec.sub(hit.at, light.at)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lr = vec.reflect(dir, hit.norm) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vcos = -vec.dot(lr, r.dir) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vcos &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phong = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(vcos, m.phongpower) sumlight += light.power * phong } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec.mul(sumlight, obj.color) }</code> </pre><br><br>  This is how it looks like: <br><br><img alt="PhongModelExample" src="https://habrastorage.org/storage/5a2c0585/b0aa9668/3f99e1ce/feb00fcb.png"><br><br>  It can be seen that one Phong is not enough for good lighting, but if you take Phong lighting with one weighting factor and add Lambert lighting to it with another weighting, you get this picture: <br><br><img alt="LambertPlusPhong" src="https://habrastorage.org/storage/c27eb365/c9a3f924/776ac1f2/f852dd62.png"><br><br>  I don‚Äôt give the code for the corresponding diffuse function: it is a combination of the previous two diffuse and can be found in the rt.js file in the example. <br><br><h4>  Reflection </h4><br><br>  To calculate the color of the reflected beam, you need to reflect this beam from the surface using the normal vector and run the already written function rt.color for the reflected beam.  Here there is only one subtlety: the surface does not reflect all the energy of the beam, but only a certain percentage, therefore we add to the beam, in addition to the coordinates of the beginning and direction, also energy.  This parameter will say whether it is still relevant to calculate the color of the beam, because if the energy is small, then the color of the beam, whatever it is, will make a small contribution to the total color obtained in rt.color. <br><br><pre> <code class="javascript hljs">rt.reflection = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r, hit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refl = hit.owner.mat.reflection <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (refl * r.power &lt; math.eps) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> q = {} q.dir = vec.reflect(r.dir, hit.norm) q.from = hit.at q.power = refl * r.power <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rt.color(q) } vec.reflect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> an = vec.dot(a, n) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec.add(a, vec.mul(<span class="hljs-number"><span class="hljs-number">-2</span></span> * an, n)) }</code> </pre><br><br>  Now each object should have a reflection coefficient - it shows how much of the beam energy is reflected from the surface.  After writing this function, you get this picture: <br><br><img alt="Reflection" src="http://habrastorage.org/storage/00ddfaec/eef9de75/c1d877c7/6be7b5e4.png"><br><br><h4>  Refraction </h4><br><br>  When a beam of light passes from one medium to another, it is refracted.  You can read about it in <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25BC%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">Wikipedia</a> .  The implementation of refraction is almost the same as the reflection: <br><br><pre> <code class="javascript hljs">rt.refraction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r, hit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = hit.owner.mat <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = m.transparency <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t * r.power &lt; math.eps) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dir = vec.refract(r.dir, hit.norm, m.refrcoeff) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dir) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> q = {} q.dir = dir q.from = hit.at q.power = t * r.power <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rt.color(q) } vec.refract = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v, n, q</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nv = vec.dot(n, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nv &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec.refract(v, vec.mul(<span class="hljs-number"><span class="hljs-number">-1</span></span>, n), <span class="hljs-number"><span class="hljs-number">1</span></span>/q) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> / q <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> D = <span class="hljs-number"><span class="hljs-number">1</span></span> - a * a * (<span class="hljs-number"><span class="hljs-number">1</span></span> - nv * nv) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = nv * a + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(D) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> D &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> : vec.sub(vec.mul(a, v), vec.mul(b, n)) }</code> </pre><br><br>  Now every object has a coefficient of transparency - the fraction of light that it passes through the surface, and the coefficient of refraction - the number involved in the calculation of the direction of the refracted beam. <br><br><img alt="Refraction" src="http://habrastorage.org/storage/3f208f41/e9469286/5a7286fc/82bf67d2.png"><br><br><h4>  Fresnel coefficient </h4><br><br>  The amount of reflected light depends on the angle at which the beam falls on the surface and the refractive index.  Formula can be viewed in <a href="http://en.wikipedia.org/wiki/Fresnel_equations">Wikipedia</a> .  I did not take into account this effect in the raytracer, because it made subtle changes. <br><br><h4>  Smoothing </h4><br><br>  If one ray is run through each pixel, the lines are smooth in three-dimensional space will appear to be stepped on the screen after design.  To avoid this, you can run several rays through each pixel, read each color and find the average between them. <br><br><h4>  Example </h4><br><br>  Here, the picture is <a href="">1000 √ó 1000</a> (RPS means Rays Per Second - the number of rays that the browser manages to calculate in one second), and here another picture is <a href="">800 √ó 800</a> .  An example can be downloaded from <a href="">this link</a> .  I compared the rendering speed in different browsers.  It turned out the following: <br><br><table><tbody><tr><td>  Opera </td><td>  33,000 RPS </td></tr><tr><td>  Chrome </td><td>  38,000 RPS </td></tr><tr><td>  Firefox </td><td>  16,000 RPS </td></tr><tr><td>  Explorer </td><td>  20,000 RPS </td></tr><tr><td>  Safari </td><td>  13,000 RPS </td></tr></tbody></table><br><br>  I used the most recent version of browsers on February 5th, 2011. <br><br><h4>  What is not in this raytracer? </h4><br><br>  I looked at the basic features of the ray tracer.  What if the object is in front of the mirror and you shine in the mirror?  The back side of the subject will be illuminated by the reflected light.  What if you shine a glass ball?  It will collect the rays of light as a lens and on the stand under it will be a bright spot.  What if there is only a small window in the room through which the light enters?  The whole room will be weak, but lit.  The raytracer does not know how to do this, but it is not difficult to add it, because the main idea of ‚Äã‚Äãthe raytracer allows this. <br><br>  You can see that to calculate all the functions - lighting according to Lambert, Phong, reflection and refraction - all they need is the ability to add vectors, multiply them by a number and find the scalar product.  These operations on vectors do not depend on the dimension of the space, so it is possible to write a four-dimensional raytracer, making some changes to the code. </div><p>Source: <a href="https://habr.com/ru/post/112944/">https://habr.com/ru/post/112944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112938/index.html">Samsung and the sea</a></li>
<li><a href="../112939/index.html">Competition for solving an integer system of linear equations</a></li>
<li><a href="../112940/index.html">Backup hosting - new service from Infobox</a></li>
<li><a href="../112941/index.html">Steel Tambourine 2: Winter Session</a></li>
<li><a href="../112943/index.html">US airlines provide passengers with free access to Facebook</a></li>
<li><a href="../112946/index.html">Microsoft Quality Assurance Day</a></li>
<li><a href="../112947/index.html">Experiment with Augmented Reality, multitouch and Vuzix glasses</a></li>
<li><a href="../112948/index.html">Java hangs on 2.2250738585072012e-308</a></li>
<li><a href="../112949/index.html">The last provider is disabled in Egypt</a></li>
<li><a href="../112950/index.html">The administrator of the UA zone, ‚ÄúHostmaster,‚Äù closes public access to information on domain owners.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>