<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An example of using WxPython to create a node interface. Part 5: We connect nodes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Slowly but surely, I continue to do a series of tutorials about WxPython, where I want to consider developing a fermwork for creating a node interface...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An example of using WxPython to create a node interface. Part 5: We connect nodes</h1><div class="post__text post__text-html js-mediator-article">  Slowly but surely, I continue to do a series of tutorials about WxPython, where I want to consider developing a fermwork for creating a node interface from scratch to something completely functional and working.  In the previous parts we have already described how to add nodes, in the same part, we will connect them, and this picture shows the result, which we will get in this article: <br><img src="https://habrastorage.org/getpro/habr/post_images/ab9/65a/1f5/ab965a1f5af139f2011ff967da0e7d7b.png"><br>  Not perfect yet, but something quite useful and working is already emerging. <br><br>  Past parts live here: <br>  <a href="http://habrahabr.ru/post/201336/">Part 1: Learning to draw</a> <br>  <a href="http://habrahabr.ru/post/201538/">Part 2: Handling Mouse Events</a> <br>  <a href="http://habrahabr.ru/post/201608/">Part 3: We continue to add features + keyboard handling</a> <br>  <a href="http://habrahabr.ru/post/201784/">Part 4: Implementing Drag &amp; Drop</a> <br>  <a href="http://habrahabr.ru/post/201930/">Part 5: We connect nodes</a> <br><a name="habracut"></a><br><br><h4>  13. Create the simplest connection. </h4><br>  In pursuit of node connections, we start with a key component, the connection class, which in its simplest form looks like this: <br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CanvasObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, source, destination, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(Connection, self).__init__(**kwargs) self.source = source self.destination = destination <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, gc)</span></span></span><span class="hljs-function">:</span></span> gc.SetPen(wx.Pen(<span class="hljs-string"><span class="hljs-string">'#000000'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, wx.SOLID)) gc.DrawLines([self.source.position, self.destination.position]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderHighlighting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, gc)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnObjectUnderCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pos)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Everything is simple and trivial, we have initial and final objects and we just draw a line between the positions of these objects.  Instead of the rest of the methods, stubs 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we need to implement the connection node process.  The user interface will be simple: holding Shift, the user clicks on the source node and pulls the connection to the end.  To implement, we will remember the source object when clicking on it, adding the following code to ‚ÄúOnMouseLeftDown‚Äù: <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> evt.ShiftDown() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self._objectUnderCursor.connectableSource: self._connectionStartObject = self._objectUnderCursor</code> </pre><br>  When the buttons are released, we will also check that the object under the cursor can accept the incoming connection and connect them if everything is fine.  To do this, at the beginning of "OnMouseLeftUp" we will add the appropriate code: <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self._connectionStartObject <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self._objectUnderCursor <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self._connectionStartObject != self._objectUnderCursor <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self._objectUnderCursor.connectableDestination): self.ConnectNodes(self._connectionStartObject, self._objectUnderCursor)</code> </pre><br>  The ‚ÄúConnectNodes‚Äù method creates a connection and registers it in both connected nodes: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectNodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, source, destination)</span></span></span><span class="hljs-function">:</span></span> newConnection = Connection(source, destination) self._connectionStartObject.AddOutcomingConnection(newConnection) self._objectUnderCursor.AddIncomingConnection(newConnection)</code> </pre><br>  It remains to teach nodes to be connected.  To do this, we introduce the appropriate interface, and not one, but as many as 3. "ConnectableObject" will be a common interface for an object that can be connected to another object.  In this case, it needs to provide the connection point and center of the node (a little later, we will use this). <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectableObject</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CanvasObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(ConnectableObject, self).__init__(**kwargs) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConnectionPortForTargetPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, targetPoint)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" GetConnectionPortForTargetPoint method should return an end point position for a connection object. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCenter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" GetCenter method should return a center of this object. It is used during a connection process as a preview of a future connection. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> NotImplementedError()</code> </pre><br>  We also inherit from ‚ÄúConnectableObject‚Äù two classes for objects suitable for incoming and outgoing connections: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectableDestination</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ConnectableObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(ConnectableDestination, self).__init__(**kwargs) self.connectableDestination = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self._incomingConnections = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddIncomingConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, connection)</span></span></span><span class="hljs-function">:</span></span> self._incomingConnections.append(connection) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteIncomingConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, connection)</span></span></span><span class="hljs-function">:</span></span> self._incomingConnections.remove(connection) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConnectableSource</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ConnectableObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(ConnectableSource, self).__init__(**kwargs) self.connectableSource = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self._outcomingConnections = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddOutcomingConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, connection)</span></span></span><span class="hljs-function">:</span></span> self._outcomingConnections.append(connection) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteOutcomingConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, connection)</span></span></span><span class="hljs-function">:</span></span> self._outcomingConnections.remove(connection) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOutcomingConnections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._outcomingConnections</code> </pre><br>  Both these classes are very similar and allow you to store lists of incoming and outgoing connections, respectively.  Plus, they set the appropriate flags so that the canvas knows that such an object can be connected. <br><br>  The last step remains: to modify our node a little, add the corresponding base classes to its parents and modify the rendering process.  With rendering everything is interesting, you can store nodes in the canvas and render them there, or you can assign this task to the node and make it render outgoing connections.  We will do this by adding the following code to the node's rendering code: <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> connection <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.GetOutcomingConnections(): connection.Render(gc)</code> </pre><br>  So, if you run this thing and play around a bit, you can get something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/3f0/b8b/00c/3f0b8b00c8dde521bf2a901e2806a75b.png"><br>  Not very nice, but functional already :) The current version of the code lives <a href="https://github.com/Akson/MoveMe/tree/a5166352fb03af271f6372613640ea8c6e457f48">here</a> . <br><br><h4>  14. Making beautiful arrows </h4><br>  The lines connecting the angles of the nodes is good for dough, but not very nice and aesthetic.  Well, not scary, now we will make beautiful and aesthetic arrows.  To begin with, we need a method of drawing arrows, which I quickly wrote, recalling school geometry and using NumPy: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderArrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, gc, sourcePoint, destinationPoint)</span></span></span><span class="hljs-function">:</span></span> gc.DrawLines([sourcePoint, destinationPoint]) <span class="hljs-comment"><span class="hljs-comment">#Draw arrow p0 = np.array(sourcePoint) p1 = np.array(destinationPoint) dp = p0-p1 l = np.linalg.norm(dp) dp = dp / l n = np.array([-dp[1], dp[0]]) neck = p1 + self.arrowLength*dp lp = neck + n*self.arrowWidth rp = neck - n*self.arrowWidth gc.DrawLines([lp, destinationPoint]) gc.DrawLines([rp, destinationPoint])</span></span></code> </pre><br>  We are counting ‚Äúself.arrowLength‚Äù from the end of the arrow to the beginning and then moving in both directions along the normal by the distance ‚Äúself.arrowWidth‚Äù.  So we find the end points of the segments connecting the end of the arrow with ... I do not know what to call it, with the ends of the tip or something. <br>  It remains to replace the line drawing method with the drawing of an arrow in the rendering method and it will be possible to contemplate the following picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/8d4/514/ae4/8d4514ae47f2ab7a52bffb6ee926fa1c.png"><br>  The code lives <a href="https://github.com/Akson/MoveMe/tree/b90f4b806f71ba515baa4f259d23e2322f740350">here</a> . <br><br><h4>  15. Get the correct end points of the connections. </h4><br>  It looks better already, but still not quite beautiful, since the ends of the arrow dangle where it is not clear where.  To begin with, we modify our connection class to make it more universal and add methods for calculating the start and end points of the connection: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SourcePoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array(self.source.GetConnectionPortForTargetPoint(self.destination.GetCenter())) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestinationPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array(self.destination.GetConnectionPortForTargetPoint(self.source.GetCenter()))</code> </pre><br>  In this case, we ask each node to indicate where the connection should start, passing the center of the opposite node to it as the other end.  This is not an ideal and not the most universal way, but it will do for a start.  Rendering the connection now looks like this: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, gc)</span></span></span><span class="hljs-function">:</span></span> gc.SetPen(wx.Pen(<span class="hljs-string"><span class="hljs-string">'#000000'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, wx.SOLID)) self.RenderArrow(gc, self.SourcePoint(), self.DestinationPoint())</code> </pre><br>  It remains to actually implement the ‚ÄúGetConnectionPortForTargetPoint‚Äù method at the node, which will calculate the point on the border of the node, from where the connection should start.  For a rectangle without considering rounded corners, you can use the following method: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConnectionPortForTargetPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, targetPoint)</span></span></span><span class="hljs-function">:</span></span> targetPoint = np.array(targetPoint) center = np.array(self.GetCenter()) direction = targetPoint - center <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> direction[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">#Check right border borderX = self.position[0] + self.boundingBoxDimensions[0] else: #Check left border borderX = self.position[0] if direction[0] == 0: t1 = float("inf") else: t1 = (borderX - center[0]) / direction[0] if direction[1] &gt; 0: #Check bottom border borderY = self.position[1] + self.boundingBoxDimensions[1] else: #Check top border borderY = self.position[1] if direction[1] == 0: t2 = float("inf") else: t2 = (borderY - center[1]) / direction[1] t = min(t1, t2) boundaryPoint = center + t*direction return boundaryPoint</span></span></code> </pre><br>  Here we find the closest intersection between the beam coming from the center of the node to the destination point and the sides of the rectangle.  So the point lies on the border of the rectangle and, in general, suits us.  So we can get something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/c96/8c9/af0/c968c9af01dfd73fc9f9fc364864265c.png"><br>  Or something similar to the picture at the very beginning of the article, which is a hierarchy of text node classes that are already close to something quite useful. <br><br>  The code lives in <a href="https://github.com/Akson/MoveMe/tree/4b35c8834647102d016ffd76af3075d91d08ca27">here</a> . <br><br>  PS: Write about typos in PM. </div><p>Source: <a href="https://habr.com/ru/post/201930/">https://habr.com/ru/post/201930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201918/index.html">Payonline HCS. Payment acceptance module for utilities</a></li>
<li><a href="../201920/index.html">What's wrong with OOP and OP, and what's wrong with programming</a></li>
<li><a href="../201922/index.html">Modifying commits in git</a></li>
<li><a href="../201924/index.html">How basic authentication in ExpressJS works</a></li>
<li><a href="../201928/index.html">‚ÄúIn defense of laziness‚Äù: why I consider ZOOM TV to be a necessary and sought-after program</a></li>
<li><a href="../201936/index.html">New IT infrastructure management and IBM Flex System Manager features</a></li>
<li><a href="../201940/index.html">Broadcast Launch Visual Studio 2013</a></li>
<li><a href="../201942/index.html">Microsoft changes employee rating system</a></li>
<li><a href="../201944/index.html">Bcache versus btier</a></li>
<li><a href="../201948/index.html">China and the Chinese. View from the outside. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>