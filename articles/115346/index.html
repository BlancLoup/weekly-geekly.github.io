<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Suffix array - a convenient replacement for the suffix tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear community! I think many people know such a data structure as a suffix tree . On Habr√© was already a description of how to build it and why...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Suffix array - a convenient replacement for the suffix tree</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear community!  I think many people know such a data structure as a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">suffix tree</a> .  On Habr√© was already <a href="http://habrahabr.ru/blogs/algorithm/111675/">a</a> description of how to build it and why.  In short, it is necessary when it is necessary to look for arbitrary <i>samples of</i> <b>X <sub>i</sub></b> in a predetermined <i>text</i> <b>A</b> many times, and such a tree is painfully constructed using the Ukkonen algorithm (there are other options, but they imply an even greater amount of suffering).  The general observation when working with algorithms is such that trees are, of course, good, but in practice they are best avoided because of serious overheads from memory and not very optimal (in terms of the efficiency of operating data with a computer) location.  In addition, it is in this tree that there is an even more significant nuisance, namely, the alphabetic dependence of the structure.  To solve these problems, a <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D1%2584%25D1%2584%25D0%25B8%25D0%25BA%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BC%25D0%25B0%25D1%2581%25D1%2581%25D0%25B8%25D0%25B2">suffix array</a> was invented.  About how to build it and how to use and go in this article. <br><br>  The material of the article assumes knowledge of the concepts of the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B0">suffix and the</a> string <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B0">prefix</a> , as well as knowledge of how <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA">binary search</a> works.  It is also necessary to imagine what is <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B0%25D0%25B1%25D0%25B8%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">stable sorting</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D0%25B0%25D0%25B7%25D1%2580%25D1%258F%25D0%25B4%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">bitwise sorting</a> , as well as understanding what is meant by stable sorting by counting.  For some parts, we need knowledge of the minimum range problem - <a href="http://en.wikipedia.org/wiki/Range_Minimum_Query">Range Minimum Query (RMQ)</a> .  Well, in general, you were warned: no one said it would be easy. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Suffix array applications </h3><br><br><h4>  Not all trees are equally useful. </h4><br><br>  So, why doesn't a tree suit us?  First, it is of course that due to the need to keep references to children, parents, etc.  the size of the memory used in this case is noticeably larger than if these links are not stored.  Secondly, if memory is allocated for data by some standard allocator, they will be ‚Äúscattered in different corners,‚Äù as a result, bypassing the tree will involve a large number of memory transitions, which has a bad effect on the memory cache.  Of course there are tricks that allow you to suppress this problem: you need to place the tree nodes in the array, and instead of pointers use the index in the array.  Then the tree will be represented as a solid piece of memory. <br><br>  Well, these are common problems for all trees.  And what about the notorious alphabetical dependence?  Let's look at the practical implementation of the suffix tree (if you have not encountered it, then it is not important to understand the essence of the problem).  At each node of such a tree, there may be references to children in an amount of from 1 (for example, for a terminal vertex without branching) and up to the size of the alphabet.  So the question is how to store these links.  You can, for example, hold an array of links the size of the alphabet in each node.  It will work quickly - to find out if there is an appropriate child in this node, it is possible for O (1).  But in most cells of the array, zero references will be stored, and the memory will go to these cells.  For small alphabets (for example, nucleotides in DNA) the hell with him, but imagine the Chinese characters?  In principle, you don‚Äôt need to go far: not even the case-sensitive Russian alphabet makes you wonder if we want to have so much empty data. <br><br>  It is possible to save memory more economically by placing only non-empty references in a dynamically changeable array (vector), but then checking for the presence of the corresponding node child for O (1) becomes quite doubtful.  If you store links in sorted form, then O (log (size of the alphabet)).  You can try to play with hash tables, but this will only make sense for very large alphabets, and also another level of indirection is introduced.  And to build such trees is no longer O (n).  In general, in any case, it will be necessary to make a compromise between memory and performance. <br><br><br><h4>  Suffix array </h4><br><br>  In 1989, Manber and Myers published an article in which they described such a data structure as a suffix array, and how to use it to search for substrings.  <i>A suffix array</i> is an array of lexicographically sorted suffix strings (if the terminology is unfamiliar, then you can take a look at the ‚Äúproblem statement‚Äù section in <a href="http://habrahabr.ru/blogs/algorithm/113266/">this</a> article).  Generally speaking, there is no sense to keep the suffixes themselves; it is enough to keep the position of the beginning of the given suffix, but the definition of an array is so easily accepted.  Here is an example for <i>the mississippi</i> line: <br><br><table><tbody><tr><th>  # </th><th>  suffix </th><th>  suffix number </th></tr><tr><td>  one </td><td>  i </td><td>  eleven </td></tr><tr><td>  2 </td><td>  ippi </td><td>  eight </td></tr><tr><td>  3 </td><td>  issippi </td><td>  five </td></tr><tr><td>  four </td><td>  ississippi </td><td>  2 </td></tr><tr><td>  five </td><td>  mississippi </td><td>  one </td></tr><tr><td>  6 </td><td>  pi </td><td>  ten </td></tr><tr><td>  7 </td><td>  ppi </td><td>  9 </td></tr><tr><td>  eight </td><td>  sippi </td><td>  7 </td></tr><tr><td>  9 </td><td>  sissippi </td><td>  four </td></tr><tr><td>  ten </td><td>  ssippi </td><td>  6 </td></tr><tr><td>  eleven </td><td>  ssissippi </td><td>  3 </td></tr></tbody></table><br><br><br>  Also an important concept is the <i>rank of the suffix</i> - the place that the suffix will take when sorting, that is, its position in the suffix array.  These are reciprocal values.  We will not distinguish them in any way, since having one array, you can get another in O (N), so you can always have both on hand. <br><br><img src="https://habrastorage.org/storage/d57649f4/e0eafa46/baf9cf4e/2c6b9ca4.png"><br><br><br><h4>  Simplest substring search </h4><br><br>  Consider an example.  The original string <i>"mississippi"</i> .  Suppose a sample comes to us <i>"sip"</i> .  The easiest way to find out if a pattern is found in the text, using the suffix array, is to take the first character of the sample and use the <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA">binary search</a> (the array is sorted) to find a range with suffixes starting with the same letter.  Since all elements in the range are sorted, and the first characters are the same, the suffixes left after discarding the first character are also sorted.  So, you can repeat the procedure of narrowing the search range to obtain either an empty range, or successful finding of all the characters of the sample.  Obviously, in this way, in O (| <b>X</b> | log | <b>A</b> |) operations we will get the answer. <br><br><br><table border="1"><tbody><tr><th>  sample </th><th>  <i><u>s</u></i> ip </th><th>  <i><u>si</u></i> p </th><th>  <i><u>sip</u></i> </th></tr><tr><td></td><td>  i </td><td>  i </td><td>  i </td></tr><tr><td></td><td>  ippi </td><td>  ippi </td><td>  ippi </td></tr><tr><td></td><td>  issippi </td><td>  issippi </td><td>  issippi </td></tr><tr><td></td><td>  ississippi </td><td>  ississippi </td><td>  ississippi </td></tr><tr><td></td><td>  mississippi </td><td>  mississippi </td><td>  mississippi </td></tr><tr><td></td><td>  pi </td><td>  pi </td><td>  pi </td></tr><tr><td></td><td>  ppi </td><td>  ppi </td><td>  ppi </td></tr><tr><td></td><td>  <b><i><u>s</u></i> ippi</b> </td><td>  <b><i><u>si</u></i> ppi</b> </td><td>  <b><i><u>sip</u></i> pi</b> </td></tr><tr><td></td><td>  <b><i><u>s</u></i> issippi</b> </td><td>  <b><i><u>si</u></i> ssippi</b> </td><td>  sissippi </td></tr><tr><td></td><td>  <b><i><u>s</u></i> sippi</b> </td><td>  ssippi </td><td>  ssippi </td></tr><tr><td></td><td>  <b><i><u>s</u></i> sissippi</b> </td><td>  ssissippi </td><td>  ssissippi </td></tr></tbody></table><br><br><br>  Exactly the same complexity will be obtained if we apply a binary search "in the forehead": with full lexicographic comparisons of strings along the edges and in the median with the sample: O (log | <b>A</b> |) comparisons with the average "price" of the comparison O (| <b>X</b> |). <br><br><br><h4>  Faster </h4><br><br>  Not bad, but better.  In fact, it is not necessary to compare the entire search string with the element of the array.  At each iteration of the binary search, we specify a certain range within which the desired element may be located.  All strings in this range are somewhat similar.  Namely, these strings may have a common prefix with the search string, since those that remained out of range will certainly not have a common prefix (in the sense that we do not consider the already processed part of the sample as part of the prefix). <br><br>  Suppose we know the length of the common prefix of the remaining sample with the edges of the current range l = lcp ( <b>X</b> , <b>S [</b> L <b>]</b> ) and r = lcp ( <b>X</b> , <b>S [</b> R <b>]</b> ) for the left and right edges ( <i>lcp</i> - longest common prefix).  The first statement is that for any string within the lcp range, it is no less than the minimum of these two numbers.  If this were not so, then with the initial part of the prefix unchanged, there would be a position where the symbol would first coincide with the corresponding sample symbol, then not match, and then again match.  This would contradict the sorting range.  It is important to penetrate this idea well, as we will use it further for granted.  The second statement is obvious: if the common prefix of the sample and any string within the range is not less than m = min (l, r), then m symbols can be skipped right away, knowing that they are the same in any case, and only be compared starting with m + 1 (and resulting in lcp for the given string). <br><br><img src="https://habrastorage.org/storage/051913b3/9cf17b96/09fbaad5/aa6abbe1.png" alt="lcp (x, l) and lcp (x, r)"><br><br>  Thus, we apply an optimized string comparison in a binary search for the head-on string.  In the worst case, of course, we won‚Äôt gain anything from it: if the element we are looking for is on the edge of the array, but the neighbors are not at all similar to lcp, then r (or l) will be small each time, m will be small too, which means we will have to check each symbol by log |  <b>A</b> |  time.  But experimental observations indicate that for natural texts, the search time is significantly reduced compared to O (log | <b>A</b> || <b>X</b> |), although it is difficult to assert anything about any particular asymptotics. <br><br>  In principle, for practical applications this is quite enough, but if you want to squeeze everything, then ... <br><br><br><h4>  Even faster </h4><br><br>  This is not the limit.  The positions of the edges of a section of an array define the center of this section, and all such configurations that are realized in a binary search are a subset of a fixed set of size |  <b>A</b> | -2.  Suppose we have taken care to calculate in these configurations the values ‚Äã‚Äãof m <sub>l</sub> = lcp ( <b>S [</b> M <b>]</b> , <b>S [</b> L <b>]</b> ) and m <sub>r</sub> = lcp ( <b>S [</b> M <b>]</b> , <b>S [</b> R <b>]</b> ), where M is the midpoint between L and R , in which we will go to the binary search step. <br><br><img src="https://habrastorage.org/storage/5a15f456/c1cbc02b/4733fbf9/9e89d723.png" alt="binary search tree"><br><br>  Let's look at one of the edges, say, left.  If l &lt;m <sub>l</sub> counted by us, then the left edge is similar to the middle (and to any element between them) much more than we would like, and then the result of the comparison is known in advance for the entire segment between L and M: lcp ( <b>X</b> , <b>S [</b> M <b>]</b> ) = l.  From this it is immediately clear that the desired element is definitely not on this site, and if we look for it, then in the opposite half.  If l&gt; m <sub>l</sub> , then the middle is similar to the left edge less than the desired sample.  So lcp ( <b>X</b> , <b>S [</b> M <b>]</b> ) = m <sub>l l</sub> , and the desired element should be found somewhere between them. <br><br>  Naturally, nothing changes in the arguments, if we replace the left edge with the right one.  Only one case was not considered: l = m <sub>l</sub> and r = m <sub>r</sub> (if at least one equality is not true, then the result is known according to the previous paragraph).  Then it is clear that lcp ( <b>X</b> , <b>S [</b> M <b>]</b> ) is not less than max (l, r), but in order to determine it precisely and find out which way to go, it will be necessary to compare characters (finally!) Starting from the position max (l, r ) +1. <br><br><img src="https://habrastorage.org/storage/47d80adf/b5a9f033/a19393d4/2bb2b690.png" alt="lcp (M, L) and lcp (M, R)"><br><br>  What have we got?  We will do some steps of the binary search by comparing several lcp with each other, and even if it comes to comparing characters, then no more than once per character <b>X</b> (we take max (l, r) +1, which means we never go back).  Thus, we obtain the complexity of the algorithm O (log | <b>A</b> | + | <b>X</b> |) <u>in the worst case</u> .  True, we need pre-calculated lcp for text suffixes <b>A</b> found in the search tree induced by the binary search algorithm. <br><br>  It is important to note that if we do not know m <sub>r</sub> , but only m <sub>l</sub> , then there is nothing terrible either.  We lose the opportunity to say in advance that there is no entry, but this does not worsen the complexity: we just will not look at the right edge, only the left.  If l &lt;m <sub>l</sub> , then we search further in the other half, and l is saved, if l&gt; m <sub>l</sub> , then r is taken as m <sub>l</sub> and we search in this half, and if l = m <sub>l</sub> , then we compare the median element with the required line starting with l + 1st position.  We are not going back again in this case either, which means we can do without lcp for the left edges without degrading the complexity of the algorithm. <br><br><br><h4>  LCP pretreatment </h4><br><br>  As you remember, in order to efficiently search for substrings we needed pre-calculated lcp for certain combinations of suffixes.  It is necessary to explain how to get them.  Methods are usually reduced to the task of finding the minimum in the segment - RMQ, so the algorithmic complexity of the algorithm is mostly determined by how effectively you can solve the RMQ problem.  A more or less simple algorithm will cost O (NlogN) on preprocessing and O (1) on request.  That is, if you use the construction of the suffix array for O (NlogN), then it is quite possible to use it.  Of course, if you want to build a suffix array in linear time, you will have to apply the RMQ preprocessing algorithm in linear time with constant queries. <br><br>  First, we build a so-called lcp-array - this is an array of lcp values ‚Äã‚Äãbetween lexicographically-neighboring suffixes (after we have a suffix array, what suffixes do we have next-door questions).  If we have an lcp-array, then finding lcp between two elements is reduced to finding the minimum value on a given segment of the lcp-array, that is, the task RMQ - finding the minimum on the segment - in its pure form.  Why this is so is clear from considerations of the ordering of suffixes: if lcp between two lines were longer, then all the lines between them would also contain at least the same number of identical characters at the beginning, and all lcp between these lines would be no less than mutual lcp items. <br><br>  Building an lcp array is quite simple.  Of course, it is impossible to go along the suffix array and count lcp neighboring elements - this is O (N <sup>2</sup> ).  But if you go through the array in the correct order, you can use the information from the previous step for calculations.  Namely, if we iterate suffixes in the order in which they appear in the source line, then at each step lcp cannot be reduced by more than 1 compared to the previous step, that is, it can be more, it may not change, but if less, only by 1. This happens for the following reason.  If you find out that lcp ( <b>A</b> [i ..], <b>A</b> [j ..]) = l, then discarding the first character obviously reduces it by one: lcp ( <b>A</b> [i + 1 ..], <b>A</b> [j +1 ..]) = l-1.  Of course, if the i-th and j-th suffixes turned out to be lexicographically adjacent, then this does not guarantee that i + 1-st and j + 1-th will be adjacent - between them, most likely, others will interpose.  But, as we have already found out, lcp between them is the minimum lcp on the whole segment between them, which means lcp between the i + 1th suffix and the lexicographically following it is not less than l-1. <br><br><br><table><tbody><tr><th>  # </th><th>  suffix </th><th>  step </th><th>  lcp </th></tr><tr><td>  one </td><td>  i </td><td>  ten </td><td>  one </td></tr><tr><td>  2 </td><td>  ippi </td><td>  7 </td><td>  one </td></tr><tr><td>  3 </td><td>  issippi </td><td>  four </td><td>  four </td></tr><tr><td>  four </td><td>  ississippi </td><td>  2 </td><td>  0 </td></tr><tr><td>  five </td><td>  mississippi </td><td>  one </td><td>  0 </td></tr><tr><td>  6 </td><td>  pi </td><td>  9 </td><td>  one </td></tr><tr><td>  7 </td><td>  ppi </td><td>  eight </td><td>  0 </td></tr><tr><td>  eight </td><td>  sippi </td><td>  6 </td><td>  2 </td></tr><tr><td>  9 </td><td>  sissippi </td><td>  3 </td><td>  one </td></tr><tr><td>  ten </td><td>  ssippi </td><td>  five </td><td>  3 </td></tr><tr><td>  eleven </td><td>  ssissippi </td><td>  skip </td><td></td></tr></tbody></table><br><br><br>  This allows you to skip all the characters to the last but one (l-1), since we are sure that they are equal, and only compare the l-th character and beyond.  This means that any checks we made either increase the current lcp, or force us to move to the next iteration.  Thus, having passed all suffixes except the lexicographically last (it must be skipped), we get an lcp-array in linear time O (N). <br><br>  Well that's all.  It remains to find the RMQ for the pairs of suffixes we need.  The RMQ solution consists of preprocessing and, in fact, responses to requests for a minimum between the elements.  Since the main computational load falls on preprocessing, and query execution can be done O (1), generally speaking it is not necessary to explicitly write the pairs of interest and lcp between them, since we can answer about O lcp of an arbitrary pair of suffixes in O (1) including those that play a role in a binary search.  Given that this eliminates the need to think about how to address stored values, this is very cool.  If you still want to store lcp in an already counted form, then you need to correctly number the states in the search tree - read about the location in memory and addressing in the binary heap. <br><br>  I will not write about how to solve RMQ - on Habr√© there was already a good <a href="http://habrahabr.ru/blogs/algorithm/114980/">article</a> about a simple version for O (NlogN), and I hope there will be a continuation in which they will write about a hardcore version for O (N) - <a href="">Farah-Colton algorithm and Bender</a> . <br><br><br><h3>  Building a suffix array </h3><br><br>  Great, here we know how to apply a suffix array, but where does it come from?  Obviously, building it in a direct way, sorting suffixes, is a long matter - O (N <sup>2</sup> logN), where N = |  <b>A</b> |.  There are a number of algorithms that work for O (NlogN), there are those that work for O (N).  Those that are O (N) are very complicated (for example, first constructing a suffix tree, and then from it already collect a suffix array).  If the maximum efficiency in a specific task is not so important, then you should think about the clarity of the code and stop at the NlogN option.  Next, go one traversal algorithm from these categories. <br><br><br><h4>  Over O (NlogN) </h4><br><br>  Recall how bitwise sorting works: first, we distribute items into baskets (buckets) by counting based on the low-order bit, then we do the same with the next digit, etc.  Here we will act in a similar way, but still a bit differently - if we directly apply the bitwise sorting to suffixes, then we get O (N <sup>2</sup> ). <br><br>  Suppose that at some step we sorted (more precisely, arranged on baskets - buckets) lines according to H first characters.  We can number these parts of the rows by their basket numbers.  But each suffix <b>S [</b> i <b>]</b> = <b>A [</b> i .. <b>]</b> is found not only as an element of the array, but also as part of other elements of the array, in particular as a substring in the H position of the suffix <b>S [</b> iH <b>]</b> (omit for clarity, the edge effects lines - they can be bypassed by writing down at the end of the desired number of centilenes)  That is, having numbered the first H characters of suffixes with the numbers of baskets, we automatically enumerate the second H characters.  Then we get a set of pairs consisting of basket numbers (of some step).  Having sorted these pairs by bitwise sorting, we will get O (N) strings, strung in baskets by 2H first characters.  Thus, the number of characters processed at each step will double.  This gives O (logN) steps and the overall complexity of the O (NlogN) algorithm. <br><br><img src="https://habrastorage.org/storage/da990887/59b243ae/f127d5af/e733571a.png" alt="O (NlogN)"><br><br>  Another small note regarding the first step.  If in the next steps we have to sort the numbers of the baskets, which does not cause problems with the bitwise sorting, then the first step is to sort the lines by the first character.  Depending on the nature of the alphabet, it may turn out that it is impossible to apply bitwise sorting there.  Then you can apply any other sorting based on comparisons with O (NlogN) complexity, and find basket ranges for O (N).  The overall complexity of the algorithm will not change this. <br><br><br><h4>  Over O (N) </h4><br><br>  This is a fairly new algorithm, published in 2003 by Karkainen and Sanders.  Immediately I will warn you that this algorithm works only on alphabets, the characters of which can be numbered in O (N) time (it is equivalent to sort the numbers, that is, you need to know how to sort by O (N) bitwise sorting).  Other is rare, but still happens. <br><br>  The algorithm is recursive, that is, at some stage we get the same problem of finding the suffix array for a string of shorter length.  Consider <i>the mississippi</i> example.  So, the first thing we will do is enumerate our characters in numbers from 1 to N, going to the numerical alphabet.  As we mentioned, this can be done using O (N) bitwise sorting.  After that, the original "real" characters do not interest us, we work only with a numeric representation of the string.  You can forget that this was once not a numeric sequence. <br><br>  Next, we want to build a superalphabet that will contain all the trigrams in the text, and again number the characters of this new alphabet in lexicographical order.  It is clear that these trigrams are no more than characters in a string (less, if there are coinciding).  Since we want to be able to work effectively with this alphabet, the option to look for a trigram in a superalphabet every time and return its lexicographic position (the lexicographic position is sometimes also called rank) does not roll.  We must immediately numbered the superscript, so that questions about this trigram would not arise at all.  For this, it is necessary to match each character of the input string (is it numeric, have you not forgotten?) The number of the trigram in this position.  This is done by a bitwise sorting of all trigrams (together with duplicates) from the source line, preserving what position the trigram came from.  Subsequent numbering in this case is not difficult. <br><br>  For example, from <b>A</b> = <i>"mississippi"</i> one can get trigrams {mis, iss, ssi, ... ppi, pi $, i $$}, and in lexicographical order {i $$, ipp, iss, ... ssi}.  We have added a line as needed by the centinels and consider them to be minimal characters. <br><br><table><tbody><tr><td>  original line: </td><td>  m </td><td>  i </td><td>  s </td><td>  s </td><td>  i </td><td>  s </td><td>  s </td><td>  i </td><td>  p </td><td>  p </td><td>  i </td></tr><tr><td>  numeric string: </td><td>  2 </td><td>  one </td><td>  four </td><td>  four </td><td>  one </td><td>  four </td><td>  four </td><td>  one </td><td>  3 </td><td>  3 </td><td>  one </td></tr><tr><td>  trigrams: </td><td>  mis </td><td>  iss </td><td>  ssi </td><td>  sis </td><td>  iss </td><td>  ssi </td><td>  sip </td><td>  ipp </td><td>  ppi </td><td>  pi $ </td><td>  i $$ </td></tr><tr><td>  trigram numbering: </td><td>  four </td><td>  3 </td><td>  9 </td><td>  eight </td><td>  3 </td><td>  9 </td><td>  7 </td><td>  2 </td><td>  6 </td><td>  five </td><td>  one </td></tr></tbody></table><br><br><br>  At this stage, it may turn out that all trigrams in the line are different.  This can be used as an early terminal condition, since if trigrams are different, their lexicographic order sets the lexicographic order of the suffixes (you can not use this condition, but simply continue to reduce the string to a shorter one until the answer becomes obvious).  We can present the original line in the form of trigrams in three ways: breaking the line itself into trigrams, a line without the first character and a line without the first two characters.  We call these representations of the rows T <sub>0</sub> , T <sub>1</sub> and T <sub>2</sub> .  Each of them is about three times shorter than the original.  If you count positions from zero, then you can call these representations corresponding to the group of suffixes in positions i mod 3 = 0, i mod 3 = 1 and i mod 3 = 2. <br><br><table border="1"><tbody><tr><td>  T <sub>0</sub> : </td><td>  mis </td><td>  sis </td><td>  sip </td><td>  pi $ </td></tr><tr><td></td><td>  four </td><td>  eight </td><td>  7 </td><td>  five </td></tr><tr><td>  T <sub>1</sub> : </td><td>  iss </td><td>  iss </td><td>  ipp </td><td>  i $$ </td></tr><tr><td></td><td>  3 </td><td>  3 </td><td>  2 </td><td>  one </td></tr><tr><td>  T <sub>2</sub> : </td><td>  ssi </td><td>  ssi </td><td>  ppi </td><td></td></tr><tr><td></td><td>  9 </td><td>  9 </td><td>  6 </td><td></td></tr></tbody></table><br><br><br>  Next, a feint is made with ears, the meaning of which will be clear later: we take two of these three lines, for concreteness, T <sub>1</sub> and T <sub>2</sub> , presented in the form of trigrams, concatenated and passed to the same algorithm in a recursive call.  Obviously, the length of the transmitted string is one third shorter than the original.  At the output of the algorithm, we expect a suffix array (or, equivalently, an array of ranks).  Turning back from trigrams to a numeric string, we will receive information on the lexicographic order between the suffixes of groups 1 and 2. <br><br>  The suffix of group 0 can be represented as a pair consisting of a symbol and a suffix of group 1, or as a triple of two symbols and a suffix of group 2: <b>A</b> [3k ..] = (A [3k], <b>A</b> [3k + 1 ..]) = (A [3k], A [3k + 1], <b>A</b> [3k + 2 ..]).  Similar expressions can be written to translate other groups of suffixes into adjacent ones.  We represent type 0 suffixes as a pair of a symbol and a type 1 suffix (more precisely, the type 1 suffix rank, we are not interested in the suffix), then sort them by bitwise sorting. <br><br>  At this stage, we have the result of a recursive function call in the form of mutually sorted type 1 and 2 suffixes, and sorted type 0 suffixes. We need to merge them using the usual merging of sorted arrays, but at the same time we need to be able to effectively compare type 0 suffixes 1 and 2. In order to compare the type 0 suffix with type 1, you must convert the type 0 suffix to type 1, and type 1 to type 2: (A [3l], <b>A</b> [3l + 1 ..]) VS (A [3m + 1], <b>A</b> [3m + 2] ..).  It is easy to compare these two pairs: either the first character determines the order, or if it is equal, then the order determines the order of the suffixes of groups 1 and 2, which we know from the results of the recursive call of this algorithm.  For comparison of the suffix of types 0 and 2, the chain is slightly larger, but the essence is the same: (A [3l], A [3l + 1], <b>A</b> [3l + 2 ..]) VS (A [3m + 2], A [3 (m + 1)], <b>A</b> [3 (m + 1) +1 ..]). <br><br>  At first glance, it is not clear why all this should give us a linear complexity.  First, let's deal with everything except the recursive call.  The superscript bitwise sorting, suffix marking is all O (N), bitwise sorting of group 0 suffixes and merging sorted arrays is also O (N).  Now the recursive call - we call the algorithm 2/3 of the original length of the string, thus the complexity of the algorithm is T (N) = T (2N / 3) + O (N).  If to paint this expression substituting it in itself, then we will receive the sum of a geometrical progression with coefficient 2/3, so limited O (N).  The resulting complexity is thus O (N). <br><br><br><h3>  Conclusion </h3><br><br>  Here it is described how to apply the suffix array and how to build it.  Algorithms are quite voluminous, but what to do is a very high-level task.  I described it all in fairly general terms and did not provide any code for an understandable reason - then there would be too many words and code.  As you can see, the algorithms are fast and a little slower differ significantly in implementation complexity, so there is a reason to think a few times whether you really need to do this, for example, for O (N), and not for O (NlogN). <br><br>  I also anticipate questions like ‚Äúwhere you can see the finished implementation,‚Äù ‚Äúwhere to read more,‚Äù and so on.  I haven‚Äôt seen any ready-made implementations in the ‚Äújust add your comparator‚Äù style, although the <a href="http://en.wikipedia.org/wiki/Suffix_array">wikipedia page</a> claims that they exist.  <a href="http://e-maxx.ru/algo/suffix_array">Here</a> and <a href="http://acm.mipt.ru/twiki/bin/view/Algorithms/SuffixArray">here</a> there are explanations and some implementation.  In addition, in the <a href="http://www.cs.helsinki.fi/u/tpkarkka/publications/icalp03.pdf">original article by</a> Karkainen and Sanders, there is also an array construction code.  About NlogN construction can be read in the article Manber and Myers: Udi Manber, Gene Myers - "Suffix arrays: a new method for on-line string searches." <br></div><p>Source: <a href="https://habr.com/ru/post/115346/">https://habr.com/ru/post/115346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115339/index.html">How do I protect my rights?</a></li>
<li><a href="../115341/index.html">I present evidence of the ability to port Qt Lighthouse to iOS (UIKit)</a></li>
<li><a href="../115342/index.html">The Prism MVVM development team needs your help.</a></li>
<li><a href="../115343/index.html">What type of installation online store is most convenient for you?</a></li>
<li><a href="../115345/index.html">FlashCache. How to use Flash in storage NOT as SSD?</a></li>
<li><a href="../115347/index.html">Vector from left to right</a></li>
<li><a href="../115348/index.html">OpenStreetMap News ‚Ññ3</a></li>
<li><a href="../115349/index.html">Erase can not be restored</a></li>
<li><a href="../115351/index.html">Art directorate and design</a></li>
<li><a href="../115353/index.html">As thanks to hc.ru, I realized that backups should be done by myself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>