<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing Sunburst Chart on JavaScript and HTML5 Canvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Today I would like to tell about how you can make your own graphics on js + canvas literally in a couple of hundred lines of code. And at the s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing Sunburst Chart on JavaScript and HTML5 Canvas</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a82/388/71c/a8238871cb8f42b6b91ab70512f9d204.jpg" align="right"><br>  Hello!  Today I would like to tell about how you can make your own graphics on js + canvas literally in a couple of hundred lines of code.  And at the same time remember the school course of geometry. <br><a name="habracut"></a><br><h2>  What for </h2><br>  There are enough cool libraries that can build graphics in the browser.  And <a href="http://d3js.org/">d3js</a> has become de facto standard.  However, I needed exactly the sunburst diagram, so I didn‚Äôt want to drag tens or hundreds of kilobytes of library code behind me.  There was also a need for quick work of such a diagram in mobile browsers, therefore the implementation on svg was not suitable due to the lower performance of the latter compared to the canvas.  Scaling of the diagram was not provided.  Also, writing such a thing is a great way to follow the path of <a href="https://medium.com/%40davidbyttow/abc-always-be-coding-d5f8051afce2">abc</a> . <br><br><h2>  What we visualize </h2><br>  Data for visualization have approximately the following format: <br><br><div class="spoiler">  <b class="spoiler_title">Sample data</b> <div class="spoiler_text"><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'day'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">children</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'work'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">9</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">children</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'coding'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">children</span></span>: [ {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'python'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'js'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>} ] }, {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'communicate'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1.5</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>} ] }, {<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'sleep'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span> * <span class="hljs-number"><span class="hljs-number">60</span></span>}, ... };</code> </pre> <br></div></div><br>  Those.  we have a hierarchical structure, each node of which has a name and a certain value.  You need to display them in something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/13b/88c/c91/13b88cc91882471686428dbd07840b40.jpg"></div><br>  In this case, it is necessary to provide for the possibility of scaling the diagram by clicking on different areas, i.e.  actually go through the data tree.  As well as data editing, i.e.  add and remove nodes <br><br><h2>  Opportunities </h2><br><ul><li>  The data should be relatively evenly spaced on the canvas, with proportions - the farther the node is from the center, the less space it should occupy. </li><li>  Clicking on a node that is not currently the root node should increase the granularity of the chart. </li><li>  A click on the central node should lead to a decrease in the granularity of the chart. </li><li>  The diagram needs to react when you hover the cursor and there are two modes for selecting nodes: a separate node and a path from the center of the diagram to the selected node. </li></ul><br>  As a result, I would like to get some hybrid of <a href="http://bl.ocks.org/kerryrodden/477c1bfb081b783f80ad">this</a> and <a href="http://bl.ocks.org/kerryrodden/7090426">that</a> . <br><br><h2>  Implementation </h2><br><h3>  Data location </h3><br>  In order to evenly distribute the data on the canvas, it is necessary to first find out their maximum nesting.  This is fairly easy to do with the following recursive function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxDeep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deeps = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = (data.children || []).length; i &lt; l; i++) { deeps.push(maxDeep(data.children[i])); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max.apply(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>, deeps.length ? deeps : [<span class="hljs-number"><span class="hljs-number">0</span></span>]); };</code> </pre><br>  The depth of nesting of the data determines the number of layers (rings) in the chart.  All rings in the amount should occupy <i>min (canvas.width, canvas.height)</i> .  The reduction of the width of the rings from the center (maximum size) to the edges of the canvas (minimum size) occurs according to the rule of the golden section.  Each subsequent ring is 1.62 times thinner than the previous one.  Thus, we have a recurrent expression: <br><br><pre> <code class="javascript hljs">x + x / <span class="hljs-number"><span class="hljs-number">1.62</span></span> + x / (<span class="hljs-number"><span class="hljs-number">1.62</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>) + ... + x / (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">62</span></span>^(n<span class="hljs-number"><span class="hljs-number">-1</span></span>)) = min(canvas.width, canvas.height)</code> </pre><br>  where n is the number of layers, and x is the thickness of the root node.  Thus, x can be easily found using the following function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rootNodeWidth</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n, canvasWidth, canvasHeight</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canvasSize = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min(canvasWidth, canvasHeight), div = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { div += <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">1.62</span></span>, i); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canvasSize / <span class="hljs-number"><span class="hljs-number">2</span></span> / div; <span class="hljs-comment"><span class="hljs-comment">//  2 ,      . };</span></span></code> </pre><br>  Further, when drawing the diagram, we simply divide the thickness of the current layer by 1.62 to get the thickness of the next one. <br><br><h3>  Chart nodes visualization </h3><br>  Before proceeding directly with the drawing of nodes, it is necessary to perform some calculations.  In particular, it is necessary to calculate the height of each of the nodes, determine the length of the node, the start angle and assign a color. <br><br>  About the definition of height has already been written above.  The angles are calculated as follows: the <b>central node</b> is a circle, i.e.  the angle between its lateral components is 360 degrees (2 Pi radians) and they merge into one line (we do not visualize it).  The thickness of the central node is the radius of this circle. <br><br>  All <b>subsequent nodes</b> are arcs wrapped around a central node. <br><br><img src="https://habrastorage.org/files/a28/6f9/d26/a286f9d267b04c87b22f886f1734b3ab.jpg"><br>  <i>Nodes of the first (not central) level.</i> <br><br>  The length of the arc (ie, the angle between its side components) is calculated based on the ratio of the data value (value), which correspond to this arc and the value of the data of the parent node for this arc.  Thus, if the central node has the value value = 100, and the node of the first level nested in it has value = 50, then the angle of the latter will be 180 degrees (50/100 = Pi / 2 Pi).  This rule is recursively applied to each of the nodes with respect to its parent.  If a node has 2 or more heirs, then the maximum angle of its first heir will be the minimum angle of the second, and so on.  All calculations are clockwise. <br><br><img src="https://habrastorage.org/files/7dc/846/b33/7dc846b3363240c0ac8120f67514c699.jpg"><br>  <i>The ratio of the lengths of the arc nodes and value.</i> <br><br>  The color of the nodes is assigned sequentially from the set available.  The above calculations can be performed by the following function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcMetaData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dataRootNode, rootNodeWidth</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startWidth = rootNodeWidth, meta = { <span class="hljs-attr"><span class="hljs-attr">root</span></span>: { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: dataRootNode, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: pickColor(), <span class="hljs-attr"><span class="hljs-attr">angles</span></span>: {<span class="hljs-attr"><span class="hljs-attr">begin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-attr"><span class="hljs-attr">abs</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI}, <span class="hljs-comment"><span class="hljs-comment">//   -  width: startWidth, offset: 0, children: [], scale: 1 } }, sibling; function calcChildMetaData(childDatum, parentMeta, sibling, scale) { var meta = { data: childDatum, color: pickColor(), parent: parentMeta, width: parentMeta.width / scale, offset: parentMeta.offset + parentMeta.width, children: [], scale: parentMeta.scale / scale }, childSibling; meta.angles = {abs: parentMeta.angles.abs * childDatum.value / parentMeta.data.value}; meta.angles.begin = sibling ? sibling.angles.end : parentMeta.angles.begin; meta.angles.end = meta.angles.begin + meta.angles.abs; for (var i = 0, l = (childDatum.children || []).length; i &lt; l; i++) { childSibling = calcChildMetaData(childDatum.children[i], meta, childSibling, scale); meta.children.push(childSibling); } return meta; } for (var i = 0, l = (dataRootNode.children || []).length; i &lt; l; i++) { if (dataRootNode.children[i].value &gt; dataRootNode.value) { console.error('Child value greater than parent value.', dataRootNode.children[i], dataRootNode); continue; } sibling = calcChildMetaData(dataRootNode.children[i], meta.root, sibling, 1.62); meta.root.children.push(sibling); } return meta; };</span></span></code> </pre><br>  Drawing the center node is easiest.  To do this, you need to make a closed arc using the <a href="http://www.w3schools.com/tags/canvas_arc.asp">arc ()</a> function, and then fill it with color. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodeMeta = {<span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>px, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-attr"><span class="hljs-attr">angles</span></span>: {<span class="hljs-attr"><span class="hljs-attr">begin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">end</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI}}; <span class="hljs-comment"><span class="hljs-comment">//    var origin = {x: 250, y: 250}; //   var ctx = canvas.getContext('2d'); function drawRootNodeBody(nodeMeta, origin, ctx) { ctx.beginPath(); ctx.arc(origin.x, origin.y, nodeMeta.width, nodeMeta.angles.begin, nodeMeta.angles.end); //  ctx.fillStyle = nodeMeta.color; //   -    ctx.fill(); ctx.strokeStyle = 'white'; //    -   ctx.stroke(); }</span></span></code> </pre><br>  The remaining nodes draw a little more interesting.  In fact, you need to draw a closed path of the desired shape, and then fill it with color. <br><br><img src="https://habrastorage.org/files/5dc/554/5d6/5dc5545d65ab44d88ba32f4515d5ced1.jpg"><br>  <i>The path to the canvas that forms the node.</i> <br><br>  The sequence of drawing plots is indicated by arrows.  Which side to start drawing does not matter.  We will start with the outer arc.  The function of drawing off-center nodes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawChildNodeBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nodeMeta, origin, ctx</span></span></span><span class="hljs-function">) </span></span>{ ctx.beginPath(); ctx.arc(origin.x, origin.y, nodeMeta.offset, nodeMeta.angles.begin, nodeMeta.angles.end); <span class="hljs-comment"><span class="hljs-comment">//   //    ctx.save(); ctx.translate(origin.x, origin.y); //         ctx.rotate(nodeMeta.angles.end); //  ,     //          ctx.lineTo(nodeMeta.offset + nodeMeta.width, 0); ctx.restore(); //        //   ctx.arc(origin.x, origin.y, nodeMeta.offset + nodeMeta.width, nodeMeta.angles.end, nodeMeta.angles.begin, true); //      -    . ctx.closePath(); ctx.fillStyle = nodeMeta.hover ? 'red' : nodeMeta.color; ctx.fill(); ctx.strokeStyle = 'white'; ctx.stroke(); }</span></span></code> </pre><br>  Instead of turning the context to draw one of the side arcs, you could use Math.sin () (or Math.cos ()) of the angle between the vertical (or horizontal) and the angle of rotation of the side component of the node.  True, thanks to the rotation of the canvas, the code is greatly simplified.  I wonder how this moment affects the rendering performance. <br><br><h3>  Definition of a node of the diagram for the given coordinates </h3><br>  In order to further implement the scaling of the diagram by clicking (or clicking) and hover nodes, you need to learn how to determine the node of the diagram by coordinates on the canvas.  This is easy to do using the transition from Cartesian to polar coordinate system. <br><br>  First, we define the distance from the center of the chart (calculated before the start of rendering) to the point of the click (coordinates are known from the onclick event object) and the angle between the X axis and the segment connecting the center of the chart and this point. <br><br><img src="https://habrastorage.org/files/b61/272/773/b6127277302e4ac9a48889ec8dec2b6d.jpg"><br><br>  For this we need the following function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cartesianCoordsToPolarCoords</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point, origin</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> difX = point.x - origin.x, difY = point.y - origin.y, distance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(difX * difX + difY * difY), angle = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.acos(difX / distance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (difY &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { angle = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI - angle; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">dist</span></span>: distance, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: angle}; };</code> </pre><br>  Now, if we recall that we have previously done calculations of some metadata about each node, and they include the level width, the start angle and the length of each of the node arcs, you can find the node under the pointer in its polar coordinates in a very simple way: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNodeByPolarCoords</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point, origin, metaData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_findNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">point, nodeMeta</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      if (nodeMeta.offset &gt;= point.dist) { //       ,  distance, //   ,        . return null; } if (nodeMeta.offset &lt; point.dist &amp;&amp; point.dist &lt;= nodeMeta.offset + nodeMeta.width) { //  ,       . if (nodeMeta.angles.begin &lt; point.angle &amp;&amp; point.angle &lt;= nodeMeta.angles.end) { return nodeMeta; } } else { // We need to go deeper.     . var node; for (var i = 0, l = (nodeMeta.children || []).length; i &lt; l; i++) { if (node = _findNode(point, nodeMeta.children[i])) { return node; } } } return null; } return _findNode(point, metaData.root); };</span></span></code> </pre><br><br><h3>  Change Chart Detail </h3><br>  For a more detailed examination of the nodes located along the edges of the diagram, it is necessary to implement scaling by clicking on the node.  In fact, this script is equivalent to re-drawing the diagram, but the one that was clicked should be selected as the root data node.  Similarly, when clicking on the central node, it is enough to find its ancestor in the data structure, and, if it exists, draw the diagram by selecting the latter as the root node.  Reuse code 100%. <br><br><h2>  Conclusion </h2><br>  Implementing graphics on js + canvas actually turned out not to be such a difficult task.  It is enough to draw a little with a <s>warm tube</s> pencil on the paper of the coordinate system and recall the definition of sin and cos from the school course. <br><br>  A working example can be viewed on <a href="https://iximiuz.github.io/cancharts/">github.io</a> . <br>  The code is available in the <a href="https://github.com/iximiuz/cancharts">repository</a> on github. </div><p>Source: <a href="https://habr.com/ru/post/246909/">https://habr.com/ru/post/246909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246897/index.html">How call centers use behavioral economics to influence customers</a></li>
<li><a href="../246901/index.html">Computer Engineering at Deutsches Museum</a></li>
<li><a href="../246903/index.html">Monitoring and managing data center infrastructure</a></li>
<li><a href="../246905/index.html">Why you should NOT use AngularJs</a></li>
<li><a href="../246907/index.html">Top 15 JavaScript Libraries for Building Diagrams and Pivot Tables</a></li>
<li><a href="../246911/index.html">OpenGL ES 1.1 on Windows 8 and Windows Phone 8.1</a></li>
<li><a href="../246913/index.html">New optimizations for x86 in GCC 5.0: PIC in 32-bit mode</a></li>
<li><a href="../246919/index.html">NORD POS. The story of why I needed another fork of Openbravo POS</a></li>
<li><a href="../246921/index.html">We open the brain to the sales manager. How to get an investment, sell a product or service</a></li>
<li><a href="../246929/index.html">Anonymous leaked a large list of passwords, credit cards, and the film ‚ÄúThe Interview‚Äù by Sony</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>