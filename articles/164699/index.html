<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Plugin system as an exercise in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Somehow it turns out that in many systems with which I had to work I had my own component models or it came to the fact that they had to appear in thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Plugin system as an exercise in C ++ 11</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f4e/460/0a6/f4e4600a655ddee87ba7eca1f4f1b83f.jpg" align="left">  Somehow it turns out that in many systems with which I had to work I had my own component models or it came to the fact that they had to appear in this system, because it was already understood that decomposition was already needed and the system code in one module to exist more and more difficult. <br><br>  Does it make sense to write something like this or take a ready-made solution?  The answer to this question does not provide a post.  In this post there will be no philosophy on the topic "Why is it necessary?" <br><br>  An attempt to do something similar was already in C ++ 03.  It developed a component / plug-in model that lives within the process.  For me, the solution of such a problem is interesting.  In gcc 4.7.2, everything that was interesting to me at the time of the beginning of this article appeared, and this is the beginning of this (2013) year.  And then I came to C ++ 11 ... At work in one direction, at home in another.  To play around with C ++ 11 I decided to rewrite the material from the old article with new language features.  To do in a sense an exercise in C ++.  But for some reason, I was unable to bring the article to the end of more than six months, and the article was left in untouched drafts.  Got, shook off naphthalene.  What came out of this can be read further. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/759/bab/5a5/759bab5a5249dcc356a9e22223d67aee.jpg" align="left"><br><h4>  About the decision to use C ++ 11 </h4><br>  We waited, waited and finally waited for the release of C ++ updates.  A new language standard has been released - C ++ 11. This version of the programming language has brought many interesting and useful features, but is it worth it to use it for the time being a controversial issue, but not all compilers support it or support it in incomplete form. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/45c/6a7/1f5/45c6a71f555419bd1de7169454533171.jpg" align="left"><h4>  Introduction and some philosophy </h4><br>  Here we will talk a little about the principles on which this implementation of the plug-in system or component model is built and why that is chosen rather than the other way.  Some water will be poured out: my reflections.  If you are not interested in such philosophizing, then go ahead with the implementation. <br><br><h5>  Interfaces and IDs </h5><br>  The basis of the described development will be based on the interaction of system components via interfaces.  The interface in this context should be understood as a C ++ structure containing only purely virtual methods.  The interface will be some logical unit around which everything is built. <br><br>  One of the important questions can be - what to use as an identifier for an interface, implementation, module and other entities.  In the previous article, the C-string was used as an identifier, since it is possible to provide greater uniqueness if, for example, uuid is used as an identifier, generated by some tool and translated into a string.  You can use a numeric identifier as an identifier.  In such a solution, the uniqueness will be weaker, but there are advantages - at least, a high performance, which is obvious, comparing strings is more laborious than numbers.  As a value of a numeric identifier, you can use for example CRC32 from a string.  Suppose there is an Ibase interface and it is in the Common namespace.  CRC32 from the string ‚ÄúCommon.IBase‚Äù can become an identifier.  Yes, if suddenly interface identifiers coincide somewhere, since this is not uuid, then you will get many hours of ‚Äúhappy‚Äù debugging and get a good idea of ‚Äã‚Äãmastering the strength of the Russian language.  But if you do not have ambitions that your model will be used throughout the world in global systems, then the probability of an outcome with long debugging is minimal.  In a pair of offices, they dealt with their ‚Äúcrafts‚Äù in the style of MS-COM, in which numerical values ‚Äã‚Äãwere used as an identifier and did not come across the problem described above, and there were no rumors that someone had it either.  Therefore, this implementation will use a numeric identifier.  In addition to the performance of this solution, there is another positive point: with a numeric identifier at the time of compilation, you can do a lot of interesting things, since you cannot manipulate strings as template parameters, and the number is easy.  And then just the first plus C ++ 11 will be used - this is constexpr, with which you can calculate hash values ‚Äã‚Äãat the time of compilation. <br><br><h5>  Cross-platform and language support </h5><br>  The described model will be cross-platform.  Cross something there - this is one of the interesting points in the design.  For a C ++ developer, one of the most understandable tasks is to support cross-platform, but less often there are also tasks related to cross-compilation, since what is easily supported by one compiler may not be supported otherwise.  One such example is before the implementation of the decltype implementation of an attempt to implement how to get an expression type at compile time.  A good example is BOOST_TYPEOF.  If you look under the hood of BOOST_TYPEOF, you will find a considerable set of sticks and crutches, since such things could not be implemented using C ++ 03, but were solved mainly on some advanced features of a specific compiler.  Also in C ++ 11, the standard library has expanded, which made it possible to refuse to write your own wrappers on threads, synchronization objects, etc.  For the library functions on type support, developers of the standard can say a special thank you, since they eliminated the need to write their code in many cases, and, most importantly, gave the implementation of such methods as std :: is_pod and others, which can be implemented using standard C ++ 03 tools without using compiler extensions was impossible. <br><br><h5>  Whether to use third-party libraries </h5><br>  There was a desire to minimize the use of third-party libraries and, if possible, reduce their use to zero.  This will be development in pure C ++.  When implementing the final components, anything can be used because of the task, any libraries, but the model itself, given here, will be pure in the sense of using third-party libraries. <br><br>  I have a certain attitude to the use of third-party libraries: do not use the library in a project if its functionality is not used by the client code as much as possible.  You should not drag Qt into a project just because some people like to use QStrung and QList.  Yes, I met projects in which some libraries and frameworks were dragged behind the ears just to use some small and unimportant part of it simply because of the habits of some developers.  In general, it is impossible to deny the use of such libraries as boost, Qt, Poco and others, but they should be applied to the place, included in the project only when they have a great need.  You should not breed a zoo, so, in the project, make a couple of exotic animals and no more :) so as not to get a project in which there are 5-7 pieces, or even more types of strings, 2-3 of which are own bicycles, and the rest came from other libraries and written a bunch of converters from one implementation to another.  As a result, the developed program instead of doing useful work may well be a significant amount of time converting between different implementations of the same entities. <br><br><h5>  Boss ... </h5><br>  Somehow I got used to lay out code in namespaces.  <b>Boss</b> (base objects for service solutions) will be chosen as the name of the namespace and the whole model.  About the origins of the name can be found in the <a href="http://habrahabr.ru/post/128135/">previous article</a> on this topic.  In the comments to the article, it was noted that ‚ÄúBoss‚Äù can be embarrassing in the code, due to the reminders of the authorities and stereotypes associated with it.  Initially, there was no goal to focus the title on a certain ‚Äúcudgel‚Äù (¬© Our Russia).  But if someone causes negative associations, then why not look at it from a different angle?  There is a wonderful book by Ken Blanchard ‚ÄúLeadership to the heights of success‚Äù, which describes high-performance organizations and servant-leaders whose goal is to do the maximum for the employee to give everything for his work with maximum productivity, and not just to stand with a stick behind his back.  Those.  Leader - assistant in the organization of effective work.  Boss is preferably perceived as a manager in a highly efficient organization that helps employees achieve maximum productivity by providing them with everything they need to do so.  Within the framework of the component model, this is exactly help in organizing a thin layer for more simple interaction of entities in the system, and not a monstrous framework with which to fight and most of the work is aimed only at working with it, and not at business logic. <br><br><h5>  Minimalism in the interface </h5><br>  One of the criteria, which for me plays an important role when reviewing a regular library, is the speed of starting work with the library and providing it with more and more advanced options for setting it up for the task.  Ie the library should not force a very long ritual to perform its user before something starts to work with its use.  But at the same time, as necessary, it should be possible to get more and more opportunities for its configuration and adaptation to more difficult tasks.  Those.  Initially, here is your ‚ÄúPysch‚Äù button, after clicking on it, a certain sequence of actions is performed on a specific pattern, and if necessary, here is a control panel with a bunch of buttons and switches.  This idea was one of the key points in the proposed model: to hide from the user as much as possible at the initial stages.  Inside libraries, code can be arbitrarily complex, but with all its complexity it has to justify maximum ease of use of the library itself. <br><br><h5>  Multiple inheritance implementations </h5><br>  A lot of holy wars have been and are being conducted on the multiple inheritance of realizations on the Internet.  I believe that multiple inheritance is one of the strengths of C ++.  Yes, sometimes there are problems with it, but without it, it is also not always possible to get out easily.  Each C ++ tool is not intended to somehow be taken and used only because it is there, but when the need arises, the tool is there. <br><br>  When I start to sing the advantages of languages ‚Äã‚Äãwith multiple inheritance of only interfaces, I like to ask about the solution of the following problem.  Suppose there are two interfaces and an implementation for each.  These interfaces and implementations are used in the project for some considerable time.  Yes, the problem of design and fat interfaces is bad, but let's say these interfaces have more than a dozen methods, and, accordingly, their implementations implement all this.  And here there is a need to implement a component with the functionality of these two entities, but with the implementation of another third interface.  With support for multiple inheritance of implementations, everything is solved simply: a class is derived from the new interface and from two existing implementations, and only the methods of the new third interface are implemented.  But with the support of only multiple inheritance of interfaces such a simple solution will not be. <br><br>  Here, of course, you can dissolve a considerable discussion about the design of the system, but real practice is not as idealistic as theoretical code design. <br>  Once at the interview I asked the candidate (far from a youth) about what he knows about multiple inheritance.  The answer was approximately as follows: ‚ÄúYes, I know that there is multiple inheritance and, it seems, like, there is also virtual plural inheritance, but this is bad.  I never use it.  And I can't say anything more about it. ‚Äù <br><br>  If you want to make new entities, dialing them from cubes-ready entities, then multiple inheritance is one of the most useful mechanisms.  And component models are just a space for building something new from pieces of something already existing. <br><br><h4>  Implementation </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/8ef/2c1/bf5/8ef2c1bf5b9b084e314b5bbc298050c9.jpg" align="left"><h5>  Core </h5><br>  As already noted, everything is built around interfaces - C ++ structures with purely virtual methods and some admixture (interface identifier). <br>  The basic interface from which all existing in this implementation should inherit: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"Boss.IBase"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() {} BOSS_DECLARE_IBASE_METHODS() }; }</code> </pre> <br>  Hmm, virtual destructor and a couple of macros ... Many will exclaim: ‚ÄúMacros are bad!‚Äù Yes, it‚Äôs bad when they are abundant and applied anywhere.  In small quantities and only when necessary, it is useful, as a poison in pharmacology - kills and heals, depending on the dosage. <div class="spoiler">  <b class="spoiler_title">BOSS_DECLARE_IFACEID</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BOSS_DECLARE_IFACEID(ifaceid_) \ static constexpr Boss::InterfaceId const GetInterfaceId() \ { \ return Boss::Crc32(ifaceid_); \ }</span></span></code> </pre></div></div>  adds some static method with which you can get the interface identifier.  Since the static method does not affect the data structure in any way, therefore, you can safely transfer the interface between modules collected even on different compilers, and constexpr will allow the resulting value to be used for parameterization of templates. <br><br>  As an interface identifier, a macro is passed as a string parameter.  Somehow the lines look more pleasant in the code than dry numbers, and you also need to have a certain set of data from which to generate a numeric identifier.  As an identifier selected crc32 from the string.  And here it is the strength of the new standard: you can count crc32 and other things from the lines at the time of compilation!  Such a trick, of course, does not come out with the lines dynamically created in the program, and it is not useful for solving this problem. <br><br>  To implement the crc32 calculation, you need some table with data that can be easily found on the Internet.  With its help, crc32 can be considered as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Crc32TableWrap</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Table[<span class="hljs-number"><span class="hljs-number">256</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>L, <span class="hljs-number"><span class="hljs-number">0x77073096</span></span>L, <span class="hljs-number"><span class="hljs-number">0xee0e612c</span></span>L, <span class="hljs-number"><span class="hljs-number">0x990951ba</span></span>L, <span class="hljs-number"><span class="hljs-number">0x076dc419</span></span>L, <span class="hljs-number"><span class="hljs-number">0x706af48f</span></span>L, <span class="hljs-number"><span class="hljs-number">0xe963a535</span></span>L, <span class="hljs-number"><span class="hljs-number">0x9e6495a3</span></span>L, <span class="hljs-number"><span class="hljs-number">0x0edb8832</span></span>L, <span class="hljs-number"><span class="hljs-number">0x79dcb8a4</span></span>L, ... etc }; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Crc32TableWrap&lt;EmptyType&gt; Crc32Table; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> I&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Crc32Impl(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *str) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Crc32Impl &lt; I - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(str) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) ^ Crc32Table::Table[(Crc32Impl&lt; I - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(str) ^ str[I]) &amp; <span class="hljs-number"><span class="hljs-number">0x000000FF</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Crc32Impl&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Crc32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;str)[N])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Private::Crc32Impl&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(str) - <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(str) ^ <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>); } }</code> </pre><br>  Why is the table wrapped in a structure, and even in a template?  To get rid of the cpp-file with the data definition, i.e.  everything is only in the included file and without the charms of static data in the included files. <br><br>  Crc32 is calculated, the identifier is generated.  Now to consider what lies under the second macro: <div class="spoiler">  <b class="spoiler_title">BOSS_DECLARE_IBASE_METHODS</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BOSS_DECLARE_IBASE_METHODS() \ virtual Boss::UInt BOSS_CALL AddRef() = 0; \ virtual Boss::UInt BOSS_CALL Release() = 0; \ virtual Boss::RetCode BOSS_CALL QueryInterface(Boss::InterfaceId ifaceId, Boss::Ptr *iface) = 0;</span></span></code> </pre></div></div>  But!  Surely it was impossible to just take and place the three methods in the structure?  Why macro?  And to finish off with the question of the presence of relatives in India ... But since there is no refusal from multiple inheritance and, moreover, it is very welcome in this model, in order to calm the compiler's anxiety that it is not clear from which branch of inheritance to take any of the methods described under the macro, this macro will be used in several more places. <br><br>  Managing the lifetime of objects is implemented through reference counting.  The functions of the IBase interface include methods for working with a reference counter and a method for requesting interfaces from an object. <br><br>  An example of a user interface definition: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> BOSS_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre>  Almost everything is clear: the interface, the declaration of its methods, the definition of the identifier.  But why not just make inheritance from Ibase? <br><br>  The second example is the user interface, so that further explanation is clearer: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace1</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> BOSS_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace2</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> BOSS_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace3</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;IFace1, IFace2&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace3"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> BOSS_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre>  Now everything is revealed?  Not?  Everything is simple: in the presence of multiple inheritance, even only interfaces need to somehow be able to ‚Äúget around‚Äù in their search for the necessary QueryInterface implementation.  The case is a little esoteric, but sometimes I stumbled upon a similar one.  Suppose you have a pointer to IFace3, it is clear that all the methods of its base classes can be called here on the spot.  And if you transfer it to another function, more generalized, which always requests IFace1 or IFace2 from some interface, not necessarily with such a structure of inheritance, it no longer relies on the C ++ mechanisms, but on the implemented QueryInterface, the implementation of which needs this hierarchy get around  This is where some impurity comes in: Boss :: Inherit, which has the following implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inherit</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T ... { <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Inherit() {} <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T ... &gt; BaseInterfaces; BOSS_DECLARE_IBASE_METHODS() }; }</code> </pre>  This impurity is simply inherited from the transferred list of basic interfaces, ‚Äúcalms down‚Äù the compiler from the illegibility of choosing the right method (using BOSS_DECLARE_IBASE_METHODS) and ‚Äúdropping‚Äù the list of inherited interfaces.  Here the new standard gives such an advantage as templates with a variable number of parameters.  Hurray, wait!  Previously, this was solved through bulky lists of types in the style Alexandrescu.  Well, here too, the new ‚Äúpluses‚Äù still gave a bonus in the form of a tuple, freeing you from writing your similar bicycle. <br><br>  How, from what and why to define user interfaces is considered, but they need to be implemented somewhere and somehow.  First, a small example of the implementation of interfaces: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace1</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face_1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Boss::CoClass&lt;Boss::Crc32(<span class="hljs-string"><span class="hljs-string">"Face_1"</span></span>), IFace1&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } };</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">And a great example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace1</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace2</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFace3</span></span></span><span class="hljs-class"> :</span></span> Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"IFace3"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Boss::CoClass&lt;Boss::Crc32(<span class="hljs-string"><span class="hljs-string">"Face1"</span></span>), IFace1&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mtd1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } }; class Face2 : public Boss::CoClass&lt;Boss::Crc32("Face2"), IFace2&gt; { public: virtual void Mtd2() { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } }; class Face123 : public Boss::CoClass&lt;Boss::Crc32("Face123"), Face1, Face2, IFace3&gt; { public: virtual void Mtd3() { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } }; struct IFace4 : Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID("IFace4") virtual void Mtd4() = 0; }; struct IFace5 : Boss::Inherit&lt;Boss::IBase&gt; { BOSS_DECLARE_IFACEID("IFace5") virtual void Mtd5() = 0; }; struct IFace6 : Boss::Inherit&lt;IFace4, IFace5&gt; { BOSS_DECLARE_IFACEID("IFace6") virtual void Mtd6() = 0; }; class Face123456 : public Boss::CoClass&lt;Boss::Crc32("Face123456"), Face123, IFace6&gt; { public: virtual void Mtd4() { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } virtual void Mtd5() { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } virtual void Mtd6() { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> } };</span></span></code> </pre></div></div>  with all the "meanness" for the implementation, which it will have to disassemble.  It is clear that you can bloat more chaos.  The above example describes the possibilities of implementation in the construction of "cubes". <br><br>  It's hard not to notice that every implementation inherits from CoClass.  CoClass has a very simple implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;ClassId ClsId, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoClass</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Private::CoClassAdditive , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T ... { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;T ... &gt; BaseEntities; CoClass() : Constructed(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// IBase BOSS_DECLARE_IBASE_METHODS() private: template &lt;typename Y&gt; friend void Private::SetConstructedFlag(Y *, bool); template &lt;typename Y&gt; friend bool Private::GetConstructedFlag(Y *); bool Constructed; }; }</span></span></code> </pre>  This class, as well as the structure of Inherit, is inherited from the list of transferred entities, "dropping" this list of inheritance, is inherited from some <div class="spoiler">  <b class="spoiler_title">impurities (Private :: CoClassAdditive) / brands</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoClassAdditive</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~CoClassAdditive() {} }; } }</code> </pre></div></div>  (which will be used to classify entities: interface or implementation), also eliminates the compiler from indiscriminations (by punching methods through BOSS_DECLARE_IBASE_METHODS) and contains a sign of the constructed object (Constructed). <br><br>  There are interfaces, there are their implementations, but so far no IBase implementation has been implemented.  The implementation of this interface will probably be one of the most complex. <br><br>  To create an object from the above large example, it will look something like this: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Obj = Boss::Base&lt;Face123456&gt;::Create();</code> </pre><br>  Boss :: Base is a class implementation of Boss :: IBase.  In the implementation to perform certain operations have to bypass the class hierarchy.  So for the example above, the simplified hierarchy will look like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/12e/94a/e8f12e94a702eadc86f90922457eed14.png"><br>  Bypassing the class hierarchy in search of the necessary briefly postpone.  Quickly go through more simple methods. <br><br>  Reference counting is performed by calling the AddRef methods (increases the reference count) and Release (decreases the reference count and, upon reaching zero, deletes the object, making delete this).  Since it is assumed that objects can be used in a multi-threaded environment, the work with the counter is done through std :: atomic, which allows the counter to be increased and decreased in a multi-threaded environment.  Yes, finally C ++ recognized the existence of threads and support for working with threads and synchronization primitives appeared. <br><br>  The Create method has the following implementation: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RefObjPtr&lt;T&gt; Create(Args <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... args) { Private::ModuleCounter::ScopedLock Lock; RefObjPtr&lt;T&gt; NewInst(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base&lt;T&gt;(args ...)); Private::FinalizeConstruct&lt;T&gt;::Construct(NewInst.Get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(NewInst); }</code> </pre>  The presence of templates with a variable number of parameters allows you to create a method for constructing objects and transfer the required parameters to the constructor.  Previously, it was impossible to do this, and if the object needed some initial settings, then it was necessary to create an object that had some method (its own specific) of type Init, into which it was necessary and passed. <div class="spoiler">  <b class="spoiler_title">ModuleCounter</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleRefCounterTypeStub</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleRefCounter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Counter.fetch_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_relaxed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Counter.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_relaxed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> UInt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;UInt&gt; Counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedLock</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ScopedLock(ScopedLock <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; ScopedLock(ScopedLock &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; ScopedLock <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (ScopedLock <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; ScopedLock <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (ScopedLock &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; ScopedLock() { ModuleRefCounter&lt;T&gt;::AddRef(); } ~ScopedLock() { ModuleRefCounter&lt;T&gt;::Release(); } }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;UInt&gt; ModuleRefCounter&lt;T&gt;::Counter(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ModuleRefCounter&lt;ModuleRefCounterTypeStub&gt; ModuleCounter; } }</code> </pre> </div></div>  Manages the module's reference count.  There are two reference counters - this is the reference counter directly at the object and the counter of all module references.  The module‚Äôs link counter is needed so that you can understand when there are ‚Äúlive‚Äù objects in the module, and when there are none and the module can be unloaded. <br><br>  To abandon static libraries and implement the loner pattern (for each of the modules) you need for the ModuleRefCounter entity to implement it only in the included file, then a trick with templates and static objects is quite useful.  More details about this can be found in the previous article.  This can be briefly described as follows: if you create a type template with a static field and instantiate it with any type, then an instance of this object will be the only one for the entire module.  It turns out a small trick used to write singles in the included files without implementation somewhere in the cpp-file (singles in include). <br>  And in this beautiful solution there is a rake, a children's rake: the handle is two times shorter, beats more accurately and hurts ... This solution works fine in .dll, but in .so caught the problem: the template with static fields, instantiated by the same type, became one on all .so with components of this model in the framework of the process!  Why I realized a little later, but I had to abandon a beautiful solution in favor of a simpler one, based on nameless namespaces and an included file, which is included in each module no more than once (who cares - boss / include / plugin / module.h). <br><br>  C ++ is considered by many to be a language that makes it easy to "shoot yourself in the foot."  And, as a rule, it is often persecuted because of the consideration of the pair of operations for the allocation / release of resources, and in particular of memory.  But if you use smart pointers, then one headache becomes less.  RefObjPtr is precisely a smart pointer that calls AddRef and Release to control the lifetime of an object and in the program when it is used; the AddRef and Release methods should not appear in user code. <br><br>  Such a bun of the new standard as r-value allows you to write more optimal entities;  for example, the same RefObjPtr to return an object without invoking AddRef / Release once again on copy constructors (return std :: move (NewInst)). <br><br>  There is also in Create and appeal to someone FinalizeConstruct.  What is it and why?  Suppose you have a hierarchy, it is about not simpler than the one shown in the figure above, and you need to call something in one of the interface implementations, which is defined in the class below.  You can use virtual functions, but, to put it simply, the designer still does not have a virtual table of functions, but it does not already exist in the destructor.  All calls to virtual functions will be like calls to ordinary functions of the class and it will not be possible to call the redefined function one level below from the constructor.  FinalizeConstruct is made on this case, which will be called after the object is already fully created.  It turns out that it is necessary to implement some logic similar to the logic of calling constructors, only on our own, i.e.  bypass the entire hierarchy and call FinalizeConstruct for each class in the order in which the constructors are called. <br><br>  The class developer is not required to determine FinalizeConstruct in its class.  When traversing the class hierarchy, the FinalizeConstruct logic implemented in the model will determine with the help of the good old SFINAE the presence of the FinalizeConstruct class in the class and, if this method is present, it will call it.  The main rule: implementation in the custom code FinalizeConstruct should not be virtual!  Otherwise, there will be confusion when constructing entities from ready-made cubes. <br>  The presence in the class of FinalizeConstruct is determined by the following code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasFinalizeConstruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;No)</span></span></span><span class="hljs-function">[1]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;Yes)</span></span></span><span class="hljs-function">[10]</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (U::*)() = &amp;U::FinalizeConstruct&gt; struct CheckMtd { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Yes Type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CheckMtd&lt;U&gt;::<span class="hljs-function"><span class="hljs-function">Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> No </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { Has = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Check(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Yes) }; };</code> </pre><br><div class="spoiler">  <b class="spoiler_title">All logic on call FinalizeConstruct</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasFinalizeConstruct&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallFinalizeConstruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;FinalizeConstruct(); SetConstructedFlag(obj, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallFinalizeConstruct</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj)</span></span></span><span class="hljs-function"> </span></span>{ SetConstructedFlag(obj, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCoClass = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;CoClassAdditive, T&gt;::value &gt; struct FinalizeConstruct { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Construct(ObjType *) { } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FinalizeConstructIter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_element&lt;I, T&gt;::type CurType; FinalizeConstructIter&lt;T, I - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::Construct(obj); FinalizeConstruct&lt;CurType&gt;::Construct(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;CurType *&gt;(obj)); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FinalizeConstructIter</span></span></span><span class="hljs-class">&lt;T, -1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *)</span></span></span><span class="hljs-function"> </span></span>{ } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FinalizeConstruct</span></span></span><span class="hljs-class">&lt;T, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::BaseEntities BaseEntities; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { BaseEntityCount = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_size&lt;BaseEntities&gt;::value - <span class="hljs-number"><span class="hljs-number">1</span></span> }; FinalizeConstructIter&lt;BaseEntities, BaseEntityCount&gt;::Construct(obj); CallFinalizeConstruct&lt;HasFinalizeConstruct&lt;T&gt;::Has&gt;::Call(obj); } }; } }</code> </pre></div></div>  built on private specializations of templates and walking the hierarchy through prikupannye tuples with types of base classes.  The standard library has become a means of working with types, so, to determine whether a class belongs to an implementation class, you can now use std :: is_base_of, rather than writing your own implementation.  You can also use std :: tuple instead of type lists in the Alexandrescu style. <br><br>  The analogy to designers is ready, but what about the analogy to destructors?  Where do without it.  The model implements logic to bypass the class hierarchy in order to call destructors, search in the implementation class all through the same SFINAE BeforeRelease method and if there is a call to it.  The implementation of the logic to work with BeforeRelease is similar to the logic of FinalizeConstruct, but only in the reverse order of the detour. <br><br>  Now it is possible to deconstruct an object after its complete creation and release something before the destruction of the object.  But in the constructor you can report a problem by throwing an exception from it.  The same behavior is implemented in this model: in any method of FinalizeConstruct in the hierarchy, you can throw an exception and the rest of the FinalizeConstruct chain will not be called anymore, besides, for objects of the hierarchy for which FinalizeConstruct has already passed successfully will be called BeforeRelease.  It turns out a complete analogy to C ++ constructors and destructors.  BeforeRelease is called from the implementation of the Release method and when traversing the hierarchy BeforeRelease will be called only for those objects for which the FinalizeConstruct call was successful, and the call success is determined by the Constructed flag located in the CoClass (remember?).  It is also worth noting that if there is no need for a pair of these methods in a class, then only one can be present, if it is needed at all. <br><br>  It remains to implement the logic <div class="spoiler">  <b class="spoiler_title">QueryInterface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Private { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsImpl&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryInterfacesListIter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj, InterfaceId ifaceId, Ptr *iface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_element&lt;I, T&gt;::type CurType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifaceId == InterfaceTraits&lt;CurType&gt;::Id) { *iface = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;CurType *&gt;(obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status::Ok; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QueryInterfacesListIter&lt;T, I - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::Query(obj, ifaceId, iface) == Status::Ok ? Status::Ok : QueryInterface&lt;CurType, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;::Query(obj, ifaceId, iface); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryInterfacesListIter</span></span></span><span class="hljs-class">&lt;T, -1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *, InterfaceId, Ptr *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status::InterfaceNotFound; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryFromInterfacesList</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj, InterfaceId ifaceId, Ptr *iface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::BaseInterfaces BaseInterfaces; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { BaseInterfaceCount = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_size&lt;BaseInterfaces&gt;::value - <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QueryInterfacesListIter&lt;BaseInterfaces, BaseInterfaceCount&gt;::Query(obj, ifaceId, iface); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryFromInterfacesList</span></span></span><span class="hljs-class">&lt;IBase&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj, InterfaceId ifaceId, Ptr *iface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifaceId == InterfaceTraits&lt;IBase&gt;::Id) { *iface = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;IBase *&gt;(obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status::Ok; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status::InterfaceNotFound; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCoClass = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;CoClassAdditive, T&gt;::value &gt; struct QueryInterface { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RetCode Query(ObjType *obj, InterfaceId ifaceId, Ptr *iface) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ifaceId == InterfaceTraits&lt;T&gt;::Id) { *iface = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T *&gt;(obj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status::Ok; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QueryFromInterfacesList&lt;T&gt;::Query(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T *&gt;(obj), ifaceId, iface); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> I&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryInterfaceIter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj, InterfaceId ifaceId, Ptr *iface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_element&lt;I, T&gt;::type CurType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QueryInterface&lt;CurType&gt;::Query(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ObjType *&gt;(obj), ifaceId, iface) == Status::Ok ? Status::Ok : QueryInterfaceIter&lt;T, I - <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::Query(obj, ifaceId, iface); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryInterfaceIter</span></span></span><span class="hljs-class">&lt;T, -1&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj, InterfaceId ifaceId, Ptr *iface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status::InterfaceNotFound; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-class">&lt;T, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RetCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ObjType *obj, InterfaceId ifaceId, Ptr *iface)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T::BaseEntities BaseEntities; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { BaseEntityCount = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple_size&lt;BaseEntities&gt;::value - <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QueryInterfaceIter&lt;BaseEntities, BaseEntityCount&gt;::Query(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T *&gt;(obj), ifaceId, iface); } }; } }</code> </pre></div></div>  which, by and large, is not very different from the hierarchy traversal described above.  When traversing a hierarchy and when meeting in the implementation class tree, its priped list of basic entities is taken and it recursively manages to find the right interface.  There is one addition.  Since there is an opportunity to work with interfaces that are multiple inherited from other interfaces, when meeting in the interface search hierarchy, it costs in searching for the desired interface similarly to bypassing the implementation class, but only with a prikopanny list of only one interface. <br><div class="spoiler">  <b class="spoiler_title">Implementing Boss :: iBase</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Base(Base <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; Base <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (Base <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; Base(Base &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; Base <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (Base &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RefObjPtr&lt;T&gt; Create(Args <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... args) { Private::ModuleCounter::ScopedLock Lock; RefObjPtr&lt;T&gt; NewInst(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base&lt;T&gt;(args ...)); Private::FinalizeConstruct&lt;T&gt;::Construct(NewInst.Get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(NewInst); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;UInt&gt; Counter; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Args&gt; Base(Args <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... args) : T(args ...) , Counter(<span class="hljs-number"><span class="hljs-number">0</span></span>) { Private::ModuleCounter::AddRef(); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() { Private::ModuleCounter::Release(); } <span class="hljs-comment"><span class="hljs-comment">// IBase virtual UInt BOSS_CALL AddRef() { return Counter.fetch_add(1, std::memory_order_relaxed) + 1; } virtual UInt BOSS_CALL Release() { UInt CurValue = Counter.fetch_sub(1, std::memory_order_relaxed); if (CurValue == 1) { Private::BeforeRelease&lt;T&gt;::Release(static_cast&lt;T *&gt;(this)); std::atomic_thread_fence(std::memory_order_acquire); delete this; } return CurValue - 1; } virtual RetCode BOSS_CALL QueryInterface(InterfaceId ifaceId, Ptr *iface) { RetCode Ret = Private::QueryInterface&lt;T&gt;::Query(static_cast&lt;T *&gt;(this), ifaceId, iface); if (Ret == Status::Ok) AddRef(); return Ret; } }; }</span></span></code> </pre></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use the final keyword in the inheritance hierarchy of user implementations and other auxiliary classes to exclude the possibility of inheritance from this implementation. You can also explicitly say this in the interface of this class to explicitly exclude the possibility of copying and moving objects of this type. what is not needed as deleted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The kernel is ready! All the most difficult and interesting described. Then everything will be much easier and smoother, without puzzles.</font></font><br><br><h5>  Plugins </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part we will discuss the organization of plug-ins. </font><font style="vertical-align: inherit;">Plug-ins should be understood in the current context of dynamic libraries (.so / .dll), which host interface implementation classes (components) and a small set of functions for accessing objects of these implementation classes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This part of the article, in my opinion, is the simplest, since there is no ‚Äútemplate programming‚Äù and other mockery of the compiler. </font><font style="vertical-align: inherit;">Just the creation of a certain set of interfaces and implementations for the organization of the plugin system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the ‚Äúlife‚Äù component in their dwellings (plug-ins) within one state, called the process, not so much is needed:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Register of plugins / components / services </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Class factory </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loader </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The service registry is a place to store all information about the service: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Service ID </font></font></li><li>     - </li><li>    (so / dll)   ,      </li><li>     Proxy/Stub'        .         </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on this information, the class factory will be able to load the necessary plug-ins and create interface implementation objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The role of the loader is to load the component registry, load the class factory and configure it to work with the service registry. After that, all calls to create objects will be only to the factory and the user gets some abstraction, he should not worry in which of the modules his object is located and how to create it. The user operates only with identifiers of classes of implementations when requesting to create a new object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The service registry provides an interface with just one method, which is sufficient to obtain the necessary information for the class factory.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IServiceRegistry</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Inherit&lt;IBase&gt; { BOSS_DECLARE_IFACEID(<span class="hljs-string"><span class="hljs-string">"Boss.IServiceRegistry"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> RetCode BOSS_CALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetServiceInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassId clsId, IServiceInfo **info)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the service registry implementation class itself can supply several interfaces. </font><font style="vertical-align: inherit;">What was it all for? </font><font style="vertical-align: inherit;">Make composing components.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class-implementation of the registry services</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRegistry</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CoClass &lt; Service::Id::ServiceRegistry, IServiceRegistry, IServiceRegistryCtrl, ISerializable &gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ServiceRegistry(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ServiceRegistry(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// IServiceRegistry virtual RetCode BOSS_CALL GetServiceInfo(ClassId clsId, IServiceInfo **info) const; // IServiceRegistryCtrl virtual RetCode BOSS_CALL AddService(IServiceInfo *service); virtual RetCode BOSS_CALL DelService(ServiceId serviceId); // ISerializable virtual RetCode BOSS_CALL Load(IIStream *stream); virtual RetCode BOSS_CALL Save(IOStream *stream); // ... }; }</span></span></code> </pre></div></div>  those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the implementation provides an interface for manipulating the registry (IServiceRegistryCtrl,) and loading and saving it (ISerializable). </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class factory implementation</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassFactory</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CoClass &lt; Service::Id::ClassFactory, IClassFactory, IClassFactoryCtrl &gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// IClassFactory virtual RetCode BOSS_CALL CreateObject(ClassId clsId, IBase **inst); // IClassFactoryCtrl virtual RetCode BOSS_CALL SetRegistry(IServiceRegistry *registry); // ... }; }</span></span></code> </pre></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It also supplies several interfaces: one main (IClassFactory), which all clients will use to create objects and auxiliary (IClassFactoryCtrl), which the loader uses to configure the factory to the registry. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The bootloader code is quite simple, but unfortunately, C ++ 11 did not recognize the platform (OS) very little. They recognized multithreading, but the existence of such things as dynamic libraries yet. So for loading of modules the code depending on an operating system will be used. Of course hidden deep. It would be nice to remember about </font></font><a href="http://c2.com/cgi/wiki%3FPimplIdiom"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pImple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but since the policy was aimed at abandoning static libraries, it will be a little different: the implementation for each OS in its header file and the file interface that parses what to include based on __ linux__ and _WIN32.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A small example of the use of services in the framework of the model of plug-ins that live in the same process: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "plugin/loader.h" #include "plugin/module.h" int main() { try { Boss::Loader Ldr("Registry.xml", "./libservice_registry.so", "./libclass_factory.so"); Boss::RefObjQIPtr&lt;Boss::IBase&gt; Inst; Inst = Ldr.CreateObject&lt;Boss::IBase&gt;(Boss::Crc32("MyClass")); } catch (std::exception const &amp;e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As it was noted at the beginning of the section, everything is very simple, only it took to write a certain amount of auxiliary code. </font></font><br><br><img src="https://habrastorage.org/storage2/8ec/10d/e62/8ec10de623475fec3b31172e98881a1b.jpg" align="left"><h5>  Examples </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The best example is a real task, and not an artificially made-up pile-up, which demonstrates this or that possibility to the maximum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, when describing the kernel, I cited a very large example, which tried as much as possible to display the existing flexibility in collecting entities from ready-made implementations and adding a new interface. </font><font style="vertical-align: inherit;">But an example, despite the fact that it displays the capabilities of the model, it is far-fetched and does not look very friendly. </font><font style="vertical-align: inherit;">Therefore, as examples, we can consider the implementation of the necessary components of the plug-in part, namely the service registry and class factory. </font><font style="vertical-align: inherit;">Though they are part of the plug-in model, they are the same plug-ins as those that the user can develop for their needs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once again I will give the implementation class for the registry of services.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Registry Implementation</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceRegistry</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CoClass &lt; Service::Id::ServiceRegistry, IServiceRegistry, IServiceRegistryCtrl, ISerializable &gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ServiceRegistry(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ServiceRegistry(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// IServiceRegistry virtual RetCode BOSS_CALL GetServiceInfo(ClassId clsId, IServiceInfo **info) const; // IServiceRegistryCtrl virtual RetCode BOSS_CALL AddService(IServiceInfo *service); virtual RetCode BOSS_CALL DelService(ServiceId serviceId); // ISerializable virtual RetCode BOSS_CALL Load(IIStream *stream); virtual RetCode BOSS_CALL Save(IOStream *stream); // ... }; }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now I will try to describe what is happening here ...</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a class-implementation of one or more interfaces, you need to create a class derived from the template class CoClass. This class takes as parameters the class-implementation identifier (which can already be used to create an object through a class factory) and a list of inherited interfaces or ready-made interface implementations. If you look at the class implementation of the service registry, then you can see the identifier (Service :: Id :: ServiceRegistry) and the following interfaces that are implemented in this class (IServiceRegistry is the service registry interface that will be used by the class factory); ISrviceRegistryCtrl - registry management interface; ISerializable - the registry must be saved somewhere and loaded from somewhere and this interface allows you to perform the required).This completes the work on creating the component and you just need to implement its methods.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The component is ready. </font><font style="vertical-align: inherit;">It remains to publish it somehow, i.e. </font><font style="vertical-align: inherit;">enable access to it from outside the module in which it is located.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To do this, use the macro BOSS_DECLARE_MODULE_ENTRY_POINT</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"service_registry.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"plugin/module.h"</span></span></span><span class="hljs-meta"> namespace { typedef std::tuple </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; Boss::ServiceRegistry &gt; ExportedCoClasses; } BOSS_DECLARE_MODULE_ENTRY_POINT("ServiceRegistry", ExportedCoClasses)</span></span></span></span></code> </pre></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A string is passed to the macro from which the CRC32 used as the module identifier and the list of class implementations exported by this module will be calculated. </font><font style="vertical-align: inherit;">After that, the component and its module are ready (and there may be several components in the module), you can use it by registering in the registry (exception: the service registry and the class factory for normal use of the model can be unregistered). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another similar example: the implementation of the class factory, which has already been given above.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class factory</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Boss { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassFactory</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CoClass &lt; Service::Id::ClassFactory, IClassFactory, IClassFactoryCtrl &gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// IClassFactory virtual RetCode BOSS_CALL CreateObject(ClassId clsId, IBase **inst); // IClassFactoryCtrl virtual RetCode BOSS_CALL SetRegistry(IServiceRegistry *registry); // ... }; }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Completely similar example. </font><font style="vertical-align: inherit;">Also inheritance from CoClass, the identifier and the list of implemented interfaces. </font><font style="vertical-align: inherit;">The class factory is located in a separate module; accordingly, it has its own</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry point</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"class_factory.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"plugin/module.h"</span></span></span><span class="hljs-meta"> namespace { typedef std::tuple </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; Boss::ClassFactory &gt; ExportedCoClasses; } BOSS_DECLARE_MODULE_ENTRY_POINT("ClassFactory", ExportedCoClasses)</span></span></span></span></code> </pre></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> similar to the entry point of the registry services. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These were simple component implementations in which each component inherited only a list of interfaces, implemented their methods and that was all. There was no inheritance of ready-made implementations. And if you look again at the interface of the registry of services, then in it you will see work with IServiceInfo, through which all information is transmitted. IServiceInfo can only transmit general information about the service, but there is also private information. Initially I wanted to make plugins that live not only in dynamic libraries, but also scattered across processes, in their executable modules. Hence, different information: for plug-ins in dynamic libraries, only an addition about the path to it, and for plug-ins in separate executable modules a lot of additional information: information about Proxy / Stubs, transport, etc. (but, unfortunately, I did not finish this part to the end, but cut off the rudiments,So as not to clog the code with imperfections). Now I‚Äôll just give an example in which components are already inherited not only from interfaces, but also from implementations.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing Service Information</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __BOSS_PLUGIN_SERVICE_INFO_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __BOSS_PLUGIN_SERVICE_INFO_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../core/base.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../core/error_codes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../core/ref_obj_ptr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/enum.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/entity_id.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/string.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iservice_info.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; namespace Boss { namespace Private { template &lt;typename T, bool = !!std::is_base_of&lt;IServiceInfo, T&gt;::value&gt; class ServiceInfo; template &lt;typename T&gt; class ServiceInfo&lt;T, true&gt; : public CoClass&lt;Crc32("Boss.ServiceInfo"), T&gt; { public: // ‚Ä¶ void SetServiceId(ServiceId srvId) { // ... } void AddCoClassId(ClassId clsId) { // ... } void AddCoClassIds(RefObjPtr&lt;IEnum&gt; coClassIds) { // ... } private: // ‚Ä¶ // IServiceInfo virtual RetCode BOSS_CALL GetServiceId(ServiceId *serviceId) const { // ... } virtual RetCode BOSS_CALL GetClassIds(IEnum **ids) const { // ... } }; } class LocalServiceInfo : public CoClass&lt;Crc32("Boss.LocalServiceInfo"), Private::ServiceInfo&lt;ILocalServiceInfo&gt;&gt; { public: void SetModulePath(std::string const &amp;path) { // ... } void SetModulePath(RefObjPtr&lt;IString&gt; path) { // ... } private: // ... // ILocalServiceInfo virtual RetCode BOSS_CALL GetModulePath(IString **path) const { // ... } }; class RemoteServiceInfo : public CoClass&lt;Crc32("Boss.RemoteServiceInfo"), Private::ServiceInfo&lt;IRemoteServiceInfo&gt;&gt; { public: void SetProps(RefObjPtr&lt;IPropertyBag&gt; props) { // ... } private: // ... // IRemoteServiceInfo virtual RetCode BOSS_CALL GetProperties(IPropertyBag **props) const { // ... } }; } #endif // !__BOSS_PLUGIN_SERVICE_INFO_H__</span></span></span></span></code> </pre></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of ServiceInfo may seem a bit complicated. </font><font style="vertical-align: inherit;">Why and here a pattern? </font><font style="vertical-align: inherit;">This is the subtlety of the implementation of the data structure, which occurred to me, and not the tribute given to the component model / plug-in system. </font><font style="vertical-align: inherit;">To clarify a little the reason for this implementation, I will give the interface:</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service Information Interface</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __BOSS_PLUGIN_ISERVICE_INFO_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __BOSS_PLUGIN_ISERVICE_INFO_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../core/ibase.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/ienum.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/istring.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/iproperty_bag.h"</span></span></span><span class="hljs-meta"> namespace Boss { struct IServiceInfo : public Inherit</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;IBase&gt; { BOSS_DECLARE_IFACEID("Boss.IServiceInfo") virtual RetCode BOSS_CALL GetServiceId(ServiceId *serviceId) const = 0; virtual RetCode BOSS_CALL GetClassIds(IEnum **ids) const = 0; }; struct ILocalServiceInfo : public Inherit&lt;IServiceInfo&gt; { BOSS_DECLARE_IFACEID("Boss.ILocalServiceInfo") virtual RetCode BOSS_CALL GetModulePath(IString **path) const = 0; }; struct IRemoteServiceInfo : public Inherit&lt;IServiceInfo&gt; { BOSS_DECLARE_IFACEID("Boss.IRemoteServiceInfo") virtual RetCode BOSS_CALL GetProperties(IPropertyBag **props) const = 0; }; } #endif // !__BOSS_PLUGIN_ISERVICE_INFO_H__</span></span></span></span></code> </pre></div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A slightly more comprehensible implementation with inheritance of interfaces and implementations is given in the kernel description with a fancy Face123456 class without any templates :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How the components implement everything is cleared up.</font></font> It's simple.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And how to query and work with interfaces, query from one another - you can look at the example of the loader that loads the registry of services, gets the necessary interfaces from it, sets up the registry itself, loads the class factory and sets it up to work with the registry. </font><font style="vertical-align: inherit;">Then, of course, all the work of the client is already going on with the class factory and the client no longer has to work with the modules, otherwise, for the sake of which all this abstractness was started.</font></font><br><div class="spoiler">  <b class="spoiler_title">Loader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __BOSS_PLUGIN_LOADER_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __BOSS_PLUGIN_LOADER_H__ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iservice_registry.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iclass_factory.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"iclass_factory_ctrl.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"module_holder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"service_ids.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"core/exceptions.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"common/file_stream.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"common/iserializable.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; namespace Boss { BOSS_DECLARE_RUNTIME_EXCEPTION(Loader) class Loader final { public: Loader(Loader const &amp;) = delete; Loader&amp; operator = (Loader const &amp;) = delete; Loader(std::string const &amp;registryFilePath, std::string const &amp;srvRegModulePath, std::string const &amp;clsFactoryModulePath) : SrvRegistry([&amp;] () { auto SrvRegModule(ModuleHolder(std::move(DllHolder(srvRegModulePath)))); auto SrvReg = SrvRegModule.CreateObject&lt;IServiceRegistry&gt;(Service::Id::ServiceRegistry); RefObjQIPtr&lt;ISerializable&gt; Serializable(SrvReg); if (!Serializable.Get()) throw LoaderException("Failed to get ISerializable interface from Registry object."); if (Serializable-&gt;Load(Base&lt;IFileStream&gt;::Create(registryFilePath).Get()) != Status::Ok) throw LoaderException("Failed to load Registry."); return std::move(std::make_pair(std::move(SrvRegModule), std::move(SrvReg))); } ()) , ClsFactory([&amp;] () { auto ClassFactoryModule(ModuleHolder(std::move(DllHolder(clsFactoryModulePath)))); auto NewClsFactory = ClassFactoryModule.CreateObject&lt;IClassFactory&gt;(Service::Id::ClassFactory); RefObjQIPtr&lt;IClassFactoryCtrl&gt; Ctrl(NewClsFactory); if (!Ctrl.Get()) throw LoaderException("Failed to get ICalssFactoryCtrl interface from ClassFactory object."); if (Ctrl-&gt;SetRegistry(SrvRegistry.second.Get()) != Status::Ok) throw LoaderException("Failed to set Registry into ClassFactory."); return std::move(std::make_pair(std::move(ClassFactoryModule), std::move(NewClsFactory))); } ()) { } template &lt;typename T&gt; RefObjPtr&lt;T&gt; CreateObject(ClassId clsId) { RefObjPtr&lt;IBase&gt; NewInst; if (ClsFactory.second-&gt;CreateObject(clsId, NewInst.GetPPtr()) != Status::Ok) throw LoaderException("Failed to create object."); RefObjQIPtr&lt;T&gt; Ret(NewInst); if (!Ret.Get()) throw LoaderException("Interface not found."); return Ret; } ~Loader() { ClsFactory.second.Release(); SrvRegistry.second.Release(); } private: std::pair&lt;ModuleHolder, RefObjPtr&lt;IServiceRegistry&gt;&gt; SrvRegistry; std::pair&lt;ModuleHolder, RefObjPtr&lt;IClassFactory&gt;&gt; ClsFactory; }; } #endif // !__BOSS_PLUGIN_LOADER_H__</span></span></span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the examples given, examples from the article with the implementation of the previous version in C ++ 03 are relevant. The only difference is the work with identifiers. </font><font style="vertical-align: inherit;">In the new model, it is not necessary to add a separate macro to the implementation class, about which you can forget. </font><font style="vertical-align: inherit;">If you forget about the identifier in the new model, the compiler will remind you of this, since now it is a template parameter.</font></font><br><br><h5>  Conclusion </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There was some big idea, but it was realized only by 2/3: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fully implemented core </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implemented basic services for the existence of a plug-in system </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plug-ins that were supposed to dwell in other processes are not brought to mind, and all the rudiments are cut out in order not to litter the code. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somehow it happened that the moment of building the skeleton or skeleton of the system is most interesting for me, but building up muscles and fat injections (developing all kinds of utility / pseudo-uses) can sometimes be a job that is done very quickly due to good awareness in the system. Because of this, a very complete (in some places, redundantly full) core can be obtained (spherical horses in vacuum have always attracted me). There is a small part of the muscles (the main components of the plug-in system: the registry of services and the class factory) so that the model can at least somehow exist. But this implementation turned out to be completely fat free: there is nothing auxiliary in it. The skeleton of the system has been assembled, some muscles have been built up and a kick in the ass has been given so that it somehow moves from the place - it becomes the material and the Habr article.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project must be either released or terminated as early as possible, before it has eaten all the resources and safely disappeared from the field of attention. Due to this judgment and the fact that the article‚Äôs material turned out to be too big and, perhaps, difficult in some places, and the reason that I didn‚Äôt manage to pay more attention to this article for more than six months, the part with plug-ins is still missing. Soon, for example, C ++ 14 may appear, and then the material of this article on C ++ 11 may already become irrelevant. It may well be that the unrealized part will be released as a separate post ... This material will be based on the material of the article </font></font><a href="http://habrahabr.ru/post/147325/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Proxy / Stubs do-it-yourself"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which I wanted to rework with the C ++ 11 standard, add interface marshaling and put all the transport under it (implement one of the mechanisms IPC).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately and fortunately at the same time, the reader does not always take out the author's entire intention from his work, which he laid into it. </font><font style="vertical-align: inherit;">According to the source code, there are some scattered seals for the future, such as RemoteServiceInfo and others, which may well be missed when considering the material. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code is available on </font></font><a href="https://github.com/tdv/boss"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has a minimal build script. </font><font style="vertical-align: inherit;">It can serve as a source of examples and ideas for your projects.</font></font><br><br>  Thank you all for your attention! <br><br></div><p>Source: <a href="https://habr.com/ru/post/164699/">https://habr.com/ru/post/164699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164687/index.html">Alternative terminal for Windows</a></li>
<li><a href="../164689/index.html">We are looking for money. Catalog of investors for a startup</a></li>
<li><a href="../164693/index.html">OMNI-395 payment terminal from the inside</a></li>
<li><a href="../164695/index.html">Mars rover Spirit went down to Mars 9 years ago</a></li>
<li><a href="../164697/index.html">Corning will present Gorilla Glass 3 at CES 2013</a></li>
<li><a href="../164701/index.html">Clojure in the Belarusian State University</a></li>
<li><a href="../164703/index.html">AWS: Semifinalists Startup Contest</a></li>
<li><a href="../164705/index.html">WPF, WinForms: draw Bitmap with> 15000 FPS. Hardcore tricks Part 1</a></li>
<li><a href="../164707/index.html">Drupal: we write the parser for Feeds</a></li>
<li><a href="../164709/index.html">Work with Freebase from .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>