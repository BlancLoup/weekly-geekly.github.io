<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of high-loaded WebSocket-service</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to create a web service that will interact with users in real time, while maintaining several hundred thousand connections at the same time? 

 He...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of high-loaded WebSocket-service</h1><div class="post__text post__text-html js-mediator-article">  How to create a web service that will interact with users in real time, while maintaining several hundred thousand connections at the same time? <br><br>  Hello everyone, my name is Andrey Klyuev, I am a developer.  Recently, I was faced with such a task - to create an interactive service where the user can receive quick bonuses for their actions.  The case was complicated by the fact that the project had rather high demands on the load, and the deadlines were extremely small. <br><br>  In this article, I will tell you how I chose a solution for implementing a websocket server for the complex project requirements, what problems I encountered during the development process, and also say a few words about how the Linux kernel configuration can help in achieving the above goals. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the end of the article are useful links to development tools, testing and monitoring. <br><br><a name="habracut"></a><h2>  Tasks and requirements </h2><br><h3>  Requirements for the project functionality: </h3><br><ul><li>  make it possible to track the presence of the user on the resource and track the viewing time; </li><li>  provide quick messaging between the client and the server, since the time for the user to receive the bonus is strictly limited; </li><li>  create a dynamic interactive interface with synchronization of all actions when the user works with the service through several tabs or devices simultaneously. </li></ul><br><h3>  Load requirements: </h3><br><ul><li>  The application must be able to withstand at least 150 thousand users online. </li></ul><br>  The implementation period is 1 month. <br><br><h2>  Technology selection </h2><br>  Having compared the tasks and requirements of the project, I came to the conclusion that for its development it is more expedient to use the WebSocket technology.  It provides a permanent connection to the server, eliminating the overhead from a new connection with each message that is present in the implementation on ajax and long-polling technologies.  This allows you to get the necessary high rate of messaging in combination with adequate resource consumption, which is very important for high loads. <br><br>  Also, due to the fact that the installation and disconnection are two clear events, it is possible to track the user‚Äôs time on the site with high accuracy. <br><br>  Given the relatively limited time frame of the project, I decided to develop using the WebSocket framework.  I studied several options, the most interesting of which seemed to me PHP ReactPHP, PHP Ratchet, Node.JS websockets / ws, PHP Swoole, PHP Workerman, Go Gorilla, Elixir Phoenix.  Their capacity in terms of load tested on a laptop with an Intel Core i5 processor and 4 GB of RAM (these resources were quite enough for research). <br><br>  <b>PHP Workerman</b> is an asynchronous event-oriented framework.  Its capabilities are limited to the simplest implementation of a websocket server and the ability to work with the libevent library needed to handle asynchronous event notifications.  The code is at the level of PHP 5.3 and does not meet any standards.  For me, the main disadvantage was that the framework does not allow to implement high-load projects.  On the test bench, the developed application of the ‚ÄúHello World‚Äù level was unable to keep thousands of connections. <br><br>  <b>ReactPHP</b> and <b>Ratchet</b> are generally comparable in their capabilities to Workerman.  Ratchet inside depends on ReactPHP, it also works through libevent and does not allow creating a solution for high loads. <br><br>  <b>Swoole</b> - an interesting framework written in C, connects as an extension for PHP, has the means for parallel programming.  Unfortunately, I found that the framework is not stable enough: on the test bench, it broke off every second connection. <br><br>  Next, I looked at <b>Node.JS WS</b> .  This framework showed quite good results - about 5 thousand connections on a test bench without additional settings.  However, my project meant significantly higher loads, so I opted for the Go Gorilla + Echo Framework and Elixir Phoenix frameworks.  These options have been tested in more detail. <br><br><h2>  Stress Testing </h2><br>  Tools such as artillery, gatling and the flood.io service were used for testing. <br><br>  The purpose of the test was to study the consumption of processor and memory resources.  Characteristics of the machine were the same - Intel iCore processor 5 and 4 GB of RAM.  Tests were conducted on the example of the simplest chats on Go and Phoenix: <br><br>  Here is a simple chat application that functioned normally on a specified power machine with a load of 25-30 thousand users: <br><br><pre><code class="hljs perl">config: target: <span class="hljs-string"><span class="hljs-string">"ws://127.0.0.1:8080/ws"</span></span> phases - duration:<span class="hljs-number"><span class="hljs-number">6</span></span> arrivalCount: <span class="hljs-number"><span class="hljs-number">10000</span></span> ws: rejectUnauthorized: false scenarios: - engine: ‚Äúws‚Äù flow - <span class="hljs-keyword"><span class="hljs-keyword">send</span></span> ‚Äúhello‚Äù - think <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">send</span></span> ‚Äúworld‚Äù</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">LoadSimulation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">Simulation</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> users = <span class="hljs-type"><span class="hljs-type">Integer</span></span>.getInteger (‚Äúthreads‚Äù, <span class="hljs-number"><span class="hljs-number">30000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rampup = java.lang.<span class="hljs-type"><span class="hljs-type">Long</span></span>.getLong (‚Äúrampup‚Äù, <span class="hljs-number"><span class="hljs-number">30</span></span>L) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> duration = java.lang.<span class="hljs-type"><span class="hljs-type">Long</span></span>.getLong (‚Äúduration‚Äù, <span class="hljs-number"><span class="hljs-number">1200</span></span>L) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpConf = http .wsBaseURL(‚Äúws:<span class="hljs-comment"><span class="hljs-comment">//8.8.8.8/socket‚Äù) val scn = scenario(‚ÄúWebSocket‚Äù) .exes(ws(‚ÄúConnect WS‚Äù).open(‚Äú/websocket?vsn=2.0.0‚Äù)) .exes( ws(‚ÄúAuth‚Äù) sendText(‚Äú‚Äú‚Äú[‚Äú1‚Äù, ‚Äú1‚Äù, ‚Äúmy:channel‚Äù, ‚Äúphp_join‚Äù, {}]‚Äù‚Äù‚Äù) ) .forever() { exes( ws(‚ÄúHeartbeat‚Äù).sendText(‚Äú‚Äú‚Äú[null, ‚Äú2‚Äù, ‚Äúphoenix‚Äù, ‚Äúheartbeat‚Äù, {}]‚Äù‚Äù‚Äù) ) .pause(30) } .exes(ws(‚ÄúClose WS‚Äù).close) setUp(scn.inject(rampUsers(users) over (rampup seconds))) .maxDuration(duration) .protocols(httpConf)</span></span></code> </pre> <br>  Test runs showed that everything works quietly on a machine of the specified power with a load of 25-30 thousand users. <br><br>  CPU consumption: <br><br>  <b>Phoenix</b> <br><br><img src="https://habrastorage.org/webt/gt/9i/a8/gt9ia8elxtq2xqigrfrvewl9djk.jpeg" alt="image"><br><br>  <b>Gorilla</b> <br><br><img src="https://habrastorage.org/webt/mj/yu/gt/mjyugtobdjld1ha2qkxw-bbsvys.jpeg" alt="image"><br><br>  The consumption of RAM with a load of 20 thousand connections reached 2 GB in the case of both frameworks: <br><br>  <b>Phoenix</b> <br><br><img src="https://habrastorage.org/webt/ra/8b/lc/ra8blc1rtvxrxuchjr72f0od1ta.jpeg" alt="image"><br><br>  <b>Gorilla</b> <br><br><img src="https://habrastorage.org/webt/4v/5t/6q/4v5t6q5isuiklpw42z16bl0c16w.jpeg" alt="image"><br><br>  At the same time, Go even outperforms Elixir in performance, but the Phoenix Framework provides much more features.  On the graph below, which shows the consumption of network resources, you can see that in the Phoenix test, 1.5 times more messages are transmitted.  This is due to the fact that this framework already in the original ‚Äúboxed‚Äù version has a mechanism of heartbeats (periodic synchronizing signals), which in Gorilla will have to be implemented independently.  With limited deadlines, any additional work was a weighty argument in favor of Phoenix. <br><br>  <b>Phoenix</b> <br><br><img src="https://habrastorage.org/webt/_l/pg/3g/_lpg3gebhazhy2b9el-ecu3l_qu.jpeg" alt="image"><br><br>  <b>Gorilla</b> <br><br><img src="https://habrastorage.org/webt/wv/5n/lu/wv5nluzykygyi99-f5u56mfzi7o.jpeg" alt="image"><br><br><h2>  About Phoenix Framework </h2><br>  Phoenix is ‚Äã‚Äãa classic MVC framework, quite similar to Rails, which is not surprising, since one of its developers and creator of the Elixir language is Jose Valim, one of the main creators of Ruby on Rails.  Some similarities can be seen even in syntax. <br><br>  <b>Phoenix</b> : <br><br><pre> <code class="hljs sql">defmodule Benchmarker.Router <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Phoenix.Router <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Benchmarker.Controllers <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-string"><span class="hljs-string">"/:title"</span></span>, Controllers.Pages, :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>: :page <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  <b>Rails:</b> <br><br><pre> <code class="ruby hljs">Benchmarker::Application.routes.draw <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> root <span class="hljs-symbol"><span class="hljs-symbol">to:</span></span> <span class="hljs-string"><span class="hljs-string">"pages#index"</span></span> get <span class="hljs-string"><span class="hljs-string">"/:title"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">to:</span></span> <span class="hljs-string"><span class="hljs-string">"pages#index"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">as:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:page</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h2>  Mix is ‚Äã‚Äãan automating utility for Elixir projects </h2><br>  When using Phoenix and the Elixir language, a significant part of the processes is performed using the Mix utility.  This is a build tool that solves many different tasks for creating, compiling and testing an application, managing its dependencies, and some other processes. <br>  Mix is ‚Äã‚Äãa key part of any Elixir project.  This utility is not inferior and does not exceed analogs from other languages, but it does its job perfectly well.  And because the Elixir code is executed on the Erlang virtual machine, it is possible to add any libraries from the Erlang world to dependencies.  In addition, together with Erlang VM, you get convenient and secure parallelism, as well as high fault tolerance. <br><br><h2>  Problems and Solutions </h2><br>  For all its merits, Phoenix has its drawbacks.  One of them is the difficulty of solving such tasks as tracking active users on the site under high load conditions. <br>  The fact is that users can connect to different application nodes, and each node will only know about its own clients.  To display a list of active users, you will have to poll all application nodes. <br>  To solve these problems, there is a Presence module in Phoenix that allows the developer to track active users in just three lines of code.  It uses the mechanism of hartbits and conflict-free replication within the cluster, as well as the PubSub server for exchanging messages between nodes. <br><br><img src="https://habrastorage.org/webt/zh/ts/ur/zhtsurf7ndsi-twjyd5wqudvgs8.png" alt="image"><br><br>  It sounds good, but in fact it turns out about the following.  Hundreds of thousands of connecting and disconnecting users generate millions of messages for synchronization between nodes, which is why the consumption of processor resources goes beyond all acceptable limits, and even connecting Redis PubSub does not save the situation.  The list of users is duplicated on each node, and the calculation of differential with each new connection becomes more and more expensive - and this is considering that the calculation is carried out on each of the existing nodes. <br><br><img src="https://habrastorage.org/webt/ds/jf/rk/dsjfrkjuzpuezbv_ae1bjt61ao0.png" alt="image"><br><br>  In this situation, even the mark of 100 thousand customers becomes unattainable.  I couldn‚Äôt find any other ready-made solutions for this task, so I decided to do the following: assign the responsibility for monitoring the online users presence to the database. <br><br>  At first glance, this is a good idea, in which there is nothing difficult: it is enough to store the last activity field in the database and update it periodically.  Unfortunately, for projects with a high load, this is not an option: when the number of users reaches several hundred thousand, the system will not cope with the millions of hits coming from them. <br><br>  I chose a less trivial, but more productive solution.  When a user connects, a unique row is created for him in the table, which stores his identifier, the exact time of entry and the list of nodes to which he is connected.  The list of nodes is stored in a JSONB field, and if there is a conflict of lines, it is enough to update it. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> watching_times ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">serial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> watching_times_pkey primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, user_id <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, join_at <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, terminate_at <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, nodes jsonb ); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> watching_times_not_null_uni_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> watching_times (user_id, terminate_at) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (terminate_at <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> watching_times_null_uni_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> watching_times (user_id) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (terminate_at <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  This request is responsible for the user login: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> watching_times ( user_id, join_at, terminate_at, nodes ) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'{nl@192.168.1.101‚Äù: 1}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> CONFLICT (user_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> terminate_at <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> nodes = watching_times.nodes || <span class="hljs-keyword"><span class="hljs-keyword">CONCAT</span></span>( <span class="hljs-string"><span class="hljs-string">'{nl@192.168.1.101:'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(watching_times.nodes-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'nl@192.168.1.101'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span> )::JSONB <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>;</code> </pre> <br>  The list of nodes looks like this: <br><br><img src="https://habrastorage.org/webt/lc/jb/lm/lcjblm_rukdhxcnf8qoeti3v9xw.png" alt="image"><br><br>  If the user opens the service in the second window or on another device, he can go to another node, and then it will also be added to the list.  If it falls on the same node as in the first window, the number opposite the name of this node in the list will increase.  This number reflects the number of active user connections to a particular node. <br><br>  Here is the query that goes to the database when the session is closed: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> watching_times <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">CONCAT</span></span>( <span class="hljs-string"><span class="hljs-string">'{‚Äúnl@192.168.1.101‚Äù: '</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(watching_times.nodes -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'nl@192.168.1.101'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>) :: <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span> )::JSONB -&gt;&gt;<span class="hljs-string"><span class="hljs-string">'nl@192.168.1.101'</span></span> )::<span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> (watching_times.nodes - <span class="hljs-string"><span class="hljs-string">'nl@192.168.1.101'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCAT</span></span>( <span class="hljs-string"><span class="hljs-string">'{‚Äúnl@192.168.1.101‚Äù: '</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(watching_times.nodes -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'nl@192.168.1.101'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>) :: <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span> )::JSONB <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ), terminate_at = (<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> ... = <span class="hljs-string"><span class="hljs-string">'{}'</span></span> :: JSONB <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  List of nodes: <br><br><img src="https://habrastorage.org/webt/q-/kd/9q/q-kd9qj3nwtpnkksu6mrzwex69e.png" alt="image"><br><br>  When a session is closed at a certain node, the connection counter in the database is decremented by one, and when it reaches zero, the node is removed from the list.  When the list of nodes is completely empty, this moment will be fixed as the final time for the user to exit. <br><br>  This approach made it possible not only to track the user's online presence and viewing time, but also to filter these sessions according to various criteria. <br><br>  In all this, there is only one drawback - if a node falls, all its users ‚Äúhang‚Äù online.  To solve this problem, we have a demon that periodically cleans the database from such records, but so far this has not been required.  Analysis of the load and monitoring of the cluster's work, carried out after the release of the project in production, showed that there were no drops of nodes and this mechanism was not used. <br><br>  There were other difficulties, but they are more specific, so it is worth turning to the issue of application resiliency. <br><br><h2>  Configuring the Linux kernel to improve performance </h2><br>  To write a good application in a productive language is only half the battle, without literate DevOps it is impossible to achieve any good results. <br>  The first obstacle in the path to the target load was the network kernel Linux.  It took some adjustments to achieve a more rational use of its resources. <br>  Each open socket is a file descriptor in Linux, and their number is limited.  The reason for the limit is that for each open file in the kernel, a C-structure is created that takes up the unreclaimable memory of the kernel. <br><br>  In order to use the memory to the maximum, I set very high values ‚Äã‚Äãfor the sizes of the receive and transmit buffers, and also increased the size of the TCP socket buffers.  The values ‚Äã‚Äãhere are not set in bytes, but in memory pages, usually one page is 4 KB, and I set the value of 15 thousand for the maximum number of open sockets waiting for connections for high-load servers. <br><br><h3>  File Descriptor Limits: </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash sysctl -w 'fs.nr_open=10000000' #      sysctl -w 'net.core.rmem_max=12582912' #       sysctl -w 'net.core.wmem_max=12582912' #       sysctl -w 'net.ipv4.tcp_mem=10240 87380 12582912' #   TCP  sysctl -w 'net.ipv4.tcp_rmem=10240 87380 12582912' #    sysctl -w 'net.ipv4.tcp_wmem=10240 87380 12582912'#    &lt;code&gt;sysctl -w 'net.core.somaxconn=15000' #    ,  </span></span></code> </pre><br>  If you use nginx in front of a cowboy server, then you should also think about increasing its limits.  The directive worker_connections and worker_rlimit_nofile are responsible for this. <br><br>  The second barrier is not so obvious.  If you run such an application in distributed mode, you can see a sharp increase in processor resource consumption with an increase in the number of connections.  The problem is that by default Erlang works with the system calls Poll.  In version 2.6 of the Linux kernel, there is Epoll, which can provide a more efficient mechanism for applications that process a large number of simultaneously open connections - with O (1) complexity, unlike Poll, which has O (n) complexity. <br><br>  Fortunately, Epoll mode is enabled with one flag: + K true, I also recommend increasing the maximum number of processes spawned by your application and the maximum number of open ports using the + P and + Q flags, respectively. <br><br><h3>  Poll vs.  Epoll </h3><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash Elixir --name ${MIX_NODE_NAME}@${MIX_HOST} --erl ‚Äú-config sys.config -setcookie ${ERL_MAGIC_COOKIE} +K true +Q 500000 +P 4194304‚Äù -S mix phx.server</span></span></code> </pre> <br>  The third problem is more individual, and not everyone can face it.  On this project, the process of automatic deployment and dynamic scaling with the help of hef and Kubernetes was organized.  Kubernetes allows you to quickly deploy Docker-containers on a large number of hosts, and it is very convenient, but you cannot learn the ip-address of a new host in advance, and if you do not register it in the Erlang config, you will not be able to connect the new node to the distributed application. <br><br>  Fortunately, the libcluster library exists to solve these problems.  Communicating with Kubernetes via the API, she learns in real time about the creation of new nodes and registers them in the erlang cluster. <br><br><pre> <code class="hljs perl">config :libcluster, topologies: [ k8s: [ strategy: Cluster.Strategy.Kubernetes, config: [ kubernetes_selector: ‚Äúapp=<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> -backend‚Äù, kubernetes_node_basename: ‚Äú<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> -backend‚Äù]]]</code> </pre><br><h2>  Results and prospects </h2><br>  The chosen framework in combination with the correct server configuration allowed to achieve all the goals of the project: in the set time frame (1 month) to develop an interactive web service that communicates with users in real time and at the same time withstands loads of 150 thousand connections and more. <br><br>  After the launch of the project in production, monitoring was conducted, which showed the following results: with a maximum number of connections up to 800 thousand, the consumption of processor resources reaches 45%.  The average load is 29% at 600 thousand connections. <br><br><img src="https://habrastorage.org/webt/w2/h0/ms/w2h0msuts0dky-2omau9hmku8lk.png" alt="image"><br><br>  On this graph - memory consumption when working in a cluster of 10 machines, each of which has 8 GB of RAM. <br><br><img src="https://habrastorage.org/webt/hr/tn/h1/hrtnh1ysbf_c0nnc_1qiei00ucq.jpeg" alt="image"><br><br><img src="https://habrastorage.org/webt/d9/ph/96/d9ph96p9f0foley0jqww7-oq3sm.jpeg" alt="image"><br><br>  As for the main working tools in this project, Elixir and Phoenix Framework, I have every reason to believe that in the coming years they will become as popular as Ruby and Rails in due time, so it makes sense to start mastering them now. <br>  Thanks for attention! <br><br><h2>  Links </h2><br>  <b>Development:</b> <br>  <a href="https://elixir-lang.org/">elixir-lang.org</a> <br>  <a href="http://phoenixframework.org/">phoenixframework.org</a> <br>  <b>Stress Testing:</b> <br>  <a href="https://gatling.io/">gatling.io</a> <br>  <a href="https://flood.io/">flood.io</a> <br>  <b>Monitoring:</b> <br>  <a href="https://prometheus.io/">prometheus.io</a> <br>  <a href="https://grafana.com/">grafana.com</a> <cut></cut></div><p>Source: <a href="https://habr.com/ru/post/351012/">https://habr.com/ru/post/351012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351000/index.html">Find him if you can. How to select letters in the general stream</a></li>
<li><a href="../351002/index.html">Fantastic-Elasticsearch. How we "tamed" smart search through documents</a></li>
<li><a href="../351004/index.html">Organization of information systems production processes. Part 3. Implementation of the project solution</a></li>
<li><a href="../351006/index.html">How to notice DDOS in time: a monitoring service usage scenario for early detection</a></li>
<li><a href="../351008/index.html">Custom aggregate and window functions in PostgreSQL and Oracle</a></li>
<li><a href="../351014/index.html">Batch image processing in Windows with ImageMagick. Part I</a></li>
<li><a href="../351016/index.html">Discover Nirvana - Yandex‚Äôs Universal Computing Platform</a></li>
<li><a href="../351018/index.html">JMeter 4.0. What's new?</a></li>
<li><a href="../351020/index.html">Why embedded developers should use static code analysis</a></li>
<li><a href="../351022/index.html">The program for network monitoring Network MACMonitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>