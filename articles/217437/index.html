<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own http-server in less than 40 lines of code on libevent and C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Looking through Habr from time to time, I occasionally meet posts on the topic of creating my own web server in C ++ or in another language. Since C +...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own http-server in less than 40 lines of code on libevent and C ++ 11</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/ee5/939/0c3ee593920d23b63192407b9045eef1.jpg" align="left">  Looking through Habr from time to time, I occasionally meet posts on the topic of creating my own web server in C ++ or in another language.  Since C ++ from programming languages ‚Äã‚Äãis of more interest to me, I read this blog the most.  If you look through it, you can easily find how to write your web server "on sockets", using boost.asio or something else.  Some time ago, I also published my post about creating such an http-server as an example of solving a test task.  But without limiting myself to this, and for the sake of interest, I made comparisons with libevent and boost.asio developments.  And the test task as such refused to perform. <br><br>  For myself, somehow in my work, I considered libevent and libev.  Each has its own advantages.  If there is a desire or need for an early development of a small http-server, then libevent is of great interest to me, and with some innovations in C ++ 11, the code becomes much more compact and allows you to create a basic http-server in less than 40 lines. <br><a name="habracut"></a><br>  The material of the post may be useful to those who are not familiar with libevent and there is a need to create their own http-server soon, as well as the material may interest people who have no such need yet and even if they already had experience in creating such a thing, it‚Äôs interesting to know their opinions and experiences.  And since the post does not contain anything fundamentally new, it can be used as material for starting work in this direction, and therefore I will try to put the mark ‚Äúteaching material‚Äù. <br><br>  What libevent is different from, for example, libev and boost.asio, is that it has its own built-in http-server, and some abstraction for working with buffers.  And also has a considerable set of auxiliary functions.  You can disassemble the HTTP protocol yourself by writing a simple state machine or some other method.  When working with libevent, this is all already there.  This is such a nice bun, but you can go down to a lower level and write your own HTTP parser, while doing work with sockets on libevent.  I liked the level of detail in the library because if you want to do something quickly, you can find a higher-level interface in it, which is usually less flexible.  With the emergence of large needs, you can gradually go down level by level lower and lower.  The library allows you to do many things: asynchronous I / O, work with the network, work with timers, rpc, ect;  You can use it to create both server and client software. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What for? </h4><br>  Creating your own small http-server can be due to each of his own needs, the desire or unwillingness to use full-featured ready-made servers for one reason or another.  Suppose you have some server software that works on some of its own protocol and solves some problems, and you have a need to issue some API for this software via the HTTP protocol.  Perhaps just a few small functions for setting up the server and getting its current state via HTTP.  For example, organizing the processing of GET requests with parameters and give a small xml with the answer or in some other format.  In this case, you can create your own http-server with a small effort, which will be the interface for your main server software.  In addition, if there is a need to create your own small specific service for the distribution of a set of files, or even create your own web application, you can also use such a self-written small server.  In general, you can use both to build self-sufficient server software, and to create support services within larger systems. <br><br><h4>  Simple http server in less than 40 lines </h4><br>  To create a simple single-threaded http-server using libevent, you need to follow these several simple steps: <br><ul><li>  Initialize the global library object using the event_init function.  This function can only be used for single-threaded processing.  For multi-threaded work on each thread must be created its own object (about this below). </li><li>  The creation of the http server itself is performed by the evhttp_start function in the case of a single-threaded server with a global event handling object.  The object created with evhttp_start at the end should be deleted with evhttp_free. </li><li>  To respond to incoming requests, you need to set up a callback function using evhttp_set_gencb. </li><li>  Then you can start the event loop with the event_dispatch function.  This function is also designed to work in one thread with a global object. </li><li>  When processing a request, you can get a buffer for a response with the evhttp_request_get_output_buffer function.  Add some content to this buffer.  For example, to send a string, you can use the evbuffer_add_printf function, and to send a file with the evbuffer_add_file function.  After that, the response to the request should be sent, and this can be done using evhttp_send_reply. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Single-threaded server code in less than 40 lines:</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdint&gt; #include &lt;iostream&gt; #include &lt;evhttp.h&gt; int main() { if (!event_init()) { std::cerr &lt;&lt; "Failed to init libevent." &lt;&lt; std::endl; return -1; } char const SrvAddress[] = "127.0.0.1"; std::uint16_t SrvPort = 5555; std::unique_ptr&lt;evhttp, decltype(&amp;evhttp_free)&gt; Server(evhttp_start(SrvAddress, SrvPort), &amp;evhttp_free); if (!Server) { std::cerr &lt;&lt; "Failed to init http server." &lt;&lt; std::endl; return -1; } void (*OnReq)(evhttp_request *req, void *) = [] (evhttp_request *req, void *) { auto *OutBuf = evhttp_request_get_output_buffer(req); if (!OutBuf) return; evbuffer_add_printf(OutBuf, "&lt;html&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;Hello Wotld!&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"); evhttp_send_reply(req, HTTP_OK, "", OutBuf); }; evhttp_set_gencb(Server.get(), OnReq, nullptr); if (event_dispatch() == -1) { std::cerr &lt;&lt; "Failed to run messahe loop." &lt;&lt; std::endl; return -1; } return 0; }</span></span></span></span></code> </pre> </div></div><br>  It turned out less than 40 lines that can handle http requests, returning the string ‚ÄúHello World‚Äù, and if you replace the evbuffer_add_printf function with evbuffer_add_file, you can send files.  You can call such a server basic configuration.  Any car dealer or realtor for the most part dreams that their cars and apartments never and under no circumstances leave as standard, but with additional options.  But whether the consumer needs such options and to what extent ... <br><br>  What this basic equipment can provide for speed can be checked using the <b>ab</b> utility for * nix systems with a small variation of parameters. <br><div class="spoiler">  <b class="spoiler_title">ab -c 1000 -k -r -t 10 http://127.0.0.1.15555/</b> <div class="spoiler_text">  Server Software: <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: / <br>  Document Length: 64 bytes <br><br>  Concurrency Level: 1000 <br>  Time taken for tests: 2.289 seconds <br>  Complete requests: 50000 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Keep-Alive requests: 50000 <br>  Total transferred: 8500000 bytes <br>  HTML transferred: 3200000 bytes <br>  Requests per second: 21843.76 [# / sec] (mean) <br>  Time per request: 45.780 [ms] (mean) <br>  Time per request: 0.046 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 3626.41 [Kbytes / sec] received <br><br>  Connection Times (ms) <br>  min mean [¬± sd] median max <br>  Connect: 0 3 48.6 0 1001 <br>  Processing: 17 42 9.0 43 93 <br>  Waiting: 17 42 9.0 43 93 <br>  Total: 19 45 49.7 43 1053 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">ab -c 1000 -r -t 10 http://127.0.0.1.15555/</b> <div class="spoiler_text">  Server Software: <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: / <br>  Document Length: 64 bytes <br><br>  Concurrency Level: 1000 <br>  Time taken for tests: 5.004 seconds <br>  Complete requests: 50000 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Total transferred: 6300000 bytes <br>  HTML transferred: 3200000 bytes <br>  Requests per second: 9992.34 [# / sec] (mean) <br>  Time per request: 100.077 [ms] (mean) <br>  Time per request: 0.100 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 1229.53 [Kbytes / sec] received <br><br>  Connection Times (ms) <br>  min mean [¬± sd] median max <br>  Connect: 0 61 214.1 20 3028 <br>  Processing: 7 34 17.6 31 277 <br>  Waiting: 6 28 16.9 25 267 <br>  Total: 17 95 219.5 50 3055 <br></div></div><br>  The test was conducted on an already not entirely new laptop (2 cores, 4GB of RAM) running a 32-bit Ubuntu 12.10 operating system. <br><br><h4>  Multi-threaded http server </h4><br>  Do you need multithreading?  A rhetorical question ... It is possible to organize all IOs and in one thread to organize, and to add requests to a queue and rake it in several streams.  In this case, the above server can be simply supplemented with a queue and a pool of threads for processing, and nothing more should be done.  If there is a desire or need to build a multi-threaded server, then it will be slightly longer than the previous one, but not much.  C ++ 11 with its smart pointers allow to implement <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">RAII</a> well, as was shown with std :: unique_ptr in the example above, and the presence of lambda functions slightly reduces the code. <br><br>  An example of a multi-threaded server is similar in its ideology to a single-threaded one, and some features associated with multithreading increase it approximately 2 times by the amount of code.  Eighty-and-a-few lines of code for a multi-threaded http server in C ++ is not so much. <br><br>  One of the decisions you can make: <br><ul><li>  Create multiple threads, for example, equal to twice the number of processor cores.  C ++ 11 has support for working with streams and now you no longer need to write your wrappers. </li><li>  For each thread, create your own object of working with events using the event_base_new function.  The created object must be deleted at the end by the event_base_free function, and std :: unique_ptr and RAII allow for this to be made more compact. </li><li>  For each stream, taking into account the above object, create your own http server object using the evhttp_new function.  This object should also be deleted at the end, and this can be done with the help of evhttp_free. </li><li>  As in the previous example, install the request handler using evhttp_set_gencb. </li><li>  This step may be the strangest.  It is necessary to create and bind a socket to the network interface for several handlers, each of which is located in its stream.  Here you can use the API for working with sockets (create a socket, configure it, bind to a specific interface), and then transfer the socket to work with the server using the evhttp_accept_socket function.  This is a long time.  Libevent provides several functions for this task.  As mentioned above, libevent gives you the opportunity, if necessary, to go down to a lower and lower level, depending on need, and choose the best one for you.  In this case, for the first thread, all the work on creating a socket, its configuration and binding is performed by the evhttp_bind_socket_with_handle function and the socket for other threads is extracted from the configured object using evhttp_bound_socket_get_fd.  All other threads are already using the received socket, setting it for processing by the evhttp_accept_socket function.  A bit strange, but much easier than using the API for working with sockets, and even easier if you take into account the cross-platform.  It would seem that the API for Berkeley sockets is one and the same, but if you wrote cross-platform software using it, for example, for Windows and Linux, then the code written for one operating system is definitely not equivalent to the code for another. </li><li>  Start the event loop.  Unlike a single-threaded server, this should be done in a different way, since the objects are different for everyone.  For this there is a special function in libevent (event_base_dispatch).  For myself, I see one minus in it - it is difficult to correct it in the correct way (for example, you need to have a situation in which you can call event_base_loopexit).  For this you need to dodge a little.  And so you can use the event_base_loop function.  This function does not block even if there are no events to be processed, it returns control, which gives a simplified opportunity to complete the event processing cycle and the ability to do something between calls.  There is also a minus - in order not to load the processor at idle in vain, you need to put at least a small delay (in C ++ 11 - 'this is easy to do something like this: std :: this_thread :: sleep_for (std :: chrono :: milliseconds (10)) ). </li><li>  Processing requests is similar to the first example. </li><li>  In the course of creating and configuring the next thread, something may not be right in its function: for example, some libevent function reported an error.  In this case, you can throw an exception and intercept it, and then send it out of the stream using all the same C ++ 11 tools (std :: exception_ptr, std :: current_exception and std :: rethrow_exception) </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code for a simple multi-threaded server:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdexcept&gt; #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;chrono&gt; #include &lt;thread&gt; #include &lt;cstdint&gt; #include &lt;vector&gt; #include &lt;evhttp.h&gt; int main() { char const SrvAddress[] = "127.0.0.1"; std::uint16_t const SrvPort = 5555; int const SrvThreadCount = 4; try { void (*OnRequest)(evhttp_request *, void *) = [] (evhttp_request *req, void *) { auto *OutBuf = evhttp_request_get_output_buffer(req); if (!OutBuf) return; evbuffer_add_printf(OutBuf, "&lt;html&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;Hello Wotld!&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"); evhttp_send_reply(req, HTTP_OK, "", OutBuf); }; std::exception_ptr InitExcept; bool volatile IsRun = true; evutil_socket_t Socket = -1; auto ThreadFunc = [&amp;] () { try { std::unique_ptr&lt;event_base, decltype(&amp;event_base_free)&gt; EventBase(event_base_new(), &amp;event_base_free); if (!EventBase) throw std::runtime_error("Failed to create new base_event."); std::unique_ptr&lt;evhttp, decltype(&amp;evhttp_free)&gt; EvHttp(evhttp_new(EventBase.get()), &amp;evhttp_free); if (!EvHttp) throw std::runtime_error("Failed to create new evhttp."); evhttp_set_gencb(EvHttp.get(), OnRequest, nullptr); if (Socket == -1) { auto *BoundSock = evhttp_bind_socket_with_handle(EvHttp.get(), SrvAddress, SrvPort); if (!BoundSock) throw std::runtime_error("Failed to bind server socket."); if ((Socket = evhttp_bound_socket_get_fd(BoundSock)) == -1) throw std::runtime_error("Failed to get server socket for next instance."); } else { if (evhttp_accept_socket(EvHttp.get(), Socket) == -1) throw std::runtime_error("Failed to bind server socket for new instance."); } for ( ; IsRun ; ) { event_base_loop(EventBase.get(), EVLOOP_NONBLOCK); std::this_thread::sleep_for(std::chrono::milliseconds(10)); } } catch (...) { InitExcept = std::current_exception(); } }; auto ThreadDeleter = [&amp;] (std::thread *t) { IsRun = false; t-&gt;join(); delete t; }; typedef std::unique_ptr&lt;std::thread, decltype(ThreadDeleter)&gt; ThreadPtr; typedef std::vector&lt;ThreadPtr&gt; ThreadPool; ThreadPool Threads; for (int i = 0 ; i &lt; SrvThreadCount ; ++i) { ThreadPtr Thread(new std::thread(ThreadFunc), ThreadDeleter); std::this_thread::sleep_for(std::chrono::milliseconds(500)); if (InitExcept != std::exception_ptr()) { IsRun = false; std::rethrow_exception(InitExcept); } Threads.push_back(std::move(Thread)); } std::cout &lt;&lt; "Press Enter fot quit." &lt;&lt; std::endl; std::cin.get(); IsRun = false; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre></div></div><br>  You can see in the code that each thread is created after some wait has been added.  This is a small hack that will already be fixed in the final version of the server.  For the time being, one can only say that if this is not done, the threads will need to be somehow synchronized so that they can work out the ‚Äústrange step‚Äù in creating and binding the socket.  For simplicity, let there be such a hack for now.  Also, in the above code, the lambda function may seem like a controversial decision.  Lambdas can be a good solution when used, for example, as a predicate when working with standard algorithms.  At the same time, you can think about using them when writing larger code fragments.  In the example above, it was possible to put everything into a normal function, pass all the necessary parameters and get the code in the C ++ 03 style.  At the same time, the use of lambda reduced the amount of code.  In my opinion, when the code is small, then lambdas can quite well enter into it even with not the shortest of its content and not adversely affect the quality of the code, of course you should not go into extremes and recall student workdays with writing a laboratory work of 700 lines in a single main functions. <br><br>  Testing a multi-threaded server was carried out with the same parameters as the previous example. <br><div class="spoiler">  <b class="spoiler_title">ab -c 1000 -k -r -t 10 http://127.0.0.1.15555/</b> <div class="spoiler_text">  Server Software: <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: / <br>  Document Length: 64 bytes <br><br>  Concurrency Level: 1000 <br>  Time taken for tests: 1.576 seconds <br>  Complete requests: 50000 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Keep-Alive requests: 50000 <br>  Total transferred: 8500000 bytes <br>  HTML transferred: 3200000 bytes <br>  Requests per second: 31717.96 [# / sec] (mean) <br>  Time per request: 31.528 [ms] (mean) <br>  Time per request: 0.032 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 5265.68 [Kbytes / sec] received <br></div></div><br><div class="spoiler">  <b class="spoiler_title">ab -c 1000 -r -t 10 http://127.0.0.1.15555/</b> <div class="spoiler_text">  Server Software: <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: / <br>  Document Length: 64 bytes <br><br>  Concurrency Level: 1000 <br>  Time taken for tests: 3.685 seconds <br>  Complete requests: 50000 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Total transferred: 6300000 bytes <br>  HTML transferred: 3200000 bytes <br>  Requests per second: 13568.41 [# / sec] (mean) <br>  Time per request: 73.701 [ms] (mean) <br>  Time per request: 0.074 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 1669.55 [Kbytes / sec] received <br><br>  Connection Times (ms) <br>  min mean [¬± sd] median max <br>  Connect: 0 36 117.2 23 1033 <br>  Processing: 3 37 10.0 37 247 <br>  Waiting: 3 30 8.7 30 242 <br>  Total: 9 73 118.8 61 1089 <br></div></div><br><h4>  Final server </h4><br>  Basic equipment is provided, equipment with a small set of options is also there.  Now the turn came and to create something more useful and functional, as well as with a little tuning. <br><br>  Minimum http-server: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http_server.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http_headers.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http_content_type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { try { using namespace Network; HttpServer Srv("127.0.0.1", 5555, 4, [&amp;] (IHttpRequestPtr req) { req-&gt;SetResponseAttr(Http::Response::Header::Server::Value, "MyTestServer"); req-&gt;SetResponseAttr(Http::Response::Header::ContentType::Value, Http::Content::Type::html::Value); req-&gt;SetResponseString("&lt;html&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;Hello Wotld!&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;"); }); std::cout &lt;&lt; "Press Enter for quit." &lt;&lt; std::endl; std::cin.get(); } catch (std::exception const &amp;e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre><br>  Very minimal amount of code for the http-server in C ++.  For everything there is a fee.  And in this case, such simplicity of the client code for creating a server is paid for by a longer implementation hidden in the proposed wrapper over libevent.  In fact, the implementation has not increased much.  Just below its fragments will be described. <br><br>  Server creation: <br><ul><li>  You must create an object of type HttpServer.  As parameters, at a minimum, pass the address and port on which the server will work, the number of threads and the function to process requests (in this case, since request processing is minimal, then you can do a little lambda without creating a separate function or even a whole handler class) .  After an object is created, the server will work as long as its object exists. </li><li>  The handler accepts a smart pointer to the IHttpRequest interface, the implementation of which hides all the work with the libevent buffer and the sending of a response, and its methods make it possible to receive data from an incoming request and generate a response. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Interface IHttpRequest</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Network { DECLARE_RUNTIME_EXCEPTION(HttpRequest) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IHttpRequest</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class"> {</span></span> HEAD, GET, PUT, POST }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; RequestParams; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IHttpRequest() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRequestType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeaderAttr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *attrName)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetContentSize() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remove)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> RequestParams </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResponseAttr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;name, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;val)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResponseCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> code)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;str)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResponseBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResponseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;fileName)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IHttpRequest&gt; IHttpRequestPtr; }</code> </pre></div></div><br>  This interface allows you to receive from the incoming request its type, some attributes (headers), the size of the request body and the request body itself, if any, as well as form a response with the ability to specify attributes (headers), request completion code and response body (in this implementations have methods for passing a string, some buffer or file in response).  Each method in its implementation can throw an exception of type HttpRequestException. <br><br>  If you look at the server code again, you can see the following lines in the request processing code: <br><pre> <code class="cpp hljs">req-&gt;SetResponseAttr(Http::Response::Header::Server::Value, <span class="hljs-string"><span class="hljs-string">"MyTestServer"</span></span>); req-&gt;SetResponseAttr(Http::Response::Header::ContentType::Value, Http::Content::Type::html::Value);</code> </pre><br>  This is the formation of the response header, and in this example such header fields as ‚ÄúContent-Type‚Äù and ‚ÄúServer‚Äù are defined.  Despite the fact that libevent has a fairly wide functionality that goes far beyond the needs of HTTP, there is no list of header field constants in it;  there is only a partial list of return codes (most commonly used).  To avoid messing with strings defining header fields (for example, in order to avoid typos in user code), all constants are already defined in the proposed wrapper over libevent. <br><div class="spoiler">  <b class="spoiler_title">Example of String Constant Definition</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Network { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Http { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Request { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Header { DECLARE_STRING_CONSTANT(Accept, Accept) DECLARE_STRING_CONSTANT(AcceptCharset, Accept-Charset) <span class="hljs-comment"><span class="hljs-comment">// ... } } namespace Response { namespace Header { DECLARE_STRING_CONSTANT(AccessControlAllowOrigin, Access-Control-Allow-Origin) DECLARE_STRING_CONSTANT(AcceptRanges, Accept-Ranges) // ... } } } }</span></span></code> </pre></div></div><br>  String constants can be defined as simple old-style macros of pure C in header files, or to distribute their declarations and definitions between .h and .cpp files, making them already typed in C ++ style.  However, you can do without spacing on files, and make all typed definitions in the C ++ style only in the header file.  To do this, you can use some approach with templates and write such a macro (macros, of course, a recognized C ++ evil, as well as in small dosages ‚Äî a balm; heterogeneous solutions are more viable). <br><div class="spoiler">  <b class="spoiler_title">DECLARE_STRING_CONSTANT</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECLARE_STRING_CONSTANT(name_, value_) \ namespace Private \ { \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T&gt; \ struct name_ \ { \ static char const Name[]; \ static char const Value[]; \ }; \ template &lt;typename T&gt; \ char const name_ &lt;T&gt;::Name[] = #name_; \ template &lt;typename T&gt; \ char const name_ &lt;T&gt;::Value[] = #value_; \ } \ typedef Private:: name_ &lt;void&gt; name_;</span></span></span></span></code> </pre></div></div><br>  The constants for setting the type of content are also defined in almost the same way;  have a slight modification.  There was a desire to implement a content type search by file extension for convenience when sending files in response to a request. <br><br>  If you want to get something from the incoming request, for example, from which host and from which page the transition was made to the requested resource and, for example, whether the user has cookies, you can get this from the header of the incoming request in this way: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Host = req-&gt;GetHeaderAttr(Http::Request::Header::Host::Value); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Referer = req-&gt;GetHeaderAttr(Http::Request::Header::Referer::Value); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Cookie = req-&gt;GetHeaderAttr(Http::Request::Header::Cookie::Value);</code> </pre><br>  Similarly, in the response, you can, for example, set the user some Cookies, which later work with his session and track if you want to wander through your resource (an example of working with response headers is given in the server code). <br><br>  If there is a desire to organize some of its API via HTTP, then this is just as easy to do.  Suppose you need to create methods: opening a session, obtaining statistical information about the server and closing the session.  Let for this query string to your server look like this: <br><br><pre>  http://myserver.com/service/login/OpenSession?user=nym&amp;pwd=kakoyto
 http://myserver.com/service/login/CliseSession?sessionId=nym1234567890
 http://myserver.com/service/stat/GetInfo?sessionId=nym1234567890 </pre><br>  By answering these query lines, the user's server can generate some kind of response, for example, in xml format.  This is a server developer case.  But how to work with such requests, get the parameters from them below: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Path = req-&gt;GetPath(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Params = req-&gt;GetParams();</code> </pre><br>  One of the ways for the examples above will be / service / login / OpenSession, and the parameters are the map from the passed key / value pairs.  Type of parameter map: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; RequestParams;</code> </pre><br>  After analyzing all that can be implemented using the proposed final version of the wrapper over libevent, you can look under the hood of the wrapper itself. <br><div class="spoiler">  <b class="spoiler_title">Class HttpServer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Network { DECLARE_RUNTIME_EXCEPTION(HttpServer) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServer</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Common::NonCopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;IHttpRequest::Type&gt; MethodPool; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (IHttpRequestPtr)&gt; OnRequestFunc; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { MaxHeaderSize = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">-1</span></span>), MaxBodySize = MaxHeaderSize }; HttpServer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> threadCount, OnRequestFunc <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;onRequest, MethodPool <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;allowedMethods = {IHttpRequest::Type::GET }, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> maxHeadersSize = MaxHeaderSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> maxBodySize = MaxBodySize); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsRun = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*ThreadDeleter)(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread *t) = [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread *t) { t-&gt;join(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> t; };; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(ThreadDeleter)&gt; ThreadPtr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ThreadPtr&gt; ThreadPool; ThreadPool Threads; Common::BoolFlagInvertor RunFlag; }; } &lt;/source&lt;/spoiler&gt; &lt;spoiler title=<span class="hljs-string"><span class="hljs-string">"  HttpServer"</span></span>&gt;&lt;source lang=<span class="hljs-string"><span class="hljs-string">"cpp"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Network { HttpServer::HttpServer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> port, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> threadCount, OnRequestFunc <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;onRequest, MethodPool <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;allowedMethods, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> maxHeadersSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> maxBodySize) : RunFlag(&amp;IsRun) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AllowedMethods = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> i : allowedMethods) AllowedMethods |= HttpRequestTypeToAllowedMethod(i); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> DoneInitThread = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception_ptr Except; <span class="hljs-keyword"><span class="hljs-keyword">evutil_socket_t</span></span> Socket = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ThreadFunc = [&amp;] () { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> ProcessRequest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RequestParams ReqPrm; ReqPrm.Func = onRequest; ReqPrm.Process = &amp;ProcessRequest; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;event_base, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;event_base_free)&gt; EventBasePtr; <span class="hljs-function"><span class="hljs-function">EventBasePtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event_base_new(), &amp;event_base_free)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EventBase) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> HttpServerException(<span class="hljs-string"><span class="hljs-string">"Failed to create new base_event."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;evhttp, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(&amp;evhttp_free)&gt; EvHttpPtr; <span class="hljs-function"><span class="hljs-function">EvHttpPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvHttp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(evhttp_new(EventBase.get()), &amp;evhttp_free)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!EvHttp) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> HttpServerException(<span class="hljs-string"><span class="hljs-string">"Failed to create new evhttp."</span></span>); evhttp_set_allowed_methods(EvHttp.get(), AllowedMethods); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxHeadersSize != MaxHeaderSize) evhttp_set_max_headers_size(EvHttp.get(), maxHeadersSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxBodySize != MaxBodySize) evhttp_set_max_body_size(EvHttp.get(), maxBodySize); evhttp_set_gencb(EvHttp.get(), &amp;OnRawRequest, &amp;ReqPrm); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Socket == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *BoundSock = evhttp_bind_socket_with_handle(EvHttp.get(), address.c_str(), port); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!BoundSock) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> HttpServerException(<span class="hljs-string"><span class="hljs-string">"Failed to bind server socket."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Socket = evhttp_bound_socket_get_fd(BoundSock)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> HttpServerException(<span class="hljs-string"><span class="hljs-string">"Failed to get server socket for next instance."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (evhttp_accept_socket(EvHttp.get(), Socket) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> HttpServerException(<span class="hljs-string"><span class="hljs-string">"Failed to bind server socket for new instance."</span></span>); } DoneInitThread = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; IsRun ; ) { ProcessRequest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; event_base_loop(EventBase.get(), EVLOOP_NONBLOCK); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ProcessRequest) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::sleep_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { Except = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::current_exception(); } }; ThreadPool NewThreads; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; threadCount ; ++i) { DoneInitThread = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">ThreadPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::thread(ThreadFunc), ThreadDeleter)</span></span></span></span>; NewThreads.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Thread)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; ; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Except != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception_ptr()) { IsRun = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::rethrow_exception(Except); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DoneInitThread) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::sleep_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); } } Threads = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(NewThreads); } }</code> </pre></div></div><br>  The query processing function can be viewed in the full version by downloading the source files of the examples, it became a bit more than in the earlier examples, and stopped claiming lambda without losing the readability of the code.  I also did not mention the implementation of the IHttpRequest interface, since it is of little interest in its routine work with the libevent buffer.  And the rest if you look at the code of the final version, it has not changed much.  A small modification and added a bit of "tuning". <br><br>  The user server is not required to handle all types of http requests.     ,        libevent   evhttp_set_allowed_methods (        GET).         libevent        ,       . <br><br>     :      .       ¬´¬ª    -      http-            evhttp_set_max_headers_size  evhttp_set_max_body_size.            ,      .          .   - ,       ,     ‚Ä¶ <br><br>     ,    GET (    )                   ,  . <br><div class="spoiler"> <b class="spoiler_title">   http-</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http_server.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http_headers.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"http_content_type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include &lt;mutex&gt; int main() { char const SrvAddress[] = "127.0.0.1"; std::uint16_t SrvPort = 5555; std::uint16_t SrvThreadCount = 4; std::string const RootDir = "../test_content"; std::string const DefaultPage = "index.html"; std::mutex Mtx; try { using namespace Network; HttpServer Srv(SrvAddress, SrvPort, SrvThreadCount, [&amp;] (IHttpRequestPtr req) { std::string Path = req-&gt;GetPath(); Path = RootDir + Path + (Path == "/" ? DefaultPage : std::string()); { std::stringstream Io; Io &lt;&lt; "Path: " &lt;&lt; Path &lt;&lt; std::endl &lt;&lt; Http::Request::Header::Host::Name &lt;&lt; ": " &lt;&lt; req-&gt;GetHeaderAttr(Http::Request::Header::Host::Value) &lt;&lt; std::endl &lt;&lt; Http::Request::Header::Referer::Name &lt;&lt; ": " &lt;&lt; req-&gt;GetHeaderAttr(Http::Request::Header::Referer::Value) &lt;&lt; std::endl; std::lock_guard&lt;std::mutex&gt; Lock(Mtx); std::cout &lt;&lt; Io.str() &lt;&lt; std::endl; } req-&gt;SetResponseAttr(Http::Response::Header::Server::Value, "MyTestServer"); req-&gt;SetResponseAttr(Http::Response::Header::ContentType::Value, Http::Content::TypeFromFileName(Path)); req-&gt;SetResponseFile(Path); }); std::cin.get(); } catch (std::exception const &amp;e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre></div></div><br><br><h4>  Conclusion </h4><br>    libevent     .  :             .       ,    http-. <a href="http_srv">        github</a> .      <a href="&amp;xid=17259,15700002,15700022,15700186,15700190,15700253&amp;usg=ALkJrhhgPuSTo3XjonfzVExfBW1oKhk8zg#">http server      </a> . <br>  : <br><div class="spoiler"> <b class="spoiler_title">ab -c 1000 -k -r -t 10 http://localhost:8888/libevent_test_http_srv.zip</b> <div class="spoiler_text"> Server Software: test <br> Server Hostname: test <br> Server Port: 8888 <br><br> Document Path: /libevent_test_http_srv.zip <br> Document Length: 23756 bytes <br><br> Concurrency Level: 1000 <br> Time taken for tests: 10.012 seconds <br> Complete requests: 2293 <br>  Failed requests: 0 <br>  Write errors: 0 <br> Keep-Alive requests: 2293 <br> Total transferred: 60628847 bytes <br> HTML transferred: 60328370 bytes <br> Requests per second: 229.02 [#/sec] (mean) <br> Time per request: 4366.365 [ms] (mean) <br> Time per request: 4.366 [ms] (mean, across all concurrent requests) <br> Transfer rate: 5913.65 [Kbytes/sec] received <br></div></div><br>                       ‚Ä¶ <br><br>  Thank you all for your attention! <br><br><h4>  Materials </h4><br><ul><li> <a href="http://libevent.org/">libevent</a> </li><li> <a href="http://habrahabr.ru/post/152345/">WebServer   </a> </li><li> <a href="http://ru.wikipedia.org/wiki/HTTP">HTTP</a> </li><li> <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">List of HTTP header fields</a> </li></ul><br></div><p>Source: <a href="https://habr.com/ru/post/217437/">https://habr.com/ru/post/217437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217425/index.html">Naval Battle in Google Spreadsheets</a></li>
<li><a href="../217427/index.html">Russian microelectronics for space: who produces what</a></li>
<li><a href="../217429/index.html">Google Glass and business: the outgoing train</a></li>
<li><a href="../217431/index.html">Monthly digest of interesting IT-projects on Kickstarter ‚Ññ2</a></li>
<li><a href="../217435/index.html">Parser in Nimbus Note, or how we solved the problem of "pure" HTML</a></li>
<li><a href="../217445/index.html">The most central coworking</a></li>
<li><a href="../217447/index.html">Meet WebStorm 8: AngularJS support, spy-js, Grunt integration, and more.</a></li>
<li><a href="../217449/index.html">Altergaze: virtual reality for your smartphone</a></li>
<li><a href="../217455/index.html">Good interface design. Part 3</a></li>
<li><a href="../217457/index.html">Developer Contest ‚ÄúNative Speech‚Äù - attention, semifinal!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>