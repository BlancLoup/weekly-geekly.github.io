<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Such amazing semaphores</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: Jeff Preshing (Jeff Preshing) - Canadian software developer, the last 12 years working in Ubisoft Montreal. He had a hand in the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Such amazing semaphores</h1><div class="post__text post__text-html js-mediator-article">  <i><b>From the translator:</b> Jeff Preshing (Jeff Preshing) - Canadian software developer, the last 12 years working in Ubisoft Montreal.</i>  <i>He had a hand in the creation of such famous franchises as Rainbow Six, Child of Light and Assassin's Creed.</i>  <i>In his blog, he often writes about interesting aspects of parallel programming, especially in relation to Game Dev.</i>  <i>Today I would like to submit to the public the translation of one of Jeff's articles.</i> <br><br>  The flow must wait.  Wait until you can get exclusive access to the resource or until the tasks for execution appear.  One of the wait mechanisms, in which the thread is not put to execution by the OS kernel scheduler, is implemented using a <b>semaphore</b> . <br><br>  I used to think that semaphores are long outdated.  In the 1960s, when few people were still writing multi-threaded programs, or any other programs, Edsger Dijkstra proposed the idea of ‚Äã‚Äãa new synchronization mechanism - a semaphore.  I knew that with the help of semaphores, one can keep track of the number of available resources or create an awkward analogue of a mutex, but this, as I believed, limits their scope. <br><a name="habracut"></a><br>  My opinion changed when I realized that using only semaphores and atomic operations, you can create all the other synchronization primitives: <br><ol><li>  Lightweight mutexes </li><li>  Lightweight conditional variables </li><li>  Lightweight read-write locks </li><li>  Primitive for solving the problem of the dining philosophers </li><li>  Lightweight semaphore </li></ol><br>  All these primitives are lightweight in the sense that some operations on them are performed completely in userspace, and they can (this is an optional condition) spin for a while in a loop before requesting a thread blocking from the operating system (examples are available <a href="https://github.com/preshing/cpp11-on-multicore">on GitHub</a> .) my primitive library has a <em>Semaphore</em> class that wraps the system semaphores of Windows, MacOS, iOS, Linux, and other POSIX-compatible OSs.  You can easily add any of these primitives to your project. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>Bouncer semaphore</b> </h4><br>  Imagine the many threads waiting to be executed, lined up, just like a line before entering a trendy nightclub.  A semaphore is a bouncer in front of the entrance.  He allows to go inside the club only when he is given the appropriate instructions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ef5/a86/e2a/ef5a86e2a1464e2d8917ada21f13957b.png"></div><br><br>  Each thread decides when to stand in this queue.  Dijkstra called this operation <em>P</em> , which was probably a reference to some funny-sounding Dutch term, but in modern semaphore implementations, you will most likely find only a <em>wait</em> operation.  Essentially, when a thread calls the <em>wait</em> method, it becomes a queue. <br><br>  The bouncer, i.e.  semaphore, should be able to do only one operation.  Dijkstra called this operation <em>V.</em>  To date, there is no agreement on how to call this operation.  As a rule, you can meet the functions <em>post</em> , <em>release</em> or <em>signal</em> .  I prefer <em>signal</em> .  When this method is called, the semaphore ‚Äúreleases‚Äù one of the waiting threads from the queue.  (This is not necessarily the same thread that caused the <em>wait</em> before the others.) <br><br>  And what happens if someone calls <em>signal</em> when there are no threads in the queue?  No problem: when any of the threads call <em>wait</em> , the semaphore will immediately skip this thread without blocking.  Moreover, if the <em>signal is</em> called 3 times in a row with an empty queue, the semaphore will allow the next three threads that caused <em>wait</em> to bypass the queue without waiting. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/425/efa/b46/425efab46dc94a98badc0c66af638b3d.png"></div><br><br>  It goes without saying that the semaphore should count the number of <em>signal</em> calls with an empty queue.  Therefore, each semaphore is provided with an internal counter, the value of which increases when the <em>signal is</em> called and decreases when the <em>wait is</em> called. <br><br>  The beauty of this approach is that regardless of the order in which the <em>wait</em> and <em>signal</em> are called, the result will always be the same: the semaphore always misses the same number of threads for execution, and the same number of pending will always remain in the queue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6f2/85f/2ee/6f285f2eec554ece8f416d0466146ef4.png"></div><br><br><h4>  <b>1. Lightweight mutex</b> </h4><br>  I already told you how to implement your own lightweight mutex <a href="http://preshing.com/20120226/roll-your-own-lightweight-mutex/">in a previous article</a> .  At that time, I did not know that this is only one example of the application of a common pattern, the main idea of ‚Äã‚Äãwhich is to delegate decisions about blocking flows of some new entity - <b>box office</b> .  Should the current thread wait in the queue?  Should he pass the semaphore without waiting?  Should we wake up some other thread? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/458/033/08e/45803308e6c84baa9bf6297c204ffbbd.png"></div><br><br>  Box office does not know anything about the number of threads waiting in the queue, nor does it know the current value of the internal semaphore counter.  Instead, he must somehow keep a history of his own states.  If we are talking about the implementation of a lightweight mutex, then a single counter with atomic increment and decrement operations is enough to store the history.  I called this counter <em>m_contention</em> , because  it stores information about how many threads at the same time want to capture the mutex. <br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LightweightMutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_contention; <span class="hljs-comment"><span class="hljs-comment">// The "box office" Semaphore m_semaphore; // The "bouncer"</span></span></code> </pre> <br>  When a thread wants to capture a mutex, it accesses the box office, which in turn increases the value of <em>m_contention</em> . <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_contention.fetch_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_acquire) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Visit the box office { m_semaphore.wait(); // Enter the wait queue } }</span></span></code> </pre><br>  If the counter value is zero, then the mutex is in an unmarked state.  In this case, the current thread automatically becomes the owner of the mutex, bypasses the semaphore without waiting, and continues to work in the code section protected by the mutex. <br><br>  If the mutex is already captured by another thread, then the counter value will be greater than zero and the current thread should wait for its turn to enter the critical section. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/99b/970/3c8/99b9703c8e3c448e98e5c31e7c1e8265.png"></div><br><br>  When a thread frees a mutex, box office reduces the internal counter by one: <br><pre> <code class="hljs cpp"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_contention.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_release) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Visit the box office { m_semaphore.signal(); // Release a waiting thread from the queue } }</span></span></code> </pre><br>  If the counter value before decrement was less than 1, then there are no waiting threads in the queue and the value of <em>m_contention</em> simply remains equal to 0. <br><br>  If the counter value was greater than 1, then another thread or several threads tried to capture the mutex, and, therefore, are waiting for their turn to enter the critical section.  In this case, we call <em>signal</em> so that the semaphore will wake up one of the threads and enable it to capture the mutex. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6ff/d3b/e97/6ffd3be97f7a45c1bba55dd7d0cef6e8.png"></div><br><br>  Each call to the box office is an atomic operation.  Thus, even if several threads call <em>lock</em> and <em>unlock</em> in parallel, they will always access the box office sequentially.  Moreover, the behavior of a mutex is completely determined by the internal state of the box office.  After accessing the box office, threads can call the semaphore methods in any order, and this will in no way break the consistency of the execution.  (In the worst case, threads will fight for a place in the semaphore line.) <br><br>  This primitive can be called "lightweight", since it allows the stream to capture the mutex without recourse to the semaphore, i.e.  without making a system call.  I published a mutex code on GitHub called <b>NonRecursiveBenaphore</b> , and there is also a recursive version of a lightweight mutex.  Nevertheless, there are no prerequisites for using these primitives in practice, since  most of the known implementations of mutexes are <a href="http://preshing.com/20111124/always-use-a-lightweight-mutex/">lightweight anyway</a> .  However, this code serves as a necessary illustration of the approach used for all other primitives described in this article. <br><br><h4>  <b>2. Lightweight conditional variable</b> </h4><br>  <i><b>Note</b></i>  <i><b>Lane:</b> in the original, the author called this primitive Auto-Reset Event Object, however, search engines for such a query give references to the C # class AutoResetEvent, whose behavior can be compared with std :: condition_variable with a few assumptions.</i> <br><br>  At <a href="http://habrahabr.ru/company/infopulse/blog/241674/">CppCon 2014,</a> I noted for myself that conditional variables are widely used when creating game engines, most often for notifying one thread of another (possibly in standby mode) about the presence of some work for it ( <i>comment: as such work perform the task of unpacking graphic resources and loading them in the GL context</i> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f3d/403/3de/f3d4033deed44f98bd58d271596ad5d0.png"></div><br><br>  In other words, no matter how many times the <em>signal</em> method is called, the internal counter of the condition variable should not become greater than 1. In practice, this means that you can queue tasks for execution by calling the <em>signal</em> method each time.  This approach works even if a data structure other than <i>queue is</i> used to assign tasks for execution. <br><br>  Some operating systems provide system tools for organizing conditional variables or their analogues.  However, if you add several thousand tasks to a queue at a time, the <i>signal</i> method calls can greatly affect the performance of the entire application. <br><br>  Fortunately, the box office pattern can significantly reduce the overhead associated with calling the <i>signal</i> method.  The logic can be implemented inside the box office entity using atomic operations so that the semaphore is accessed only when it is necessary to make the thread wait for its turn. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/375/cfb/707/375cfb707dc6420eae02b1ffdb7428f3.png"></div><br><br>  I implemented this primitive and called it <b>AutoResetEvent</b> .  This time the box office uses a different way of counting the number of threads waiting in the queue.  With a negative <i>m_status</i> , its absolute value indicates the number of threads waiting on the semaphore: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AutoResetEvent { private: // m_status == <span class="hljs-number"><span class="hljs-number">1</span></span>: Event <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> signaled. // m_status == <span class="hljs-number"><span class="hljs-number">0</span></span>: Event <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> threads are waiting. // m_status == -N: Event <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> N threads are waiting. std::atomic&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; m_status; Semaphore m_sema;</code> </pre><br>  In the <i>signal</i> method, we atomically increase the value of the <i>m_status</i> variable until its value reaches 1: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: <span class="hljs-type"><span class="hljs-type">void</span></span> signal() { <span class="hljs-type"><span class="hljs-type">int</span></span> oldStatus = m_status.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(std::memory_order_relaxed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) // <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> m_status atomically via CAS loop. { assert(oldStatus &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">int</span></span> newStatus = oldStatus &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? oldStatus + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_status.compare_exchange_weak(oldStatus, newStatus, std::memory_order_release, std::memory_order_relaxed)) break; // The compare-exchange failed, likely because another thread changed m_status. // oldStatus has been updated. Retry the CAS <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>. } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldStatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) m_sema.signal(); // <span class="hljs-keyword"><span class="hljs-keyword">Release</span></span> one waiting thread. }</code> </pre><br><br><h4>  <b>3. Lightweight read-write lock</b> </h4><br>  Using the same box office pattern, we can implement a primitive for read-write locks. <br><br>  This primitive does not block threads in the absence of writers.  In addition, it is a starvation-free for writers and readers, and, like other primitives, it can temporarily capture a spin lock before blocking the execution of the current stream.  To implement this primitive, two semaphores are required: one for awaiting readers, the other for writers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2dd/b13/2c2/2ddb132c224f48728b2b4bb67721465d.png"></div><br><br><h4>  <b>4. The problem of dining philosophers</b> </h4><br>  With the help of the box office pattern, you can solve the problem of the dining philosophers, and in a rather unusual way, which I have never met before.  I do not really believe that the proposed solution will be useful for someone, so I will not go into the details of the implementation.  I included a description of this primitive only to demonstrate the versatility of semaphores. <br><br>  So, we assign each philosopher (stream) its own semaphore.  Box office keeps track of who of the philosophers is currently taking food, who of the philosophers has asked for the start of the meal and the order of these requests.  This information is sufficient for the box office to lead all philosophers through semaphores attached to them in an optimal way. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/828/d6c/cc0/828d6ccc068a48eda8aad01bf4962343.png"></div><br><br>  I offered two complete implementations.  One of them is <b>DiningPhilosophers</b> , which implements the box office using a mutex.  The second is <b>LockReducedDiningPhilosophers</b> , in which each call to the box office is implemented as a lock-free algorithm. <br><br><h4>  <b>5. Lightweight semaphore</b> </h4><br>  Yes, that's right: with the box office pattern and the semaphore, we can implement ... another semaphore. <br><br>  Why do we need to do this?  Because then we get <b>LightweightSemaphore</b> .  Such a semaphore has a very cheap <i>signal</i> operation when there are no waiting threads in the queue.  Moreover, it does not depend on the semaphore implementation provided by the OS.  When you call <i>signal</i> , the box office increases the value of its own internal counter, without referring to the underlying semaphore. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8ea/c90/bf3/8eac90bf32a049cc9dc12f743c65ba63.png"></div><br><br>  In addition, you can force the thread to wait for some time in a loop, and only then block it.  This trick allows you to reduce the overhead associated with the system call, if the waiting time is less than some predetermined value. <br><br>  In the <a href="https://github.com/preshing/cpp11-on-multicore/tree/master/common">GitHub repository,</a> all primitives are implemented based on <b>LightweightSemaphore</b> .  This class is implemented on the basis of <b>Semaphore</b> , which in turn is implemented on the basis of semaphores provided by a specific OS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a8b/339/6db/a8b3396db55a49e096f1ad909c202e2f.png"></div><br><br>  I ran a few tests to compare the speed of the presented primitives when using <i>LightweightSemaphore</i> and <i>Semaphore</i> on my PC running Windows.  The corresponding results are shown in the table: <br><table><tbody><tr><th></th><th>  Lightweightsemaphore </th><th>  Semaphore </th></tr><tr><th>  testBenaphore </th><td>  375 ms </td><td>  5503 ms </td></tr><tr><th>  testRecursiveBenaphore </th><td>  393 ms </td><td>  404 ms </td></tr><tr><th>  testAutoResetEvent </th><td>  593 ms </td><td>  4665 ms </td></tr><tr><th>  testRWLock </th><td>  598 ms </td><td>  7126 ms </td></tr><tr><th>  testDiningPhilosophers </th><td>  309 ms </td><td>  580 ms </td></tr></tbody></table><br>  As you can see, the work time is sometimes quite different.  I must say, I am aware that not every environment will have the same or similar results.  In the current implementation, the thread waits for 10,000 loop iterations before blocking on the semaphore.  I briefly considered the possibility of using an adaptive algorithm, but the best way seemed to me unobvious.  So I am open to suggestions. <br><br><h4>  <b>Comparing semaphores and conditional variables</b> </h4><br>  Semaphores turned out to be much more useful primitives than I expected.  Why then are they missing in C ++ 11 STL?  For the same reason that they were absent in Boost: preference was given to mutexes and conditional variables.  From the point of view of library developers, the use of traditional semaphores <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2043.html">too often leads to errors</a> . <br><br>  If you think about it, then the box office pattern is just an optimization of ordinary condition variables for the case when all operations on condition variables are executed at the end of the critical section.  Consider the class AutoResetEvent.  I implemented the AutoResetEventCondVar class with the same behavior, but using std: condition_variable.  All operations on the conditional variable are performed at the end of the critical section. <br><pre> <code class="hljs ruby">void AutoResetEventCondVar::signal() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Increment m_status atomically via critical section. std::unique_lock&lt;std::mutex&gt; lock(m_mutex); int oldStatus = m_status; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldStatus == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Event object is already signaled. m_status++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldStatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) m_condition.notify_one(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Release one waiting thread. }</code> </pre><br>  We can optimize this method in two iterations: <br><ol><li>  We take out each conditional variable from the critical section and transform it into a semaphore.  The independence of the <i>signal</i> - <i>wait</i> sequence of operations over the semaphore makes such optimization possible.  After this step, our implementation of the method is already similar to the implementation of the box office pattern. </li><li>  Now we can make the lock-free method, replacing all operations with CAS, thereby dramatically increasing the scalability of the system. </li></ol><br>  After these two simple optimizations, we get an AutoResetEvent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/65b/5c7/a48/65b5c7a482b64dd6a2a726684bf7b4ce.png"></div><br><br>  On my Windows PC, simply replacing AutoResetEventCondVar with AutoResetEvent increases the speed of the algorithm 10 times. <br><br>  <em>From the translator: I have not translated anything for a long time, so I will be grateful for corrections and clarifications.</em> </div><p>Source: <a href="https://habr.com/ru/post/261273/">https://habr.com/ru/post/261273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261259/index.html">Yandex-Transfer in the terminal via Java</a></li>
<li><a href="../261263/index.html">"Pip -t" is a simple alternative to virtualenv</a></li>
<li><a href="../261265/index.html">Overview of new features in NDepend 6</a></li>
<li><a href="../261267/index.html">Microservice design</a></li>
<li><a href="../261271/index.html">Setting up security sites on VPS / VDS</a></li>
<li><a href="../261275/index.html">Key trends in the development of mobile applications, which is worth remembering in 2015</a></li>
<li><a href="../261277/index.html">Detailed App Store Optimization Guide for 2015 - Part 2: Google Play Store</a></li>
<li><a href="../261279/index.html">How does the program work with all these errors?</a></li>
<li><a href="../261285/index.html">C ++ User Group, meeting in Nizhny Novgorod</a></li>
<li><a href="../261287/index.html">Everything gets better when there is Bluetooth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>