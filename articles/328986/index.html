<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Breaking words into elements of the periodic table</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(The full source code is here ) 


 Sitting in a five-hour class in chemistry, I often glanced at the periodic table hanging on the wall. To pass the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Breaking words into elements of the periodic table</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/0ce/932/5a9/0ce9325a99ff4b5782697b2a737fd6b9.jpg"></p><br><p>  <em>(The full source code is <a href="https://github.com/mesbahamin/stoichiograph">here</a> )</em> </p><br><p>  Sitting in a five-hour class in chemistry, I often glanced at the periodic table hanging on the wall.  To pass the time, I began to look for words that I could write using only the notation of the elements from the table.  For example: ScAlS, FeArS, ErAsURe, WAsTe, PoInTlEsSnEsS, MoISTeN, SALMoN, PuFFInEsS. </p><br><p>  Then I thought what the longest word could be made (I managed to pick up <a href="https://www.poets.org/poetsorg/poem/bells">TiNTiNNaBULaTiONS</a> ), so I decided to write a Python program that would search for words consisting of chemical symbols.  She had to receive the word and return all of its possible transformations into sets of chemical elements: </p><br><ul><li>  Input: Amputations </li><li>  Output: AmPuTaTiONS, AmPUTaTiONS <a name="habracut"></a></li></ul><br><h2 id="generirovanie-gruppirovok-oboznacheniy">  Generate naming groupings </h2><br><p>  If the designations of all elements were of the same length, the problem would be trivial.  But some designations consist of two symbols, some - of one.  This greatly complicates matters.  For example, pu in amputations may mean plutonium (Pu) or phosphorus with uranium (PU).  Any input word must be broken down into all possible combinations of one and two-character symbols. </p><br><p>  I decided to call such transformations ‚Äúgroups‚Äù.  They define the specific division of the word into symbols.  Grouping can be represented as a tuple of ones and twos, where 1 is a one-character symbol, and 2 is a two-character one.  Each division into elements corresponds to a grouping: </p><br><ul><li>  'AmPuTaTiONS' <br><ul><li><code>(2,2,2,2,1,1,1)</code> </li> </ul></li><li>  'AmPUTaTiONS' <br><ul><li> <code>(2,1,1,2,2,1,1,1)</code> </li> </ul></li></ul><br><p>  Analyzing the task, in an attempt to find patterns, I wrote such a table in a notebook. </p><br><p>  <strong>Question:</strong> is a string given, n, how many sequences of units and twos can exist for it, so that the number of digits in each sequence equals n? </p><br><table><thead><tr><th>  n </th><th>  # groupings </th><th>  Groupings </th></tr></thead><tbody><tr><td>  0 </td><td>  one </td><td> <code>()</code> </td> </tr><tr><td>  one </td><td>  one </td><td> <code>(1)</code> </td> </tr><tr><td>  2 </td><td>  2 </td><td> <code>(1,1), (2)</code> </td> </tr><tr><td>  3 </td><td>  3 </td><td> <code>(1,1,1), (2,1), (1,2)</code> </td> </tr><tr><td>  four </td><td>  five </td><td> <code>(1,1,1,1), (2,1,1), (1,2,1), (1,1,2), (2,2)</code> </td> </tr><tr><td>  five </td><td>  eight </td><td> <code>(1,1,1,1,1), (2,1,1,1), (1,2,1,1), (1,1,2,1), (1,1,1,2), (2,2,1), (2,1,2), (1,2,2)</code> </td> </tr><tr><td>  6 </td><td>  13 </td><td> <code>(1,1,1,1,1,1), (2,1,1,1,1), (1,2,1,1,1), (1,1,2,1,1), (1,1,1,2,1), (1,1,1,1,2), (2,2,1,1), (2,1,2,1), (2,1,1,2), (1,2,2,1), (1,2,1,2), (1,1,2,2), (2,2,2)</code> </td> </tr><tr><td>  7 </td><td>  21 </td><td> <code>(1,1,1,1,1,1,1), (2,1,1,1,1,1), (1,2,1,1,1,1), (1,1,2,1,1,1), (1,1,1,2,1,1), (1,1,1,1,2,1), (1,1,1,1,1,2), (2,2,1,1,1), (2,1,2,1,1), (2,1,1,2,1), (2,1,1,1,2), (1,2,2,1,1), (1,2,1,2,1), (1,2,1,1,2), (1,1,2,2,1), (1,1,2,1,2), (1,1,1,2,2), (2,2,2,1), (2,2,1,2), (2,1,2,2), (1,2,2,2)</code> </td> </tr></tbody></table><br><p>  <strong>Answer:</strong> <code>fib(n + 1)</code> !? </p><br><p>  I was surprised to find the Fibonacci sequence in such an unexpected place.  During the following explorations, I was surprised even more when I <a href="http://people.sju.edu/~rhall/mathforpoets.pdf">learned</a> that this pattern was known two thousand years ago.  Prosodist poets from ancient India discovered it by exploring the transformations of short and long syllables of Vedic chants.  You can read about this and other excellent studies in the history of combinatorics in Chapter 7.2.1.7 of the book <em><a href="https://books.google.com/books%3Fid%3D56LNfE2QGtYC%26pg%3DPA50%26dq%3DPingala">The Art of Computer Programming by</a></em> Donald Knut. </p><br><p>  I was impressed with this discovery, but still did not reach the initial goal: generating the factions themselves.  After some thoughts and experiments, I came up with the simplest solution I could come up with: generate all possible sequences of ones and twos, and then filter out those whose sum of elements does not coincide with the length of the input word. </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> itertools import chain, <span class="hljs-function"><span class="hljs-function">product def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_groupings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word_length, glyph_sizes=(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)): cartesian_products</span></span> = ( product(glyph_sizes, repeat=r) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> r </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, word_length + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) ) #  ,       groupings</span></span> = tuple( grouping <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> grouping <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chain.from_iterable(cartesian_products) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grouping</span></span></span><span class="hljs-function">)</span></span> == word_length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> groupings</code> </pre> <br><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258F%25D0%25BC%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">A Cartesian product</a> is a collection of all tuples composed of an existing set of elements.  The standard Python library provides the function <a href="https://docs.python.org/3/library/itertools.html"><code>itertools.product()</code></a> , which returns the Cartesian product of elements for a given iterable.  <code>cartesian_products</code> is a generating expression that collects all possible transformations of elements into <code>glyph_sizes</code> up to the length specified in <code>word_length</code> . </p><br><p>  If <code>word_length</code> is 3, then <code>cartesian_products</code> generate: </p><br><pre> <code class="hljs json">[ (<span class="hljs-number"><span class="hljs-number">1</span></span>,), (<span class="hljs-number"><span class="hljs-number">2</span></span>,), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ]</code> </pre> <br><p>  The result is then filtered so that the <code>groupings</code> include only those transformations whose number of elements satisfies the <code>word_length</code> . </p><br><pre> <code class="hljs lisp">&gt;&gt;&gt; generate_groupings(<span class="hljs-number"><span class="hljs-number">3</span></span>) ((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><p>  Of course, there is a lot of extra work.  The function has computed 14 transformations, but only 3 remain. Performance drops dramatically with increasing word length.  But we will come back to this later.  In the meantime, I got a working function and moved on to the next task. </p><br><h2 id="sopostavlenie-slov-s-gruppirovkami">  Matching words with groupings </h2><br><p>  After calculating all possible groupings for the word, it was necessary to ‚Äúmatch‚Äù it with each of the groups: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word, grouping)</span></span></span></span>: chars = (c <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> word) mapped = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> glyph_size <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-symbol"><span class="hljs-symbol">grouping:</span></span> glyph = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(glyph_size): glyph += <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>(chars) mapped.append(glyph) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tuple(mapped)</code> </pre> <br><p>  The function treats each designation in the grouping as with a cup: first it fills it with as many characters from the word as it can, and then proceeds to the next.  When all characters are placed in the correct notation, the resulting matching word is returned as a tuple: </p><br><pre> <code class="hljs lisp">&gt;&gt;&gt; map_word('because', (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) ('b', 'ec', 'a', 'u', 'se')</code> </pre> <br><p>  After matching, the word is ready for comparison with the list of symbols of chemical elements. </p><br><h2 id="poisk-variantov-napisaniya">  Search for spelling options </h2><br><p>  I wrote a <code>spell()</code> function that brings together all previous operations: </p><br><pre> <code class="hljs pgsql">def spell(word, symbols=ELEMENTS): groupings = generate_groupings(len(word)) spellings = [map_word(word, grouping) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> grouping <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> groupings] elemental_spellings = [ tuple(token.capitalize() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> spelling) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> spelling <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> spellings <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(s.lower() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> spelling) &lt;= <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(s.lower() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols) ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elemental_spellings</code> </pre> <br><p>  <code>spell()</code> gets all the possible spellings and returns only those that are entirely composed of the element designations.  For effective filtering of unsuitable options, I used sets. </p><br><p>  Python sets are very similar to mathematical sets.  These are unordered collections of unique items.  Behind the scenes, they are implemented as dictionaries (hash tables) with keys, but without values.  Since all elements of the set are hashable, the membership test works very efficiently ( <a href="https://wiki.python.org/moin/TimeComplexity">on average, O (1)</a> ).  Comparison operators are reloaded to test for <a href="https://en.wikipedia.org/wiki/Subset">subsets</a> using these effective affinity checks.  Sets and dictionaries are well described in the wonderful book <em><a href="http://shop.oreilly.com/product/0636920032519.do">Fluent Python by</a></em> Luciano Ramalho. </p><br><p>  I earned the last component, and I got a functioning program! </p><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; spell(<span class="hljs-string"><span class="hljs-string">'amputation'</span></span>) [(<span class="hljs-string"><span class="hljs-string">'Am'</span></span>, <span class="hljs-string"><span class="hljs-string">'Pu'</span></span>, <span class="hljs-string"><span class="hljs-string">'Ta'</span></span>, <span class="hljs-string"><span class="hljs-string">'Ti'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'N'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Am'</span></span>, <span class="hljs-string"><span class="hljs-string">'P'</span></span>, <span class="hljs-string"><span class="hljs-string">'U'</span></span>, <span class="hljs-string"><span class="hljs-string">'Ta'</span></span>, <span class="hljs-string"><span class="hljs-string">'Ti'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">'N'</span></span>)] &gt;&gt;&gt; spell(<span class="hljs-string"><span class="hljs-string">'cryptographer'</span></span>) [(<span class="hljs-string"><span class="hljs-string">'Cr'</span></span>, <span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">'Pt'</span></span>, <span class="hljs-string"><span class="hljs-string">'Og'</span></span>, <span class="hljs-string"><span class="hljs-string">'Ra'</span></span>, <span class="hljs-string"><span class="hljs-string">'P'</span></span>, <span class="hljs-string"><span class="hljs-string">'H'</span></span>, <span class="hljs-string"><span class="hljs-string">'Er'</span></span>)]</code> </pre> <br><h2 id="samoe-dlinnoe-slovo">  The longest word? </h2><br><p>  Satisfied with my implementation of the core functionality, I called the <a href="https://github.com/mesbahamin/stoichiograph">Stoichiograph</a> program and made a wrapper for it using the command line.  The wrapper takes a word as an argument or from a file and displays spellings.  Adding the function of sorting words in descending order, I set the program on the word list. </p><br><pre> <code class="hljs mel">$ ./stoichiograph.py --<span class="hljs-keyword"><span class="hljs-keyword">sort</span></span> --batch-<span class="hljs-keyword"><span class="hljs-keyword">file</span></span> /usr/share/dict/american-english NoNRePReSeNTaTiONaL NoNRePReSeNTaTiONAl [...]</code> </pre> <br><p>  Fine!  I myself would not have found this word.  The program is already solving the task.  I played around and found a longer word: </p><br><pre> <code class="hljs ruby">$ ./stoichiograph.py nonrepresentationalisms NoNRePReSeNTaTiONaLiSmS NONRePReSeNTaTiONaLiSmS NoNRePReSeNTaTiONAlISmS NONRePReSeNTaTiONAlISmS</code> </pre> <br><p>  Interesting.  I wanted to find out if this is really the longest word ( <a href="https://www.amin.space/blog/2017/5/elemental_speller/spoiler.txt">spoiler</a> ), and I decided to explore <a href="https://en.wikipedia.org/wiki/Longest_word_in_English">longer words</a> .  But first it was necessary to deal with performance. </p><br><h2 id="reshenie-problem-s-proizvoditelnostyu">  Solving performance problems </h2><br><p>  Processing 119,095 words (many of which were rather short) took about 16 minutes for the program: </p><br><pre> <code class="hljs go">$ time ./stoichiograph.py --sort --batch-file /usr/share/dict/american-english [...] <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>m0<span class="hljs-number"><span class="hljs-number">.458s</span></span> user <span class="hljs-number"><span class="hljs-number">15</span></span>m33<span class="hljs-number"><span class="hljs-number">.680s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m23<span class="hljs-number"><span class="hljs-number">.173s</span></span></code> </pre> <br><p>  On average about 120 words per second.  I was sure that you could do it much faster.  I needed more detailed performance information to figure out where to dig. </p><br><p>  <a href="https://github.com/rkern/line_profiler">Line profiler</a> is a tool for determining bottlenecks in Python code performance.  I used it to profile the program when she was looking for a spelling for the 23-letter word.  Here is a compressed version of the report: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Line</span></span> # % <span class="hljs-type"><span class="hljs-type">Time</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> Contents =============================== <span class="hljs-number"><span class="hljs-number">30</span></span> @profile <span class="hljs-number"><span class="hljs-number">31</span></span> def spell(word, symbols=ELEMENTS): <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">71.0</span></span> groupings = generate_groupings(len(word)) <span class="hljs-number"><span class="hljs-number">33</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> <span class="hljs-number"><span class="hljs-number">15.2</span></span> spellings = [map_word(word, grouping) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> grouping <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> groupings] <span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span> elemental_spellings = [ <span class="hljs-number"><span class="hljs-number">37</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> tuple(token.capitalize() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> spelling) <span class="hljs-number"><span class="hljs-number">38</span></span> <span class="hljs-number"><span class="hljs-number">13.8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> spelling <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> spellings <span class="hljs-number"><span class="hljs-number">39</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(s.lower() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> spelling) &lt;= <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(s.lower() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols) <span class="hljs-number"><span class="hljs-number">40</span></span> ] <span class="hljs-number"><span class="hljs-number">41</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elemental_spellings <span class="hljs-type"><span class="hljs-type">Line</span></span> # % <span class="hljs-type"><span class="hljs-type">Time</span></span> <span class="hljs-type"><span class="hljs-type">Line</span></span> Contents =============================== <span class="hljs-number"><span class="hljs-number">45</span></span> @profile <span class="hljs-number"><span class="hljs-number">46</span></span> def generate_groupings(word_length, glyhp_sizes=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)): <span class="hljs-number"><span class="hljs-number">47</span></span> cartesian_products = ( <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> product(glyph_sizes, repeat=r) <span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, word_length + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">50</span></span> ) <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> groupings = tuple( <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> grouping <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-number"><span class="hljs-number">100.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> grouping <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chain.from_iterable(cartesian_products) <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sum(grouping) == word_length <span class="hljs-number"><span class="hljs-number">56</span></span> ) <span class="hljs-number"><span class="hljs-number">57</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> groupings</code> </pre> <br><p>  It's no wonder that <code>generate_groupings()</code> works so long.  The problem that she is trying to solve is a special case <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE_%25D1%2581%25D1%2583%25D0%25BC%25D0%25BC%25D0%25B5_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2">of the sum of subsets problem</a> , which is an <a href="https://ru.wikipedia.org/wiki/NP-%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0">NP-complete problem</a> .  Finding a Cartesian product quickly becomes expensive, and <code>generate_groupings()</code> searches for numerous Cartesian products. </p><br><p>  You can perform an asymptotic analysis to see how bad everything is: </p><br><ol><li>  We assume that <code>glyph_sizes</code> always contain two elements (1 and 2). </li><li>  <code>product()</code> finds <code>r</code> times the Cartesian product of a set of two elements, so the time complexity for <code>product()</code> is <code>O(2^r)</code> . </li><li>  <code>product()</code> is called in a loop that repeats <code>word_length</code> times, so if we equate <code>n</code> to <code>word_length</code> , the time complexity for the entire cycle will be <code>O(2^r * n)</code> . </li><li>  But <code>r</code> gets different values ‚Äã‚Äãfor each run of the loop, so in fact the time complexity is closer to <code>O(2^1 + 2^2 + 2^3 + ... + 2^(n-1) + 2^n)</code> . </li><li>  And since <code>2^0 + 2^1 + ... + 2^n = 2^(n+1) - 1</code> , the resulting time complexity is <code>O(2^(n+1) - 1)</code> , or <code>O(2^n)</code> . </li></ol><br><p>  With <code>O(2^n)</code> it can be expected that the execution time will double with each <code>word_length</code> increment.  Awful </p><br><p>  I have been thinking about the performance problem for many weeks.  It was necessary to solve two interrelated, but different tasks: </p><br><ol><li>  Processing a list of words of different lengths. </li><li>  Handling a single, but very long word. </li></ol><br><p>  The second task turned out to be much more important, because it influenced the first one.  Although I did not immediately figure out how to improve the processing in the second case, but I had ideas about the first, so I started with it. </p><br><h2 id="zadacha-1-byt-lenivym">  Task 1: to be lazy </h2><br><p>  Laziness is a virtue not only for <a href="http://wiki.c2.com/%3FLazinessImpatienceHubris">programmers</a> , but also for the programs themselves.  The solution of the first problem required the addition of laziness.  If the program will check a long list of words, then how to make it do as little work as possible? </p><br><h2 id="proverka-na-nepravilnye-simvoly">  Check for incorrect characters </h2><br><p>  Naturally, I thought that the list probably contains words containing characters that are not listed in the periodic table.  It makes no sense to spend time searching for spellings for such words.  So, the list can be processed faster if you quickly find and throw out such words. </p><br><p>  Unfortunately, the only characters not represented in the table were j and q. </p><br><pre> <code class="hljs lisp">&gt;&gt;&gt; set('abcdefghijklmnopqrstuvwxyz') - set(''.join(<span class="hljs-name"><span class="hljs-name">ELEMENTS</span></span>).lower()) ('j', 'q')</code> </pre> <br><p>  And in my dictionary only 3% of words contained these letters: </p><br><pre> <code class="hljs lua">&gt;&gt;&gt; with <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(<span class="hljs-string"><span class="hljs-string">'/usr/share/dict/american-english'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) as f: ... words = f.readlines() ... &gt;&gt;&gt; total = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(words) &gt;&gt;&gt; invalid_char_words = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>( ... [w <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'j'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> w.<span class="hljs-built_in"><span class="hljs-built_in">lower</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> w.<span class="hljs-built_in"><span class="hljs-built_in">lower</span></span>()] ... ) ... &gt;&gt;&gt; invalid_char_words / total * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">3.3762962340988287</span></span></code> </pre> <br><p>  Throwing them out, I got a performance boost of only 2%: </p><br><pre> <code class="hljs go">$ time ./stoichiograph.py --sort --batch-file /usr/share/dict/american-english [...] <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>m44<span class="hljs-number"><span class="hljs-number">.246s</span></span> user <span class="hljs-number"><span class="hljs-number">15</span></span>m17<span class="hljs-number"><span class="hljs-number">.557s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m22<span class="hljs-number"><span class="hljs-number">.980s</span></span></code> </pre> <br><p>  It was not the improvement I was hoping for, so I moved on to the next idea. </p><br><h2 id="memoizaciya">  Memoization </h2><br><p>  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25BC%25D0%25BE%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Memoisation</a> is a technique for storing the output of a function and returning it if the function is called again with the same input data.  Memotized functions need to generate output data only once based on specific inputs.  This is very useful when using expensive functions that are repeatedly called with the same multiple inputs.  But memoization works only for pure functions. </p><br><p>  <code>generate_groupings()</code> was the perfect candidate.  It is unlikely to encounter a very large range of input data and is very expensive to perform when processing long words.  The <code>functools</code> package facilitates memoization by providing the decorator <a href="https://docs.python.org/3/library/functools.html"><code>@lru_cache()</code></a> . </p><br><p>  The <code>generate_groupings()</code> memoization has led to a decrease in execution time ‚Äî noticeably, although not enough: </p><br><pre> <code class="hljs go">$ time ./stoichiograph.py --sort --batch-file /usr/share/dict/american-english [...] <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>m15<span class="hljs-number"><span class="hljs-number">.483s</span></span> user <span class="hljs-number"><span class="hljs-number">10</span></span>m54<span class="hljs-number"><span class="hljs-number">.553s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m17<span class="hljs-number"><span class="hljs-number">.083s</span></span></code> </pre> <br><p>  But still not bad for the only decorator from the standard library! </p><br><h2 id="zadacha-2-byt-umnym">  Task 2: be smart </h2><br><p>  My optimizations helped a little with the first task, but the key unsolved problem remained the inefficiency of <code>generate_groupings()</code> , large individual words were still processed for a very long time: </p><br><pre> <code class="hljs go">$ time ./stoichiograph.py nonrepresentationalisms [...] <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m20<span class="hljs-number"><span class="hljs-number">.275s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m20<span class="hljs-number"><span class="hljs-number">.220s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.037s</span></span></code> </pre> <br><p>  Laziness can lead to some progress, but sometimes you need to be smart. </p><br><h2 id="rekursiya-i-dag">  Recursion and DAG </h2><br><p>  Dozing off one evening, I experienced a flash of inspiration and ran to the marker board to draw it: </p><br><p><img src="https://habrastorage.org/web/708/387/258/7083872584c4441993090c1c157769f9.png" alt="image"></p><br><p>  I thought that I could take any string, pull out all the one and two-character notations, and then in both cases <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BA%25D1%2583%25D1%2580%25D1%2581%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">recurs the</a> rest.  After going through the whole line, I will find all the designations of the elements and, most importantly, I will receive information about their structure and order.  I also thought that the graph could be an excellent option for storing such information. </p><br><p>  If a series of recursive function calls for the perfect word amputation looks like this: </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-string"><span class="hljs-string">'mputation'</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-string"><span class="hljs-string">'putation'</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-string"><span class="hljs-string">'utation'</span></span> <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-string"><span class="hljs-string">'tation'</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-string"><span class="hljs-string">'ation'</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-string"><span class="hljs-string">'tion'</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-string"><span class="hljs-string">'ion'</span></span> <span class="hljs-string"><span class="hljs-string">'i'</span></span> <span class="hljs-string"><span class="hljs-string">'on'</span></span> <span class="hljs-string"><span class="hljs-string">'o'</span></span> <span class="hljs-string"><span class="hljs-string">'n'</span></span> <span class="hljs-string"><span class="hljs-string">'n'</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-string"><span class="hljs-string">'on'</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-string"><span class="hljs-string">'io'</span></span> <span class="hljs-string"><span class="hljs-string">'n'</span></span> <span class="hljs-string"><span class="hljs-string">'ti'</span></span> <span class="hljs-string"><span class="hljs-string">'on'</span></span> <span class="hljs-string"><span class="hljs-string">'at'</span></span> <span class="hljs-string"><span class="hljs-string">'ion'</span></span> <span class="hljs-string"><span class="hljs-string">'ta'</span></span> <span class="hljs-string"><span class="hljs-string">'tion'</span></span> <span class="hljs-string"><span class="hljs-string">'ut'</span></span> <span class="hljs-string"><span class="hljs-string">'ation'</span></span> <span class="hljs-string"><span class="hljs-string">'pu'</span></span> <span class="hljs-string"><span class="hljs-string">'tation'</span></span> <span class="hljs-string"><span class="hljs-string">'mp'</span></span> <span class="hljs-string"><span class="hljs-string">'utation'</span></span> <span class="hljs-string"><span class="hljs-string">'am'</span></span> <span class="hljs-string"><span class="hljs-string">'putation'</span></span></code> </pre> <br><p>  then after filtering all the symbols that do not satisfy the periodic table, you can get a similar graph: </p><br><p><img src="https://habrastorage.org/web/b81/f42/0ab/b81f420ab7b541c5b5ebec0953efbe9d.png" alt="image"></p><br><p>  The result is a <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BA%25D0%25BB%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584">directed acyclic graph</a> (DAG), each node of which contains the designation of a chemical element.  All paths from the first node to the last will be valid spellings of the source word in the form of chemical elements! </p><br><p>  Before that, I did not work with graphs, but I found a very useful <a href="https://www.python.org/doc/essays/graphs/">essay</a> that describes the basics, including an effective search for all paths between two nodes.  In the excellent book <em><a href="http://aosabook.org/en/index.html">500 Lines or Less</a></em> there is a <a href="http://www.aosabook.org/en/500L/contingent-a-fully-dynamic-build-system.html">chapter</a> with another example of a graph implementation in Python.  These examples I took as a basis. </p><br><p>  Having implemented and tested a simple graph class, I turned my drawing on the board into a function: </p><br><pre> <code class="hljs pgsql">#   .        . Node = namedtuple(<span class="hljs-string"><span class="hljs-string">'Node'</span></span>, [<span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-string"><span class="hljs-string">'position'</span></span>]) def build_spelling_graph(word, graph, symbols=ELEMENTS): """   ,    -    .    ,        . """ def pop_root(remaining, position=<span class="hljs-number"><span class="hljs-number">0</span></span>, previous_root=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> remaining == <span class="hljs-string"><span class="hljs-string">''</span></span>: graph.add_edge(previous_root, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> single_root = Node(remaining[<span class="hljs-number"><span class="hljs-number">0</span></span>], position) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> single_root.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.capitalize() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: graph.add_edge(previous_root, single_root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> remaining <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> processed: pop_root( remaining[<span class="hljs-number"><span class="hljs-number">1</span></span>:], position + <span class="hljs-number"><span class="hljs-number">1</span></span>, previous_root=single_root ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(remaining) &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>: double_root = Node(remaining[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>], position) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> double_root.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.capitalize() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: graph.add_edge(previous_root, double_root) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> remaining <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> processed: pop_root( remaining[<span class="hljs-number"><span class="hljs-number">2</span></span>:], position + <span class="hljs-number"><span class="hljs-number">2</span></span>, previous_root=double_root ) processed.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(remaining) processed = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>() pop_root(word)</code> </pre> <br><h3 id="vyigrysh">  Win </h3><br><p>  While the head-on algorithm ran awfully long ( <code>O(2^n)</code> ), the recursive lasted <code>O(n)</code> .  Much better!  When I for the first time ran a svezheoptimizirovannuyu program on his dictionary, I was shocked: </p><br><pre> <code class="hljs go">$ time ./stoichiograph.py --sort --batch-file /usr/share/dict/american-english [...] <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m11<span class="hljs-number"><span class="hljs-number">.299s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m11<span class="hljs-number"><span class="hljs-number">.020s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.17</span></span>ys</code> </pre> <br><p>  Instead of 16 minutes, I got 10 seconds, instead of 120 words per second - 10,800 words! </p><br><p>  For the first time, I really appreciated the power and value of data structures and algorithms. </p><br><h2 id="samoe-dlinnoe-slovo-1">  Longest word </h2><br><p>  With the new features I was able to find the longest word, broken down into chemical elements: floccinaucinihilipilificatiousness.  It is a derivative of <a href="https://ru.wiktionary.org/wiki/floccinaucinihilipilification">floccinaucinihilipilification</a> , which means an action or habit of describing something or treating something as unimportant, valueless or useless.  This word is often called the longest non-technical word in the English language. </p><br><p>  Floccinaucinihilipilificatiousness can be represented in the form of 54 spellings, all of them are encrypted in this beautiful graph: </p><br><p><img src="https://habrastorage.org/web/30e/27b/fe9/30e27bfe9d29468e9ef86e5f85cdf594.png" alt="image"><br>  <a href="">Original</a> </p><br><h2 id="horosho-potrachennoe-vremya">  Well spent time </h2><br><p>  Someone may say that all of the above is complete nonsense, but for me it has become a valuable and important experience.  When I started my project, I was relatively inexperienced in programming and had no idea where to start.  It moved slowly, and it took quite a while until I achieved a satisfactory result (see the <a href="https://github.com/mesbahamin/stoichiograph/commits/master">history of commits</a> , there are big breaks when I switched to other projects). </p><br><p>  Nevertheless, I learned a lot and learned a lot.  It: </p><br><ul><li>  Combinatorics </li><li>  Performance profiling </li><li>  Time complexity </li><li>  Memoization </li><li>  Recursion </li><li>  Graphs and trees </li></ul><br><p>  The understanding of these concepts helped me many times.  Especially important for my <a href="https://www.amin.space/blog/2017/5/quadtree_debug/">simulation project on n-bodies</a> recursion and trees. </p><br><p>  Finally, it was nice to find the answer to my own original question.  I know that you no longer need to think about splitting into chemical elements, because I now have a tool for this that you can get and you can use <code>pip install stoichiograph</code> . </p><br><h2 id="obsuzhdenie">  Discussion </h2><br><p>  Kind people (and several well-intentioned bots) participated in the <a href="https://www.reddit.com/r/programming/comments/6bgxia/using_python_to_find_the_longest_word_spellable/%3Fref%3Dshare%26ref_source%3Dlink">discussion of</a> this article in the r / programming branch. </p><br><h2 id="dopmaterialy">  Additional materials </h2><br><p>  I got a lot of inspiration from the elegant solutions to some interesting problems, the solutions belong to Peter Norvig: </p><br><ul><li>  <em><a href="http://norvig.com/spell-correct.html">How to Write a Spelling Corrector</a></em> </li><li>  <em><a href="http://norvig.com/sudoku.html">Solving Every Sudoku Puzzle</a></em> </li></ul><br><p>  Two informative articles about performance profiling in Python: </p><br><ul><li>  <em><a href="http://blog.thehumangeo.com/2015/07/28/profiling-in-python/">Profiling in Python</a></em> </li><li>  <em><a href="https://www.huyng.com/posts/python-performance-analysis">A Guide to Analyzing Python Performance</a></em> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/328986/">https://habr.com/ru/post/328986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328974/index.html">Top designs by Behance users</a></li>
<li><a href="../328976/index.html">Scheduling: myths and reality. Yandex experience</a></li>
<li><a href="../328978/index.html">How and why to create a NginX module - theory, practice, profit</a></li>
<li><a href="../328980/index.html">When you need a corporate app store</a></li>
<li><a href="../328984/index.html">Open broadcast DotNext 2017 Piter: Jon Skeet, Sasha Goldshtein and Andrey Akinshin live</a></li>
<li><a href="../328988/index.html">How to choose a reliable data center provider: seven success factors</a></li>
<li><a href="../328990/index.html">Tours in exploratory testing. Personal translation from D. Whittaker's book "Software Research Testing"</a></li>
<li><a href="../328992/index.html">We clean the tails of Microsoft Exchange Server 2016 using Powershell</a></li>
<li><a href="../328994/index.html">Tale of two printers, or how we drove the Ricoh printers</a></li>
<li><a href="../328996/index.html">Marketing research. How to check the business idea for a week, spending a penny?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>