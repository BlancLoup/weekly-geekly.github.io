<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Iterator in doT.js template engine for objects with filtering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The compact (3.5 Kb) and fast doT.js template for browsers and nodeJS so far (v.1.0.1) has iteration over arrays only. It is not always convenient to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Iterator in doT.js template engine for objects with filtering</h1><div class="post__text post__text-html js-mediator-article"> <nobr><img src="https://habrastorage.org/getpro/habr/post_images/054/21c/59a/05421c59a7cc5e2fb6f9cf627dadea83.png" align="right"></nobr>  The compact (3.5 Kb) and fast <b>doT.js</b> template for browsers and nodeJS so far (v.1.0.1) has iteration over arrays only.  It is not always convenient to adjust the control object to the presence of arrays in it.  It is better to adjust the template engine to the presence in it of an <b>iterator on objects with condition check</b> .  It is often necessary to check conditions in loops on objects ‚Äî this includes hasOwnProperty (), and checking for a DOM object, and taking a part of the hash by filtering indexes. <br><br>  How do you write an array iteration in a template?  Like that: <br><pre><code class="html hljs xml">{{~it.elemsArray:property:i}} ... {{~}}</code> </pre> <br><a name="habracut"></a><br>  Inside the loop, you can use {{= property}} (the value of the current property), {{= i}} (array index) and expressions based on them.  Nothing prevents you from adding a check in the template engine not only to the array, but also to the object in order to correctly select the further construction of the loop.  To do this, you need to get inside a rather simple template engine and rewrite the loop, already working on arrays, into a loop that will work on objects.  Leaving, of course, the original possibility in the general code. <br><br>  Add another iterator type to the template engine.  <i>(The number of teams in the arsenal will increase by one - {{@ ...}}, so the template engine will begin to work a little slower - while you search for another regexp using a template.)</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="html hljs xml">{{@ it.elemsObject : property : i : condition}} ... {{@}} <span class="hljs-comment"><span class="hljs-comment">&lt;!--    --&gt;</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">(another option)</b> <div class="spoiler_text">  If we combine the iterators into one, there will be practically no slowdown, since the regular expression will become slightly more complicated, and then at the end itself.  <i>(We will not implement this option now, so as not to turn the template engine into another one.)</i> <br><br><pre> <code class="html hljs xml">{{~ it.elemsObjectOrArray : property : i : condition}} ... {{~}}</code> </pre><br><br>  Further code generation will be complicated, but it is known to be executed quickly.  (Most likely, not even the template parsing, but the interpretation of the synthesized code will be slower.) <br></div></div><br>  " <i>condition</i> " here is just an executable part of an expression.  The peculiarity of this template engine, like many others, is that it synthesizes the JS code (as they say - compiles the template), turning it into an executable function, and immediately executes it.  We use this to simply attach part of the expression to the <i>property</i> value, which is calculated in a loop.  As you know, the loop for objects in JS often looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(it.elemsObject) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> it.elemsObject){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property = it.elemsObject[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(property condition){ ...   ... }};</code> </pre><br><br>  This is exactly what the iterator on the object in our appendix will do.  The syntacically incomprehensible ‚Äúproperty condition‚Äù is our ploy that fully exploits the already existing drawback of this template engine ‚Äî the implicit execution of eval () in new Function ().  In order not to violate the syntactic integrity of the code, it will be necessary to comply with the requirement that <i>condition</i> be an expression that does not change its meaning when concatenated with <i>property</i> . <br><br>  Here are the 3 most popular examples when it is needed and how it will look. <br><br>  1. <u>Cycle by own properties</u> <br>  {{@ it.elemsObject: propName: ii: .hasOwnProperty (ii)}} ... {{@}} <br><br>  2. <u>Loop through DOM elements</u> <br><pre> <code class="html hljs xml">{{@ it.elemsObject : elName : ii :.attributes}} ... {{@}}</code> </pre><br><br>  Will give a cycle: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr1 = it.elemsObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr1) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arr1){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elName = arr1[ii]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(elName.attributes){ out += <span class="hljs-string"><span class="hljs-string">'...'</span></span> }}</code> </pre><br><br>  3. <u>Cycle of the main object</u> <br><br><pre> <code class="html hljs xml">{{@ it.elemsObject : elName : ii :, /y\d+/.test(ii) }} ... {{@}}</code> </pre><br><br>  For iterations, selects only those objects whose indices look like ‚Äúy &lt;number&gt;‚Äù. <br><br>  The last example greatly expands the flexibility of using templates ‚Äî you can place one or more collections of items in the root of a shared object that differ in the format of the index or the properties of their values.  (For example, values ‚Äã‚Äãcan be an object with a property ‚Äî a collection attribute. It also demonstrates how easy it is to drop the default propName element in a template ‚Äî simply by putting a comma, turning the expression into an enumeration of expressions. <br><br>  In the existing template engine, such cycles, in fact, could be implemented by using the ‚Äúevaluate‚Äù construction: <i>{{&lt;arbitrary operators&gt;}}</i> .  Then I would have to completely describe my cycle in the template.  But instead, we create a small addition to the loop construction of arrays, in order to have a brief notation of the conditional expression.  It would be a little wise (for large systems) to wrap an expression in a function (so as not to have a composite syntax), which, by the way, would slow it down and require explicitly writing the name <i>property</i> in the condition. <br><br>  For reference, the loop that makes the existing template array array looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr1 = it.elemsObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(arr1){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vname, ii =<span class="hljs-number"><span class="hljs-number">-1</span></span>, l1 = arr1.length <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ii &lt; l1){ vname = arr1[++ii]; out += <span class="hljs-string"><span class="hljs-string">'...'</span></span> }}</code> </pre><br><br>  Therefore, he could not work with objects - he uses a counter.  Which is probably a bit faster than the universal for-in loop, but the loss of time does not go on cycles.  Time is wasted interpreting the synthesized pattern.  We will not improve it in this extension in order to fully preserve the efficiency and behavior of existing templates. <br><br>  There is in our new type of cycle, c condition at the end, a small but natural limitation - it cannot use 2 "}" characters in a row.  In all cases, the code is easy to get around.  It is permissible to write multi-line expressions with definitions of functions, for example, not forgetting only that "}}" is the end of the iterator header.  Example: <br><br><pre> <code class="javascript hljs">{{@ it :year:i:, aa = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1234</span></span>; }, /^y\d+$/.test(i + aa) }}</code> </pre><br><br>  With such features, the template easily turns into a description of functions with small HTML inserts (and not vice versa).  This is not necessarily convenient, but we have removed the restrictions on JS in the iterator. <br><br><h3>  Related improvements </h3><br>  The propName: ii values ‚Äã‚Äãcan be omitted - the parsing in the template engine is corrected so that in the absence of values ‚Äã‚Äãthe default names are substituted.  The default property name is arrI1, arrI2, and further, depending on the sequence number of the iterator header.  The default object index is i1, i2 or later.  Such strange names were chosen for historical reasons ‚Äî the same exist in doT.js for array indices, and the implicit array names looked like arr1, arr2, and so on.  We simply keep the tradition: if the name of the hash is arr1, then the name of its property is arrI1 (equal to arr1 [i1]).  For example, <br><br><pre> <code class="html hljs xml">{{@ it.elemsObject :::.attributes}}</code> </pre><br>  tantamount to <br><pre> <code class="html hljs xml">{{@ it.elemsObject : arrI1 : i1 :.attributes}}</code> </pre><br>  (if this is the first iterator header in the template) <br>  or <br><pre> <code class="html hljs xml">{{@ it.elemsObject : arrI2 : i2 :.attributes}}</code> </pre><br>  (if this is the second iterator header in the template, etc.) <br><br>  If you think about the quality of reading the template, then the default name would be better to choose as the last in the compound name of the object.  In this example, elemsObject.  It would be like this: {{@ it.elemsObject}} is {{@ it.elemsObject: elemsObjectI1: i1}}.  But for the sake of historical conformity, we will not introduce such a rule for the iterator. <br><br>  * The second important addition.  Not to delete elements with the value 0 || '' || false || null - the loop filter becomes true (the filter is not valid) if the expression in the iterator header is absent. <br><br>  And the third - multiline partner in retexp for the first parameter (the name of the array or object) is replaced with a single line (". +").  This leads to a slight acceleration of parsing (3% by measurement). <br><br>  4. Added the ability to write inline single-level (multi-line) hashes, as can be seen in the example on <a href="http://jsfiddle.net/spmbt/6KU9Y/2/">jsfiddle</a> .  It is possible to write inline arrays (in an iterator over objects), as seen in the same example. <br><br><h3>  Speed ‚Äã‚Äãcomparison </h3><br>  <b>How much will we pay for the execution time for including in the template engine the possibility of looping over objects?</b> <br><br>  The answer to the question will be given by the test, which lies in the doT.js project on Github.  It will need to be rewritten, because it measures the speeds of the compiled templates, and the difference in compilation speeds is primarily of interest.  For simplicity, we will consider <u>tests in Chrome</u> (version 30).  On other browsers, they are easy to repeat and draw similar conclusions and comparisons. <br><br>  It was originally made for comparing strongly shortened doU.js and full doT.js, and shows how much slower the executable part of the full function doT.compile () is compared to the much shorter one.  It also proves that using ‚Äúit‚Äù instead of this makes almost no difference on long patterns, so the tests are replete with lines of measurements of various simple variants.  The template, the speed of which is measured, looks like this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Just static text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>\ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Here is a simple {{=it.f1}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>\ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>test {{=it.f2}}\ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{=it.f3}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>\ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{!it.f4}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>\ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Or its modifications, or repetition many times (32-128-256).  We are interested in these tests to show that an extra check on the iterator header did not slow down the work of simple templates. <br><br>  For our purposes, we are also interested in cycle tests.  In order for their speed to be approximately equal to the speed of simple templates, the following test template was written (it is without line breaks): <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Text from hash<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>\ {{@it::i}} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{=i}}: {{=it[i]}} : <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {{@}}\ {{@it:val:i}} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{=i}}: {{=val}} : <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {{@}}\ {{@it:a}} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>{{=a}}: {{=a}} : <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {{@}}\ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  For testing in the old doT.js template engine of version 1.0.1, the characters "@" were replaced with "~".  The same - for testing by arrays - in the new.  And the data was used for one case - hashes, for another - arrays with the same number of elements.  According to the results at the bottom of the diagram we will see which of them is faster. <br><br>  It will be of interest both uncompressed (doT11.js) and compressed (doT11m.js) new version.  To pass the tests, the doT variable in each version had to be made unique.  The pictures show the test speed diagrams (the number of calculations per second): more is faster, and therefore better.  The first picture is the result (attention) of the <u>compiled</u> templates.  Therefore, they are so fast - 500-700 K per second, and the difference between the minified version and the uncompressed version does not have the meaning that we want to see.  On the other hand, this test shows how much slower the full cycle (lines ‚Äú5. doT.js‚Äù, 6, 7) compared with the compilation results (the higher the indicator, the better). <br><br><img src="http://habrastorage.org/storage3/ced/5bd/2b3/ced5bd2b38fa45b15cf710a73b1c18fd.png"><br><br>  The results show that the template compilation time takes a huge share of the total time - from 99% for short templates to 90% for long ones (more than 10KB), and for a reloaded browser - 92% and 75% under the same conditions.  This is a fee for implicit eval (), which must be performed during de-template. <br><br>  By numbers it can be seen that the minified code is 1-1.5% faster.  And the execution of compiled templates, in theory, should not depend on minification at all.  Dependence - or the manifestation of random errors, or compilation errors of functions, or errors of the measuring tool. <br><br><div class="spoiler">  <b class="spoiler_title">The same test for Firefox 25</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage3/541/5f9/a9b/5415f9a9bbdaec156ad301abf5424b19.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">The same test for IE 8 (8 times slower than Chrome)</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage3/1d1/183/df0/1d1183df06bed3d42fdba6c9c5db3e61.png"></div></div><br><br>  Separate attention deserves a comparison of 2 types of cycles.  As it was supposed, the array loop works faster on almost the same templates, but with slightly different data.  The difference is 20% for short templates, 25% for templates of medium length (2-5 KB with the number of cycles up to 300 in the template).  With 100 or more cycles, an interesting effect appears in Chrome, apparently related to the number of variables in the compiled function.  The performance of the cycle on objects remains at the usual level, and the cycles on arrays suddenly begin to sink sharply with an increase in the number of cycles (and variables) in the pattern.  For example, at 190 cycles, the pattern test becomes 10% slower, and at 750 cycles, it almost stops at all - 6% of the pattern speed for objects. <br><br>  The following figure illustrates the beginning of the collapse of loops over arrays on long patterns with the number of loops 386 (the higher the indicator, the better). <br><img src="http://habrastorage.org/storage3/8d8/b4b/e33/8d8b4be337532b426461cd5cbe1ca984.png"><br><br>  An interesting question is whether there is a collapse threshold for a loop on objects?  Yes.  Increasing the volume of the test pattern by a factor of 2 (up to 512 copies of the short pattern), we get the browser to hang on iterating through the array and every 10 times lower speed of the cycles on the objects.  (Perhaps, in this mode, something is not optimized and some stack overflows. Or so the test script used in this project, which, besides standardization, does thousands more and hundreds of thousands of tests, affects it, and it could also Something "to flow. In the meantime, we conclude that the limit on the number of cycles in a template and in JS functions in general is. It is better not to do more than 1000 cycles on objects in one template (for Chrome).) <br><br>  The effect of a general slowdown of the template engine operation with the open browser operation time and measurements in it has also been noticed.  At the same time, the speed of work on arrays starts to look not so much higher than the speed of objects. <br><br><h3>  Pattern Interpretation Rates </h3><br>  The initial interest in the question of speeds was in the speed of <u>interpreting an</u> iterator on objects.  The fact that the compiled template for the array is faster - have already figured out.  But developers are often interested in not compiling templates, but in their interpretation, even if it is 10-100 times slower than the execution stage.  After all, if you need to render a page in 30 ms, you usually don‚Äôt think about compiling for subsequent rendering in 3 ms.  We will do tests to interpret our templates using the same function and data stubs.  This is where the minification template template will play its role - in the first series of measurements it did not matter. <br><br>  In the existing tests there is also a separate page for a separate compilation (without execution).  We transform the tests on it into complete ones by adding the pattern drawing execution.  This, in practice, will not change the picture, but will give realistic tests, more similar to practical tasks. <br><br>  Run the <b>doT / benchmarks / compileBench.html file</b> . <br><br>  This group of tests showed everything that interested us: <br>  1) the minified code shows stable acceleration for single short templates - by 5%; <br>  2) for the same, but uncompressed functions, short patterns demonstrate a slowdown compared with the old code in tests with measurement cycles, by 4%; <br>  3) for long patterns, the new code is always steadily faster by 3%; <br><br><img src="http://habrastorage.org/storage3/616/c70/9fc/616c709fc7c2525ed7af81438acf40ea.png"><br><br>  Intuitively, it seemed that the comparison would show a slowdown of 10%, especially where it is necessary to parse the arrays - the work on regexp passes along the pattern increases by about so much.  Changes show compliance with these assumptions, but not so significant.  Firstly, it is compensated for by improving the array pattern without losing properties (". *"), Secondly, the pattern has become slower on short patterns by 4% (for all, not just arrays), but the difference disappears for long ones - in this and is the expected slowdown. <br><br>  A separate group are measurements on other templates, with cycles (the last 3 measurements).  The third is the pattern by arrays in the old code.  It had to be slightly corrected so that there were no implicit variables ("~ it: val: i", and not "@it :: i").  Perhaps that is why it is a little slower, 10% in short patterns.  Other features are visible: <br><br>  4) Interpreter on objects slower than interpreter on arrays by 3-5%; <br>  5) the performance of both of them was faster relative to other dimensions, and interpretation was 2-3 times slower;  the longer the pattern, the slower; <br>  6) the old code by arrays is not faster than the new code by objects - faster by the indicated 3-5% only the new code by arrays.  (This effect is obtained by a small rewrite of the compilation code - using "++" instead of "+ = 1".) <br>  7) the speed of work of templates and speed of work on arrays noticeably (at times) depends on the browser reload.  Arrays are faster than cycles for objects by 20% at the beginning and by 5% after some time of the test page.  Perhaps this is not only the effect of the function, but also the influence of the testing environment (tested in Chrome 32bit, Win). <br><br>  We received answers to the question whether the code had become worse.  In general, it does not require further improvements to make its work look like the work of the old code.  Replacing the old with the new in existing projects is possible.  Even if the question includes the speed of compilation or execution. <br><br>  <b>Once again, it doesn‚Äôt bother to remind</b> : interpretation (see tests) is much slower than the execution of compiled templates.  If speed is important in the project and there is more than one template execution, use a separate compilation (doT.compile ()). <br><br><h3>  Hackney template further? </h3><br>  If the described solution is well suited for cautious extension of functions as nothing that changes for the old code, only adding a new iterator, then for new projects you can use the option in which the loop over the while arrays is replaced with the universal for-in loop, and the loop over the array filter expression added.  Two types of iterator are combined into one, and the speed of parsing practically does not suffer, as well as the speed of the cycle.  There may be side effects, so a replacement with the second option would be a good idea to test in an existing project to determine if there would be any abnormal situations with erroneous templates.  The cycles change, which means that the side effects of errors change. <br><br>  For a for-in loop over an array for some older browsers, you need to ensure that the iterator only works on numeric indexes and does not capture the length property in the iteration.  The requirement is perfectly fulfilled by the existing loop filtering mechanism, so it only remains to write a valid check if the object turned out to be an array.  Such a check will not be superfluous for collections of type arguments or attributes.  And certainly not superfluous - for objects that inherit the properties of the array.  Array-based objects will by default be iterated only by numeric indices. <br><br>  However, this is a slightly different task.  In this article we will limit ourselves to the cautious extension made, which is tested and works on one project. <br><br><h3>  results </h3><br>  The addition of the doT.js template maker to the possibility of iteration over objects, made in order to obtain an extension that does not violate the other properties of the existing version, is investigated. <br>  Got: <br>  1) an iteration in the template by objects ({{@ ...}}) with the ability to filter a part of the elements by any condition; <br>  2) the possibility not to specify unused parameters and colons at the end of the iterator header; <br>  3) for the array iterator, a similar opportunity has been added not to specify parameters in the array iterator header; <br>  4) there is no loss of speed in the work of the template engine compared to the old version (there is a slight loss on the short templates); <br> 5)   ‚Äî  250  ,       ; <br> 6)      ‚Äî  3%     ( + ). <br><br>  .     ‚Äî   ¬´global¬ª  ¬´doT¬ª,    .       1.0.1   ,      ,   (doT     ). <br><br>  <a href="https://github.com/spmbt/doT">  GitHub</a> ; <a href="http://jsfiddle.net/spmbt/6KU9Y/2/">jsFiddle  </a> . </div><p>Source: <a href="https://habr.com/ru/post/201592/">https://habr.com/ru/post/201592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201578/index.html">How to make a contribution to Kickstarter, get the goods + pick up your money? The story of one deception</a></li>
<li><a href="../201582/index.html">UrlEye.com is a free website control service.</a></li>
<li><a href="../201586/index.html">Installing the latest version of Firebird on Ubuntu</a></li>
<li><a href="../201588/index.html">Counts for the smallest: Ford & Bellman or how to understand that you got into the infinitely distant past</a></li>
<li><a href="../201590/index.html">The tragedy of communities in the real world or coupon fever-2</a></li>
<li><a href="../201594/index.html">Profiling and Debugging Python</a></li>
<li><a href="../201596/index.html">From idea to App Store in 24 hours</a></li>
<li><a href="../201598/index.html">Experience creating a cross-platform game (iOS / Android)</a></li>
<li><a href="../201600/index.html">jBone. Replacing jQuery for Backbone or 2kb for DOM manipulation</a></li>
<li><a href="../201602/index.html">Remote DOS exploit (device reboot) iOS ~ 6.1 - 7.0.3 [0day]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>