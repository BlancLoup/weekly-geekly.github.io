<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel Software Guard Extensions Extensions Tutorial. Part 6, two branches of code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the sixth part of the Intel Software Guard Extensions (Intel SGX) series of tutorials, we temporarily set the enclave aside to tackle the other req...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel Software Guard Extensions Extensions Tutorial. Part 6, two branches of code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d97/d65/513/d97d65513fd34c58b88f25d3f795e499.jpg"><br><br>  In the sixth part of the <a href="https://software.intel.com/en-us/sgx">Intel Software Guard Extensions</a> (Intel SGX) series of tutorials, we temporarily set the enclave aside to tackle the other requirement that we set out <a href="https://habrahabr.ru/company/intel/blog/317510/">in the second part</a> (draft application): we will dedicate this series to supporting the two code branches .  Our Tutorial Password Manager application needs to work on PCs with and without Intel SGX support.  Most of the content of this material is taken from the article <a href="https://software.intel.com/en-us/articles/properly-detecting-intel-software-guard-extensions-in-your-applications">Proper detection of Intel Software Guard Extensions extensions in applications</a> . <br><br>  Source code is provided with this part of the series. <br><a name="habracut"></a><br><h2>  <font color="#0071c5">All applications using the Intel Software Guard Extensions must contain two code branches.</font> </h2><br>  First of all, it is important to emphasize that all applications using Intel SGX must contain two code branches.  Even if the application is written in such a way that it should be executed <i>only</i> if the Intel SGX extensions are available and enabled, the application should have a spare code branch that displays a clear error message to the user and the application closes correctly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In short, the <i>application should not crash and refuse only because the application does not support Intel SGX</i> . <br><br><h2>  <font color="#0071c5">Identify the problem</font> </h2><br>  In the <a href="https://habrahabr.ru/company/intel/blog/320030/">fifth part of</a> this series, we created the first version of the enclave of the application and tested it, rigidly including support for the enclave in the code.  To do this, we set the <i>_supports_sgx</i> flag in the PasswordCoreNative.cpp file. <br><br><pre><code class="cpp hljs">PasswordManagerCoreNative::PasswordManagerCoreNative(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { _supports_sgx= <span class="hljs-number"><span class="hljs-number">1</span></span>; adsize= <span class="hljs-number"><span class="hljs-number">0</span></span>; accountdata= <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; timer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Of course, this flag should not be enabled by default.  The ideology of the detection of components is as follows: by default, all components are disabled, and upon detection, they are enabled.  Therefore, the first thing to do is to return the value 0 to this flag and thereby disable the Intel SGX code branch. <br><br><pre> <code class="cpp hljs">PasswordManagerCoreNative::PasswordManagerCoreNative(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { _supports_sgx= <span class="hljs-number"><span class="hljs-number">0</span></span>; adsize= <span class="hljs-number"><span class="hljs-number">0</span></span>; accountdata= <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; timer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre><br>  However, before proceeding with the detection of components, we will arrange for a console application that runs our test suite, the CLI Test App, a brief functional test: we will run it on a system that does not support Intel SGX.  If you set this flag to zero, the application will not use the branch of the Intel SGX code and should work fine. <br><br>  Here is the result obtained on a laptop with a fourth-generation Intel Core i7 processor running the 64-bit version of Microsoft Windows * 8.1.  This system does not support Intel SGX. <br><br><img src="https://habrastorage.org/files/5ff/7b5/ee9/5ff7b5ee9aa741c2b652e958d0176251.png"><br><br><h2>  <font color="#0071c5">What happened?</font> </h2><br>  There is a problem, although the code branch with Intel SGX is explicitly disabled in the program.  This application, in the form in which it is written, does not work on a system that does not support Intel SGX.  It did not even start to run.  What is the matter? <br><br>  The necessary hint gives us an error message in the console window. <br><br> <code>System.IO.FileNotFoundException: Could not load file or assembly 'PasswordManagerCore.dll' or one of its dependencies. The specified file could not be found.</code> <br> <br>  Consider the PasswordManagerCore.dll library and its dependencies. <br><br><img src="https://habrastorage.org/files/020/bd2/29b/020bd229b82847179567ede9f4639688.png"><br><br>  In addition to the main OS libraries, dependencies include bcrypt.lib and EnclaveBridge.lib, which will require the bcrypt.dll and EnclaveBridge.dll libraries at runtime.  Since the bcrypt.dll library is supplied by Microsoft and is included with the OS, we can assume that its dependencies, if any, have already been installed.  Remains EnclaveBridge.dll. <br><br>  Consider the dependencies of this library.  Here is what we see. <br><br><img src="https://habrastorage.org/files/2e0/1ab/098/2e01ab0982a04c8398b42d674161b769.png"><br><br>  This is the problem.  Although we have explicitly disabled the Intel SGX code branch, EnclaveBridge.dll still refers to the Intel SGX runtime libraries.  All characters in the object module must be resolved immediately after it is loaded.  Disabling the Intel SGX code branch does not matter: there are still undefined characters in the DLL. <br><br>  When loading PasswordManagerCore.dll, this library resolves undefined characters by loading bcrypt.dll and EnclaveBridge.dll, the latter of these two libraries, in turn, tries to resolve its undefined files by downloading sgx_urts.dll and sgx_uae_service.dll.  In the system where we tried to start the test application, these libraries are missing, and since the OS cannot resolve all these characters, it throws an exception, and the program crashes before it starts. <br><br>  These two DLLs are part of the Intel SGX Platform Software (PSW) package.  Without them, it is impossible to run Intel SGX applications written using the Intel SGX Software Development Kit (SDK).  Our application should work even in the absence of these libraries. <br><br><h2>  <font color="#0071c5">Platform software package</font> </h2><br>  As mentioned above, runtime libraries are part of the PSW package.  The PSW package, in addition to these support libraries, includes the following. <br><br><ul><li>  Services supporting and servicing the trusted computing unit (TCB) in the system </li><li>  Services that perform certain Intel SGX operations (for example, certification) and manage them </li><li>  Interfaces to platform services, such as trusted time services and monotonous counters. </li></ul><br>  The PSW package must be installed by the application installer when deploying the Intel SGX application, since the PSW package is not available for direct download to end users.  Software developers should not rely on this package being installed on a target system.  Moreover, the <a href="https://software.intel.com/en-us/articles/intel-sgx-product-licensing">Intel SGX License Agreement</a> specifically states that licensees themselves must distribute PSW along with their applications. <br><br>  We will discuss the PSW installer in more detail in one of the next releases in this series on packaging and deployment. <br><br><h2>  <font color="#0071c5">Detection of support for Intel Software Guard Extensions extensions</font> </h2><br>  So far, we have dealt only with the problem of launching our application on systems that do not support Intel SGX, and more specifically on systems without the PSW package.  The next step is to determine after the launch of the application whether Intel SGX extensions are supported and enabled. <br><br>  Finding an Intel SGX component, unfortunately, is not a simple task.  The system supports Intel SGX if the following four conditions are met. <br><br><ol><li>  CPU must support Intel SGX. </li><li>  The BIOS must support Intel SGX. </li><li>  In the BIOS, the Intel SGX extensions must either be explicitly enabled or set to the "software control" state. </li><li>  The platform must have the PSW package installed. </li></ol><br>  Note that the CPUID instruction alone is not enough to determine whether the platform supports Intel SGX.  This instruction can only determine if the CPU supports the Intel SGX extensions, but cannot determine the BIOS configuration and software installed on the system.  If you rely solely on the results of the CPUID instruction when making decisions about supporting Intel SGX, then the program may fail. <br><br>  The definition of components is further complicated by the fact that analyzing the state of the BIOS is a nontrivial task, which, as a rule, cannot be accomplished from the user process.  Fortunately, the Intel SGX SDK provides a simple solution: the <i>sgx_enable_device</i> function checks for the presence of the Intel SGX extensions and attempts to enable them if software controls these extensions are selected in the BIOS (software control aims to allow applications to enable Intel SGX without restarting the computer and run BIOS setup: not the safest and most frightening procedure, if users are not too technically savvy). <br><br>  <i>There</i> is only one problem with the <i>sgx_enable_device</i> function: this function is part of the Intel SGX runtime, therefore, the PSW package must be installed on the system to use it.  Therefore, before calling the <i>sgx_enable_device</i> function, <i>you</i> need to determine the presence of the PSW package. <br><br><h2>  <font color="#0071c5">Implementation</font> </h2><br>  We decided on the area of ‚Äã‚Äãproblems that need to be solved, so now we can make a list of actions necessary for our application with two branches of code to work properly.  This is what our application should do. <br><br><ol><li>  Download and start execution even without the Intel SGX runtime libraries. </li><li>  Determine whether the PSW package is installed. </li><li>  Determine whether Intel SGX extensions are enabled (and try to enable them). </li></ol><br><h2>  <font color="#0071c5">Download and run without Intel Software Guard Extensions runtime</font> </h2><br>  Our main application depends on the PasswordManagerCore.dll library, which depends on the EnclaveBridge.dll library, which, in turn, depends on the Intel SGX runtime.  Since you need to allow all characters when loading an application, you need to somehow make sure that the bootloader does not try to resolve characters coming from the Intel SGX runtime libraries.  Two options are available. <br><br><h3>  <font color="#0071c5">Option 1. Dynamic loading</font> </h3><br>  With dynamic loading, there is no explicit library layout in the project.  Instead, system calls are used to load the library at run time, then the names of each function are planned to be used to obtain the addresses at which they were placed in memory.  After that, the functions contained in the library are invoked indirectly using pointers. <br><br>  The method of dynamic loading can not be called simple and convenient.  Even if only a few functions are needed, it may take a lot of effort to create prototypes of pointers for each desired function and get their download addresses one by one.  It also loses some of the benefits provided by the integrated development environment (for example, assistance in creating prototypes), since you no longer call functions explicitly by name. <br><br>  Dynamic loading is commonly used in applications with an extensible architecture (for example, plug-ins). <br><br><h3>  <font color="#0071c5">Option 2. Delayed loading of DLL libraries</font> </h3><br>  In this case, all the libraries are dynamically linked in the project, but Windows receives the command to postpone the loading of the problematic DLL libraries.  When deferred loading of Windows DLLs does not attempt to resolve the characters defined by the library, when you run the application.  Instead, the system waits for the first program call to the function defined in the library.  It is at this point that the library is loaded, and the symbol is resolved (along with all its dependencies).  This essentially means that the library does not load until the application needs it.  The advantage of this approach is that applications can refer to libraries that are not installed in the system, if the functions contained in these libraries are not called. <br><br>  We find ourselves in precisely such a situation when the flag of the Intel SGX component is disabled, so we use option number 2. <br><br>  The delayed loading of the DLL library is specified in the project configuration for the dependent application or library.  For Tutorial Password Manager, it is best to use deferred download for EnclaveBridge.dll, since we only call this library when the Intel SGX code branch is enabled.  If this library does not load, the two Intel SGX runtime libraries will not be loaded either. <br><br>  The corresponding parameter is configured on the Linker ‚Üí Input page in the configuration window of the PasswordManagerCore.dll project. <br><br><img src="https://habrastorage.org/files/13a/eee/22d/13aeee22d1a64e60893bcf620bc63aa0.png"><br><br>  After re-assembling and installing the library on a system with a fourth-generation Intel Core processor, the console test application starts working as desired. <br><br><img src="https://habrastorage.org/files/02d/d55/bb1/02dd55bb1ba04863b35193bc3673affb.png"><br><br><h2>  <font color="#0071c5">Platform Software Package Discovery</font> </h2><br>  Before calling the <i>sgx_enable_device</i> function to verify that platform-level support for Intel SGX is available, you must ensure that the PSW package is installed on the system, since the <i>sgx_enable_device</i> function is part of the Intel SGX runtime.  For this, it is best to try to load runtime libraries. <br><br>  From the previous step, we know that we cannot simply dynamically assemble them: this will lead to an error when trying to start the program if the system does not support Intel SGX (or if the PSW package is not installed).  But you cannot use the deferred loading of libraries: with this method of loading it is impossible to determine whether the library is installed, because, if it is absent, the application will fail.  This means that you need to use dynamic loading to check for runtime libraries. <br><br>  PSW runtime libraries must be installed in the Windows system folder, so we will use <i>GetSystemDirectory</i> to get this path, and to limit the scope of the library search, use the <i>SetDllDirectory</i> call.  Finally, to load these libraries, we use the <i>LoadLibrary</i> function.  If any of these calls fail, we will know that the PSW package is not installed and that the main application should not attempt to run a branch of the Intel SGX code. <br><br>  Detect and enable Intel Software Guard Extensions extensions. <br><br>  Since the PSW runtime libraries were dynamically loaded in the previous step, it is now enough to manually find the sgx_enable_device symbol and call it using a function pointer.  As a result, we will know if support for Intel SGX extensions is included. <br><br><h2>  <font color="#0071c5">Implementation</font> </h2><br>  To implement these features in the Tutorial Password Manager application, we will create a new library, FeatureSupport.dll.  This library can be dynamically safely linked with the main application, since it does not have explicit dependencies on other libraries. <br><br>  Component detection will be implemented in a C ++ / CLI class called FeatureSupport.  This class will also contain some high-level features for more information on the state of the Intel SGX.  In rare cases, a program reboot may be required to enable Intel SGX programmatically, and in even more rare cases, a software enable may not work, so users will need to explicitly enable Intel SGX support in the BIOS. <br><br>  The class declaration for FeatureSupport is shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sgx_status_t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SGXAPI *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">fp_sgx_enable_device_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sgx_device_status_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureSupport</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: UINT sgx_support; HINSTANCE h_urts, h_service; <span class="hljs-comment"><span class="hljs-comment">// Function pointers fp_sgx_enable_device_t fp_sgx_enable_device; int is_psw_installed(void); void check_sgx_support(void); void load_functions(void); public: FeatureSupport(); ~FeatureSupport(); UINT get_sgx_support(void); int is_enabled(void); int is_supported(void); int reboot_required(void); int bios_enable_required(void); // Wrappers around SGX functions sgx_status_t enable_device(sgx_device_status_t *device_status); };</span></span></code> </pre><br>  Here are the low-level procedures that check for the presence of the PSW package and are trying to detect and enable Intel SGX. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FeatureSupport::is_psw_installed() { _TCHAR *systemdir; UINT rv, sz; <span class="hljs-comment"><span class="hljs-comment">// Get the system directory path. Start by finding out how much space we need // to hold it. sz = GetSystemDirectory(NULL, 0); if (sz == 0) return 0; systemdir = new _TCHAR[sz + 1]; rv = GetSystemDirectory(systemdir, sz); if (rv == 0 || rv &gt; sz) return 0; // Set our DLL search path to just the System directory so we don't accidentally // load the DLLs from an untrusted path. if (SetDllDirectory(systemdir) == 0) { delete systemdir; return 0; } delete systemdir; // No longer need this // Need to be able to load both of these DLLs from the System directory. if ((h_service = LoadLibrary(_T("sgx_uae_service.dll"))) == NULL) { return 0; } if ((h_urts = LoadLibrary(_T("sgx_urts.dll"))) == NULL) { FreeLibrary(h_service); h_service = NULL; return 0; } load_functions(); return 1; } void FeatureSupport::check_sgx_support() { sgx_device_status_t sgx_device_status; if (sgx_support != SGX_SUPPORT_UNKNOWN) return; sgx_support = SGX_SUPPORT_NO; // Check for the PSW if (!is_psw_installed()) return; sgx_support = SGX_SUPPORT_YES; // Try to enable SGX if (this-&gt;enable_device(&amp;sgx_device_status) != SGX_SUCCESS) return; // If SGX isn't enabled yet, perform the software opt-in/enable. if (sgx_device_status != SGX_ENABLED) { switch (sgx_device_status) { case SGX_DISABLED_REBOOT_REQUIRED: // A reboot is required. sgx_support |= SGX_SUPPORT_REBOOT_REQUIRED; break; case SGX_DISABLED_LEGACY_OS: // BIOS enabling is required sgx_support |= SGX_SUPPORT_ENABLE_REQUIRED; break; } return; } sgx_support |= SGX_SUPPORT_ENABLED; } void FeatureSupport::load_functions() { fp_sgx_enable_device = (fp_sgx_enable_device_t)GetProcAddress(h_service, "sgx_enable_device"); } // Wrappers around SDK functions so the user doesn't have to mess with dynamic loading by hand. sgx_status_t FeatureSupport::enable_device(sgx_device_status_t *device_status) { check_sgx_support(); if (fp_sgx_enable_device == NULL) { return SGX_ERROR_UNEXPECTED; } return fp_sgx_enable_device(device_status); }</span></span></code> </pre> <br><br><h2>  <font color="#0071c5">Summarizing</font> </h2><br>  With the code changes described, we embedded the detection of Intel SGX components in our application.  Now the application will work correctly both on systems with Intel SGX support and without Intel SGX, choosing the appropriate code branch. <br><br>  As mentioned above, this section provides sample code for download. <br><br>  The included archive includes the source code for the Tutorial Password Manager application kernel, including a new library for discovering components.  In addition, we added a new GUI test program that automatically selects a branch of the Intel SGX code, but allows you to disable this branch if necessary (only available if the system supports Intel SGX). <br><br><img src="https://habrastorage.org/files/493/eb9/1bd/493eb91bd9184404b62a108803411cd0.png"><br><br>  The console test program has also been updated to detect Intel SGX, although it is not possible in this program to configure disabling the leg of the Intel SGX code without changing the source code. <br><br><h2>  <font color="#0071c5">In further releases</font> </h2><br>  In the seventh part, we will return to working with the enclave for further refinement of the interface.  Follow the news! <br><br>  <a href="https://software.intel.com/protected-download/676750/700434">The downloads are</a> available under the terms of the license agreement Intel Software Export Warning. </div><p>Source: <a href="https://habr.com/ru/post/323626/">https://habr.com/ru/post/323626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323616/index.html">A preliminary DUMP program is ready. Speakers from Dropbox, JetBrains, Mozilla, Mail.Ru, Yandex, Rambler & Co</a></li>
<li><a href="../323618/index.html">PostgreSQL data change audit</a></li>
<li><a href="../323620/index.html">Where the games go: the problem of preserving old video games. Part 2</a></li>
<li><a href="../323622/index.html">Developing the mechanics of the game Bounce from Nokia JavaScript</a></li>
<li><a href="../323624/index.html">Memory models underlying programming languages</a></li>
<li><a href="../323628/index.html">Testing Conference Heisenbag: Video recordings of reports-2016 and work on the bugs in 2017</a></li>
<li><a href="../323630/index.html">Videos: February TechLeads Mitap at Badoo</a></li>
<li><a href="../323632/index.html">How to optimize a site on Magento</a></li>
<li><a href="../323634/index.html">Stacker: what's new?</a></li>
<li><a href="../323636/index.html">Top 10 errors in open projects With ++ for 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>