<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive application without Redux / NgRx</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will examine in detail the reactive angular application ( repository on github ), written entirely on the OnPush strategy. Another applicatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive application without Redux / NgRx</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/d4/ck/od/d4ckodq4-ei9nntgvweinv65mdu.jpeg"><br><br>  Today we will examine in detail the reactive angular application ( <a href="https://github.com/fshchudlo/forms-and-state">repository on github</a> ), written entirely on the <a href="https://www.toptal.com/angular/angular-change-detection">OnPush</a> strategy.  Another application uses reactive forms, which is quite typical for an enterprise application. <br><br>  We will not use Flux, Redux, NgRx and instead take advantage of the capabilities already available in Typescript, Angular and RxJS.  The fact is that these tools are not a silver bullet and can add unnecessary complexity even to simple applications.  We are honestly warned about this by <a href="https://github.com/petehunt/react-howto">one of the Flux authors</a> , the <a href="https://medium.com/%40dan_abramov/you-might-not-need-redux-be46360cf367">author Redux</a> and the <a href="https://www.youtube.com/watch%3Ftime_continue%3D1587%26v%3DN15ie0cGuB0">author NgRx</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But these tools give our applications very nice features: <br><br><ul><li>  Predictable data flow; </li><li>  Support OnPush by design; </li><li>  The immutability of data, the lack of accumulated side effect and other pleasant things. </li></ul><br>  We will try to get the same characteristics, but without introducing additional complexity. <br><br>  As you will see by the end of the article, this is a fairly simple task - if you remove the details of the work of Angular and OnPush from the article, then only a few simple ideas remain. <br><a name="habracut"></a><br>  The article does not offer a new universal pattern, but only shares with the reader several ideas that, for all their simplicity, for some reason did not occur at once.  Also, the developed solution does not contradict and does not replace Flux / Redux / NgRx.  They can be connected if this <a href="https://blog.angular-university.io/angular-2-redux-ngrx-rxjs/">really becomes necessary</a> . <br><br>  <i>For a comfortable reading of the article, an understanding of the terms <a href="https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/">smart, presentational and container components is</a> needed.</i> <br><br><h2>  Action plan </h2><br>  The logic of the application, as well as the sequence of presentation of the material can be described in the following steps: <br><br><ol><li>  <a href="https://habr.com/ru/company/true_engineering/blog/426819/">Separate read (GET) and write (PUT / POST) data</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/426819/">Load state as a stream in container component</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/426819/">Distribute State across the hierarchy to OnPush components</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/426819/">Report Angular on component changes.</a> </li><li>  <a href="https://habr.com/ru/company/true_engineering/blog/426819/">Edit encapsulated data</a> </li></ol><br>  To implement OnPush, we need to parse all the ways to launch change detection in Angular.  There are only four such methods, and we will consistently consider them in the course of the article. <br><br>  So let's go. <br><br><a name="backend"></a><h2>  Separate read and write data </h2><br>  For the interaction of the frontend and backend applications, typically typed contracts are used (otherwise why are typescript?). <br><br>  The demo project we are considering does not have a real backend, but it contains the previously prepared description file <a href="https://swagger.io/">swagger.json</a> .  On its basis, typescript contracts are generated by the <a href="https://github.com/mstssk/sw2dts">sw2dts</a> utility. <br><br>  The generated contracts have two important properties. <br><br>  First, reading and writing are performed using different contracts.  We use a small agreement and name reading contracts with the suffix ‚ÄúState‚Äù, and write contracts with the suffix ‚ÄúModel‚Äù. <br><br>  By sharing contracts in this way, we share the flow of data in the application.  From top to bottom, the read-only state extends across the component hierarchy.  To change the data, a model is created, which is initially filled with data from the state, but exists as a separate object.  After editing is completed, the model is sent to the backend as a command. <br><br>  The second important point is that all State fields are marked with the readonly modifier.  This is how we get support for typescript immunity.  Now we can not accidentally change the state in the code or bind to it using [(ngModel)] - when we compile the application in the AOT mode, we get an error. <br><br><a name="container"></a><h2>  Load state as a stream in container component </h2><br>  To load and initialize the state, we will use ordinary angular services.  They will be responsible for the following scenarios: <br><br><ul><li>  A classic example is downloading via HttpClient using the id parameter received by the component from the router. </li><li>  Initializing an empty state when creating a new entity.  For example, if the fields have default values ‚Äã‚Äãor for initialization, you need to request additional data from the backend. </li><li>  Reloading an already loaded state after a user performs an operation that changes data on the backend. </li><li>  Reset state by push notification, for example, when editing data together.  In this case, the service is merging the local state and the state obtained from the backend. </li></ul><br>  In the demo application, we consider the first two scenarios as the most typical.  Also, these scenarios are simple and will allow the service to be implemented as simple stateless objects and not be distracted by complexity that is not the subject of this particular article. <br><br>  An example of a service can be found in the file <a href="">some-entity.service.ts</a> . <br><br>  It remains to get the service via DI in the container component and load the state.  This is usually done like this: <br><br><pre><code class="plaintext hljs">route.params .pipe( pluck('id'), filter((id: any) =&gt; { return !!id; }), switchMap((id: string) =&gt; { return myFormService.get(id); }) ) .subscribe(state =&gt; { this.state = state; });</code> </pre> <br>  But with this approach, two problems arise: <br><br><ul><li>  You must unsubscribe manually from the created subscription, otherwise a memory leak will occur. </li><li>  If you switch a component to the OnPush strategy, it will stop responding to data loading. </li></ul><br>  <a href="https://toddmotto.com/angular-ngif-async-pipe">Async pipe</a> comes to the rescue.  He listens to the Observable directly and will write off from him when necessary.  Also, when using async, pipe Angular automatically launches a change detection each time the Observable publishes a new value. <br><br>  An example of using an async pipe can be found in the template of the <a href="">some entity entity of the component</a> . <br><br>  And in the component code, we carried the repeated logic into custom RxJS operators, added a script for creating an empty state, merging both sources of State into one stream with the merge operator, and creating a form for editing, which we will consider later: <br><br><pre> <code class="plaintext hljs">this.state$ = merge( route.params.pipe( switchIfNotEmpty("id", (requestId: string) =&gt; requestService.get(requestId) ) ), route.params.pipe( switchIfEmpty("id", () =&gt; requestService.getEmptyState()) ) ).pipe( tap(state =&gt; { this.form = new SomeEntityFormGroup(state); }) );</code> </pre><br>  This is all that was required to do in the container component.  And we put in the piggy bank the first way to trigger change detection in the OnPush component - async pipe.  It is useful to us more than once. <br><br><a name="presentation"></a><h2>  Distribute State across the hierarchy to OnPush components </h2><br>  When we need to display a complex state, we create a hierarchy of small components - this is how we struggle with complexity. <br><br>  As a rule, components are divided into a hierarchy similar to a data hierarchy, and each component receives its own piece of data through Input-parameters to display them in a template. <br><br>  Once we are going to implement all the components as OnPush, let's digress for a while and discuss what it is and how Angular works with OnPush components.  If you already know this material - feel free to scroll to the end of the section. <br><br>  During compilation of the application, Angular generates for each component a special change detector class that ‚Äúremembers‚Äù all the bindings used in the component template.  At runtime, the created class starts checking the saved expressions at each change detection cycle.  If the check shows that the result of any expression has changed, then Angular will redraw the component. <br><br>  By default, Angular knows nothing about our components and cannot determine which components will be affected, for example, by the newly triggered setTimeout or the completed AJAX request.  Therefore, he is forced to check the entire application completely literally for every event inside the application - even a simple window scroll repeatedly launches the change detection for the entire hierarchy of application components. <br><br>  Here lies the potential source of performance problems ‚Äî the more complex the component templates, the harder the change detector checks.  And if there are a lot of components and the checks are run frequently, then the change detection begins to take considerable time. <br><br>  What to do? <br><br>  If a component does not depend on any global effects (by the way, it is better to design components like this), then its internal state is determined by: <br><br><ul><li>  Input parameters ( <a href="https://angular.io/api/core/Input">@Input</a> ); </li><li>  Events that occurred in the component itself ( <a href="https://angular.io/api/core/Output">@Output</a> ). </li></ul><br>  Let us put aside the second point for now and assume that the state of our component depends only on the input parameters. <br><br>  If all Input parameters of the component are immutable objects, then we can mark the component as OnPush.  Then, before launching change detection, Angular will check if the references to the Input parameters of the component have changed since the last check.  And, if they have not changed, Angular will skip the change detection for the component itself and all its child components. <br><br>  Thus, if we build our entire application using the OnPush strategy, we will eliminate a whole class of performance problems from the very beginning. <br><br>  Since the State in our application is already immutable, immutable objects are also passed to the Input parameters of the child components.  That is, we are already ready to enable OnPush for child components and they will react to state changes. <br>  For example, these are components of <a href="">readonly-info.component</a> and <a href="">nested-items.component</a> <br><br>  Now let's see how to implement a change in the component's own state in the OnPush paradigm. <br><br><a name="output"></a><h2>  Speak with Angular about your condition </h2><br>  Presentation state is the parameters that are responsible for the appearance of the component: loading indicators, flags of the visibility of elements or the availability to the user of an action, glued together from three fields into one line of the user's full name, etc. <br><br>  Every time the presentation state of the component changes, we must notify Angular so that it can display the changes on the UI. <br><br>  Depending on what is the source of the component state, there are several ways to notify Angular. <br><br><h4>  Presentation state, calculated on the basis of Input-parameters </h4><br>  This is the easiest option.  We place the logic of computing the presentation state in the ngOnChanges hook.  Change detection will start by changing the @ Input-parameters.  In the demo application it is <a href="">readonly-info.component</a> . <br><br><pre> <code class="plaintext hljs">export class ReadOnlyInfoComponent implements OnChanges { @Input() public state: Backend.SomeEntityState; public traits: ReadonlyInfoTraits; public ngOnChanges(changes: { state: SimpleChange }): void { this.traits = new ReadonlyInfoTraits(changes.state.currentValue); } }</code> </pre><br>  Everything is extremely simple, but there is one point that should be paid attention to. <br><br>  If the presentation state of a component is complex, and especially if some of its fields are calculated on the basis of others, also calculated by Input-parameters, take the state of the component into a separate class, make it immutable and re-create each time ngOnChanges is started.  In the demo project, an example is the class <a href="">ReadonlyInfoComponentTraits</a> .  Using this approach, you protect yourself from having to synchronize dependent data when it changes. <br><br>  At the same time, it is worth thinking: perhaps the component has a complex state due to the fact that it contains too much logic.  A typical example is an attempt to accommodate views for different users in one component, which have very different ways of working with the system. <br><br><h4>  Component's own events </h4><br>  For communication between application components, we use Output-events.  This is also the third way to launch change detection.  Angular reasonably assumes that if a component generates an event, then something could change in its state.  Therefore, Angular listens to all Output-events of components and launches change detection when they occur. <br><br>  The demo project is completely synthetic, but the example is the component <a href="">submit-button.component</a> , which throws the <i>formSaved</i> event.  The container component subscribes to this event and displays an alert with a notification. <br><br>  Use Output-events should be as intended, that is, to create them for communication with the parent components, and not to launch change detection.  Otherwise, there is a possibility, after months and years, not to remember why this event is not needed by anyone, and remove it, breaking everything. <br><br><h4>  Changes in smart components </h4><br>  Sometimes the state of a component is determined by complex logic: an asynchronous call to a service, a connection to a web socket, checks running via setInterval, and there is little else.  Such components are called smart components. <br><br>  In general, the smaller the application will be smart components, which in this case are not container components - the easier it will be to live.  But sometimes you can not do without them. <br><br>  The easiest way to associate the state of a smart component with change detection is to turn it into an Observable and use the <a href="https://toddmotto.com/angular-ngif-async-pipe">async pipe</a> already discussed above.  For example, if the source of change is a service call or a reactive form status, then this is already a ready Observable.  If the state is formed from something more complex, you can use <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">fromPromise</a> , <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">websocket</a> , <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">timer</a> , <a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html">interval</a> from the composition of the RxJS.  Or generate the stream yourself using <a href="http://reactivex.io/rxjs/class/es6/Subject.js~Subject.html">Subject</a> . <br><br><h4>  If none of the options fit </h4><br>  In cases where none of the three methods already studied is suitable, we are left with a bulletproof option - use <a href="https://angular.io/api/core/ChangeDetectorRef">ChangeDetectorRef</a> directly.  We are talking about the detectChanges and markForCheck methods of this class. <br><br>  Documentation is comprehensive answers to all questions, so we will not dwell on his work.  But note that the use of <a href="https://angular.io/api/core/ChangeDetectorRef">ChangeDetectorRef</a> should be limited to cases where you clearly understand what you are doing, as this is still an Angular internal kitchen. <br><br>  For all the time we have found only a few cases where this method may be needed: <br><br><ol><li>  Manual work with change detection is used when implementing low-level components and is just the case ‚Äúyou clearly understand what you are doing‚Äù. </li><li>  Complicated relationships between components ‚Äî for example, when you need to create a link to a component in a template and pass it as a parameter to another component that is higher in the hierarchy or even in another branch of the component hierarchy.  Sounds hard?  And there is.  And it‚Äôs better to simply code this code, because it will deliver pain not only with change detection. </li><li>  Specific behavior of Angular itself - for example, when implementing a custom <a href="https://blog.angularindepth.com/never-again-be-confused-when-implementing-controlvalueaccessor-in-angular-forms-93b9eee9ee83">ControlValueAccessor,</a> you may encounter that the change in the value of the control <a href="https://github.com/angular/angular/issues/10816">is performed by the Angular asynchronously</a> and the changes are not applied to the desired change detection cycle. </li></ol><br>  As examples of use in a demo application, there is a base class <a href="">OnPushControlValueAccessor</a> , which solves the problem described in the last paragraph.  Also in the project there is an inheritor of this class - a custom <a href="">radio-button.component</a> . <br><br>  Now we have discussed all four ways to launch change detection and OnPush implementation options for all three component types: container, smart, presentational.  We proceed to the final point - data editing with reactive forms. <br><br><a name="form"></a><h2>  Edit encapsulated data </h2><br>  Reactive forms have a number of limitations, but still this is one of the best things that happened in the Angular ecosystem. <br><br>  First of all, they well encapsulate work with the state and provide all the necessary tools to respond to changes in a reactive manner. <br><br>  In fact, the reactive form is a sort of mini-store that encapsulates work with the state: data and disabled / valid / pending statuses. <br><br>  It remains for us to support this encapsulation as much as possible and to avoid mixing the presentation logic and the logic of the form operation. <br><br>  In the demo application, you can see <a href="">individual classes of forms</a> that encapsulate all the specifics of their work: validation, creation of FormGroup children, working with the disabled state of input fields. <br><br>  We create the root form in the container component at the time of loading the state and each time the state is restarted, the form is created anew.  This is not a prerequisite, but so we can be sure that there are no accumulated effects in the logic of the form remaining from the previous loaded state. <br><br>  Inside the form itself, we construct controls and ‚Äúpush‚Äù the received data on them, converting them from the State contract to the Model contract.  The structure of the forms, as far as possible, coincides with the contracts of the models.  As a result, the value property of the form gives us a ready model for sending to the backend. <br><br>  If the state or model structure changes in the future, we will get a typescript compilation error in exactly the place where we need to add / remove fields, which is very convenient. <br><br>  Also, if the state and model objects have an absolutely identical structure, then the structural typing used in typescript saves us from having to build meaningless mapping of one into another. <br><br>  So, the logic of the form is isolated from the presentation logic in the components and lives ‚Äúby itself‚Äù, without increasing the complexity of the data flow of our application as a whole. <br><br>  This is almost all.  Border cases remain when we cannot isolate the logic of the form from the rest of the application: <br><br><ol><li>  Changes in shape that change the presentation state ‚Äî for example, the visibility of a data block depending on the value entered.  We implement in the component by subscribing to form events.  You can do this through the immutable traits discussed earlier. </li><li>  If you need an asynchronous validator that calls a backend, in the component we construct AsyncValidatorFn and pass it to the form designer, not the service. </li></ol><br>  Thus, the entire "borderline" logic remains in the most prominent place - in the components. <br><br><h2>  findings </h2><br>  Let's summarize what we got and what else there are moments for studying and development. <br><br>  First of all, the development of the OnPush strategy forces us to thoughtfully design the data flow of the application, since now we dictate the rules of the game to Angular, and not to us. <br><br>  The consequences of this situation are two. <br><br>  First, we get a pleasant feeling of control over the application.  There is no more magic that ‚Äúworks somehow‚Äù.  You clearly understand what is happening at any time in your application.  Intuition is gradually developing, which allows you to understand the cause of the found bug, even before you opened the code. <br><br>  Secondly, now we have to spend more time designing an application, but the result will always be the most ‚Äúdirect‚Äù, which means the simplest solution.  This clearly brings to zero the likelihood of a situation when, as it grows, the application turned into a monster of immense complexity, developers lost control of this complexity and the development now looks more like mystical rites. <br><br>  Controlled complexity and the absence of ‚Äúmagic‚Äù reduce the likelihood of a whole class of problems arising, for example, with cyclical data updates or accumulated side effects.  Instead, we deal with noticeable problems already in development, when the application simply does not work.  And perforce it is necessary to make the application work simply and clearly. <br><br>  We also mentioned the good consequences for performance.  Now, using very simple tools, such as <a href="https://blog.angularindepth.com/everything-you-need-to-know-about-debugging-angular-applications-d308ed8a51b4">profiler.timeChangeDetection</a> , we can check at any time that our application is still in good shape. <br><br>  Also now it's a sin not to try <a href="https://blog.angularindepth.com/do-you-still-think-that-ngzone-zone-js-is-required-for-change-detection-in-angular-16f7a575afef">disabling NgZone</a> .  First, it will allow you not to load the whole library when the application starts.  Secondly, it will remove a fair amount of magic from your application. <br><br>  On this we end our narration. <br><br>  We will be in touch! </div><p>Source: <a href="https://habr.com/ru/post/426819/">https://habr.com/ru/post/426819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426809/index.html">Zeev Suraski: The Future of Zend Engine and Zend Framework</a></li>
<li><a href="../426811/index.html">Parkour, dance and construction work from Boston Dynamics</a></li>
<li><a href="../426813/index.html">? Skype has turned into a sad likeness ... and a product that allows you to get full access to your system? Is there any hope?</a></li>
<li><a href="../426815/index.html">How to get a grant for the development of the project, if you are a poor student? And is it worth it</a></li>
<li><a href="../426817/index.html">CommuniGate Pro, Private Keys and Web API</a></li>
<li><a href="../426821/index.html">How to organize a CI / CD on a project: from setting tasks to setting up a deployment pipeline</a></li>
<li><a href="../426825/index.html">A few tips for freelancers</a></li>
<li><a href="../426827/index.html">Mobile operators have bothered to secret communication</a></li>
<li><a href="../426831/index.html">Unpleasant conversation, herpetologist and complete surprise</a></li>
<li><a href="../426835/index.html">Comparative and detailed analysis of caching plugins for WordPress</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>