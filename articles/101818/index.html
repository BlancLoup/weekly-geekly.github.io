<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cartesian wood: Part 1. Description, operations, applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (for now) 
 Part 1. Description, operation, application. 
 Part 2. Valuable information in the tree and multiple operations with it....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cartesian wood: Part 1. Description, operations, applications</h1><div class="post__text post__text-html js-mediator-article"><h4>  Table of Contents (for now) </h4><br>  <b>Part 1. Description, operation, application.</b> <br>  <a href="http://habrahabr.ru/post/102006/">Part 2. Valuable information in the tree and multiple operations with it.</a> <br>  <a href="http://habrahabr.ru/post/102364/">Part 3. The Cartesian tree by implicit key.</a> <br>  <em>To be continued ...</em> <br><br>  <strong>The Cartesian tree</strong> (cartesian tree, treap) is a beautiful and easily implemented data structure that allows you to perform many high-speed operations on arrays of your data with minimal effort.  That is characteristic, on Habrakhabr I found its only mention in the <a href="http://habrahabr.ru/post/66926/">review post of the</a> highly respected <a href="https://habrahabr.ru/users/winger/" class="user_link">winger</a> , but then the continuation of that cycle never followed.  It's a shame by the way. <br><br>  I will try to cover everything that I know about the topic - despite the fact that I know relatively not so much, there will be enough material for two, or even three.  All algorithms are illustrated with source codes in C # (and since I am a lover of functional programming, somewhere in the epilogue, it will come to F # as well - but it is not necessary to read this :).  So let's get started. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Introduction </h4><br>  As an introduction, I recommend reading the <a href="http://habrahabr.ru/post/65617/">post about binary search trees of</a> the same <a href="https://habrahabr.ru/users/winger/" class="user_link">winger</a> , because without understanding what a tree is, the search tree, as well as without knowing the <a href="http://habrahabr.ru/post/78728/">estimates of the complexity of the algorithm,</a> much of the material in this article will remain for you in Chinese writing.  It's a shame, right? <br><br>  The next item on our mandatory program is a <strong>heap</strong> .  I think many well-known data structures, but I still give a brief overview. <br>  Imagine a binary tree with some data (keys) in the vertices.  And for each vertex we necessarily demand the following: her key is strictly greater than the keys of her immediate sons.  Here is a small example of a valid heap: <br><img src="https://habrastorage.org/storage/habraeffect/f4/8e/f48e012bd2babdc5d90dd98fd7b880b6.png"><br><br><blockquote>  I will immediately say to a note that it is absolutely not necessary to think about the heap solely as a structure whose parent has <em>more</em> than its descendants.  Nobody forbids to take the opposite option and assume that the parent is <em>smaller than the</em> descendants - the main thing is to choose one for the whole tree.  For the needs of this article it will be much more convenient to use the option with the ‚Äúmore‚Äù sign. <br></blockquote><br>  Now the question remains how to add and remove items from it in a heap.  Firstly, these algorithms require a separate place for inspection, and secondly, we still will not need them. <br><a name="habracut"></a><br><h4>  Problems </h4><br>  When it comes to search trees (you have already read the recommended article, right?), The main question that is posed to the structure is the speed of operations, regardless of the data stored in it, and the sequence of their receipt.  Thus, a binary search tree guarantees that a search for a specific key in this tree will be done in O (H), where <strong>H</strong> is the height of the tree.  But what could be the height - the devil knows.  Under unfavorable circumstances, the height of a tree can easily become <strong>N</strong> (the number of elements in it), and then the search tree degenerates into a regular list - and why is it then needed?  To achieve this situation, it is enough to add elements from 1 to N in the ascending queue to the search tree - with the standard addition algorithm to the tree, we get the following picture: <br><img src="https://habrastorage.org/storage/habraeffect/2c/f5/2cf582dd0b73a4015d084a8587e27f7e.png"><br>  A huge number of so-called balanced search trees were invented - roughly speaking, in which, as the tree exists, each operation on it maintains the optimality of the maximum depth of the tree.  The optimal depth is of the order O (log <sub>2</sub> N) - then the same order has the execution time of each search in the tree.  The data structures supporting such depth are many, the most famous here is a red-ebony or AVL-tree.  Their distinctive feature in the majority is a difficult implementation, based on the size of the damn pile of cases in which you can get confused.  Its simplicity and beauty favorably differ, on the contrary, the Cartesian tree, and even gives us that logarithmic time in some way, but only with rather high probability ... however, about such details and subtleties later. <br><br><h4>  Definition </h4><br>  So, we have the tree data ‚Äî the <b>x</b> keys (hereinafter, the key is assumed to be the same information that we store in the tree; when later we need to separate user information from the keys, I‚Äôll say a little).  Let's add to them another parameter in the pair - <b>y</b> , and call it a <em>priority</em> .  Now we will build such a magic tree, which stores at each vertex two parameters, and at the same time <i>the keys are the search tree, and the priorities are the heap</i> .  Such a tree will be called Cartesian. <br><br><blockquote>  By the way: in English literature the name <em>treap is</em> very popular, which clearly shows the essence of the structure: tree + heap.  In the Russian-speaking language, it is sometimes possible to find those composed according to the same principle: <em>deramid</em> (tree + pyramid) or <em>ducha</em> (tree + heap). <br></blockquote><br>  Why is a tree called Cartesian?  This will immediately become clear as soon as we try to draw it.  Take a set of key-priority pairs and place the corresponding points (x, y) on the coordinate grid.  And then we connect the corresponding vertices with lines, forming a tree.  Thus, the Cartesian tree fits perfectly on the plane due to its limitations, and its two main parameters, the key and the priority, are, in a sense, coordinates.  The result of the construction is shown in the figure: on the left in the standard tree notation, on the right - on the Cartesian plane. <br><img src="https://habrastorage.org/storage/habraeffect/a1/0a/a10a744def8f325a1019502ecc175ef6.png"><br><br>  So far it is not very clear why this is necessary.  And the solution is simple, and it lies in the following statements.  First, let a set of keys be given: there are many different ones that can be constructed from the correct search trees, including the list-like ones.  But after adding priorities to them, a tree from these keys can be built only one single thing, regardless of the order in which the keys arrive.  This is pretty obvious. <br>  And secondly, let's now make our priorities random.  That is, we simply associate with each key a random number from a sufficiently large range, and it will serve as the corresponding player.  Then the resulting Cartesian tree with a very high, tending to 100% probability will have a height not exceeding 4 log <sub>2</sub> N. (I will leave this fact here without proof.) So, although it may not be perfectly balanced, the search time for the key is such a tree will still be of the order of O (log <sub>2</sub> N), which we, in fact, achieved. <br><br><blockquote>  Another interesting approach is not to make priorities random, but to recall that we have a huge amount of some additional user information, which, as a rule, we have to store in the treetops.  If there is reason to believe that this information is inherently quite random (the user's birthday, for example), then you can try to use it for personal gain.  Take as a priority either directly information, or the result of some function from it (only then the function must be reversible in order to restore information from priorities, if necessary).  However, it is necessary to act here at your own peril and risk - if after a while the tree becomes strongly unbalanced and the whole program begins to be significantly slowed down, you will have to immediately tinker with something to save the situation. <br></blockquote><blockquote>  Further, for simplicity, we assume that all keys and all priorities in trees are different.  In fact, the possibility of key equality does not create any particular problems; you just need to clearly define where elements equal to a given x will be located - either <em>only</em> in its left subtree, or <em>only</em> in the right one.  Equality of priorities in theory is also not a particular problem, except for contamination of evidence and reasoning with special cases, but in practice it is better to avoid it.  Random generation of integer priorities is quite suitable in most cases, real between 0 and 1 - in almost all cases. <br></blockquote><br>  Before starting the story about operations, I‚Äôll give you a class C # preset that will implement our Cartesian tree. <br><blockquote><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Treap</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Treap Left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Treap Right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Treap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, Treap left = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Treap right = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Right = right; } <span class="hljs-comment"><span class="hljs-comment">//   ... }</span></span></code> </pre> </blockquote><br><blockquote>  For simplicity, I made x and y of <code>int</code> type, but it is clear that in their place there could be any type, the instances of which we can compare with each other - that is, anyone implementing <code>IComparable</code> or <code>IComparable&lt;T&gt;</code> in terms of C #.  In Haskell, it could be any type from the <code>Ord</code> class, in F # any with restrictions on the comparison operator, in Java it implements the <code>Comparable&lt;T1&gt;</code> interface, and so on. <br></blockquote><br><h4>  Magic glue and scissors </h4><br>  On the agenda of pressing issues - how to work with Cartesian wood.  The question of how to build it from a raw set of keys in general, I will postpone a bit, but for now let's assume that some kind soul has already built the initial tree for us, and now we need to change it if necessary. <br><br>  All the ins and outs of the Cartesian wood work consists of two main operations: <strong>Merge</strong> and <strong>Split</strong> .  With the help of them all other popular operations are elementarily expressed, so let's start with the basics. <br><br>  Operation Merge takes as input two Cartesian trees <strong>L</strong> and <strong>R.</strong>  It is required from it to merge them into one, also correct, Cartesian tree <strong>T.</strong>  It should be noted that operation Merge can work not with any pairs of trees, but only with those for which all keys of one tree (L) do not exceed the keys of the second (R).  (Pay special attention to this condition - it will be useful to us again and again in the future!) <br><img src="https://habrastorage.org/storage/habraeffect/28/2e/282eb999908e6a2102d654a685f6483a.png"><br><br>  The Merge algorithm is very simple.  Which element will become the root of the future tree?  Obviously, with the highest priority.  We have two candidates for maximum priority - only the roots of two source trees.  Let's compare their priorities;  let for unambiguity the priority y of the left root is greater, and the key in it is equal to x.  The new root is defined, now it is worth thinking what elements will appear in its right subtree, and which - in the left one. <br><br>  It is easy to understand that the whole tree R will be in the right subtree of the new root, because the keys have more than x by condition.  Similarly, the left subtree of the old root L.Left has all the keys smaller than x, and the left subtree should remain, and the right L.Tight subtree should be right for the same reasons, but it‚Äôs not clear where to put its elements and where are the elements of the tree R? <br><br>  Wait, why is it unclear?  We have two trees, the keys in one are fewer keys in the other, and we need to somehow combine them and attach the result to the new root as the right subtree.  Simply recursively call Merge for L.Right and tree R, and use the tree returned by it as a new right subtree.  The result is obvious. <br><br>  The figure in blue shows the right subtree of the result tree after the Merge operation and the connection from the new root to this subtree. <br><img src="https://habrastorage.org/storage/habraeffect/a9/8f/a98f52fd388745ea9be4b4681f780880.png"><br>  The symmetric case - when the priority in the root of the tree R is higher - is dealt with similarly.  And, of course, we must not forget about the basis of recursion, which in our case occurs if one of the trees L and R, or both at once, are empty. <br><br>  Merge source code: <blockquote><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Treap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Merge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Treap L, Treap R</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (L == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ly &gt; Ry) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newR = Merge(L.Right, R); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(Lx, Ly, L.Left, newR); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newL = Merge(L, R.Left); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(Rx, Ry, newL, R.Right); } }</code> </pre></blockquote><br><br>  Now about the operation Split.  The input is a valid Cartesian tree T and a key <strong>x <sub>0</sub></strong> .  The task of the operation is to divide the tree into two so that in one of them (L) all elements of the source tree with keys smaller than x <sub>0 are found</sub> , and in the other (R) - with large ones.  There are no special restrictions on the tree. <br><img src="https://habrastorage.org/storage/habraeffect/4c/bd/4cbde2feb466d25a36d4296ffb745450.png"><br><br>  We argue in a similar way.  Where is the root of the tree T?  If its key is less than x <sub>0</sub> , then in L, otherwise in R. Again, suppose for the sake of unambiguity that the key of the root was less than x <sub>0</sub> . <br><br>  Then you can immediately say that all elements of the left subtree of T will also appear in L - their keys, too, will all be less than x <sub>0</sub> .  Moreover, the root T will also be the root L, since its priority is greatest in the whole tree.  The left subtree of the root will remain completely unchanged, but the right one will decrease - you will have to remove elements with keys greater than x <sub>0</sub> from it and take it to the R tree. Save the rest of the keys as a new right subtree L. See the identical task again, recursion again suggests! <br><br>  Take the right subtree and recursively split it by the same key x <sub>0</sub> into two trees L 'and R'.  Then it becomes clear that L 'will become the new right subtree of the tree L, and R' is just the tree R - it consists of those and only those elements that are larger than x <sub>0</sub> . <br><img src="https://habrastorage.org/storage/habraeffect/35/27/35277f3277ac1bf837b7735f18066f58.png"><br>  The symmetric case in which the root key is greater than x <sub>0</sub> is also completely identical.  The basis of recursion here is when some of the subtrees are empty.  Well, the source code of the function: <br><blockquote><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Split</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Treap L, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Treap R</span></span></span><span class="hljs-function">)</span></span> { Treap newTree = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x &lt;= x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Right == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) R = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Right.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> R); L = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x, y, Left, newTree); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Left == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) L = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Left.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> L, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> newTree); R = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x, y, newTree, Right); } }</code> </pre></blockquote><br>  By the way, pay attention: the trees, which are output by the Split operation, are suitable as input data for the Merge operation: all the keys of the left tree do not exceed the keys on the right.  This valuable circumstance will come in handy in just a few paragraphs. <br><br>  The last question is the time of the Merge and Split.  From the description of the algorithm, it can be seen that for each iteration of the recursion Merge reduces the total height of two trees to be merged by at least one, so that the total operation time does not exceed 2H, that is, O (H).  And with Split, everything is quite simple - we work with a single tree, its height decreases with each iteration, too, by at least one, and the asymptotic behavior of the operation is also O (H).  And since the Cartesian tree with random priorities, as already mentioned, has a high probability close to the logarithmic height, the Merge and Split work for the desired O (log <sub>2</sub> N), and this gives us tremendous scope for their use. <br><br><h4>  Tree operations </h4><br>  Now, when you and I are perfectly fluent in glue and scissors, it is absolutely no work just with the help of them to implement the most necessary actions with the Cartesian tree: adding an element to the tree and removing it.  I will give the simplest version of their implementation, based <em>entirely</em> on Merge and Split.  It will work for all the same logarithmic time, however, as ACM Olympians say, will differ by a greater constant: that is, the order of time dependency on the size of the tree will still be O (log <sub>2</sub> N), but the <em>exact</em> work time will differ several times - in constant times.  Say, 4 log <sub>2</sub> N versus just log <sub>2</sub> N. In practice, this difference is hardly felt until the size of the tree reaches truly galactic sizes. <br><blockquote>  There are also optimal implementations of both add-ons with deletions and other necessary deramid operations, the constant of which is much smaller.  I will definitely bring these implementations in one of the following parts of the cycle, and also talk about the pitfalls associated with the use of a faster option.  Pitfalls are primarily associated with the need to support additional requests to the tree and store special information in it ... however, I won‚Äôt be bothering the reader with this, the time will come to multiple operations with the tree (an extremely important feature!). <br></blockquote><br>  So, let us be given a Cartesian tree and some element <strong>x</strong> that needs to be inserted into it (as we remember, in the context of the article it is assumed that all elements are different and there is no X in the tree yet).  I would like to apply the approach from the binary search tree: go down the keys, each time choosing a path left or right, until we find a place where we can insert our x, and add it.  But this decision is wrong, because we have forgotten about priorities.  The place where the search tree algorithm wants to add a new vertex uniquely satisfies the constraints of the search tree with respect to x, but may violate the heap constraint with y.  So you have to act a little higher and more abstract. <br><br>  The second solution is to present the new key as a tree from a single vertex (with a random priority y), and merge it with the original one with the help of Merge.  This is again wrong: in the source tree there may be vertices with keys greater than x, and then we break the promise given to the Merge function regarding the relationship between its input trees. <br><br>  The problem can be fixed.  Remembering the versatility of the Split / Merge operations, the solution is suggested almost immediately: <br><ol><li>  Divide (split) tree by key x into tree L, with keys less than X, and tree R, with large ones. </li><li>  Create a tree M from a single key from a single vertex (x, y), where y is a random priority just generated. </li><li>  Combine (merge) in turn L with M, then what happened - with R. </li></ol>  All steps of the algorithm can be illustrated. <br><img src="https://habrastorage.org/storage/habraeffect/d5/91/d591771892a5cf1fa80e71a91610e71f.png"><br>  We have 1 Split application here, and 2 Merge applications - total O (log <sub>2</sub> N) operation time.  Short source code is attached. <br><blockquote><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Treap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { Treap l, r; Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); Treap m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(x, rand.Next()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(Merge(l, m), r); }</code> </pre></blockquote><br><br>  There are no issues with deletion either.  Let us ask you to remove the element with the key x from the Cartesian tree.  Now I assume that you have dealt with the equality of keys, giving preference to the left side: in the right subtree of the vertex with the key x, other elements are not found with the same key, but in the left can.  Then perform the following sequence of actions: <br><ol><li>  Divide the tree first by key x-1.  All elements that are smaller or equal to x-1, went to the left result, then the desired element - in the right. </li><li>  We divide the right result by the key x (here it is worth being careful with equality!).  All elements with keys greater than x went to the new right result, and all smaller or equal to x went to the ‚Äúmiddle‚Äù (left from the right).  But since the strictly smaller ones after the first step were all sifted out, the middle tree is the desired element. </li><li>  Now simply combine the left tree with the right one, without the middle one, and the deramid is left without the x keys. </li></ol><br>  Now I understand why I constantly focused on how it is necessary to take into account the equality of keys.  Say, if your comparator thought that elements with equal keys should be sent to the right subtree, then in the first step you would have to divide by the key x, and in the second - by x + 1.  But if there were no specifics on this issue at all, then the deletion procedure in this variant could not even accomplish what was desired - after the second step, the middle tree would remain empty, and the desired element would slip away somewhere, either to the left or to the right, and look for him now. <br><img src="https://habrastorage.org/storage/habraeffect/b7/25/b72500a639cd03ed366994f2dbb44f05.png"><br>  The operation time is still O (log <sub>2</sub> N), since we applied Split 2 times and Merge 1 times. <br>  Source: <br><blockquote><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Treap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { Treap l, m, r; Split(x - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> l, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); r.Split(x, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> r); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Merge(l, r); }</code> </pre></blockquote><br><h4>  Act of creation </h4><br>  Now, knowing the algorithm for adding an element to a finished Cartesian tree, we can provide the simplest way to build a tree from an incoming set of keys: simply add them in turn by the standard algorithm, starting from a tree from one vertex - the first key.  Bearing in mind that the add operation is performed in logarithmic time, we get the total execution time of a full tree construction - O (N log <sub>2</sub> N). <br><br>  Interesting, but you can quickly? <br><br>  As it turned out, in some cases - yes.  Let's imagine that the keys to us come in ascending order.  This, in principle, may well happen if these are some kind of newly created identifiers with auto increment.  So, in this case, there is a simple algorithm for constructing a tree in O (N).  True, we will have to pay for this temporary overhead from memory: to store a reference to its ancestor for each vertex of the tree under construction (in fact, it is not even necessary for each, but these are subtleties). <br><br>  We will keep a link to the last added vertex in the tree.  In terms of compatibility, it will be right in it - after all, it has the key of the largest of all keys of the tree built at the moment.  Now suppose that the next key <strong>x</strong> arrives at the input with some priority <strong>y</strong> .  Where to put it? <br><br>  The last vertex is the rightmost, therefore it has no right son.  If its priority is greater than the y being added, then you can simply assign a new vertex to the right-hand son and move to the next key at the entrance with a clear conscience.  Otherwise, you have to think.  The new top still has the largest key, so ultimately it will definitely become the rightmost top of the tree.  Therefore, it does not make sense to look for a place to insert it anywhere, except along the rightmost branch.  We only need to find a place where the priority of the vertex is greater than y.  So, we will rise from the rightmost up the branch, each time checking the priority of the current top of the inspected.  In the end, we will either come to the root, or stop somewhere in the middle of the branch. <br><br>  Suppose we come to the root.  Then it turns out that y is greater than all the priorities in the tree.  We have no choice but to make (x, y) a new root and attach an old tree to it with our left son. <br><br>  If we did not reach the root, the situation is similar.  At some vertex of the right branch (x <sub>0</sub> , y <sub>0</sub> ) we have <nobr>y <sub>0</sub> &gt; y</nobr> .  And its immediate right descendant has a priority less than y.  To keep the search tree structure by keys, and make (x, y) the most right in the tree, we hang it as a new right son to <nobr>(x <sub>0</sub> , y <sub>0</sub> )</nobr> , and the entire old right subtree becomes the left subtree (x, y). <br><br>  To make it clearer, I will illustrate with examples.  Take a Cartesian tree and show what happens if you try to add certain vertices to it.  The key is the same everywhere (22), and the priority is vary. <br>  y = 4: <br><img src="https://habrastorage.org/storage/habraeffect/d4/14/d414a774067989e32d38caa3fc2c9273.png"><br>  y = 16: <br><img src="https://habrastorage.org/storage/habraeffect/c4/dc/c4dc34aa95aa3d188896b92e8c4de1a5.png"><br>  y = 11: <br><img src="https://habrastorage.org/storage/habraeffect/af/92/af92745b00f14d074aadb1de242011d9.png"><br><br>  Why does this algorithm work for O (N)?  Note that you will visit each tree peak a maximum of two times: <ul><li>  when it is directly added; </li><li>  perhaps by adding some other one, as long as it stays in the right branch.  Immediately after that, it will leave the right branch and will not be visited more. </li></ul>  Thus, the total number of transitions does not exceed 2N, and the asymptotic construction is O (N). <br><br>  For a snack - the source code for building a given array of keys and priorities.  Here it is assumed that each vertex of the tree has the <code>Parent</code> property, and also that an optional parameter with the same name is already used in the private vertex constructor (the fifth in a row). <br><blockquote><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Treap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] xs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] ys</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(xs.Length == ys.Length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(xs[<span class="hljs-number"><span class="hljs-number">0</span></span>], ys[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> last = tree; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; xs.Length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (last.y &gt; ys[i]) { last.Right = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(xs[i], ys[i], parent: last); last = last.Right; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Treap cur = last; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cur.Parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; cur.y &lt;= ys[i]) cur = cur.Parent; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.y &lt;= ys[i]) last = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(xs[i], ys[i], cur); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { last = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Treap(xs[i], ys[i], cur.Right, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, cur); cur.Right = last; } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (last.Parent != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) last = last.Parent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; }</code> </pre></blockquote><br><br><h4>  Summary </h4><br>  We have built a tree data structure with the following properties: <ul><li>  has almost guaranteed logarithmic height relative to the number of its vertices; </li><li>  allows for logarithmic time to search for any key in the tree, add it and delete it; </li><li>  the source code of all its methods does not exceed 20 lines, they are easily understood and it is extremely difficult to make mistakes in them </li><li>  contains some overhead memory, compared with the truly self-balancing trees, to store priorities. </li></ul><br>  In principle, the result is quite powerful.  However, some may still be unclear whether it was worth for him to fence such a large garden with such a bunch of text.  Worth it.  The point is that the possibilities of the Cartesian tree and the potential for its use are far from being limited to the functions described in this article.  This is only a preface. <br><br>  In the following parts: <ol><li>  Multiple operations on a Cartesian tree (looking for O (log <sub>2</sub> N) sum, maximum, etc.) </li><li>  Cartesian tree by implicit key (or how to improve a regular array) </li><li>  Accelerated implementations of Cartesian functions (and their problems) </li><li>  The functional implementation of the Cartesian tree on F #. </li></ol><br><h4>  Sources </h4><br>  Sources indicate once and for all, they are the same for all planned articles. <br><br>  First of all, when writing these articles, I base myself on Vital Goldstein's lecture told at the ACM ICPC Kharkiv Winter School on Programming in 2010.  It can be downloaded from the <a href="http://olimp.sc170.kharkov.ua/">school‚Äôs</a> video gallery (year 2010, day 2) as soon as it starts working again, because in the last few days the server has messed up something disastrous. <br><br>  Maxim's <a href="http://e-maxx.ru/">site</a> ‚Äúe-maxx‚Äù Ivanova is a rich storehouse of information on various algorithms and data structures used in sports programming.  In particular, there is on it and <a href="http://e-maxx.ru/algo/treap">an article about the Cartesian tree</a> . <br><br>  In the famous book Kormen, Leiserson, Rivest, Stein ‚ÄúAlgorithms: Construction and Analysis‚Äù you can find evidence that the expectation of the height of a random binary search tree is O (log <sub>2</sub> N), although its definition of a random search tree is different from what we used here. <br><br>  For the first time, deramids were proposed in an article by Seidel, Raimund;  Aragon, Cecilia R. (1996), <a href="http://people.ischool.berkeley.edu/~aragon/pubs/rst96.pdf">"Randomized Search Trees"</a> .  In principle, there you can find the full amount of information on the topic. <br><br>  That's all for now.  I hope you were interested :) </div><p>Source: <a href="https://habr.com/ru/post/101818/">https://habr.com/ru/post/101818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../101808/index.html">How I won the trial in Makhost</a></li>
<li><a href="../101809/index.html">A childless family of millionaires built an "intelligent" robot</a></li>
<li><a href="../101810/index.html">Writing Your OS: Release 1</a></li>
<li><a href="../101815/index.html">StarCraft 2 Review</a></li>
<li><a href="../101817/index.html">Prevent hidden Nmap scanning in Linux</a></li>
<li><a href="../101819/index.html">Accounting for Internet traffic tenants (netflow)</a></li>
<li><a href="../101821/index.html">Where are you going, software developer?</a></li>
<li><a href="../101823/index.html">Conflict of Master Password and Login Form</a></li>
<li><a href="../101824/index.html">Mainstream Social Media: The Tipping Point for Tumblr</a></li>
<li><a href="../101831/index.html">Quick Search Protection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>