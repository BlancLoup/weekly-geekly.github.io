<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Splitting a continuous data stream into structural units</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quite often a situation arises when it is necessary to transfer data blocks along a continuous stream. In this case, the question of how to separate o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Splitting a continuous data stream into structural units</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/71c/d25/a25/71cd25a25ce1e0bcc59aa519c718c69f.jpg"><br><br>  Quite often a situation arises when it is necessary to transfer data blocks along a continuous stream.  In this case, the question of how to separate one data block from another comes to the fore.  The second question is whether to transmit data in binary or text form.  Add to this the possibility of continuing work with small distortions (loss, garbage, errors of interacting nodes) and the need for effective utilization of the data transmission channel.  In this case, the problem should be solved on a simple microcontroller with limited resources. <br><br>  Such tasks arise, for example, when transmitting telemetry and for controlling remote equipment.  On the one hand, there is usually a simple microcontroller, on the other hand there is a computer.  Communication between them can be carried out by the old, good RS232.  Although it is more difficult, for example, the output of the UART microcontroller is converted to 802.11b, then the radio signal propagates to the radio tower and Ethernet comes to the server. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If my bike is interesting on this topic, welcome under cat. <br><a name="habracut"></a><br>  First of all, let's define the requirements: <br><br><ol><li>  The channel can be created at any time. </li><li>  Both the controller and the computer can be connected to the channel at an arbitrary point in time, including in the middle of the data packages. </li><li>  If a channel is corrupted, the corresponding data block must be discarded. </li><li>  On one channel can be multiple devices. </li><li>  Data blocks can contain any sequence of bytes and be of arbitrary length. </li><li>  Resources allocated to support the protocol are strictly limited. </li></ol><br><br>  It turns out the implementation is remotely resembling UDP. <br><br>  Let us consider several common methods using the example of transmitting three numbers of "voltages", as one block and two other numbers "temperature", as another block. <br><br>  Often there is a solution to this problem by translating all the sent data into a text view, and separating the blocks (packages) with a line feed. <br><br>  It might look like this: <br><br>  <b>V 1231, 2400, -231</b> <b><br></b>  <b>V 1333, 2100, -232</b> <b><br></b>  <b>T 36, -40</b> <br>  Use sprintf (buf, ‚ÄúV% d,% d‚Äù, ...). <br><br>  Transmission problem: sprintf uses a significant amount of stack, quite a long one. <br><br>  Acceptance problem: on the controller, converting the character set ‚Äú-232‚Äù to int requires additional resources.  No type control, 100,500 error checking conditions. <br><br>  As pluses - a person can see the transmitted parameters with the naked eye. <br><br>  If the project continues to evolve on this protocol, then after a while it will be impossible to maintain it and even the availability of human analysis will disappear. <br><br>  Partially, you can solve the problem by transferring not decimal digits, but hexadecimal ones - this will simplify processing, but it will not get rid of other problems. <br><br>  To improve control, you can wrap the transmitted data in XML: <br><pre><code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltages</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">num</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äù1‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>1231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">num</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äù1‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span> 2400<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">num</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äù1‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span> -231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">voltages</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Or you can wrap in JSON: <br><pre> <code class="javascript hljs">{ ‚ÄúVoltages‚Äù: [<span class="hljs-number"><span class="hljs-number">1231</span></span>, <span class="hljs-number"><span class="hljs-number">2400</span></span>, <span class="hljs-number"><span class="hljs-number">-231</span></span>] }</code> </pre><br>  The protocol will be documented.  But at the same time, there is still no type control at the compilation stage.  And the amount of additionally transmitted data becomes excessively large.  At the same time, there remains the problem of parsing numbers and text on limited resources. <br><br>  If one of the nodes continuously transmits something, then the moment of connecting the second node may fall in the middle of the transmitted data.  In most cases, it is impossible to reliably determine the beginning of a package on a freshly-included node, so you have to either wait for a line break or rely on luck.  In addition, there is no packet inspection for correctness (for example, due to a close thunderstorm, one bit was transmitted wrong).  These disadvantages can be solved using an approach close to the NMEA protocol: <br><br>  <b>$ GNVLT, 1231,2400, -231 * 71</b> <br><br>  Here the beginning of the packet is always $, the end of the packet is an asterisk and a CRC (0x71) of the packet data.  This is where the problem of package incorrectness is solved (the classic CRC is very simple here - XOR), but there are still problems in documenting and controlling the types of packages. <br>  It turns out that when using a text stream, there is a lot of overhead, there is little type control, there are difficulties in documenting. <br><br>  Consider data transfer in a binary way.  The sets of bytes will be transmitted, therefore it is necessary to define structures: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> supplyIn; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> supplyOut; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> groundPotential; }PackVoltages; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> internal; <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> outside; }PackTemperature;</code> </pre><br><br>  We have 6 bytes for voltages and 2 bytes for temperatures. <br><br>  You can combine these structures into one, add 5 more bytes there for further protocol expansion, enter the type of transmitted data in the structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { PackVoltages voltages; PackTemperature temperatures; }Data; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rezerv[<span class="hljs-number"><span class="hljs-number">5</span></span>]; }FullPack;</code> </pre><br><br>  We get a packet of 16 bytes (because of not obvious alignment), and not 12 as it might seem (in our example this is not a problem, but you should be careful when aligning).  You can include compiler options for dense packing bytes, but another problem may arise - some processors (on the ARM core) cannot read unaligned data and it is not so easy for novice Jedi to find this error. <br><br>  Further, the channel is always transmitted by 16 bytes.  The receiving party waits to receive the next 16 bytes and processes the next packet.  It is easy to see that there is no CRC.  Add CRC: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> type; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { PackVoltages voltages; PackTemperature temperatures; }Data; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rezerv[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> CRC; }FullPack;</code> </pre><br><br>  The packet size was 16 bytes.  When sending data, we need to put down the type of the package, calculate and add it to the CRC package, then send the received package. <br><br>  The advantages of this approach are that when processing packages, type checking appears during compilation.  No unnecessary conversion number - text and back.  The received portion of data is always the same size - it is convenient to allocate memory in advance. <br>  There are many shortcomings: there is an extra overhead of data transfer from small values ‚Äã‚Äãup to tens of times with significantly different lengths of transmitted data.  This synchronization method is well suited for client-server communication over a TCP channel ‚Äî nothing is lost along the way, the beginning of a packet is always known.  In the situation of connecting to the channel after initialization, a situation is possible when the first few bytes have not reached.  Then all received packets will be shifted by this number of bytes and the data in them will naturally be incorrect.  Well, if the CRC discards them, there will be no connection with the node.  And with a probability of 1/256, skips for ‚Äúbroken‚Äù packets are possible.  You can try to solve this problem by transferring a certain signature byte of the ‚Äúbeginning‚Äù of a packet, but, given that we are transmitting binary data, the same byte can also be found in the data itself.  Therefore, it is not always possible to reliably determine the beginning of a packet.  Another problem is the alignment of variables.  One byte is required for a packet header, 32-bit numbers can often be found in the data themselves, which will result in periodic data shifts of 0-2 bytes.  An annoying nuisance is that the CRC needs to be calculated "manually" when sending different types of packets. <br><br>  Another option is similar to the previous one, to reduce the overhead of transferring bytes at the beginning of the packet, its real length is transmitted.  The problem with this approach is that the packet must be fully calculated in advance (that is, placed in memory) and then transmitted.  This can be a difficult task on limited microcontroller resources, especially for large packets.  In addition, while the library does not receive the entire packet, the transmission cannot begin, which can adversely affect the bandwidth and latency of the channel.  Other disadvantages and advantages are similar to the previous version. <br><br>  And the last considered method, it is also used in my library.  The historical name is Bin Protocol or BIN Protocol. <br>  When sending binary data, they can be separated by a dedicated byte.  However, if this byte is found in the data, replace it with another sequence of bytes.  When receiving do the reverse procedure.  This method is called ‚Äúbyte stuffing‚Äù (thanks for the <a href="http://habrahabr.ru/users/flexz/" class="user_link">Flexz</a> name) <br>  Counting the CRC is also to entrust the transfer package. <br><br>  For various conversions to work, you must reserve three bytes.  It is best to choose them so that they are less likely to meet.  Rules for replacing bytes: <br>  <i>&lt;Splitting&gt; = &lt;Splitting&gt; &lt;Splitting&gt;</i> <i><br></i>  <i>&lt;Final&gt; = &lt;Splitting&gt; &lt;Optional&gt;</i> <i><br></i>  <i>&lt;Optional&gt; = &lt;Optional&gt;</i> <i><br></i> <br>  This shows that <i>&lt;Final&gt;</i> cannot be declared in the data stream in any way. <br>  You can create a package like this: <br>  <i>&lt;</i> <i>Split</i> <i>&gt;</i> <i>Protocol data</i> <i>&lt;Final&gt;</i> <br>  If you want increased reliability, you can create a package like this: <br>  <i>&lt;Final&gt; &lt;Splitting&gt; Protocol_Name &lt;Splitting&gt; &lt;Final&gt;</i> <br><br>  The second form increases the percentage of discarded spoiled small packages by about 15%, while adding overhead costs of the same 10-15%, so it will not be considered further. <br><br>  Thus, when receiving packets, even if we connected at an arbitrary point in time, it is enough to wait for the <i>&lt;Sharing&gt;</i> symbol to begin receiving a packet.  And only by receiving the &lt;Final&gt; byte, it is necessary to check the correctness of the packet and send it for processing. <br><br>  Now you can see what the "protocol data" consists of: <br><br>  Header: 1 byte - packet type, 1 byte destination address <br>  Data: the data itself, processed by the above rules <br>  CRC: 1 byte, also processed by the above rules. <br>  That is, you can send an arbitrary number of bytes, and they will be wrapped with markers of the beginning and end of the packet, the packet type, the destination address and the CRC are added to them. <br><br>  For our case, it will look like a definition of structures with data: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> supplyIn; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> supplyOut; <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> groundPotential; }PackVoltages; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> internal; <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> outside; }PackTemperature;</code> </pre><br><br>  And the knowledge that the first structure will be denoted by the symbol 'V', and the second 'T'.  These parameters will be transmitted through a function with 3 parameters - this is the type of the packet, the address of the beginning of the transmitted data and the length of the transmitted data. <br>  BP_SendMyPack ('T', &amp; packTemperature, sizeof (PackTemperature)); <br><br>  And in the transmission channel, there will be the following sequence: <br><br><img src="https://habrastorage.org/storage2/1cb/99a/50b/1cb99a50b5842e1d6819922c367ae7ee.png"><br><br>  On small packages, a large overhead projector is obtained, but as the size of the package grows, it becomes imperceptible. <br>  The real information transmitted is marked in gray, the necessary minimum of auxiliary information is necessary for white, and yellow is my binprotocol overhead. <br><br>  The advantages of this approach are that there is little overhead, arbitrary connection is not a problem, a good level of abstraction from data - you can use the same functions for sending and receiving on different devices, programs, protocols.  Good type control can be achieved at compile time.  The data itself can be aligned in the program in the correct way, and this will not add extra bytes when sending packets. <br><br>  Disadvantages: the type of the packet and the address of the packet cannot be equal to special characters and can take values ‚Äã‚Äãfrom 1 to 254. The CRC byte is only one and, as a result, there is 1/256 probability of missing a bad packet. <br><br>  When transferring parameters in binary form between different architectures, it is necessary to consider the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582">order of bytes</a> .  In case of differences, it is necessary to use conversion functions that replace the order of bytes to the reverse. <br><br>  As a working illustration of the protocol, a small QT program is attached.  At startup, the program opens a TCP socket and starts itself again with the connection parameters to this socket.  That is, two almost identical instances of the program are created that are interconnected by a TCP socket.  If necessary, you can start with the necessary keys to start the server or client of the program separately. <br><br>  Available keys: <br>  <b>-dedicated</b> - creates a server, displays connection parameters in the console. <br>  <b>-child</b> - connects by the specified attributes: <br>  <b>-A: 11.22.33.44</b> - ip connection address (default is localhost) <br>  <b>-P: 12345</b> - connection port <br>  Without keys - starts the server and client, and connects them. <br>  Program - translates user actions through a binary protocol into a socket, and also listens to the return channel and performs actions based on the received data. <br>  In the program, any mouse button on a black background draws an expanding circle before releasing the button.  Clicking on the top rainbow strip changes the current color.  It‚Äôs very fun to draw a couple with a baby from two different computers :) <br><br>  Explanations for working with a binary protocol. <br>  In the <b>MainWindow</b> class, all the interaction between the protocol and TCP connections is collected (instead of TCP, you could use anything else). <br><br>  In the constructor MainWindow :: MainWindow, the private function is called initBinProtocol ();  Which initializes the protocol.  In the same place, the address of the function on the ‚Äúbyte issue‚Äù globalSendCharToExternal () is transferred to the protocol.  Then the handler of signals arrival of characters in TCP socket is installed on ReadFromParent (), which as a result, character-by-character transfers all received bytes to the protocol handler. <br><br>  After the TCP connection to the connected session, another ReadFromChild () handler is hung, which similarly transfers all received bytes to the protocol handler. <br><br>  The <b>PackTypes.h</b> file contains all types of transmitted packets.  In fact, this is a description of the protocol.  The type TPackAllTypes is entered for convenience of processing on a computer; it is not necessary to use this type on a microcontroller. <br><br>  The <b>PaintBox</b> class contains the actual work with the protocol.  Packages from other instances of the program are checked once every 50ms by timer.  If desired, you can do the processing by receiving the last byte of the whole packet. <br><br>  Events are sent to the protocol at the moments when the mouse buttons are pressed and released, as well as when the ‚Äúclear‚Äù button is pressed through the <b>BP_SendMyPack ()</b> function.  At first the structure with binary values ‚Äã‚Äãof parameters is filled, then it is transferred.  To send a clear command, no data is required and all that is transmitted is a command byte. <br><br>  The PaintBox :: timerCheckPacks () function periodically checks for the presence of commands in the protocol buffer ( <b>BP_IsPackReceived ()</b> ) and their execution. <br><br>  The <b>Types.h</b> file contains definitions of similar basic types for cross-compilation by different compilers for different platforms, it may be necessary to edit it in your case. <br><br>  In general, the code is documented, so it's not hard to figure out. <br><br>  Links to github with library: <br><ul><li>  git: git@github.com: Elvish / microkern.git </li><li>  http: <a href="https://github.com/Elvish/microkern">https://github.com/Elvish/microkern</a> </li></ul><br><br>  Ps.  And how do you split the streams into pieces?  If you have questions, I will try to answer.  If you are interested in the topic - in the next article I can issue a simplified shell with an auto-add-on for the simplest controllers (an indispensable thing for debugging almost any small device). <br><br>  <b>UPD.</b> <br>  Another crushing method from <a href="http://habrahabr.ru/users/flexz/" class="user_link">Flexz</a> : <br>  The method used, for example, in the <a href="http://ru.wikipedia.org/wiki/Modbus">Modbus-RTU</a> protocol.  Packets are separated by ‚Äúsilence‚Äù intervals, the line is kept in an inactive state for the time required to transmit several characters.  In this case, it is not necessary to process each byte to disassemble byte stuffing, and you can use the DMA receiver, if it is available, of course. <br><br>  From the author: In my opinion time separation is possible on lightly loaded lines or at very accurate clocks.  In a situation where physical data transfer is difficult to monitor (for example, relaying over WiFi).  Packages can be combined with each other or split up arbitrarily.  Even some USB-RS232 adapters are wrong with this - they combine packets of 8 bytes each and as a result not all the hardware works through adapters. <br><br>  The presence of two different bytes of the beginning and end of the packet is associated with an increased protocol stability with heavy channel losses.  Initially, the protocol was developed when the transmission was conducted by ancient radio modems on mobile equipment in very poor visibility conditions.  With one byte, the protocol was more often mistaken when receiving the beginning of one packet (then the transmission failed) and the end of another packet. </div><p>Source: <a href="https://habr.com/ru/post/174115/">https://habr.com/ru/post/174115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../174097/index.html">Configurable authorization in Asp.Net MVC</a></li>
<li><a href="../174099/index.html">SharePoint 2013 Application Development with TypeScript</a></li>
<li><a href="../174103/index.html">Ruby on Rails Application Development in Visual Studio</a></li>
<li><a href="../174109/index.html">Writing a SOAP client in C ++ using gSOAP</a></li>
<li><a href="../174111/index.html">Setting up IPTV Beeline via WiFi using Mikrotik routers</a></li>
<li><a href="../174119/index.html">Accountology vs Accounting. The rules of computer accounting and the consequences of non-compliance</a></li>
<li><a href="../174121/index.html">Does NASA terminate all educational programs?</a></li>
<li><a href="../174123/index.html">RE: Is time travel possible?</a></li>
<li><a href="../174127/index.html">Screenshots of Windows Blue and IE 11 published</a></li>
<li><a href="../174133/index.html">LinkMeUp. Release 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>