<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fine Rust state machines</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Andrew Hobden "Pretty State Machine Patterns in Rust". Link to the original at the end. 


 Recently, I have been thinki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fine Rust state machines</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Translation of the article by Andrew Hobden "Pretty State Machine Patterns in Rust".</em>  <em>Link to the original at the end.</em> </p><br><p>  Recently, I have been thinking a lot about design patterns and techniques that we use in programming.  It‚Äôs really great to start exploring a project and seeing familiar patterns and styles that you‚Äôve already seen more than once.  This facilitates understanding of the project and makes it possible to speed up the work. </p><br><p>  Sometimes you work on a new project and you realize that you need to do something the same way you did in the past project.  It may not be part of the functionality or library, it may be something that cannot be wrapped in an elegant macro or a small container.  It may be just a design pattern or structural concept that solves a problem well. </p><br><p>  One interesting pattern that is often applied to such problems is the "State Machine".  I propose to spend a little time to understand what exactly is meant by this phrase, and why is it so interesting. </p><a name="habracut"></a><br><p>  Throughout the article you can run all the examples on the <a href="https://play.rust-lang.org/">Rust Playground</a> , I usually use the Nightly version out of habit. </p><br><h1 id="obosnovyvaem-nashi-idei">  Justify our ideas </h1><br><p>  On the Internet there are a huge amount of resources and thematic articles about state machines.  Moreover, there are many of their implementations. </p><br><p>  You used one of them, just to get to this page.  You can simulate the TCP protocol using a state machine.  You can also simulate HTTP requests with it.  You can model any <strong><em>regular</em></strong> language as a finite state machine, for example, a regular expression language (REGEX).  They are everywhere, hidden inside the things that we use every day. </p><br><p>  So, a finite state machine is any <strong>‚Äúautomaton‚Äù</strong> that has a set of <strong>‚Äústates‚Äù</strong> and <strong>‚Äútransitions‚Äù</strong> between them. </p><br><p>  When we speak of an automaton, we mean the abstract concept of <em>something doing something</em> .  For example, your function "Hello, world!"  - automatic.  It turns on and ultimately produces what we expect.  Also behave and the model with which you interact with your database.  We will consider our basic automaton as an ordinary structure that can be created and destroyed. </p><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Machine</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_machine = Machine; <span class="hljs-comment"><span class="hljs-comment">// . // `my_machine`  ,      . }</span></span></code> </pre> <br><p>  States are a way to explain where the state machine is located.  For example, we can imagine an automat filling a bottle.  This machine is in the "waiting" state when waiting for a new bottle.  As soon as he discovers the bottle, then goes into the "filling".  Immediately after filling the bottle with the right amount of water, the machine goes into the "completed" state.  He returns to the "waiting" state as soon as the bottle is taken. </p><br><p>  The main conclusion from this is that no state has any information that relates to other states.  The "fill" state does not care how long the machine has been in the "waiting" state.  The "completed" state does not care about the degree of filling of the bottles.  Each state has <em>strictly defined duties and problems</em> .  The natural way to consider these <em>options</em> is <code>enum</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BottleFillerState</span></span></span></span> { Waiting { waiting_time: std::time::Duration }, Filling { rate: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }, Done } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BottleFiller</span></span></span></span> { state: BottleFillerState }</code> </pre> <br><p>  Using <code>enum</code> in this way means that the states are mutually exclusive, you can only be in one state at a specific point in time.  Fat enums in Rust allow each state to store the necessary information in itself.  Until our definition is declared this way, everything is in order. </p><br><p>  But there is one small problem.  When we described our automaton above, we described three transitions between states: <code> ‚Üí </code> , <code> ‚Üí </code> and <code> ‚Üí </code> .  We did not take into account <code> ‚Üí </code> or <code> ‚Üí </code> , they simply do not make sense! </p><br><p>  This brings us to the idea of ‚Äã‚Äãtransitions.  One of the most enjoyable features of a true state machine is that we never have to take care of transitions such as <code> -&gt; </code> .  The state machine design pattern must <strong>ensure</strong> that such a transition is impossible.  Ideally, this will happen even before we launch our machine gun - at the time of compiling the program. </p><br><p>  Let's look at our transitions in the diagram again: </p><br><pre> <code class="hljs ruby"> +----------+ +------------+ +-----------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|  +--&gt;+  +--&gt;+  |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +----+-----+ +------------+ +--+--------+ ^ <span class="hljs-params"><span class="hljs-params">| +-----------------------------+</span></span></code> </pre> <br><p>  As we can see, there are a finite number of states, and a finite number of transitions between states.  At the moment, we can perfectly legally make transitions between each state to any other state, but in most cases this is not true. </p><br><p>  This means that the transition between the "Waiting" state and the "Filling" state must satisfy a certain rule.  In our example, this rule might look like "Bottle is in place."  In the case of a TCP stream, this will be "We received a FIN packet", which means that we need to complete the transfer by closing the stream. </p><br><h1 id="opredelyaem-chto-my-hotim">  Determine what we want </h1><br><p>  Now that we know what a state machine is, how do we implement it in Rust?  To begin with, let's think about what we <strong>want</strong> . </p><br><p>  Ideally, we would like to see the following characteristics: </p><br><ul><li>  It can only be in one state at a time. </li><li>  Each state must have its own data, if necessary. </li><li>  The transition between states must have certain semantics. </li><li>  It should be possible to have some general condition. </li><li>  Only explicitly defined transitions should be allowed. </li><li>  Changing one state to another should <strong>absorb the</strong> state if it can no longer be used. </li><li>  We should not allocate memory for <strong>all</strong> states.  Memory consumption must be at least no more than the size of the largest state. </li><li>  Every error message should be easy to understand. </li><li>  We should not resort to using heaps.  Everything should be placed on the stack. </li><li>  Type system should be considered as our strongest advantage. </li><li>  As many errors as possible should be detected at <strong>compile time.</strong> </li></ul><br><p>  So, if we had a pattern that satisfies all these requirements, it would be truly fantastic.  Well, a template that fits only part of the requirements, will also be good. </p><br><h1 id="issleduem-vozmozhnye-realizacii">  Explore possible implementations </h1><br><p>  With such a powerful and flexible type system as in Rust, we should be able to implement this.  The truth is this: there are several ways, each of which offers us certain advantages and teaches us a lesson. </p><br><h2 id="vtoraya-popytka-s-enum">  The second attempt with Enum </h2><br><p>  As we already know, the most natural way is <code>enum</code> , but we have already noticed that we cannot prohibit transitions in this case.  But can we just wrap them in a structure?  Of course we can!  Take a look: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span></span> { Waiting { waiting_time: std::time::Duration }, Filling { rate: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> }, Done } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span></span> { state: State } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> StateMachine { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { StateMachine { state: State::Waiting { waiting_time: std::time::Duration::new(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_filling</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.state { <span class="hljs-comment"><span class="hljs-comment">//   "" -&gt; ""  State::Waiting { .. } =&gt; State::Filling { rate: 1}, //    _ =&gt; panic!("Invalid state transition!") } } // ... } fn main() { let mut state_machine = StateMachine::new(); state_machine.to_filling(); }</span></span></code> </pre> <br><p>  At first glance, everything is in order.  But do you notice some problems? </p><br><ul><li>  An error due to a forbidden transition will occur at runtime, which is terrible! </li><li>  This prevents only incorrect transitions <em>from outside the</em> module, because private fields can be freely modified from within the module.  For example, <code>state_machine.state = State::Done</code> unconditionally operates inside a module. </li><li>  Every our function that works with states must have a <code>match</code> expression. </li></ul><br><p>  However, this approach has some advantages: </p><br><ul><li>  The memory required to represent the state machine is the size of the largest state.  This is the result of using <code>fat enum</code> , the size of which corresponds to the size of the largest variant. </li><li>  All memory is allocated in the stack, the heap is not involved. </li><li>  Transitions between states have certain rules.  This either works or gives an error! </li></ul><br><p>  Now you might think: "Allow, Hoverbear, you can wrap the output <code>to_filling()</code> in <code>Result&lt;T,E&gt;</code> or add the <code>InvalidState</code> option to the <code>enum</code> !".  But let's face it: it doesn't improve the situation much, if it improves at all.  Even if we get rid of runtime crashes, we still have to deal with awkward pattern matching expressions, and our errors will still be detected only after the program has started!  Ugh!  We can do better, I promise. </p><br><p>  So continue the search! </p><br><h2 id="struktury-s-perehodami">  Structures with transitions </h2><br><p>  What if we just use a set of structures?  We can define for each of them a set of types common to each state.  We can use special functions that turn one type into another!  How will it look like? </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      trait SharedFunctionality { fn get_shared_value(&amp;self) -&gt; usize; } struct Waiting { waiting_time: std::time::Duration, // ,     shared_value: usize } impl Waiting { fn new() -&gt; Self { Waiting { waiting_time: std::time::Duration::new(0,0), shared_value: 0 } } //  ! fn to_filling(self) -&gt; Filling { Filling { rate: 1, shared_value: 0 } } } impl SharedFunctionality for Waiting { fn get_shared_value(&amp;self) -&gt; usize { self.shared_value } } struct Filling { rate: usize, //      shared_value: usize, } impl SharedFunctionality for Filling { fn get_shared_value(&amp;self) -&gt; usize { self.shared_value } } // ... fn main() { let in_waiting_state = Waiting::new(); let in_filling_state = in_waiting_state.to_filling(); }</span></span></code> </pre> <br><p>  Damn it, how much code!  Thus, the idea was that all states have both data common to all states and their own.  As you can see, the <code>to_filling()</code> function <code>to_filling()</code> absorb the "Waiting" state and make the transition to the "Filling" state.  Let's summarize everything: </p><br><ul><li>  Conversion errors are determined at compile time!  For example, you cannot even create a "Fill" state by accident without first creating a "Waiting" state.  (Actually you can, but this is irrelevant) </li><li>  A transition between states is required. </li><li>  During the transition between states, the old value is <strong>absorbed</strong> instead of a simple change. <br>  True, we could do the same with <code>enum</code> from our first attempt. </li><li>  We do not need constant <code>match</code> . </li><li>  Memory consumption is still not satisfactory.  We only need the size of the current <br>  states. </li></ul><br><p>  There are some disadvantages: </p><br><ul><li>  Lots of duplicate code.  You must define the same functions and types for each structure. </li><li>  It is not always clear which values ‚Äã‚Äãare common for states and which belong to only one.  Updating the code in the future can cost you dearly. </li><li>  Since the size of the state is not constant, we have to wrap it in <code>enum</code> as before, so that we can use the state machine as one of the components of a more complex system.  Here is what it might look like: </li></ul><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span></span> { Waiting(Waiting), Filling(Filling), Done(Done) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> in_waiting_state = State::Waiting(Waiting::new()); <span class="hljs-comment"><span class="hljs-comment">//    ,   `Waiting`   `enum`! //    `match`    let in_filling_state = State::Filling(in_waiting_state.to_filling()); }</span></span></code> </pre> <br><p>  As you can see, this is not very convenient.  We are getting closer to what we want.  The idea of ‚Äã‚Äãtransition between certain types seems like a big step forward!  Before we try something completely different, let's talk about how to change our example, which can simplify further reflections. </p><br><p>  The standard Rust library provides two very important types: <code>From</code> and <code>Into</code> , which are extremely useful and deserve mention.  It is important to note that the implementation of one of them automatically implements the other.  In general, the <code>From</code> implementation is preferable, since it is a bit more flexible.  We can implement them very easily for our previous example: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ... impl From&lt;Waiting&gt; for Filling { fn from(val: Waiting) -&gt; Filling { Filling { rate: 1, shared_value: val.shared_value, } } } // ...</span></span></code> </pre> <br><p>  This not only gives us a general transition function, but is also much easier to read when you see this in the source code!  This reduces the psychological burden and facilitates the perception of readers.  <em>Instead of implementing our own</em> <em>functions, we use an existing template.</em>  The foundation of our templates on the basis of existing ones is an excellent solution. </p><br><p>  So it's cool, how do we cope with annoying repetition of code and <code>shared_value</code> everywhere?  Let's explore some more! </p><br><h2 id="pochti-idealno">  Almost perfect </h2><br><p>  Now we will bring together the lessons and ideas from the first two ways, add some new ideas, and get something more pleasant.  The essence of this method is to use the power of generalized types.  Let's look at a fairly basic structure: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BottleFillingMachine</span></span></span></span>&lt;S&gt; { shared_value: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, state: S } <span class="hljs-comment"><span class="hljs-comment">//     `S`  StateMachine&lt;S&gt; struct Waiting { waiting_time: std::time::Duration } struct Filling { rate: usize } struct Done;</span></span></code> </pre> <br><p>  So, we actually embed the state of the finite state machine in the signature <code>BottleFillingMachine</code> .  The state machine is in the ‚ÄúFill‚Äù state with <code>BottleStateMachine&lt;Filling&gt;</code> , which is <strong>great</strong> because when we see this type as part of an error message or something like that, we immediately know the current state of the machine. </p><br><p>  We can continue and implement <code>From&lt;T&gt;</code> for some specific options, like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;BottleFillingMachine&lt;Waiting&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BottleFillingMachine&lt;Filling&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(val: BottleFillingMachine&lt;Waiting&gt;) -&gt; BottleFillingMachine&lt;Filling&gt; { BottleFillingMachine { shared_value: val.shared_value, state: Filling { rate: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;BottleFillingMachine&lt;Filling&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BottleFillingMachine&lt;Done&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(val: BottleFillingMachine&lt;Filling&gt;) -&gt; BottleFillingMachine&lt;Done&gt; { BottleFillingMachine { shared_value: val.shared_value, state: Done } } }</code> </pre> <br><p>  The definition of the initial state of the machine looks like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> BottleFillingMachine&lt;Waiting&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(shared_value: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { BottleFillingMachine { shared_value: shared_value, state: Waiting { waiting_time: std::time::Duration::new(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) } } } }</code> </pre> <br><p>  And what does the change of states look like?  Like this: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> in_waiting = BottleFillingMachine::&lt;Waiting&gt;::new(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> in_filling = BottleFillingMachine::&lt;Filling&gt;::from(in_waiting); }</code> </pre> <br><p>  In case you do this inside a function whose signature limits the output type: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition_the_states</span></span></span></span>(val: BottleFillingMachine&lt;Waiting&gt;) -&gt; BottleFillingMachine&lt;Filling&gt; { val.into() <span class="hljs-comment"><span class="hljs-comment">// ,   ? }</span></span></code> </pre> <br><p>  What about the type of error messages <strong>at the compilation stage</strong> ? </p><br><pre> <code class="hljs rust">error[E0277]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bound</span></span></span></span> `BottleFillingMachine&lt;Done&gt;: std::convert::<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;BottleFillingMachine&lt;Waiting&gt;&gt;` is not satisfied --&gt; &lt;anon&gt;:<span class="hljs-number"><span class="hljs-number">50</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span> | <span class="hljs-number"><span class="hljs-number">50</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> in_filling = BottleFillingMachine::&lt;Done&gt;::from(in_waiting); | ^^^^^^^^^^^^^^^^^^^^^^^^^^ | = help: the following implementations were found: = help: &lt;BottleFillingMachine&lt;Filling&gt; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> std::convert::<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;BottleFillingMachine&lt;Waiting&gt;&gt;&gt; = help: &lt;BottleFillingMachine&lt;Done&gt; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> std::convert::<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;BottleFillingMachine&lt;Filling&gt;&gt;&gt; = note: required by `std::convert::<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from`</code> </pre> <br><p>  It is quite clear what is wrong here.  The error message even tells us the right transitions! </p><br><p>  So what does this approach give us? </p><br><ul><li>  The correctness of the transitions is confirmed at compile time. </li><li>  Error messages are very understandable and even offer a list of possible fixes. </li><li>  We have a "parent" structure, which may have associated types and data that need not be repeated in child types. </li><li>  As soon as the transition was made, the old state no longer exists, it was "absorbed."  In fact, the whole structure disappears, so that we cannot get old values ‚Äã‚Äãif there are side effects during the transition (changing average waiting time, for example). </li><li>  Low memory consumption, only stack involved. </li></ul><br><p>  There are still disadvantages: </p><br><ul><li>  Our implementations <code>From&lt;T&gt;</code> suffer from some "clutter types".  However, this is quite a minor inconvenience. </li><li>  Each <code>BottleFillingMachine&lt;S&gt;</code> has a different size, so we still have to use <code>enum</code> .  Yet this is not a serious disadvantage due to our structure. </li></ul><br><p>  You can play with this example <a href="https://is.gd/CyuJlH">here.</a> </p><br><h2 id="gryaznye-otnosheniya-s-roditelyami">  Dirty relationships with parents </h2><br><p>  <em>Translator‚Äôs Note: The translation of this title, courtesy of Google Translator, is so great that I chose to leave it that way.</em> </p><br><p>  How can we organize the parent structure to store the state of the finite state machine without terrible problems with the interaction?  Well, this will roll us back to the first idea with <code>enum</code> . </p><br><p>  If you remember, the main problem with our first approach was that we did not have the ability to provide transitions, and all the errors showed themselves at run time. </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BottleFillingMachineWrapper</span></span></span></span> { Waiting(BottleFillingMachine&lt;Waiting&gt;), Filling(BottleFillingMachine&lt;Filling&gt;), Done(BottleFillingMachine&lt;Done&gt;) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span></span> { bottle_filling_machine: BottleFillingMachineWrapper } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Factory { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { Factory { bottle_filling_machine: BottleFillingMachineWrapper::Waiting(BottleFillingMachine::new(<span class="hljs-number"><span class="hljs-number">0</span></span>)) } } }</code> </pre> <br><p>  At the moment, your first reaction is most likely "Damn, Hoverbear, look at these long, horrible type declarations."  You are absolutely right!  Honestly, they are really long, but I chose the most understandable type names!  You can use all your favorite abbreviations and aliases in your code. <br>  Look! </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> BottleFillingMachineWrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { BottleFillingMachineWrapper::Waiting(val) =&gt; BottleFillingMachineWrapper::Filling(val.into()), BottleFillingMachineWrapper::Filling(val) =&gt; BottleFillingMachineWrapper::Done(val.into()), BottleFillingMachineWrapper::Done(val) =&gt; BottleFillingMachineWrapper::Waiting(val.into()) } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> the_factory = Factory::new(); the_factory.bottle_filling_machine = the_factory.bottle_filling_machine.step(); }</code> </pre> <br><p>  Again, you may notice that this works through <strong>absorption</strong> , not change.  Using <code>match</code> , we <em>move</em> <code>val</code> and, thus, allow <code>.into()</code> use it and absorb the previous state.  But if you prefer to change values, you can implement <code>#[derive(Clone)]</code> or even <code>Copy</code> for your states. </p><br><p>  Despite the fact that it is somewhat less convenient and pleasant to work with, we still have the transitions provided by the system of types and all the guarantees that come with them. </p><br><p>  You may notice that this method <strong>forces</strong> you to process all possible states during the manipulation of the state machine, and this makes sense.  If you own and control a structure with a state machine, you must determine the actions for each state in which there can be a state machine. </p><br><p>  Or you can just call <code>panic!()</code> If you really want to.  But if you just want to <code>panic</code> , then why not use the very first approach? </p><br><p>  You can see a fully working example <a href="https://is.gd/s03IaQ">here.</a> </p><br><h1 id="rabochie-primery">  Working examples </h1><br><p>  This is the case when examples are not superfluous.  So I collected a couple of working examples below and provided them with comments. </p><br><h2 id="tri-sostoyaniya-dva-perehoda">  Three states, two transitions </h2><br><p>  This example is very similar to our bottle-filling machine, but it <strong>actually</strong> works, albeit rather trivially.  This state machine receives the string and returns the number of words in it. <br>  <a href="https://is.gd/4ITDyV">Link to Rust Playground</a> </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//   &lt;StateA&gt;.       ! let in_state_a = StateMachine::new("  ".into()); //   ,         in_state_a.some_unrelated_value; println!(" : {}", in_state_a.state.start_value); //    .    //      let in_state_b = StateMachine::&lt;StateB&gt;::from(in_state_a); //   !     ! // in_state_a.some_unrelated_value; //           in_state_b.some_unrelated_value; println!(" : {:?}", in_state_b.state.interm_value); //     let in_state_c = StateMachine::&lt;StateC&gt;::from(in_state_b); //     !      ! // in_state_c.state.start_value; println!(" : {}", in_state_c.state.final_value); } //     struct StateMachine&lt;S&gt; { some_unrelated_value: usize, state: S } //       impl StateMachine&lt;StateA&gt; { fn new(val: String) -&gt; Self { StateMachine { some_unrelated_value: 0, state: StateA::new(val) } } } //        struct StateA { start_value: String } impl StateA { fn new(start_value: String) -&gt; Self { StateA { start_value: start_value, } } } //  B     struct StateB { interm_value: Vec&lt;String&gt;, } impl From&lt;StateMachine&lt;StateA&gt;&gt; for StateMachine&lt;StateB&gt; { fn from(val: StateMachine&lt;StateA&gt;) -&gt; StateMachine&lt;StateB&gt; { StateMachine { some_unrelated_value: val.some_unrelated_value, state: StateB { interm_value: val.state.start_value.split(" ").map(|x| x.into()).collect(), } } } } // ,      ,       struct StateC { final_value: usize, } impl From&lt;StateMachine&lt;StateB&gt;&gt; for StateMachine&lt;StateC&gt; { fn from(val: StateMachine&lt;StateB&gt;) -&gt; StateMachine&lt;StateC&gt; { StateMachine { some_unrelated_value: val.some_unrelated_value, state: StateC { final_value: val.state.interm_value.len(), } } } }</span></span></code> </pre> <br><h2 id="raft">  Raft </h2><br><p>  If you‚Äôve been following my blog recently, you may know that I prefer to write about Raft.  It was Raft, as well as communication with <a href="https://twitter.com/Argorak">@argorak</a> that pushed me to conduct this research. </p><br><p>  Raft is somewhat more complicated than the previous examples, because state transitions are not linear, as <code>A-&gt;B-&gt;C</code>  Here is a state and transition diagram for this state machine. </p><br><pre> <code class="hljs ruby">+----------+ +-----------+ +--------+ <span class="hljs-params"><span class="hljs-params">| +----&gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| Follower |</span></span> <span class="hljs-params"><span class="hljs-params">| Candidate +----&gt; Leader |</span></span> <span class="hljs-params"><span class="hljs-params">| &lt;----+ |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> +--------^-+ +-----------+ +-+------+ <span class="hljs-params"><span class="hljs-params">| |</span></span> +-------------------------+</code> </pre> <br><p>  ‚Üí <a href="https://is.gd/HDZeGR">Link to Rust Playground</a> </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      fn main() { let is_follower = Raft::new(/* ... */); //  ,  3, 5  7  Raft.      :) //      let is_candidate = Raft::&lt;Candidate&gt;::from(is_follower); //  !   let is_leader = Raft::&lt;Leader&gt;::from(is_candidate); //        Follower let is_follower_again = Raft::&lt;Follower&gt;::from(is_leader); //    ... let is_candidate_again = Raft::&lt;Candidate&gt;::from(is_follower_again); //     ! let is_follower_another_time = Raft::&lt;Follower&gt;::from(is_candidate_again); } //     struct Raft&lt;S&gt; { // ...   state: S } //  ,      Raft //     ,     struct Leader { // ...    } //   ,            struct Candidate { // ...    } //    ,   struct Follower { // ...    } // Raft    Follower impl Raft&lt;Follower&gt; { fn new(/* ... */) -&gt; Self { // ... Raft { // ... state: Follower { /* ... */ } } } } //       //     ,     impl From&lt;Raft&lt;Follower&gt;&gt; for Raft&lt;Candidate&gt; { fn from(val: Raft&lt;Follower&gt;) -&gt; Raft&lt;Candidate&gt; { // ...      Raft { // ... attr: val.attr state: Candidate { /* ... */ } } } } //       ,      impl From&lt;Raft&lt;Candidate&gt;&gt; for Raft&lt;Follower&gt; { fn from(val: Raft&lt;Candidate&gt;) -&gt; Raft&lt;Follower&gt; { // ...      Raft { // ... attr: val.attr state: Follower { /* ... */ } } } } //       impl From&lt;Raft&lt;Candidate&gt;&gt; for Raft&lt;Leader&gt; { fn from(val: Raft&lt;Candidate&gt;) -&gt; Raft&lt;Leader&gt; { // ...      Raft { // ... attr: val.attr state: Leader { /* ... */ } } } } //   ,     ,    impl From&lt;Raft&lt;Leader&gt;&gt; for Raft&lt;Follower&gt; { fn from(val: Raft&lt;Leader&gt;) -&gt; Raft&lt;Follower&gt; { // ...      Raft { // ... attr: val.attr state: Follower { /* ... */ } } } }</span></span></code> </pre> <br><h1 id="alternativnye-podhody-iz-otzyvov">     </h1><br><p>     <a href="https://www.reddit.com/r/rust/comments/57ccds/pretty_state_machine_patterns_in_rust/d8rhwq4"> I-impv  Reddit</a> ,   <a href="https://play.rust-lang.org/%3Fgist%3Dee3e4df093c136ced7b394dc7ffb78e1%26version%3Dstable%26backtrace%3D0">,     </a> .    : </p><br><blockquote>    .            -. <br>  ,     : <br><ul><li>       .           (, ),        . </li><li>         "",          . </li></ul><br></blockquote><p>           ! </p><br><h1 id="zaklyuchitelnye-mysli">   </h1><br><p> Rust        .       <code>enum</code>     ,   .           ,    ,   . </p><br><p>            ,          .     IRC Mozilla   Hoverbear. </p><br><p> <em> :</em> <br> <em> : Andrew Hobden</em> <br> <a href="https://hoverbear.org/2016/10/12/rust-state-machine-pattern/">  </a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324382/">https://habr.com/ru/post/324382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324372/index.html">How and why static analyzers deal with false positives</a></li>
<li><a href="../324374/index.html">CEPH for pumping</a></li>
<li><a href="../324376/index.html">Exceptions in Windows x64. How it works. Part 3</a></li>
<li><a href="../324378/index.html">We bring business to the international market in 5 minutes</a></li>
<li><a href="../324380/index.html">Hard Prioritization</a></li>
<li><a href="../324384/index.html">Intel SGX Extensions Tutorial. Part 7, revision of the enclave</a></li>
<li><a href="../324388/index.html">React + mobx path from scratch. Mobx + react, side view</a></li>
<li><a href="../324394/index.html">Are commodity aggregators good?</a></li>
<li><a href="../324396/index.html">Check Point Security CheckUP - Free network security audit. Part 1</a></li>
<li><a href="../324398/index.html">Biometrics: the art of recognition. Perspectives of biometric systems on the example of the Id-Me platform from the company RecFaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>