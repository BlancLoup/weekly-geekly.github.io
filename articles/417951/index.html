<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing Java Friendly Kotlin Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the outside, it may seem that Kotlin has simplified Android development, without at all bringing new challenges: the language is Java-compatible,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing Java Friendly Kotlin Code</h1><div class="post__text post__text-html js-mediator-article">  From the outside, it may seem that Kotlin has simplified Android development, without at all bringing new challenges: the language is Java-compatible, so even a large Java project can be gradually transferred to it without scoring a head, right?  But if you look deeper, there is a double bottom in each box and a secret door in the dressing table.  Programming languages ‚Äã‚Äãare too complex projects to combine without cunning nuances. <br><br>  Of course, this does not mean ‚Äúeverything is bad and you don‚Äôt need to use Kotlin together with Java‚Äù, but it means that you should know about the nuances and take them into account.  At our <b>Mobius</b> conference, Sergei Ryabov <a href="https://mobiusconf.com/2017/msk/talks/jslrnocqzieusmswmg0w0/">told</a> how to write such code on Kotlin that you‚Äôll be comfortable using from Java.  And the audience liked the report so much that we not only decided to post a video, but also made a text version for Habr: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1L0q5VKx_-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  I have been writing on Kotlin for more than three years, now only on it, but at first I dragged Kotlin into existing Java projects.  Therefore, the question "how to connect Java and Kotlin together" in my way arose quite often. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Often, when you add a Kotlin project, you can see how this ... <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span></code> </pre> <br>  ... turns into this: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents-kotlin:xyz'</span></span></code> </pre><br>  The specifics of the last couple of years: the most popular libraries acquire ‚Äúwrappers‚Äù in order to be able to use them from Kotlin more idiomatically. <br><br>  If you wrote on Kotlin, you know that there are cool extension-functions, inline-functions, lambda-expressions that are available from Java 6. And this is cool, it attracts us to Kotlin, but the question arises.  One of the biggest, most publicized features of the language is interoperability with Java.  If we take into account all the listed features, then why not just write libraries on Kotlin?  They will all work out of the box with Java perfectly, and you will not need to support all these wrappers, everyone will be happy and contented. <br><br>  But, of course, in practice, not everything is as rosy as in advertising brochures, there is always a ‚Äúsmall sign‚Äù, there are sharp edges at the junction of Kotlin and Java, and today we will talk about this a little. <br><br><h2>  Sharp edges </h2><br>  Let's start with the differences.  For example, do you know that there are no volatile, synchronized, strictfp, transient keywords in Kotlin?  They are replaced by annotations of the same name that are in the kotlin.jvm package.  So, about the contents of this package and go most of the conversation. <br><br>  There is <a href="https://github.com/JakeWharton/timber">Timber</a> - such a library-abstraction over loggers from the notorious <abbr title="Jake wharton">Zheka Vartanov</abbr> .  It allows you to use it everywhere in your application, and everything where you want to send logs (to logcat, or to your server for analysis, or to crash reporting, and so on) turns into plugins. <br><br>  Let's imagine for example that we want to write a similar library, just for analytics.  Also abstracted. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Analytics { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Plugin&gt; {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: Map&lt;String, Any&gt; = emptyMap() )</code> </pre><br>  We take the same construction pattern, we have one entry point - this is Analytics.  We can send events there, add plugins and watch what we have already added there. <br><br>  Plugin is a plugin interface that abstracts a particular analytic API. <br><br>  And, actually, the Event class that contains the key and our attributes that we send.  Here the report is not about whether it is worth using singltons, so let's not breed holivar, but we will watch how this whole thing is combed. <br><br>  Now a little dive.  Here is an example of using our library in Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> props = mapOf( USER_ID to <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span> to <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins = Analytics.hasPlugins Analytics.addPlugin(EMPTY_PLUGIN) <span class="hljs-comment"><span class="hljs-comment">// dry-run Analytics.addPlugins(listOf(LoggerPlugin("ALog"), SegmentPlugin))) val plugins = Analytics.getPlugins() // ... }</span></span></code> </pre><br>  In principle, it looks as expected.  One entry point, methods are called a la statics.  Event without parameters, event with attributes.  We check if we have plug-ins, push an empty plug-in there in order to just do some kind of ‚Äúdry run‚Äù.  Or add a few other plugins, display them, and so on.  In general, standard user cases, I hope everything is clear for now. <br><br>  Now let's see what happens in Java when we do the same: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>, Collections.emptyMap())); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.INSTANCE.getHasPlugins(); Analytics.INSTANCE.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run final List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin("ALog"), new SegmentPlugin()); // ... }</span></span></code> </pre><br>  Immediately, the fuss with INSTANCE, which is stretched upward, the presence of explicit values ‚Äã‚Äãfor the default parameter with attributes, some getters with strong names, immediately catches the eye.  Since we, in general, have gathered here to turn it into something similar to the previous file with Kotlin, let's go through each moment that we don‚Äôt like and try to adapt it somehow. <br><br>  Let's start with the Event.  We remove the Colletions.emptyMap () parameter from the second line, and a compiler error pops up.  What is the reason? <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Any</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emptyMap</span></span></span><span class="hljs-class">() )</span></span></code> </pre><br>  Our constructor has a default parameter to which we pass the value.  We come from Java to Kotlin, it is logical to assume that the presence of the default parameter generates two constructors: one complete with two parameters, and one partial, which can only be given a name.  Obviously, the compiler does not think so.  Let's see why he thinks we're wrong. <br><br>  Our main tool for analyzing all the twists and turns of how Kotlin turns into a JVM bytecode - Kotlin Bytecode Viewer.  In Android Studio and IntelliJ IDEA, it is located in the Tools - Kotlin - Show Kotlin Bytecode menu.  You can simply press Cmd + Shift + A and enter Kotlin Bytecode in the search bar. <br><br><img src="https://habrastorage.org/webt/3d/9i/kg/3d9ikgrehu0zgr50qyftivtoahi.png"><br><br>  Here, surprisingly, we see the baytkod of what turns our Kotlin-class.  I do not expect from you excellent knowledge of baytkod, and, most importantly, IDE developers also do not expect.  Therefore, they made a button Decompile. <br><br>  After pressing it, we see such a pretty good Java code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map context; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, @NotNull Map context)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(name, <span class="hljs-string"><span class="hljs-string">"name"</span></span>); Intrinsics.checkParameterIsNotNull(context, <span class="hljs-string"><span class="hljs-string">"context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context = context; } <span class="hljs-comment"><span class="hljs-comment">// $FF: Synthetic method public Event(String var1, Map var2, int var3, DefaultConstructorMarker var4) { if ((var3 &amp; 2) != 0) { var2 = MapsKt.emptyMap(); } // ... }</span></span></code> </pre><br>  We see our fields, getters, the expected constructor with two parameters name and context, everything happens fine.  And below we see the second constructor, and here it is with an unexpected signature: not with one parameter, but for some reason with four. <br><br>  Here you can be embarrassed, but you can climb a little deeper and delve.  When we begin to understand, we will understand that DefaultConstructorMarker is a private class from the Kotlin standard library added here so that there are no conflicts with us written by designers, since we cannot set the parameters of the DefaultConstructorMarker type with our hands.  And int var3 is interesting in all - the bit mask of what default values ‚Äã‚Äãwe should use.  In this case, if the bitmask matches the two, we know that var2 is not set, our attributes are not set, and we use the default value. <br><br>  How can we fix the situation?  To do this, there is a wonderful annotation @JvmOverloads from the package, which I have already mentioned.  We have to hang it on the designer. <br><br><pre> <code class="hljs delphi">data <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Event @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( val </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val context: Map&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; = emptyMap()</span></span></span><span class="hljs-function"> )</span></span></code> </pre><br>  And what will she do?  Refer to the same tool.  Now we can see both our complete constructor and the constructor with the DefaultConstructorMarker, and, miracle, the constructor with one parameter, which is now available from Java: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, (Map)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre><br>  And, as you can see, it delegates all the work with default parameters to that our constructor with bit masks.  Thus, we do not produce information about the fact that for the default value we need to shove there, we simply delegate everything to one constructor.  Nice  We check what we got from the Java side: the compiler is happy and not outraged. <br><br>  Let's see what we don't like next.  We do not like this INSTANCE, which in IDEA is purple in color.  I do not like purple color :) <br><br><img src="https://habrastorage.org/webt/ys/rq/er/ysrqerlelunfipzn0xat3yek9da.png"><br><br>  Let's check, due to what it turns out.  Look at the baytkod again. <br><br>  Let us select, for example, the function init and make sure that init is really generated not static. <br><br><img src="https://habrastorage.org/webt/ek/5h/m2/ek5hm21brrzzf5yfu5mahq4x5eq.png"><br><br>  That is, whatever one may say, we need to work with the instance of this class and call these methods on it.  But we can generate the generation of all these methods as static.  There is a wonderful annotation for this @JvmStatic.  Let's add it to the functions init and send and check what the compiler thinks about it now. <br><br>  We see that the static keyword has been added to the public final init (), and we have saved ourselves from working with INSTANCE.  See for yourself in the Java code. <br><br>  The compiler now tells us that we are calling a static method from the context INSTANCE.  This can be corrected: press Alt + Enter, select "Cleanup Code", and voila, INSTANCE disappears, everything looks approximately the same as it was in Kotlin: <br><br><pre> <code class="java hljs"> Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>));</code> </pre><br>  Now we have a scheme for working with static methods.  Add this annotation wherever it matters to us: <br><br><img src="https://habrastorage.org/webt/0o/m4/ky/0om4kydc_nj_fnmjd6jnfsfqfao.png"><br><br>  And a comment: if the methods we have are obviously methods of the instance, then, for example, with prop, not everything is so obvious.  The fields themselves (for example, plugins) are generated as static.  But the getters and setters work as instance methods.  Therefore, you also need to add this annotation for the perpetrators to get the setters and getters as static.  For example, we see the isInited variable, we add the @JvmStatic annotation to it, and now we see in the Kotlin Bytecode Viewer that the isInited () method has become static, everything is fine. <br><br>  Now let's go to the Java code, ‚Äúbehind-the-clean-up-it‚Äù it, and everything looks like in Kotlin, except for the semicolons and the word new - well, you will not get rid of them. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.getHasPlugins(); Analytics.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run // ... }</span></span></code> </pre><br>  Next step: we see this dubbed getHasPlugins getter with two prefixes at once.  Of course, I am not a great expert in English, but it seems to me that something else was meant here.  Why it happens? <br><br>  As they know, who tightly communicated with Kotlin, for the names of getters and setters are generated according to JavaBeans rules.  This means that, in general, getters will be with get prefixes, setters with set prefixes.  But there is one exception: if you have a boolean field and its name has the prefix is, then the getter will be prefixed with is.  This can be seen on the example of the aforementioned isInited field. <br><br>  Unfortunately, not always Boolean fields should be called with is.  isPlugins would not quite satisfy what we want to semantically show by name.  How can we be? <br><br>  And it is easy for us to have our own abstract for this (as you already understood, I will often repeat this today).  The @JvmName annotation allows you to specify any name we want (naturally, supported by Java).  Add it: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hasPlugin"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Let's check out what we got in Java: the getHasPlugins method is no longer there, but hasPlugins is quite there.  This solved our problem, again, with one annotation.  Now let's solve all the annotations! <br><br>  As you can see, here we hung the annotation directly on the getter.  What is the reason?  With the fact that there is a lot of things under the profile, and it is not clear to what @JvmName applies.  If you transfer the annotation to val hasPlugins itself, the compiler does not understand what to apply it to. <br><br>  However, Kotlin has the ability to specify the location of the application of the annotation directly in it.  You can specify the goal of the getter, the entire file, the parameter, the delegate, the field, the property, the receiver extension functions, the setter, and the parameter of the setter.  In our case, the getter is interesting.  And if you do this, it will be the same effect as when we annotated get: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@get:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPlugins"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Accordingly, if you do not have a custom getter, then you can hang directly on your property, and everything will be OK. <br><br>  The next point that confuses us a bit is ‚ÄúAnalytics.INSTANCE.getEMPTY_PLUGIN ()‚Äù.  It's not even English, but simply: WHY?  The answer is about the same, but at first a small introduction. <br><br>  In order to make a field constant, you have two options.  If you define a constant as a primitive type or as a String, and it is also inside an object, then you can use the keyword const, and then no getter setters and other things will be generated.  This will be a regular constant ‚Äî private final static ‚Äî and it will be inline, that is, an absolutely regular Java thing. <br><br>  But if you want to make a constant from an object that is different from the string, then you will not be able to use the word const for this.  Here we have val EMPTY_PLUGIN = EmptyPlugin (), according to it, that terrible getter was obviously generated.  We can rename the @JvmName annotation, remove this get prefix, but still it will remain a method with parentheses.  So, the old solutions will not work, we are looking for new ones. <br><br>  And here for this is the abstract @JvmField, which says: ‚ÄúI don‚Äôt want getters here, I don‚Äôt want setters, make me a field‚Äù.  Put it in front of val EMPTY_PLUGIN and check that this is all true. <br><br><img src="https://habrastorage.org/webt/7e/ei/0i/7eei0iwsgrd3pvkg_6lljoylhzm.png"><br><br>  Kotlin Bytecode Viewer shows highlighted the piece on which you are now standing in the file.  We are now standing at EMPTY_PLUGIN, and you see that there is some kind of initialization written in the constructor.  The fact is that the getter is no more and access to it is only recorded.  And if you click decompile, we see that ‚Äúpublic static final EmptyPlugin EMPTY_PLUGIN‚Äù has appeared, this is exactly what we wanted.  Nice  We check that everyone is happy, in particular, the compiler.  The most important person you need to appease is the compiler. <br><br><h2>  Generics </h2><br>  Let's tear off a bit from the code and look at generics.  This is quite a hot topic.  Or slippery, someone that no longer like.  Java has its difficulties, but Kotlin is different.  First of all, we are concerned about the variation.  What it is? <br><br>  Variance is a way to transfer information about a type hierarchy from basic types to derivatives, for example, to containers or generics.  Here we have the classes Animal and Dog with a quite obvious connection: Dog is a subtype, Animal is a supertype, the arrow comes from the subtype. <br><br><img src="https://habrastorage.org/webt/rz/-b/uz/rz-buzyeywt0xgwewjvauwmf0lc.png"><br><br>  And what connection will their derivatives have?  Let's look at some cases. <br><br>  The first is Iterator.  To determine what is a supertype, and what is a subtype, we will be guided by the Barbara Liskov substitution rule.  It can be formulated as follows: ‚Äúthe subtype should require no more, and provide no less.‚Äù <br><br>  In our situation, the only thing Iterator does is give us typed objects, for example, Animal.  If we take Iterator somewhere, we can easily put Iterator into it, and we get Animal from the next () method, because the dog is also Animal.  We provide not less, but more, because the dog is a subtype. <br><br><img src="https://habrastorage.org/webt/bz/4e/ra/bz4eracdjm_ep_qnzk0mbkr5q7w.png"><br><br>  I repeat: we only read from this type, therefore the dependence between type and subtype is preserved here.  And such types are called covariant. <br><br>  Another case: Action.  Action is a function that returns nothing, takes one parameter, and we only write to Action, that is, it takes a dog or an animal from us. <br><br><img src="https://habrastorage.org/webt/h5/hg/74/h5hg74k6id9rwtzfq1j2g1qsjyk.png"><br><br>  Thus, here we no longer provide, but demand, and we must demand no more.  This means that our dependence is changing.  "No more" we have Animal (Animal less than a dog).  And such types are called contravariant. <br><br>  There is also a third case - for example, ArrayList, from which we both read and write.  Therefore, in this case we are breaking one of the rules, we demand more for the recording (dog, not animal).  Such types are not related in any way by relation, and they are called invariant. <br><br><img src="https://habrastorage.org/webt/gj/5o/gp/gj5ogpkqy1ifvtmxghqszew7fgk.png"><br><br>  So, in Java, when it was designed before version 1.5 (where the generics appeared), arrays were made covariant by default.  This means that you can assign an array of objects to an array of objects, then transfer it somewhere to a method where you need an array of objects, and try to stuff an object there, although this is an array of strings.  Everything will fall for you. <br><br>  Having learned from bitter experience that it is impossible to do this, when designing generics, they decided ‚Äúwe will make collections invariant, we will not do anything with them‚Äù. <br><br>  And in the end it turns out that in such a seemingly obvious thing everything should be ok, but in fact not ok: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); List&lt;Animal&gt; animals = dogs;</span></span></code> </pre><br>  But we need to somehow determine that we can still: if we only read from this sheet, why not make it possible to transfer a sheet of dogs here?  Therefore, it is possible with the help of a wildcard to describe what kind of variation this type will have: <br><br><pre> <code class="java hljs">List&lt;Dog&gt; dogs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); List&lt;? extends Animal&gt; animals = dogs;</code> </pre><br>  As you can see, this variation is indicated at the place of use, where we assign dogs.  Therefore, it is called use-site variance. <br><br>  What negative side does it have?  The negative side is that you must, wherever you use your API, specify these terrible wildcards, and this is all very fruitful in the code.  But for some reason, in Kotlin such a thing works out of the box, and there is no need to indicate anything: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dogs: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dog</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">ArrayList</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animals: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Animal</span></span>&gt; = dogs</code> </pre><br>  What is the reason?  With the fact that the sheets are actually different.  List in Java implies writing, and in Kotlin it is read-only, not implying.  Therefore, in principle, we can immediately say that we only read from here, so we can be covariant.  And it is specified in the type declaration with the out keyword, replacing the wildcard: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out E</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">E</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br>  This is called a declaration-site variance.  Thus, we indicated everything in one place, and where we use it, we no longer touch on this topic.  And this is nishtyak. <br><br><h2>  Back to code </h2><br>  Let's go back to our depths.  Here we have the addPlugins method, it takes a List: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }    ,  , List&lt;EmptyPlugin&gt;, ,     : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"java"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin(<span class="hljs-string"><span class="hljs-string">"Alog"</span></span>), new SegmentPlugin());</code> </pre><br>  Due to the fact that the List in Kotlin is covariant, we can transfer here a sheet of the heirs of the plugin without any problems.  Everything works, the compiler does not mind.  But due to the fact that we have a Declaration-site variance, where we have specified everything, we cannot then control the connection with Java at the use stage.  And what will happen if we really want the Plugin list there, do not want any heirs there?  There are no modifiers for this, but is that?  That's right, there is a summary.  And the abstract is called @JvmSuppressWildcards, that is, by default we consider that here is a type with a wildcard, a covariant type. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;@</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JvmSuppressWildcards</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }</code> </pre><br>  Speaking of SuppressWildcards, we suppress all these questions, and our signature actually changes.  Moreover, I will show how everything looks in bytecode: <br><br><img src="https://habrastorage.org/webt/rn/xp/ft/rnxpft1zqpioojczpiiyn1g3veo.png"><br><br>  I will delete while from the code the summary.  Here is our method.  You probably know that there is a type erasure.  And in your bytecode there is no information about what kind of questions there were, well, in general, generics.  But the compiler follows this and signs it in the comments to the bytecode: which is the type with us. <br><br><img src="https://habrastorage.org/webt/u4/5e/mm/u45emmdne71zx9e9whz7uu8law0.png"><br><br>  Now we will insert the annotation again and see that this is our type without questions. <br><br><img src="https://habrastorage.org/webt/cu/if/wm/cuifwmem7zn636x3ky7n_41vuly.png"><br><br>  Now our previous code will stop compiling precisely because we have cut off the Wildcards.  You can see for yourself. <br><br>  We deconstructed covariant types.  Now the opposite situation. <br><br>  We think that we have a list with a question.  ,       getPlugins,     .  What does it mean?  ,       ,    ,   .  ,    Java. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Plugin&gt; plugins = Analytics.getPlugins(); displayPlugins(plugins); Analytics.getPlugins().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br>   ,      - ,   ,  -   .    ,      .     ,   -  . <br><br>     . Kotlin  ,   , ,    ,  ,    wildcards  Java. ,       ,     .   ,    List,         Plugin.   ,   , ,     :    Plugin,     . <br><br>       .    ,        ,      usecase,      - ,     . <br><br>      ,      ,     ,     - .     ,       Java.  Kotlin  List ‚Äî  read only-,       ,       Java      ‚Äî   ?    ,     List  wildcard.      , .   @JvmWildcard  :     ,   .  ,    Java   . Java  ¬´  ?¬ª: <br><br><img src="https://habrastorage.org/webt/su/v_/1r/suv_1rnnuub7bsqlod-oglgra74.png"><br><br>         List&lt;? extends Plugin&gt;,      ¬´  ?¬ª ,  ,      .   script kiddie,   ¬´   ,   ,  ,   ArrayList,    ¬ª.   ,     ArrayList   ,    . <br><br><pre> <code class="java hljs">((ArrayList&lt;Plugin&gt;) Analytics.getPlugins()).add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br> , ,   ,      defensive-,  - . ,   ,   ,  script kiddies   . <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;<span class="hljs-meta"><span class="hljs-meta">@JvmWildcard</span></span> Plugin&gt; = plugin.toImmutableList()</code> </pre><br>  ,   @JvmSuppressWildcard     ,       ,    ,     ,     . <br><br>    ,     .    ,     : . <br><br>       Java.   ,    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Event event)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException</span></span></code> </pre><br>    : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  Kotlin   checked exception.     :   .    , , .  Java   -. : ¬´  Throws -   , ¬ª: <br><br><img src="https://habrastorage.org/webt/g-/v8/go/g-v8gog8gwfa-on0anv0bkwktsk.png"><br><br>    -,   Kotlin? ,   ‚Ä¶ <br><br>   @Throws,     .   throws-   .  ,     IOExeption: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyPlugin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Plugin { @Throws</span></span></span></span>(IOException::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">send</span></span></span></span>(event: Event) {} <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>        : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Throws(IOException::class)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>   ?   ,   Java,       exception,  .  , .  ,     - ,      ,   @JvmName.  . <br><br>       ,   Java  .   ‚Ä¶ <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> util <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;Int&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it, acc -&gt; it + acc }) } <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printReversedConcatenation"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;String&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(StringBuilder()) { it, acc -&gt; acc.append(it) }) }</code> </pre><br> ,  Java    ,  . ,  IDE     .   ,    ? ,       ,    ,    List,   List. , type erasure.      : <br><br><img src="https://habrastorage.org/webt/qk/oq/jr/qkoqjrub5xc4mdn-twq-s_jehl4.png"><br><br>    ,   ,   top-level     c.         printReversedSum  List,       List.   Kotlin-   ,  Java-  .    ,     kotlin.jvm    ,   Java    ,   ,   Kotlin .    ‚Äî    ,   concatenation ‚Äî    ,   . <br><br>   .     .    extension- reverse. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = StringBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).reverse().toString() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reversedClassName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simpleName</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reverse</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br>  reverse     ,   ReverserKt. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(ReverserKt.reverse(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>)); SumsKt.printReversedSum(asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); SumsKt.printReversedConcatenation(asList(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>)); }</code> </pre><br> ,  ,    .   ,  ,     Java,   - .              .     ?   ,  @JvmName,     ,    . <br><br>      ,  ,  ,   ,       ,     . <br><br><pre> <code class="hljs ruby">@file<span class="hljs-symbol"><span class="hljs-symbol">:Suppress</span></span>(<span class="hljs-string"><span class="hljs-string">"NOTHING_TO_INLINE"</span></span>) @file<span class="hljs-symbol"><span class="hljs-symbol">:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"ReverserUtils"</span></span>)</code> </pre><br>    Java   ReverserKt,   ,   ReverserUtils   .   ¬´ 2.1¬ª ‚Äî  ,       top-level     ,   . ,    ,    sums.kt   SumsKt,  ,       reversing    ReverserUtils.        @JvmName,  ¬´ReverserUtils¬ª,  ,  ,      ,  . <br><br>     ,      ,  ¬´          , -¬ª.   ?       @JvmMultifileClass, ,         ,        . <br><br>     "@file:JvmMultifileClass",    SumsKt  ReverserUtils,   ‚Äî  .   ! <br><br>       ,   .  ,     ,    .   ,  , , @JvmName     Kotlin. <br><br><h2> Kotlin- </h2><br> ,     ,     .   ,    Kotlin- . <br><br> , inline-.   Kotlin  ,  ,        Java  ? , ,   ,      Java.    , , Kotlin-only ,        dex count limit.    Kotlin   ,     . <br><br>    Reified type parameters.     Kotlin,     -     ,   Java   .    Kotlin-only ,     Kotlin,   Java       reified,  . <br><br> java.lang.Class.     ,      Java,     .   .     ¬´ Retrofit¬ª,     (   ,     ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Retrofit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseUrl: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: Client ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(service.java) } }</code> </pre><br>  ,     Java,  ,     KClass,       ,    extension-,   KClass  Class,  Class  KClass (  Kotlin,   ). <br><br>    ,    .  Kotlin-    KClass,     Reified-,       : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  .    Kotlin  ,    .  <i>val api = retrofit.create(Api::class)</i>   <i>val api = retrofit.create&lt;Api&gt;()</i> ,   ::class  .    Reified-,    -. <br><br> Unit.     Unit,      ,   void  Java,  .      .       ,       .  -   Scala,   Scala      ,   - ,       ,    ,    void. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in Kotlin this is not. </font><font style="vertical-align: inherit;">Kotlin has only 22 interfaces that accept a different set of parameters and return something. </font><font style="vertical-align: inherit;">Thus, the lambda that returns Unit will return not void, but Unit. </font><font style="vertical-align: inherit;">And it imposes its limitations. </font><font style="vertical-align: inherit;">What does the lambda that returns Unit look like? </font><font style="vertical-align: inherit;">Here, look at it in this code snippet. </font><font style="vertical-align: inherit;">Let's get acquainted.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using it from Kotlin: everything is good, we even use method reference, if we can, and it reads well, the eyes are not sore. </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>).forEachReversed(::println) println(reversedClassName&lt;String&gt;()) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What happens in java? </font><font style="vertical-align: inherit;">In Java, this canoe happens:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; list = asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); ReverserUtils.forEachReversed(list, integer -&gt; { System.out.println(integer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Unit.INSTANCE; });</code> </pre><br> - ,     - .   Void   ,         .       ,   void,  .  , ,   ,          .  ,     Unit .  null,      .  ,     . <br><br>  : Typealiases ‚Äî     ,     ,     Kotlin,   Java,  ,    ,    .      ,  -  . Java-    . <br><br>   : visibility.  , internal visibility.   ,   Kotlin  package private,     - ,   public.   internal. Internal ‚Äî    ,       .  Retrofit    internal- validate. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Retrofit { println(<span class="hljs-string"><span class="hljs-string">"!!!!!! internal fun validate() was called !!!!!!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre><br>       Kotlin,   .    Java?     validate? ,    ,  internal   public.     ,  Kotlin bytecode viewer. <br><br><img src="https://habrastorage.org/webt/cc/mr/ts/ccmrtst8oqwmbdvgn4onk8jlrus.png"><br><br>   public,     ,   ,  , ,     ,    API    .   -   80  ,          . <br><br>  Java    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$production_sources_for_module_library_main() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br>     . ,   ,   ,  .      ,  let me explain this to you. ,     ? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$library() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br>  .    ¬´ ?¬ª    ‚Ä¶ MAGIC! <br><br>   ,    -   internal,  ,        API.   script kiddie   Kotlin Bytecode Viewer,   .         internal visibility. <br><br>      ,    .         ,     ,  <a href="https://skillsmatter.com/skillscasts/10012-keynote-sinking-your-teeth-into-bytecode"> </a> ,   ,     SkillsMatter.  Very cool. <br><br>    <a href="https://medium.com/%40BladeCoder/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62"></a>        ,     Kotlin-.    , -  ,     .    Kotlin bytecode viewer   . <br><br>  Thank! <br><br><blockquote>   ,  : 8-9      <b>Mobius</b> ,      .      ‚Äî <a href="https://mobiusconf.com/"> </a> ,      . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/417951/">https://habr.com/ru/post/417951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417941/index.html">Where does the water in the kettle go?</a></li>
<li><a href="../417943/index.html">Serverless and React 2: sleight of hand and no fraud</a></li>
<li><a href="../417945/index.html">What tools does the Parker sun probe have?</a></li>
<li><a href="../417947/index.html">Data visualization for your web project</a></li>
<li><a href="../417949/index.html">As I wrote the standard C ++ 11 library or why the boost is so scary. Chapter 4.2</a></li>
<li><a href="../417953/index.html">Trends in FPGA Design. Transfer</a></li>
<li><a href="../417955/index.html">How to become an interface designer. Necessary skills and powerful tools that we are not told about</a></li>
<li><a href="../417957/index.html">Open webinar "Linux containerization mechanisms"</a></li>
<li><a href="../417959/index.html">10 interface design tips</a></li>
<li><a href="../417963/index.html">Wind, locust and deadline: how we built the power substation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>