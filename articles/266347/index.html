<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of segmentation algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This summer I was lucky enough to get a summer internship at Itseez . I was asked to explore modern methods that would allow to select the locations o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of segmentation algorithms</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/21e/c02/78e/21ec0278e7f349d696960a65974204d4.jpg"></div><br>  This summer I was lucky enough to get a summer internship at <a href="http://itseez.com/"><b><i>Itseez</i></b></a> .  I was asked to explore modern methods that would allow to select the locations of objects in the image.  Basically, these methods rely on segmentation, so I began my work with an introduction to this area of ‚Äã‚Äãcomputer vision. <br>  <i><b>Image segmentation</b></i> is the division of an image into multiple areas covering it.  Segmentation is used in many areas, for example, in manufacturing to indicate defects in the assembly of parts, in medicine for the initial processing of images, as well as for the mapping of the terrain from satellite images.  For those who are interested in understanding how such algorithms work, welcome under cat.  We will look at several methods from the <a href="http://opencv.org/"><i><b>OpenCV</b></i></a> computer vision <a href="http://opencv.org/"><i><b>library</b></i></a> . <br><a name="habracut"></a><br><h2>  <b>Water</b> Segmentation Segmentation Algorithm <b>(WaterShed)</b> </h2><br><img src="https://habrastorage.org/files/b40/406/622/b404066220ae40729682db0b2dec473e.jpg"><br><br><img src="https://habrastorage.org/files/4a4/0f6/e1e/4a40f6e1e7e84ca9bc23ed47219e160e.jpg"><br><br>  The algorithm works with an image as with a function of two variables <i><b>f = I (x, y)</b></i> , where <i><b>x, y</b></i> are the coordinates of a pixel: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/231/d1b/237/231d1b2379ce4d3ebffbee72c5aa4843.jpg"><img src="https://habrastorage.org/files/29e/319/da2/29e319da25364ecea5ee135f6fc0f70b.jpg"><img height="250" width="250" src="https://habrastorage.org/files/427/c3d/bb9/427c3dbb9770434493dd6b818b4b5c22.jpg"><br><br>  The value of the function can be the intensity or modulus of the gradient.  For the greatest contrast, you can take a gradient from the image.  If the absolute value of the gradient is plotted along the <i><b>OZ</b></i> axis, then ridges form at the places of intensity drop, and plains in homogeneous regions.  After finding the minima of the function <i><b>f</b></i> , there is a process of filling with ‚Äúwater‚Äù, which begins with a global minimum.  As soon as the water level reaches the value of the next local minimum, its filling with water begins.  When the two regions begin to merge, a partition is built to prevent the regions from merging [2].  The water will continue to rise until the regions are separated only by artificially constructed partitions (Fig. 1). <br><br><img height="250" width="250" src="https://habrastorage.org/files/ee2/fa7/7cf/ee2fa77cfd104aa599f25d0de1d8f948.jpg"><img height="250" width="250" src="https://habrastorage.org/files/d35/b2c/111/d35b2c1116d6484893c63135b2ad17bd.jpg"><img height="250" width="250" src="https://habrastorage.org/files/e60/aad/082/e60aad0827824b078e195900d29dd5b7.jpg"><br>  <font color="3C752A"><i>Fig.1.</i></font>  <font color="3C752A"><i>Illustration of the water filling process</i></font> <br><br>  Such an algorithm can be useful if there are a small number of local minima in the image, and in the case of a large number of them there is an excessive splitting into segments.  For example, if you directly apply the algorithm to fig.  2, we obtain many small parts of fig.  3 <br><br><img src="https://habrastorage.org/files/32c/8e4/237/32c8e42377154175883228dcb9bef93b.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>2. Original image</i></font> <br><br><img src="https://habrastorage.org/files/a47/0cb/63c/a470cb63c7034f68bccb12f36131a70b.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>3. Image after segmentation with <b>WaterShed</b> algorithm</i></font> <br><br><div class="spoiler">  <b class="spoiler_title">How to cope with small details?</b> <div class="spoiler_text">  To get rid of the excess of small parts, you can specify areas that will be tied to the nearest minimum.  The partition will be built only if the two regions merge with the markers, otherwise merging of these segments will occur.  This approach removes the effect of redundant segmentation, but requires pre-processing of the image to highlight markers that can be labeled interactively in the image in Fig.  4, 5. <br><br><img src="https://habrastorage.org/files/640/faa/f4a/640faaf4a7524a238ec78a91c456072b.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>4. Image with markers</i></font> <br><br><img src="https://habrastorage.org/files/ac6/bc3/7fb/ac6bc37fb3464ed385a0dead9effcd00.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>5. Image after segmentation with <b>WaterShed</b> using markers</i></font> <br><br>  If it is required to act automatically without user intervention, then you can use, for example, the <a href="http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html%3Fhighlight%3Dfindcontours"><i><b>findContours ()</b></i></a> function to select markers, but here, too, for better segmentation, small contours should be deleted.  6., for example, removing them along the threshold along the contour length.  Or, before separating outlines, use dilated erosion to remove small parts. <br><br><img src="https://habrastorage.org/files/249/fd5/240/249fd52400a143e4b0c9b955dbd424a8.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>6. As the markers were used contours having a length above a certain threshold.</i></font> <br></div></div><br>  As a result of the algorithm, we get a mask with a segmented image, where the pixels of one segment are marked with the same label and form a connected area.  The main disadvantage of this algorithm is the use of a preprocessing procedure for images with a large number of local minima (images with a complex texture and with an abundance of different colors). <br><br><div class="spoiler">  <b class="spoiler_title">Sample code to run the algorithm:</b> <div class="spoiler_text"><pre><code class="cpp hljs">Mat image = imread(<span class="hljs-string"><span class="hljs-string">"coins.jpg"</span></span>, CV_LOAD_IMAGE_COLOR); <span class="hljs-comment"><span class="hljs-comment">//   Mat imageGray, imageBin; cvtColor(image, imageGray, CV_BGR2GRAY); threshold(imageGray, imageBin, 100, 255, THRESH_BINARY); std::vector&lt;std::vector&lt;Point&gt; &gt; contours; std::vector&lt;Vec4i&gt; hierarchy; findContours(imageBin, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE); Mat markers(image.size(), CV_32SC1); markers = Scalar::all(0); int compCount = 0; for(int idx = 0; idx &gt;= 0; idx = hierarchy[idx][0], compCount++) { drawContours(markers, contours, idx, Scalar::all(compCount+1), -1, 8, hierarchy, INT_MAX); } std::vector&lt;Vec3b&gt; colorTab(compCount); for(int i = 0; i &lt; compCount; i++) { colorTab[i] = Vec3b(rand()&amp;255, rand()&amp;255, rand()&amp;255); } watershed(image, markers); Mat wshed(markers.size(), CV_8UC3); for(int i = 0; i &lt; markers.rows; i++) { for(int j = 0; j &lt; markers.cols; j++) { int index = markers.at&lt;int&gt;(i, j); if(index == -1) wshed.at&lt;Vec3b&gt;(i, j) = Vec3b(0, 0, 0); else if (index == 0) wshed.at&lt;Vec3b&gt;(i, j) = Vec3b(255, 255, 255); else wshed.at&lt;Vec3b&gt;(i, j) = colorTab[index - 1]; } } imshow("watershed transform", wshed); waitKey(0);</span></span></code> </pre> <br></div></div><br><h2>  <b>MeanShift</b> Segmentation <b>Algorithm</b> </h2><br>  MeanShift groups objects with similar attributes.  Pixels with similar features are combined into one segment, the output is an image with homogeneous areas. <br><br><img height="242" width="300" src="https://habrastorage.org/files/ed2/926/4a5/ed29264a51f640ea9b9b0df9de28f08f.jpg"><img height="242" width="300" src="https://habrastorage.org/files/85f/ab1/8e3/85fab18e3db949fc8510bf968b7fb3aa.jpg"><br><br>  For example, as coordinates <b><i>in feature space,</i></b> you can select pixel coordinates <b><i>(x, y)</i></b> and <b><i>RGB</i></b> pixel components.  By depicting pixels in the feature space, you can notice thickening in certain places. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/85f/fc0/f9d/85ffc0f9dad544cc97ffe860d4e6e583.png"></div><br><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>7. (a) Pixels in a two-dimensional feature space.</i></font>  <font color="3C752A"><i>(b) Pixels that came to one local maximum are painted in one color.</i></font>  <font color="3C752A"><i>(with)</i></font> <font color="3C752A"><i><img height="30" width="45" src="https://habrastorage.org/files/451/946/6bf/4519466bfe504e92aa4bb5ee3a90d304.png"></i></font>  <font color="3C752A"><i>- Density function, maxima correspond to the places of the highest pixel concentration.</i></font>  <font color="3C752A"><i>Picture taken from article [3].</i></font> <br><br>  To make it easier to describe point condensations, <b><i>a density function</i></b> is introduced: <img height="81" width="231" src="https://habrastorage.org/files/e9d/68b/32c/e9d68b32c2dd43838dce8c8c1b2cc0d0.png"><br><img height="28" width="30" src="https://habrastorage.org/files/bd7/53a/f56/bd753af56ff94f5895b4d9643c216f2c.png">  Is the feature vector of the <i><b>i-th</b></i> pixel, <i><b>d</b></i> is the number of features, <i><b>N</b></i> is the number of pixels, <i><b>h</b></i> is the parameter responsible for smoothness, <img height="30" width="60" src="https://habrastorage.org/files/1d1/cd3/21a/1d1cd321acfd4b50abd418400a59bacb.png">  - core.  Function maxima <img height="30" width="45" src="https://habrastorage.org/files/451/946/6bf/4519466bfe504e92aa4bb5ee3a90d304.png">  are located in the points of concentration of the image pixels in the feature space.  Pixels belonging to the same local maximum are combined into one segment.  It turns out, in order to find to which of the thickening centers the pixel belongs, one must step along the gradient <img height="30" width="45" src="https://habrastorage.org/files/451/946/6bf/4519466bfe504e92aa4bb5ee3a90d304.png">  to find the nearest local maximum. <br><br><div class="spoiler">  <b class="spoiler_title">Gradient Estimation of Density Function</b> <div class="spoiler_text">  To estimate the density function gradient, one can use the mean shift vector <img height="30" width="75" src="https://habrastorage.org/files/6dd/c9f/a1c/6ddc9fa1c02b4cd3b160e6cf94f6f155.png"><br>  As a core <img height="30" width="60" src="https://habrastorage.org/files/1d1/cd3/21a/1d1cd321acfd4b50abd418400a59bacb.png">  OpenCV uses the Epechnikov kernel [4]: <br><img src="https://habrastorage.org/files/3fc/a7a/5f7/3fca7a5f718c484ea553f5ce9a7849c2.png"><br><img height="31" width="48" src="https://habrastorage.org/files/5f8/dd0/4bb/5f8dd04bb2a04eb68da390c5e72a7b4e.png">  Is the volume of the <i><b>d-</b></i> dimensional sphere with a unit radius. <br><img src="https://habrastorage.org/files/5e5/786/58b/5e578658bc1547ac8e9bc2ea1442ae9d.png"><br><img height="41" width="113" src="https://habrastorage.org/files/f34/2e2/005/f342e20058274b209bf447417208584d.png">  means that the sum goes not for all pixels, but only for those that fall into a sphere of radius <b><i>h</i></b> with the center at the point where the vector points <img height="28" width="33" src="https://habrastorage.org/files/c61/32b/715/c6132b7158674a1ab80f546515af5878.png">  in the space of signs [4].  This is introduced specifically to reduce the amount of computation. <img height="36" width="60" src="https://habrastorage.org/files/d88/e63/9d5/d88e639d57cd4886b6f75dad55258876.png">  - the volume of the <i><b>d-</b></i> dimensional sphere with radius h. You can separately set the radius for the spatial coordinates and the radius separately in the color space. <img src="https://habrastorage.org/files/856/fa7/67e/856fa767ebb64997b210f6e2c645a869.png">  - the number of pixels that fall into the sphere.  Magnitude <img src="https://habrastorage.org/files/5ab/db9/16a/5abdb916a58a4b96baaf2ac398fb680d.png">  can be considered as an estimate of the value <img height="30" width="45" src="https://habrastorage.org/files/451/946/6bf/4519466bfe504e92aa4bb5ee3a90d304.png">  in the area of <img height="35" width="66" src="https://habrastorage.org/files/182/cab/e24/182cabe2481f4a20b14947a07b414624.png">  . <br><img src="https://habrastorage.org/files/979/354/961/9793549615ff4ed5b78d7151f020831b.png"><br><img src="https://habrastorage.org/files/412/684/30c/41268430c0fa4d43ba2173a1ed8aa725.png"><br>  Therefore, in order to walk along the gradient, it suffices to calculate the value <img height="30" width="75" src="https://habrastorage.org/files/6dd/c9f/a1c/6ddc9fa1c02b4cd3b160e6cf94f6f155.png">  - vector of the average shift.  It should be remembered that when choosing a different core, the mean shift vector will look different. <br></div></div><br>  When you select pixels as indications of coordinates and intensities in colors in one segment, pixels with similar colors and located close to each other will be combined.  Accordingly, if you select another feature vector, then the union of the pixels into segments will already go along it.  For example, if you remove the coordinates from the attributes, the sky and the lake will be considered as one segment, since the pixels of these objects in the attribute space would fall into one local maximum. <br><br>  If the object that we want to select consists of areas that differ greatly in color, then <b>MeanShift</b> will not be able to combine these regions into one, and our object will consist of several segments.  But well to cope with a uniform object in color on a variegated background.  More <b>MeanShift is</b> used in the implementation of the tracking algorithm for moving objects [5]. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code to run the algorithm:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Mat image = imread(<span class="hljs-string"><span class="hljs-string">"strawberry.jpg"</span></span>, CV_LOAD_IMAGE_COLOR); Mat imageSegment; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> spatialRadius = <span class="hljs-number"><span class="hljs-number">35</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> colorRadius = <span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pyramidLevels = <span class="hljs-number"><span class="hljs-number">3</span></span>; pyrMeanShiftFiltering(image, imageSegment, spatialRadius, colorRadius, pyramidLevels); imshow(<span class="hljs-string"><span class="hljs-string">"MeanShift"</span></span>, imageSegment); waitKey(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Result: <br><img height="316" width="444" src="https://habrastorage.org/files/d25/2fc/af1/d252fcaf138542529f2682f23661c776.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>8. Original image</i></font> <br><br><img height="316" width="444" src="https://habrastorage.org/files/7f2/dc9/f02/7f2dc9f029ac441fa52e1b8896daba40.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>9. After segmentation by <b>MeanShift</b> algorithm</i></font> <br></div></div><br><h2>  <b>FloodFill</b> segmentation <b>algorithm</b> </h2><br>  Using the <b>FloodFill</b> (fill or ‚Äúflood‚Äù method) you can select regions of uniform color.  To do this, select the starting pixel and set the interval for changing the color of neighboring pixels relative to the original.  The interval can be asymmetric.  The algorithm will combine the pixels into one segment (filling them with one color) if they fall within the specified range.  The output will be a segment filled with a certain color, and its area in pixels. <br><br>  Such an algorithm can be useful for filling a region with weak color differences with a uniform background.  One of the options for using <b>FloodFill</b> may be to identify the damaged edges of the object.  For example, if the algorithm fills the neighboring regions, filling the homogeneous areas with a certain color, then the integrity of the boundary between these areas is violated.  Below in the image you can see that the integrity of the borders of the filled areas is maintained: <br><img src="https://habrastorage.org/files/fbc/b9c/f8f/fbcb9cf8f52a4d958bdca8be7d2d6c6e.jpg"><img src="https://habrastorage.org/files/8d4/5e4/476/8d45e4476821422d94e24c77958a9610.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>10, 11. Original image and result after filling in several areas</i></font> <br><br>  And the following pictures show the version of the work of <b>FloodFill</b> in case of damage to one of the borders in the previous image. <br><br><img src="https://habrastorage.org/files/6cd/232/bd6/6cd232bd6f3b4b21b2aeb38693e336a4.jpg"><img src="https://habrastorage.org/files/a6f/c21/da8/a6fc21da82f64b48b29672e125f9e1e3.jpg"><br>  <font color="3C752A"><i>Fig.</i></font>  <font color="3C752A"><i>12, 13. Illustration of the work of <b>FloodFill</b> in violation of the integrity of the boundary between the poured areas</i></font> <br><br><div class="spoiler">  <b class="spoiler_title">Sample code to run the algorithm:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Mat image = imread(<span class="hljs-string"><span class="hljs-string">"cherry.jpg"</span></span>, CV_LOAD_IMAGE_COLOR); Point startPoint; startPoint.x = image.cols / <span class="hljs-number"><span class="hljs-number">2</span></span>; startPoint.y = image.rows / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-function">Scalar </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loDiff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">20</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">20</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Scalar </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upDiff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Scalar </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = <span class="hljs-number"><span class="hljs-number">8</span></span>; Rect domain; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = floodFill(image, startPoint, fillColor, &amp;domain, loDiff, upDiff, neighbors); rectangle(image, domain, Scalar(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); imshow(<span class="hljs-string"><span class="hljs-string">"floodFill segmentation"</span></span>, image); waitKey(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  The number of filled pixels is written to the <i>area</i> variable. <br>  Result: <br><img height="300" width="300" src="https://habrastorage.org/files/df1/b32/c82/df1b32c826f14e00a116fada71af9998.jpg"><img height="300" width="300" src="https://habrastorage.org/files/5c7/767/b20/5c7767b20e294e869e7d8e1243fb0589.jpg"><br></div></div><br><h2>  <b>GrabCut</b> segmentation <b>algorithm</b> </h2><br>  This is an interactive algorithm for selecting an object; it was developed as a more convenient alternative to the magnetic lasso (to select an object, the user needed to circle his path with the mouse).  For the algorithm to work, it is enough to enclose the object together with a part of the background in a rectangle (grab).  Segmentation of the object will occur automatically (cut). <br><br><img height="241" width="320" src="https://habrastorage.org/files/e65/888/b30/e65888b302b44bcfbc27a5141b2a682b.jpg"><img height="241" width="320" src="https://habrastorage.org/files/3aa/90e/96d/3aa90e96d87941979322b874fb22c22d.jpg"><br><br>  Difficulties may occur during segmentation if there are colors inside the bounding box that are found in large numbers not only in the object, but also in the background.  In this case, you can put additional labels of the object (red line) and background (blue line). <br><br><img height="241" width="320" src="https://habrastorage.org/files/862/567/db2/862567db2d4b4487b2e5e5f5767383b6.jpg"><img height="241" width="320" src="https://habrastorage.org/files/98d/d37/649/98dd376497974363910c702076d81389.jpg"><img src="https://habrastorage.org/files/767/f97/75c/767f9775c2fd4bfc826ac2ceff47ffc2.jpg"><br><br>  Consider the idea of ‚Äã‚Äãthe algorithm.  The basis is an algorithm of interactive segmentation GraphCut, where the user must put markers on the background and on the object.  The image is treated as an array. <img src="https://habrastorage.org/files/745/94a/f97/74594af97b3f48e293bac6ff7fb4bea4.png">  .  <b><i>Z</i></b> - the intensity values ‚Äã‚Äãof pixels, <i><b>N is the</b></i> total number of pixels.  To separate an object from the background, the algorithm determines the values ‚Äã‚Äãof the elements of the transparency array. <img src="https://habrastorage.org/files/6ca/cfd/5b1/6cacfd5b1fd1498abfb2c75bd4b16ccc.png">  , and <img src="https://habrastorage.org/files/b6b/af7/6b2/b6baf76b26ce43559c6fa15c447428ed.png">  may take two values ‚Äã‚Äãif <img src="https://habrastorage.org/files/b6b/af7/6b2/b6baf76b26ce43559c6fa15c447428ed.png">  <b><b>= 0</b></b> , then the pixel belongs to the background, if <img src="https://habrastorage.org/files/b6b/af7/6b2/b6baf76b26ce43559c6fa15c447428ed.png">  <b><i>= 1</i></b> , then the object.  Internal parameter <img src="https://habrastorage.org/files/131/a8b/70f/131a8b70f03c47529620ea3f4b9eb2fd.png">  contains a histogram of the foreground intensity distribution and a histogram of the background: <br><img src="https://habrastorage.org/files/d00/9fd/94f/d009fd94f84f4deea47aa5f55df51ada.png">  . <br>  Segmentation task - find unknowns <img src="https://habrastorage.org/files/b6b/af7/6b2/b6baf76b26ce43559c6fa15c447428ed.png">  .  The function of energy is considered: <br><img src="https://habrastorage.org/files/ddb/27e/ff9/ddb27eff972b4cecb0bb2bfd283bc6c6.png"><br>  Moreover, the minimum energy corresponds to the best segmentation. <br><img src="https://habrastorage.org/files/24f/d29/4ed/24fd294ed9b04df28941bf7605ca4b25.png"><br>  <b><i>V (a, z)</i></b> - the term is responsible for the connection between the pixels.  The sum goes over all pairs of pixels that are neighbors, <b><i>dis (m, n)</i></b> is the Euclidean distance. <img src="https://habrastorage.org/files/399/4de/0d7/3994de0d7a834c53ae5c267fb9d58b87.png">  responsible for the participation of pairs of pixels in the sum, if <i><b>a <sub>n</sub> = a <sub>m</sub></b></i> , then this pair will not be taken into account. <br><img height="30" width="100" src="https://habrastorage.org/files/c4a/419/359/c4a41935921b48cab6363c4e6a96ec26.png">  - is responsible for the quality of segmentation, i.e.  separation of the object from the background. <br><br>  Finding the global minimum of the energy function <b><i>E</i></b> , we get an array of transparency <img src="https://habrastorage.org/files/326/d4a/e05/326d4ae053dc4ac2be5bfe821c6ea2e4.png">  .  To minimize the energy function, the image is described as a graph and a minimal cut of the graph is sought.  Unlike GraphCut, in the <b>GrabCut</b> algorithm <b>,</b> pixels are considered in the RGB space, so the Gaussian Mixture Model (GMM) is used to describe color statistics.  The work of the <b>GrabCut</b> algorithm can be viewed by running the OpenCV sample <i><b><a href="">grabcut.cpp</a></b></i> . <br><br>  We considered only a small part of the existing algorithms.  As a result of segmentation, areas are selected in the image into which pixels are combined according to selected features.  <b>FloodFill is</b> suitable for filling objects of uniform color.  With the task of separating a particular object from the background, <b>GrabCut</b> will do <b>well</b> .  If you use the implementation of <b>MeanShift</b> from OpenCV, then pixels that are close in color and coordinates will be clustered.  <b>WaterShed is</b> suitable for images with a simple texture.  Thus, the segmentation algorithm should be chosen, of course, on the basis of a specific task. <br><br><h2>  Literature: </h2><br><ol><li>  G. Bradski, A. Kaehler Learning OpenCV: OReilly, second edition 2013 </li><li>  R. Gonzalez, R. Woods Digital Image Processing, Moscow: Technosphere, 2005. - 1072 p. </li><li>  D. Comaniciu, P. Meer Mean Shift: A Robust Approach Toward Feature Space Analysis.  IEEE Transactions on Pattern Analysis and Machine Intelligence, 2002, pp.  603‚Äì619. </li><li>  D. Comaniciu, P. Meer Mean shift analysis and applications, IEEE International Conference on Computer Vision, 1999, vol.  2, pp.  1197. </li><li>  D. Comaniciu, V. Ramesh, P. Meer Real-Time Tracking of Non-Rigid Objects Using Mean Shift, Conference on CVPR, 2000, vol.  2, pp.  1-8. </li><li>  S. Rother, V. Kolmogorov, A. Blake Grabcut - interactive foreground extraction using iterated graph cuts, 2004 </li><li>  <i><b><a href="https://github.com/Itseez/opencv/tree/master/samples/cpp">OpenCV samples</a></b></i> </li></ol><br></div><p>Source: <a href="https://habr.com/ru/post/266347/">https://habr.com/ru/post/266347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266337/index.html">Bleed TinyMCE 4</a></li>
<li><a href="../266339/index.html">How I tried to make friends with Google API with CodeIgniter A3M and what came of it</a></li>
<li><a href="../266341/index.html">The course "Basics of effective work with Wolfram technologies". Lesson 2.1: Introduction to the Wolfram Language, its features. The main difficulties of novice users. Work with the Mathematica interface and its capabilities</a></li>
<li><a href="../266343/index.html">Handling cloud traffic. Who needs network function virtualization (NFV)?</a></li>
<li><a href="../266345/index.html">A practical guide to hacking (and protecting) games on Unity</a></li>
<li><a href="../266349/index.html">Practical training in pentest laboratories. Part 1</a></li>
<li><a href="../266351/index.html">Battered banality. As a schoolboy bot wrote</a></li>
<li><a href="../266353/index.html">Ansible and Rails - flexible replacement for Capistrano while maintaining familiar comfort</a></li>
<li><a href="../266355/index.html">Firebase queue: steroids for firebase</a></li>
<li><a href="../266357/index.html">100 out of 100 in Google PageSpeed ‚Äã‚ÄãInsights (Bug or feature)?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>