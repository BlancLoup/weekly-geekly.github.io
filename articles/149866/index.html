<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Future WinRT or Going Native 2.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexandre Mutel is the creator of the fastest and most comprehensive .NET wrapper for DirectX, the only Windows 8 Metro support, R & D developer of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Future WinRT or Going Native 2.0</h1><div class="post__text post__text-html js-mediator-article">  <i>Alexandre Mutel is the creator of the fastest and most comprehensive .NET wrapper for DirectX, the only Windows 8 Metro support, R &amp; D developer of the game engine in SiliconStudio, a member of the French demo group FRequency.</i> <br><br>  Recently, we hear a lot of noise about the return of the idea of ‚Äã‚Äã"Going Native" after the era of controlled languages ‚Äã‚Äãsuch as Java and .NET.  Last year, when WinRT was only introduced, short-sighted comments began to appear that claimed that .NET was dead and C ++ was coming back in all its glory - the true and only sure way to develop applications, while JIT is starting increasingly appear in the world of scripting languages ‚Äã‚Äã(JavaScript uses the advantages of JIT most actively).  Any code will somehow become native before execution - the difference is only in the length of the path it takes to become native, and how optimized it will be.  The meaning of the word ‚Äúnative‚Äù has changed a little and has become inextricably linked with the word ‚Äúperformance.‚Äù  Even as a strong advocate for a managed language [C #], its performance is actually lower than a well-written C ++ application.  So, we just have to accept this fact and return to C ++, when such things as WinRT will be the basis for inter-language interaction for us?  In truth, I would like .NET to die, and this post is about why and why. <br><a name="habracut"></a><br><h4>  The era of controlled languages </h4><br>  Let's review the recent development history in managed languages ‚Äã‚Äãand note current problems.  Remember the Java slogan?  "Write once runs everywhere."  It was a presentation of a new paradigm, when a completely ‚Äúsecure‚Äù language based on a virtual machine, associated with a rich set of APIs, would make it possible to easily develop applications for any OS and platform.  This was the beginning of the era of controlled languages.  While Java was quite successfully adopted in various development areas, it was also rejected by many developers who were aware of the memory management features, the insufficiently optimized JIT (although everything has improved significantly since), a huge number of poor architectural solutions, such as the lack of support of structures, direct access to memory, and calls to native code through JNI were extremely inefficient and time consuming (and even <a href="http://marxsoftware.blogspot.jp/2011/10/javaone-2011-from-java-se-2012-to-java.html">recently</a> they considered the possibility of removing all native object types and making  all object - what a terrible idea!). <br><br>  Also, Java failed to fulfill the promise made in the slogan itself - in fact, it is impossible to cover all the capabilities of each platform with a single API, which led to things like Swing - to put it mildly, the most unimportant UI framework.  Also, Java was originally designed for a single programming language, although many saw in JIT and bytecode the ability to port scripting languages ‚Äã‚Äãto Java JVM. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the beginning of the managed language era, Microsoft tried to enter the Java market with its own language extensions (everyone knows about the end of this story) and eventually got its own platform for managed languages, which in some aspects was better designed and put together: starting from bytecode, the key word unsafe, calling native code, lightweight but very effective JIT and NGEN, the rapidly developing language C #, C ++ / CLI, etc. Initially given interlanguage interaction without the burden of Java slogan (although Silverlight on MacOS or Moonlight were quite good  Attempts). <br><br>  Both platforms used a similar monolithic stack: metadata, bytecode, JIT, and the garbage collector are all closely related.  Accordingly, there were similar problems with performance: JIT implies a delay at startup, and code execution is not as fast as it should be.  Main reasons: <br><br><ul><li>  JIT performs insufficient optimizations in comparison with C ++ -O2, because it must generate code very quickly (also, unlike the Java HotSpot JVM, the .NET JIT cannot replace existing code with more optimized code on the fly). </li><li>  .NET types, such as Array, always do border checks on access (apart from simple cycles, where the JIT can take away checks if the loop termination condition is less than or equal to the length of the array). </li><li>  The garbage collector stops all threads during the build (although the new garbage collector in .NET 4.5 <a href="http://blogs.msdn.com/b/dotnet/archive/2012/07/20/the-net-framework-4-5-includes-new-garbage-collector-enhancements-for-client-and-server-apps.aspx">improved</a> somewhat in this respect), which can lead to unpredictable performance drops. </li></ul><br>  But even with such insufficient productivity, a managed ecosystem with a universal framework is the king of productivity and inter-language interaction, with decent overall performance for all supported languages.  The culmination of the era of managed languages ‚Äã‚Äãwas probably the launch of WindowsPhone and VisualStudio 2010 (which used WPF to render the interface, although WPF itself worked on top of a decent amount of native code).  Managed languages ‚Äã‚Äãwere the only way to develop applications at that time.  This was not the best thing that could have happened, given the long list of unresolved .NET performance problems, long enough to encourage ‚Äúnative developers‚Äù to strike back, and they had every right to do so. <br><br>  So it turned out that this means in a sense, the rejection of .NET.  I don‚Äôt know so much about Microsoft‚Äôs internal kitchen, but judging by the frequent reports, there is a lot of confrontation between departments.  Good or bad, but for .NET in recent years it seems that Microsoft is running out of heat (for example, there are practically no significant improvements in JIT / NGEN, many unresolved performance improvement requests, including such things as SIMD developers are waiting for already very long).  And it seems to me that all these changes are possible only if .NET is a global strategy and with the strong support and participation of all departments. <br><br>  At the same time, Google began to promote its technology NativeClient, which allows you to run native code in the sandbox directly from the browser.  Last year, following the trend of ‚ÄúGoing Native‚Äù, Microsoft announced that even HTML5, designed for the next IE, will be native!  Sic. <br><br>  In ‚Äú <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/">Reader Q &amp; A: When will better JITs save managed code?</a> ‚Äù Herb Sutter, one of the evangelists ‚ÄúGoing Native‚Äù, argues some interesting arguments that the philosophy of ‚ÄúGoing Native‚Äù thinks about JIT (‚Äú <a href="http://tirania.org/blog/archive/2012/Apr-04.html">Can JITs be faster?</a> ‚Äù post Miguel de Icaza) with a lot of inaccurate facts, but let's just consider the key: even if JIT gets better in the future, managed languages ‚Äã‚Äãhave already made a choice between performance and security in favor of security.  Thus, the way to the big leagues has already been ordered for them. <br><br>  And at this moment WinRT appears, which smooths sharp corners a bit.  Using part of the .NET philosophy (metadata and some common types, such as strings and arrays) and the good old COM model (as a common denominator for native interlanguage interaction), WinRT tries to solve language interaction problems outside the CLR world (which means no loss of performance C ++) and provide a more modern API for the OS.  Is this the answer to the main question of life, the universe and all that?  Not really.  For WinRT, they chose a course for a clear convergence of technologies, which could potentially lead to great things, but so far there is no certainty about the right choice of path.  But what could be the ‚Äúright way‚Äù? <br><br><h4>  Going Native 2.0 - Performance for All </h4><br>  Security checks can have a negative impact on performance, but managed code is not doomed to run all its life only on top of a slow JIT (for example, Mono can run C # code natively compiled via LLVM on iOS / Linux) and it would be fairly easy to extend bytecode with unsafe instructions provide a controlled improvement in performance (such as canceling array bounds checking). <br><br>  But the most obvious problem now is the lack of a strong infrastructure for interlanguage compilers.  Starting with the compiler used in IE 10 JavaScript JIT,. NET JIT and NGE compilers, Visual C ++ compiler (and many others) - they all use different code for almost the same time-consuming and complex task - generating efficient machine code.  Having a single compiler is a very important step to provide high-performance code available for all languages. <br><br>  Felix9 on Channel9 <a href="http://channel9.msdn.com/Forums/Coffeehouse/MS-working-on-a-same-compiler-for-C-AND-C--Not-in-incubation-but-for-production-">found</a> that Microsoft can actually work on this problem.  This is definitely good news, but the problem of ‚Äúproductivity for all‚Äù is only a small part of the big picture.  In fact, the ‚Äúright path‚Äù mentioned earlier is a broader integrated architecture, not only an improved <a href="http://llvm.org/">LLVM</a> stack, but supported by Microsoft‚Äôs many years of experience in various areas (C ++ compiler, JIT, garbage collection, metadata, etc.) which will provide a <b>fully expandable and modular "CLR"</b> consisting of: <br><br><ul><li> <b>Intermediate language intermediate level</b> .  Supportive reflection, very similar to LLVM IR or .NET bytecode, defining common data types (primitives, strings, arrays, etc.).  An API similar to System.Reflection.Emit should be available.  Vectorized types (SIMD) must be the same basic types as int and double.  The IL code should not be limited only to the CPU, but also should allow for computations on the GPU (as AMP extensions for C ++ do).  It should be possible to present HLSL bytecode using this IL, taking advantage of the common compiler infrastructure (see below).  A typeless IL should also be available to make it easier to transfer dynamic programming languages ‚Äã‚Äãto it. </li><li>  <b>Dynamically linked libraries and executable files, such as .NET assemblies, providing metadata, IL code</b> that supports reflection.  During development, the code must be associated with assemblies (IL code), and not with obsolete C / C ++ header files. </li><li>  <b>A compiler from IL to machine code</b> , which can be integrated into a JIT, desktop application or cloud compiler, or a combination of all of this.  This compiler should provide vectorization as much as the target platform supports.  IL code must be compiled into machine code during installation or deployment, using information about the system architecture (during development this can be done immediately after compiling into IL).  Compilation steps should be accessible through the API and should provide extension points wherever possible (providing access to the IL, optimizing the IL, or embedding your own transformations from the IL into the machine code).  Optimization settings should range from fast compilation (like JIT) to aggressive optimization (pre-compiled applications or hot-swappable JIT code to more productive ones).  An application profile can also be used to automatically tune localized optimizations.  This compiler must support advanced JIT scripts, such as dynamic code analysis, On Stack Replacement (OSR, allowing code replacement for complex calculations to more optimal code at runtime), unlike the current .NET JIT compiler, which compiles the method in the time of its first launch.  Optimizations of this kind are very important in dynamic scenarios, when type inference (type inference) occurs after compilation (as in the case of Javascript). </li><li>  <b>An extensible memory allocator that allows parallel allocations.</b>  <b>The garbage collector will be one of the possible implementations</b> .  Most applications will use it for most objects, while most performance-critical objects will use other memory allocation strategies (such as reference counting used in COM / WinRT).  There should be no restrictions on using multiple memory allocation strategies in one application (this is what happens in .NET when an application has to resort to using calls to native functions to create objects outside the CLR). </li></ul><br><br>  The idea is very close to the CLR stack, but it does not force applications to run on top of the JIT compiler (yes, there is NGEN in .NET, but it was designed to speed up loading, not to speed up overall work, besides it is a black box and it works only with assemblies installed in the GAC) and allows mixed memory allocation strategies: using and without the garbage collector. <br><br>  In such a system, inter-language interaction will be simpler without sacrificing performance for the sake of simplicity and vice versa.  Ideally, the OS itself should be built on the basis of a similar architecture.  Perhaps this idea was (is?) At the heart of projects such as <a href="http://www.zdnet.com/blog/microsoft/microsoft-codename-redhawk-lives-in-windows-8/9233">Redhawk</a> (this is for the compiler) or <a href="http://www.zdnet.com/blog/microsoft/goodbye-xp-hello-midori/1466">Midori</a> (for the OS).  In such an integrated system, it is possible that only drivers will require direct access to the hardware. <br><br>  Felix9 also <a href="http://channel9.msdn.com/Forums/Coffeehouse/MS-patent-Optimizer-as-an-AppStore-Service-Cloud-JIT-/c539c486cf914d3ab718a0a700fb473e">unearthed</a> that an intermediate bytecode, lower-level than MSIL (.NET bytecode), called MDIL, can already be used and it can be exactly the intermediate bytecode described earlier.  Although, if you look at the corresponding patent " <a href="http://www.freepatentsonline.com/y2011/0258616.html">INTERMEDIATE LANGUAGE SUPPORT FOR CHANGE RESILIENCE</a> ", then in the specification you can find x86 instructions that do not quite fall under the definition of an architecturally independent bytecode.  Perhaps they will leave MSIL unchanged and use MDIL at a lower level.  We will find out soon. <br><br>  So, what problems does WinRT solve from this point of view?  Metadata, some APIs that support sandboxes and interlanguage interaction in the embryonic stage (although there are common data types and metadata).  As you can see, not a lot, such a COM ++.  It is also obvious that <b>WinRT does not provide advanced optimizations when we use its API</b> .  For example, we are not allowed to have a structure with inline methods.  Each method call in WinRT is a virtual call that will go through the virtual method table (and in some cases it takes several virtual calls when, for example, a static method is used).  The simplest read-write properties will require a virtual call.  This is clearly ineffective.  Apparently, WinRT focuses only on higher-level APIs, not allowing scripts in which we would like to use high-performance code wherever possible, bypassing the layer of virtual calls and non-embeddable code.  As a result, we have an extended COM model - this is not exactly what could be called ‚ÄúBuilding the Future‚Äù. <br><br><h4>  Productivity and performance for C # 5.0 </h4><br>  A language like C # would be an ideal candidate for such a modular CLR system, and could easily be transferred to an already existing intermediate bytecode.  But in order to effectively use a similar system, C # needs to be improved in several ways: <br><br><ul><li>  <b>More unsafe constructions</b> , when we could turn off "controlled" behavior like checking array boundaries (like "super insecure mode", when we could use caching instructions in the CPU to access array elements, this kind of "advanced" things cannot be done with managed arrays without the use of undocumented tricks). </li><li>  <b>Configurable new operator</b> that supports different memory allocation schemes. </li><li>  <b>Vectorized types</b> (like float4 in HLSL) should be added to base types.  This has long been asked for (with horrible patches in XNA WP to "solve" this problem). </li><li>  <b>Lightweight interaction with native code</b> : in the current state, the transition from managed to unmanaged code is quite expensive, even without transferring any parameters.  The transition to unmanaged code should be possible without the x86 / x64 prologue / epilogue instructions that are now generated in the .NET JIT. </li></ul><br><br>  In addition to performance, there are other equally important areas: <br><br><ul><li>  <b>Generic (generics) everywhere</b> - in constructors and implicit type conversions, with more advanced constructions (contracts for operators, etc.), closer to the flexibility of C ++ templates, but safer and less cluttered. </li><li>  <b>Inheritance and finalizers in structures</b> (to allow the execution of lightweight code when completing a method without using cumbersome patterns like try / finally and using). </li><li>  <b>More metaprogramming</b> .  Extension methods for static types, impurities (adding class content to another class, convenient for things like mathematical functions), modifying classes / types / methods at compile time (for example, methods that would be called at compile time to add other methods or properties to class, something like <a href="http://stackoverflow.com/questions/1630815/why-isnt-the-eigenclass-equivalent-to-self-class-when-it-looks-so-similar">eigenclass in Ruby</a> , instead of using T4 templates to generate code). </li><li>  <b>A built-in literal or type that could express a link to a language object</b> (class, property, method) using a simple construct like: symbol LinkToMyMethod = <nobr>@ MyClass.MyMethod;</nobr>  instead of using Linq expressions.  This would make more reliable code for things like INotifyPropertyChanged or simplify all property-based systems like WPF (which in its current state contains a lot of duplicate code). </li></ul><br><br>  The basic idea is that <b>you need to add less to C # than to remove from C ++ in order to fully utilize the capabilities of such an integrated system, increase developer productivity and without attendant performance losses</b> .  Some may argue that C ++ already offers all this and even more, but that is why C ++ is so cluttered (in terms of syntax) and dangerous for most developers.  It allows unsafe code absolutely everywhere, while every application has quite specific places where it is really needed (which leads to memory problems that are easier to fix if these places were clearly marked in the code, as is done with the key the word asm).  It is much easier and safer to keep track of these areas in the code than to have them everywhere. <br><br><h4>  What next? </h4><br>  We hope that Microsoft has chosen the path from the general to the particular and started with the release of WinRT, which provides a universal API for all languages ‚Äã‚Äãand simple inter-language interaction.  And then they will present all these more advanced features in the next versions of their OS.  But this is the ideal situation and it will be interesting to see if Microsoft can handle this.  Even if the recently announced that .NET applications in WP8 will have compilation benefits in the cloud, we still know little about it: it‚Äôs just an adapted NGEN (which, I remind you, is not performance oriented and generates code very similar to that generates JIT) or not yet introduced RedHawk compiler? <br><br>  Microsoft probably has something in store, considering the many years of development of C ++ compilers, JIT, garbage collector and all related R &amp; D projects that they have ... <br><br>  To summarize, .NET should die and give way to a more integrated, performance-oriented, shared environment, where managed (security and productivity) and unmanaged (performance) would be closely related.  And this should be a structural part of the next round of WinRT development. </div><p>Source: <a href="https://habr.com/ru/post/149866/">https://habr.com/ru/post/149866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149861/index.html">More than a watch: a review of the Sony SmartWatch</a></li>
<li><a href="../149862/index.html">Latin America on the side of Ecuador</a></li>
<li><a href="../149863/index.html">A selection of CSS3 generators to simplify front-end development</a></li>
<li><a href="../149864/index.html">Menu with smooth color inversion</a></li>
<li><a href="../149865/index.html">DVR AdvoCam FD3, a detailed review</a></li>
<li><a href="../149867/index.html">Core Data in iOS 5: how to load and import existing data</a></li>
<li><a href="../149868/index.html">Ubuntu One, we get 20GB for free</a></li>
<li><a href="../149869/index.html">The story of one "hack" or "forced" restoration of Navigon with reference to Android smartphone</a></li>
<li><a href="../149870/index.html">Google is working on the possibility of Android updates without the participation of manufacturers</a></li>
<li><a href="../149871/index.html">Xperia SL. Sony's Next Generation Smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>