<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Embedding into the Linux kernel: intercepting system calls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The term "system call" in programming and computing refers to the application program to the core of the operating system (OS) to perform any operatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Embedding into the Linux kernel: intercepting system calls</h1><div class="post__text post__text-html js-mediator-article">  The term "system call" in programming and computing refers to the application program to the core of the operating system (OS) to perform any operation.  Since this interaction is the main one, interception of system calls seems to be the most important stage of embedding, since  allows you to control a key component of the OS kernel ‚Äî the system call interface, which, in turn, makes it possible to inspect application requests for kernel services. <br><br>  This article is a continuation of the <a href="http://habrahabr.ru/company/securitycode/blog/230697/">previously announced cycle</a> , dedicated to the particular issues of the implementation of the imposed remedies, and, in particular, embedding in software systems. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  I. Approaches to embedding </h4><br><br>  There are various ways to intercept system calls to the Linux kernel.  First of all, it is worth noting that the method of interception of kernel functions discussed <a href="http://habrahabr.ru/company/securitycode/blog/237089/">earlier</a> can be used to intercept single system calls.  Indeed, due to the fact that most of the system calls are represented by the corresponding functions (for example, <a href="">sys_open</a> ), the task of intercepting them is equivalent to the task of intercepting these functions.  However, with an increase in the number of intercepted system calls and the increasing complexity of "business logic", this approach may be limited. <br><br>  A more universal way is to modify the entries in the system call tables (more details on the tables will be described later) containing pointers to functions that implement the logic of a particular system call.  The tables are used by the kernel during dispatching, when according to the number of the system call requested by the application, a pointer to the handler function is selected from the corresponding table with its subsequent execution.  Replacing such an index will change the logic of the kernel in handling system calls.  Looking ahead, it is worth noting that for the successful implementation of this method, the tables themselves will need to be somehow found, since  they are not exported.  Ultimately, intercepting the system call will consist in a simple redefinition of the table element. <br><br>  The most universal method of intercepting system calls was and remains modifying the code of the system call manager so that the pre- and post-processing of the context of the thread requesting any system service is provided.  This option gives greater flexibility in comparison with the previous ones, since  introduces a single point of state control before and after the handler function. <br><br>  Further, an <a href="https://github.com/milabs/kmod_hooking_sct">example</a> will be described in detail how to embed the Linux kernel into the system call interface, modifying the dispatchers code. <br><br><h4>  Ii.  System call dispatch in the Linux kernel </h4><br><br>  Dispatching system calls is a rather complicated process with a lot of nuances, however, many details will be omitted in this article, because, except for the dispatching process itself (fetching and executing a function corresponding to a system call), you don‚Äôt need to know anything to implement embedding . <br><br>  Traditionally, the Linux kernel supports the following system call features for the x86 architecture: <br><br><ul><li>  INT 80h instruction (32-bit interface, native call or emulation); </li><li>  SYSENTER instruction (32-bit interface, native call or emulation); </li><li>  SYSCALL instruction (64-bin interface, native call or emulation). </li></ul><br><br>  Below is an excellent illustration of the implementation of a system call, <a href="http://lwn.net/Articles/604515/">borrowed by</a> me, depending on the variant used: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c27/67a/161/c2767a161bea9de19632f8cfc0e521fa.png" alt="image"><br><br>  As you can see, 32-bit applications make system calls using INT 80h and SYSENTER, whereas 64-bit applications use SYSCALL.  At the same time, there is support for the ability to execute 32-bit code in a 64-bit environment (the so-called compatibility mode is emulation / compatibility mode; the kernel option is <code>CONFIG_IA32_EMULATION</code> ).  In this regard, there are 2 non-exportable tables in the kernel - <code>sys_call_table</code> and <code>ia32_sys_call_table</code> (available only for emulation mode), containing the addresses of functions that process system calls. <br><br>  In the general case, when all possible mechanisms are presented in the 64-bit kernel, there are 4 entry points that define what the logic of the corresponding dispatcher will be: <br><br><ul><li>  emulation of INT 80h, <a href="">ia32_syscall</a> (x86 / ia32 / ia32entry.S); </li><li>  SYSENTER emulation, <a href="">ia32_sysenter_target</a> (x86 / ia32 / ia32entry.S); </li><li>  SYSCALL32 emulation, <a href="">ia32_cstar_target</a> (x86 / ia32 / ia32entry.S); </li><li>  SYSCALL, <a href="">system_call</a> (x86 / kernel / entry_64.S). </li></ul><br><br>  One way or another, when an application makes a system call, the kernel gets control.  The system call manager for each of the cases examined has differences from the others, but without loss of generality, their overall structure can be examined using the example <a href="">system_call</a> : <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0xffffffff81731670</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: swapgs <span class="hljs-number"><span class="hljs-number">0xffffffff81731673</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;: mov %rsp,%gs:<span class="hljs-number"><span class="hljs-number">0xc000</span></span> <span class="hljs-number"><span class="hljs-number">0xffffffff8173167c</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">12</span></span>&gt;: mov %gs:<span class="hljs-number"><span class="hljs-number">0xc830</span></span>,%rsp <span class="hljs-number"><span class="hljs-number">0xffffffff81731685</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">21</span></span>&gt;: sti <span class="hljs-number"><span class="hljs-number">0xffffffff81731686</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">22</span></span>&gt;: data32 data32 xchg %ax,%ax <span class="hljs-number"><span class="hljs-number">0xffffffff8173168a</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">26</span></span>&gt;: data32 xchg %ax,%ax <span class="hljs-number"><span class="hljs-number">0xffffffff8173168d</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">29</span></span>&gt;: sub $<span class="hljs-number"><span class="hljs-number">0x50</span></span>,%rsp <span class="hljs-number"><span class="hljs-number">0xffffffff81731691</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">33</span></span>&gt;: mov %rdi,<span class="hljs-number"><span class="hljs-number">0x40</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff81731696</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">38</span></span>&gt;: mov %rsi,<span class="hljs-number"><span class="hljs-number">0x38</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff8173169b</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">43</span></span>&gt;: mov %rdx,<span class="hljs-number"><span class="hljs-number">0x30</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316a0</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">48</span></span>&gt;: mov %rax,<span class="hljs-number"><span class="hljs-number">0x20</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316a5</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">53</span></span>&gt;: mov %r8,<span class="hljs-number"><span class="hljs-number">0x18</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316aa</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">58</span></span>&gt;: mov %r9,<span class="hljs-number"><span class="hljs-number">0x10</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316af</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">63</span></span>&gt;: mov %r10,<span class="hljs-number"><span class="hljs-number">0x8</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316b4</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">68</span></span>&gt;: mov %r11,(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316b8</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">72</span></span>&gt;: mov %rax,<span class="hljs-number"><span class="hljs-number">0x48</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316bd</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">77</span></span>&gt;: mov %rcx,<span class="hljs-number"><span class="hljs-number">0x50</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316c2</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">82</span></span>&gt;: testl $<span class="hljs-number"><span class="hljs-number">0x100801d1</span></span>,<span class="hljs-number"><span class="hljs-number">-0x1f78</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316cd</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">93</span></span>&gt;: jne <span class="hljs-number"><span class="hljs-number">0xffffffff8173181e</span></span> &lt;tracesys&gt; <span class="hljs-number"><span class="hljs-number">0xffffffff817316d3</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">0xbfffffff</span></span>,%eax <span class="hljs-number"><span class="hljs-number">0xffffffff817316d8</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;: cmp $<span class="hljs-number"><span class="hljs-number">0x220</span></span>,%eax <span class="hljs-comment"><span class="hljs-comment">/* &lt;-------- cmp $__NR_syscall_max,%eax */</span></span> <span class="hljs-number"><span class="hljs-number">0xffffffff817316dd</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;: ja <span class="hljs-number"><span class="hljs-number">0xffffffff817317a5</span></span> &lt;badsys&gt; <span class="hljs-number"><span class="hljs-number">0xffffffff817316e3</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">16</span></span>&gt;: mov %r10,%rcx <span class="hljs-number"><span class="hljs-number">0xffffffff817316e6</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: callq *<span class="hljs-number"><span class="hljs-number">-0x7e7fec00</span></span>(,%rax,<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* &lt;-------- call *sys_call_table(,%rax,8) */</span></span> <span class="hljs-number"><span class="hljs-number">0xffffffff817316ed</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">26</span></span>&gt;: mov %rax,<span class="hljs-number"><span class="hljs-number">0x20</span></span>(%rsp) <span class="hljs-number"><span class="hljs-number">0xffffffff817316f2</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: mov $<span class="hljs-number"><span class="hljs-number">0x1008feff</span></span>,%edi <span class="hljs-number"><span class="hljs-number">0xffffffff817316f7</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: cli <span class="hljs-number"><span class="hljs-number">0xffffffff817316f8</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;: data32 data32 xchg %ax,%ax <span class="hljs-number"><span class="hljs-number">0xffffffff817316fc</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;: data32 xchg %ax,%ax <span class="hljs-number"><span class="hljs-number">0xffffffff817316ff</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">-0x1f78</span></span>(%rsp),%edx <span class="hljs-number"><span class="hljs-number">0xffffffff81731706</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">15</span></span>&gt;: <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> %edi,%edx <span class="hljs-number"><span class="hljs-number">0xffffffff81731708</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">17</span></span>&gt;: jne <span class="hljs-number"><span class="hljs-number">0xffffffff81731745</span></span> &lt;sysret_careful&gt; <span class="hljs-number"><span class="hljs-number">0xffffffff8173170a</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x50</span></span>(%rsp),%rcx <span class="hljs-number"><span class="hljs-number">0xffffffff8173170f</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">24</span></span>&gt;: mov (%rsp),%r11 <span class="hljs-number"><span class="hljs-number">0xffffffff81731713</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">28</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x8</span></span>(%rsp),%r10 <span class="hljs-number"><span class="hljs-number">0xffffffff81731718</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">33</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x10</span></span>(%rsp),%r9 <span class="hljs-number"><span class="hljs-number">0xffffffff8173171d</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">38</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x18</span></span>(%rsp),%r8 <span class="hljs-number"><span class="hljs-number">0xffffffff81731722</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">43</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x20</span></span>(%rsp),%rax <span class="hljs-number"><span class="hljs-number">0xffffffff81731727</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">48</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x30</span></span>(%rsp),%rdx <span class="hljs-number"><span class="hljs-number">0xffffffff8173172c</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">53</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x38</span></span>(%rsp),%rsi <span class="hljs-number"><span class="hljs-number">0xffffffff81731731</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">58</span></span>&gt;: mov <span class="hljs-number"><span class="hljs-number">0x40</span></span>(%rsp),%rdi <span class="hljs-number"><span class="hljs-number">0xffffffff81731736</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">63</span></span>&gt;: mov %gs:<span class="hljs-number"><span class="hljs-number">0xc000</span></span>,%rsp <span class="hljs-number"><span class="hljs-number">0xffffffff8173173f</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">72</span></span>&gt;: swapgs <span class="hljs-number"><span class="hljs-number">0xffffffff81731742</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">75</span></span>&gt;: sysretq</code> </pre><br><br>  As you can see, the first instruction ( <code>swapgs</code> ) switches data structures (from user to nuclear).  Next, the stack is configured, interrupts are enabled, and the register context of the flow ( <code>pt_regs</code> structure) required during processing is formed on the stack.  Returning to the listing presented above, special attention should be paid to the following commands: <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0xffffffff817316d8</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;: cmp $<span class="hljs-number"><span class="hljs-number">0x220</span></span>,%eax <span class="hljs-comment"><span class="hljs-comment">/* &lt;-------- cmp $__NR_syscall_max,%eax */</span></span> <span class="hljs-number"><span class="hljs-number">0xffffffff817316dd</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">10</span></span>&gt;: ja <span class="hljs-number"><span class="hljs-number">0xffffffff817317a5</span></span> &lt;badsys&gt; <span class="hljs-number"><span class="hljs-number">0xffffffff817316e3</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">16</span></span>&gt;: mov %r10,%rcx <span class="hljs-number"><span class="hljs-number">0xffffffff817316e6</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: callq *<span class="hljs-number"><span class="hljs-number">-0x7e7fec00</span></span>(,%rax,<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* &lt;-------- call *sys_call_table(,%rax,8) */</span></span> <span class="hljs-number"><span class="hljs-number">0xffffffff817316ed</span></span> &lt;+<span class="hljs-number"><span class="hljs-number">26</span></span>&gt;: mov %rax,<span class="hljs-number"><span class="hljs-number">0x20</span></span>(%rsp)</code> </pre><br><br>  The first line checks whether the number of the requested system call (register <code>%rax</code> ) <code>%rax</code> maximum allowable value ( <code>__NR_syscall_max</code> ).  In the event that the check is successful, the system call will be dispatched, namely, the control will transfer to a function that implements the appropriate logic. <br><br>  Thus, a key point in the processing of system calls is the dispatch command, which is a function <code>call *sys_call_table(,%rax,8)</code> ( <code>call *sys_call_table(,%rax,8)</code> ).  Further embedding will be carried out by modifying this command. <br><br><h4>  Iii.  Embedding technique </h4><br><br>  As noted, a universal way of embedding in the dispatcher will be modifying its code in such a way as to ensure that the context of the flow can be controlled before it performs the function of implementing the system call logic (pre-processing), as well as after it has been executed (post-processing). <br><br>  In order to implement embedding in this way, it is proposed to slightly patch the dispatcher by modifying the dispatch command ( <code>call *sys_call_table(,%rax,8)</code> ), and write an unconditional branch command ( <code>JMP REL32</code> ) on it to the <code>service_stub</code> handler.  In this case, the general structure of such a handler will be as follows (hereinafter pseudocode): <br><br><pre> <code class="cpp hljs">system_call: swapgs .. jmp service_stub <span class="hljs-comment"><span class="hljs-comment">/* &lt;--------   call *sys_call_table(,%rax,8) */</span></span> mov %rax,<span class="hljs-number"><span class="hljs-number">0x20</span></span>(%rsp) <span class="hljs-comment"><span class="hljs-comment">/* &lt;--------     service_stub */</span></span> ... swapgs sysretq service_stub: ... call ServiceTraceEnter <span class="hljs-comment"><span class="hljs-comment">/* void ServiceTraceEnter(struct pt_regs *) */</span></span> ... call sys_call_table[N](args) ... <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceTraceLeave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(regs)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* void ServiceTraceLeave(struct pt_regs *) */</span></span></span><span class="hljs-function"> ... jmp back</span></span></code> </pre><br><br>  Here, <code>ServiceTraceEnter()</code> and <code>ServiceTraceLeave()</code> are the pre- and post-processing functions, respectively.  Their parameters are a pointer to a <code>pt_regs</code> - a register structure representing the stream context.  The final instruction is the command to transfer control to the system call manager code, from where the call to this handler was previously made. <br><br>  Below is the <a href="">service_syscall64</a> handler code used as an example for <code>system_call</code> interception (SYSCALL instruction): <br><br><pre> <code class="cpp hljs">.global service_syscall64 service_syscall64: SAVE_REST movq %rsp, %rdi call ServiceTraceEnter RESTORE_REST LOAD_ARGS <span class="hljs-number"><span class="hljs-number">0</span></span> movq %r10, %rcx movq ORIG_RAX - ARGOFFSET(%rsp), %rax call *<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>(,%rax,<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">// origin call movq %rax, RAX - ARGOFFSET(%rsp) SAVE_REST movq %rsp, %rdi call ServiceTraceLeave RESTORE_REST movq RAX - ARGOFFSET(%rsp), %rax jmp 0x00000000</span></span></code> </pre><br><br>  As can be seen, it has the structure considered above.  The exact values ‚Äã‚Äãof pointers and offsets are adjusted during the module loading process (this will be described below).  In addition, the above fragment contains additional elements ( <code>SAVE_REST</code> , <code>RESTORE_REST</code> , <code>LOAD_ARGS</code> ), the purpose of which is mainly to form a stream context ( <code>pt_regs</code> ) before calling the <code>ServiceTraceEnter</code> and <code>ServiceTraceLeave</code> . <br><br><h4>  Iv.  Features of embedding </h4><br><br>  The implementation of embedding into the dispatching mechanisms of the system calls of the Linux kernel somehow implies the need to solve the following practical tasks: <br><br><ul><li>  determining the addresses of system call managers; </li><li>  determining the addresses of the system call dispatch tables; </li><li>  modification code dispatchers; </li><li>  setting handlers; </li><li>  unloading module. </li></ul><br><br>  <b>Determining System Call Manager Addresses</b> <br><br>  The presence of several dispatchers in the system suggests the need to determine their addresses.  It was noted above that each dispatcher corresponds to his ‚Äúmethod‚Äù of making a request for a system call.  Therefore, appropriate mechanisms will be used to determine the required addresses: <br><br><ul><li>  INT 80h, reading the IDT table vector ( <a href="">more</a> info); </li><li>  SYSENTER, read the contents of the MSR register with the number MSR_IA32_SYSENTER_EIP ( <a href="">more</a> ); </li><li>  SYSCALL32, read the contents of the MSR register with the number MSR_CSTAR ( <a href="">more</a> ); </li><li>  SYSCALL, read the contents of the MSR register with the number MSR_LSTAR ( <a href="">more</a> ). </li></ul><br><br>  Thus, each of the desired addresses is easily determined. <br><br>  <b>Determining the addresses of the system call dispatch tables</b> <br><br>  As noted above, the <code>sys_call_table</code> and <code>ia32_sys_call_table</code> not exported.  There are different ways to determine their addresses, but by defining the addresses of dispatchers in the previous step, the addresses of the tables are also determined simply by searching for a dispatching instruction, which has the form <code>call sys_call_table[N]</code> . <br><br>  For these purposes it is rational to use the disassembler ( <a href="https://github.com/vmt/udis86">udis86</a> ).  By successively searching through the instructions, starting with the very first, you can reach the command you are looking for, whose argument is the address of the corresponding table.  Due to the fact that the structure of dispatchers is well-established, it is possible to unambiguously determine the characteristics of the command being searched for (CALL with a length of 7 bytes) and with a high degree of reliability obtain from it the required value of the address of the table. <br><br>  If for some reason this is not enough, you can enhance the verification of the received address.  To do this, for example, you can check whether the value in the cell with the number <code>__NR_open</code> expected table is equal to the address of the sys_open function.  However, in this example, such additional checks are not performed. <br><br>  <b>Dispatcher code modification</b> <br><br>  When modifying the code of system call managers, it is necessary to take into account the fact that their code is read-only (ReadOnly).  In addition, code modification on the working system should be carried out atomically, i.e.  so that during the modification process there are no undefined states when any of the threads sees a partially completed record. <br><br>  In a previous <a href="http://habrahabr.ru/post/207122/">article,</a> the correct way to write to write-protected pages using the creation of temporary mappings is discussed.  There is no need to repeat something here.  As for atomicity, this issue was also covered <a href="http://habrahabr.ru/company/securitycode/blog/237089/">earlier</a> , when the topic of interception of nuclear functions was considered. <br><br>  Thus, it is advisable to modify the write-protected code using temporary <a href="">mappings</a> , as well as a special interface of the Linux kernel - <code>stop_machine</code> . <br><br>  <b>Setting handlers</b> <br><br>  In accordance with the introduced embedding method, the code of each of the dispatchers is modified so that the 7-byte <code>CALL MEM32</code> dispatch <code>CALL MEM32</code> is replaced with the 5-byte unconditional branch command with the corresponding <code>JMP REL32</code> handler.  As a result, certain restrictions are imposed on the distance of the transition.  The handler must be located no further than ¬± 2 GB from the location of the <code>JMP REL32</code> . <br><br>  In accordance with the structure of the handlers, they contain commands (JMP and CALL) that require the specification of precise arguments (for example, return addresses or system call table addresses).  Due to the fact that such values ‚Äã‚Äãare not available at the stage of compilation or module loading, they must be put down ‚Äúmanually‚Äù, after loading, before starting work. <br><br>  Another important feature when setting up handlers is the need to ensure that the module can be unloaded while maintaining system health.  For these purposes, the handler code must remain in the system even after the main module is unloaded (more on this later). <br><br>  <b>Unloading module</b> <br><br>  Unloading of the module should be carried out with preservation of system performance.  This means that after the module has been unloaded, the system should function normally.  This task is not trivial due to the fact that with unloading the module, all the code used in it is unloaded. <br><br>  For example, one can imagine a situation that some thread performing a system call ‚Äúfell asleep‚Äù in the core.  Until the moment when he wakes up, someone is trying to unload the module.  In principle, nothing prevents to make this system.  As a result, when the thread in question wakes up and completes the requested system call, the control will return to the appropriate handler (which is why it should not be unloaded). <br><br>  However, the non-uploading of the handlers code is not the only condition for the preservation of the system operability after unloading the module.  It is worth recalling that the real system call in the handler was wrapped in a couple of calls to the <a href="">ServiceTraceEnter</a> and <a href="">ServiceTraceLeave</a> trace functions, the code of which was located in the unloaded module. <br><br>  Therefore, in order not to get into a situation where, on returning from a system call, the thread would try to call a function that is no longer physically needed, it is necessary to re-modify the code of each handler, eliminating invalid more calls from there (in other words, by filling them with NOPs). <br><br><h4>  V. Features of the implementation of the kernel module </h4><br><br>  The following describes the structure of the kernel module, which is embedded in the dispatching system of system calls of the Linux kernel. <br><br>  The key structure of the module is a <a href="">struct scentry</a> - a structure containing the information necessary for embedding into the corresponding dispatcher.  The structure contains the following fields: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scentry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *entry; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *table; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pcall; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pcall_map; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *stub; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *handler; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*prepare)(struct scentry *); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*implant)(struct scentry *); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*restore)(struct scentry *); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*cleanup)(struct scentry *); } <span class="hljs-keyword"><span class="hljs-keyword">scentry_t</span></span>;</code> </pre><br><br>  Structures are combined into an <a href="">array</a> that defines how and with what parameters to embed: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scentry_t</span></span> elist[] = { ... { .name = <span class="hljs-string"><span class="hljs-string">"system_call"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* SYSCALL: MSR(LSTAR), kernel/entry_64.S (1) */</span></span> .handler = service_syscall64, .prepare = prepare_syscall64_1 }, { .name = <span class="hljs-string"><span class="hljs-string">"system_call"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* SYSCALL: MSR(LSTAR), kernel/entry_64.S (2) */</span></span> .handler = service_syscall64, .prepare = prepare_syscall64_2 }, ... };</code> </pre><br><br>  With the exception of the indicated fields, the filling of the remaining elements of the structure occurs automatically ‚Äî the <code>prepare</code> function is responsible for this.  Below is <a href="">an example of the</a> implementation of the function to prepare for embedding a SYSCALL command in the manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service_syscall64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_syscall64_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scentry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *se)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* * searching for -- 'call *sys_call_table(,%rax,8)' * http://lxr.free-electrons.com/source/arch/x86/kernel/entry_64.S?v=3.13#L629 */</span></span> se-&gt;entry = get_symbol_address(se-&gt;name); se-&gt;entry = se-&gt;entry ? se-&gt;entry : to_ptr(x86_get_msr(MSR_LSTAR)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!se-&gt;entry) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; se-&gt;pcall = ud_find_insn(se-&gt;entry, <span class="hljs-number"><span class="hljs-number">512</span></span>, UD_Icall, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!se-&gt;pcall) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; se-&gt;table = to_ptr(*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(se-&gt;pcall + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }</code> </pre><br><br>  As you can see, the first attempt is to resolve the name of the character to its corresponding address ( <code>se-&gt;entry</code> ).  If it is not possible to determine the address in this way, the mechanisms specific to each dispatcher come into play (in this case, reading the MSR register with the number MSR_LSTAR). <br><br>  Further, for the found dispatcher, the dispatch command ( <code>se-&gt;pcall</code> ) is <code>se-&gt;pcall</code> and, if successful, the address used by the system call table manager is determined. <br><br>  The completion of the preparation phase is the creation of a handler code used by the dispatcher after it has been modified.  Below is the <a href="">stub_fixup</a> function that does this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixup_stub</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scentry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *se)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ud_t</span></span> ud; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(se-&gt;stub, <span class="hljs-number"><span class="hljs-number">0x90</span></span>, STUB_SIZE); ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, se-&gt;handler, STUB_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ud_disassemble(&amp;ud)) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *insn = se-&gt;stub + ud_insn_off(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *orig_insn = se-&gt;handler + ud_insn_off(&amp;ud); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(insn, orig_insn, ud_insn_len(&amp;ud)); <span class="hljs-comment"><span class="hljs-comment">/* fixup sys_call_table dispatcher calls (FF.14.x5.xx.xx.xx.xx) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Icall &amp;&amp; ud_insn_len(&amp;ud) == <span class="hljs-number"><span class="hljs-number">7</span></span>) { x86_insert_call(insn, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, se-&gt;table, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* fixup ServiceTraceEnter/Leave calls (E8.xx.xx.xx.xx) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Icall &amp;&amp; ud_insn_len(&amp;ud) == <span class="hljs-number"><span class="hljs-number">5</span></span>) { x86_insert_call(insn, insn, orig_insn + (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(orig_insn + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* fixup jump back (E9.xx.xx.xx.xx) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Ijmp &amp;&amp; ud_insn_len(&amp;ud) == <span class="hljs-number"><span class="hljs-number">5</span></span>) { x86_insert_jmp(insn, insn, se-&gt;pcall + <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } se-&gt;pcall_map = map_writable(se-&gt;pcall, <span class="hljs-number"><span class="hljs-number">64</span></span>); }</code> </pre><br><br>  As you can see, the main role of this function is to create a copy of handlers and then adjust them to actual addresses.  Here is also actively used disassembler.        -  .         <code>JMP REL32</code> ,   . <br><br>      <a href=""></a>    .            ( <code>JMP REL32</code> )      . <br><br>       <a href="">restore</a> ,       ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generic_restore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scentry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *se)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ud_t</span></span> ud; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!se-&gt;pcall_map) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, se-&gt;stub, STUB_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ud_disassemble(&amp;ud)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Icall &amp;&amp; ud_insn_len(&amp;ud) == <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(se-&gt;stub + ud_insn_off(&amp;ud), <span class="hljs-number"><span class="hljs-number">0x90</span></span>, ud_insn_len(&amp;ud)); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Ijmp) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } debug(<span class="hljs-string"><span class="hljs-string">" [o] restoring original call instruction %p (%s)\n"</span></span>, se-&gt;pcall, se-&gt;name); x86_insert_call(se-&gt;pcall_map, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, se-&gt;table, <span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre><br><br>  ,      5-  CALL     NOP',           .     . <br><br>   implant  restore     <code>stop_machine</code> ,        . <br><br>       <a href="">clenup</a> ,     ( <code>pcall_map</code> ). <br><br>    ,        <b></b>  ,   .    ,          . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thus, using the example, the basic principles of embedding the system kernel calls into the mechanism are analyzed, and the possibility of intercepting them is illustrated. </font></font><br><br><h4>  Vi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testing and debugging </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For testing purposes, intercept the system call </font></font><code>open(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Below is the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trace_syscall_entry</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">that implements this interception using the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ServiceTraceEnter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> handler </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_syscall_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> major, \ </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *filename = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (major == __NR_open || major == __NR_ia32_open) { filename = kmalloc(PATH_MAX, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!filename || strncpy_from_user(filename, (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __user *)a0, PATH_MAX) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; printk(<span class="hljs-string"><span class="hljs-string">"%s open(%s) [%s]\n"</span></span>, arch ? <span class="hljs-string"><span class="hljs-string">"X86_64"</span></span> : <span class="hljs-string"><span class="hljs-string">"I386"</span></span>, filename, current-&gt;comm); } out: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filename) kfree(filename); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceTraceEnter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pt_regs *regs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_IA32) trace_syscall_entry(<span class="hljs-number"><span class="hljs-number">0</span></span>, regs-&gt;orig_ax, \ regs-&gt;bx, regs-&gt;cx, regs-&gt;dx, regs-&gt;si); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_X86_64 </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> trace_syscall_entry(1, regs-&gt;orig_ax, \ regs-&gt;di, regs-&gt;si, regs-&gt;dx, regs-&gt;r10); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="https://github.com/milabs/kmod_hooking_sct"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font><font style="vertical-align: inherit;">assembled and loaded </font><font style="vertical-align: inherit;">by standard means:</font></font><br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/milabs/kmod_hooking_sct $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> kmod_hooking_sct $ make $ sudo insmod scthook.ko</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result </font></font><code>dmesg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the following information should appear </font><font style="vertical-align: inherit;">in the kernel log (command </font><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="bash hljs">[ 5217.779766] [scthook] <span class="hljs-comment"><span class="hljs-comment"># SYSCALL hooking module [ 5217.780132] [scthook] # prepare [ 5217.785853] [scthook] [o] prepared stub ffffffffa000c000 (ia32_syscall) [ 5217.785856] [scthook] entry:ffffffff81731e30 pcall:ffffffff81731e92 table:ffffffff81809cc0 [ 5217.790482] [scthook] [o] prepared stub ffffffffa000c200 (ia32_sysenter_target) [ 5217.790484] [scthook] entry:ffffffff817319a0 pcall:ffffffff81731a36 table:ffffffff81809cc0 [ 5217.794931] [scthook] [o] prepared stub ffffffffa000c400 (ia32_cstar_target) [ 5217.794933] [scthook] entry:ffffffff81731be0 pcall:ffffffff81731c75 table:ffffffff81809cc0 [ 5217.797517] [scthook] [o] prepared stub ffffffffa000c600 (system_call) [ 5217.797518] [scthook] entry:ffffffff8172fcb0 pcall:ffffffff8172fd26 table:ffffffff81801400 [ 5217.800013] [scthook] [o] prepared stub ffffffffa000c800 (system_call) [ 5217.800014] [scthook] entry:ffffffff8172fcb0 pcall:ffffffff8172ff38 table:ffffffff81801400 [ 5217.800014] [scthook] # prepare OK [ 5217.800015] [scthook] # implant [ 5217.800052] [scthook] [o] implanting jump to stub handler ffffffffa000c000 (ia32_syscall) [ 5217.800054] [scthook] [o] implanting jump to stub handler ffffffffa000c200 (ia32_sysenter_target) [ 5217.800054] [scthook] [o] implanting jump to stub handler ffffffffa000c400 (ia32_cstar_target) [ 5217.800055] [scthook] [o] implanting jump to stub handler ffffffffa000c600 (system_call) [ 5217.800056] [scthook] [o] implanting jump to stub handler ffffffffa000c800 (system_call) [ 5217.800058] [scthook] # implant OK</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proper interception processing </font></font><code>open(2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will result in the following messages in the same log:</font></font><br><br><pre> <code class="bash hljs">[ 5370.999929] X86_64 open(/usr/share/locale-langpack/en_US.utf8/LC_MESSAGES/libc.mo) [perl] [ 5370.999930] X86_64 open(/usr/share/locale-langpack/en_US/LC_MESSAGES/libc.mo) [perl] [ 5370.999932] X86_64 open(/usr/share/locale-langpack/en.UTF-8/LC_MESSAGES/libc.mo) [perl] [ 5370.999934] X86_64 open(/usr/share/locale-langpack/en.utf8/LC_MESSAGES/libc.mo) [perl] [ 5370.999936] X86_64 open(/usr/share/locale-langpack/en/LC_MESSAGES/libc.mo) [perl] [ 5371.001308] X86_64 open(/etc/login.defs) [cron] [ 5372.422399] X86_64 open(/home/ilya/.cache/awesome/<span class="hljs-built_in"><span class="hljs-built_in">history</span></span>) [awesome] [ 5372.424013] X86_64 open(/dev/null) [awesome] [ 5372.424682] I386 open(/etc/ld.so.cache) [skype] [ 5372.424714] I386 open(/usr/lib/i386-linux-gnu/libXv.so.1) [skype] [ 5372.424753] I386 open(/usr/lib/i386-linux-gnu/libXss.so.1) [skype] [ 5372.424789] I386 open(/lib/i386-linux-gnu/librt.so.1) [skype] [ 5372.424827] I386 open(/lib/i386-linux-gnu/libdl.so.2) [skype] [ 5372.424856] I386 open(/usr/lib/i386-linux-gnu/libX11.so.6) [skype] [ 5372.424896] I386 open(/usr/lib/i386-linux-gnu/libXext.so.6) [skype] [ 5372.424929] I386 open(/usr/lib/i386-linux-gnu/libQtDBus.so.4) [skype] [ 5372.424961] I386 open(/usr/lib/i386-linux-gnu/libQtWebKit.so.4) [skype] [ 5372.425003] I386 open(/usr/lib/i386-linux-gnu/libQtXml.so.4) [skype] [ 5372.425035] I386 open(/usr/lib/i386-linux-gnu/libQtGui.so.4) [skype] [ 5372.425072] I386 open(/usr/lib/i386-linux-gnu/libQtNetwork.so.4) [skype] [ 5372.425103] I386 open(/usr/lib/i386-linux-gnu/libQtCore.so.4) [skype] [ 5372.425151] I386 open(/lib/i386-linux-gnu/libpthread.so.0) [skype] [ 5372.425191] I386 open(/usr/lib/i386-linux-gnu/libstdc++.so.6) [skype] [ 5372.425233] I386 open(/lib/i386-linux-gnu/libm.so.6) [skype] [ 5372.425265] I386 open(/lib/i386-linux-gnu/libgcc_s.so.1) [skype] [ 5372.425292] I386 open(/lib/i386-linux-gnu/libc.so.6) [skype] [ 5372.425338] I386 open(/usr/lib/i386-linux-gnu/libxcb.so.1) [skype] [ 5372.425380] I386 open(/lib/i386-linux-gnu/libdbus-1.so.3) [skype] [ 5372.425416] I386 open(/lib/i386-linux-gnu/libz.so.1) [skype] [ 5372.425444] I386 open(/usr/lib/i386-linux-gnu/libXrender.so.1) [skype] [ 5372.425475] I386 open(/usr/lib/i386-linux-gnu/libjpeg.so.8) [skype] [ 5372.425510] I386 open(/lib/i386-linux-gnu/libpng12.so.0) [skype] [ 5372.425546] I386 open(/usr/lib/i386-linux-gnu/libxslt.so.1) [skype] [ 5372.425579] I386 open(/usr/lib/i386-linux-gnu/libxml2.so.2) [skype]</code> </pre><br><br>   ,     32-  (, Skype)    ,     ,   I386,    X86_64.  ,   <code>open(2)</code>      . <br><br><h4> VII.  Conclusion </h4><br><br>             Linux         ,     .             ,    ,  ,     .            . <br><br>    ,      ,   <a href="https://github.com/milabs/kmod_hooking_sct">github</a> . </div><p>Source: <a href="https://habr.com/ru/post/245539/">https://habr.com/ru/post/245539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245529/index.html">Payments via WebMoney and other benefits of the Timeweb affiliate program</a></li>
<li><a href="../245531/index.html">Code Review Process with Atlassian Stash</a></li>
<li><a href="../245533/index.html">Containers for Windows: 10 years before Microsoft</a></li>
<li><a href="../245535/index.html">Private library: information etiquette, preparation for large projects, lean manufacturing, space exploration</a></li>
<li><a href="../245537/index.html">Crowdsourcing translation of OWASP Testing Guide 4.0 has been launched into 30+ languages ‚Äã‚Äã(including Russian)</a></li>
<li><a href="../245545/index.html">Birch's hypothesis - Swinnerton-Dyer</a></li>
<li><a href="../245549/index.html">Multiple versions of php on the same server. suphp</a></li>
<li><a href="../245553/index.html">How we assemble DDBP: huge flywheels in data centers and emergency reserve facility for responsible objects</a></li>
<li><a href="../245557/index.html">Some interesting and useful things for web developer # 35</a></li>
<li><a href="../245559/index.html">New Year Promotion from Payler and Polonium Arts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>