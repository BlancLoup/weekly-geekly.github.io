<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AWS framework for serverless applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We decided to create a small framework for serverless web applications in AWS. It may be more correct to call this not a framework, but a blank - I do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AWS framework for serverless applications</h1><div class="post__text post__text-html js-mediator-article">  We decided to create a small framework for serverless web applications in AWS.  It may be more correct to call this not a framework, but a blank - I do not know.  But the bottom line is to create the foundation for the rapid development of serverless AWS applications.  The code is posted on <a href="https://github.com/gnemtsov/ab-erp">GitHub</a> and is open to any improvements, of which there are plenty to be. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6s/gf/s9/6sgfs9bi4pwuqwppkjeqaznmlty.png"></div><br>  The article will discuss how to develop and test serverless applications locally, about routing on the frontend and backend, about Amazon services and things like that.  Who cares, welcome under the cat! <br><a name="habracut"></a><br><h2>  Something like a preface </h2><br>  Until recently, the development of serverless applications was greatly complicated by the fact that there was no means for fully-fledged local testing of lambda functions and APIs.  When creating applications, you had to either work all the time online, editing the code in the browser, or constantly archive and upload the source code of lambda functions to the cloud. <br><br>  In the summer of 2017 there was a breakthrough.  AWS created a new simplified standard for CloudFormation templates, which they called the <a href="https://github.com/awslabs/serverless-application-model">Serverless Application Model</a> (SAM) and simultaneously launched the <a href="https://github.com/awslabs/aws-sam-local">sam-local</a> project.  First things first. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Amazon CloudFormation</b> is a service that allows you to describe all the AWS infrastructure you need for your application using a template file in JSON or YAML format.  This is a very, very handy thing.  Because without it, you need to manually create many of the necessary resources: Lambda functions, database, API, roles and policies ... <br><br>  With CloudFormation, the infrastructure can be drawn either in a special designer, or you can write it in the template with your hands.  In any case, the result is a template file, with which you can continue in a couple of clicks or with one command to raise everything that is needed for the application.  And then, if necessary, make changes to this template and apply them again with one command.  This makes supporting the application infrastructure much easier.  It turns out, infrastructure, as a code. <br><br>  CloudFormation is beautiful, its templates <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-reference.html">allow you to</a> describe almost 100% of AWS resources.  But because of its versatility, this is a rather ‚Äúverbose‚Äù format - templates can quickly grow to a decent size.  Realizing this and pursuing the goal to make the creation of serverless applications easier, AWS created a new <b>SAM</b> format. <br><br>  You can conditionally assume that the usual CloudFormation templates are written in a low-level language.  And SAM templates are in a high-level language, thus allowing you to describe the infrastructure of serverless applications using a simplified syntax.  SAM templates are transformed by CloudFront into regular templates with a layer. <br><br>  What is <b>sam-local</b> ?  This is a command line tool that allows you to work locally with serverless applications described by SAM templates.  Sam-local allows you to test lambda functions, generate events from various AWS services, run API Gateway, check SAM templates ‚Äî and all this locally! <br><br>  Sam-local uses the docker container to emulate the Gateway and Lambda APIs.  The principle of operation is as follows.  When running, sam-local searches for the SAM template file in the project folder.  It analyzes the template file and launches the resources allocated in the template in the docker-container: opens the API and connects the Lambda functions to them.  And the support is very close to the work of real lambda-functions (limits, the amount of memory used and the duration of execution are shown). <br><br>  It looks like this <br><br><pre><code class="bash hljs">Georgiy@Baltimore MINGW64 /h/dropbox/projects/aberp/lambda (master) $ sam <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> start-api --docker-volume-basedir /h/Dropbox/Projects/aberp/lambda <span class="hljs-string"><span class="hljs-string">"aberp"</span></span> ‚Üê[34mINFO‚Üê[0m[0000] Unable to use system certificate pool: crypto/x509: system root pool is not available on Windows 2018/04/04 22:33:49 Connected to Docker 1.35 ‚Üê[34mINFO‚Üê[0m[0001] Unable to use system certificate pool: crypto/x509: system root pool is not available on Windows 2018/04/04 22:33:50 Fetching lambci/lambda:nodejs6.10 image <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nodejs6.10 runtime... nodejs6.10: Pulling from lambci/lambda ‚Üê[1B06c3813f: Already exists ‚Üê[1B967675e1: Already exists ‚Üê[1Bdaa0d714: Pulling fs layer ‚Üê[1BDigest: sha256:56205b1ec69e0fa6c32e9658d94ef6f3f5ec08b2d60876deefcbbd72fc8cb12f52kB/2.052kBB Status: Downloaded newer image <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> lambci/lambda:nodejs6.10 ‚Üê[32;1mMounting index.handler (nodejs6.10) at http://127.0.0.1:3000/{proxy+} [OPTIONS GET HEAD POST PUT DELETE PATCH]‚Üê[0 m You can now browse to the above endpoints to invoke your <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span>. You <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> not need to restart/reload SAM CLI <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> working on your <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span>, changes will be reflected instantly/automatically. You only need to restart SAM CLI <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you update your AWS SAM template.</code> </pre> <br>  Further, a call to the local API and a call to the corresponding lambda-functions is displayed in the console in general as well, as the lambda-functions output information to the CloudWatch logs: <br><br><pre> <code class="bash hljs">2018/04/04 22:36:06 Invoking index.handler (nodejs6.10) 2018/04/04 22:36:06 Mounting /h/Dropbox/Projects/aberp/lambda as /var/task:ro inside runtime container ‚Üê[32mSTART RequestId: 9fee783c-285c-127d-b5b5-491bff5d4df5 Version: <span class="hljs-variable"><span class="hljs-variable">$LATEST</span></span>‚Üê[0m ‚Üê[32mEND RequestId: 9fee783c-285c-127d-b5b5-491bff5d4df5‚Üê[0m ‚Üê[32mREPORT RequestId: 9fee783c-285c-127d-b5b5-491bff5d4df5 Duration: 476.26 ms Billed Duration: 500 ms Memory S ize: 128 MB Max Memory Used: 37 MB ‚Üê[0m</code> </pre> <br>  Sam-local is still in the status of a public beta, but it seemed to me that it works quite stable. <br><br>  All this as a whole allows you to work on creating a serverless application on a local computer and this is no more difficult than creating traditional web applications. <br><br>  I can not fail to mention.  The sam-local has an analogue - this is the <a href="https://serverless.com/">Serverless framework</a> .  Serverless framework is quite popular, largely due to the fact that before there were no alternatives.  I have no particular experience of using it, but as far as I know, it does not provide such a complete local environment as sam-local.  Sam-local is developed in AWS itself, and a separate team of enthusiasts makes the serverless framework.  In favor of the serverless framework, however, it can be attributed to the fact that it allows you to make applications less tied to a specific vendor. <br><br><h2>  About the framework </h2><br>  As I already wrote, it is needed in order to provide a quick start when creating new serverless applications.  Currently, it only implements authorization on web tokens.  Next we plan to add error handling, work with forms and tabular data output, and set up a deployment mechanism.  In general, in order to be able to clone the AB-ERP repository in the future and quickly start working on applications. <br><br>  We create ERP-systems, therefore we called it <b>AB-ERP</b> by analogy with the names of our other products: <a href="https://ab-tasks.ru/">AB-TASKS</a> and <a href="https://ab-doc.com/">AB-DOC</a> .  At the same time, AB-ERP is not necessary for the creation of ERP systems, any serverless web applications can be made on the basis of it. <br><br>  The application has a frontend code and a backend code.  Accordingly, there are 2 folders in the project root: <b>lambda</b> (backend) and <b>public</b> (frontent): <br><br><pre> <code class="bash hljs">+---lambda | +---api | +---core \---public +---css | \---core +---img +---js | \---core \---views</code> </pre> <br>  AB-ERP works on the principle of a one-page web application (SPA).  When deploying an application, the frontend code will need to be placed in AWS S3 and configured in front of it by CloudFront.  This was described in my <a href="https://habrahabr.ru/company/abdoc/blog/349808/">previous article</a> on AB-DOC in the ‚ÄúDevelopment and Deployment‚Äù section. <br><br>  When deployed, the backend code will be loaded into the AWS Lambda service. <br><br>  AB-ERP uses MariaDB as its database.  MariaDB is deployed in the AWS RDS service.  If desired, AB-ERP can be reconfigured, for example, to work with AWS DynamoDB. <br><br>  User files will be stored in AWS S3. <br><br>  This is how the application architecture looks like: <br><br><img src="https://habrastorage.org/webt/sq/ws/cd/sqwscdnfg8k0t5lnezgybckpcc4.png"><br><br><h2>  Backend </h2><br>  At the moment everything is very, very simple.  Only one API Gateway resource and just one lambda function. <br><br>  This is how the SAM template looks like: <br><br><pre> <code class="hljs pgsql">AWSTemplateFormatVersion : <span class="hljs-string"><span class="hljs-string">'2010-09-09'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Transform</span></span>: AWS::Serverless<span class="hljs-number"><span class="hljs-number">-2016</span></span><span class="hljs-number"><span class="hljs-number">-10</span></span><span class="hljs-number"><span class="hljs-number">-31</span></span> Description: An example RESTful service Resources: ABLambdaRouter: <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: AWS::Serverless::<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> Properties: Runtime: nodejs6<span class="hljs-number"><span class="hljs-number">.10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> Events: ABAPI: <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: Api Properties: <span class="hljs-type"><span class="hljs-type">Path</span></span>: /{proxy+} <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span></code> </pre> <br>  In the SAM template, we see one of our resources, ABLambdaRouter, which is a lambda function.  ABLambdaRouter is called only by one ABAPI event that comes from the API. <br><br>  Our API Gateway resource accepts requests by any methods ( <b>ANY</b> ) to any paths in the URL: <b>/ {proxy +}</b> .  That is, in other words, acts as a normal two-way proxy.  Lambda-function, respectively, should take on the role of a router that will execute different code depending on the requests. <br><br><div class="spoiler">  <b class="spoiler_title">Code lambda-function (router)</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jwt = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jsonwebtoken'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//process.env.PROD and other env.vars are set in production only if(process.env.PROD === undefined){ process.env.PROD = 0; process.env.SECRET = 'SOME_SECRET_CODE_672967256'; process.env.DB_HOST = '192.168.1.5'; process.env.DB_NAME = 'ab-erp'; process.env.DB_USER = 'ab-erp'; process.env.DB_PASSWORD = 'ab-erp'; } //core modules const HTTP = require('core/http'); const DB = require('core/db'); //main handler exports.handler = (event, context, callback) =&gt; { context.callbackWaitsForEmptyEventLoop = false; let api; const [resource, action] = event.pathParameters['proxy'].split('/'); //OPTIONS requests are proccessed by API GateWay using mock //sam-local can't do it, so for local development we need this if(event.httpMethod === 'OPTIONS'){ return callback(null, HTTP.response()); } //require resource module try { api = require('api/' + resource)(HTTP, DB); } catch(e) { if (e.code === 'MODULE_NOT_FOUND') { return callback(null, HTTP.response(404, {error: 'Resource not found.'})); } return callback(null, HTTP.response(500)); } //call resource action if(api.hasOwnProperty(action)) { if(api[action].protected === 0){ api[action](event, context, callback); } else if (event.headers['X-Access-Token'] !== undefined) { let token = event.headers['X-Access-Token']; try { event.userData = jwt.verify(token, process.env.SECRET); api[action](event, context, callback); } catch(error) { return callback(null, HTTP.response(403, {error: 'Failed to verify token.'})); } } else { return callback(null, HTTP.response(403, {error: 'No token provided.'})); } } else { return callback(null, HTTP.response(404, {error: 'Action not found.'})); } }</span></span></code> </pre> <br></div></div><br>  The API has a two-level hierarchy: the first level is the module, the second level is the action.  URLs are as follows <b>api.app.com/module/action</b> .  The router function analyzes the <b>pathParameters of the</b> incoming request, tries to connect the required module from the <b>lambda / api</b> folder and further transfer the request to the desired function in this module. <br><br>  By default, functions in modules require authorization, so before calling a function from a module, our router checks for a valid token in the <b>X-Access-Token</b> request header.  If the token is valid, the function from the module will be called; if not, error 403 will be returned. <br><br>  Why did we choose this approach, instead of creating many individual API Gateway resources and many lambda functions?  First, and most importantly, ease of configuration, deployment, and the actual work with such an architecture.  Secondly, this approach minimizes cold starts of the function.  The fact is that if the function has no long calls, AWS deletes its container and then with a new call it takes more time to process the request. <br><br>  There are also disadvantages to this approach.  We will not be able to make any special settings for different API resources at the API Gateway level. <br><br>  Maybe someone has a question, why then do we need an API Gateway, why not contact lambda directly from the browser?  API Gateway provides many benefits.  It can work as a CDN, in Edge Optimized mode, there is a caching of answers, it can respond to OPTION requests itself without accessing the backend (MOCK integration) - all this significantly speeds up the application.  It also has DDOS protection and the ability to control traffic using restrictions.  Well, it also allows you to open API applications for third-party developers. <br><br><h2>  Frontend </h2><br>  For the frontend, we decided not to use ‚Äúbig‚Äù frameworks, like React, Vue.js or Angular.js, so we wrote a small router for our SPA application. <br><br>  The router stores the description of each page: which html-template and which css, js-files it needs.  When prompted to the page, the router loads all the necessary files in plain text, merges them and inserts them into the div-container of the application interface.  When inserted into a container, the JavaScript of the page being opened is executed. <br><br><div class="spoiler">  <b class="spoiler_title">Router code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ROUTER object const ROUTER = { pages: { "index": ["css/index.css", "views/index.html", "js/index.js"], "login": ["css/login.css", "views/login.html", "js/login.js"] }, open: function(page){ let self = this; $container.html(big_preloader_html); if(self.pages.hasOwnProperty(page)){ const parts = self.pages[page]; let getters = []; let wrappers = []; for (let i = 0; i &lt; parts.length; i++) { if( /^.*\.css$/i.test(parts[i]) ){ wrappers.push('style'); } else if ( /^.*\.js$/i.test(parts[i]) ){ wrappers.push('script'); } else { wrappers.push(''); } getters.push( $.get(parts[i], null, null, 'text').promise() ); } Promise.all(getters).then(function(results) { let html = ''; for (let i = 0; i &lt; results.length; i++) { if(wrappers[i] === ''){ html += results[i]; } else { html += `&lt;${wrappers[i]}&gt;${results[i]}&lt;/${wrappers[i]}&gt;`; } } self.updatePath(page); $container.html(html); }); } else { //TODO console.log('404'); } }, updatePath: function(newPath){ if(newPath !== window.location.pathname) { history.pushState({}, null, newPath); } } }</span></span></code> </pre> <br></div></div><br><h2>  Setting up the environment </h2><br>  All that would be required to run the project on my computer, I tried to explain the steps in the README on the project <a href="https://github.com/gnemtsov/ab-erp">github</a> .  If something does not work, write in the comments - we will try to help.  Accordingly, README will replenish. <br><br>  For local testing, I wrote a small HTTP server on Node.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(express.static(<span class="hljs-string"><span class="hljs-string">'public'</span></span>)); app.use(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) </span></span>{ req.url = <span class="hljs-string"><span class="hljs-string">'app.html'</span></span>; next(); }); app.use(express.static(<span class="hljs-string"><span class="hljs-string">'public'</span></span>)); app.listen(<span class="hljs-number"><span class="hljs-number">80</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Listening..'</span></span>))</code> </pre> <br>  Before you begin, you need to run it with the <b>node</b> command <b>abserver.js</b> .  When a request comes in, he searches for a file in the <b>public</b> folder and gives it away if he found it.  If the file is not found, it gives the main application file <b>public \ app.html</b> .  This is quite enough for the SPA application to work.  In production, Amazon CloudFront solves this problem. <br><br><h2>  Conclusion </h2><br>  AB-ERP is still very raw.  We welcome any suggestions and comments, and even more commits. <br><br>  Currently, only authorization is more or less implemented in AB-ERP - I plan to talk about it in one of the following articles.  What authorization options are there when working with API Gateway and why we did not implement custom authorizer or integration with Cognito. <br><br>  <b>Some plans for the further development of the project.</b> <br><br>  The key components for any data application are data entry forms and a table for their output.  Therefore, the functionality for working with forms and tables will be added first. <br><br>  There is an idea to standardize work with forms (building forms on a page, validating to backend and frontend, saving in the database) through the use of YAML templates.  That is, to make it possible to describe forms in YAML templates, and then all the rest of the work on the frontend and backend is done with the code AB-ERP.  For the tables, we will use the <a href="https://datatables.net/">Datatables</a> library, which we used in our task tracker AB-TASKS. <br><br>  <b>The following tools helped me in writing this article:</b> <br><br><ul><li>  Online drawing service <a href="https://www.draw.io/">draw.io</a> diagrams </li><li>  Windows command line <b>tree</b> command for directory tree rendering </li></ul></div><p>Source: <a href="https://habr.com/ru/post/352856/">https://habr.com/ru/post/352856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352846/index.html">Distrust of authority and economy: main trends of millenial investment activity according to Robinhood service statistics</a></li>
<li><a href="../352848/index.html">Backend United # 1. The vinaigrette. Announcement</a></li>
<li><a href="../352850/index.html">We are preparing an iOS client for GraphQL</a></li>
<li><a href="../352852/index.html">Excel-calculator of complex wave resistance transformation on waveguide line segments</a></li>
<li><a href="../352854/index.html">We keep the design of the system under control using isolated unit testing</a></li>
<li><a href="../352858/index.html">Tehnostrim. Learning to build the Internet</a></li>
<li><a href="../352860/index.html">DANOS: First Open Network Operating System Presented</a></li>
<li><a href="../352864/index.html">Simple, affordable and useful Wi-Fi lab. Do it yourself</a></li>
<li><a href="../352868/index.html">Is the keyboard an output device?</a></li>
<li><a href="../352872/index.html">The art of winning or what is quantum pseudo telepathy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>