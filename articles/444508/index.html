<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we made PHP 7 twice as fast as PHP 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In December 2015 , PHP 7.0 was released. Companies that have switched to the "seven" have noted that productivity has increased, and the load on the s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we made PHP 7 twice as fast as PHP 5</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://php.net/archive/2015.php">In December 2015</a> , PHP 7.0 was released.  Companies that have switched to the "seven" have noted that productivity has increased, and the load on the servers has decreased.  The first went to the seven Vebia and Etsy, and we have Badoo, Avito and OLX.  For Badoo, the transition to the seven cost $ 1 million in savings on servers.  Thanks to PHP 7 in OLX, the average server load has decreased by 3 times, the efficiency and resource savings have increased. <br><br>  <strong>Dmitry Stogov</strong> from Zend Technologies at <a href="http://www.highload.ru/">HighLoad ++</a> explained how his performance improved.  In the decoding: about the internal structure of PHP, about the ideas in the basis of version 7.0, about changes in the basic data structures and algorithms that determined success. <br><br>  <em>Disclaimer: As of March 2019,</em> <a href="https://w3techs.com/technologies/details/pl-php/5/all"><em>80% of the sites</em></a> <em>work on PHP, and</em> <a href="https://w3techs.com/technologies/details/pl-php/all/all"><em>70% of them work</em></a> <em>on PHP 5, although</em> <a href="http://php.net/supported-versions.php"><em>this version is not supported</em></a> <em>since January 1, 2019</em> <em>.</em>  <em>Dmitry's report from 2016 on the principles that have led to a two-fold performance jump between PHP 5 and 7 is also relevant in March 2019. For half of the sites, for sure.</em> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/tHapNKpacSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>About the speaker: Dmitry Stogov</strong> began programming in the 80s: ‚ÄúElectronics B3-34‚Äù, Basic, assembler.  In 2002, Dmitry met PHP and soon began working on improving it: he developed Turck MMCache for PHP, managed the PHPNG project and played an important role in working on JIT for PHP.  The last 14 years of Principal Engineer at Zend Technologies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Zend Technologies develops PHP and commercial solutions based on it.  In 1999, it was founded by Israeli programmers Andy Gutmans and Zeev Sourasky, who two years ago created PHP 3. These people were at the very beginning of PHP development and in many respects determined the current look of the language and the success of the technology. <br><br>  Zend Technologies develops the PHP core and applications for it, and during the work I had to write extensions, get into all subsystems, and even engage in commercial projects, sometimes not related to PHP at all.  But the most interesting topic for me has always been <strong>performance</strong> . <br><br>  I started looking for ways to speed up PHP even before joining Zend, working on my own project that competed with the company.  During the work on the project, I thoroughly understood the language and realized that working not with the mainstream project can only affect certain aspects of the script execution, and all the most interesting and effective can be created <strong>only in the core</strong> .  This understanding and coincidence led me to Zend. <br><br><h2>  A little excursion into the history of PHP </h2><br>  PHP is not really and <strong>not just a programming language</strong> .  PHP is translated as Personal Home Page - a tool for creating personal web pages and dynamic websites.  Language is only one of its main parts.  PHP is a huge library of functions, many extensions for working with other third-party libraries, for example, for accessing databases or XML parsers, as well as a set of modules for communicating with various web servers. <br><br>  Danish programmer <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B5%25D1%2580%25D0%25B4%25D0%25BE%25D1%2580%25D1%2584,_%25D0%25A0%25D0%25B0%25D1%2581%25D0%25BC%25D1%2583%25D1%2581">Rasmus Lerdorf</a> introduced PHP <a href="https://ru.wikipedia.org/wiki/PHP">in June 1995</a> .  At that time, it was just a <strong>collection of CGI scripts written in Perl</strong> .  In April 96, Rasmus introduced PHP / FI, and in June the version of PHP / FI 2.0 was released.  Subsequently, this version was significantly reworked by Andy Gutmans and Zeev Suraski, and in 1998 they released PHP 3.0.  By 2000, the language came to the form that we are used to seeing today, both in terms of language and internal architecture - PHP 4, based on the Zend Engine. <br><br>  Since the 4th version of PHP is evolving evolutionary.  The turning point was the release of PHP 5 in 2004, when the <strong>object model was completely updated</strong> .  It was she who opened the era of PHP frameworks and raised the issue of performance to a new level.  Anticipating this, immediately after the release of 5.0, we at Zend thought about accelerating PHP and began to work on improving performance. <br><br>  Version 7.1, which was released in November 2016 on synthetic tests <strong>is 25 times faster than the 2002 version</strong> .  According to the schedule of performance changes in different branches, the main breakthroughs are visible in 5.1 and 7.0. <br><br><img src="https://habrastorage.org/webt/ao/_s/mp/ao_smpopukfzjmclxqqu83xefvo.png"><br><br>  In version 5.1, we just started working on performance, and everything we took for was good, but after 5.3 we ran into the wall, all attempts to improve the interpreter did not lead to anything. <br><br>  Nevertheless, we found where to dig, and got even more than expected - 2.5-fold acceleration compared to the previous version 5.6 on the tests.  But the most interesting thing is that we got the same 2.5-fold acceleration on unchanged real-world applications.  This is a phenomenon, because we have accumulated the previous factor 2 throughout the life of the five for 10 years. <br><br><img src="https://habrastorage.org/webt/ge/9j/n_/ge9jn_isn9hxm-gbrk0ahaexfms.png"><br><br>  A huge jump in 5.1 on synthetic tests, on real applications is not noticeable.  The reason is that with different uses, PHP's performance rests on the brakes associated with different subsystems. <br><br>  <strong>The history of PHP 7 begins with a three-year stagnation</strong> , which began in 2012, and ended in 2015 with the release of the seventh version.  Then we realized that we could no longer increase the performance with minor improvements to our interpreter and turned in the direction of JIT. <br><br><h2>  Wandering around jit </h2><br>  For almost two years, we spent on a JIT prototype for PHP-5.5.  First, we generated a very simple code - a sequence of calls for standard handlers, something like a stitched Fort code.  Then they wrote their own <strong>Runtime Assembler</strong> , inline a separate code for detours, but realized that such <strong>low-level optimizations did not give a practical</strong> effect even on tests. <br><br>  Then we thought about the derivation of types of variables using static analysis methods.  Implementing the conclusion, immediately received a <strong>2-fold acceleration on the tests.</strong>  Encouraged, they tried to write a global register alocator, but failed.  We used a fairly high-level view, and for register allocation it was almost impossible to use it. <br><br>  To avoid problems with a low level, we decided to try LLVM, and a year later we had a <strong>10-fold acceleration for bench.php</strong> , but nothing on real applications.  In addition, the compilation of real applications now took minutes, for example, the first <strong>requester to Wordpress took 2 minutes and did not give acceleration.</strong>  Of course, it was completely unsuitable for real practice. <br><br><blockquote>  Good code is possible with proper type prediction, which in real applications does not work well, and the use of PHP data structures makes the generated code ineffective. </blockquote><br><h3>  What inhibits? </h3><br>  We rethought the reasons for the failures and decided once again to see why PHP slows down.  In the picture, the result of profiling multiple requests to the Wordpress home page. <br><br><img src="https://habrastorage.org/webt/3w/dh/7v/3wdh7vd40xumtwtyqgshsdan-a8.png"><br><br>  Less than 30% is spent on the interpretation of the byte-code, 20% is the overhead of the memory manager, 13% is working with hash tables, and 5% is working with regular expressions. <br><br>  Working at JIT, we got rid of only the first 30%, and everything else was a dead weight.  Almost everywhere, we were forced to use standard PHP data structures that entailed overhead: memory allocation, reference counting, and so on.  This understanding has led to the conclusion that it is necessary to replace key data structures in PHP.  With this <strong>substitution of the foundation</strong> , the <strong>PHPNG</strong> project <strong>began.</strong> <br><br><h2>  PHPNG.  New generation </h2><br>  The project was developed after unsuccessful attempts to create a JIT for PHP.  The main goal is <strong>to achieve a new level of performance and lay the foundation for future improvements</strong> . <br><br>  We promised ourselves some time not to use synthetic tests to measure performance - these are usually small computational programs that use a limited amount of data that fits completely into the processor‚Äôs cache.  Real applications, on the contrary, are subject to the brakes associated with the subsystem memory, and a single reading from memory can cost 100 computational instructions.  <strong>The PHPNG project is a refactoring of key PHP data structures to optimize memory access</strong> .  No innovations, 100% compatibility with PHP 5. <br><br>  How to change these structures was clear.  But the volume of dependent changes was huge because the <strong>core of PHP</strong> itself <strong>is 150,000 lines</strong> , and almost every third needed to be changed.  Add another hundred extensions that are included in the base distribution, a dozen modules for different web servers, and you will understand the grandeur of the project. <br><br>  We were not even sure that we would complete the project.  Therefore, they launched the project in secret and opened it only when the first optimistic results appeared.  It took two weeks to simply <strong>compile the kernel</strong> .  Two weeks later, earned bench.php.  Spent a month and a half to make Wordpress work.  A month later, we opened the project - it was May 2014.  At that time, we had <strong>a 30% acceleration on Wordpress</strong> .  This already seemed like a big deal. <br><br>  PHPNG immediately caused a wave of interest, and in August 2014 was <strong>adopted as the basis for the future of PHP 7</strong> .  It was a different project, with a different set of goals, where productivity was only one of them. <br><br><h2>  PHP 7.0 </h2><br>  Version 7 itself was questionable.  The previous version was the fifth.  And the sixth was developed several years ago and was completely devoted to native support for <strong>Unicode</strong> , but the unsuccessful decisions made in the early stages of development led to an excessive complication of the kernel code and each extension.  In the end, it was decided to freeze the project. <br><br>  By this time, a lot of material on PHP 6 had already been accumulated: presentations at conferences, published books.  To not confuse anyone, we called the project PHP 7, skipping PHP 6. This version was lucky much more - PHP 7 was released in December 2015, almost according to plan. <br><br>  In addition to performance, in PHP 7, some long-awaited innovations have appeared: <br><br><ul><li>  Ability to define scalar types of parameters and return values. </li><li>  Exceptions instead of errors - now we can catch and handle them. </li><li> <code>Zero-cost assert()</code> , anonymous classes, cleaning inconsistencies, new operators and functions (&lt;=&gt;, ??) have appeared. </li></ul><br>  Innovation is good, but back to the internal changes.  Let's talk about the path that PHP 7 went through, and where this path might lead us. <br><br><h2>  zval </h2><br>  This is the main data structure of PHP.  It is used to <strong>represent any value in PHP</strong> .  Since the language we have is dynamically typed and the type of variables can change in the execution of the program, we need to keep the field type (zend_uchar type), which can be IS_NULL, IS_BOOL, IS_LONG, IS_DOUBLE, IS_ARRAY, IS_OBJECT, etc., and the actual value , represented by a union (value), where an integer, a real number, a string, an array, or an object can be stored. <br><br><h3>  zval in php 5 </h3><br>  Memory for each such structure was allocated separately in Heap.  In addition to the type and value, it also stored a reference count to the structure.  So the structure occupied 24 bytes, not counting the overhead of the memory-manager and a pointer to it. <br><br>  The picture on the right above shows the data structures that were created in PHP 5 memory for a simple script. <br><br><img src="https://habrastorage.org/webt/m8/km/ix/m8kmixgehjrhtxthe-gefmmi86i.png"><br><br>  The stack has allocated memory for 4 variables, represented by pointers.  The values ‚Äã‚Äãthemselves (zval) are in the heap.  In our case, these are just two zval, each of which is referred to by two variables, and, accordingly, their reference counters are set to 2. <br><br>  To access a type or scalar value, you need at least two readings: first read the value of the pointer, and then the value of the structure.  If you need to read not a scalar value, but for example, a part of a string or array, then you will need at least one more reading more. <br><br><h3>  zval in php 7 </h3><br>  Where we used pointers before, in the seven we began to embed zval.  We have gone from reference counting for scalar types.  The type and value fields remained without significant changes, but some more flags and a reserved place were added, which I will discuss later. <br><br><img src="https://habrastorage.org/webt/tz/we/yn/tzweyn8n32_rntdwwjxhz-fbwc4.png"><br><br>  On the left, what it looked like in PHP 5, and on the right in PHP 7. <br><br><img src="https://habrastorage.org/webt/5n/wl/4h/5nwl4hrqaqr2kb4pmenzvbtrnh4.png"><br><br>  Now on the stack themselves are zval.  To read types and scalar values, all you need is a single machine instruction.  All values ‚Äã‚Äãare grouped in one memory area, which means that when working with local variables, we will have practically no losses due to processor cache misses.  But the real power of the new view is included when copying is necessary. <br><br><h3>  Copy Record </h3><br>  In the top line of the script one more assignment was added. <br><br><img src="https://habrastorage.org/webt/kb/yr/ww/kbyrwwvzaeuqpt8quf1lyujztjo.png"><br><br>  In PHP5, we allocated from memory a new zval from the heap, initialized its int (2), changed the value of the pointer to the variable b, and decreased the reference counter of the value to which b referred earlier. <br><br>  In PHP 7, we simply <strong>initialized the variable b directly in place with a few instructions</strong> , while in PHP 5 it required hundreds of instructions.  So zval looks now in memory. <br><br><img src="https://habrastorage.org/webt/ax/ab/sa/axabsadvso8c49azoqvvks5jsfc.png"><br><br>  These are two 64-bit words.  The first word is a <strong>value:</strong> integer, real or pointer.  In the second word, the <strong>type</strong> (he tells how to interpret the meaning), the flags, and the reserved space that would still be added during alignment.  But it does not disappear, but is used by different subsystems for storing indirectly related values. <br><br>  <strong>Flags are a set of bits</strong> , where each bit tells whether zval supports a protocol.  For example, if <code>IS_TYPE_REFCOUNTED</code> , then when working with this zval, the engine should take care of the value of the reference count.  On assignment ‚Äî increment; when going out of scope ‚Äî decreasing; if the reference counter reaches zero ‚Äî destroy the dependent structure. <br><br>  Of the types, compared with PHP 5, there are several new ones. <br><br><ul><li>  <code>IS_UNDEF</code> is a marker for an uninitialized variable. </li><li>  The single <code>IS_BOOL</code> replaced by separate <code>IS_FALSE</code> and <code>IS_TRUE</code> . </li><li>  Added a separate type for links and a few more magical types. </li></ul><br>  Types from <code>IS_UNDEF</code> to <code>IS_DOUBLE</code> are scalar and do not require additional memory.  To copy them, just copy the first machine 64-bit word with the value and half the second with the type and flags. <br><br><h3>  Refcounted </h3><br>  With other types harder.  All of them are represented by a subordinate structure, and zval simply stores a reference to this structure.  For each type, this structure has its own, but in OOP terms, they all have a common abstract ancestor or zend_refcounted structure.  It defines the format of the first <strong>64-bit word</strong> where the reference counter and other information for the garbage collector is stored. <br><br><img src="https://habrastorage.org/webt/vn/zm/yy/vnzmyywum831lpzipgxtenm_98s.png"><br><br>  This word can be viewed simply as information for the garbage collector, and structures for specific types add their fields after this first word. <br><br><h3>  Strings </h3><br>  In the seven for the string, we store the computed value of the hash function, its length, and the characters themselves.  The size of this structure is variable and depends on the length of the string.  The hash function is calculated for the string once, when necessary.  In PHP 5, it was re-computed at every need. <br><br><img src="https://habrastorage.org/webt/em/2t/ax/em2tax1wdnckpbzqxjh1tlqn37o.png"><br><br>  Now the lines have become reference countable, and if in PHP 5 we copied the characters themselves, now it is enough to increase the reference count to this structure. <br><br>  As in PHP 5, we are left with the notion of <strong>immutable or interned strings</strong> .  They usually exist in one instance, live to the end of the query, and can behave like scalar values.  We have no need to take care of the counter of links to them, and to copy it is enough to copy only the zval itself using four machine instructions. <br><br><h3>  Arrays </h3><br>  Arrays are represented by a built-in hash table and are not much different from PHP 5. The hash table itself has changed, but about this separately. <br><br><img src="https://habrastorage.org/webt/_u/kn/ls/_uknlsdbw247d7whq_-euez8zuw.png"><br><br>  Arrays are now an <strong>adaptive structure</strong> that slightly changes its internal structure and behavior depending on the stored data.  If we store only elements with close numeric keys, we get access to the elements directly by index with a speed comparable to the speed of arrays in C. But it is necessary to add an element with a string key to the same array - it turns into a real hash with collision resolution. <br><br>  So the hash table looks like in PHP 5. <br><br><img src="https://habrastorage.org/webt/d6/c-/6r/d6c-6rvue6zlsyyhnscfyjtnjj4.png"><br><br>  This is a classic implementation of a hash table with collision resolution using linear lists (shown in the upper right corner).  Each item is represented by a bucket.  All Buckets are linked by doubly linked lists for resolving collisions, and are also linked by another doubly linked list for iteration in order.  Values ‚Äã‚Äãfor each zval are allocated separately - in the Bucket we store only a link to it.  Also, string keys can be allocated separately. <br><br>  Thus, for each hash table you need to allocate a lot of small blocks of memory, and then to find something, you have to run along the pointers.  Each such transition can cause cahce miss and a delay of ~ 10-100 processor cycles. <br><br>  This is what happened in PHP 7. <br><br><img src="https://habrastorage.org/webt/g_/mk/ax/g_mkaxt7a0ua8shao-rzketmjag.png"><br><br>  The logical structure has remained unchanged, only the physical has changed.  Now for a hash table, memory is allocated using a single operation. <br><br>  In the picture, at the bottom of the base index, there are elements, and at the top - a hash array, which is addressed by a hash function.  For flat or packaged arrays, when we store only elements with numeric indexes, the upper part is not allocated at all, and we refer to buckets directly by number. <br><br>  To bypass the elements, we sequentially go through them from top to bottom or from bottom to top, which modern processors do flawlessly.  The values ‚Äã‚Äãare built into the buckets, but the reserved space in them is just used to resolve collisions.  There is stored the index of another Bucket with the same hash function or a marker at the end of the list. <br><br>  Memory for string values ‚Äã‚Äãof keys is allocated separately, but these are all the same zend_string.  When inserting into an array, it is enough to increase the reference counter of the line, although earlier we had to copy the characters directly, and when searching we can now compare not the characters, but the pointers to the lines themselves. <br><br><h3>  Immutable arrays </h3><br>  Previously, we had immutable strings, and now there are also immutable arrays.  Like strings, they do not use a reference count and are not destroyed until the end of the request.  This is a simple script that creates an array of one million elements, and each element is one and the same array with a single ‚Äúhello‚Äù element. <br><br><img src="https://habrastorage.org/webt/uv/sm/lu/uvsmluqtfldezjnbbfdqvd83sr8.png"><br><br>  In PHP 5, at each iteration of the loop, a new empty array was created, ‚Äúhello‚Äù was written to it, and all this was added to the resulting array.  In PHP 7, at compile time, we <strong>create only one immutable array</strong> that behaves like a scalar, and add it to the resulting one.  In the example presented, this makes it possible to achieve more than 10-fold reduction in memory consumption and almost 10-fold acceleration. <br><br>  Constant arrays of millions of elements in real applications, of course, are not often, but small - quite often.  On each of them you get a small, but a gain. <br><br><h3>  Objects </h3><br>  Links to all objects in PHP 5 lay in a separate repository, and in zval there was only a handle - a unique object ID. <br><br><img src="https://habrastorage.org/webt/in/lo/dq/inlodqhjne7lo12nslgcuqrckvy.png"><br><br>  To get to the object, we made at least 3 readings.  In addition, the memory for the value of each property of the object is distributed separately, and we needed at least 2 more readings to read it. <br><br>  In PHP 7, we were able to go to direct addressing. <br><br><img src="https://habrastorage.org/webt/zm/vp/vv/zmvpvvqlmybttr3zvze6gzglin4.png"><br><br>  Now the <code>zend_object</code> address is accessible with one machine instruction.  And Property are built in and for their reading only one additional reading is needed.  They are also grouped together, which <strong>improves the data locality</strong> and helps modern processors not to stumble. <br><br>  In addition to the predefined properties, a reference to the class of this object is also stored here, some handlers are analogous to tables of virtual methods, and a hash table for property that has not been defined.  In PHP, you can add properties to any object that were not originally defined, and if several machine instructions are enough to access predefined properties, then for non-predefined properties you will have to refer to a hash table, which will require dozens of machine instructions.  Of course, it is much more expensive. <br><br><h3>  Reference </h3><br>  Finally, we had to introduce a <strong>separate type</strong> to represent PHP links. <br><br><img src="https://habrastorage.org/webt/yk/jj/ng/ykjjngfnlq8sefuvmwzjfxwjz7g.png"><br><br>  This is an absolutely transparent type.  It is not visible to PHP scripts.  Scripts see another zval, which is built into the structure of zend_reference.  It is implied that we refer to one such structure from at least two places, and the reference counter of this structure is always greater than 1. As soon as the counter drops to 1, the link becomes a normal scalar value.  The zval embedded in the link is copied to the last zval that references it, and the structure itself is deleted. <br><br>  It seems that now working with reference is much more difficult than with other types (and this is true), but in fact in PHP 5 we had to perform work of comparable complexity when referring to any value (even a simple integer).  Now we apply more complex protocols to only one type and thereby accelerated work with all others, especially with scalar values. <br><br><h3>  IS_FALSE and IS_TRUE </h3><br>  I already said that the single type IS_BOOL was split into separate IS_FALSE and IS_TRUE.  This idea was spied in the implementation of LuaJIT, and was made to speed up one of the most frequent operations - the conditional transition. <br><br><img src="https://habrastorage.org/webt/fv/5j/-z/fv5j-zx0u_2kfmtmxjwce4uzetk.png"><br><br>  If PHP 5 was required to read a type, check for a boolean, read a value, find out if it is true or false and make a transition based on this, then now it is enough just to check the type and compare it with true: <br><br><ul><li>  if it is true, then we go on one branch; </li><li>  if it is less than true, go to another branch; </li><li>  if it is more true, go to the so-called slow path (slow path) and there we check what type it came and what to do with it: if it is an integer, then we should compare its value with 0, if float - again with 0 ( but real), etc. </li></ul><br><h2>  Calling convention </h2><br>  A change in the Calling Convention or function call convention is an important optimization that affects not only data structures, but also basic algorithms.  The picture on the left shows a small script consisting of the foo () function and its call.  Below is the bytecode in which this script was compiled by PHP 5. <br><br><img src="https://habrastorage.org/webt/bn/fw/a4/bnfwa4e5ifjqs6rd6cp66uctega.png"><br><br>  First I‚Äôll tell you how this worked in PHP 5. <br><br><h3>  Calling Convention in PHP 5 </h3><br>  The first instruction <code>SEND_VAL</code> should have sent the value ‚Äú3‚Äù to the function foo.  To do this, she was forced to allocate a new zval on the heap, copy the value (3) there and write the value of the pointer to this structure on the stack. <br><br><img src="https://habrastorage.org/webt/mt/vu/d3/mtvud3tb2ljaijnwecbmvnqepjs.png"><br><br>  Similarly with the second instruction.  Further <code>DO_FCALL</code> initialized <code>CALL FRAME</code> , reserved space for local and temporary variables, and transferred control to the called function. <br><br><img src="https://habrastorage.org/webt/rx/rw/qo/rxrwqogtbhgd0q9tsd7wnw2r4og.png"><br><br>  The first <code>RECV</code> checked the first argument and initialized the slot of the corresponding local variable ($ a) on the stack.  Here we did without copying and simply increased the reference count of the corresponding parameter (zval with a value of 3).  Similarly, the second <code>RECV</code> established a connection between the $ b variable and parameter 5. <br><br><img src="https://habrastorage.org/webt/lw/c1/zw/lwc1zw26uby_oj54yjzu7yz-vus.png"><br><br>  Next is the function body.  There was an addition of 3 + 5 - it turned out 8. This is a temporary variable and its value was stored directly on the stack. <br><br><img src="https://habrastorage.org/webt/d0/xj/s5/d0xjs5j2c0i6qgioybezypay9k4.png"><br><br>  RETURN and we return from the function. <br><br><img src="https://habrastorage.org/webt/zd/cc/nb/zdccnbal1xuynwdcymbrwcf2fmq.png"><br><br>  On return, we release all variables and arguments that are out of scope.  To do this, we go through all the zval that slots from the freed frame refer to, and for each we reduce the reference count.  If it reaches 0, then destroy the corresponding structure. <br><br>  As you can see, even such a simple operation as sending a constant to a function requires allocating a new memory, copying and increasing the reference count, and then double decrement and delete. <br><br><h3>  Calling Convention in PHP 7 </h3><br>  In PHP 7, these problems have been fixed - now we are not storing pointers to zvals on the stack, but zvals themselves. <br><br><img src="https://habrastorage.org/webt/xc/ek/ls/xceklspoxwmga__zvpeat1a4plw.png"><br><br>  We also introduced the new <code>INIT_FCALL</code> instruction, which is now responsible for initializing and allocating memory for <code>CALL FRAME</code> , and reserving space for arguments and temporary variables. <br><br><img src="https://habrastorage.org/webt/yi/gd/a5/yigda5wg7xswdcyadip7euboboa.png"><br><br>  <code>SEND_VAL 3</code> now simply copies the argument to the first slot in the <code>CALL FRAME</code> .  Next <code>SEND_VAL 5</code> in the second slot. <br><br><img src="https://habrastorage.org/webt/-0/es/8_/-0es8_skigjtyvja3vzzegwo-su.png"><br><br>  Next is the most interesting.  It would seem that <code>DO_FCALL</code> should transfer control to the first instruction of the function being called.  But the arguments are already in the slots that are reserved for the variable parameters $ a and $ b, and the <code>RECV</code> instructions just do nothing.  Therefore, you can simply skip them.  We sent two parameters, so we skip two instructions.  If they sent three, they would have missed three. <br><br><img src="https://habrastorage.org/webt/4z/vm/gj/4zvmgjldpmtfpgprtvqoks__-km.png"><br><br>  So we go directly to the function body, perform addition and return. <br><br><img src="https://habrastorage.org/webt/zh/j1/yf/zhj1yfwxp5kf1s4xxlyoasy170i.png"><br><br>  When returning, we clear all local variables, but now only for two slots, and since we have scalars there, we do not need to do anything again. <br><br><img src="https://habrastorage.org/webt/wy/dh/2p/wydh2pvz_hpawjivtoxx3hmxoqa.png"><br><br>  My story is slightly simplified; it does not take into account functions with a variable number of arguments and the need for type checking and some other points. <br><br>  <strong>The new Calling Convention broke compatibility a bit</strong> .  PHP has functions such as <code>func_get_arg</code> and <code>func_get_args</code> .  If earlier they returned the original value of the sent parameter, they now return the current value of the corresponding local variable, because we simply do not store the original values.  Just like debuggers from C. <br><br><img src="https://habrastorage.org/webt/5r/n2/6j/5rn26j24gjyfolmeu07qgv1wmxu.png"><br><br>  In addition, the function can no longer have several parameters with the same name.  There was no sense in it before, but I met such PHP code <code>foo($_, $_)</code> .  What does it look like?  (I learned Prolog) <br><br><h2>  New memory manager </h2><br>  Having finished with the optimization of data structures and basic algorithms, we once again paid attention to all the braking subsystems.  The PHP 5 memory manager took up <strong>almost 20% of CPU time</strong> on Wordpress. <br><br>  After we got rid of a lot of allocations, his overhead costs became less, but still significant - not because he did some substantial work, but because he stumbled on the cache.  This was due to the fact that we used the classical algorithm of Doug Lea's malloc, which meant finding suitable free memory areas with the help of traveling through links and trees, and all these journeys inevitably caused cache misses. <br><br>  Today, there are new memory management algorithms that take into account the features of modern processors.  For example: <strong>jemalloc</strong> and <strong>ptmalloc from Google</strong> .  At first, we tried to use them in an unchanged form, but did not win, because the lack of PHP-specific functionality made it more expensive to completely release memory at the end of the request.  As a result, we abandoned dlmalloc and wrote something of our own, combining ideas from the old memory manager and jemalloc. <br><br>  We <strong>reduced the Memory Manager overhead by up to 5%</strong> , reduced memory overhead for service information, and improved CPU cache utilization.  Suitable memory blocks are now searched by bitmaps, memory for small blocks is allocated from individual pages and cached when released, and specialized functions are added for frequently used block sizes. <br><br><h2>  Many minor improvements </h2><br>  I told only about the most important improvements, but there were more small ones.  I can mention some of them. <br><br><ul><li>  A quick API for parsing the parameters of internal functions and a new API for iterating over the HashTable. </li><li>  New VM instructions: string concatenation, specialization, super instructions. </li><li>  Some internal functions have been turned into VM instructions: strlen, is_int. </li><li>  Use of CPU registers for VM: IP and FP registers. </li><li>  Optimization of duplicate and delete arrays. </li><li>  Use reference counters instead of copying wherever possible. </li><li>  PCRE JIT. </li><li>  Optimization of internal functions and serialize (). </li><li>  Reducing the size of the code and the data being processed. </li></ul><br>  Some were very simple, for example, it took only three lines of code to enable JIT in regular Perlovsky expressions, and this immediately brought visible (2-3%) acceleration to almost all applications.  Other optimizations have touched upon some narrow aspects of certain PHP functions, and are not particularly interesting, although the total contribution of all these minor improvements is quite significant. <br><br><h2>  What came to </h2><br>  This is a contribution of various subsystems on WordPress / PHP 7.0. <br><br><img src="https://habrastorage.org/webt/7q/r4/d0/7qr4d08m8yhid4rngwh9-gffxbu.png"><br><br>  The contribution of the virtual machine increased to 50%.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Manager already consumes less than 5% - and mostly not by optimizing the Memory Manager itself, but by reducing the number of calls to it. </font><font style="vertical-align: inherit;">If earlier memory was allocated 130 million times on the same test, now it is only 10 million. It may seem that all the main acceleration is achieved by reducing the memory manager overhead and reducing the number of calls to it by improving data structures, but in fact all subsystems have been significantly improved. </font></font><br><br><img src="https://habrastorage.org/webt/kk/nq/5p/kknq5ppnd1ihr8wjw9xfv38boyy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Main sources of acceleration:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The interpreter began to work better 2 times. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MM overhead decreased 17 times. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hash tables began to work 4 times faster. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The overall performance of WordPress increased by 3.5 times. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> At the beginning of the article we talked about 2.5-fold real acceleration, and now the numbers are different. </font></font> Why is that?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that we measured the real speed in requests per second, and here the speed is measured by the profiler in terms of CPU time, in fact, by the processor clock, when it is not idle. </font><font style="vertical-align: inherit;">When PHP waits for a response from the database, the processor is worth and this time is not counted here.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PHP 7 performance </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WordPress 3.6 was our main benchmark - we monitored performance on it from the first days of work. </font><font style="vertical-align: inherit;">At some point, when the mysql extension was dropped from PHP 7, we had to specifically support it, just to continue this schedule. </font></font><br><br><img src="https://habrastorage.org/webt/bs/x9/pa/bsx9pa3fc3ccedmnajaj1h5dm0q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The graph shows that the main breakthroughs occurred in the first months of work on PHPNG. </font><font style="vertical-align: inherit;">By August, there were 2/3 improvements. </font><font style="vertical-align: inherit;">Then we moved in small steps, and scored the remaining third. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, we measured the performance not only on WordPress, but also on other popular applications, and almost everywhere we see - from 1.5 to 2-fold acceleration.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PHP 7 and HHVM </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to our version, we almost everywhere overtook even the current versions of HHVM. </font></font><br><br><img src="https://habrastorage.org/webt/fs/vg/ot/fsvgotogozunvqed7dwflmmef1u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But comparison with a third-party product is a thankless task. Always win in favor of measuring. The version of the Facebook team shows other results. On the graph, HHVM is proportionally faster everywhere. Perhaps this is due to different measurement procedures, testing on different hardware platforms, the difference in fine-tuning, and maybe subjective factors have also influenced. </font></font><br><br><img src="https://habrastorage.org/webt/c_/pg/jv/c_pgjvoejr-q3o5sgvgtplxkbm0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apotheosis of PHP 7 - the beginning of the use of large sites. The pioneers were Chinese Vebia, American Etsy and Badoo. The highload check revealed several significant problems, but they were quickly localized and fixed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The transition to PHP 7.0 for Etsy and Badoo allowed to shut down almost half of the servers in web farms. Badoo </font></font><a href="https://habr.com/ru/company/badoo/blog/279047/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rated</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saving a million dollars. </font></font><br><br><img src="https://habrastorage.org/webt/pn/rv/rj/pnrvrjrzp9re46lbmngnyddzu44.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The graphs are indicative that at the time of the transition, the total processor utilization decreased by 2 times, and the memory consumption - by as much as 7 times. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this joyful note, we‚Äôll finish today's talk about PHP 7.0. But we will continue it very soon with PHP 7.1, in the optimization of which we went significantly further than data structures.</font></font><br><br><blockquote>    <a href="https://phprussia.ru/2019/">PHP Russia</a>     <a href="https://phprussia.ru/2019/abstracts/5080"></a>        <b>PHP 8</b> .         PHP,  ,    ,      ‚Äî <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2019"> </a>  1 .  , ,    ‚Äî   ,    ,     ,  . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/444508/">https://habr.com/ru/post/444508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444494/index.html">La Moto Volante (Lazareth LMV 496) - flying transforming motorcycle</a></li>
<li><a href="../444496/index.html">New HTTPS Interception Detection Tools</a></li>
<li><a href="../444500/index.html">March 29, Moscow - Backend Stories 3.0</a></li>
<li><a href="../444502/index.html">Is quantum cryptography reliable?</a></li>
<li><a href="../444504/index.html">Using the local package directory in Python now</a></li>
<li><a href="../444514/index.html">Webinar "Machine Learning Security: Natural Problems of Artificial Intelligence"</a></li>
<li><a href="../444516/index.html">Wolfenstein 3D: ray tracing with WebGL1</a></li>
<li><a href="../444518/index.html">Towards a fundamental theory of consciousness</a></li>
<li><a href="../444520/index.html">2. Check Point Getting Started R80.20. Solution Architecture</a></li>
<li><a href="../444522/index.html">Apocalypse is canceled</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>