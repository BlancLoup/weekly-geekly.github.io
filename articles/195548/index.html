<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The impact of the Web application architecture on investment volumes, product life cycle and user positive emotions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently it has become fashionable to use the terms "Web-application", "front-end-architecture", "Web 2.0", "HTML5-applications". But, unfortunately, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The impact of the Web application architecture on investment volumes, product life cycle and user positive emotions</h1><div class="post__text post__text-html js-mediator-article"> Recently it has become fashionable to use the terms "Web-application", "front-end-architecture", "Web 2.0", "HTML5-applications".  But, unfortunately, in most cases the context of using these terms is not always true, because it does not take into account all the specifics of the implementation and use of the architecture of a Web application.  Today we will talk about architecture. <br><br>  The impetus for writing this article was the blog post <a href="http://blog.pamelafox.org/2013/05/frontend-architectures-server-side-html.html">http://blog.pamelafox.org/2013/05/frontend-architectures-server-side-html.html</a> .  It is worth noting that it is quite compressed and does not take into account the possibility of converting HTML5 / Mobile.  Here we tried to consider the architecture in more detail, taking into account the latest trends in the Web and some key points for the customer of the application (such as security). <br><br>  To begin with, we will look at the most common architectures for Web applications, their advantages and disadvantages from three points of view: customer, developer, and user.  Other options are possible, but they are still subtypes of the considered architectures and come down to the main three. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start by defining the Web application as such.  Wikipedia will give us the following definition: a client-server application in which the client is a browser, and the server is a web server.  The web application logic is distributed between the server and the client, data is stored primarily on the server, and information is exchanged over the network. <br><br>  Here begins the confusion associated directly with the architecture with which the Web application is implemented.  The fact is that the logic of the application can be located both on the server and on the client.  Different architectures distribute the logic between client and server in different ways. <br><br><a name="habracut"></a><br><br>  Unfortunately, it is impossible to objectively evaluate completely different architectures.  We will use the following criteria for evaluation: <br><br>  <b>User:</b> <br>  <i>Responsiveness / usability:</i> updating data on the page and switching between pages (response time).  The richness and convenience of the interface, its intuitiveness. <br>  <i>Linkability: the</i> ability to save bookmarks and links to different sections of the site. <br>  <i>Offline: the</i> ability to run the application without a network. <br><br>  <b>Developer:</b> <br>  <i>Development</i> speed <i>: the</i> speed of adding a new functional, refactoring, paralleling the development process between developers and layout designers, etc. <br>  <i>Performance: the</i> fastest possible response from the server with minimal computational power. <br>  <i>Scalability: the</i> ability to increase computing power or disk space due to the increasing amount of information or the number of users.  In the case of using a distributed scalable system, data consistency, availability and separation resistance should be ensured (CAP-theorem).  It should be noted that the number of features / screenshots of the application with increasing customer requirements (on the client side) does not apply to this definition - it rather depends not on the type of Web architecture, but on the framework used and execution. <br>  <i>Testability: the</i> ability and ease of testing (modular auto-testing). <br><br>  <b>Customer:</b> <br>  <i>Functional extensibility: the</i> ability to increase functionality with minimal time and money costs. <br>  <i>SEO:</i> users should be able to find the application using any search engine. <br>  <i>Support: the</i> cost of maintaining the infrastructure of the application - the cost of hardware, network infrastructure, staff needed to maintain the application. <br>  <i>Security:</i> The customer of the application must be confident in the safety of business data and the inaccessibility of data about other users.  As the main security criterion, we will consider only the possibility of changing the functionality of the application's behavior on the client, as well as the associated risks.  Standard threats (for example, analyzed in <a href="https://www.owasp.org/index.php/Main_Page">https://www.owasp.org/index.php/Main_Page</a> ) are the same for all compared architectures.  We do not take security into account on the server-client data transfer area due to the fact that all the architectures in question are equally susceptible to hacking ‚Äî the data transfer channel may be the same. <br>  <i>Conversion: site - mobile or desktop application: the</i> ability to publish the application on mobile markets, or wrap it in a desktop application with minimal additional cost. <br><br>  Perhaps some of the criteria or our estimates may seem incorrect to you;  but the purpose of this article is not to show ‚Äúwhat is good and what is bad‚Äù, but to make a more detailed review and show the possibility of choice. <br><br>  Let's try to highlight the main types of Web applications, depending on the roles performed by the server and browser (client). <br><br>  <b>Type 1: Server-side HTML</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e4/0c1/c12/9e40c1c122aec825fa4deaca4b1e8570.png" alt="image"><br><br>  The most common at the moment architecture.  The reason is that the server generates HTML content and sends it to the client as a full HTML page. <br>  Sometimes this architecture is called ‚ÄúWeb 1.0‚Äù, due to the fact that it appeared first, and is currently dominant in the Web. <br><br>  <i>Responsiveness / usability:</i> 1/5.  The least optimal of the considered architectures.  This is due to the fact that between the server and the client, it is necessary to transfer a huge amount of data that is responsible not only for the business data itself, but also for their design.  The user has to wait for the page to reload in response to trivial actions, for example, updating only a small part of the page.  UI templates on the client depend directly on the frameworks used on the server.  Due to the limited mobile Internet and large amounts of data sent, this architecture is practically not operational in the mobile segment.  There is no way to deliver instant data updates or changes in real time.  If we consider the possibility of changes in real time by generating on the server side and updating the client (via AJAX, WebSockets) in the form of ready-made pieces of content, plus design with the replacement of part of the page, then we will go beyond the boundaries of the architecture under consideration. <br>  <i>Linkability:</i> 5/5.  Of the architectures in question, linkability is the easiest to implement in this.  This is due to the fact that on the server by default a specific HTML content is assigned to one URL. <br>  <i>SEO:</i> 5/5.  It is implemented quite simply, similarly to the previous point - the page content is known in advance. <br>  <i>Development speed:</i> 5/5.  The oldest architecture, so it is possible to choose any server language and framework for specific needs. <br>  <i>Scalability</i> : 4/5.  If we consider the generation of HTML, then with increasing load in the end there is a moment when it is necessary to implement balancing for load distribution.  The situation with database scaling is much more complicated, but this task is the same and typical for all three architectures under consideration. <br>  <i>Productivity:</i> 3/5.  Closely related to responsiveness and scaling in terms of traffic, speed, etc.  The performance is low because it requires the transfer of the largest amount of data that contains HTML, design, as well as the business data itself.  Thus, it is necessary to generate data for the entire page (and not only for the changed business data), as well as all related information (for example, design). <br>  <i>Testability:</i> 4/5.  The positive aspect of this architecture is that, in general, special tools that support the interpretation of JavaScript are not needed for testing the front-end (since the content of the pages is static). <br>  <i>Security:</i> 4/5.  "You can not break what is not" - all the logic of the application is on the server.  At the same time, data is sent in open form, so a secure channel is recommended if necessary (as a matter of fact, for any architecture associated with the server).  All security functionality falls on the server side. <br>  <i>Conversion: site - mobile or desktop application:</i> 0/5.  In most cases, this is simply not possible.  The exception (or rather, exotic) are rare cases: for example, if you have a server implemented on node.js, and there are no large databases;  or if you use third-party web services to retrieve data (but this is already a more advanced version of the architecture).  Thus, you will wrap your application using node-webkit or analogs. <br>  <i>Offline:</i> 2/5.  It is implemented using a server manifest entered in the HTML5 specification.  If the browser supports this specification, all pages of the application will be cached, and if the user is disconnected from the network, the cached page will be displayed to the user. <br><br>  <b>Type 2: JS generation widgets (AJAX)</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f36/a4c/034/f36a4c034fb22ad3596ae0c081e917cd.png" alt="image"><br><br>  The development of architecture of the first type.  The difference is that the page displayed in the browser consists of widgets (functionally independent blocks).  The data in these widgets are loaded by an AJAX request from the server: or a full piece of HTML;  either in the form of JSON, and already with the help of JavaScript-template making / binding are converted into page content.  The option of loading pieces of HTML eliminates the need to use JavaScript-MV * frameworks on the client side, and in this case it is possible to get by with something simpler, for example, jQuery.  By reducing interactivity, we accelerate development speed and make the functionality cheaper and more reliable. <br><br>  The main advantage is that only data is sent from the server to update the part of the page that the client is requesting to update.  It is also good that the widgets are functionally separated, and changing the functionality of the part of the page for which a particular widget is responsible will not affect all of it. <br><br>  <i>Responsiveness / usability</i> : 3/5.  The amount of data sent to update only part of the page is much smaller than for the entire page, so there is more responsiveness.  But due to the fact that the page is a set of widgets, the UI templates used in the Web application are limited to the UI framework used.  It is worth mentioning that the ‚Äúcold start‚Äù (first full download) of such a web page will be a little longer.  Fully generated and cached content on the server can be instantly displayed on the client;  here, time is spent on getting data for the widget and, as a rule, on templating.  Thus, when you first enter the site will not open very quickly, but then it will be much nicer to work when compared with the first type of architecture.  It is also worth mentioning the possibility of implementing the download "in parts" (as it is done at <a href="http://www.yahoo.com/">http://www.yahoo.com/</a> ). <br>  <i>Linkability</i> : 2/5.  Special tools and mechanisms are needed.  Usually, a hash-bang mechanism is used. <br>  <i>SEO</i> : 2/5.  There are special mechanisms for these tasks.  For example, to promote sites of a given architecture, it is possible to determine in advance the list of pages being promoted and make static URLs for them, without parameters and modifiers. <br>  <i>Development speed:</i> 3/5.  It requires not only the knowledge of server side technologies, but also the use of JavaScript frameworks on the client side.  An implementation of server-side web services similarity is also required. <br>  <i>Productivity:</i> 4/5.  The time and resources spent on generating HTML content are relatively small compared to the time the application spends extracting data from the database and processing it before templating.  Using the extended type of this architecture (when data is transmitted as JSON), although it reduces traffic between the client and the server, it adds an additional level of abstraction to the application: extraction from the database -&gt; data processing, serialization in JSON -&gt; API: JSON -&gt; parsing JSON -&gt; binding the data object on the client to HTML. <br>  <i>Scalability:</i> similar to the first type of architecture. <br>  <i>Testability:</i> 1/5.  Required testing server side, client code and web service, which returns the data to update the widgets. <br>  <i>Security:</i> 4/5.  Part of the logic is rendered into client-side JavaScript, which can be easily modified by an attacker. <br>  <i>Conversion: site - mobile or desktop application:</i> similar to the first type of architecture. <br>  <i>Offline:</i> 1/5.  The manifest mechanism also works in this case, but the problem occurs when updating or caching the data displayed on the widget.  This functionality must be implemented additionally, since in the manifest, you can specify only the names of files that will be cached from the server.  The organization of the relationship between the name of the widget's template file cached in the manifest and the logic of page behavior requires additional work. <br><br>  <b>Type 3: Service-oriented single-page Web apps (Web 2.0, HTML5 apps)</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85e/a73/b4f/85ea73b4fae35d4691f2399809f8f043.png" alt="image"><br><br>  Here I want to make a small remark that the term ‚ÄúWeb 2.0‚Äù is not entirely correct to use here.  It was introduced for the first time by Tim O'Reilly as ‚Äúa technique for designing systems that, by taking into account network interactions, become better, the more people use them.‚Äù  And the feature of Web 2.0 is the principle of attracting users to the content and repeated reconciliation of information material.  In essence, the term ‚ÄúWeb 2.0‚Äù refers to projects and services that are actively developed and improved by the users themselves: blogs, wikis, social networks, etc. From this it follows that Web 2.0 is not tied to any single technology or set of technologies. <br><br>  The essence of the architecture under consideration is that an HTML page is loaded from the server, which is a container for JavaScript code that, when accessing a specific web service, receives only business data from it.  From which, in turn, the JavaScript application generates the HTML content of the page.  In essence, the third type of architecture is the development of the previous type and bringing it to the full-fledged level of independent, fairly complex JavaScript application by transferring some of the functionality to the client side.  The architecture of the second type usually cannot boast of a very large number of interrelated, structured functions. <br><br>  It should also be noted that JavaScript-based applications that work completely offline are now practically not made (with rare exceptions: <a href="http://www.wakanda.org/">http://www.wakanda.org/</a> , <a href="http://html.adobe.com/edge/code/">http://html.adobe.com/edge/code/</a> , <a href="http://cdn.sencha.io/touch/sencha-touch-2.2.1/examples/kitchensink/index.html">http: / /cdn.sencha.io/touch/sencha-touch-2.2.1/examples/kitchensink/index.html</a> , <a href="http://rad-js.com/">http://rad-js.com/</a> ), this approach allows you to perform an easy reverse conversion - publish an existing application in web <br><br>  <i>Responsiveness / usability:</i> 5/5.  The amount of data sent to update the information is minimal, so the maximum responsiveness.  The UI is generated using JavaScript, it is possible to implement any necessary options.  A subtle point is the issue of multithreading in JavaScript: in the case we are considering, processing large volumes of business data must be brought to the side of the web service) <br>  <i>Linkability:</i> 1/5.  Not only special tools and mechanisms are needed, but also frameworks that can use, for example, the Hash-Bang mechanism. <br>  <i>SEO:</i> 1/5.  The most difficult to promote architecture.  If the whole application is being promoted directly, there are no problems: the application container may be promoted.  If rotation of parts of the application is necessary, then of all the mechanisms at the moment there are only similar to the following: <a href="http://googlewebmastercentral.blogspot.com/2009/10/proposal-for-making-ajax-crawlable.html">http://googlewebmastercentral.blogspot.com/2009/10/proposal-for-making-ajax-crawlable.html</a> and <a href="http://seodacha.ru/news/yandeks-predlagaet-reshenie-dlya-indeksacii-ajax-saytov">http: // seodacha .ru / news / yandeks-predlagaet-reshenie-dlya-indeksacii-ajax-saytov</a> .  Each more or less large search engine offers its own methods of standardization of this process. <br>  <i>Development speed:</i> 2/5.  It requires the development of a web service and the use of more specialized (building the application architecture) JavaScript frameworks.  It is worth mentioning that due to the novelty of the architecture, so far there are few specialists who can make a really high-quality website / system with this approach;  few developed and developed tools, frameworks and approaches. <br>  <i>Productivity:</i> 5/5.  With this architecture, this characteristic has the least impact from the server side, since the server is only required to send the JS application to the browser.  On the client side, performance and type of browser is most important. <br>  <i>Scalability:</i> 5/5.  All Web-logic is placed on the client side, no load is generated on the server for generating content.  As the number of users increases, only web services that provide business data are scaled. <br>  <i>Testability:</i> 3/5.  Testing of web services and client-side JavaScript code is required. <br>  <i>Security:</i> 0/5.  All logic is rendered into client-side JavaScript, which can be easily modified by an attacker.  Therefore, for secure systems, it is necessary to develop a preventive architecture that takes into account the peculiarities of the organization of open-source applications <a href="http://aosabook.org/en/index.html">http://aosabook.org/en/index.html</a> ‚Äî for example, a variant with a third-party key distribution channel. <br>  <i>Conversion: site - mobile or desktop application:</i> 5/5.  The site quietly turns into an application using platforms such as <a href="http://phonegap.com/">http://phonegap.com/</a> , <a href="https://github.com/rogerwang/node-webkit">https://github.com/rogerwang/node-webkit</a> , <a href="https://code.google.com/p/chromiumembedded/">https://code.google.com/p/chromiumembedded/</a> and others similar <br>  <i>Offline:</i> 5/5.  This architecture is a complete application;  it is possible to save both individual data and parts of the application itself using any storage (for example, localstorage).  Another plus is that you can completely switch the storage and management of data to offline mode;  while the two previous architectures are only partially functional offline.  Here, the missing data can be replaced with plugs, you can show warning windows or use data from the local storage, leaving the synchronization for later. <br><br>     - ,   ,       ‚Äî          .    ,       ¬´¬ª,    ,      ,       ,    -  . <br><br>  ,   ,     ‚Äî          .          ,      -. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0b/aa6/ecf/e0baa6ecf54b06014c8178dcab1192ec.png" alt="image"><br><br>          ;           . </div><p>Source: <a href="https://habr.com/ru/post/195548/">https://habr.com/ru/post/195548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195532/index.html">Internet for people with impaired color perception and not only. The idea of ‚Äã‚Äãsolving the problem at the global level</a></li>
<li><a href="../195534/index.html">Life hacking 187-FZ: we send links by e-mail</a></li>
<li><a href="../195538/index.html">An enthusiast from Chervonograd, regardless of the state, wants to develop the space industry</a></li>
<li><a href="../195540/index.html">"Remington" - the first typewriter</a></li>
<li><a href="../195542/index.html">Erlang for the little ones. Chapter 1: Data Types, Variables, Lists, and Tuples</a></li>
<li><a href="../195550/index.html">Facebook added the ability to edit posts in the feed</a></li>
<li><a href="../195552/index.html">8+ in 1: how I wanted to attract attention</a></li>
<li><a href="../195558/index.html">Getting ready for CCNA Security (IINS 554)</a></li>
<li><a href="../195562/index.html">Jet manifest</a></li>
<li><a href="../195564/index.html">The third version of the typograph Muravyov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>