<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Polynomial hashes and their applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, habr. Today I will write how to use polynomial hashes (hereinafter referred to as simply hashes) when solving various algorithmic problems. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Polynomial hashes and their applications</h1><div class="post__text post__text-html js-mediator-article">  Hello, habr.  Today I will write how to use polynomial hashes (hereinafter referred to as simply hashes) when solving various algorithmic problems. <br><br><h4>  Introduction </h4><br>  Let's start with the definition.  Suppose we have the string <i>s <sub>0..n-1</sub></i> .  The polynomial hash of this string is the number <i>h = hash (s <sub>0..n-1</sub> ) = s <sub>0</sub> + ps <sub>1</sub> + p <sup>2</sup> s <sub>2</sub> + ... + p <sup>n-1</sup> s <sub>n-1</sub></i> , where <i>p</i> is a natural number (later it is said which one), and <i>s <sub>i</sub></i> is the code of the <i>i-th</i> character of the string <i>s</i> (in almost all modern languages ‚Äã‚Äãit is written <code>s[i]</code> ). <br><br>  Hashes have the property that the same hash lines are equal.  Therefore, the main operation that hashes allow you to perform is a quick comparison of two substrings for equality. <a name="habracut"></a>  Of course, to compare 2 strings, we can write a similar function (we will assume that the lengths of the strings <i>s</i> and <i>t are the</i> same and equal to <i>n</i> ): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s[i] != t[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  However, in the worst case, this function is obliged to check all the characters, which gives the asymptotics of <i>O (n)</i> . <br><br><h4>  String comparison using hashes </h4><br>  Now let's see how the hashes do it.  Since the hash is just a number, we need <i>O (1)</i> time to compare them.  However, in order to find the hash of one substring in a naive way, it takes <i>O (n)</i> time.  Therefore, you will need to tinker a bit with mathematical formulas and learn how to find <u>all the</u> substrings at <u>once</u> for <i>O (n)</i> hashes.  Let's compare the substrings <i>s <sub>L..R</sub></i> and <i>t <sub>X..Y</sub></i> (of the same length).  Using the definition of a hash, we can write: <br><br>  <i>s <sub>L</sub> + ps <sub>L + 1</sub> + ... + p <sup>RL-1</sup> s <sub>R-1</sub> + p <sup>RL</sup> s <sub>R</sub> = t <sub>X</sub> + pt <sub>X + 1</sub> + ... + p <sup>YX-1</sup> t <sub>Y-1</sub> + p <sup>YX</sup> t <sub>Y</sub></i> <br><br>  Let's make small transformations on the left side (on the right side, everything will be similar).  We write the hash of the substring <i>s <sub>0..R</sub></i> , we need it: <br><br>  <i>hash (s <sub>0..R</sub> ) = s <sub>0</sub> + ps <sub>1</sub> + ... + p <sup>L-1</sup> s <sub>L-1</sub> + p <sup>L</sup> s <sub>L</sub> + p <sup>L + 1</sup> s <sub>L + 1</sub> + ... + p <sup>R-1</sup> s <sub>R-1</sub> + p <sup>R</sup> s <sub>R</sub></i> <br><br>  We divide this expression into two parts ... <br><br>  <i>hash (s <sub>0..R</sub> ) = (s <sub>0</sub> + ps <sub>1</sub> + ... + p <sup>L-1</sup> s <sub>L-1</sub> ) + (p <sup>L</sup> s <sub>L</sub> + p <sup>L + 1</sup> s <sub>L + 1</sub> + ... + p <sup>R-1</sup> s <sub>R-1</sub> + p <sup>R</sup> s <sub>R</sub> )</i> <br><br>  ... and we take out the factor p <sup>L</sup> from the second bracket: <br><br>  <i>hash (s <sub>0..R</sub> ) = (s <sub>0</sub> + ps <sub>1</sub> + ... + p <sup>L-1</sup> s <sub>L-1</sub> ) + p <sup>L</sup> (s <sub>L</sub> + ps <sub>L + 1</sub> + ... + p <sup>RL-1</sup> s <sub>R-1</sub> + p <sup>RL</sup> s <sub>R</sub> )</i> <br><br>  The expression in the first parenthesis is nothing but the hash of the substring <i>s <sub>0..L-1</sub></i> , and in the second, the hash of the substring we need <i>s <sub>L..R</sub></i> .  So, we got that: <br><br>  <i>hash (s <sub>0..R</sub> ) = hash (s <sub>0..L-1</sub> ) + p <sup>L</sup> hash (s <sub>L..R</sub> )</i> <br><br>  Hence the following formula for <i>hash (s <sub>L..R</sub> )</i> : <br><br>  <i>hash (s <sub>L..R</sub> ) = (1 / p <sup>L</sup> ) (hash (s <sub>0..R</sub> ) - hash (s <sub>0..L-1</sub> ))</i> <br><br>  Similarly, for our second substring, the equality <i>hash (t <sub>X..Y</sub> ) = (1 / p <sup>X</sup> ) (hash (t <sub>0..Y</sub> ) - hash (t <sub>0..X-1</sub> )) will be <sub>true</sub></i> . <br><br>  Looking carefully at these formulas, you can see that to calculate the hash of any substring, we only need to know the hash of the prefixes of this string <i>s <sub>0..0</sub></i> , <i>s <sub>0..1</sub></i> , ..., <i>s <sub>0..n-2</sub></i> , <i>s <sub>0. .n-1</sub></i> .  And, since the hash of each of the next prefix is ‚Äã‚Äãexpressed through the hash of the previous one, they are easy to count as a linear pass through the line.  All at once for <i>O (n)</i> time.  The powers of <i>p</i> must also be pre-calculated and stored in an array. <br><br>  Code example: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      p,     pow[0] = 1; for (int i = 1; i &lt;= MAX; i++) { pow[i] = pow[i - 1] * p; } //     s hs[0] = s[0]; for (int i = 1; i &lt; n; i++) { hs[i] = hs[i - 1] + pow[i] * s[i]; } //     t ht[0] = t[0]; for (int i = 1; i &lt; m; i++) { ht[i] = ht[i - 1] + pow[i] * t[i]; }</span></span></code> </pre><br>  It would seem that we are now fully armed and able to compare 2 any substrings for <i>O (1)</i> .  But not everything is so simple: mathematical formulas need some refinement.  For example, a similar code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((hs[R] - hs[L - <span class="hljs-number"><span class="hljs-number">1</span></span>]) / pow[L] == (ht[Y] - ht[X - <span class="hljs-number"><span class="hljs-number">1</span></span>]) / pow[X]) { ... }</code> </pre>  will not work. <br><ul><li>  Remark the first: <i>L</i> (or <i>X</i> ) can appear equal to zero, and at calculation of <code>hs[L - 1]</code> there will be an exit for array borders.  However, if <i>L</i> is zero, then the hash of the substring <i>s <sub>L..R of interest</sub></i> is stored exactly in <code>hs[R]</code> .  Therefore, instead of <code>hs[L - 1]</code> , it is more correct to write like this: <br><pre> <code class="java hljs">L == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : hs[L - <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre>  . </li><li>  Second note: even the <code>long</code> type contains only 64 bits (I use Java), and our strings can be several thousand long, and an overflow will inevitably occur when calculating hashes.  The easiest way to solve this problem is to close your eyes to it.  Well, or almost close: we will have hashes, in fact, modulo 2 <sup>64</sup> (and therefore it will not be necessary to perform the operations of taking the remainder of the division - beauty!).  The number <i>p</i> for counting them must be, firstly, greater than the code of the largest character in the lines, and secondly, mutually simple with the module (in our case, it is 2 <sup>64</sup> , that is, it must be odd).  Why so, I will not tell here - you can read about it in books on algebra.  Of course, the probability of a collision inevitably appears, but it is extremely small, therefore, when solving Olympiad problems, it can simply be neglected. </li><li>  Third note: since we now perform all operations on a module, the division is not available to us (more precisely, it is <a href="http://e-maxx.ru/algo/reverse_element">available</a> , but writing it is rather inefficient).  Therefore, it is necessary to get rid of it.  This is done quite simply, in a way that is called ‚Äúproportion‚Äù in school: the expression is reduced to a common denominator, and multiplication is used instead of division: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((hs[R] - (L == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : hs[L - <span class="hljs-number"><span class="hljs-number">1</span></span>])) * pow[X] == (ht[Y] - (X == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : ht[X - <span class="hljs-number"><span class="hljs-number">1</span></span>])) * pow[L]) { ... }</code> </pre></li></ul><br>  Now we take a closer look at the tasks where you can use hashes. <br><br><h4>  Tasks solved using hashes </h4><br><h5>  1. Comparing substrings </h5><br>  The first and most important application, as already mentioned, is a quick comparison of two substrings - all other algorithms with hashes are based on it.  The code in the last section is rather cumbersome, so I will write a more convenient code that will be used in the future. <br>  The following function calculates the hash of the substring <i>s <sub>L..R</sub></i> multiplied by <i>p <sup>L</sup></i> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> L, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> R)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = h[R]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (L &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result -= h[L - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Now we are comparing the two substrings with the following line: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getHash(hs, L, R) * pow[X] == getHash(ht, X, Y) * pow[L]) { ... }</code> </pre><br>  Multiplication by degrees of the number <i>p</i> can be called ‚Äúreduction to one degree‚Äù.  The first hash was multiplied by <i>p <sup>L</sup></i> , and the second one - by <i>p <sup>X</sup></i> - means that the comparison would take place correctly, they must be multiplied by the missing factor. <br>  Note: it makes sense to first check whether the lengths of the substrings match.  If not, then the lines in principle can not be equal, and then you can not check the above condition. <br><br><h5>  2. Search for a substring in the string for <i>O (n + m)</i> </h5><br>  Hashes allow you to search for a substring in a string for asymptotically minimal time.  This makes the so-called Rabin-Karp algorithm. <br>  Let there be a string <i>s of</i> length <i>n</i> in which we want to find all occurrences of string <i>t of</i> length <i>m</i> .  We will find the hash of the string <i>t</i> (the entire string as a whole) and the hashes of all the prefixes of the string <i>s</i> , and then we will move along the string <i>s with a</i> window of length <i>m</i> , comparing substrings <i>s <sub>i..i + m-1</sub></i> . <br>  Code: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    t long ht = t[0]; for (int i = 1; i &lt; m; i++) { ht += pow[i] * t[i]; } //    for (int i = 0; i + m &lt;= n; i++) { if (getHash(h, i, i + m - 1) == ht * pow[i]) { //     i } }</span></span></code> </pre><br><h5>  3. Finding the z-function for <i>O (n log n)</i> </h5><br>  <a href="http://ru.wikipedia.org/wiki/Z-%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F">A z-function of</a> string <i>s</i> is an array <i>z</i> , whose <i>i-</i> th element is equal to the longest prefix of a substring starting at position <i>i</i> in string <i>s</i> , which is also the prefix of the entire string <i>s</i> .  The value of the z-function in the zero position will be considered equal to the length of the string <i>s</i> , although some sources take it for zero (but this is not critical). <br><br>  Of course, there is an <a href="http://e-maxx.ru/algo/z_function">algorithm for</a> finding the z-function for <i>O (n)</i> .  But when you don‚Äôt know it or don‚Äôt remember it (and the algorithm is rather cumbersome), hashes come to the rescue. <br><br>  The idea is as follows: for each <i>i = 0, 1, ..., n-1,</i> we search for <i>z <sub>i by a</sub></i> binary search, i.e.  at each iteration, reducing the interval of possible values ‚Äã‚Äãby half.  This is correct, because the equality <i>s <sub>0..k-1</sub> = s <sub>i..i + k-1 is</sub></i> necessarily satisfied for all <i>k</i> , less than <i>z <sub>i</sub></i> , and is not necessarily fulfilled for large <i>k</i> . <br><br>  Code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] z = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = <span class="hljs-number"><span class="hljs-number">1</span></span>, right = n - i; <span class="hljs-comment"><span class="hljs-comment">//    while (left &lt;= right) { //  middle -   int middle = (left + right) / 2; //  ,    s[0..middle-1]  s[i..i+middle-1] if (getHash(h, 0, middle - 1) * pow[i] == getHash(h, i, i + middle - 1)) { //  ,      middle,      z[i] = middle; left = middle + 1; } else { //   ,     right = middle - 1; } } }</span></span></code> </pre><br><h5>  4. Search for a lexicographically minimum cyclic row shift for <i>O (n log n)</i> . </h5><br>  There is <a href="http://e-maxx.ru/algo/duval_algorithm">Duval's algorithm</a> , which allows solving this problem for <i>O (n)</i> , however, I know some pretty strong olympiad programmers who never understood it.  As long as they understand it, we will again apply the hashes. <br><br>  The algorithm is as follows.  First we take the string <i>s</i> itself for the best (lexicographically minimal) answer.  Then for each cyclic shift using a binary search we find the length of the maximum total prefix of this shift and the current best answer.  After that, it suffices to compare the characters following the prefix and, if necessary, update the answer. <br>  We also note that for convenience, it is recommended to assign the string <i>s</i> to itself ‚Äî you do not have to do modulo operations when referring to the characters of the string <i>s</i> .  We assume that this has already been done. <br><br>  Code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bestPos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = <span class="hljs-number"><span class="hljs-number">1</span></span>, right = n, length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  length -     while (left &lt;= right) { int middle = (left + right) / 2; if (getHash(h, bestPos, bestPos + middle - 1) * pow[i] == getHash(h, i, i + middle - 1) * pow[bestPos]) { length = middle; left = middle + 1; } else { right = middle - 1; } } //          //      n, //       , //      if (length &lt; n &amp;&amp; s[i + length] &lt; s[bestPos + length]) { bestPos = i; } }</span></span></code> </pre><br>  Note: in fact, a comparator is written inside the <code>for</code> loop that compares two cyclic shifts lexicographically.  Using it, it is possible to sort all cyclic shifts for <i>O (n log <sup>2</sup> n)</i> . <br><br><h5>  5. Search all palindromes in the line for <i>O (n log n)</i> . </h5><br>  Again, there is a <a href="http://e-maxx.ru/algo/palindromes_count">solution to</a> this problem for <i>O (n)</i> .  And again we will solve it with the help of hashes. <br><br>  The substring <i>s <sub>L..R</sub></i> is called a palindrome if <i>s <sub>L</sub> = s <sub>R</sub></i> , <i>s <sub>L + 1</sub> = s <sub>R-1</sub></i> , etc.  If expressed in Russian, this means that it is read equally from left to right and from right to left. <br><br>  Perhaps you already know or have guessed what the hashes are.  In addition to the array <code>h[]</code> containing the hashes for the substrings <i>s <sub>0..0</sub></i> , <i>s <sub>0..1</sub></i> , ..., <i>s <sub>0..n-2</sub></i> , <i>s <sub>0..n-1</sub></i> , we calculate the second array <code>rh[]</code> (for "Inverted" line), which we will bypass from right to left.  It will contain, respectively, hashes <i>s <sub>0..n-1</sub></i> , <i>s <sub>1..n-1</sub></i> , ..., <i>s <sub>n-2..n-1</sub></i> , <i>s <sub>n-1..n-1</sub></i> : <br><pre> <code class="java hljs">rh[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] = s[n - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = n - <span class="hljs-number"><span class="hljs-number">2</span></span>, j = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--, j++) { rh[i] = rh[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] + pow[j] * s[i]; }</code> </pre><br>  It should be clear how to determine if <i>O (1)</i> is a palindrome.  I will write a getRevHash () function, similar to getHash (), and then give the necessary condition for comparison.  You can verify for yourself the correctness of this expression by doing mathematical calculations similar to those given at the beginning of the article. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRevHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> L, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> R)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = rh[L]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (R &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>) result -= rh[R + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPalindrome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] pow, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> L, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> R)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getHash(h, L, R) * pow[n - R - <span class="hljs-number"><span class="hljs-number">1</span></span>] == getRevHash(rh, L, R) * pow[L]; }</code> </pre><br>  Now consider the position of <i>i</i> in the string.  Let there be a palindrome of odd length <i>d</i> centered at position <i>i</i> (in the case of an even length, centered between positions <i>i-1</i> and <i>i</i> ).  If one symbol is cut from its edges, it will remain a palindrome.  And so you can continue until its length becomes zero. <br>  Thus, it is enough for us to store 2 values ‚Äã‚Äãfor each position: how many odd length palindromes exist with center at position <i>i</i> , and how many even length palindromes exist with center between positions <i>i-1</i> and <i>i</i> .  Please note that these 2 values ‚Äã‚Äãare completely independent of each other, and they must be processed separately. <br><br>  Let's apply, as before, binary search: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] oddCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = <span class="hljs-number"><span class="hljs-number">1</span></span>, right = min(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, n - i); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &lt;= right) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = (left + right) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPalindrome(h, rh, pow, i - middle + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + middle - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { oddCount[i] = middle; left = middle + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { right = middle - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] evenCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[n]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = <span class="hljs-number"><span class="hljs-number">1</span></span>, right = min(i, n - i); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (left &lt;= right) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = (left + right) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPalindrome(h, rh, pow, i - middle, i + middle - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { evenCount[i] = middle; left = middle + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { right = middle - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>  Now you can, for example, find the total number of all palindromes in a string, or the length of the maximum palindrome.  The length of the maximum odd palindrome with center in position <i>i</i> is counted as <code>2 * oddCount[i] - 1</code> , and the maximum even palindrome - <code>2 * evenCount[i]</code> . <br>  Once again I remind you that you need to be more careful with palindromes of even and odd length - as a rule, they must be processed independently of each other. <br><br><h4>  Hashes in matrices </h4><br>  Finally, consider the more sophisticated use of hashes.  Now our space will be two-dimensional, and we will compare submatrices.  Fortunately, hashes are very well generalized to the two-dimensional case (I have not met three-dimensional or more). <br><br>  Now, instead of the number <i>p</i> and the <code>pow</code> array, we will have two different numbers <i>p</i> , <i>q</i> and two <code>pow1</code> , <code>pow2</code> : one number and one array in each direction: vertically and horizontally. <br><br>  The hash of the matrix <i>a <sub>0..n-1, 0..m-1 is</sub></i> called the sum over all <i>i = 0, ..., n-1</i> , <i>j = 0, ..., m-1 of the</i> quantities <i>p <sup>i</sup> q <sup>j</sup> a <sub>ij</sub></i> . <br><br>  Now let's learn how to count hashes of submatrices containing the upper left element <i>a <sub>00</sub></i> .  Obviously, <i>hash (a <sub>0..0, 0..0</sub> ) = a <sub>00</sub></i> .  It is almost as obvious that for all <i>j = 1, ..., m-1</i> <i>hash (a <sub>0..0, 0..j</sub> ) = hash (a <sub>0..0, 0..j-1</sub> ) + q <sup>j</sup> a <sub>0j</sub></i> , for all <i>i = 1, ..., n-1</i> <i>hash (a <sub>0..i, 0..0</sub> ) = hash (a <sub>0..i-1, 0..0</sub> ) + p <sup>i</sup> a <sub>i0</sub></i> .  This directly follows from the one-dimensional case. <br><br>  How to calculate the hash of the submatrix <i>a <sub>0..i, 0..j</sub></i> ?  You can guess that <i>hash (a <sub>0..i, 0..j</sub> ) = hash (a <sub>0..i-1, 0..j</sub> ) + hash (a <sub>0..i, 0..j-1</sub> ) - hash (a <sub>0..i-1, 0..j-1</sub> ) + p <sup>i</sup> q <sup>j</sup> a <sub>ij</sub></i> .  This formula can be obtained from the following considerations: we add up all the terms (a hash, remember, this is the sum of several terms) that make up the hash of submatrices <i>a <sub>0..i-1, 0..j</sub></i> and <i>a <sub>0..i, 0..j-1</sub></i> .  In this case, we twice took into account the terms that make up the submatrix <i>a <sub>0..i-1, 0..j-1</sub></i> , so we subtract them so that they are counted once.  Now, only the element <i>a <sub>ij</sub></i> multiplied by the corresponding powers of <i>p</i> and <i>q</i> is missing. <br><br>  Approximately from the same considerations as in the first part of the article (have you already noticed the involvement of the inclusion-exception formula?), A function is constructed to calculate the hash of an arbitrary submatrix <i>a <sub>x1..x2, y1..y2</sub></i> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMatrixHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = h[x2][y2]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x1 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result -= h[x1 - <span class="hljs-number"><span class="hljs-number">1</span></span>][y2]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y1 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result -= h[x2][y1 - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x1 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y1 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result += h[x1 - <span class="hljs-number"><span class="hljs-number">1</span></span>][y1 - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  This function returns the hash of the submatrix <i>a <sub>x1..x2, y1..y2</sub></i> multiplied by the value of <i>p <sup>x1</sup> q <sup>y1</sup></i> . <br><br>  And the comparison of two submatrices <i>a <sub>ax1..ax2, ay1..ay2</sub></i> and <i>a <sub>bx1..bx2, by1..by2</sub></i> is performed using the following expression: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getMatrixHash(h, ax1, ax2, ay1, ay2) * pow1[bx1] * pow2[by1] == getMatrixHash(h, bx1, bx2, by1, by2) * pow1[ax1] * pow2[ay1]) { ... }</code> </pre><br>  Heshes can also solve problems associated with finding the largest symmetric submatrix and similar to them.  And I do not know comparable with the hashes in speed and simplicity of the algorithms that perform this work.  Here, the same principles are used as in the search for palindromes in the one-dimensional case (i.e., consider ‚Äúreversed‚Äù hashes from right to left and bottom-up, conduct bin search separately for submatrices of even and odd length).  I suggest trying to solve this problem on your own - this article will help you! <br><br><h4>  Conclusion </h4><br>  So, we have a pretty good machine at our disposal, which allows us to do many things either with the best possible asymptotics, or only slightly (logarithm times) more slowly than specialized algorithms.  Not bad, right? </div><p>Source: <a href="https://habr.com/ru/post/142589/">https://habr.com/ru/post/142589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142584/index.html">Creating plugins for Redmine</a></li>
<li><a href="../142585/index.html">Wt, C ++ Library for Web Application Development</a></li>
<li><a href="../142586/index.html">The problem of the popularity of Ruby and Ruby on Rails - bad documentation</a></li>
<li><a href="../142587/index.html">13 tools for community-based crowdfunding</a></li>
<li><a href="../142588/index.html">How to make a good promotional video for a startup. Part 2. Right off the bat</a></li>
<li><a href="../142590/index.html">7 reasons why AngularJS is cool</a></li>
<li><a href="../142592/index.html">Perlin Noise</a></li>
<li><a href="../142593/index.html">When you connect the IPTV service you</a></li>
<li><a href="../142594/index.html">Erlang. Recommendations for code design</a></li>
<li><a href="../142595/index.html">So, you decided to prohibit copying class objects in C ++.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>