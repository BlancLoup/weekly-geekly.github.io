<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimizing the rendering of scenes from the Disney cartoon "Moana". Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will look at two more places in which pbrt spends a lot of time parsing scenes from the Disney cartoon Moana . Let's see if we can improve pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimizing the rendering of scenes from the Disney cartoon "Moana". Part 3</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg" alt="image"></div><br>  Today we will look at two more places in which pbrt spends a lot of time parsing scenes from the Disney cartoon <em>Moana</em> .  Let's see if we can improve performance here.  This concludes what is reasonable to do in pbrt-v3.  In another post, I will deal with how far we can go if we give up the ban on making changes.  In this case, the source code will be too different from the system described in the book <em>Physically Based Rendering</em> . <br><br><h2>  Optimization of the parser itself </h2><br>  After the performance improvements introduced in the <a href="https://habr.com/post/417445/">previous article</a> , the proportion of time spent in the pbrt parser, and so significant from the outset, naturally increased even more.  Currently the most time is spent on the parser at startup. <br><br>  I finally braced up and <a href="https://github.com/mmp/pbrt-v3/commit/ea34ef7452601e53c3c3ade4cce11ec5e55e49d2">implemented a</a> handwritten tokenizer <a href="https://github.com/mmp/pbrt-v3/commit/ea34ef7452601e53c3c3ade4cce11ec5e55e49d2">and parser</a> for pbrt scenes.  <a href="http://pbrt.org/fileformat-v3.html">The pbrt scene file format parsing is</a> quite simple: if you do not take into account the quoted lines, the tokens are separated by spaces, and the grammar is very straightforward (you never need to look further than one token), but your own parser is still a thousand lines of code write and debug.  It helped me that it could be tested on many scenes;  after correcting the obvious failures, I continued to work until I managed to render exactly the same images as before: there should be no difference in pixels due to the replacement of the parser.  At this stage I was absolutely sure that everything was done correctly. <br><a name="habracut"></a><br>  I tried to make the new version as efficient as possible by exposing the <code>mmap()</code> input files as much as possible and using the new implementation of <a href="http://en.cppreference.com/w/cpp/string/basic_string_view"><code>std::string_view</code></a> from C ++ 17 to minimize the creation of copies of lines from the contents of the file.  In addition, since the previous traces took a lot of time on <code>strtod()</code> , I wrote <a href=""><code> parseNumber()</code></a> with special care: single-digit integers and regular integers are processed separately, and in the standard case when pbrt is compiled to use 32-bit float , applied <code>strtof()</code> instead of <code>strtod()</code> <sup>1</sup> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the process of creating a new parser implementation, I was a little afraid that the old parser would be faster: after all, flex and bison have been developed and optimized for many years.  I could not find out in advance whether all the time to write a new version would be wasted until I completed it and did not get it to work properly. <br><br>  To my delight, my own parser turned out to be a huge victory: the generalization of flex and bison reduced performance so much that the new version easily overtook them.  Thanks to the new parser, the launch time decreased to 13 minutes 21 seconds, that is, it accelerated another 1.5 times!  An added bonus was that from the pbrt build system it was now possible to remove all flex and bison support.  It has always been a headache, especially under Windows, where most people don‚Äôt have them installed by default. <br><br><h2>  Graphic State Management </h2><br>  After the parser significantly accelerated, a new annoying detail surfaced: at this stage, approximately 10% of the setup time was spent on the <code>pbrtAttributeBegin()</code> and <code>pbrtAttributeEnd()</code> functions, and most of this time was allocated to allocating and freeing dynamic memory.  During the first start, which took 35 minutes, these functions took only about 3% of the execution time, so they could be ignored.  But when optimizing it is always like this: when you start to get rid of big problems, small ones become more important. <br><br>  The pbrt scene description is based on the hierarchical state of the graphics, which indicates the current transformation, the current material, and so on.  You can take snapshots of the current state ( <code>pbrtAttributeBegin()</code> ), make changes to it before adding a new geometry to the scene, and then return to the original state ( <code>pbrtAttributeEnd()</code> ). <br><br>  The graphics state is stored in a structure with an unexpected name ... <code>GraphicsState</code> .  To store copies of <code>GraphicsState</code> objects in the stack of saved graphics states, use <code>std::vector</code> .  Looking at the members of the <code>GraphicsState</code> , we can assume the source of the problems - three <code>std::map</code> , from names to instances of textures and materials: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GraphicsState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Float&gt;&gt;&gt; floatTextures; std::map&lt;std::string, std::shared_ptr&lt;Texture&lt;Spectrum&gt;&gt;&gt; spectrumTextures; std::map&lt;std::string, std::shared_ptr&lt;MaterialInstance&gt;&gt; namedMaterials; };</span></span></code> </pre> <br>  Exploring these scene files, I found that most cases of saving and restoring the state of the graphics are performed on these lines: <br><br><pre> <code class="cpp hljs">AttributeBegin ConcatTransform [<span class="hljs-number"><span class="hljs-number">0.981262</span></span> <span class="hljs-number"><span class="hljs-number">0.133695</span></span> <span class="hljs-number"><span class="hljs-number">-0.138749</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">-0.067901</span></span> <span class="hljs-number"><span class="hljs-number">0.913846</span></span> <span class="hljs-number"><span class="hljs-number">0.400343</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">0.180319</span></span> <span class="hljs-number"><span class="hljs-number">-0.383420</span></span> <span class="hljs-number"><span class="hljs-number">0.905800</span></span> <span class="hljs-number"><span class="hljs-number">0.000000</span></span> <span class="hljs-number"><span class="hljs-number">11.095301</span></span> <span class="hljs-number"><span class="hljs-number">18.852249</span></span> <span class="hljs-number"><span class="hljs-number">9.481399</span></span> <span class="hljs-number"><span class="hljs-number">1.000000</span></span>] ObjectInstance <span class="hljs-string"><span class="hljs-string">"archivebaycedar0001_mod"</span></span> AttributeEnd</code> </pre> <br>  In other words, it updates the current transformation and creates an object instance;  No changes are made to the contents of these <code>std::map</code> .  Creating a full copy of them ‚Äî allocating nodes of a red-black tree, increasing the reference counters of common pointers, allocating space, and copying lines ‚Äî is almost always a waste of time.  All this is released when the previous state of the graphics is restored. <br><br>  I replaced each of these maps with the pointer <code>std::shared_ptr</code> with a map and implemented the copy-on-write approach, in which copying inside the begin / end of the attribute occurs only when its content needs to be changed.  <a href="https://github.com/mmp/pbrt-v3/commit/65d90464ad30c83d8e7e256c6e0daddca0c6d7ca">The change</a> was not particularly difficult, but it reduced the launch time by more than a minute, which gave us 12 minutes and 20 seconds of processing before rendering - again acceleration 1.08 times. <br><br><h2>  What about rendering time? </h2><br>  The attentive reader will notice that while I did not say anything about the rendering time.  To my surprise, it turned out to be quite tolerable even ‚Äúout of the box‚Äù: pbrt can render images of cinematic-quality scenes with several hundred samples per pixel on twelve processor cores over a period of two to three hours.  For example, this image, one of the slowest, rendered in 2 hours and 51 minutes and 36 seconds: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/025/729/0d7025729325723a1c454f795c17af39.jpg"></div><br>  <i>Dunes from Moana, rendered <a href="https://github.com/mmp/pbrt-v3">pbrt-v3</a> with a resolution of 2048x858 with 256 samples per pixel.</i>  <i>The total rendering time on the Google Compute Engine instance with 12 cores / 24 threads with a frequency of 2 GHz and the latest version of pbrt-v3 was 2 h 51 min 36 s.</i> <br><br>  In my opinion this seems to be a surprisingly reasonable indicator.  I am sure that improvements are still possible, and after careful study of the places where the most time is spent, a lot of ‚Äúinteresting‚Äù things will open, but so far there are no special reasons for their research. <br><br>  When profiling, it turned out that approximately 60% of the rendering time was spent on intersecting rays with objects (most of the operations were performed during the BVH bypass), and 25% was spent on searching for ptex textures.  These ratios are similar to the indicators of simpler scenes, so at first glance there is nothing obviously problematic here.  (However, I am confident that Embree will be able to trace these rays in a little less time.) <br><br>  Unfortunately, parallel scalability is not so good.  I usually see that 1400% of CPU resources are spent on rendering, compared to the 2400% ideal (per 24 virtual CPUs on Google Compute Engine).  It seems that the problem is related to conflicts with locks in ptex, but I haven‚Äôt investigated it in more detail yet.  It is very likely that the pbrt-v3 does not compute the ray difference for indirect rays in the ray tracer;  in turn, such rays always get access to the most detailed MIP-level of textures, which is not very useful for texture caching. <br><br><h2>  Conclusion (for pbrt-v3) </h2><br>  Having corrected the management of the state of the graphics, I rested on the limit, after which further progress without making significant changes to the system was not obvious;  all the rest took a lot of time and was not very optimistic.  Therefore, I‚Äôll dwell on this, at least as far as pbrt-v3 is concerned. <br><br>  In general, the progress was serious: the launch time before rendering decreased from 35 minutes to 12 minutes and 20 seconds, that is, the total acceleration was 2.83 times.  Moreover, thanks to clever work with the conversion cache, the memory usage has decreased 80 GB to 69 GB.  All these changes are available now, if you are synchronized with the latest version of pbrt-v3 (or if you have done this in the last few months.) And we come to understand how garbage is <code>Primitive</code> memory for this scene;  we figured out how to save another 18 GB of memory, but did not implement it in pbrt-v3. <br><br>  This is what these 12 minutes and 20 seconds are spent on after all our optimizations: <br><br><table><thead><tr><th>  Function / operation </th><th>  Percentage of execution time </th></tr></thead><tbody><tr><td>  Build BVH </td><td>  34% </td></tr><tr><td>  Parsing (except <code>strtof()</code> ) </td><td>  21% </td></tr><tr><td> <code>strtof()</code> </td> <td>  20% </td></tr><tr><td>  Conversion cache </td><td>  7% </td></tr><tr><td>  Read PLY files </td><td>  6% </td></tr><tr><td>  Allocation of dynamic memory </td><td>  five% </td></tr><tr><td>  Conversion mapping </td><td>  2% </td></tr><tr><td>  Graphic State Management </td><td>  2% </td></tr><tr><td>  Other </td><td>  3% </td></tr></tbody></table><br>  In the future, even better multithreading of the launch phase will be the best option for improving performance: almost everything during scene parsing is single-threaded;  our most natural first goal is building a BVH.  It will also be interesting to analyze such things as reading PLY files and generating BVH for individual instances of objects and executing them asynchronously in the background, while parsing will be done in the main thread. <br><br>  At some point, I'll see if there are faster implementations of <code>strtof()</code> ;  pbrt uses only what the system provides.  However, it is worth being careful with the choice of replacements that are not very carefully tested: parsing of float values ‚Äã‚Äãis one of those aspects of which the programmer must be completely sure. <br><br>  A further reduction in the load on the parser also looks attractive: we still have 17 GB of text input files for parsing.  We can add support for binary encoding of the pbrt input files (perhaps, by analogy with <a href="https://renderman.pixar.com/resources/RenderMan_20/ribBinding.html">the RenderMan approach</a> ), but I have mixed feelings about this idea;  The ability to open and edit scene description files in a text editor is quite useful, and I worry that sometimes binary coding will confuse students using pbrt in the learning process.  This is one of those cases where the correct solution for pbrt may differ from the solutions for a commercial production-level renderer. <br><br>  It was very interesting to keep track of all these optimizations and to better understand the various solutions.  It turned out that pbrt has unexpected assumptions that interfere with the scene of this level of complexity.  All this is an excellent example of how important it is for a wide community of rendering researchers to have access to real production scenes with a high degree of complexity;  I say again many thanks to Disney for taking the time to process this scene and put it in open access. <br><br>  In the <a href="http://pharr.org/matt/blog/2018/07/15/moana-island-pbrt-4.html">next article</a> , we will look at aspects that can improve performance even more if we allow more radical changes to pbrt. <br><br><h2>  Note </h2><br><ol><li>  On a Linux system where I was testing, <code>strtof()</code> not faster than <code>strtod()</code> .  It is noteworthy that on OS X, <code>strtod()</code> about twice as fast, which is completely illogical.  For practical reasons, I continued to use <code>strtof()</code> . </li></ol></div><p>Source: <a href="https://habr.com/ru/post/417913/">https://habr.com/ru/post/417913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417901/index.html">How we began to do awesome long meetings, and why it is no longer universal evil</a></li>
<li><a href="../417903/index.html">Code Review case 1</a></li>
<li><a href="../417905/index.html">11 ways to (not) become a victim of hacking in Kubernetes</a></li>
<li><a href="../417909/index.html">Why do you need Splunk? Application Performance Analytics</a></li>
<li><a href="../417911/index.html">Continuous design in development: methodology and principle</a></li>
<li><a href="../417915/index.html">How to play a roommate</a></li>
<li><a href="../417917/index.html">ASC'18: Perseverance and regular training as a way to achieve a goal</a></li>
<li><a href="../417919/index.html">Simulation of vibrations and noise in the car's gearbox</a></li>
<li><a href="../417927/index.html">Cyber ‚Äã‚Äãbattles on PHDays, or How to hack urban infrastructure in 30 hours</a></li>
<li><a href="../417929/index.html">An excerpt from the book ‚ÄúOne Day in the Life of the Brain. Neurobiology of consciousness from dawn to dusk "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>