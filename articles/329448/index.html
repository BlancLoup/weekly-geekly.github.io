<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reverse engineering game Lost Vikings</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After an interesting reverse development of the game engine Comprehend (see Recomprehend ), I selected a new project for reverse engineering of the ga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reverse engineering game Lost Vikings</h1><div class="post__text post__text-html js-mediator-article">  After an interesting reverse development of the game engine Comprehend (see <a href="https://github.com/RyanMallon/recomprehend">Recomprehend</a> ), I selected a new project for reverse engineering of the game under DOS.  Over the years, different people have reversed many of the old popular games and published specifications and tools for them.  For example, the site <a href="http://www.shikadi.net/moddingwiki/Category:Game_Intro_Page">shikadi.net</a> has a lot of information about the games I played in my childhood. <br><br>  I found that Blizzard‚Äôs The Lost Vikings reverse engineering (then called Silicon and Synapse) did not seem to have made any serious attempts to reverse-engineer.  The game was released in 1993, at the sunset of the DOS era, and I really liked it in my youth.  The Lost Vikings is a platforming puzzle game in which the player controls three Vikings, each with their own skills.  Vikings need to combine their strengths to solve puzzles and complete levels with different themes: spacecraft, prehistoric world, Ancient Egypt.  The image below shows the first level of the game (source: <a href="http://strategywiki.org/wiki/The_Lost_Vikings/Level_1">Strategy Wiki</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec0/d37/d53/ec0d37d532989859939c13250f4a9901.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It seemed that this game will be quite easy to disassemble.  The levels are based on tile maps and contain simple puzzles: buttons that turn on and off objects, mobile boxes and a crane that lifts objects.  And in fact, most of the reverse development project was fairly straightforward.  The game has one batch data file containing compressed file blocks.  The blocks encode various game resources, such as sprites, maps, sounds, etc.  I have written several utilities that you can use to view game resources: <a href="https://github.com/RyanMallon/TheLostVikingsTools">The Lost Vikings Tools</a> . <br><a name="habracut"></a><br><h2>  Virtual machine </h2><br>  An interesting aspect of the engine is that the objects in the game use a template system of classes.  For each world, there is a block in the data file that defines a set of object classes.  For example, in the first level shown above, both emergency exit doors are of type class 0x4f.  Reverse engineering of the object class code led to the following function: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/cb5/14b/fb4cb514b7efbc1a7fdd60084f737f92.png" alt="image"><br><br>  While skipping the alternative path to the address 0x142a2, this code uses si as an index in the structure of the array of object classes (each class template consists of 0x15 bytes).  The word at offset 0x3 is the structure used as the address in the ES segment.  The ES segment contains all the data of an object class template block.  Then the code goes into a loop at address 0x142a6.  This cycle receives the next byte from the ES segment and uses it as an index of the function table.  At each step of the loop, bx contains the address in the ES segment, and si contains the current opcode (opcode). <br><br>  It is interesting to note that the unconditional transition is used in the loop, and therefore it never ends.  At least with normal program execution.  It seems that each object class has some kind of program associated with it based on opcodes, which is interpreted by this function.  Initially, I just explored some of the functions in the call table.  Here‚Äôs what the first one looks like in IDA graph mode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/603/6dc/773/6036dc7734a64723cd837a182d455ca5.png" alt="image"><br><br>  Analysis of the IDA stack here fails, and for good reason.  pop ax as the first command of a function is a rather strange behavior.  The x86 call command loads the command pointer (ip) onto the stack, and the ret command retrieves it to return to the caller.  The pop command here actually drops the return address.  This means that the next ret command will go back two frames of the stack instead of one.  This opcode performs an exit from an infinite interpreter loop. <br><br>  To understand how the opcode is actually implemented, we need to switch to linear IDA mode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fa/8ce/3b0/0fa8ce3b037f87c675ae05a5dd685767.png" alt="image"><br><br>  I commented on the function names with their respective opcode numbers so that this part of the code would be clearer.  Code reuse is quite clever here.  The easiest way to start is to study opcode 0x03.  Recall that in the processing opcodes cycle there is data of object class blocks loaded into the ES segment, and bx is used as a pointer to the virtual machine command.  Thus, opcode 0x03 is an unconditional branch instruction.  It loads the word at the address of the current command pointer, sets the command pointer to it, and then returns to the opcode processing cycle. <br><br>  Working in the reverse order, opcode 0x05 skips the next word operand and stores the next address in an array.  The reverse of other functions indicates that word_28522 is the index of the current instance of an object, that is, this opcode stores one address for each object at the level.  Then it restores the value of bx and passes in the code to the opcode 0x03 (transition).  Therefore, this opcode seems to be a very limited call command with only one stack level. <br><br>  Opcode 0x00 saves the current function pointer to the global array.  Note that it differs from opcode 0x05, which stores the address after the operand of the call address.  Then it goes to the opcode call handler.  However, the command will not be executed due to the first pop command.  Instead, the calling loop will exit.  The address stored by this command is used as an alternative path to the function call loop, which I did not consider above.  Here the opcode 0x00 is used as something like a coroutine exit.  It saves the current position in the program and exits the opcode processing cycle, allowing the game engine to perform other tasks: update the graphics, retrieve user input data, etc., returning to where the virtual machine program exited.  This allows the virtual machine program to perform complex tasks without idle the rest of the game engine. <br><br><h2>  Disassembling Opcodes </h2><br>  At this stage, I already had a general idea of ‚Äã‚Äãhow the opcode handler of the virtual machine works.  Having studied the table of function calls, I found about 215 implemented opcodes there, so instead of developing them directly in reverse, I started writing a simple script to decompile the program for the desired class of objects.  Thus, I could focus only on opcodes called by objects on the first level. <br><br>  At this point, I basically tried to determine how many operands opcodes have, and what their main tasks are.  If the opcode handler was short, I usually tried to completely figure out what it was doing.  If it was more than a few blocks of code, then I just tried to find out how many operands it has, and whether it performs a conditional transition or a call.  I did this because sometimes the purpose of an opcode becomes apparent from its surrounding context in a disassembled program, which is often easier to understand than doing code reversal. <br><br>  Here is an example of a simple opcode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db0/4a1/eb0/db04a1eb004309c4ab2e216ce71e4af9.png" alt="image"><br><br>  This opcode takes an operand-word and stores it in a global variable.  Reversing other functions indicates that this global variable is a temporary storage or general purpose register.  There is only one such register in a virtual machine, but it also has the following opcode: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/907/d14/4bb/907d144bbfeed471ab93887ac9c6cc45.png" alt="image"><br><br>  This opcode saves the current value of the general-purpose register to an address in the data segment (DS) specified by the operand-word.  Programs in the game data file use this opcode to write to certain parts of the game data, such as Viking inventory slots.  Several DS offsets are also used as additional time values ‚Äã‚Äãwhen they need more than one.  For example, offsets 0x0206 and 0x0208 are often used as temporal x and y coordinates of an object. <br><br>  This opcode and its opposite opcode 0x53, which reads from DS to the general register, are interesting in that they can read and write to DS any game data, and not just those that are designated by the creators of the original game.  This gives us interesting prospects for expanding the original game. <br><br>  More complex is the opcode 0x14: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/053/955/469/053955469145a3897c05bd0ab9eb470f.png" alt="image"><br><br>  At first glance, its reversal should not cause problems.  It receives a byte operand and calls a couple of subfunctions.  It then receives another byte operand and calls the same subfunctions again.  But if you look at the first subfunction (sub_15473), then the case becomes a bit more complicated: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b4/5d4/b54/6b45d4b54bf4fbeb11d78cc9a598c1b7.png" alt="image"><br><br>  The analysis of the IDA stack fails again, and it shows four exits from this block, which I cut off because all of them are incorrect.  What actually happens is that the first byte operand is passed to this function in ax, which is then used as the index of the jump table.  Although the AND operation is performed on ax for 7, in fact there are only four real values ‚Äã‚Äãin the transition table.  Looking at the type 0 in the transition table, we will see the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2af/e3a/179/2afe3a1797320d2622a490b2c3c33466.png" alt="image"><br><br>  This is where the immediate operand word is loaded.  This function fragment executes the retn, which is returned from the top-level opcode handler 0x14.  It is easy to see why the IDA has problems with the correct disassembly of this code. <br><br>  Other entries in the jump table load the values ‚Äã‚Äãin different ways, and then each of them retn again.  Type 1 takes a byte operand used as the index of the object field.  The object has fields for values ‚Äã‚Äãsuch as x and y offsets, flags, etc.  Type 2 receives the operand word and loads the value from DS (as opcode 0x53 from the example above).  Type 3 receives a byte operand and loads the target field to perform actions, such as collision detection. <br><br>  Let's go back to the top-level opcode handler 0x14.  Here the next is called sub_15470.  It is only three bytes ahead of the first sub-function called.  And in this there is again a smart code optimization.  This subfunction simply shifts ax to the right by 3, and then proceeds to the code that we just reversed above.  So, the first byte operand of the opcode 0x14 is used to encode how the next two arguments are obtained.  Reversing the processing of the second byte operand shows that it works in the same way. <br><br>  After receiving all its operands (of variable length), the opcode handler 0x14 calls sub_13809.  I will not insert the code here, because the function is quite large and causes many other subfunctions, each of which is also voluminous.  This is one of those cases where I did not bother reversing the actions of a function, because later they will become clear from the context. <br><br><h2>  CISC virtual machine </h2><br>  The commands in The Lost Vikings virtual machine are variable length.  In the case of the opcode 0x14 and other similar opcodes, determining the length requires decoding some operands.  The presence of variable length commands means that the program must be disassembled iteratively, at least determining the number of operands for each new opcode in the program.  If all opcodes had a fixed length, then it would be possible to skip unknown opcodes. <br><br>  There are also commands that perform standard operations used by many programs.  For example, many programs perform summation or subtraction from the current position of an object based on its direction.  This can be encoded as several commands, but opcode 0x91 receives a single operand word as an offset in DS, and then adds or subtracts from it the current value of the temporary register based on the current horizontal direction of the object (flag 0x0040).  The following pseudocode demonstrates how opcode 0x90 works. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.flags &amp; <span class="hljs-number"><span class="hljs-number">0x0040</span></span>) DS[operand] -= var; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> DS[operand] += var;</code> </pre> <br>  Due to this, much less bytes are required for encoding, especially since this operation is performed by several programs.  In the days of DOS, when disk space and computing power were in short supply, this made a lot of sense.  For a modern reverse developer, this simply adds a few new opcodes that need to be sorted out. <br><br><h2>  Disassembler </h2><br>  I wrote a simple Python script that can disassemble virtual machine programs into something that vaguely resembles C. It decodes program instructions linearly, keeping the addresses of jumps and calls.  When he stumbles upon a function that stops or redirects the execution of a code, for example, a return or an unconditional branch, he stops and checks other unvisited addresses in the program. <br><br>  In the programs of the virtual machine, they used optimization tricks similar to those used in the binary code of the game.  For example, some exit paths from subprocedures are reused in virtual machine programs by switching to them from other subprocedures.  The disassembler copes with this by decoding the commands twice, so two sub procedures can have code with the same addresses. <br><br>  The disassembler can trim access to the temporary register to make the final code more readable.  For example, in the virtual machine programs the following sequences are often used: <br><br><pre> <code class="cpp hljs">var = <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; obj-&gt;field_10 = var;</code> </pre> <br>  The disassembler reorganizes them as follows: <br><br><pre> <code class="cpp hljs">obj-&gt;field_10 = <span class="hljs-number"><span class="hljs-number">0x1000</span></span>;</code> </pre> <br>  The disassembler does not attempt to rebuild the blocks of code in such constructions as if or while, so the resulting programs look like spaghetti code.  Some large programs themselves can be made full-fledged projects for reverse engineering. <br><br><h2>  Full program </h2><br>  I started with a program for a turret with a cannon in the upper left room of the first level (object class 0x04).  It seemed to me that it should be a fairly simple program.  A turret with a gun shoots shells at a certain interval, and the Vikings cannot destroy it.  The following shows the program obtained after processing my disassembler.  There is a comment above each opcode that shows the address in square brackets, an opcode in quotation marks, followed by operands. <br><br>  The tower program looks like this: <br><br><pre> <code class="cpp hljs">main_374d: { <span class="hljs-comment"><span class="hljs-comment">// [374d] (19) 37bc this.field_21 = 0x37bc; this.field_22 = 0x0001; // [3750] (97) 00 01 if (0x0001 &amp; (1 &lt;&lt; 0)) var = 0x0001; // [3753] (00) this.save_state(); // [3754] (9c) 18 08 if (!(var)) this.db_flags &amp;= ~(1 &lt;&lt; 12); label_3757: // [3757] (2f) vm_func_2f(); // [3758] (00) this.save_state(); // [3759] (01) nop(); // [375a] (51) 0000 // [375d] (8c) 30 3798 if (this.field_30 != 0x0000) call sub_3798; // [3761] (52) 1c // [3763] (77) 0000 3757 if (this.update_time != 0x0000) jump label_3757; // [3768] (19) 37c8 this.field_21 = 0x37c8; this.field_22 = 0x0001; // [376b] (52) 1e // [376d] (57) 0206 g_tmp_a = this.xoff; // [3770] (51) 0004 // [3773] (91) 0206 if (this.flags &amp; 0x0040) g_tmp_a -= 0x0004; else g_tmp_a += 0x0004; // [3776] (52) 20 // [3778] (57) 0208 g_tmp_b = this.yoff; // [377b] (51) fff8 // [377e] (5a) 0208 g_tmp_b += 0xfff8; // [3781] (51) 001e // [3784] (56) 1c this.update_time = 0x001e; // [3786] (02) 3030 vm_func_02(0x3030); // [3789] (14) 12 0206 0208 00 0000 0000 05 new.x = g_tmp_a; new.y = g_tmp_b; new.unknown_a = 0x0000; new.unknown_b = 0x0000; new.unknown_c &amp;= 0x801; new.type = 0x05; spawn_obj(new); // [3795] (03) 3757 jump label_3757; } sub_3798: { // [3798] (51) 000a // [379b] (73) 30 37a5 if (this.field_30 == 0x000a) jump label_37a5; // [379f] (51) 0000 // [37a2] (56) 30 this.field_30 = 0x0000; // [37a4] (06) return; label_37a5: // [37a5] (52) 32 // [37a7] (69) 0a 37ba if (this.argument &lt; this.field_32) jump label_37ba; // [37ab] (52) 32 // [37ad] (5c) 0a this.argument -= this.field_32; // [37af] (51) 0000 // [37b2] (56) 30 this.field_30 = 0x0000; // [37b4] (51) 0000 // [37b7] (56) 32 this.field_32 = 0x0000; // [37b9] (06) return; label_37ba: // [37ba] (0e) vm_func_0e(); // [37bb] (10) this.update(); }</span></span></code> </pre> <br>  Here you can see the following: <br><br><ul><li>  The function this.save_state () is the opcode 0x00.  It is used as a result, allowing the program to save the place in which it was located and return to the game engine code. </li><li>  My disassembler assigns names to some fields of an object.  In this program, you can see the names xoff, yoff, flags, and update_time. </li><li>  Names are also given to known DS offsets.  g_tmp_a and g_tmp_b are offsets DS 0x0206 and 0x0208. </li><li>  It uses opcode 0x14.  I gave him the name spawn_obj (), because from the context of its application it is clear that it is used to create a new bullet object with each shot of the tower. </li><li>  Opcode 0x19 assigns values ‚Äã‚Äãto the fields 0x21 and 0x22 of the object.  It is noteworthy that the field 0x21 is assigned a value resembling the address of the program.  Reading the code and experimenting, I found out that this address is actually an offset for commands in a small secondary virtual machine that controls the display of graphics objects.  Until I reversed this code. </li></ul><br>  Refactoring a program helps to understand what is happening in it: <br><br><pre> <code class="cpp hljs">main_374d: { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set_graphics_prog(<span class="hljs-number"><span class="hljs-number">0x37bc</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0x0001</span></span> &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) var = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.save_state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(var)) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.db_flags &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">12</span></span>); label_3757: <span class="hljs-comment"><span class="hljs-comment">/* *   .     *     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { vm_func_2f(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.save_state(); <span class="hljs-comment"><span class="hljs-comment">/* *    .  this.argument *       * . ,     *    . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_30 != <span class="hljs-number"><span class="hljs-number">0x0000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_30 != <span class="hljs-number"><span class="hljs-number">0x000a</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_30 = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.argument &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32) { vm_func_0e(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.argument -= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_30 = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32 = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">/*    update_time  ,    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update_time == <span class="hljs-number"><span class="hljs-number">0x0000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.set_graphics_prog(<span class="hljs-number"><span class="hljs-number">0x37c8</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.update_time = <span class="hljs-number"><span class="hljs-number">0x001e</span></span>; vm_func_02(<span class="hljs-number"><span class="hljs-number">0x3030</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* *          *        . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.flags &amp; OBJ_FLAG_FLIP_HORIZONTAL) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>.x -= <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>.x += <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;y = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yoff - <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;unknown_a = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;unknown_b = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;unknown_c &amp;= <span class="hljs-number"><span class="hljs-number">0x801</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;type_d = <span class="hljs-number"><span class="hljs-number">0x05</span></span>; spawn_obj(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); } } }</code> </pre> <br>  It is worth noting that the program still has parts and opcodes, the purpose of which I did not define, but the behavior of the tower is quite understandable.  The object's update_time field is used to encode the shooting speed of the turret.  The program itself does not reduce this value (at least in the obvious way).  Perhaps this task is performed by one of the unknown opcodes or some part of the main game engine. <br><br><h2>  Hacking game </h2><br>  Of course, the opportunity to study the source programs used by the game is interesting in itself.  But the most interesting thing about the way a virtual machine implements an object‚Äôs behavior is that we can change it or create new programs.  It would be much simpler if you write a compiler (I will tell about it below), but for now we can only change the values ‚Äã‚Äãin the hex editor manually. <br><br>  I repeat - I chose to modify the program of the tower with a gun, because it is quite simple.  At first I decided to change the type of object that the tower shoots.  Success was variable.  Attempts to implement the shooting of some objects, for example, a green alien, led to the "throwing out" or hang the game.  The choice of other objects led to the fact that the tower did not shoot at all.  I managed to get her to shoot fire arrows (in a normal game this is a bonus that one of the Vikings can use).  It is also quite simple to increase the rate of fire of a cannon by decreasing the value of the update_time field. <br><br>  The second modification I made became a bit more ambitious: I made the tower move instead of shooting.  Opcode (0x14) to create a bullet is quite long: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">0206</span></span> <span class="hljs-number"><span class="hljs-number">0208</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span></code> </pre> <br>  The virtual machine provides the ability to use the single-byte nop (0x01) command (which is quite noble on its part), which can be used to replace this command.  The commands above have already set DS [0x0206] to the current position along the x axis of the tower, plus or minus 4, depending on its direction.  So I just need to add commands to assign this value to the current position x.  This requires only two commands: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">0206</span></span> <span class="hljs-comment"><span class="hljs-comment">// var = DS[0x0206]; 56 1e // this.x = var;</span></span></code> </pre> <br>  Thanks to this change, the tower can move, but nothing stops it.  I tried to implement collision detection and rotation back, but I could not achieve proper operation.  Deeper reverse engineering is required. <br><br>  I collected a small video of my modifications: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/gyf-d_OgbLc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  I also laid out my disassembler in open access: <br><br>  <a href="https://github.com/RyanMallon/TheLostVikingsTools/blob/master/dissassembler/lv_vm_disasm.py" rel="nofollow">https://github.com/RyanMallon/TheLostVikingsTools/blob/master/dissassembler/lv_vm_disasm.py</a> <br><br><h1>  Recompilation of the game </h1><br>  In the previous section, we talked about the reverse engineering of the virtual machine used to implement objects in Lost Vikings. <br><br>  I used to test some of the opcode empirically, by manually patching the original data blocks in a hex editor.  This approach worked, but was very monotonous and did not scale well for experiments with large programs or with programs containing loops and transitions.  Above, I suggested that creating a simple language and a compiler would be useful for further developing the virtual machine.  Therefore, I wrote it. <br><br><h2>  Building a compiler </h2><br>  To help reverse engineer a virtual machine and ease the creation of new programs, I decided to write a compiler.  In order not to complicate things, I chose the single-pass method of recursive descent. <br><br>  The design of the compiler is mainly borrowed from compilers such as PL / 0, which are often studied at university courses on compilers (see <a href="https://en.wikipedia.org/wiki/PL/0">PL / 0</a> ).  I will not go into the details of writing the basic compiler, because the Internet has enough information about it.  In essence, the compiler gets the source program, performs lexical analysis to create a stream of tokens, and then parses the program, generating code. <br><br><h3>  Lost vikings c </h3><br>  I created a very simple C-like language for implementing object programs on it.  One advantage of using a C-like language is that you can use an existing C preprocessor to support the definition of constants and macros.  The language does not allow to define variables, the programmer is limited to the fields of objects and global variables defined by the virtual machine.  Built-in functions provide support for generating opcodes for the operations of obtaining results and creating objects.  The language is slightly different from C, just to preserve the simplicity of the lexical and parser. <br><br>  Again, take for example the object of the turret with a cannon from the first level, which we modified above.  You can implement an arrow-firing tower on Lost Vikings C as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vikings.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> timer field_30 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DELAY_TIME 40 function main { call set_gfx_prog(0x37bc); this.timer = 0; while (this.timer != 0xffff) { call update_obj(); call yield(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (this.timer != 0) { this.timer = this.timer - 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  . if (this.flags &amp; OBJ_FLAG_FLIP_HORIZ) { g_tmp_a = this.x - 12; } else { g_tmp_a = this.x + 12; } g_tmp_b = this.y - 12; //    call set_gfx_prog(0x37c8); //   call spawn_obj(g_tmp_a, g_tmp_b, 0, 0, 7); //     this.timer = DELAY_TIME; } } }</span></span></span></span></code> </pre> <br>  Each object needs a main loop, which should never be terminated.  The main loop must call the yield () function to allow the output to execute the virtual machine's processing loop.  Otherwise, the game engine will freeze.  Calling update_obj () does what its name implies. <br><br>  The use of many fields of objects refers to a specific object.  In our case, I used the field_30 field as a timer to control the speed of the tower.  When the timer reaches zero, the tower shoots and then resets the timer. <br><br>  The only thing left is to generate code for this program. <br><br><h3>  Code generation </h3><br>  The Lost Vikings virtual machine is not an ideal environment for a simple compiler.  PL / 0 compilers usually generate code for an abstract stack machine, so a simple type expression is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  will generate the following code: <br><br><pre> <code class="cpp hljs">push <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y ;  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y   push <span class="hljs-number"><span class="hljs-number">1</span></span> ;  <span class="hljs-number"><span class="hljs-number">1</span></span>   add ;    ,     pop <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x ;    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x</code> </pre> <br>  However, The Lost Vikings virtual machine does not have a stack.  It has a simple temporary register, object fields, and global variables.  The program shown above is translated into a Lost Vikings virtual machine as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> ; var = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y <span class="hljs-number"><span class="hljs-number">56</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>e ; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = var <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">0001</span></span> ; var = <span class="hljs-number"><span class="hljs-number">0x0001</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>e ; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y += var</code> </pre> <br>  It is much harder for it to generate code when compiling from a general purpose language.  You may need to generate an intermediate representation in the first pass, and then in the second pass, change the order of commands, etc.  to generate the final code. <br><br><h3>  Abstract machine </h3><br>  I came up with the following solution: creating an abstract stack machine for which you can comfortably compile over the Lost Vikings virtual machine.  This is possible thanks to opcodes for loading and storing global variables.  These opcodes receive as their operands offset in the data segment (DS) of the game.  This allows opcodes to be used to load and store any arbitrary address in DS. <br><br>  The compiler generates code by placing a fake stack on top of the (0xf004) data segment.  The two addresses at the bottom of the fake stack are reserved for the special register: 0xf000 is the zero register, and 0xf002 is the flag register used for comparison.  The above expression can now be compiled like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">52</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> ; var = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x <span class="hljs-number"><span class="hljs-number">57</span></span> f004 ; ds[f004] = var <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">0001</span></span> ; var = <span class="hljs-number"><span class="hljs-number">0x0001</span></span> <span class="hljs-number"><span class="hljs-number">57</span></span> f006 ; ds[f006] = var <span class="hljs-number"><span class="hljs-number">53</span></span> f006 ; var = ds[f006] <span class="hljs-number"><span class="hljs-number">5</span></span>a f004 ; ds[f004] += var <span class="hljs-number"><span class="hljs-number">53</span></span> f004 ; var = ds[f004] <span class="hljs-number"><span class="hljs-number">56</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>e ; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = var</code> </pre> <br>  Despite not very high performance, this code is very easy to generate.  My goal is to create a compiler for testing small programs to determine what opcodes or their combinations do.  So far I am not very concerned about efficiency, in terms of both time and code size. <br><br>  The second problem in creating a language for the original virtual machine is that many opcodes perform conditional function calls.  For example, opcode 0x1a checks if the current object collides with a Viking, and if so, it executes a call command.  It is desirable that the programmer can decide for himself whether to use a call or a transition (for example, a construction with if). <br><br>  I implemented this by generating code for a standard helper function that sets a flag and performs a return.  When generating a code for an opcode that performs a conditional call, the flag register is first reset.  If the opcode makes a call, the flag register is set.  You can then check the flag to make the transition call.  For example, the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (call collided_with_viking(<span class="hljs-number"><span class="hljs-number">0x01</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  generates the following code: <br><br><pre> <code class="cpp hljs">[c009] <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> ; var = <span class="hljs-number"><span class="hljs-number">0x0000</span></span> [c00c] <span class="hljs-number"><span class="hljs-number">57</span></span> f002 ; ds[f002] = var,    [c00f] <span class="hljs-number"><span class="hljs-number">1</span></span>a <span class="hljs-number"><span class="hljs-number">01</span></span> c0a5 ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collided_with_viking(<span class="hljs-number"><span class="hljs-number">0x01</span></span>)) call c0a5 [c013] <span class="hljs-number"><span class="hljs-number">53</span></span> f002 ; var = ds[f002] [c016] <span class="hljs-number"><span class="hljs-number">74</span></span> f000 c026 ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (var == ds[f000]) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> c026 [c01b] <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">0001</span></span> ; var = <span class="hljs-number"><span class="hljs-number">0x0001</span></span> [c01e] <span class="hljs-number"><span class="hljs-number">57</span></span> f004 ; ds[f004] = var [c021] <span class="hljs-number"><span class="hljs-number">53</span></span> f004 ; var = ds[f004] [c024] <span class="hljs-number"><span class="hljs-number">56</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>e ; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_x = var [c026] ... ;     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ;     [c0a5] <span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-number"><span class="hljs-number">0001</span></span> ; var = <span class="hljs-number"><span class="hljs-number">0x0001</span></span> [c0a8] <span class="hljs-number"><span class="hljs-number">57</span></span> f002 ; ds[f002] = var,    [c0ab] <span class="hljs-number"><span class="hljs-number">06</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Zero register is used here to compare it with the flag value.  At the beginning of each program, the compiler generates commands to reset the zero register. <br><br><h3>  Software patching </h3><br>  Virtual machine programs for each game world are packed in a separate block in the data file.  The compiler uses a simple approach: it adds the generated code to the end of the block, and then modifies the program title of the object so that it points to a patch in the program. <br><br>  All this works in theory, but in fact there is one small problem.  The game stores the virtual machine programs in an additional segment (ES) in the space specified by the DOS memory allocation API.  The memory allocation function looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02f/98c/8b8/02f98c8b87321a2d163d62133b6c12df.png" alt="image"><br><br>  The memory allocation call for the virtual machine looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e5/a6d/6aa/5e5a6d6aa1919331303b8edee36b6e7a.png" alt="image"><br><br>  That is, 0xc000 bytes (48 KB) are allocated for programs.  The problem is that the block for the programs of the world of the spacecraft already occupies 48972 bytes, that is, at the end of it only 180 bytes remain for the patch in the new program.  Not so much when working with a compiler that generates very redundant code. <br><br>  I discovered this problem when I tried to compile a large program.  The game began to behave erratically, it either hung, or the cannon tower disappeared randomly.  Such errors are quite difficult to track down, because this may be a bug in my compiler or generated code, a problem of misunderstanding of the principle of operation of some opcode, or a bug / restriction of the original game. <br><br>  A quick solution is to patch the binary code of the game to expand the size of the memory allocated for the program.  Increasing the allocated size to 0xd000 bytes (52 KB) does not cause problems and gives enough space for experiments with simple programs.  I added commands for this to my compiler. <br><br><h2>  Empirical reversal </h2><br>  The purpose of the compiler was to simplify the reverse development of a virtual machine.  To test a new opcode, you need to add an entry to the function dictionary in the code generator class and create a command generation function for the opcode.  For example, one of the first experiments was to work with 0x41, which is used in several disassembled programs, such as objects of buttons / icons with a question mark. <br><br>  His dictionary entry in the compiler initially looked like this: <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"vm_func_41"</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, emit_builtin_vm_func_41),</code> </pre> <br>  A tuple indicates whether a function will return a value, the number of arguments passed to it, and a code generator function.  Functions are marked as returning values ‚Äã‚Äãif the opcode performs a conditional call or transition. <br><br>  After studying the opcode in IDA, I knew that opcode 0x41 is executed unconditionally and takes four arguments.  His arguments use variable type encoding, which I described at the beginning of the article.  It generates the following function: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emit_builtin_vm_func_41</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, reg_list)</span></span></span><span class="hljs-function">:</span></span> operands = self.pack_args(reg_list, <span class="hljs-number"><span class="hljs-number">4</span></span>) self.emit(<span class="hljs-number"><span class="hljs-number">0x41</span></span>, *operands)</code> </pre> <br>  The pack_args helper function provides a package for the variable type arguments. <br><br>  Now you can call it in a short test program.  For testing, I use the collided_with_viking function (opcode 0x1a), so the opcode being tested runs only when the viking touches the tower.  Note that the function collided_with_viking receives a single byte operand, the purpose of which I do not know, but the value 0x01 is quite suitable for it.  I also use as a one-time trigger the field field_32 of the object, so that the opcode I test works only at the first touch of a viking object. <br><br>  My test program looks like this: <br><br><pre> <code class="cpp hljs">function main { <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_gfx_prog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x37bc</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32 != <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) { <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_obj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (call collided_with_viking(<span class="hljs-number"><span class="hljs-number">0x01</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-function"><span class="hljs-function">call </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_func_41</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field_32 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, this graphic ‚Äúglitch‚Äù </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/eba/07e/1dfeba07e89df0a6fe381c6b9e1e1227.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appears </font><font style="vertical-align: inherit;">in the game: </font><font style="vertical-align: inherit;">It seems that the opcode is used to display the dialog box, but it is not clear why this graphic error occurs. If you look at some disassembled programs from the original game, you can see that opcode 0x41 is usually followed by unknown opcodes 0xcb and 0x42, none of which receive my arguments. When adding firmware to these opcodes in the compiler and restarting the game, a dialog box is displayed waiting for the button to be pressed, and then the window closes. So, opcode 0x41 shows a dialog box, opcode 0xcb waits for a button, and opcode 0x42 deletes the window.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further experiments with opcode 0x41 show that its first argument is the index of the dialog line. Strings are stored in a binary game file, which is inconvenient for modding. The second argument is still unknown, and the third and fourth control the x and y offset relative to the object next to which the dialog box opens. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good example of why this experimental reversal is useful can be the opcode 0xcb, discussed in IDA:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/204/260/5c4/2042605c4344f005086534ce1e0e6a03.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although this function is small in size, and its purpose is clear (it changes global variables), it is not at all obvious what effect it has on the game engine. </font><font style="vertical-align: inherit;">Studying cross-references for each of the global variables in IDA does not help much either. </font><font style="vertical-align: inherit;">Each of these global variables is used in many places, and for none of them the purpose becomes immediately apparent. </font><font style="vertical-align: inherit;">I could spend a lot of time in IDA, trying to figure out that changing these global variables tells the game engine to wait for a button press in the next game cycle. </font><font style="vertical-align: inherit;">Empirical testing made it clear very quickly. </font><font style="vertical-align: inherit;">The disadvantage is that I still do not know the exact purpose of each global variable in the function.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interesting fields </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the interesting features that I found when experimenting with the compiler is how objects can refer to each other. </font><font style="vertical-align: inherit;">From the initial analysis, I already knew that there was support for references in the code, but the compiler helped me quickly understand the details.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The 0x3c field of each object identifies the current target object. </font><font style="vertical-align: inherit;">Some opcodes, for example collided_with_viking (0x1a), automatically assign a value to this field, but you can also specify it manually. </font><font style="vertical-align: inherit;">Vikings are always objects 0 (Baleog), 1 (Eric) and 2 (Olaf). </font><font style="vertical-align: inherit;">After assignment of the target object, it can be managed through the target fields. </font><font style="vertical-align: inherit;">Each opcode has its own options for changing the field of the current object (target field). </font><font style="vertical-align: inherit;">For example, opcode 0x59 adds a temporary register to the field in the current object, and opcode 0x5b adds a temporary register to the field in the target object.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other objects can control the fields in the Viking objects to control their behavior. For example, a 0x32 field for Vikings is the amount of expected damage. An object can inflict damage on a viking by adding value to this field. The Vikings themselves are partially implemented by programs in a virtual machine. The next time you start a viking program, it checks the expected damage field and deals the corresponding damage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of interest are also 0x12 and 0x14, which are the speeds for all objects in x and y. Before writing the compiler, I thought that the objects are moved either by adding / subtracting x and y offsets from their fields (0x1e and 0x20) or, possibly, using an opcode similar to the function. However, the game uses a couple of speed fields. Some objects, such as Vikings, automatically change their speed. Therefore, for example, if an object assigns a speed to the Vikings that raises them up, then in subsequent cycles of the game, the Viking accordingly changes its own speed in order to fall down again.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems that in the Viking objects there were not enough fields for storing everything, so each of the four Viking inventory slots is a global variable. </font><font style="vertical-align: inherit;">An object can check whether the corresponding global variable is equal to zero, and give the viking object by directly assigning the value to the global slot variable of the inventory.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advanced hacking game </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To experiment with a virtual machine and demonstrate its flexibility, I wrote a slightly more complicated program for a tower with a gun on the first level. </font><font style="vertical-align: inherit;">The tower checks which of the Vikings has touched it, and reacts differently. </font><font style="vertical-align: inherit;">If Eric touches the tower, she gives him items. </font><font style="vertical-align: inherit;">If Olaf touches, he pushes off into the air. </font><font style="vertical-align: inherit;">When it comes to Baleog, the tower changes direction. </font><font style="vertical-align: inherit;">Here‚Äôs what it looks like in action:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QMk76rKpFqQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This level of flexibility in the game, created in the early 90s, is quite impressive. </font><font style="vertical-align: inherit;">I added the source code of this program to the compiler's folder.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Work for the future </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are still quite a few opcodes, fields and global variables, the purpose of which I do not understand. </font><font style="vertical-align: inherit;">The compiler lacks some functions, for example, while it supports only comparison operators == and! =, And it lacks most bitwise operators. </font><font style="vertical-align: inherit;">It is a bit cumbersome to work, because it requires a separate unpacking of the original program block from the game data file, patching and repacking the data file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All tools are public domain (public domain), their open source code is posted on github: </font></font><a href="https://github.com/RyanMallon/TheLostVikingsTools" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/RyanMallon/TheLostVikingsTools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old School Blizzard: Sprites, Maps and Palettes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I was engaged in reverse engineering of two early Blizzard games under DOS, The Lost Vikings and Blackthorne. </font><font style="vertical-align: inherit;">Above, I wrote about the virtual machine used by The Lost Vikings to implement game objects. </font><font style="vertical-align: inherit;">Blizzard has posted The Lost Vikings and Blackthorne freely available on </font></font><a href="http://eu.blizzard.com/en-gb/games/legacy/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battle.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is worth noting that Blizzard created its early games, including The Lost Vikings, under the name of Silicon and Synapse. </font><font style="vertical-align: inherit;">Blackthorne is the first game released under the brand Blizzard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, I will talk about how in two games the sprite formats and the tile engine are implemented. </font><font style="vertical-align: inherit;">These two games have very similar engines, and some improvements have been made to Blackthorne after The Lost Vikings. </font><font style="vertical-align: inherit;">In the future, I will call the game engine of both games "Blizzard engine."</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Games store all their data in a single batch data file called DATA.DAT. </font><font style="vertical-align: inherit;">A batch file is an archive that contains blocks of sprites, levels, sounds, etc. </font><font style="vertical-align: inherit;">Most batch file blocks are compressed by a kind of </font></font><a href="https://en.wikipedia.org/wiki/Lempel%25E2%2580%2593Ziv%25E2%2580%2593Storer%25E2%2580%2593Szymanski"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LZSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compression </font><a href="https://en.wikipedia.org/wiki/Lempel%25E2%2580%2593Ziv%25E2%2580%2593Storer%25E2%2580%2593Szymanski"><font style="vertical-align: inherit;">algorithm</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I created some simple utilities that you can use to view sprites, levels, etc. </font><font style="vertical-align: inherit;">from The Lost Vikings and Blackthorne. </font><font style="vertical-align: inherit;">These utilities can be downloaded from GitHub (link above). </font><font style="vertical-align: inherit;">In this section, I added code samples. </font><font style="vertical-align: inherit;">All screenshots in the section are made using these utilities.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f3/d4c/4c3/0f3d4c4c3162f7a67b739eeb0271dc98.png" alt="image"><br><br><pre> <code class="cpp hljs">./sprite_view DATA.DAT -fraw -s -u -w344 -p <span class="hljs-number"><span class="hljs-number">0x17b</span></span> <span class="hljs-number"><span class="hljs-number">0x17c</span></span> ./level_view --blackthorne DATA.DAT <span class="hljs-number"><span class="hljs-number">1</span></span> -h0x6e</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Graphic mode </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both games use the popular VGA Mode X mode. Mode X is a 256-color planar graphics mode with a resolution of 320 √ó 240. </font><font style="vertical-align: inherit;">"Planar" means that instead of a linear arrangement of pixels, as in VGA Mode 13h with a resolution of 320 √ó 200, they are divided into a set of planes. </font><font style="vertical-align: inherit;">Planar graphics were originally designed to speed up graphics processing. </font><font style="vertical-align: inherit;">It allows several memory chips to store separate planes and transfer them in parallel. </font><font style="vertical-align: inherit;">This </font></font><a href="http://www.shikadi.net/moddingwiki/Raw_EGA_data"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article on Shikadi.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has a good explanation of the work of plane graphics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode X uses four planes. </font><font style="vertical-align: inherit;">The first plane stores the pixels 0, 4, 8, etc. </font><font style="vertical-align: inherit;">The second plane stores pixels 1, 5, 9, etc. </font><font style="vertical-align: inherit;">Therefore, an 8 √ó 2 sprite is not linearly stored as pixels:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plane Mode Mode X stores them like this: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basically, I did the reverse engineering of sprite formats, studying the data in blocks of a batch file, not the rendering code in IDA. </font><font style="vertical-align: inherit;">I have a very rudimentary understanding of programming under DOS and VGA, and the rendering code for old games usually contains a lot of tricks for optimizing and cleverly using assembler that are hard to understand (for me).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Raw Sprites Format </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first format of sprites used in games is simply raw coded planar data. </font><font style="vertical-align: inherit;">"Raw" sprites can have any width and height, divisible by four. </font><font style="vertical-align: inherit;">Drawing raw sprites is simple:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (plane = <span class="hljs-number"><span class="hljs-number">0</span></span>; plane &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; plane++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (sprite_width * sprite_height) / <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { offset = (i * <span class="hljs-number"><span class="hljs-number">4</span></span>) + plane; y = offset / sprite_width; x = offset % sprite_width; pixel = *sprite++; dst[((dst_y + y) * dst_width) + (dst_x + x)] = pixel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additionally, you can select the index of the color used as transparent. </font><font style="vertical-align: inherit;">Raw sprites of the same width and height always have the same amount of data, but they do not use space very efficiently. </font><font style="vertical-align: inherit;">This is especially true for the Blizzard game engine, because sprites use only sixteen colors (these are always values ‚Äã‚Äãfrom 0x0 to 0xf), so four bytes per pixel are wasted. </font><font style="vertical-align: inherit;">Sixteen colors per sprite are used because it allows you to apply clever tricks with a palette, which I will explain below.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unpacked sprites / sprites with mask </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second format of sprites allows you to use transparency without sacrificing the color index, but the price is a more complex rendering algorithm and a slightly larger data size. </font><font style="vertical-align: inherit;">In the utilities I developed, I called this format ‚Äúunpacked‚Äù, but perhaps it would be better to call it ‚Äúwith a mask‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this sprite format, each set of eight pixels is preceded by a mask byte indicating which pixels to draw. </font><font style="vertical-align: inherit;">Transparent pixels are still encoded with a value of 0x0, but are skipped when drawing. </font><font style="vertical-align: inherit;">This allows you to use the color index 0x0 as an additional color. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm for rendering such sprites is as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (plane = <span class="hljs-number"><span class="hljs-number">0</span></span>; plane &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; plane++) { x = plane; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (sprite_width * sprite_height) / <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { mask = *sprite++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bit = <span class="hljs-number"><span class="hljs-number">7</span></span>; bit &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; bit--) { pixel = *sprite++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit)) dst[((dst_y + y) * dst_width) + (dst_x + x)] = pixel; x += <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= sprite_width) { y++; x = plane; } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Various The Lost Vikings collected items are 16 √ó 16 unpacked sprites / sprites. </font><font style="vertical-align: inherit;">They can be viewed using:</font></font><br><br><pre> <code class="cpp hljs">./sprite_view DATA.DAT -l2 -funpacked -w16 -h16 <span class="hljs-number"><span class="hljs-number">0x12f</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/996/d8c/8ee/996d8c8eea3abfbac54ba932345f3609.png" alt="image"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Packed Sprites 32 √ó 32 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The latest sprite format is used only in The Lost Vikings and is optimized for rendering 32 √ó 32 sprites. As in the unpacked format, each set of pixels is preceded by a mask byte, defining the pixels to be drawn. However, the packaged format does not store transparent pixels and packs two pixels into each byte, because only sixteen colors are used. If the number of pixels drawn is odd, then the last nibble is zero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This format uses space more efficiently than the previous two, but it has a more complex rendering algorithm and variable length of sprites. Batch file blocks containing packed-format sprites begin with a header of 16-bit values ‚Äã‚Äãdefining the offset of each sprite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm for rendering packed sprites is as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (plane = <span class="hljs-number"><span class="hljs-number">0</span></span>; plane &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; plane++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>; y++) { num_pixels = <span class="hljs-number"><span class="hljs-number">0</span></span>; mask = *sprite++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (bit = <span class="hljs-number"><span class="hljs-number">7</span></span>; bit &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; bit--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit)) { pixel = *sprite; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num_pixels &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) sprite++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pixel &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; pixel &amp;= <span class="hljs-number"><span class="hljs-number">0xf</span></span>; x = ((<span class="hljs-number"><span class="hljs-number">7</span></span> - bit) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + plane; dst[((dst_y + y) * dst_width) + (dst_x + x)] = pixel; num_pixels++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num_pixels &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) sprite++; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the process of writing a post, I found the following sprite in the second-level title of The Lost Vikings. </font><font style="vertical-align: inherit;">It uses a packaged 32 √ó 32 format, but I don‚Äôt remember seeing it in the game. </font><font style="vertical-align: inherit;">Maybe someone knows, maybe this is a secret or unused resource? </font><font style="vertical-align: inherit;">It can be viewed as follows:</font></font><br><br><pre> <code class="cpp hljs">./sprite_view DATA.DAT -l2 -fpacked32 <span class="hljs-number"><span class="hljs-number">0xec</span></span> -b0x10</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/98b/1e1/78d/98b1e178dc878d4cf4bacf9aa6467a91.png" alt="image"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why use multiple sprite formats? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have no exact answer to this question. I am by no means a specialist in the intricacies of programming for optimizing VGA. Perhaps different formats are used to increase the rendering speed of sprites, which should have a different refresh rate. Tiles for cards always have a "raw" format. The raw format is also used for some interface sprites. Sprites in the packaged format 32 √ó 32 are the Vikings and many enemies. The unpacked format is used for some poorly animated enemies like a cannon tower and other objects, such as switches and elevators.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It appears that Blackthorne does not use the packaged 32 √ó 32 format at all. </font><font style="vertical-align: inherit;">Perhaps because many Blackthorne sprites are larger than 32 √ó 32. </font><font style="vertical-align: inherit;">Most sprites with detailed animations use a ‚Äúraw‚Äù format. </font><font style="vertical-align: inherit;">Blackthorne has no levels with scrolling (as in the original Prince of Persia), which speeds up rendering. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did not understand yet another question: how does the Blizzard engine understand what format and size of sprites is used to draw each object? </font><font style="vertical-align: inherit;">In the headings of the levels there is a partial relevant information, but it is not enough to correctly draw all the objects. </font><font style="vertical-align: inherit;">I suspect that these parts of the rendering information are controlled by the virtual machine.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprite layout </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I mentioned above, Blackthorne uses larger sprites than The Lost Vikings. Although you can write an algorithm for rendering raw sprites of arbitrary size, a different approach is used in the Blizzard engine. Large sprites are rendered by combining several small sprites in a consistent pattern. For example, the main character of Blackthorne uses 32 √ó 48 sprites consisting of two 16 √ó 16 sprites for the head and one sprite 32 √ó 32 for the body: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/889/32e/d7e88932e1f722d490b8525bd62ca3d1.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that the background color used here is actually the color with the index 0 for Blackthorne sprites, which is considered to be transparent in the game. The whole set of Blackthorne character sprites can be viewed as:</font></font><br><br><pre> <code class="cpp hljs">./sprite_view --blackthorne DATA.DAT -fraw -w32 -h48 -l2 -b0x80 <span class="hljs-number"><span class="hljs-number">0x42</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhaps this approach was chosen because the Blizzard developers have already written optimized rendering cycles for 16 √ó 16 and 32 √ó 32 sprites, and it was faster to render large sprites as a set of small ones, and not as one large one. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Levels from tile cards </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both in The Lost Vikings and Blackthorne, the levels are created from tile cards with 16 √ó 16 tiles (although it seems to me that in both games the authors did their best to ensure that such a feeling did not occur). </font><font style="vertical-align: inherit;">Sprites used for tiles are actually 8 √ó 8 in size. </font><font style="vertical-align: inherit;">Each tile contains a structure, which I call a ‚Äústub‚Äù. </font><font style="vertical-align: inherit;">It defines how to create a set of 8 √ó 8 sprites from a 16 √ó 16 tile. </font><font style="vertical-align: inherit;">Each part of the component can be turned horizontally / vertically, which allows the use of component tiles in different places. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, in the first-tier set of the first-level tiles of The Lost Vikings there are several tiles, such as stairs, which have mirrored versions, as well as many tiles, which several times use the same corner fragment, for example, blue riveted panels.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/948/28c/5af/94828c5af381995b1dcf525ba4cd97b5.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can view this tile set like this: </font></font><br><br><pre> <code class="cpp hljs">./tileset_view DATA.DAT <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The batch file contains for each tile set a block describing the blanks. Each blank has a length of 8 bytes, and each tile is encoded as a 16-bit value. For each 16-bit value, the sprite index is encoded as a 10-bit value, and the remaining 6 bits are used as flags. The flags determine the vertical and / or horizontal mirroring of the sprite, as well as where this component of the tile is located: in front or in the background. Encoding the front / background bit in the workpiece allowed the Blizzard engine to use a common tile map for rendering both layers</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blackthone expands the use of blanks in the engine in two ways. First, the three unused bits of flags are applied as a color base. The Lost Vikings binds to all tiles of the card only 16 colors. Thanks to the addition of the base color bits, Blackthorne can use 128 colors for tiles, but every single component sprite is still limited to 16 colors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, a background map layer was added to Blackthorne. This allows the game to have more detailed backgrounds and the sky, translucent through the voids in the front tiles. For simplicity, I will call the secondary background layer a sky layer, and the main tile map as the foreground and background layers. The sky layer does not use bits of the front / background flags, so you can consider it as a single layer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure below shows how the tile map for the first level of Blackthorne is assembled: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/37d/dbd/67937ddbd48b4e2fcc8b386a139fe439.png" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From left to right, top to bottom: sky / background, front tiles, background tiles, all layers.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can view the tile map as follows (note that level is number 3 because levels are 1 and 2 - this is the initial animation screensaver and training level):</font></font><br><br><pre> <code class="cpp hljs">./level_view --blackthorne DATA.DAT <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here you can see a couple of interesting points: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some parts of the sky layer are completely covered by the front layers. </font><font style="vertical-align: inherit;">Perhaps it happened because of the development process or the Blizzard tools.</font></font><br></li><li>      ,    ‚Äî  . ,          .   ,      ,  . -              /. </li><li>      . ,     .  ,   Blackthorne   ,   .         .      ,      . , Blizzard           ,      ,        The Lost Vikings. </li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything is a level </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blizzard took another smart step: everything in the game - intermediate screens, animated screensavers, menus - are levels. </font><font style="vertical-align: inherit;">Without a doubt, it saved a lot of development time. </font><font style="vertical-align: inherit;">Since all the hard work of implementing the code for the levels of the game with animation and moving objects has already been done, it is logical to use it again to control the screensavers and menus. </font><font style="vertical-align: inherit;">I suppose, in the game engine, the virtual machine is again used to implement animation in the levels of animated screensavers. </font><font style="vertical-align: inherit;">The only notable exception was The Lost Vikings' initial screen from the beginning of this section, which is encoded as a big raw sprite without compression.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, when you start a game, several initial screens are displayed. </font><font style="vertical-align: inherit;">Two of them are encoded as a single level (of two rooms). </font><font style="vertical-align: inherit;">The left part of the image below shows a set of tiles for the level, and on the right - the level itself. </font><font style="vertical-align: inherit;">The game first shows the silhouette of the character (which glows, but more on that later). </font><font style="vertical-align: inherit;">The Blackthorne logo is displayed above the main menu. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e84/49b/07c/e8449b07c7e61bf5c9def7d09846b8eb.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I don‚Äôt know exactly why we need these two copies of Blackthorne logo tiles. </font><font style="vertical-align: inherit;">Notice that they have slightly different colors. </font><font style="vertical-align: inherit;">For example, in the upper set the TM icon is black and is inside the logo, and in the lower one is white and is outside. </font><font style="vertical-align: inherit;">Perhaps this set of tiles is once again used for another screen at the end of the game? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A set of tiles and the level of this screen can be viewed as:</font></font><br><br><pre> <code class="cpp hljs">./tileset_view --blackthorne DATA.DAT <span class="hljs-number"><span class="hljs-number">1</span></span> -c <span class="hljs-number"><span class="hljs-number">0x6e</span></span> ./level_view --blackthorne DATA.DAT <span class="hljs-number"><span class="hljs-number">1</span></span> -h0x6e</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Palette control </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I mentioned above that sixteen colors are used in each sprite, and the values ‚Äã‚Äãare always encoded as 0x0 - 0xf. This allows each level to assign its own palette to reuse sprites in different levels.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several worlds in The Lost Vikings, including the cosmic, prehistoric and insane candy worlds. Each has its own color scheme and enemies. Player-controlled Vikings use only two sets of 16-color palettes (Olaf and Baleog both use the same green-yellow color scheme, while Eric has a red-blue scheme). The interface uses another set of 16 colors, and another one is used for items such as keys and health replenishment that exist in all worlds. Due to this, a decent part of the 256-color palette remains, which is determined by the level. Most levels load a basic 128-color palette, and then a set of eight 16-color palettes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Individual level palettes allow you to reuse sprites with a different color scheme. It was a popular trick in the era of 8-bit color and limited disk space. As you know, in Mortal Kombat games there are several palettes that change the look of ninja characters. The image below shows the same dinosaur sprites with palette settings of different levels: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/318/e5d/8e2/318e5d8e22394e98543336f19c41bd48.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can view two different versions of the dinosaur sprite like this:</font></font><br><br><pre> <code class="cpp hljs">./sprite_view DATA.DAT -fpacked32 -b0xc0 -l5 <span class="hljs-number"><span class="hljs-number">0xf8</span></span> ./sprite_view DATA.DAT -fpacked32 -b0xc0 -l10 <span class="hljs-number"><span class="hljs-number">0xf8</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the sprite number viewer (-l) and offset base offset (-b) arguments are passed to the sprite viewer. </font><font style="vertical-align: inherit;">The level number is used to determine which palette blocks to load when analyzing a level header block. </font><font style="vertical-align: inherit;">I determined the index of the base palette experimentally. </font><font style="vertical-align: inherit;">Again, in this part of the Blizzard engine, I did not understand completely. </font><font style="vertical-align: inherit;">Again I suspect that the index of the base palette is indicated by commands in the program of virtual machine objects.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Palette animations </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another popular trick from the DOS era is animation of graphics by changing the colors of the palette. Animation of the object by redrawing pixels is quite expensive, especially for large parts that need to be updated frequently, for example, for background waterfalls in Blackthorne. Instead of changing the pixels themselves, it is much more economical to change the colors of the palette. At the same time, all pixels of the corresponding color are instantly updated. This technique is mainly useful for simple loop animations, such as waterfalls and flashing lights in the cosmic levels of The Lost Vikings. As mentioned earlier, palette animations are used in Blackthorne to create a silhouette glow effect on the initial screen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Blizzard engine implements palette animations in the level header. Each palette animator has an 8-bit speed value and two 8-bit color index values. If the two indices are not equal, then the animation cycles between the two indices. This format is well suited for animating objects moving in a pattern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the two indices are equal, then the animation of the palette is used for one color and the level header indicates a list of 16-bit values ‚Äã‚Äãfor the animation. </font><font style="vertical-align: inherit;">Each of the 16-bit values ‚Äã‚Äãencodes the color value in the RGB-555 format (5 bits per color, that is, one bit is wasted). </font><font style="vertical-align: inherit;">The usual VGA palette and Blizzard engine are capable of displaying 6 bits per color. </font><font style="vertical-align: inherit;">Palette animations lose the least significant byte by shifting each color value one space to the left. </font><font style="vertical-align: inherit;">This palette animation format is useful for animating something like pulsating light. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can click in the ‚ÄúA‚Äù level viewer to view the palette animations.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Game over </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That's all for now: </font></font><br><br><pre> <code class="cpp hljs">./level_view DATA.DAT <span class="hljs-number"><span class="hljs-number">48</span></span> ./level_view --blackthorne DATA.DAT <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/13c/dfa/77e/13cdfa77ec9f933380c5840a8e2e9b61.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can read me on Twitter: </font></font><a href="https://ryiron.wordpress.com/mentions/ryiron/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ryiron</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/329448/">https://habr.com/ru/post/329448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329436/index.html">How IT professionals work. Savva Mikhalevsky, front-end architect Grabr</a></li>
<li><a href="../329438/index.html">Check Point Security CheckUP - R80.10. Part 2</a></li>
<li><a href="../329440/index.html">Accelerating WSUS</a></li>
<li><a href="../329444/index.html">How does Roketbank know your name</a></li>
<li><a href="../329446/index.html">Execution Threads and PHP</a></li>
<li><a href="../329450/index.html">IT digest of events of the end of May-June</a></li>
<li><a href="../329452/index.html">Vue.js for doubters. All you need to know</a></li>
<li><a href="../329454/index.html">Top reports on Google I / O 2017: Architecture and more</a></li>
<li><a href="../329456/index.html">Learning to listen to the robot talk</a></li>
<li><a href="../329458/index.html">Becoming in demand in the labor market: what topics need a Java developer to know?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>