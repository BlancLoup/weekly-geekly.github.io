<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Macros in Emacs: form teams for processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Do not forget your roots, remember, there are things much higher ... 
 Caste here 

 Life story 

 Many began their computer life with games. Whoever ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Macros in Emacs: form teams for processing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d6d/e2e/0d9/d6de2e0d9cd9478cbcb737bdf0656563.jpg"><br><br>  <i>Do not forget your roots, remember, there are things much higher ...</i> <i><br></i>  <i>Caste here</i> <br><br><h1>  Life story </h1>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many began their computer life with games.  Whoever did not start, he plays chess on a wooden board, like some other president.  I do not play chess, I play Starcraft and other similar games.  Once I played for many hours, but the time passed and the games turned into serious lessons, giving some result.  At the same time, although the games were reborn, the habits remained old.  Sometimes you want to play. <br><br>  What is not in chess?  In chess, there are no live patrols, troops, minefields in the most favorite places and a lot more, which is sometimes not enough, while you recompile some program by editing it.  Nostalgia captures and we slowly begin to look for something similar in the software environment.  And we find! <br><br>  Today we will talk about funny macros. <br><br><a name="habracut"></a><br><br>  In Emacs, there are two kinds of macros ‚Äî boring and fun.  Boring ones are macros in Lisp, and fun ones are keyboard macros that are well known to many.  Here about the second and will be discussed. <br><br><h1>  Priming - master buttons </h1><br><br>  <i>When you start the game for the first time, you see in front of you one builder who stands and does nothing.</i>  <i>Chasing him around the neighborhood, you start building something, and at the same time you notice the highlighted letters in the names of buildings and actions.</i>  <i>These letters are access keys through which you can quickly perform actions.</i>  <i>In the future, the game is reduced to the sequential pressing of these letters at the right time.</i> <br><br><h2>  What is a macro? </h2><br><br>  Everyone knows that there are such things in programs that are called ‚Äúmacros‚Äù, and Emacs itself contains this concept in the root of its name (Editor MACroS), so don‚Äôt know this concept when using Emacs and do not try them - shame-like.  At the same time, not everyone knows further macros F3 and F4, by analogy with macros in other programs, in which they are in their infancy. <br><br><h2>  What are macros in emacs? </h2><br><br>  Macros in Emacs, generally speaking, of the common with other programs, only keyboard writing and have.  Otherwise, it is a powerful apparatus that can be used to its fullest, to which, as a rule, no one comes.  One guy on the Internet, in the midst of many decent settings for Emacs, even suggested to hang another action on a macro combination, because it is never said to be used.  Apparently, he thought that Emacs macros are the same as everywhere else, and they boil down to two keys ‚Äî recording and playback. <br><br>  In Emacs, the situation is completely different: <br><br>  First, when recording macros, they fall into the macro ring, for which a number of operations are defined.  That is, macros there are not just recorded for memories of them, but you can choose them by walking around the ring back and forth.  And you can not just walk around the ring, but also go into each macro, making changes to it. <br><br>  Secondly, this ring itself is not simple.  Such control keys are attached to it, which are designed for permanent operations with it, which is why the initial key combination for access to the ring is remembered by Emacs so that it does not need to be pressed each time. <br><br>  If you press Ctrl + x + Ctrl + k, then you will enter the keyboard namespace.  After that, holding Ctrl, you can press many keys that are responsible for actions with the ring and the current macro. <br><br>  Consider an example: <br><br>  1) We write two macros.  The first macro will insert the number 1, and the second will insert the number 2. <br><br> <code>F3 1 F4 <br> F3 2 F4 <br></code> <br><br>  From the bottom, after each click on F3, you will see that the recording has started, and after each click on F4, you will see that the macro is recorded.  After these actions, 12 are displayed in the buffer and we have an invisible ring in which there are two macros.  The second macro is selected (or active). <br><br>  2) Run the selected macro.  Many would like to press F4 now, because it is so simple, but we will not press it.  We are now passing the ring, and not how a macro can be performed in a quick way. <br><br>  Push long start <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + k <br></code> <br><br>  We saw that the number 2 was inserted, while we do not release Ctrl, but continue to press the buttons <br><br> <code>Ctrl + p + Ctrl + k <br></code> <br><br>  And first, after p, we see that at the bottom (in the minibuffer) something is written (number 1), and then after k, we see how the number 1 is inserted. While holding Ctrl, we press further <br><br> <code>Ctrl + n + Ctrl + k <br></code> <br><br>  And first, after n, we see that the information on the current macro is written in the same way (number 2), and then after k, we see how the number 2 is inserted. <br><br>  3) Release all the buttons.  12212 remained on the screen. The first two digits participated in the macro recording, the other three digits - the result of the macro execution. <br><br>  What happened?  We recorded two simple macros, and then entered the keyboard namespace by pressing the prefix combination Ctrl + x + Ctrl + k.  Acting in this namespace, we first executed the second macro, then switched from the second macro to the first one and executed the first one, and then switched from the first macro back to the second one and again executed the second one. <br><br>  If you did everything correctly, then the left Ctrl was never released after entering the space and at the same time only the kpkn k keys were pressed with the right hand. <br><br>  This is the difference in the launch of the macro: if we have a single macro, then it is more convenient for us to run it through F4;  if we have several macros in the ring and we need to run them alternately, then we use a long start. <br><br><h2>  What else can you do with this ring? </h2><br><br>  The ring itself can be rotated by changing the current element, so the ring has no fixed beginning or end.  At each moment of time, the last element in the ring is considered the current element, and the first element is the element following it.  When a new macro is recorded, it will be added to the ring after the current element, becoming the last element in the ring.  So you can create the desired order of macros in the ring. <br><br>  Most of the operations with the ring (forward transitions <b>n</b> and back <b>p</b> , doing <b>k</b> , deleting <b>d</b> , editing the macro) work in the same way, requiring only one button press, which makes the use of the ring speed and convenient.  But there are also operations that, in theory, should work the same way, but do not work.  Perhaps they were added later by another author who did not notice this ecosystem. <br><br>  To clean the ring by removing some or all of the elements, you need to click <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + d <br></code> <br><br>  And then just hold down Ctrl and press dd d. <br><br>  And you can change the order of macros through <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + t <br></code> <br><br>  Sometimes this is required in conjunction with cleaning the ring from failed macros. <br><br>  And this is exactly the case when the removal of elements works in an abbreviated version, and the exchange of elements only in full.  So most often you just need to know what actions need to be typed in full.  As a rule, such inconvenient actions are combined with each other because they are used less frequently than the main ones. <br><br>  The length of the ring limit is 8 macros, but in the Emacs settings, of course, you can easily increase it (for example, set 32).  It‚Äôs a lot or a little ‚Äî for individual manually recorded macros, it may seem like 8 is enough.  But in order to seriously use this, 8 is not enough. <br><br><h1>  We make the first fighters </h1><br><br>  <i>Chasing the builder, when we built the first buildings open for construction, we find barracks in which you can make the simplest fighters.</i>  <i>Usually there are two of them: one for close combat, the other for long-range.</i>  <i>As they are created, we also notice the highlighted letters for quick access to these fighters and their actions.</i> <br><br><h2>  How can I create a macro? </h2><br><br>  At first we, of course, write them down through F3 F4.  Then we find the macro editor, in which we find the only way to edit already recorded macros, and everything goes back to F3 F4. <br><br>  In fact, there are two states of the ring: there is nothing in the ring and there is something in the ring.  And for these two states there are ways to create a new macro. <br><br>  When there is nothing in the macro ring and we just want to create a macro, we can apply the following methods: <br><br>  1) Start the macro editor, which will offer to create a macro. <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + ey <br></code> <br><br>  This method requires that something be necessarily written to the macro, it will not be possible to create an empty macro. <br><br>  2) Apply a hack to F3 F4. <br><br> <code>F3 + Ctrl + u + F4 <br></code> <br><br>  Emacs writes an error in the minibuffer, but an absolutely empty macro is created. <br><br> <code>Wrong type argument: integerp, (4) <br></code> <br><br>  3) Run the command to read the macro from the text. <br><br> <code>Ctrl + SPC + Ctrl + SPC + Alt + x + read-kbd-macro <br></code> <br><br>  There is a side effect: since we set and remove the marker, the ring of markers is changing, which might be necessary somewhere.  Through Ctrl + u + Ctrl + SPC you can usually walk on this ring, thus an extra position may appear. <br><br>  When there is at least one macro in the macro ring and we just want to add a macro, we can apply the following methods: <br><br>  1) Copy a macro through a single-line macro editor. <br><br> <code>Ctrl + x + Ctrl + k + SPC + Ctrl + k <br></code> <br><br>  The editor for the current macro opens, but because of Ctrl + k, the macro will be copied to the new macro, discarding all the contents. <br><br>  2) Apply a hack to F3 F4. <br><br> <code>F3 + Ctrl + u + F4 <br></code> <br><br>  Here the method is the same as with the empty ring. <br><br>  When there are macros in the ring, the read-kbd-macro command will not create a new macro, but write to the selected one.  Therefore, the method with this command does not work here.  You can only overwrite the selected macro, which may contain something important. <br><br>  Here, many may have the question "why do we need an empty macro?".  The fact is that macros are large and small, complex and simple.  Writing a macro can take much longer than writing it quickly through the editor.  In addition, not always the seemingly correct recording of a macro turns out to be like this when it is executed.  You need to be able to use the editor, especially since it is elementary. <br><br><h2>  How can I edit a macro? </h2><br><br>  For the next experiment, we will need to make two macros and prepare the third one completely empty. <br><br> <code>F3 123 F4 <br> F3 456 F4 <br> F3 Ctrl+u F4 <br></code> <br><br>  We have three macros in the ring: one inserts 123, another inserts 456, the third macro is empty and is selected.  We need to write in the third macro the contents of the first two. <br><br>  We move to the first macro. <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + n <br></code> <br><br>  Open it for editing <br><br> <code>Ctrl + e <br></code> <br><br>  We see <br><br><pre> <code class="hljs cmake">;; Keyboard <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span> Editor. Press Cc Cc to finish; press Cx k RET to cancel. ;; Original keys: <span class="hljs-number"><span class="hljs-number">123</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span>: last-kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> Key: none <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span> ;; self-insert-<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br>  Go to the line at the top, where it is written <br><br><pre> <code class="hljs perl">;; Original <span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span></code> </pre><br><br>  And copy to buffer 123. <br><br>  Then just close the buffer. <br><br> <code>Ctrl + x + k + &lt;RET&gt; <br></code> <br><br>  Then go to the second macro <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + n <br></code> <br><br>  Open it for editing <br><br> <code>Ctrl + e <br></code> <br><br>  We see <br><br><pre> <code class="hljs cmake">;; Keyboard <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span> Editor. Press Cc Cc to finish; press Cx k RET to cancel. ;; Original keys: <span class="hljs-number"><span class="hljs-number">456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span>: last-kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> Key: none <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span>: <span class="hljs-number"><span class="hljs-number">456</span></span> ;; self-insert-<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><br>  Go to the line at the top, where it is written <br><br><pre> <code class="hljs perl">;; Original <span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>: <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre><br><br>  And copy to buffer 456. <br><br>  Then just close the buffer. <br><br> <code>Ctrl + x + k + &lt;RET&gt; <br></code> <br><br>  Then go to the third macro. <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + n <br></code> <br><br>  Open it for editing <br><br> <code>Ctrl + e <br></code> <br><br>  We see <br><br><pre> <code class="hljs cmake">;; Keyboard <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span> Editor. Press Cc Cc to finish; press Cx k RET to cancel. ;; Original keys: <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span>: last-kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> Key: none <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span>:</code> </pre><br><br>  And paste after the line "Macro:" via Ctrl + y, Alt + y, Ctrl + y our copied lines 456 and 123. <br><br><pre> <code class="hljs cmake">;; Keyboard <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span> Editor. Press Cc Cc to finish; press Cx k RET to cancel. ;; Original keys: <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span>: last-kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> Key: none <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span> <span class="hljs-number"><span class="hljs-number">456</span></span></code> </pre><br><br>  Then save it via Ctrl + c + Ctrl + c. <br><br>  Now we have three macros in the ring: the first is 123, the second is 456, the third is 123456. <br><br>  Naturally, we could write all this manually (123456), without copying anything, but these macros are too simple.  In more complex cases, writing the sequence to the beginning will not be so easy, and writing a large macro through F3 can drown in errors.  Therefore, small macros are written one after another, and there is always a complete record in the editor that can be simply copied. <br><br>  The second method, which is also often used, is through read-kbd-macro.  We simply select the text and execute read-kbd-macro.  Then whatever macro we are (full or empty), it will be overwritten with this text.  Just need to remember that spaces and line breaks will disappear. <br><br>  The spaces in the editor are written in the form of SPC SPC SPC, so copying through the editor does not often require additional actions. <br><br><h2>  What is in the macro? </h2><br><br>  What the macro consists of - of three things: a sequence of clicks, a counter and a format string of the counter.  There are two more things that can often be noticed, the name of the macro and its keyboard combination.  If the first three things are in each macro, then the remaining two are external and are attached to the macro at will through an additional code.  Therefore, they can be either tied to a macro or untied from it. <br><br>  The counter itself inside the macro can be confusing, since it is not immediately obvious how it changes when the macro is called.  The answer is simple: it does not change at all.  This counter is simply stored in a macro and works completely independently of it.  A format string refers only to the counter, determining its output. <br><br>  From what is often used from the macro-insides, you can select only the ‚Äúrequest for continuation‚Äù.  Its essence boils down to the following: during operation, the macro by a special feature in its sequence determines that it is necessary to stop and ask the user about further actions.  Why do you need it?  The command to execute a macro has an argument that specifies the number of its repetitions.  And when we process some unknown data with a macro, using the argument to automatically repeat the macro, often they need to be processed selectively, because the macro during such execution can find fragments that need to be skipped. <br><br>  Even if we recorded a macro without this ‚Äúrequest for continuation‚Äù, then we can add it through the macro editor at any time.  If we added it, but it was no longer needed, then through the editor it can be removed as quickly. <br><br>  And it looks like this <br><br> <code>Cx q <br></code> <br><br>  You can directly open macro 123 and insert such lines between the numbers, then run it and see the request for continuation <br><br><pre> <code class="hljs cmake">;; Keyboard <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span> Editor. Press Cc Cc to finish; press Cx k RET to cancel. ;; Original keys: <span class="hljs-number"><span class="hljs-number">1</span></span> Cx q <span class="hljs-number"><span class="hljs-number">2</span></span> Cx q <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span>: last-kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> Key: none <span class="hljs-keyword"><span class="hljs-keyword">Macro</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> ;; self-insert-<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> Cx q ;; kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span>-query <span class="hljs-number"><span class="hljs-number">2</span></span> ;; self-insert-<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> Cx q ;; kbd-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span>-query <span class="hljs-number"><span class="hljs-number">3</span></span> ;; self-insert-<span class="hljs-keyword"><span class="hljs-keyword">command</span></span></code> </pre><br><br>  If we now run the macro with the argument <br><br> <code>Alt + 5 + F4 <br></code> <br><br>  When executed, it will ask each time at the appropriate places, write down a number and continue or not write down a number and continue. <br><br>  If someone did not notice, now everything is ready to test this experiment.  You can copy the macro directly from this text from the line with ";; Original keys:" to the clipboard, open the macro editor in your Emacs via Ctrl + x + Ctrl + k + Ctrl + e, insert this line after the line "Macro : ‚Äù, Press Ctrl + c + Ctrl + c, and then press Alt + 5 + F4. <br><br><h2>  What macros to do, large or small? </h2><br><br>  When you make macros in any programs, the question arises, how best to do one large or many small ones.  Experience suggests that a large macro, even while recording, may turn on and have to be overwritten with the same risk.  If we talk about storage, then at the slightest change in the data that it converts, you will need to deal with its change, and the change leads to debugging.  It is easy to get bogged down in such a macro by simply starting editing some unimportant text through it. <br><br>  There is another aspect - macros require repetitions.  It often happens that you need to repeat only a small subset of the actions of the whole macro cyclically.  To do this, one would have to single them out of a monolith and in the same way make a small macro out of them, as one could do from the very beginning. <br><br>  Therefore, small macros are better.  They can be repeated, they can be replaced, they can be corrected and their order can be easily changed without destroying the entire system. <br><br><h1>  We send soldiers in the first campaign </h1><br><br>  <i>When the first soldiers are done, they go hiking to break something and fight with someone.</i>  <i>So it turns out the strength, armor and speed of different types of fighters, so that later you can properly distribute them during planned campaigns.</i> <br><br><h2>  What macros are there? </h2><br><br>  Very often, macros are applied only to the text, since the rest of their capabilities are not obvious.  In Emacs, macros can be divided into three types: for changing text, for changing appearance, and for executing functions. <br><br>  Most of the actions to create windows in the frame and resize them are performed many times, but few know that all this can be done by macros.  Now we will write a simple macro and play with it. <br><br>  1) Open the editor and write the first macro. <br><br> <code>Cx 2 Cx 3 Cx o Cx o Cx 3 Cx o <br></code> <br><br>  2) Write the second macro. <br><br> <code>123 <br></code> <br><br>  3) Now in the clean window, select the first macro and run it three times. <br><br> <code>Alt + 3 + Ctrl + x + Ctrl + k + Ctrl + k <br></code> <br><br>  Without releasing Ctrl, go to the second macro. <br><br> <code>Ctrl + n <br></code> <br><br>  Without releasing Ctrl, run it. <br><br> <code>Ctrl + k <br></code> <br><br>  If done correctly, you will see such a picture. <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/682/f94/0f6/682f940f624049658a15c9c0e257a933.png"><br></div></div><br><br>  It is easy to make such a picture. <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/045/7f9/f82/0457f9f8279b4787bac5e0fa4d82e416.png"><br></div></div><br><br>  And such <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/6ca/49d/899/6ca49d899e044e3c9a5e8ff661063900.png"><br></div></div><br><br>  As you can see, we just recorded a simple macro of splitting the windows, and they can make such different patterns. <br><br>  A more useful example is the opening of two independent consoles.  If we program, it is often necessary to start one in one console, and another in another.  At the same time, we need to edit the source. <br><br>  Write the macro and execute <br><br> <code>Cx 2 Cx o Cx 3 Cu &lt;&lt;shell&gt;&gt; shell-compil RET Cx o Cu &lt;&lt;shell&gt;&gt; shell-exec RET M-- 2 Cx o <br></code> <br><br>  See a text buffer with two different consoles below it. <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ece/d45/6c2/eced456c267a42fb8d7a154d99fac378.png"><br></div></div><br><br>  Now write this macro <br><br> <code>Cx o Cx k RET yes RET Cx o Cx k RET yes RET Cx 0 Cx 0 <br></code> <br><br>  This is the reverse action - closing windows with consoles.  Now a set of consoles can be opened with one macro and closed with another.  And switching between these macros can be a way we already know. <br><br>  Here is another example of a macro, but no longer processing the text or creating a window, but performing some set of actions in the file manager mode. <br><br>  Record a macro <br><br> <code>+ dir &lt;f3&gt; 2*RET Cx Cf file . txt RET abcd Cx Cs Cx k RET g ^ g <br></code> <br><br>  Set him a counter <br><br> <code>Ctrl + x + Ctrl + k + Ctrl + c <br> 1 <br> RET <br></code> <br><br>  Create a directory somewhere and go to it via Ctrl + x + d.  Having executed a macro in it five times, you will see five directories created, where each directory will have its own file with its own text. <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/487/5d8/bbc/4875d8bbcbfa4e00b26dd7066c1c9b00.png"><br></div></div><br><br>  So you can create and delete directory trees, change the contents of files or their external data like rights or names.  Similarly, you can use macros in consoles to automatically compile and run programs.  In addition, one macro can interact with different consoles, switching between them. <br><br>  Here is another example. <br><br> <code>echo SPC x RET Cx o echo SPC y RET Cx o <br></code> <br><br><div class="spoiler">  <b class="spoiler_title">Show</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/57d/94b/622/57d94b62215c4c65ae14dcd26988bc71.png"><br></div></div><br><br><h1>  Cooking soldiers on base </h1><br><br>  <i>When we found out in the first battle the capabilities of different types of soldiers, we can already make specific types to solve already defined tasks and accumulate them in a safe place where no one will beat them.</i>  <i>We begin to find out what the composition and in what quantity is more effective.</i> <br><br><h2>  How to hide macros? </h2><br><br>  When during the Emacs session we have done a lot of all sorts of convenient macros, it becomes a pity to throw them away.  Searches on the Internet do little, on the best pages dedicated to Emacs, it is written only about converting a macro to a Lisp view and then saving it as a normal function.  It seems that this is what is needed, but here you encounter a known problem: this function needs to memorize a name that will be forgotten in a couple of days.  There is an even more difficult option - when the macro itself is forgotten.  Adding these two things results in &lt;forgotten macro&gt; + &lt;forgotten name&gt; = 0. But the most important thing, and this is the main problem, - such macros are not inserted into the macro ring, therefore they fall out of this wonderful machine.  It turns out a bundle of macros on those that were saved, and those that were recorded during the current session. <br><br>  To convert a macro to a Lisp view, we switch to it and run insert-kbd-macro. <br><br>  Here are macros 123 and 456 <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">setq</span></span> last-kbd-macro <span class="hljs-string"><span class="hljs-string">"123"</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> last-kbd-macro <span class="hljs-string"><span class="hljs-string">"456"</span></span>)</code> </pre><br><br>  It seems simple and tasteful, but they are not suitable for loading, since both are loaded into the last macro, and for this you have to make an empty macro.  To create macros suitable for loading, you need to give them both names through Ctrl + x + Ctrl + k + n (not to be confused with switching to the next macro). <br><br>  When they have onetwothree and fourfivesix names, the insert-kbd macro command works differently. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">fset</span></span> 'onetwothree (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> arg) <span class="hljs-string"><span class="hljs-string">"Keyboard macro."</span></span> (<span class="hljs-name"><span class="hljs-name">interactive</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>) (<span class="hljs-name"><span class="hljs-name">kmacro-exec-ring-item</span></span> (<span class="hljs-name"><span class="hljs-name">quote</span></span> (<span class="hljs-string"><span class="hljs-string">"123"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>)) arg))) (<span class="hljs-name"><span class="hljs-name">fset</span></span> 'fourfivesix (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> arg) <span class="hljs-string"><span class="hljs-string">"Keyboard macro."</span></span> (<span class="hljs-name"><span class="hljs-name">interactive</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>) (<span class="hljs-name"><span class="hljs-name">kmacro-exec-ring-item</span></span> (<span class="hljs-name"><span class="hljs-name">quote</span></span> (<span class="hljs-string"><span class="hljs-string">"456"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>)) arg)))</code> </pre><br><br>  This is now cast into the Lisp file, which connects to the Emacs init files.  This is considered a classic way of saving macros, which will be available under these names the next time Emacs is booted.  It does not take into account that the macro ring will be empty. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your way was found quickly. </font><font style="vertical-align: inherit;">I had to pick it all up and get to the ring, and then learn how to push macros into it without any names.</font></font><br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defun</span></span> make-my-macros() <span class="hljs-string"><span class="hljs-string">"Make macros."</span></span> (<span class="hljs-name"><span class="hljs-name">interactive</span></span>) (<span class="hljs-name"><span class="hljs-name">add-to-list</span></span> 'kmacro-ring '(<span class="hljs-string"><span class="hljs-string">"123"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>)) (<span class="hljs-name"><span class="hljs-name">add-to-list</span></span> 'kmacro-ring '(<span class="hljs-string"><span class="hljs-string">"456"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>))) (<span class="hljs-name"><span class="hljs-name">make-my-macros</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, having executed this code through eval-buffer, you can at any time load macros into the ring, while the ring remains open to writing new macros. </font><font style="vertical-align: inherit;">If you throw this code into the initialization file, then to reload the macros it will be enough to call the function.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why is this better than normal functions? </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if you know lisp well (not even lisp itself, but the names of Emacs internals), in any case, writing one function will take longer than recording a macro. At the same time, any changes to the function will be stopped due to the difficulties of debugging, saving and reloading the function. The homework of one function in symbiosis with others will not go well either, since many unimportant things will have to be memorized by heart. And macros - today they are here, and tomorrow - there. They are more free. They can be changed on the go and copied without any problems and the fear of loss or fear of subsequent heavy debugging. If there is an error in the macro, it is simply copied and all experiments are performed on the copy in the macro editor. When everything is ready, the old version is removed and the new one moves to its place.In this case, the effect of one small macro is often equal to the effect of a heap of functional structures.</font></font><br><br><h1>      </h1><br><br> <i>   ,     .    ,     ,      ,            .      ,       .</i> <br><br><h2>    ? </h2><br><br>     <a href="https://habrahabr.ru/post/268709/">  </a> Emacs'.         ,          ,           .   ,      Emacs'  ‚Äî          ,      . <br><br>  ,       ,    .           ,          .          ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have several modes: one for Habra, another for Yutyube, and the rest for forums. </font><font style="vertical-align: inherit;">And some of them have already developed their own system of functions and macros. </font><font style="vertical-align: inherit;">In each mode, macros are grouped by task, and for each task its set of macros can be loaded into the ring. </font><font style="vertical-align: inherit;">In addition, the task itself and the composition of the macros in it can be described in the comments in the function, which can then be easily viewed through the help of the mode available via Ctrl + h + m. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what does the help to the regime for Habra look like?</font></font><br><br><pre> <code class="hljs cmake">Habra minor mode (indicator Habr): Mode for `http://www.habrahabr.ru'. key binding --- ------- Cc Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc m Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc mh Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc mhc Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc mhm Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc mhq habra-wrap-quote Cc mhmg habra-make-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span>-general Cc mhc <span class="hljs-number"><span class="hljs-number">1</span></span> habra-wrap-code Cc mhc <span class="hljs-number"><span class="hljs-number">2</span></span> habra-wrap-source</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And so it looks like help to the regime for Yutyuba </font></font><br><br><pre> <code class="hljs cmake">Youtube minor mode (indicator YouTube): Mode for `https://www.youtube.com'. key binding --- ------- Cc Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc m Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc my Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc mym Prefix <span class="hljs-keyword"><span class="hljs-keyword">Command</span></span> Cc mymg youtube-make-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span>-general Cc mymp youtube-make-<span class="hljs-keyword"><span class="hljs-keyword">macro</span></span>-playlist</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can always remember the names of functions in this way, and then go into these functions and see their comment about the macros in them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The mode itself for Habra looks like this</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Source code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">;; Habra mode (defun habra-wrap-<span class="hljs-keyword"><span class="hljs-keyword">quote</span></span>() "Wrap selection to &lt;blockquote&gt;&lt;/blockquote&gt; tags." (interactive) (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (mark)) (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-mark (<span class="hljs-type"><span class="hljs-type">point</span></span>))) (narrow-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-region (mark) (<span class="hljs-type"><span class="hljs-type">point</span></span>)) (goto-<span class="hljs-type"><span class="hljs-type">char</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>-min)) (<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> "&lt;blockquote&gt;") (goto-<span class="hljs-type"><span class="hljs-type">char</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>-max)) (<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> "&lt;/blockquote&gt;") (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-mark (<span class="hljs-type"><span class="hljs-type">point</span></span>-min)) (widen)) (defun habra-wrap-code() "Wrap selection to &lt;code&gt;&lt;/code&gt; tags." (interactive) (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (mark)) (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-mark (<span class="hljs-type"><span class="hljs-type">point</span></span>))) (narrow-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-region (mark) (<span class="hljs-type"><span class="hljs-type">point</span></span>)) (goto-<span class="hljs-type"><span class="hljs-type">char</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>-min)) (<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> "&lt;code&gt;\n") (goto-<span class="hljs-type"><span class="hljs-type">char</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>-max)) (<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> "\n&lt;/code&gt;") (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-mark (<span class="hljs-type"><span class="hljs-type">point</span></span>-min)) (widen)) (defun habra-wrap-source() "Wrap selection to &lt;source&gt;&lt;/source&gt; tags." (interactive) (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (mark)) (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-mark (<span class="hljs-type"><span class="hljs-type">point</span></span>))) (narrow-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-region (mark) (<span class="hljs-type"><span class="hljs-type">point</span></span>)) (goto-<span class="hljs-type"><span class="hljs-type">char</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>-min)) (<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> "&lt;source&gt;\n") (goto-<span class="hljs-type"><span class="hljs-type">char</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span>-max)) (<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> "\n&lt;/source&gt;") (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-mark (<span class="hljs-type"><span class="hljs-type">point</span></span>-min)) (widen)) (defun habra-make-macro-general() "Make general macros." (interactive) ;; <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a title <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> spoiler (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>("\Cs&lt;spoiler\Cm title=\"\"\Cb\Cu\C-xq" <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ;; Replace * <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &lt;h1&gt; (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>([?\Cu ?\Cs ?^ ?\\ ?* ? ?\Cm ?\Cx ?q ?\M<span class="hljs-number"><span class="hljs-number">-2</span></span> ?\C-? ?\M-\\ ?&lt; ?h ?<span class="hljs-number"><span class="hljs-number">1</span></span> ?&gt; ?\Ce ?\M-\\ ?&lt; ?/ ?h ?<span class="hljs-number"><span class="hljs-number">1</span></span> ?&gt;] <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ;; Replace ** <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &lt;h2&gt; (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>([?\Cu ?\Cs ?^ ?\\ ?* ?\\ ?* ? ?\Cm ?\Cx ?q ?\M<span class="hljs-number"><span class="hljs-number">-3</span></span> ?\C-? ?\M-\\ ?&lt; ?h ?<span class="hljs-number"><span class="hljs-number">2</span></span> ?&gt; ?\Ce ?\M-\\ ?&lt; ?/ ?h ?<span class="hljs-number"><span class="hljs-number">2</span></span> ?&gt;] <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ;; Change &lt; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &amp;lt; (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>("\Cs&lt;\Cm\C-xq\C-?&amp;lt;" <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ;; Change &gt; <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &amp;gt; (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>("\Cs&gt;\Cm\C-xq\C-?&amp;gt;" <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ;; Change <span class="hljs-keyword"><span class="hljs-keyword">leading</span></span> space <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &amp;nbsp; (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>("\Cu\Cs^ \Cm\C-xq\C-?&amp;nbsp;" <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ;; Change <span class="hljs-type"><span class="hljs-type">double</span></span> space <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> &amp;nbsp; (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>("\Cu\Cs \Cm\C-xq\C-?&amp;nbsp;" <span class="hljs-number"><span class="hljs-number">0</span></span> "%d")) ) (defvar habra-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "Cc mh q") <span class="hljs-string"><span class="hljs-string">'habra-wrap-quote) (define-key map (kbd "Cc mhc 1") '</span></span>habra-wrap-code) (define-key map (kbd "Cc mhc 2") <span class="hljs-string"><span class="hljs-string">'habra-wrap-source) (define-key map (kbd "Cc mhm g") '</span></span>habra-make-macro-general) map) "Keymap for `habra-mode'.") (define-minor-mode habra-mode "Mode for `http://www.habrahabr.ru'. \\{habra-mode-map}" nil " Habr" nil (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> habra-mode (progn (habra-make-macro-general) (<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-list <span class="hljs-string"><span class="hljs-string">'yas-extra-modes '</span></span>habra-mode) (yas-minor-mode t)) (progn (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-string"><span class="hljs-string">'yas-extra-modes (delete '</span></span>habra-mode yas-extra-modes))))) (provide <span class="hljs-string"><span class="hljs-string">'habra-mode)</span></span></code> </pre><br></div></div><br><br>  ,       . Cc + m        ,      ‚Äî h (habra),   ,  ,   ‚Äî m (macro)      ‚Äî g (general). , ,     ,         .                 . <br><br>     ,  ,        .   c (code)     ,   1  2     .         ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted here that in any small mode the general group of macros should be loaded automatically immediately upon connection. </font><font style="vertical-align: inherit;">As practice has shown, without this, it was necessary to constantly invoke a combination to access the macros. </font><font style="vertical-align: inherit;">But the rest of the macros are not automatically loaded, because we remember that the macro ring has a length limitation. </font><font style="vertical-align: inherit;">Therefore, in the mode for Yutyuba, general macros are loaded when the mode is turned on, and special macros (to translate the video list into a table for org-mode) are always waiting for loading via the keyboard shortcut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content Mode for YouTube</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Source code</b> <div class="spoiler_text"><pre> <code class="hljs ruby">;; YouTube mode (defun youtube-make-macro-general() <span class="hljs-string"><span class="hljs-string">"Make general macros."</span></span> (interactive) (add-to-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.youtube.com\Cj"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>)) ) (defun youtube-make-macro-playlist() <span class="hljs-string"><span class="hljs-string">"Make macros for saving playlist."</span></span> (interactive) ;;     (add-to-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>([?\Mx <span class="hljs-string"><span class="hljs-string">?b</span></span> <span class="hljs-string"><span class="hljs-string">?r</span></span> <span class="hljs-string"><span class="hljs-string">?o</span></span> <span class="hljs-string"><span class="hljs-string">?w</span></span> <span class="hljs-string"><span class="hljs-string">?s</span></span> <span class="hljs-string"><span class="hljs-string">?e</span></span> ?- <span class="hljs-string"><span class="hljs-string">?u</span></span> <span class="hljs-string"><span class="hljs-string">?r</span></span> <span class="hljs-string"><span class="hljs-string">?l</span></span> ?- <span class="hljs-string"><span class="hljs-string">?e</span></span> <span class="hljs-string"><span class="hljs-string">?m</span></span> <span class="hljs-string"><span class="hljs-string">?a</span></span> <span class="hljs-string"><span class="hljs-string">?c</span></span> <span class="hljs-string"><span class="hljs-string">?s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ?\Cy <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>] <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>)) ;;      (add-to-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>(<span class="hljs-string"><span class="hljs-string">"\Cs&lt;tr\Ca\Cs&lt;/tbody\Ca\367"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">"%d"</span></span>)) ;;   (, , ) (add-to-list <span class="hljs-string"><span class="hljs-string">'kmacro-ring '</span></span>([?\Cs ?&lt; <span class="hljs-string"><span class="hljs-string">?a</span></span> ? <span class="hljs-string"><span class="hljs-string">?h</span></span> <span class="hljs-string"><span class="hljs-string">?r</span></span> <span class="hljs-string"><span class="hljs-string">?e</span></span> <span class="hljs-string"><span class="hljs-string">?f</span></span> ?= ?\<span class="hljs-string"><span class="hljs-string">" ?\Cm ?\Cw ?h ?t ?t ?p ?s ?: ?/ ?/ ?w ?w ?w ?. ?y ?o ?u ?t ?u ?b ?e ?. ?c ?o ?m ?\Cs ?&amp; ?\Cm ?\Cb ?\Cj ?\Cs ?&lt; ?a ? ?c ?l ?a ?s ?s ?= ?\" ?p ?l ?- ?v ?i ?d ?e ?o ?- ?t ?i ?t ?l ?e ?\Cm ?\Cw ?\Cs ?d ?a ?t ?a ?- ?s ?e ?s ?s ?i ?o ?n ?l ?i ?n ?k ?= ?\Cm ?\Cw ?\Cs ?&gt; ?\Cm ?\Cw ?\Ck ?\M-\\ ?\Ce ?\M-\\ ?\Cj ?\Cs ?c ?l ?a ?s ?s ?= ?\" ?t ?i ?m ?e ?s ?t ?a ?m ?p ?\Cm ?\Cw ?\Cs ?l ?a ?b ?e ?l ?\Cm ?\Cw ?\Cs ?&gt; ?\Cm ?\Cw ?\Cs ?&lt; ?\Cb ?\Cj] 0 "</span></span>%d<span class="hljs-string"><span class="hljs-string">")) ;;    (add-to-list 'kmacro-ring '("</span></span><span class="hljs-params"><span class="hljs-params">|id|</span></span>Url<span class="hljs-params"><span class="hljs-params">|S|</span></span>Desc<span class="hljs-params"><span class="hljs-params">|Time|</span></span>\Cj<span class="hljs-params"><span class="hljs-params">|-\Cj|</span></span><span class="hljs-params"><span class="hljs-params">||</span></span><span class="hljs-params"><span class="hljs-params">|&lt;40&gt;|</span></span><span class="hljs-params"><span class="hljs-params">|\Cm\Ca" 0 "%d")) ;;   (, , )    (add-to-list 'kmacro-ring '("|</span></span>\Cx\Ck\Ci<span class="hljs-params"><span class="hljs-params">|[[\Ce][link]]|</span></span>-<span class="hljs-params"><span class="hljs-params">|\Ck\Ce|</span></span>\Ck\Ce<span class="hljs-params"><span class="hljs-params">|\Ce\Cn\Ca" 1 "%d")) ) (defvar youtube-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "Cc mym g") 'youtube-make-macro-general) (define-key map (kbd "Cc mym p") 'youtube-make-macro-playlist) map) "Keymap </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span><span class="hljs-params"> `youtube-mode'.") (define-minor-mode youtube-mode "Mode </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span><span class="hljs-params"> `https://www.youtube.com'. \\{youtube-mode-map}" </span><span class="hljs-literal"><span class="hljs-params"><span class="hljs-literal">nil</span></span></span><span class="hljs-params"> " YouTube" </span><span class="hljs-literal"><span class="hljs-params"><span class="hljs-literal">nil</span></span></span><span class="hljs-params"> (</span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">if</span></span></span><span class="hljs-params"> youtube-mode (progn (youtube-make-macro-general) (add-to-list 'yas-extra-modes 'youtube-mode) (yas-minor-mode t)) (progn (set 'yas-extra-modes (delete 'youtube-mode yas-extra-modes))))) (provide 'youtube-mode)</span></span></code> </pre><br></div></div><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It's time to send troops to the big war </font></font></h1><br><br> <i>.    ,        .    ,     ,    ,     ,   ,               -.</i> </div><p>Source: <a href="https://habr.com/ru/post/281499/">https://habr.com/ru/post/281499/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281487/index.html">Competition "Admin 80 level" from RUVDS</a></li>
<li><a href="../281491/index.html">About extended support and maintenance of IT infrastructures</a></li>
<li><a href="../281493/index.html">From love to hate - one step, or how I stopped loving magic in ActiveRecord</a></li>
<li><a href="../281495/index.html">C # math expression parser - amateur experience</a></li>
<li><a href="../281497/index.html">Experiments with malloc</a></li>
<li><a href="../281501/index.html">Project Tofino - the new Mozilla browser</a></li>
<li><a href="../281503/index.html">Interfaces: How not to do the option of unsubscribing from the email-list</a></li>
<li><a href="../281505/index.html">How we implemented DevOps: infrastructure-as-code using Microsoft Azure and Azure Resource Manager</a></li>
<li><a href="../281509/index.html">5G core networks: flexibility opens up new business opportunities</a></li>
<li><a href="../281511/index.html">// BUILD / 2016: how it was</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>