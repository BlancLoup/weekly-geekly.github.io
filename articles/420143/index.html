<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin performance on Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's talk today about the performance of Kotlin on Android in production. Let's take a look under the hood, implement cunning optimizations, compare ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin performance on Android</h1><div class="post__text post__text-html js-mediator-article">  Let's talk today about the performance of Kotlin on Android in production.  Let's take a look under the hood, implement cunning optimizations, compare bytecode.  Finally, let us take a serious look at the comparison and measure the benchmarks. <br><br>  This article is based on the report by <strong>Alexander Smirnov</strong> at AppsConf 2017 and will help you figure out whether you can write code on Kotlin, which will not be inferior to Java in speed. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Alexander Smirnov CTO in the company PapaJobs, has a video blog " <a href="https://www.youtube.com/channel/UCW6lJMRd66erX8bwnfortrA">Android in faces</a> ", and is also one of the organizers of the Mosdroid community. <br><a name="habracut"></a><br>  Let's start with your expectations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  Do you think Kotlin at runtime is slower than Java?  Or faster?  Or maybe there is not much difference?  After all, both work on the bytecode that the virtual machine provides us. </blockquote><br>  Let's figure it out.  Traditionally, when the question of performance comparison arises, everyone wants to see benchmarks and specific numbers.  Unfortunately, there is no JMH ( <a href="http://openjdk.java.net/projects/code-tools/jmh/">Java Microbenchmark Harness</a> ) for Android, so we cannot measure everything as coolly as Java.  So what is left for us to do, as written below? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  If you ever try to measure your code this way, then one of the JMH developers will be sad, cry and come to you in a dream - never do that. <br><br>  On Android, you can do benchmarks, in particular, Google demonstrated this even last year‚Äôs I / O.  They said that they have greatly improved the virtual machine, in this case ART, and if on Android 4.1 one allocation of the object took about 600-700 nanoseconds, then in the eighth version it will take about 60 nanoseconds.  Those.  they were able to measure it with such accuracy on a virtual machine.  Why can not we do the same - we do not have such tools. <br><br>  If we look at all the documentation, the only thing we can find is the recommendation above, how to measure the UI: <br><br>  <strong>adb shell dumpsys gfxinfo% package_name%</strong> <br><br>  Actually, let's do that, and see at the end what it will give.  But first, we define what we will measure and what else we can do. <br><br><blockquote>  Next question.  Where do you think performance is important when you create a first-class application? <br><br><ol><li>  Definitely everywhere. </li><li>  Ui thread. </li><li>  Custom view + animations. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  I like the first option the most, but most likely the majority believes that it is impossible to make all the code work very, very quickly and it is important that at least it does not lag UiThread or custom view.  With this, I also agree - this is very, very important.  What you have in a separate stream of JSON will be deserialized for 10 milliseconds longer, then no one will notice. <br><br>  Gestalt psychology says that when we blink, about 150-300 milliseconds, the human eye is at a loss of focus and does not see what is actually happening there.  And then these 10 milliseconds of weather do not.  But if we return to Gestalt psychology, what is important is not what I really see and what is really happening, what I understand as a user is important. <br><br>  Those.  if we make the user think that everything is very, very fast, and in fact it will just be beautifully beaten up, for example, with the help of beautiful animation, he will be satisfied, even if in fact it is not. <br><br>  The motives of Gestalt psychology in iOS have been moving for a long time.  Therefore, if you take two applications with the same processing time, but on different platforms, and put them next to each other, it will seem that everything is faster on iOS.  Animation in iOS processes a little faster, earlier animation starts when loading and many other animations, so that it is beautiful. <br><br>  So the <strong>first rule is to think about the user.</strong> <br><br>  And for the second rule you need to plunge into hardcore. <br><br><h2>  KOTLIN STYLE <br></h2><br>  To honestly evaluate the performance of Kotlin, we will compare it with Java.  Therefore, it turns out, it is impossible to measure some things that are only in Kotlin, for example: <br><br><ul><li>  Sollection Api. </li><li>  Method default parameters. </li><li>  Data classes. </li><li>  Reified types. </li><li>  Coroutines. </li></ul><br>  <strong>The collection of APIs</strong> that Kotlin provides us are very cool, very fast.  In Java, this is simply not there, there are only different implementations.  For example, the Liteweight Stream API library will be slower because it does the same thing as Kotlin, but with one or two additional allocations per operation, since everything turns into an additional object. <br><br>  If we take the Stream API from Java 8, then it will run slower than the Kotlin Solita API, but with one condition ‚Äî there is no paralysis in the API Sollection as in Java 8. If we enable parallel, on large amounts of Stream API data in Java bypasses the Kotlin API collection.  Therefore, we cannot compare such things, because we make comparisons from the point of view of Android. <br><br>  The second thing, which, I think, cannot be compared, is <strong>Method default parameters</strong> - a very cool feature, which, by the way, is in Dart.  When you call a method, it may have some parameters that can take on some value, or they can be NULL.  And therefore you do not do 10 different methods, but do one method and say that one of the parameters can be NULL, and then use it without any parameter.  Those.  it will look, the parameter has come, or it has not come.  Very handy in the sense that you can write a lot less code, but the inconvenience is that you have to pay for it.  This is syntactic sugar: you, as a developer, think that this is one API method, but in reality, under a hood, every variation of a method with missing parameters is generated in the byte code.  And in each of these methods a check is made bit by bit whether this parameter has arrived.  If it came, then ok, if it didn‚Äôt come, then further we make up a bit mask, and depending on this bit mask, the original method that you wrote is already being called.  Bitwise operations, all <em>if / else</em> costs a little bit of money, but very little, and it‚Äôs normal that you have to pay convenience.  It seems to me that this is absolutely normal. <br><br>  The next item that cannot be compared is <strong>Data classes</strong> . <br><br>  Everyone laments that in Java there are parameters for which there are model classes.  Those.  you take the parameters and make more methods, getters and setters for all these parameters.  It turns out that for a class with ten parameters you need a whole pair of getters, setters and a whole heap of everything.  Moreover, if you do not use generators, then you have to write it with your hands, which is generally terrible. <br><br>  Kotlin lets you get away from it all.  First, since there are properties in Kotlin, you do not need to write getters and setters.  It has <strong>no class parameters, all properties</strong> .  In any case, we think so.  Secondly, if you write that it is Data classes, a whole bunch of everything else will be generated.  For example, equals (), toStrung () / hasCode (), etc. <br><br>  Of course, this has its drawbacks.  For example, I did not need to have all 20 parameters of my data classes compared at once in equals (), it was necessary to compare only 3. Someone does not like all this, because performance is lost on this, and besides, a lot is generated service functions, and the compiled code is quite voluminous.  That is, if you write everything with your hands, the code will be less than if you use data classes. <br><br>  I do not use data classes for another reason.  Previously, there were restrictions on the expansion of such classes and something else.  Now with all this better, but the habit has remained. <br><br>  What is very, very cool in Kotlin, and what will it always be faster than Java?  These are <strong>Reified types</strong> , which is also in Dart, by the way. <br><br>  You know that when you use generics, then at the compilation stage, type erasure occurs (type erasure) and at runtime you don‚Äôt know what object of this generic is actually used. <br><br>  With Reified types, you do not need to use reflection in many places, when in Java you would need it, because with inline methods with Reified, knowledge of the type remains, and therefore it turns out that you do not use reflection and your code runs faster.  Magic. <br><br>  And there are <strong>Coroutines</strong> .  They are very cool, I really like them, but at the time of the performance they were only in the alpha version, so there was no possibility to make correct comparisons with them. <br><br><h2>  FIELDS <br></h2><br>  Therefore, let's go further, let's move on to what we can compare with Java and what we can influence in general. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  As I said, we have no parameters for the class, we have properties. <br><br>  We have a var, we have a val, we have an external class, one of the properties of which is @JvmField, and we‚Äôll see what actually happens with the work () function: we summarize the value of the a field and the b field of our own class and the value of the field a and the field b of the outer class, which is written in the immutable field c. <br><br>  The question is what, in fact, will be caused in d = a + b.  We all know that this is a property, then the getter of this class will be called for this parameter. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  But if we look at the byte-code, we will see that in reality there is a getfield conversion.  That is, this is not a call to the InvokeVirtual function in the bytecode, but a direct call to the field.  There is nothing that was promised to us initially, that we have all the properties, not the fields.  It turns out that Kotlin is deceiving us, there is a direct appeal. <br><br>  What will happen if we still see which bytecode is generated for another line: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Previously, if you were accessing a non-private property, then you always had a call to InvokeVirtual.  If it was a private property, then it was accessed via GetField.  GetField is much faster than InvokeVirtual, in the specification from Android it is stated that it is 3‚Äì7 times faster to access the field directly.  Therefore, it is recommended to always refer to the Field, and not through getters or setters.  Now, especially in the eighth ART virtual machine, there will already be other numbers, but if you still support 4.1, this will be true. <br><br>  Therefore, it turns out, it is still beneficial for us to have GetField, not InvokeVirtual. <br><br>  Now, you can get GetField if you are accessing a property of your own class, or, if it is a public property, you need to put @JvmField.  Then just in the bytecode there will be a call to GetField, which is 3‚Äì7 times faster. <br><br>  It is clear that here we are talking in nanoseconds and, on one trona, this is very, very little.  But, on the other hand, if you do it in the UI stream, for example, in the ondraw method you refer to some view, this will affect the rendering of each frame, and you can do it a little faster. <br><br>  <strong>If you add up all the optimizations, then this may add up to something.</strong> <br><br><h2>  STATIC !? <br></h2><br>  What about statics?  We all know that in Kotlin static is a companion object.  Previously, you probably added some kind of tag, for example, public static, final static, etc., if you convert it into code on Kotlin, then you will get a companion object in which something like this will be written: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  Do you think this entry is identical to the standard static static declaration in Java?  Is it generally static or not? </blockquote><br>  Yes, indeed, Kotlin declares that here it is in Kotlin - static, that object says that it is static.  In reality, this is not static. <br><br>  If we look at the generated byte-code, we will see the following: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Test.Companion is generated by a singleton-object for which an instane is created, this instance is written in its own field.  After that, access to any of the companion object occurs through this object.  It takes getstatic, that is, a static instance of this class and calls the invokevirtual function getK, and exactly the same for the work2 function.  Thus, we get that it is not static. <br><br>  This is important, for the reason that the old JVM invokestatic was about 30% faster than invokevirtual.  Now, of course, optimized virtualization is happening on HotSpot very cool, and it is almost imperceptible.  However, you need to keep this in mind, especially since there is one extra allocation here, and an extra location on 4ST1 is 700 nanoseconds, also a lot. <br><br>  Let's look at the Java-code, which turns out, if you reverse the bytecode back: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  A static field is created, a static final implementation of the Companion object, and getters and setters are created, and, as you can see, by accessing the static field inside, an additional static method appears.  Everything is quite sad. <br><br>  What can we do, making sure that it is not static?  We can try adding @JvmField and @JvmStatic and see what happens. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  I‚Äôll say right away that you can‚Äôt get away from @JvmStatic, in the same way it will be an object, since this is a companion object, there will be an extra allocation of this object and there will be an extra call. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  But the call will change only for k, because it will be @JvmField, it will be taken directly as getstatic, getters and setters will not be generated anymore.  And for the work2 function, nothing will change. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  The second option, how to create static is proposed in the Kotlin documentation, so it‚Äôs said that we can simply create an object, and this will be static code. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  In reality, this is also not the case. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  It turns out that we make a call to getstatic instance from singletone, which is being created, and we call the exact same virtual methods. <br><br>  The only option, how we can achieve exactly invokestatic, is Higher-Order Functions.  When we simply write some function outside the class, for example, fun test2 will actually be called static. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  Moreover, the most interesting thing is that a class will be created, an object, in this case, testKt, it will generate an object for itself, it will generate a function that it will put into this object, and then it will be invoked as invokestatic. <br><br>  Why this was done is not clear.  Many are unhappy with this, but there are those who consider this implementation quite normal.  Since the virtual machine, incl.  Art is improving, now it is not so critical.  In the eighth version of Android, just like on HotSpot, everything is optimized, but still these little things slightly affect the overall performance. <br><br><h2>  NULLABILITY <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  This is the next interesting example.  It would seem that we noted that second could be nullable, and it must be checked before doing something with it.  In this case, I expect that we have one if.  When this code is deployed in if second is not zero, then I think that the execution will go on and output only first. <br><br>  How does this all really unfold in java code?  Actually there will be a check. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  We will get Intrinsics initially.  Suppose that what I am saying is that this one <br><br>  If will expand into a ternary operator.  But besides this, although we have even fixed that the first parameter cannot be nullable, it will still be checked through Intrinsics. <br><br>  Intrinsics is an internal class in Kotlin that has some set of parameters and checks.  And every time you make a method parameter not nullable, it still checks it.  What for?  Because we work in Interop Java, and it may happen that you expect that it will not be nullable here, but it will come from Java somewhere. <br><br>  If you check it, it will go further along the code, and then after 10-20 method calls, you will do something with a parameter that, although it cannot be nullable, but for some reason it turned out to be.  You all will fall, and you can not understand what actually happened.  To avoid this situation, every time you pass a null parameter, you will still have to check it.  And if it is nullable, it will be exception. <br><br>  This test is also worth something, and if there are many of them, it will not be very good. <br><br>  But in fact, if we talk about HotSpot, then 10 calls of these Intrinsics will take about four nanoseconds.  This is very, very little, and you should not worry about this, but this is an interesting factor. <br><br><h2>  PRIMITIVES <br></h2><br>  In Java, there is such a thing as primitives.  In Kotlin, as we all know, there are no primitives, we always operate with objects.  In Java, they are used to provide better performance of objects on any minor calculations.  Folding two objects is much more expensive than adding two primitives.  Consider an example. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  There are three numbers, for the first two, not null type will be displayed, and about the third we ourselves say that it can be nullable. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  If you look at the bytecode and see which Java code is generated, then the first two numbers are not null, and therefore they can be primitives.  But the primitive cannot contain a Null, only an object can do this, so an object will be generated for the third number. <br><br><h2>  AUTOBOXING <br></h2><br>  When you work with primitives, and perform an operation with a primitive and non-primitive, then either you need to translate one of them into a primitive, or into an object. <br><br>  And, it would seem, it is no wonder that if you do operations with nullable and not nullable in Kotlin, then you lose a little bit in performance.  Moreover, if there are many such operations, then you lose a lot. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  See where Boxing / Unboxing will be here?  I also did not see until I looked at the byte code. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  Actually, I expected that there would be something like this comparison: if the string is not null and if it is empty, then set to true, otherwise, set to false.  It seems simple, but in reality the following code is generated: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Let's look inside.  The variable <em>a is</em> taken, it is cast in CharSequence, after it has been cast, which has also been spent some time, another check is called - StringsKt.isBlank - this is how the extension function for CharSequence is written, so it is cast and sent.  Since the first expression can be nullable, it takes it and makes Boxing, and wraps it all in Boolean.valueOf.  Therefore, the primitive true also becomes an object, and only after that a check occurs and Intrinsics.areEqual is called. <br><br>  It would seem that such a simple operation, but such an unexpected result.  In fact, such things are very few.  But when you can have nullable / not nullable, you can generate a lot of this, and you would never expect it.  Therefore, I recommend you to avoid confusions as soon as possible.  Those.  <strong>as soon as possible to come to the immunity of values ‚Äã‚Äãand move away from nullable</strong> , so that you can operate as quickly as possible, not null. <br><br><h2>  Loops <br></h2><br>  The next interesting thing. <br><br>  You can use the usual for, which is in Java, but you can also use the new convenient API - just write through the list of elements.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, you can call the work function in a loop, where it will be some element of this list. </font></font><br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An iterator will be generated and there will be a trivial iteration over the iterator. </font><font style="vertical-align: inherit;">This is normal, it is much recommended. </font><font style="vertical-align: inherit;">But if we see what advice Google gives us, we‚Äôll find out, in terms of performance, specifically for ArrayList, iteration through for works 3 times faster than through an iterator. </font><font style="vertical-align: inherit;">In all other cases, the iterator will work identically. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, if you are sure that you have an ArrayList, it is logical to do another thing - write your foreach.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This will also be an API, but which will generate a slightly different code. </font><font style="vertical-align: inherit;">Here we use all the power that Kotlin gives us: we will make an extension function that will be ‚Äúinline‚Äù, which will be of type reified, i.e. </font><font style="vertical-align: inherit;">we will not erase anything, and we will also do so that we will give the lambda, for which we will perform the crossinline. </font><font style="vertical-align: inherit;">Therefore, everything will become very good everywhere, even perfect, the bill works very quickly. </font><font style="vertical-align: inherit;">3 times faster, as recommended by Google‚Äôs Android specification.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rangs </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We could do the same with Ranges. </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The previous example and this with: Unit will be identically handled in bytecode. </font><font style="vertical-align: inherit;">But if you try to do here either ‚àí1, or until add, or another step, then there will be back iterators. </font><font style="vertical-align: inherit;">And besides this, there will be an allocation for the object that will generate ranges. </font><font style="vertical-align: inherit;">Those. </font><font style="vertical-align: inherit;">you allocate the object to which the starting point is written. </font><font style="vertical-align: inherit;">Every next iteration this method will be called with the next step value. </font><font style="vertical-align: inherit;">It's worth remembering.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> INTRINSICS </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let us return to Intrinsics, and consider another interesting example: </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case Intrinsics is called twice - for both second and first. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   ‚Äî Xno-param-assertions ‚Äî    Intrinsics,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this is done everywhere, it will not work out very well, because it leads to the fact that I have already said that the program may fall where you do not expect. </font><font style="vertical-align: inherit;">And in those places where you are really sure that an additional check is not needed, you can do so.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> REDEX </font></font><br></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many believe that the getters and setters, as written in the documentation, inline in Proguard. But I would say that in 99% of cases a method that consists of a single function will not be inline. In Android 8.0, this was optimized, and there it is already invaded. It only remains to wait, when we all will be on it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another option is to use other than Proguard, a Facebook tool called </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redex</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It also uses bytecode optimizations, but in the same way it does not inline everything, and so does not inline getters and setters. It turns out that Jvm Fields is currently the only way to get away from the getter and setter for simple properties.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, other optimizations are included in Redex. </font><font style="vertical-align: inherit;">In particular, I created a primitive application where I did not write any code at all, I added Proguard for it, which cut out everything that was possible. </font><font style="vertical-align: inherit;">After that, I rotated this application through Redex and received a minus 7% by weight of the APK. </font><font style="vertical-align: inherit;">I think this is good enough.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BENCHMARKS </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We turn to the benchmarks. </font><font style="vertical-align: inherit;">I took quite an interesting application, which has a lot of frames and a lot of animations to make it convenient to measure. </font><font style="vertical-align: inherit;">This application was written by </font></font><a href="https://github.com/Doctoror"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaroslav Mytkalyk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and I measured the benchmarks on four different phones. </font><font style="vertical-align: inherit;">Actually, I did dumpsys gfxinfo and collected data thousands of times, which I then reduced to the final value. </font><font style="vertical-align: inherit;">In my github profile</font></font><a href="https://github.com/smred"></a> <a href="https://github.com/smred"><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smred</font></font></strong></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can find the source and results.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, on a rather weak Huawei device.</font></font><br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The purple column shows the minimum variation of one frame. Green - maximum, always jumped on different calculations. The blue bar represents the median value, which was fairly stable, the error was of the order of 0.04 milliseconds. But, unfortunately, according to the schedule, the benchmark result is quite difficult to understand - everything is very close, so let's look at the time of drawing one frame in milliseconds.</font></font><br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we just switched to Kotlin, we got a little more time per frame. After all the optimizations have been made, the differences are almost within the margin of error. But for some reason it turned out that the median in optimized Kotlin is even greater than that of Java. But if you look at the average, then, of course, the results were always slightly better than in the just autogenerated Kotlin code. On the four devices, a similar circuit was obtained. </font></font><br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that the optimization I was talking about really helped and led to the fact that Kotlin offhand almost always works the same way as Java code. Yes, because of some features and differences, for example, in abstractions, there is a little extra workload, but if you want, you can always achieve almost identical speed of work.</font></font><br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, one more feature: for some reason, in these benchmarks, always for Kotlin the minimum time for drawing one frame was reduced, i.e. </font><font style="vertical-align: inherit;">it got even better. </font><font style="vertical-align: inherit;">On average, it was either a small increase, or exactly the same time. </font><font style="vertical-align: inherit;">Surprisingly, some Chinese phone with a small resolution gets a lot of time to draw one frame ‚Äî much less ‚Äî almost 2 times less than that of a cool Galaxy S6, with a very large screen resolution. </font></font><br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a benchmark on Google Pixel. </font><font style="vertical-align: inherit;">For him, the difference is very small, everything is within 0.1 millisecond.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FINDINGS </font></font><br></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To summarize, I would like to say that </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speed ‚Äã‚Äãis only important on the UI stream or custom view. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Very critical onmeasure-onlayout-ondraw. </font><font style="vertical-align: inherit;">Try to avoid all autoboxing, non null parameters, etc.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Almost always you can write code on Kotlin, which will work with identical Java speed, and in some places it may even turn out faster. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Premature optimization is evil. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything that I did could have spent a lot of time on you. </font><font style="vertical-align: inherit;">There are developers who believe that some modern tools, for example, Kotlin, are bad in terms of performance. </font><font style="vertical-align: inherit;">But I was able to provide evidence that Kotlin does not affect this in any way and can be used in production without any problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not waste time where you could not spend it.</font></font><br><br><blockquote>        brand new <a href="http://appsconf.ru/2018">AppsConf</a> ,        Android   . ,      . <a href="https://conf.ontico.ru/conference/join/ac2018.html"> </a> ,   8  9       . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/420143/">https://habr.com/ru/post/420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420129/index.html">Patterns corinne asyncio: outside of await</a></li>
<li><a href="../420131/index.html">Bitcoin Probabilistic Mining Method</a></li>
<li><a href="../420133/index.html">Modeling Dynamic Systems: How does the moon move?</a></li>
<li><a href="../420139/index.html">The book "Site Reliability Engineering. Reliability and reliability as in Google "</a></li>
<li><a href="../420141/index.html">From loaded MPP, the DBMS is a vigorous Data Lake with analytical tools: sharing the creation details</a></li>
<li><a href="../420145/index.html">How is the working day of the members of the PC AppsConf</a></li>
<li><a href="../420147/index.html">OpenSource at Clojure</a></li>
<li><a href="../420151/index.html">Easier than it seems. Chapter 12</a></li>
<li><a href="../420153/index.html">3D printing of complex parts made of ABS and PLA plastics with a lot of support</a></li>
<li><a href="../420157/index.html">SJ-meetup "Functional modeling with the use of options"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>