<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exploring the format of the level map of the Jackal NES game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article will describe a non-standard way to search for data about levels in NES games ‚Äî by sequentially changing all the data in an image and exam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exploring the format of the level map of the Jackal NES game</h1><div class="post__text post__text-html js-mediator-article">  The article will describe a non-standard way to search for data about levels in NES games ‚Äî by sequentially changing all the data in an image and examining the consequences (‚Äúcorrelation‚Äù in terms of romhackers).  For example, I will show you how to find the level data in the game <b>Jackal</b> for NES and add one of its levels to the <b>CadEditor</b> editor.  This method allows you to explore any game with a <a href="http://habrahabr.ru/post/259171/">block level structure</a> (almost any game on NES), without knowledge of the X8502 assembler, only initial skills of working with scripting languages ‚Äã‚Äã( <b>Lua</b> and <b>Python</b> ) are required. <br><a name="habracut"></a><br><h2>  Theory </h2><br>  The idea of ‚Äã‚Äãthe method is to alternately change all the bytes in the game one by one and see if any of them change the level has changed.  Hands to do this for a very long time, so you need to use auxiliary tools, namely, the <b>Lua</b> scripting language built into the <b>FCEUX</b> emulator, its capabilities and limitations will be discussed below. <br><br>  In addition, some difficulty is the process of checking the result - a modified ROM image must be loaded into the emulator, and then the game should be completed before the first level is launched.  Moreover, it is impossible to simply load the already saved emulator made on the original image at the moment after the start of the level - the data from the image will already get into the video memory and RAM, and the first level screen will remain unchanged, it will be impossible to visually distinguish it from the original.  Therefore, it is necessary either to record in the FCEUX emulator the repetition of all keystrokes that causes the game from the start screen to start the level (this is done using the <i><b>File-&gt; Movie-&gt; Record Movie ...</b></i> menu), or it is simpler to do - to save directly to level loading moment.  After clicking the <i>"Start"</i> button in the main menu of the game, before the start of a level, the image on the screen is dimmed for a few moments, at which time the first game screen of the level is created. <br><br>  To save at the right time, you can slow down the time several times ( <i><b>NES-&gt; Emulation Speed-&gt; Speed ‚Äã‚ÄãDown</b></i> menu, I recommend <i><b>setting</b></i> up hotkeys in the <i><b>Config-&gt; Map Hotkeys</b></i> menu to conveniently speed up / slow down the game from the keyboard).  It is necessary to wait for the screen to black out and at this point (before the game screen appears) to save the game (say in slot 1, with the <i>Shift + F1</i> key combination).  Also, for further work, you need to detect which frame was saved and on which frame the game screen finally appeared (you can turn on the display of the current frame-frame on the screen using the menu item <i><b>Config-&gt; Display-&gt; Frame Counter</b></i> ).  This will be needed in order to take a screenshot of the level screen at the moment when it is already created, so as not to remove the black screen earlier. <br><img src="https://habrastorage.org/files/08f/e75/472/08fe754724b4402791576cbb904c8fed.png"><br>  In the screenshot, the level data is loaded from the image into memory at the moment between frames 454 and 560. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, the algorithm for searching data about levels will look like this: <br><ol><li>  Run the modified ROM in the emulator </li><li>  We load the saving prepared in advance on the original ROM image (at the time of loading the data from the image into the video memory in order to get the changed level on the screen). </li><li>  We are waiting for a measured number of frames (for this we marked the Frame Counter value at the moment when the image appears on the screen). </li><li>  Make a screenshot of the screen. </li><li>  Repeat the process for the next version of the modified ROM image. </li><li>  We analyze the screenshots made (in the name of the screenshot made, you must specify the address of the byte that was changed, so that it was clear what change led to the data on the screen changed). </li></ol><br>  In most cases, the image on the screen will not change, sometimes it will not exist at all, since in some versions of ROM images we will inevitably break the game code, sometimes there will be a strange porridge from tiles, the ultimate goal is to find the version in which the screen will be changed only one macroblock (recall again, the level screens in NES are <a href="http://habrahabr.ru/post/259171/">made up of macroblocks</a> ).  When such a screenshot is found, it will become clear to which address the array of block numbers describing the screens is stored. <br><br>  The Lua language built into the emulator <a href="http://www.fceux.com/web/help/fceux.html%3FLuaFunctionsList.html">allows you to</a> operate with processor memory and registers; however, it is designed to work with the already loaded ROM cartridge image, so there are no operations either to load modified versions of ROM images or to change the image itself after loading, but with the help of it implement steps 2,3,4 of the algorithm. <br><br>  The rest of the first version of the automatic corrapter I decided using the Python language.  However, in that version there were several serious flaws - several thousand ROM-generated images took up a lot of space, the emulator was constantly launched from the command line as a separate application and closed, which caused focus to switch to it, so working on a machine with a running script was inconvenient, as close it in the course of work.  Therefore, for the article I decided to add the necessary functionality to the Lua modules in order to change the byte within the ROM image directly from the emulator. <br><br><h2>  Making tools </h2><br>  Fortunately, the source code for the FCEUX emulator <a href="http://sourceforge.net/projects/fceultra/">is available</a> , so you can download the source code and add your own modifications. <br><br>  We find the function to read the byte from the ROM image (file <i>fceu.cpp</i> , function <i><b>FCEU_ReadRomByte</b></i> ) and add the same version for writing: <br><blockquote>  <font color="#666666">//new</font> <br>  <font color="#0000ff">void</font> FCEU_WriteRomByte <font color="#008000">(</font> <font color="#0000ff">uint32</font> i, <font color="#0000ff">uint8</font> value <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">if</font> <font color="#008000">(</font> i <font color="#000080">&lt;</font> <font color="#0000dd">16</font> <font color="#000040">+</font> PRGsize <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#008000">)</font> PRGptr <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#008000">[</font> i <font color="#000040">-</font> <font color="#0000dd">16</font> <font color="#008000">]</font> <font color="#000080">=</font> value <font color="#008080">;</font> <br>  <font color="#0000ff">else</font> <font color="#0000ff">if</font> <font color="#008000">(</font> i <font color="#000080">&lt;</font> <font color="#0000dd">16</font> <font color="#000040">+</font> PRGsize <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#000040">+</font> CHRsize <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#008000">)</font> CHRptr <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#008000">[</font> i <font color="#000040">-</font> <font color="#0000dd">16</font> <font color="#000040">-</font> PRGsize <font color="#008000">[</font> <font color="#0000dd">0</font> <font color="#008000">]</font> <font color="#008000">]</font> <font color="#000080">=</font> value <font color="#008080">;</font> <br>  <font color="#008000">}</font> </blockquote><br>  Next, we "forward" the ability to call this function from Lua (file <i>lua_engine.cpp</i> ): <br><blockquote>  <font color="#0000ff">static</font> <font color="#0000ff">int</font> rom_writebyte <font color="#008000">(</font> lua_State <font color="#000040">*</font> L <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  FCEU_WriteRomByte <font color="#008000">(</font> luaL_checkinteger <font color="#008000">(</font> L, <font color="#0000dd">1</font> <font color="#008000">)</font> , luaL_checkinteger <font color="#008000">(</font> L, <font color="#0000dd">2</font> <font color="#008000">)</font> <font color="#008000">)</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">1</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">static</font> <font color="#0000ff">const</font> <font color="#0000ff">struct</font> luaL_reg romlib <font color="#008000">[</font> <font color="#008000">]</font> <font color="#000080">=</font> <font color="#008000">{</font> <br>  <font color="#008000">{</font> <font color="#FF0000">"readbyte"</font> , rom_readbyte <font color="#008000">}</font> , <br>  <font color="#008000">{</font> <font color="#FF0000">"readbytesigned"</font> , rom_readbytesigned <font color="#008000">}</font> , <br>  <font color="#666666">// alternate naming scheme for unsigned</font> <br>  <font color="#008000">{</font> <font color="#FF0000">"readbyteunsigned"</font> , rom_readbyte <font color="#008000">}</font> , <br>  <font color="#008000">{</font> <font color="#FF0000">"writebyte"</font> , rom_writebyte <font color="#008000">}</font> , <font color="#666666">// new function</font> <br>  <font color="#008000">{</font> <font color="#FF0000">"gethash"</font> , rom_gethash <font color="#008000">}</font> , <br>  <font color="#008000">{</font> <font color="#0000ff">NULL</font> , <font color="#0000ff">NULL</font> <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> </blockquote><br>  Thus, we were able to change the data bytes from the scripts and got rid of the need to create and load thousands of different versions of ROM images. <br><br>  The next stage is to teach Lua to analyze screenshots before saving them.  To do this, instead of saving the standard screenshot to the file, the <i>gui.savescreenshot ()</i> function <i>will</i> leave it in memory using the <i>gui.gdscreenshot ()</i> function, and then check whether the same screenshot has already been taken (for this you have to store the hashes of all the screenshots already taken ), and save to disk only unique ones.  This will allow not to store thousands of identical screenshots, in which a change in one byte did not affect the first screen of the game. <br>  To save the screenshots, I used the <b>gd</b> library (the compiled version can be taken <a href="http://sourceforge.net/projects/lua-gd/files/lua-gd/lua-gd-2.0.33r2%2520%2528for%2520Lua%25205.1%2529/">here</a> or compiled from the source itself), the unpacked files should be put in the folder with the compiled emulator.  To calculate the hashes, I used a little trick - I threw the calculation function from the emulator itself (there it was used to calculate the checksums of ROM images): <br><blockquote>  <font color="#666666">// file lua_engine.cpp</font> <br>  <font color="#0000ff">static</font> <font color="#0000ff">int</font> calchash <font color="#008000">(</font> lua_State <font color="#000040">*</font> L <font color="#008000">)</font> <font color="#008000">{</font> <br>  <font color="#0000ff">const</font> <font color="#0000ff">char</font> <font color="#000040">*</font> buffer <font color="#000080">=</font> luaL_checkstring <font color="#008000">(</font> L, <font color="#0000dd">1</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">int</font> size <font color="#000080">=</font> luaL_checkinteger <font color="#008000">(</font> L, <font color="#0000dd">2</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">int</font> hash <font color="#000080">=</font> CalcCRC32 <font color="#008000">(</font> <font color="#0000dd">0</font> , <font color="#008000">(</font> <font color="#0000ff">uint8</font> <font color="#000040">*</font> <font color="#008000">)</font> buffer, size <font color="#008000">)</font> <font color="#008080">;</font> <br>  lua_pushinteger <font color="#008000">(</font> L, hash <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">1</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">static</font> <font color="#0000ff">const</font> <font color="#0000ff">struct</font> luaL_reg emulib <font color="#008000">[</font> <font color="#008000">]</font> <font color="#000080">=</font> <font color="#008000">{</font> <br>  <font color="#666666">// part of the code is missing</font> <br>  <font color="#666666">// ...</font> <br>  <font color="#008000">{</font> <font color="#FF0000">"readonly"</font> , movie_getreadonly <font color="#008000">}</font> , <br>  <font color="#008000">{</font> <font color="#FF0000">"setreadonly"</font> , movie_setreadonly <font color="#008000">}</font> , <br>  <font color="#008000">{</font> <font color="#FF0000">"print"</font> , print <font color="#008000">}</font> , <font color="#666666">// sure, why not</font> <br>  <font color="#008000">{</font> <font color="#FF0000">"calchash"</font> , calchash <font color="#008000">}</font> , <br>  <font color="#008000">{</font> <font color="#0000ff">NULL</font> , <font color="#0000ff">NULL</font> <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> </blockquote><br><h2>  Corrupt script and its use </h2><br>  Now, the preparatory work is finally finished and you can write a Lua-script for the image corrupt (if the comments at the end of the lines are not displayed completely, you can view the commented scripts on the githabe, the link at the end of the article): <br><br><blockquote> <font color="#808080">- we load library gd</font> <br>  <font color="#0000aa">require</font> <font color="#ff6666">"gd"</font> <br><br>  <font color="#808080">- the initial address for the corrupt (immediately from the header of the ROM image)</font> <br>  START_ADDR <font color="#66cc66">=</font> <font color="#cc66cc">0x10</font> <br>  <font color="#808080">- the end address for the corrupt (depends on the mapper on which the cartridge is made, you can simply set the file size)</font> <br>  END_ADDR <font color="#66cc66">=</font> <font color="#cc66cc">0x20010</font> <br>  CUR_ADDR <font color="#66cc66">=</font> START_ADDR <br>  <font color="#808080">- end frame number, after which you need to take a screenshot (when the game screen is already displayed for the player, the number is measured for the created save)</font> <br>  FRAME_FOR_SCREEN <font color="#66cc66">=</font> <font color="#cc66cc">7035</font> <br>  <font color="#808080">- test value that will be written instead of game byte</font> <br>  WRITE_VALUE <font color="#66cc66">=</font> <font color="#cc66cc">0x33</font> <br>  <font color="#808080">--Step, which will be used to make a corrupt, to save search time</font> <br>  <font color="#808080">- (it is not necessary to change each byte on the screen, a large number of macroblocks can be displayed on the screen, it is enough to detect at least one of them).</font> <br>  STEP <font color="#66cc66">=</font> <font color="#cc66cc">8</font> <br><br>  <font color="#808080">- table for saving hashes of all unique screenshots</font> <br>  shas <font color="#66cc66">=</font> <font color="#66cc66">{</font> <font color="#66cc66">}</font> <br><br>  <font color="#808080">- remember the value that will be corrupted by the corrupt, in order to restore it later</font> <br>  lastValue <font color="#66cc66">=</font> rom <font color="#66cc66">.</font>  readbyte <font color="#66cc66">(</font> START_ADDR <font color="#66cc66">)</font> <br>  <font color="#808080">- load the previously prepared saving from the FIRST slot (the numbering of slots in the emulator starts from 0, and in Lua - from 1).</font> <br>  s <font color="#66cc66">=</font> savestate <font color="#66cc66">.</font>  create <font color="#66cc66">(</font> <font color="#cc66cc">2</font> <font color="#66cc66">)</font> <br>  savestate <font color="#66cc66">.</font>  load <font color="#66cc66">(</font> s <font color="#66cc66">)</font> <br><br>  <font color="#aa9900">while</font> <font color="#66cc66">(</font> <font color="#aa9900">true</font> <font color="#66cc66">)</font> <font color="#aa9900">do</font> <br>  <font color="#808080">--If the screen has loaded and is already displayed</font> <br>  <font color="#aa9900">if</font> <font color="#66cc66">(</font> emu <font color="#66cc66">.</font> framecount <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">&gt;</font> FRAME_FOR_SCREEN <font color="#66cc66">)</font> <font color="#aa9900">then</font> <br>  <font color="#808080">--save screenshot in memory</font> <br>  <font color="#aa9900">local</font> gdStr <font color="#66cc66">=</font> gui <font color="#66cc66">.</font>  gdscreenshot <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#808080">- count it hash</font> <br>  <font color="#aa9900">local</font> hash <font color="#66cc66">=</font> emu <font color="#66cc66">.</font>  calchash <font color="#66cc66">(</font> gdStr <font color="#66cc66">,</font> <font color="#0000aa">string.len</font> <font color="#66cc66">(</font> gdStr <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#808080">--If there was no such screenshot</font> <br>  <font color="#aa9900">if</font> <font color="#66cc66">(</font> <font color="#aa9900">not</font> shas <font color="#66cc66">[</font> hash <font color="#66cc66">]</font> <font color="#66cc66">)</font> <font color="#aa9900">then</font> <br>  <font color="#0000aa">print</font> <font color="#66cc66">(</font> <font color="#ff6666">"Found new screen"</font> <font color="#66cc66">..</font> <font color="#0000aa">tostring</font> <font color="#66cc66">(</font> hash <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#aa9900">local</font> fname <font color="#66cc66">=</font> <font color="#0000aa">string.format</font> <font color="#66cc66">(</font> <font color="#ff6666">"% 05X"</font> <font color="#66cc66">,</font> CUR_ADDR <font color="#66cc66">)</font> <font color="#66cc66">..</font> <font color="#ff6666">".png"</font> <font color="#66cc66">;</font> <br>  <font color="#aa9900">local</font> gdImg <font color="#66cc66">=</font> gd <font color="#66cc66">.</font>  createFromGdStr <font color="#66cc66">(</font> gdStr <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#808080">- save a screenshot to a disk with the specified byte address in the name</font> <br>  gdImg <font color="#66cc66">:</font> png <font color="#66cc66">(</font> fname <font color="#66cc66">)</font> <br>  shas <font color="#66cc66">[</font> hash <font color="#66cc66">]</font> <font color="#66cc66">=</font> <font color="#aa9900">true</font> <font color="#66cc66">;</font> <br>  <font color="#aa9900">end</font> <font color="#66cc66">;</font> <br>  <font color="#808080">- restore previous byte value</font> <br>  rom <font color="#66cc66">.</font>  writebyte <font color="#66cc66">(</font> CUR_ADDR <font color="#66cc66">,</font> lastValue <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  CUR_ADDR <font color="#66cc66">=</font> CUR_ADDR <font color="#66cc66">+</font> STEP <font color="#66cc66">;</font> <br>  <font color="#808080">- Correspondent next byte</font> <br>  lastValue <font color="#66cc66">=</font> rom <font color="#66cc66">.</font>  readbyte <font color="#66cc66">(</font> CUR_ADDR <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  rom <font color="#66cc66">.</font>  writebyte <font color="#66cc66">(</font> CUR_ADDR <font color="#66cc66">,</font> WRITE_VALUE <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#808080">- loading save again to allow the game to load data from the new image into the memory</font> <br>  s <font color="#66cc66">=</font> savestate <font color="#66cc66">.</font>  create <font color="#66cc66">(</font> <font color="#cc66cc">2</font> <font color="#66cc66">)</font> <br>  <font color="#808080">- display of progress</font> <br>  savestate <font color="#66cc66">.</font>  load <font color="#66cc66">(</font> s <font color="#66cc66">)</font> <br>  gui <font color="#66cc66">.</font>  text <font color="#66cc66">(</font> <font color="#cc66cc">20</font> <font color="#66cc66">,</font> <font color="#cc66cc">20</font> <font color="#66cc66">,</font> <font color="#0000aa">string.format</font> <font color="#66cc66">(</font> <font color="#ff6666">"% 05X"</font> <font color="#66cc66">,</font> CUR_ADDR <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#808080">--When all addresses are processed, stop the emulator.</font> <br>  <font color="#aa9900">if</font> <font color="#66cc66">(</font> CUR_ADDR <font color="#66cc66">&gt;</font> END_ADDR <font color="#66cc66">)</font> <font color="#aa9900">then</font> <br>  emu <font color="#66cc66">.</font>  pause <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#aa9900">end</font> <br>  <font color="#aa9900">end</font> <font color="#66cc66">;</font> <br>  <font color="#808080">- flush the emulation to the next frame</font> <br>  emu <font color="#66cc66">.</font>  frameadvance <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">;</font> <br>  <font color="#aa9900">end</font> <font color="#66cc66">;</font> </blockquote><br>  To run the emulator with a script, you can use the batch file with the following content: <br>  <b>fceux -turbo 1 -lua corrupt.lua "Jackal (U) [!]. nes"</b> <br>  (The <i>turbo</i> key will allow the emulator to run as fast as possible). <br><br>  The script on my machine processes all data in 8 minutes.  If it works too long, you can increase the <i>STEP</i> step to a larger one, up to 64 per screen, and also make a more accurate save of the game, in which the time between the launch frame and the frame on which you need to take a screenshot will be minimal. <br>  A few recommendations for setting up a script for different games: data on screens often start from the beginning of banks (at addresses that are multiples of <b>0x2000</b> or <b>0x4000</b> ), these zones can be explored in more detail;  If there are video banks ( <b><i>CHR-ROM</i></b> ) in the ROM image, you can not explore them, since they store only video memory.  Video banks are always at the end of the ROM image, their number can also be viewed in the header (the first 16 bytes of the ROM image). <br><br>  For the game ‚ÄúJackal‚Äù, the script finds 235 unique screenshots, which present a wide range of various graphic glitches.  However, of interest are screenshots made from images with modified bytes at addresses <b>0x1058, 0x105D8, 0x105E8</b> : <br><img src="https://habrastorage.org/files/c4e/9e5/a65/c4e9e5a65f3240a29b8c3643ea422018.png"><br>  It is clear from them that: <br><ul><li>  The game uses a macroblock system of 2x2 blocks (4x4 tiles). </li><li>  Screens are described by lines of 16 macroblocks wide (the difference between two adjacent addresses). </li><li>  The lines are stored in the ROM image in order from bottom to top. </li></ul><br><br>  What can be done with the data obtained?  For example, prepare pictures of all level macroblocks that use them in the block editor <a href="https://github.com/spiiin/CadEditor/">CadEditor</a> to create a level map editor. <br><br>  To do this, we need to slightly rewrite the script of the corrush so that it records all possible byte values ‚Äã‚Äãat the address that causes the block to change on the screen (for example, <b>0x105C8</b> ) and take screenshots of all the blocks.  I will not give the full text of the script, it is in the example archive at the end of the article ( <b><i>corrupt_byte.lu</i> a</b> ).  Unfortunately, the <b>gd</b> library is not designed for convenient processing of parts of images, so to ‚Äúbite out‚Äù the macroblock image from the screenshot and combine them for convenience into one long ‚Äútape‚Äù I had to write another Python script (with the <a href="http://www.pythonware.com/products/pil/">PIL</a> library installed for image processing): <br><blockquote>  <font color="#808080"># - * - coding: utf-8 - * -</font> <br>  <font color="#ff7700">import</font> Image <br>  <font color="#ff7700">def</font> cutBlock <font>(</font> pp <font>)</font> : <br>  im <font color="#66cc66">=</font> Image.  <font color="#008000">open</font> <font>(</font> pp <font>)</font> <br>  <font color="#808080"># upload a screenshot to any graphics editor to view the coordinates of the beginning of the block</font> <br>  X <font color="#66cc66">=</font> <font color="#ff4500">96</font> <br>  Y <font color="#66cc66">=</font> <font color="#ff4500">96</font> <br>  <font color="#808080"># cut from the screenshot block given coordinates</font> <br>  imCut <font color="#66cc66">=</font> im.  <font>crop</font> <font>(</font> <font>(</font> X <font color="#66cc66">,</font> Y <font color="#66cc66">,</font> X + <font color="#ff4500">32</font> <font color="#66cc66">,</font> Y + <font color="#ff4500">32</font> <font>)</font> <font>)</font> <br>  imCut.  <font>save</font> <font>(</font> <font color="#483d8b">"_"</font> + pp <font>)</font> <br><br>  <font color="#ff7700">for</font> x <font color="#ff7700">in</font> <font color="#008000">xrange</font> <font>(</font> <font color="#ff4500">256</font> <font>)</font> : <br>  cutBlock <font>(</font> r <font color="#483d8b">"% 03d.png"</font> % x <font>)</font> <br><br>  BLOCK_COUNT <font color="#66cc66">=</font> <font color="#ff4500">102</font> <br>  MAX_BLOCK_COUNT <font color="#66cc66">=</font> <font color="#ff4500">256</font> <br>  imBig <font color="#66cc66">=</font> Image.  <font color="#dc143c">new</font> <font>(</font> <font color="#483d8b">"RGB"</font> <font color="#66cc66">,</font> <font>(</font> <font color="#ff4500">32</font> * MAX_BLOCK_COUNT <font color="#66cc66">,</font> <font color="#ff4500">32</font> <font>)</font> <font>)</font> <br>  <font color="#ff7700">for</font> x <font color="#ff7700">in</font> <font color="#008000">xrange</font> <font>(</font> BLOCK_COUNT <font>)</font> : <br>  im <font color="#66cc66">=</font> Image.  <font color="#008000">open</font> <font>(</font> <font color="#483d8b">"_% 03d.png"</font> % x <font>)</font> <br>  imBig.  <font>paste</font> <font>(</font> im <font color="#66cc66">,</font> <font>(</font> <font color="#ff4500">32</font> * x <font color="#66cc66">,</font> <font color="#ff4500">0</font> <font color="#66cc66">,</font> <font color="#ff4500">32</font> * x + <font color="#ff4500">32</font> <font color="#66cc66">,</font> <font color="#ff4500">32</font> <font>)</font> <font>)</font> <br>  <font color="#808080"># increase macroblock size to 64x64, requirement for use with CadEditor</font> <br>  imBig64 <font color="#66cc66">=</font> imBig.  <font>resize</font> <font>(</font> <font>(</font> MAX_BLOCK_COUNT * <font color="#ff4500">64</font> <font color="#66cc66">,</font> <font color="#ff4500">64</font> <font>)</font> <font>)</font> <br>  imBig64.  <font>save</font> <font>(</font> <font color="#483d8b">"outStrip.png"</font> <font>)</font> </blockquote><br><h2>  Adding a game to the level editor </h2><br>  The last part remains - it is necessary to create a configuration file for the <b>CadEditor</b> editor, which would use the resulting image.  It uses C # as the scripting language (using the <a href="http://www.csscript.net/">CSScript</a> library). <br>  From the screenshots, we calculate the beginning of the line in the macroblock map - if the address <b>0x105C8</b> changes the 4th macroblock in the line, then the address <b>0x105C5</b> is responsible for the first <b>one</b> .  Next, create a template config: <br><blockquote>  <font color="#0600FF">using</font> <font color="#008080">CadEditor</font> <font color="#008000">;</font> <br>  <font color="#0600FF">using</font> <font color="#008080">System</font> <font color="#008000">;</font> <br>  <font color="#0600FF">using</font> <font color="#008080">System.Collections.Generic</font> <font color="#008000">;</font> <br>  <font color="#0600FF">using</font> <font color="#008080">System.Drawing</font> <font color="#008000">;</font> <br><br>  <font color="#0600FF">public</font> <font color="#6666cc">class</font> Data <br>  <font color="#008000">{</font> <br>  <font color="#008080">/ * calculate the correct address by alternately moving the boundaries of the lines up and down until</font> <font color="#008080"><br></font>  <font color="#008080">until the correct level map appears in the ‚Äúwindow‚Äù.</font> <font color="#008080"><br></font>  <font color="#008080">From the starting address 0x10625 we fall back 96 lines up.</font> <font color="#008080"><br></font>  <font color="#008080">1 - the number of game screens at the level</font> <font color="#008080"><br></font>  <font color="#008080">16 * 96 - the size in bytes of one game screen</font> <font color="#008080"><br></font>  <font color="#008080">* /</font> <br>  <font color="#0600FF">public</font> OffsetRec getScreensOffset <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#008000">new</font> OffsetRec <font color="#008000">(</font> 0x10625 <font color="#008000">-</font> <font color="#FF0000">16</font> <font color="#008000">*</font> <font color="#FF0000">96</font> , <font color="#FF0000">1</font> , <font color="#FF0000">16</font> <font color="#008000">*</font> <font color="#FF0000">96</font> <font color="#008000">)</font> <font color="#008000">;</font>  <font color="#008000">}</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">int</font> getScreenWidth <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#FF0000">16</font> <font color="#008000">;</font>  <font color="#008000">}</font> <font color="#008080">// set the screen width</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">int</font> getScreenHeight <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#FF0000">96</font> <font color="#008000">;</font>  <font color="#008000">}</font> <font color="#008080">// set the screen height</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">int</font> getBigBlocksCount <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#FF0000">256</font> <font color="#008000">;</font>  <font color="#008000">}</font> <br>  <font color="#008080">// connect a strip with pictures of macroblocks</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">string</font> getBlocksFilename <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#666666">"jackal_1.png"</font> <font color="#008000">;</font>  <font color="#008000">}</font> <br><br>  <font color="#008080">// turn off the macroblock sub-editors and enemies that are not implemented for this game</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">bool</font> isBigBlockEditorEnabled <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#0600FF">false</font> <font color="#008000">;</font>  <font color="#008000">}</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">bool</font> isBlockEditorEnabled <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#0600FF">false</font> <font color="#008000">;</font>  <font color="#008000">}</font> <br>  <font color="#0600FF">public</font> <font color="#6666cc">bool</font> isEnemyEditorEnabled <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> <font color="#0600FF">false</font> <font color="#008000">;</font>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> </blockquote><br>  The level map loaded into the editor with this config looks strange, although it resembles the real one: <br><img src="https://habrastorage.org/files/3e3/a0c/1e3/3e3a0c1e3e104c53bfcdf1a4616a8874.png"><br><br>  After studying the result, it turns out that the lines of the screen of 16x8 macroblocks are stored in the order from bottom to top, but the screens themselves are from top to bottom, because of which it turns out that every 8 lines of the screen are swapped.  Fortunately, the editor has a large number of methods that allow you to specify how exactly the level will be loaded from the ROM image.  In this case, you need to set two special functions that will control exactly how the macroblock number will be read from the card and, accordingly, how it will be written back by the editor. <br><blockquote>  <font color="#008080">// Telling the editor to use a special function to get the macroblock number from</font> <br>  <font color="#008080">// maps and records back</font> <br>  <font color="#0600FF">public</font> GetBigTileNoFromScreenFunc getBigTileNoFromScreenFunc <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> getBigTileNoFromScreen <font color="#008000">;</font>  <font color="#008000">}</font> <br>  <font color="#0600FF">public</font> SetBigTileToScreenFunc setBigTileToScreenFunc <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <font color="#0600FF">return</font> setBigTileToScreen <font color="#008000">;</font>  <font color="#008000">}</font> <br><br>  <font color="#0600FF">public</font> <font color="#6666cc">int</font> getBigTileNoFromScreen <font color="#008000">(</font> <font color="#6666cc">int</font> <font color="#008000">[</font> <font color="#008000">]</font> screenData, <font color="#6666cc">int</font> index <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#6666cc">int</font> w <font color="#008000">=</font> getScreenWidth <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">;</font> <br>  <font color="#6666cc">int</font> noY <font color="#008000">=</font> index <font color="#008000">/</font> w <font color="#008000">;</font> <br>  noY <font color="#008000">=</font> <font color="#008000">(</font> noY <font color="#008000">/</font> <font color="#FF0000">8</font> <font color="#008000">)</font> <font color="#008000">*</font> <font color="#FF0000">8</font> <font color="#008000">+</font> <font color="#FF0000">7</font> <font color="#008000">-</font> <font color="#008000">(</font> noY <font color="#008000">%</font> 8 <font color="#008000">)</font> <font color="#008000">;</font>  <font color="#008080">// transformation of the Y-coordinate of the macroblock</font> <br>  <font color="#6666cc">int</font> noX <font color="#008000">=</font> index <font color="#008000">%</font> w <font color="#008000">;</font> <br>  <font color="#0600FF">return</font> screenData <font color="#008000">[</font> noY <font color="#008000">*</font> w <font color="#008000">+</font> noX <font color="#008000">]</font> <font color="#008000">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0600FF">public</font> <font color="#6666cc">void</font> setBigTileToScreen <font color="#008000">(</font> <font color="#6666cc">int</font> <font color="#008000">[</font> <font color="#008000">]</font> screenData, <font color="#6666cc">int</font> index, <font color="#6666cc">int</font> <font color="#0600FF">value</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#6666cc">int</font> w <font color="#008000">=</font> getScreenWidth <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">;</font> <br>  <font color="#6666cc">int</font> noY <font color="#008000">=</font> index <font color="#008000">/</font> w <font color="#008000">;</font> <br>  noY <font color="#008000">=</font> <font color="#008000">(</font> noY <font color="#008000">/</font> <font color="#FF0000">8</font> <font color="#008000">)</font> <font color="#008000">*</font> <font color="#FF0000">8</font> <font color="#008000">+</font> <font color="#FF0000">7</font> <font color="#008000">-</font> <font color="#008000">(</font> noY <font color="#008000">%</font> 8 <font color="#008000">)</font> <font color="#008000">;</font>  <font color="#008080">// transformation of the Y-coordinate of the macroblock</font> <br>  <font color="#6666cc">int</font> noX <font color="#008000">=</font> index <font color="#008000">%</font> w <font color="#008000">;</font> <br>  screenData <font color="#008000">[</font> noY <font color="#008000">*</font> w <font color="#008000">+</font> noX <font color="#008000">]</font> <font color="#008000">=</font> <font color="#0600FF">value</font> <font color="#008000">;</font> <br>  <font color="#008000">}</font> </blockquote><br>  Everything, now the map is displayed correctly and you can redraw the level geometry: <br><img src="https://habrastorage.org/files/691/c12/106/691c12106a41439f8f5f650f434be396.png"><br><br>  The search method is applicable to almost all NES-games, you can use the scripts from the archive with an example to explore your favorite games! <br><br>  In addition, with some modifications, the method is also applicable for the Sega Mega Drive and SNES platforms (the difference is that it is not the ROM image that needs to be modified, but the memory of the device, often the unpacked level map is stored in it). <br><br>  In the next article I will show, using an example of some game, a device of game logic and methods of searching for game objects, in order to display and arrange them on the map. <br><br>  References: <br>  <a href="">Archive with an example</a> <br>  <a href="https://gist.github.com/spiiin/a5ec2c7c9e5b6ba59039">Commented scripts</a> </div><p>Source: <a href="https://habr.com/ru/post/259483/">https://habr.com/ru/post/259483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259471/index.html">API Jellyfish: write full text RSS</a></li>
<li><a href="../259473/index.html">Compass with PWM on the stm32f3discovery debug board</a></li>
<li><a href="../259475/index.html">Another language recognizer 4</a></li>
<li><a href="../259477/index.html">That the new versions of the UEFI standards are prepared for us, part two, ACPI 6.0</a></li>
<li><a href="../259479/index.html">Configure OpenSWAN IPsec PSK using NAT Traversal (NAT-T)</a></li>
<li><a href="../259489/index.html">Experiment: Testing Live ReactOS Applications</a></li>
<li><a href="../259491/index.html">Motion sensor for switching radio stations - part II</a></li>
<li><a href="../259493/index.html">Monitoring Server with Wiren Board NetMon-1</a></li>
<li><a href="../259495/index.html">HiDPI in Linux</a></li>
<li><a href="../259497/index.html">Type casting in PHP == stool with two legs?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>