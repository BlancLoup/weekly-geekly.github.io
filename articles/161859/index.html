<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inferno Shell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FAQ: What is OS Inferno and why is it needed? 

 Inferno OS shell for many years has caused me exclusively negative emotions. And I never understood t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inferno Shell</h1><div class="post__text post__text-html js-mediator-article"> <b>FAQ:</b> <a href="http://habrahabr.ru/post/145993/">What is OS Inferno and why is it needed?</a> <br><br>  Inferno OS shell for many years has caused me exclusively negative emotions.  And I never understood that in <a href="http://debu.gs/entries/inferno-part-1-shell">Inferno sh causes delight</a> in some people.  But, as they say, it's better late than never - today I decided to thoroughly deal with the shell, and as a result, I also got through - this is really a unique thing!  Incredibly elegant and simple. <br><a name="habracut"></a><br>  I will begin all the same with shortcomings, for greater objectivity.  The main one is the shell is very slow.  It is not known why, but all the inferno shells (there are actually several of them, but now we are talking about <code>/dis/sh.dis</code> ) are very slow.  This is extremely strange, because  usually the speed of applications written in Limbo (in JIT mode) is between the speed of C and fast scripting languages ‚Äã‚Äãlike Perl.  Therefore, full-fledged applications on <code>sh</code> will not work.  But, nevertheless, for every sneeze, uncovering Limbo is also inconvenient, so all sorts of starting scripts and other small things anyway have to be written on <code>sh</code> .  The second serious drawback - the inconvenience of using the text console, the lack of command history, autocompletion, easy editing when entering is very annoying (but I was just told about the <a href="http://utopia.knoware.nl/~hlub/uck/rlwrap/">rlwrap</a> utility, running emu through <code>rlwrap -a</code> seems to solve this problem).  The third - the syntax of this shell is unusual using unmatched quotes, which, when trying to highlight the syntax of its scripts using the highlight for absolutely any other shell (due to the lack of a ready highlight for infernovskogo) leads to a complete nightmare.  I was going to solve this problem today by implementing syntax highlighting for vim, for which I sat down to deal with the shell ... and as a result, instead of syntax highlighting, I could not resist and write this article.  :) <br><br><h4>  Content </h4><br><ul><li>  <a href="https://habr.com/ru/post/161859/">From what, from what, from what are our scripts made?</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Running applications</a> <br><ul><li>  <a href="https://habr.com/ru/post/161859/">Additional command I / O redirects</a> </li><li>  <a href="https://habr.com/ru/post/161859/">$ status</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/161859/">Lines, lists of lines, blocks of commands</a> <br><ul><li>  <a href="https://habr.com/ru/post/161859/">Line</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Block of commands</a> </li><li>  <a href="https://habr.com/ru/post/161859/">List of strings</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/161859/">Environment variables</a> <br><ul><li>  <a href="https://habr.com/ru/post/161859/">/ env</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Lists</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Scopes</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Variable references</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/161859/">Intercepted command output</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Embedded commands</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Add if, for, functions</a> <br><ul><li>  <a href="https://habr.com/ru/post/161859/">We do our ‚Äúfunctions‚Äù</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Make your for</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/161859/">Interesting stuff</a> </li><li>  <a href="https://habr.com/ru/post/161859/">Summary</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="whatinside"></a><h4>  From what, from what, from what are our scripts made? </h4><br>  The functionality supported by <code>/dis/sh.dis</code> out of the box is impressive!  There is not even conditional operators and cycles!  No features.  And then what is there, and how can one exist under these conditions?  Now see.  So what is: <br><ul><li>  running applications (including pipelines and I / O redirection) </li><li>  lines, lists of lines, blocks of commands </li><li>  environment variables </li><li>  file name patterns (*,?, [...]) </li><li>  and some built-in commands and string commands </li></ul>  Probably, having seen the last item you thought ‚ÄúAha!  Any special commands.  Surely everything else they do, everything is trite. "... but no, you did not guess.  Of the built-in commands, three are usually used: <code>exit</code> , <code>run</code> and <code>load</code> ;  <code>unquote</code> used commands for working with strings are <code>quote</code> and <code>unquote</code> .  As for <code>run</code> , it simply executes the specified script in the current shell (analog <code>.</code> Or <code>source</code> in bash). <br><br>  But <code>load</code> - yes, this is a bomb!  It allows loading additional modules into the current shell that are written in Limbo and allow you to add absolutely any functionality to the shell - if, for, functions, exceptions, regular expressions, mathematical operations, etc.  etc.  There is also the <code>unload</code> command that allows you to <code>unload</code> these modules dynamically.  :) Nevertheless, even without loadable modules, the shell is absolutely complete and functional - which I will prove at the end of the article by implementing on ‚Äúbare sh‚Äù if and for! <br><br>  Oh, something else I forgot to mention.  (Do you think now it‚Äôs definitely ‚Äúaha!‚Äù? Nah.) He still supports the comments.  Beginning with <code>#</code> .  :) <br><br><a name="exec"></a><h4>  Running applications </h4><br>  Much identical to any * nix shell: <br><ul><li>  runs applications ( <code>.dis</code> files) and scripts (files in which the first line is <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a> <code>#!</code> ) </li><li>  teams are divided <code>;</code> </li><li>  running commands in the background via <code>&amp;</code> </li><li>  command pipelines through <code>|</code> </li><li>  redirect stdin / stdout via <code>&gt;</code> , <code>&gt;&gt;</code> and <code>&lt;</code> </li></ul><br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> one two | wc 1 2 8</code> </pre><br>  But there are differences. <br><br><a name="redir"></a><h5>  Additional command I / O redirects </h5><br><ul><li>  specifying a file descriptor (for redirecting stderr or opening additional descriptors plus 0, 1 and 2 available by default) <br><ul><li> <code>cmd &lt;stdin.txt &gt;stdout.txt &gt;[2]stderr.txt</code> </li> <li>  <code>cmd &gt;[1=2]</code> (redirect stdin to stderr) </li><li>  <code>cmd &lt;[3]file.txt</code> (command runs with additional file descriptor 3 open for reading from file) </li><li>  <code>cmda |[2] cmdb</code> (instead of stdout of the first command, stderr is sent to the input of the pipeline, and stdout is displayed simply on the screen) </li><li>  <code>cmda |[1=2] cmdb</code> (stderr is sent to the pipeline again, not stdout cmda, but it connects not to stdin, but to stdout cmdb - which is opened for reading, not a record, of course) </li></ul><br></li><li>  opening simultaneously reading and writing <br><ul><li>  <code>cmd &lt;&gt;in_pipe &lt;&gt;[1]out_pipe</code> (stdin and stdout are open for reading and writing to different files at the same time) </li></ul><br></li><li>  nonlinear conveyors <br><ul><li>  <code>cmd &lt;{;;} &gt;{;;}</code> (both command blocks run in parallel with cmd, while cmd takes two parameters ‚Äî filenames a la <code>/fd/</code> , which are connected via pipe to stdout first command block and stdin second command block) </li></ul><br></li></ul>  The last feature is especially interesting.  For example, the standard command for comparing two <code>cmp</code> files with its help can compare not the files, but the results of the work of two other commands: <code>cmp &lt;{ ls /dir1 } &lt;{ ls /dir2 }</code> . <br><br><a name="status"></a><h5>  $ status </h5><br>  Inferno, an unusual approach to the implementation of the exit code (exit status) of the application.  In traditional OS, any program ends with a number: 0 if everything is in order, and any other in case of an error.  In inferno, any program either just terminates (if everything is all right) or it generates an exception, the value of which is a string with the error text. <br><br>  An agreement has been adopted whereby this line should begin with ‚Äúfail:‚Äù if this is a regular error - i.e.  the application is not ‚Äúdropped‚Äù, but just wants to exit by returning this error to the one who launched this application (usually this is the shell).  If the error does not begin with ‚Äúfail:‚Äù, then after the application is completed, its process will remain in memory (in the ‚Äúbroken‚Äù state) so that it can be examined by debuggers and find out why this exception occurred (analogous to core dumps, only instead of saving they hang on the disk in memory). <br><br>  So, after the completion of the running command, its ‚Äúexit code‚Äù - i.e.  the text of the error-exception will be in the <code>$status</code> environment variable (the prefix ‚Äúfail:‚Äù will be automatically deleted from it, if the exception text except ‚Äúfail:‚Äù contained nothing more, then <code>$status</code> will contain the string ‚Äúfailed‚Äù). <br><br><a name="strlistblock"></a><h4>  Lines, lists of lines, blocks of commands </h4><br>  Infern shell operates <b>only</b> with strings and lists of strings. <br><br><a name="str"></a><h5>  Line </h5><br>  A string is either a word that does not contain spaces and some special characters, or any characters enclosed in single quotes.  The only ‚Äúescaped‚Äù character in such a string is the single quote itself, and it is written with two such quotes: <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'quote '</span></span><span class="hljs-string"><span class="hljs-string">' &lt;-- here'</span></span> quote <span class="hljs-string"><span class="hljs-string">' &lt;-- here</span></span></code> </pre><br>  No \ n, \ t, variable interpolations, etc.  in rows is not supported.  If you need to insert a newline character in the string, either simply insert it as is (by pressing Enter), or concatenate a string with a variable containing this character.  Inferno, there is a <a href="http://powerman.name/Inferno/man/1/unicode.html">unicode (1)</a> utility that can output any character by its code, which is done with its help (the construction <code>"{}</code> is described below, but for now consider it an analogue <code>``</code> bash-a): <br><pre> <code class="bash hljs">; cr=<span class="hljs-string"><span class="hljs-string">"{unicode -t 0D} ; lf="</span></span>{unicode -t 0A} ; tab=<span class="hljs-string"><span class="hljs-string">"{unicode -t 09} ; echo -n 'a'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cr</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lf</span></span></span><span class="hljs-string">'b'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$tab</span></span></span><span class="hljs-string">'c' | xd -1x 0000000 61 0d 0a 62 09 63 0000006</span></span></code> </pre><br>  Double quotes for strings are not used (by the way, <i>paired</i> double quotes in the Infern shell are not used for anything at all). <br><br><a name="block"></a><h5>  Block of commands </h5><br>  A block of commands is written inside curly brackets, and the whole block is processed by the shell as <b>one line</b> (including the characters of curly brackets). <br><pre> <code class="bash hljs">; { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> one; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> two } one two ; <span class="hljs-string"><span class="hljs-string">'{ echo one; echo two }'</span></span> one two</code> </pre><br>  The only difference from a string in single quotes is that <code>sh</code> checks the syntax of command blocks and reformats them into more compact strings. <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> { cmd | } sh: stdin: parse error: syntax error ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> { cmd | cmd } {cmd|cmd} ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> one <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> two } {<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> one;<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> two}</code> </pre><br><br><a name="list"></a><h5>  List of strings </h5><br>  Lists of lines is just zero and more lines separated by whitespace.  They can be enclosed in parentheses, but in most cases this is not necessary. <br><br>  Any shell command is <b>just a list of lines</b> , where the first line contains a command or a block of code, and the remaining lines are parameters for them. <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> one two three one two three ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> (one two) (three) one two three ; (<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> () (one (two three))) one two three ; ({<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Hello, <span class="hljs-variable"><span class="hljs-variable">$1</span></span>!} World) Hello, World!</code> </pre><br>  To concatenate lists of strings, use the <code>^</code> operator.  It can be applied to two lists containing either the same number of elements (then elements are concatenated in pairs), or one of the lists must contain only one element, then it will be concatenated with each element of the second list.  As a special case, if both lists contain only one element at a time, the usual concatenation of two strings is obtained. <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> (abc) ^ (1 2 3) a1 b2 c3 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> (ab) ^ 1 a1 b1 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 1 ^ (ab) 1a 1b ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> a ^ b ab</code> </pre><br>  Usually, one shell command must be written on one line - there are no special characters to mean ‚Äúcontinue the command on the next line‚Äù.  But it is very simple to split a command into several lines without opening the line and not closing the line (with a single quote) or a block of commands (curly bracket) or a list of lines (parentheses), or terminating the previous line with a concatenation operator. <br><br><a name="var"></a><h4>  Environment variables </h4><br>  Working with variables in the Infern shell looks deceptively similar to traditional shells, but do not be fooled by this! <br><pre> <code class="bash hljs">; a = <span class="hljs-string"><span class="hljs-string">'World'</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Hello, <span class="hljs-variable"><span class="hljs-variable">$a</span></span>! Hello, World!</code> </pre><br><br><a name="env"></a><h5>  / env </h5><br>  Environment variables in Inferno OS are implemented differently than in traditional OS.  Instead of introducing an additional POSIX API for working with environment variables and passing them to each process through a nightmare like <code>int execvpe(const char *file, char *const argv[], char *const envp[]);</code>  environment variables are just files in the <code>/env</code> directory.  This gives interesting possibilities, for example, an application can provide access to its environment variables by other applications over the network ‚Äî simply by exporting (via <a href="http://powerman.name/Inferno/man/1/listen.html">listen (1)</a> and <a href="http://powerman.name/Inferno/man/4/export.html">export (4)</a> ) your <code>/env</code> . <br><br>  You can create / delete / modify environment variables by creating, deleting and modifying files in <code>/env</code> .  But it should be borne in mind that the current sh keeps a copy of all environment variables in memory, so changes made through the files in <code>/env</code> will see the applications being launched, but not the current sh.  On the other hand, by changing the variables in the usual way for the shell (through the operator <code>=</code> ) you automatically update the files in <code>/env</code> . <br><br>  Shell variable names can contain any characters, including  those that are not valid for file names (for example, names <code>.</code> , <code>..</code> and containing <code>/</code> ).  Variables with such names will be available only in the current sh, and launched applications will not see them. <br><br><a name="varlist"></a><h5>  Lists </h5><br>  Another important difference is that all variables contain <b>only lists of strings</b> .  You cannot put a single line in a variable - it will always be a list of one line. <br><br>  Saving an empty list to a variable (explicitly by assigning <code>a=()</code> or implicitly through <code>a=</code> ) is the deletion of the variable. <br><ul><li>  <code>$var</code> is getting a list of strings from a var variable, and there may be zero, one, or several </li><li>  <code>$#var</code> is getting the number of elements in the <code>$var</code> string list </li><li>  <code>$"var</code> is the concatenation of all the elements of the list of strings from <code>$var</code> into one string (separated by a space) </li></ul><br><pre> <code class="bash hljs">; var = <span class="hljs-string"><span class="hljs-string">'first str'</span></span> second ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$var</span></span> first str second ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$#var</span></span> 2 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $<span class="hljs-string"><span class="hljs-string">"var first str second</span></span></code> </pre><br>  As you can see, the output of <code>$var</code> and <code>$"var</code> not visually different, because <code>echo</code> displays all its parameters separated by a space, and <code>$"</code> also unites all the elements of a variable through a space.  But the first <code>echo</code> command received two parameters, and the last one. <br><br>  Whenever you implicitly concatenate the value of a variable with something, the shell inserts the concatenation operator <code>^</code> (which, as you remember, works with lists of strings, not strings).  This is convenient, although unaccustomed to it may be unexpected: <br><pre> <code class="bash hljs">; flags = abc ; files = file1 file2 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -<span class="hljs-variable"><span class="hljs-variable">$flags</span></span> <span class="hljs-variable"><span class="hljs-variable">$files</span></span>.b -a -b -c file1.b file2.b ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -<span class="hljs-variable"><span class="hljs-variable">$flags</span></span> <span class="hljs-variable"><span class="hljs-variable">$files</span></span>.b } {<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -^<span class="hljs-variable"><span class="hljs-variable">$flags</span></span> <span class="hljs-variable"><span class="hljs-variable">$files</span></span>^.b}</code> </pre><br>  Assigning variables to the list also works.  If in the right part there is a list of more elements than variables in the left part - the last variable will receive the rest of the list, and in the previous variables there will be one element in each. <br><pre> <code class="bash hljs">; list = abcd ; (head tail) = <span class="hljs-variable"><span class="hljs-variable">$list</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$head</span></span> a ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$tail</span></span> bcd ; (xy) = (3 5) ; (xy) = (<span class="hljs-variable"><span class="hljs-variable">$y</span></span> <span class="hljs-variable"><span class="hljs-variable">$x</span></span>) ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'x='</span></span>^<span class="hljs-variable"><span class="hljs-variable">$x</span></span> <span class="hljs-string"><span class="hljs-string">'y='</span></span>^<span class="hljs-variable"><span class="hljs-variable">$y</span></span> x=5 y=3</code> </pre><br>  The list of all script parameters or any code block is in the <code>$*</code> variable, plus individual parameters are in the <code>$1</code> , <code>$2</code> , ... variables. <br><br><a name="scope"></a><h5>  Scopes </h5><br>  Each block of code forms its own scope.  Values ‚Äã‚Äãof variables can be assigned with the operators <code>=</code> and <code>:=</code> .  The first will change the value of an existing variable or create a new variable in the current scope.  The second one always creates a new variable, overlapping the old value of the variable with that name (if it existed) to the end of the current block. <br><pre> <code class="bash hljs">; a = 1 ; { a = 2 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$a</span></span> } 2 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$a</span></span> 2 ; { a := 3; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$a</span></span> } 3 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$a</span></span> 2 ; { b := 4; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$b</span></span> } 4 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> b is <span class="hljs-variable"><span class="hljs-variable">$b</span></span> b is</code> </pre><br><br><a name="ref"></a><h5>  Variable references </h5><br>  The variable name is just a string after the <code>$</code> character.  And it can be any string - in single quotes or another variable. <br><pre> <code class="bash hljs">; <span class="hljs-string"><span class="hljs-string">'var'</span></span> = 10 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$var</span></span> 10 ; ref = <span class="hljs-string"><span class="hljs-string">'var'</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $<span class="hljs-variable"><span class="hljs-variable">$ref</span></span> 10 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $<span class="hljs-string"><span class="hljs-string">'var'</span></span> 10 ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $(<span class="hljs-string"><span class="hljs-string">'va'</span></span> ^ r) 10</code> </pre><br><br><a name="subst"></a><h4>  Intercepted command output </h4><br>  In general, this topic is rather related to the section describing the launch of commands, but in order to understand what we were talking about, it was necessary to first describe the work with lists of strings, so we had to postpone it until the current moment. <br><br>  Meet the same unmatched quotes that always break syntax highlighting. <br><ul><li>  <code>`{}</code> (executes the command, and returns what it output to stdout as a list of strings; the elements of the list are separated using the value of the <code>$ifs</code> variable; if it is not defined, it is considered that it contains a string of three characters: space, tab and line feed) </li><li>  <code>"{}</code> (executes the command, and returns what it output to stdout as a single line - the concatenation of all the lines output by the command) </li></ul>  As an example, load the file list via the <code>ls</code> call.  Given that file names may contain spaces, the standard <code>`{}</code> behavior doesn‚Äôt work for us - we only need to separate list items by line breaks. <br><pre> <code class="bash hljs">; ifs := <span class="hljs-string"><span class="hljs-string">"{unicode -t 0A} ; files := `{ ls / } ; echo </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$#files</span></span></span><span class="hljs-string"> 82 ; ls / | wc -l 82</span></span></code> </pre><br>  But in general this is done easier and more reliably through the file name patterns, which are deployed by the shell to the file name list: <br><pre> <code class="bash hljs">; files2 := /* ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$#files2</span></span> 82</code> </pre><br><br><a name="builtin"></a><h4>  Embedded commands </h4><br>  There are two types of built-in commands: regular and for working with strings. <br><br>  Normal commands are invoked in the same way as applications / scripts are run: <br><pre> <code class="bash hljs">; run /lib/sh/profile ; load std ; unload std ; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre><br>  Commands for working with strings are called via <code>${ }</code> and return (do not output to stdout, namely, return - as it does, for example, referring to the value of a variable) a regular string - i.e.  they should be used in the parameters of the usual commands or in the right part of the assignment of values ‚Äã‚Äãinto variables.  For example, the command <code>${quote}</code> escapes the list of lines passed to it into one line, and <code>${unquote}</code> performs the inverse operation turning one line into a list of lines. <br><pre> <code class="bash hljs">; list = <span class="hljs-string"><span class="hljs-string">'ab'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$list</span></span> abcd ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${quote $list}</span></span> <span class="hljs-string"><span class="hljs-string">'ab'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">${unquote ${quote $list}</span></span>} abcd</code> </pre><br><br><a name="impl"></a><h4>  Add if, for, functions </h4><br>  As I promised, I show how to make my implementations of these badly needed things on ‚Äúbare sh‚Äù.  Of course, in real life, this is not required, the <i>std</i> loadable module provides everything that is needed, and it is much more convenient to use it.  But, nevertheless, this implementation is of interest as a demonstration of the possibilities of ‚Äúbare sh‚Äù. <br><br>  Everything is implemented using only: <br><ul><li>  variables </li><li>  lines and lines lists </li><li>  code blocks and their parameters </li></ul><br><br><a name="implfunc"></a><h5>  We do our ‚Äúfunctions‚Äù </h5><br>  As I already mentioned, any shell command is just a list of lines, where the first line is a command, and the remaining lines are its parameters.  A shell command block is just a string, and it can be stored in a variable.  And the parameters any block of commands gets in <code>$*</code> , <code>$1</code> , etc. <br><pre> <code class="bash hljs">; hello = { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Hello, <span class="hljs-variable"><span class="hljs-variable">$1</span></span>! } ; <span class="hljs-variable"><span class="hljs-variable">$hello</span></span> World Hello, World!</code> </pre><br>  Moreover, we can even do currying of functions in the best spirit of functional programming.  :) <br><pre> <code class="bash hljs">; greet = {<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>, <span class="hljs-variable"><span class="hljs-variable">$2</span></span>!} ; hi = <span class="hljs-variable"><span class="hljs-variable">$greet</span></span> Hi ; hello = <span class="hljs-variable"><span class="hljs-variable">$greet</span></span> Hello ; <span class="hljs-variable"><span class="hljs-variable">$hi</span></span> World Hi, World! ; <span class="hljs-variable"><span class="hljs-variable">$hello</span></span> World Hello, World!</code> </pre><br>  Another example - you can use block parameters to get the desired list item by number: <br><pre> <code class="bash hljs">; list = abcdef ; { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$3</span></span> } <span class="hljs-variable"><span class="hljs-variable">$list</span></span> c</code> </pre><br><br><a name="implfor"></a><h5>  Make your for </h5><br>  I didn‚Äôt try to do a full-fledged convenient if I was interested in implementing for, and if I did a minimally functional one.  it was necessary for for (the cycle must be stopped once, and without if it is difficult to do this). <br><pre> <code class="bash hljs">; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> = { $* } ; dont = { } ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> = { (cmd cond) := $* { <span class="hljs-variable"><span class="hljs-variable">$2</span></span> <span class="hljs-variable"><span class="hljs-variable">$cmd</span></span> } <span class="hljs-variable"><span class="hljs-variable">$cond</span></span> <span class="hljs-variable"><span class="hljs-variable">$do</span></span> <span class="hljs-variable"><span class="hljs-variable">$dont</span></span> } ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> = { (var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list) := $* code := $<span class="hljs-variable"><span class="hljs-variable">$#</span></span>* <span class="hljs-variable"><span class="hljs-variable">$iter</span></span> <span class="hljs-variable"><span class="hljs-variable">$var</span></span> <span class="hljs-variable"><span class="hljs-variable">$code</span></span> <span class="hljs-variable"><span class="hljs-variable">$list</span></span> } ; iter = { (var code list) := $* (cur list) := <span class="hljs-variable"><span class="hljs-variable">$list</span></span> (next unused) := <span class="hljs-variable"><span class="hljs-variable">$list</span></span> <span class="hljs-variable"><span class="hljs-variable">$if</span></span> {<span class="hljs-variable"><span class="hljs-variable">$var</span></span>=<span class="hljs-variable"><span class="hljs-variable">$cur</span></span>; <span class="hljs-variable"><span class="hljs-variable">$code</span></span>; <span class="hljs-variable"><span class="hljs-variable">$iter</span></span> <span class="hljs-variable"><span class="hljs-variable">$var</span></span> <span class="hljs-variable"><span class="hljs-variable">$code</span></span> <span class="hljs-variable"><span class="hljs-variable">$list</span></span>} <span class="hljs-variable"><span class="hljs-variable">$next</span></span> } ; <span class="hljs-variable"><span class="hljs-variable">$for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10 20 30 { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> i is <span class="hljs-variable"><span class="hljs-variable">$i</span></span> } i is 10 i is 20 i is 30 ;</code> </pre><br><br><a name="misc"></a><h4>  Interesting stuff </h4><br>  By default, the shell when the script is run forks the namespace, so the script cannot change the namespace of the process that started it.  This is not suitable for scripts whose task is just setting up the parent's namespace.  Such scripts should begin with <code>#!/dis/sh -n</code> . <br><br>  The <code>loaded</code> builtin command lists all the builtin commands from all loaded modules.  And <code>whatis</code> built-in command displays information on variables, functions, commands, etc. <br><br>  If you create the <code>$autoload</code> variable with the list of shell modules, then these modules will be automatically loaded into every shell that is started. <br><br>  There is syntax sugar support in the shell: <code>&amp;&amp;</code> and <code>||</code>  .  These operators are available in ‚Äúbare sh‚Äù, but are converted to a call to the builtin commands <code>and</code> and <code>or</code> , which are not in ‚Äúbare sh‚Äù, they are from the <i>std</i> module (so that using <code>&amp;&amp;</code> and <code>||</code> possible only after <code>load std</code> ). <br><pre> <code class="bash hljs">; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> { cmd &amp;&amp; cmd } {and {cmd} {cmd}} ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> { cmd || cmd } {or {cmd} {cmd}}</code> </pre><br>  Applications written in Limbo can be obtained, for example, when a command line parameter is run, a line with a block of sh commands can be executed very simply using the <a href="http://powerman.name/Inferno/man/2/sh.html">sh (2)</a> module. <br><br>  The style of the shell with variables and lists of strings leads to the fact that, unlike traditional shells, in inferno it is necessary to think about screening parameters and values ‚Äã‚Äãof variables only once - when they are first mentioned.  And then they can be transferred anywhere and somehow without thinking about what characters are in them. <br><br><a name="resume"></a><h4>  Summary </h4><br>  This short article is an almost complete reference guide for the Infern shell.  In a sense, the entire functionality of the basic shell is described, and in some detail with all the nuances and examples.    <a href="http://powerman.name/Inferno/man/1/sh.html">sh(1)</a> ,  ,        <code>$apid</code> , <code>$prompt</code> , -  ,   <code>sh</code>    .,        . <br><br>         /,    : <br><ul><li>      </li><li>   (       ) </li><li>      <code>^</code> </li><li>     <code>=</code> </li><li>     <code>$var</code> , <code>$#var</code>  <code>$"var</code> </li></ul>    !    ¬´¬ª ,        , if  for (   ,     raise   <i>std</i> ‚Äî ..   <code>/bin/false</code> :)     <code>run</code>        ). <br><br>        ,        .  ,    <a href="http://powerman.name/Inferno/man/1/sh-std.html">sh-std(1)</a> : <br><ul><li>    ( <code>and</code> , <code>or</code> , <code>if</code> ) </li><li>       ( <code>!</code> , <code>~</code> , <code>no</code> ) </li><li>    ( <code>apply</code> , <code>for</code> , <code>while</code> , <code>getlines</code> ) </li><li>    ( <code>fn</code> , <code>subfn</code> ) </li><li>      ( <code>raise</code> , <code>rescue</code> , <code>status</code> ) </li><li>      ( <code>${hd}</code> , <code>${tl}</code> , <code>${index}</code> , <code>${split}</code> , <code>${join}</code> ) </li><li>  etc. </li></ul>           ,       ! </div><p>Source: <a href="https://habr.com/ru/post/161859/">https://habr.com/ru/post/161859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161843/index.html">Add a new tag to MODX Revolution</a></li>
<li><a href="../161849/index.html">Framework in Marmalade (part 2)</a></li>
<li><a href="../161853/index.html">The shortest overview of the mechanical keyboard Matias Tactile Pro 4.0</a></li>
<li><a href="../161855/index.html">Bitcoin has an official bank</a></li>
<li><a href="../161857/index.html">The need for proper goal setting</a></li>
<li><a href="../161861/index.html">Evolution of Zeus. Part II</a></li>
<li><a href="../161863/index.html">STM32 + linux</a></li>
<li><a href="../161865/index.html">Windows Store opened in Ukraine</a></li>
<li><a href="../161867/index.html">‚ÄúQuote‚Äù button for iOs</a></li>
<li><a href="../161875/index.html">Simple technique Parallax Scrolling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>