<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parallel execution of dependent tasks and synchronization with conditional variables in the shell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to synchronize parallel shell processes using named pipes (FIFO files) as condition variables. How to perform parallel dependent tasks in topologi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parallel execution of dependent tasks and synchronization with conditional variables in the shell</h1><div class="post__text post__text-html js-mediator-article">  How to synchronize parallel shell processes using named pipes (FIFO files) as condition variables.  How to perform parallel dependent tasks in topological order with a minimum of tools: POSIX shell, mkfifo, POSIX kernel.  How parallel launch speeds up the loading of embedded systems and * BSD (rc-stage FreeBSD from 27 to 7 seconds) or the launch of applications in Docker, LXC and jail user containers.  How it improves uptime in <a href="http://jet9.ru/">Jet9</a> failover clusters. <a name="habracut"></a><br><br>  1 <a href="https://habr.com/ru/company/truevds/blog/268763/">Why do you need tasks with dependencies and what gives them a parallel launch</a> <br>  2 <a href="https://habr.com/ru/company/truevds/blog/268763/">Parallel vs sequential</a> <br>  3 <a href="https://habr.com/ru/company/truevds/blog/268763/">Performing tasks with dependencies</a> <br>  3.1 <a href="https://habr.com/ru/company/truevds/blog/268763/">rcorder, topological sorting and sequential execution</a> <br>  3.2 <a href="https://habr.com/ru/company/truevds/blog/268763/">upstart, events and asynchronous execution</a> <br>  3.3 <a href="https://habr.com/ru/company/truevds/blog/268763/">systemd, dependencies and asynchronous execution</a> <br>  3.4 <a href="https://habr.com/ru/company/truevds/blog/268763/">runit, parallel execution and synchronization when performing a single task</a> <br>  4 <a href="https://habr.com/ru/company/truevds/blog/268763/">Supervisors or Planners</a> <br>  4.1 <a href="https://habr.com/ru/company/truevds/blog/268763/">multitask-flow, parallel execution of dependent tasks</a> <br>  5 <a href="https://habr.com/ru/company/truevds/blog/268763/">Means for synchronization of parallel shell processes</a> <br>  5.1 <a href="https://habr.com/ru/company/truevds/blog/268763/">Lock file as mutex</a> <br>  5.2 <a href="https://habr.com/ru/company/truevds/blog/268763/">FIFO file as a condition variable</a> <br>  5.3.1 <a href="https://habr.com/ru/company/truevds/blog/268763/">Constructs for a condition variable in a shell</a> <br>  5.3.2 <a href="https://habr.com/ru/company/truevds/blog/268763/">Requirements for the working environment</a> <br>  6 <a href="https://habr.com/ru/company/truevds/blog/268763/">Device multitask-flow</a> <br>  6.1 <a href="https://habr.com/ru/company/truevds/blog/268763/">Parallel execution and synchronization on FIFO files</a> <br>  6.2 <a href="https://habr.com/ru/company/truevds/blog/268763/">How can and how can not apply multitask-flow</a> <br>  7 <a href="https://habr.com/ru/company/truevds/blog/268763/">Related Links</a> <br><br><a name="section"></a><h2>  Why do you need tasks with dependencies and what gives them a parallel launch </h2><br>  Frequently encountered tasks with pronounced dependencies are loading or changing the server operation mode and starting / stopping user containers.  Most of our Linux and FreeBSD hardware is not loaded into the standard installation of the distribution, but into our own operating environment.  This is a compact image located on a RAM disk, in which there are system programs required for the main profile of work, and various auxiliary utilities.  Starting a service, initializing a device, applying settings are separate tasks that are present or absent in the system depending on the purpose of the server, and these tasks must be performed in the correct sequence.  For example, if the network configuration starts running before the network card driver is loaded, the network will not work.  Different applications work in user containers, the correctness of the work of some of them may depend on the work of others, which is why the order in which they start and stop is important.  For example, if the application server is started before the database server, it may immediately stop due to the inability to connect to the database. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To start the system now there are two generally accepted approaches.  The first is to specify the order in which tasks are performed explicitly.  To do this, you can either list the tasks in the execution order in the shell script, or <strong>number the</strong> tasks and use the number in the file name of the task, and then execute them by sorting the file name: <br><br><pre><code class="bash hljs">S23ntp S25mdadm S91apache2</code> </pre> <br><br>  The second way to start is to specify the <strong>dependencies</strong> between the start scripts, that is, to list what conditions are needed to complete the task and what conditions the task creates after its completion: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># REQUIRE: apache # PROVIDE: nginx</span></span></code> </pre><br><br>  Although specifying dependencies is more complicated than numbering, it is much more convenient and is now used almost everywhere. <br><br>  The main drawback that has explicit numbering of tasks is that the developer first needs to identify dependencies on other tasks, then find the numbers of these dependencies, and select the appropriate number for the new task, in the process which may reveal that the numbering was unsuccessful and needs to be changed for some of the scripts .  When performing according to dependencies, the main advantage is the simplicity of adding tasks to an already established process ‚Äî for a new task, it is enough just to list its dependencies on other tasks.  Another convenience is the possibility of parallel execution of tasks, because only dependent tasks should be performed in turn, and tasks that are not dependent on each other can be performed in parallel. <br><br><a name="vs-"></a><h2>  Parallel vs serial </h2><br>  Parallel execution when performing tasks has two key advantages: <br><br><ul><li>  if tasks are not limited to a single resource (for example, one processor), then with parallel execution they will be completed earlier than with a sequential one; </li><li>  if one of the tasks for some reason has stopped, then it does not block the performance of other tasks that do not depend on it and they will continue to be performed. </li></ul><br><br>  With regard to the latter, some people are probably familiar with the situation when <code>sendmail</code> does not start up for a long time due to network problems and waits for DNS responses for tens of minutes, as a result of which it‚Äôs impossible to log in to the server, since <code>sshd</code> was in the starting sequence later than <code>sendmail</code> .  With a parallel start, if <code>sshd</code> does not specify a dependency on <code>sendmail</code> , then it will not stop it. <br><br>  It is necessary to take into account that the absence of an explicitly specified dependency does not mean the absence of a dependency at all - a dependency can be mediated, for example, several tasks can simultaneously access a resource that does not allow for this (simultaneous writing to one file, changing the program configuration, or initializing the device).  When performing tasks in sequence, such a situation is impossible and therefore may not be taken into account, but in case of parallel execution, it may be necessary to identify such resources and prevent their simultaneous use.  In practice, this rarely happens, since most of the tasks ultimately run system utilities that are independently involved in blocking access, or the kernel does this if the access is made to its resources. <br><br><a name="section-1"></a><h2>  Tasks with dependencies </h2><br><a name="rcorder-----"></a><h3>  rcorder, topological sorting and sequential execution </h3><br>  The easiest way to perform dependencies - <a href="https://www.freebsd.org/cgi/man.cgi%3Frcorder%25288%2529">rcorder (8)</a> - appeared in NetBSD 1.5 in 2000. The rc-scripts using the PROVIDE, REQUIRE and BEFORE annotations describe the dependencies between the scripts.  The <code>rcorder</code> utility <code>rcorder</code> a list of scripts, extracts relationships from them, builds a dependency graph, and returns a list of scripts in the order of topological sorting of the dependency graph. <br><br>  Running scripts in this order ensures that the dependent scripts will be launched only after the dependency scripts have been completed.  Scripts are executed alternately, and the possibility of parallel start is not implemented.  Therefore, synchronization of parallel processes is not required and the implementation is simple and reliable. <br><br>  A similar mechanism appeared later in Debian Lenny, where the <em>Required-Start</em> , <em>Required-Stop</em> , <em>Provides</em> annotations were added to SysV-init, which describe dependencies for different actions ( <em>start</em> and <em>stop</em> ).  Further, the order of execution is determined by these dependencies, numbers are added to the names of the scripts and the scripts are placed in the starting directory: <br><br><pre> <code class="bash hljs">S23ntp S25mdadm S91apache2</code> </pre><br><br><a name="upstart----"></a><h3>  upstart, events and asynchronous execution </h3><br>  <a href="http://upstart.ubuntu.com/">Upstart</a> appeared in 2006 in Ubuntu and later began to be used in many other distributions.  Instead of specifying relationships between tasks, the <a href="http://upstart.ubuntu.com/cookbook/">condition</a> <em>on the</em> event is described here using the <em>start on</em> directive - an event or a logical expression of the presence of events, during which the task should be executed.  For example, for services requiring a network, you can specify the start condition of the NETWORK_AVAILABLE event and then they will be launched after someone sends the NETWORK_AVAILABLE event to the system.  In the condition, you can specify not only the dependence on some other task, but also more complex options, for example, runlevel and the state of other tasks. <br><br>  This method of execution leads to the fact that tasks are executed asynchronously at the moment when the event occurred, and when the condition involving this event turned out to be true.  If there are several tasks waiting for one event, they will be executed simultaneously.  The dispatch of events and the execution of tasks will be handled by the <code>init</code> service.  There are all the advantages in the form of speed of start and localization of problem branches. <br><br><a name="systemd----"></a><h3>  systemd, dependencies, and asynchronous execution </h3><br>  <a href="http://www.freedesktop.org/wiki/Software/systemd/">Systemd</a> appeared later, turned on an even wider number of functions, captured the <code>upstart</code> space and is now used as a subsystem for configuration, management, service execution and logging on most popular Linux distributions. <br><br>  Unlike <code>upstart</code> , <code>systemd</code> uses dependencies, not events, to start services.  These <a href="http://www.freedesktop.org/software/systemd/man/systemd.unit.html">dependencies are more complex and varied</a> than in <code>rcorder</code> ‚Äî here it can be order relations (starting a task before or after another task) and requirements (presence is desirable, another task should be present or should be absent).  Tasks (units) are divided into several types - services (daemons), devices, mounting file systems, etc. <br><br>  Tasks are executed in parallel, as in <code>upstart</code> .  The method of describing dependencies allows you to check them at run time for the presence of deadlocks, that is, cyclic dependencies (when a task through a chain of other tasks ultimately depends on itself).  <code>systemd</code> as far as possible tries to solve such problems and removes creating tasks from the execution transaction ( <em>Wants =</em> ), and also checks for dependencies-conflicts ( <em>Conflicts =</em> ), not allowing conflicting tasks to start. <br><br><a name="runit--------"></a><h3>  runit, parallel execution and synchronization when performing a single task </h3><br>  <a href="http://smarden.org/runit/">Runit is</a> positioned as a lightweight replacement of <code>init</code> and the system of launching scripts, with a clear device and simple configuration.  It is also convenient to use this program for supervision over the work of services or groups of services, for example, for starting individual application servers and databases.  Because of its simplicity and cross-platform, <code>runit</code> often used on embedded systems or for managing web applications. <br><br>  There are no dependencies as such in <code>runit</code> .  Instead, in the service start script <a href="http://smarden.org/runit/faq.html">, the <code>sv</code> command is specified, starting other services</a> .  <code>sv</code> independently checks whether the service is running or not, and prevents from duplicate launches of the same service.  This is enough to allow programs to run in parallel, but does not allow detecting cyclic dependencies leading to deadlocks. <br><br>  <code>runit</code> designed to manage services, that is, constantly running demons.  It checks the process and restarts it if necessary.  But its logic does not fit well with the execution of one-time tasks with dependencies, for example, the client receiving network settings via DHCP. <br><br><a name="section-2"></a><h2>  Supervisors or Schedulers </h2><br>  Of the above tools, only <code>rcorder</code> is a pure scheduler for running dependent tasks.  All the others are designed to start services with dependencies and then control the existence of the service, that is, they are service supervisors.  <code>systemd</code> and <code>upstart</code> also support one-time tasks ( <em>Type = oneshot</em> or <em>task</em> ) while preserving all the dependency logic and thus allow you to conveniently manage the loading and operation of the computer, taking into account most details.  A more formal way of describing dependencies in <code>systemd</code> , and using targets as a substitute for modes of operation (runlevels), is a major evolution after the <code>upstart</code> .  But both <code>upstart</code> and its <code>systemd</code> follower are complex and cumbersome tools that are difficult to integrate into the operating environment, which differs from their main purpose. <br><br>  The focus on capturing all aspects of the operating system and the solidity of the system makes it difficult or impossible to integrate <code>systemd</code> into an environment in which narrow responsibility would be placed on it.  For this reason, to manage individual services and for embedded systems, they still continue to use <code>runit</code> , <a href="http://cr.yp.to/daemontools.html">daemontools</a> , <a href="https://github.com/kostya/eye">eye</a> , <a href="http://supervisord.org/">supervisord,</a> or their own scripts that manage demons, taking into account the features of their work. <br><br>  Both <code>upstart</code> and <code>systemd</code> along with <code>runit</code> are claimed as a means to ensure the serviceability of services (daemons).  This statement contains a large share of slyness, since by ensuring the operability of the service it is meant to restart the fallen service.  This tracks the genetic relationship with <code>init</code> , one of the purposes of which was to run <code>getty</code> , the terminal maintenance process.  Since terminals were the main means of work and management in Unix, the terminal‚Äôs operability could be called the second most critical function after the kernel‚Äôs operability.  Accordingly, the most important and very first process was assigned the role of restarting <code>getty</code> processes both during normal terminal release and <code>getty</code> .  The reason why <code>getty</code> dropped or the terminal was freed was irrelevant to the fact that there was no <code>getty</code> on the terminal and the possibility of entering the computer was lost. <br><br>  The evolutionary descendants of <code>init</code> undertook to restart not only <code>getty</code> , but also all constantly running services.  But the supervision of services remained at the primitive level - if the demon fell, it is simply restarted.  More serious monitoring of both the quality of services (absence of internal errors, maintenance of requests on time), and control over their technical parameters (memory size, CPU usage) still have to be performed by other means.  Therefore, the use of <code>systemd</code> and its analogues in a pure form for reliable operation is not very suitable, and when integrated with other means of monitoring and management, one must additionally take into account the competitive influence of supervisory systems. <br><br>  In some cases, an automatic restart of a dropped service will be dangerous, since if it is somehow related to storing data, then due to some non-stored data or a broken structure, an error will occur in the stored data.  And if, after an emergency restart, work continues without taking measures to check the integrity of the data and eliminate possible errors, the errors will be multiplied.  Therefore, for a simple and reliable system operation, a more correct approach would be, where monitoring the operation of services and the response to their disruption will be tailored to the characteristics of each particular service, rather than being done automatically by the same comb for all. <br><br>  The use of large and actively growing systemsd-type complexes leads to another risk - either attachment to the selected version of the program and difficulty with backporting error fixes, or the constant probability of encountering large rework when updating a version. <br><br><a name="multitask-flow----"></a><h3>  multitask-flow, parallel execution of dependent tasks </h3><br>  To start and control the modes of operation of our various equipment, a minimalist tool was needed to perform tasks with dependencies, which would not try to perform additional functions for state control and restart, but would simply do its main work well (execution by dependencies) and which would be easily integrated into different sites.  In addition to convenient integration, cross-platform and ease of maintenance were required.  With some improvements, it later found other applications ‚Äî the launch of custom containers, the management of cluster operating modes, the start, and the management of operating modes of other subsystems. <br><br>  The default option was a C program. Dependencies are independently extracted from scripts or obtained by an external script and are served in a form compatible with <code>tsort(1)</code> .  The list is used to construct the dependency digraph, it is checked for cycles, after which the tasks are performed in the reverse order of resetting or resetting the dependency counter.  Unlike <code>upstart</code> and <code>systemd</code> , which require Linux kernel 2.6.24 and 3.0 for their needs, in this case, the usual <em>fork-exec-wait</em> scheme and any POSIX kernel are sufficient.  But then a more convenient alternative was chosen - a utility and a small POSIX shell library: <a href="https://github.com/cvss/jet9-multitask-flow">jet9-multitask-flow</a> . <br><br>  The use of the shell gives obvious advantages: cross-platform, that is, work in any environment where there is a POSIX shell, and flexibility that allows you to extend the script to the specific features of the scripts it manages - a way of describing dependencies, a way of doing it.  There are also disadvantages: the language makes it easy to make hard-to-find errors and, being an interpreter, leads to a low execution speed.  Due to the small size of the code, the first problem turns out to be insignificant, and the speed of execution for our application is also not a problem: the time required to perform the control functions turns out to be negligible compared to the time of task execution. <br><br>  It looks paradoxical, but the execution time of a set of several hundred tasks using the scheduler on <code>sh</code> turns out to be several times faster than using a similar scheduler on C. This has a rational explanation - shell scripts using a large shared library will work faster if the required load the library once into the parent process of the shell scheduler and then execute all hundreds of scripts in the sub shells.  If the C scheduler is used and it runs hundreds of scripts via <code>exec()</code> , then much more time is required to initialize the shell and load all the libraries with each script. <br><br><a name="section-3"></a><h2>  Means for synchronizing parallel shell processes </h2><br><a name="section-4"></a><h3>  Lock file as mutex </h3><br>  In the dialects of the shell, where it is possible to start parallel processes (they are called background processes in this area), the <code>wait</code> command is also present.  This command, when executed in the parent process, waits for the completion of all child processes.  The analogy of multi-threaded programming is the creation of several threads and then wait through <code>join</code> completion of all threads created from the main thread.  This is a means of synchronization, but in many cases the tool is not very suitable: in addition to waiting for all the descendant processes, it is impossible to wait for processes that are not descendants. <br><br>  Lock-file mutexes have been used for a long time to prevent simultaneous access to a resource in shell scripts.  As a rule, an atomic operation is used for this - creating a file or creating a directory via <code>mkdir</code> .  If this operation fails, the resource is considered busy and the script interrupts execution.  When operating on files, the <em>no clobber</em> flag can be used to prevent writing to existing files, and creating a directory in the presence of an existing one is impossible.  But the atomicity of such operations is provided not by the language or the runtime, but by the file system, so the behavior may differ under different conditions. <br><br>  This is a simple script and it is great for most cases - when it is required to prohibit duplication of script execution, for example, if you frequently run long-lived scripts through <code>cron</code> or when daemons start.  If it is required not to interrupt work, but to wait for the resource to be released, then the usual technique for this is a periodic check for the absence of a lock, in fact, a spinlock with falling asleep: if a file or directory exists, then the script goes to sleep for a while and then tries again.  It is pointless and harmful to do spinlock on a shell without falling asleep - due to the nature of using shell scripts, the blocking time can be either a fraction of a second or several tens of seconds, which is why a non-stop check will load both the processor and the OS kernel, taking away resources from all and slowing down, including the competing process. <br><br>  Falling asleep saves the processor, but at the same time decreases the speed of reaction to the release of the lock.  Previously, when the <code>sleep</code> command understood only integer arguments, the minimum sleep time was 1 second.  Now this value may already be smaller, but, in any case, it will be some constant, which may be too large for short actions in a few milliseconds.  Therefore, for a quick response, a mechanism is desirable that implements waiting for a resource to be released without falling asleep for a fixed time, but also without active waiting. <br><br>  One method for stopping and asynchronous resuming after that is to transmit signals, such as falling asleep and transmitting <code>SIGALRM</code> .  The method is also available for the shell, but it requires additional complex actions to notify the Lok owner about the waiting processes.              <code>flock(2)</code>  <code>fcntl(2)</code> , ,  ,   -            . <br><br><a name="fifo-----"></a><h3> FIFO-     </h3><br>  Unix        <strong>named pipes</strong> ‚Äî   ,          ,    .         Unix ‚Äî  <code>pipe(2)</code> ,         .  ‚Äî    ,      .               ,      .         ,     ,   ..,     ,      ,   .   ,    <code>pipe(2)</code>   ,   FIFO-  <code>mkfifo(2)</code>   ,                 ,  FIFO-           ,          . <br><br>       ,       (    ),  ,    ,    ,      .     ,       ,     ,    .   ,     ,          ,   ,      . <br><br>         :        FIFO-; ,    ,     ;      FIFO-     ,     .        ,           . <br><br>         ,      FIFO-     <code>wait</code>   ,          <code>broadcast</code>  <code>notifyAll</code> . <br><br><a name="shell"></a><h4>      shell </h4><br>  (),   ,    : <br><br><pre> <code class="bash hljs">mkfifo <span class="hljs-variable"><span class="hljs-variable">$lock_file</span></span></code> </pre><br><br> ,     : <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">read</span></span> none &lt; <span class="hljs-variable"><span class="hljs-variable">$lock_file</span></span></code> </pre><br><br>  (broadcast),   race condition,   -       ,    ,   : <br><br><pre> <code class="bash hljs">mv <span class="hljs-variable"><span class="hljs-variable">$lock_file</span></span> <span class="hljs-variable"><span class="hljs-variable">$lock_file</span></span>.$$ : &lt;&gt; <span class="hljs-variable"><span class="hljs-variable">$lock_file</span></span> rm -f <span class="hljs-variable"><span class="hljs-variable">$lock_file</span></span>.$$</code> </pre><br><br><a name="section-5"></a><h4>     </h4><br>    FIFO-     <code>mkfifo(2)</code> ( POSIX.1),   <code>mkfifo(1)</code> ( POSIX.2)   ,     ,   POSIX shell.      Linux,  FreeBSD, , ,   Unix-like  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a caveat: to unlock waiting processes, you need to open the FIFO file for writing and close it immediately. But if there is not a single process reading from the pipe (the resource is of no interest to anyone), the process opening the file for writing will be blocked. This blocking will continue until someone reading from the pipe appears, and if no one appears, the blocking will be permanent. For Linux and FreeBSD, this problem is solved by the fact that the FIFO file can be opened simultaneously for writing and reading, in which case the process is never blocked. Thus, the logic is observed that the FIFO file does not block the processes when it is opened, if it is open for both reading and writing, even if this is the same single process. In POSIX, this behavior is not described in any way, but in the Linux kernel (fs / fifo.c) on this occasion separately mentioned with a justification why such a discovery is not blocked:</font></font><br><br><pre> / *<font></font>
 * O_RDWR<font></font>
 * POSIX.1 leaves this case "undefined" when O_NONBLOCK is set.<font></font>
 * This implementation will NEVER block on a O_RDWR open, since<font></font>
 * the process can at least talk to itself.<font></font>
  * /
</pre><br><br>   FreeBSD    ,       ,       . <br><br>      ,   -              . ,  AIX  ,    O_RDWR .        FIFO-   ,      ,  FIFO-      . <br><br><a name="multitask-flow"></a><h2>  multitask-flow </h2><br><a name="fifo-"></a><h3>      FIFO- </h3><br>       ,      ,    -    shell      .        ,      ,     . <br><br>     ,      .      ,   FIFO-    .     ,       . <br><br>              ,    ,  -      .    . <br><br>        ,          ,            .           (FIFO-),   .   ‚Äî broadcast-   .         .  ,      ,          . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method is somewhat wasteful in costs, since a separate sub-shell will be launched for each task, and therefore a separate process. To execute a stream of hundreds of tasks, hundreds of processes will be launched. But this expense is not as great as it may seem - the code and data segments are almost completely in common with the main process and only the stack and some other small piece of allocated memory will be their own for each process. For Linux on a 64-bit Intel architecture, for a dash on the 3.16 kernel is about 160 KB per process, for FreeBSD in a similar situation about 120 KB. That is, the simultaneous waiting of 100 tasks requires 12-16 MB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The blocking, waiting, and notification of unblocking are implemented according to the principle described earlier on FIFO files and put into separate functions ( </font></font><code>dependency_init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>dependency_wait</code> , <code>dependency_mark</code> )    .         <em>wait + notifyAll/broadcast</em> ,        ,    .                sinchronized,          ( <code>dependency_lock</code> ).         FIFO-,         . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The functions of the last group organize interaction with real tasks - with system startup scripts, with service scripts, etc. </font><font style="vertical-align: inherit;">With the help of some functions, tasks, dependencies and relationships between tasks are obtained, and with the help of other functions, tasks are performed. </font><font style="vertical-align: inherit;">You can redefine these functions under specific rules for annotation of dependencies and init-script execution and leave the scripts themselves unchanged. </font><font style="vertical-align: inherit;">For example, the </font></font><a href="https://github.com/cvss/jet9-multitask-flow/tree/master/examples/freebsd"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parallel launch of rc-scripts for FreeBSD was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> made according to this principle </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="multitask-flow-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How can and how can not apply multitask-flow </font></font></h3><br>      <code>jet9-multitask-init</code> ,                   <a href="http://jet9.ru/">Jet9</a> ,       <code>init</code>   .     <code>init</code>           <code>jet9-multitask-flow</code> . <br><br>   <code>init</code> ,        ,   .      <code>init</code> ‚Äî      (runlevel).         (   -),    <a href="http://www.truevirtual.ru/">TrueVirtual</a> .       Linux   c <code>init</code>  Debian 6    <code>jet9-multitask-init</code> . <br><br> <code>runit</code>    <code>multitask-flow</code>            ,         ,  ,  Docker.  ,   <code>runit</code> : <br><br><ul><li>      ( , DHCP, service discovery, DNS registration) </li><li> ‚Äú‚Äù ,         <em>mark</em>        ,         </li><li>      </li><li>       ,          </li><li>   <code>tsort</code>   ,    </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><a href="http://jet9.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet9</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we transferred </font></font><code>multitask-flow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">custom containers </font><font style="vertical-align: inherit;">to the </font><font style="vertical-align: inherit;">start. For most sites, the LAMP environment is used, and in this case, only user </font></font><code>apache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">are working inside the container </font></font><code>mysqld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. U </font></font><code>mysqld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has its own supervisor </font></font><code>mysqld_safe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>apache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the supervisor function is performed by its root process. Another supervisor overseeing these supervisors is clearly redundant. On the rare occasions when the supervisor universal all the same it is necessary, along with </font></font><code>multitask-flow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used </font></font><code>runit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But in other web environments, most often the application server also has its own supervisor and it‚Äôs enough to start services, as in LAMP, via</font></font><code>multitask-flow</code>   . ,  - Ruby on Rails  Unicorn, -  ,    .    <code>runit</code>  ,   <code>unicorn</code> ,     ,  , <a href="http://samsaffron.com/archive/2013/11/13/live-restarts-of-a-supervised-unicorn-process">     <code>unicorn</code></a> .       <a href="https://github.com/kostya/eye">eye</a> ,     ,      , , , HTTP- .  ,     ,        <code>eye</code>   . <br><br>    <code>multitask-flow</code>      ,  .   ?  .            ,          .            . ,  SLA    (99.99%, ~5   ),     .                15-30 . <br><br>      <a href="https://github.com/cvss/jet9-multitask-flow/tree/master/examples/freebsd">  FreeBSD</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the current version, a quick way is rather difficult to get dependencies through awk (three awk launches for each script), and this definitely needs some work. </font><font style="vertical-align: inherit;">In addition, you need to test several hundred system rc scripts and scripts from packages - dependencies and concurrent access conflicts may be incompletely written in them. </font><font style="vertical-align: inherit;">With a sequential start, the wrong dependencies could be masked, but in a parallel start they can appear. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most likely, with the help </font></font><code>multitask-flow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you can speed up the start of systems on </font></font><code>busybox</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>OpenWRT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but in practice this has not yet been verified. </font><font style="vertical-align: inherit;">In OpenWRT, there is already some groundwork for integration with </font></font><code>systemd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and, perhaps, an alternative is no longer needed for it.</font></font><br><br><a name="section-6"></a><h2>  Related Links </h2><br><br><ul><li> <a href="https://www.freebsd.org/cgi/%25E2%2586%25B3%2520man.cgi%3Frcorder%25288%2529"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rcorder (8)</font></font></a> </li><li> <a href="http://linux.die.net/man/1/tsort"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tsort</font></font></a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topological sorting</font></font></a> </li><li> <a href="http://upstart.ubuntu.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upstart</font></font></a> </li><li> <a href="http://www.freedesktop.org/wiki/Software/systemd/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemd</font></font></a> </li><li> <a href="http://smarden.org/runit/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Runit</font></font></a> </li><li> <a href="http://cr.yp.to/daemontools.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daemontools</font></font></a> </li><li> <a href="https://github.com/kostya/eye"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eye</font></font></a> </li><li> <a href="http://supervisord.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supervisord</font></font></a> </li><li> <a href="https://github.com/cvss/jet9-multitask-flow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jet9-multitask-flow</font></font></a> </li><li> <a href="https://github.com/cvss/jet9-multitask-flow/tree/master/examples/freebsd">freebsd-multitask-flow</a> </li></ul><br><br><a name="ps"></a><h2>  PS </h2><br>       - Jet9 (  ).       ,      . <br><br><a name="section-7"></a><h3>     </h3><br>       : Ruby, Python  Java.               .      ,  ,   ,  ,    ,  .    ,      . <br><br><a name="section-8"></a><h4>   : </h4><br><br><ul><li> Java ‚Äî OpenJDK 7, Tomcat 6, 7, 8 </li><li> Python mod_wsgi / Tornado,  2.6, 2.7, 3.3, 3.5 </li><li> Ruby mod_passenger / Unicorn / Puma,  1.8.7, 1.9.3, 2.0, 2.2 </li></ul><br><br><a name="section-9"></a><h4>  Questions </h4></div><p>Source: <a href="https://habr.com/ru/post/268763/">https://habr.com/ru/post/268763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268749/index.html">Benefits of Managed Security Service</a></li>
<li><a href="../268751/index.html">Alibaba vs. Facebook is where the West converges with the East</a></li>
<li><a href="../268753/index.html">CoffeeScript array comprehensions - fashionable, stylish, slow</a></li>
<li><a href="../268757/index.html">C ++ Russia in St. Petersburg</a></li>
<li><a href="../268759/index.html">13 basic principles of game design: progression, environment, method and basics</a></li>
<li><a href="../268765/index.html">Back to the Code - Contest Report</a></li>
<li><a href="../268767/index.html">Deploying Applications in InterSystems Cach√©</a></li>
<li><a href="../268769/index.html">MiML2</a></li>
<li><a href="../268771/index.html">Using web fonts, the best way (for 2015)</a></li>
<li><a href="../268773/index.html">Imitation of the radio using Freeswitch and a little about voip-conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>