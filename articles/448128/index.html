<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>9 tips on using the Cats library in Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Functional programming in Scala can be hard to master due to some syntactic and semantic features of the language. In particular, some of the language...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>9 tips on using the Cats library in Scala</h1><div class="post__text post__text-html js-mediator-article">  Functional programming in Scala can be hard to master due to some syntactic and semantic features of the language.  In particular, some of the language tools and ways of implementing what was planned with the help of the main libraries seem obvious when you are familiar with them - but at the very beginning of the study, especially self-learning, it is not so easy to recognize them. <br><br>  For this reason, I decided that it would be helpful to share some tips on functional programming in Scala.  Examples and names correspond to cats, but the syntax in scalaz should be similar due to the general theoretical basis. <br><br><img src="https://habrastorage.org/webt/wf/n0/92/wfn0925sgvde-jv71ogsic_xuwk.jpeg"><br><a name="habracut"></a><br><h3>  <b>9) Constructors of extension methods</b> </h3><br>  Let's start with, perhaps, the most basic tool - extension methods of any type that turn an instance into Option, Either, etc., in particular: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li> <code>.some</code> and the corresponding constructor method <code>none</code> for <code>Option</code> ; </li><li>  <code>.asRight</code> , <code>.asLeft</code> for <code>Either</code> ; </li><li>  <code>.valid</code> , <code>.invalid</code> , <code>.validNel</code> , <code>.invalidNel</code> for <code>Validated</code> </li></ul><br>  Two main advantages of using them: <br><br><ol><li>  So compact and clearer (since the sequence of method calls is preserved). </li><li>  Unlike constructor variants, the return types of these methods are expanded to a supertype, that is: </li></ol><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some[String] "a".some //Option[String]</span></span></code> </pre> <br>  Although type inference has improved over the years, and the number of possible situations in which this behavior helps a programmer to remain calm has decreased, compilation errors due to overly specialized typing are still possible in Scala today.  Quite often, the desire to beat your head against the table arises when working with <code>Either</code> (see chapter 4.4.2 of the book <a href="https://underscore.io/books/scala-with-cats/"><u>Scala with Cats</u></a> ). <br><br>  Something else on the topic: <code>.asRight</code> and <code>.asLeft</code> still have one type parameter.  For example, <code>"1".asRight[Int]</code> is <code>Either[Int, String]</code> .  If you do not provide this parameter, the compiler will try to output it and get <code>Nothing</code> .  Still, it is more convenient than either to provide both parameters each time or not to provide either one, as in the case of constructors. <br><br><h3>  <b>8) Fifty shades *&gt;</b> </h3><br>  The *&gt; operator, defined in any <code>Apply</code> method (that is, in <code>Applicative</code> , <code>Monad</code> , etc.), simply means ‚Äúprocess the original calculation and replace the result with what is specified in the second argument‚Äù.  In terms of code (in the case of <code>Monad</code> ): <br><br><pre> <code class="scala hljs">fa.flatMap(_ =&gt; fb)</code> </pre> <br>  Why use the obscure symbolic operator for an operation that does not have a noticeable effect?  When you start using ApplicativeError and / or MonadError, you will find that the operation retains the effect of an error on the entire workflow.  Take for example <code>Either</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success1 = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success2 = <span class="hljs-string"><span class="hljs-string">"b"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] success1 *&gt; success2 <span class="hljs-comment"><span class="hljs-comment">//Right(b) success2 *&gt; success1 //Right(a) success1 *&gt; failure //Left(400) failure *&gt; success1 //Left(400)</span></span></code> </pre> <br>  As you can see, even in case of an error, the calculation remains short-circuited.  *&gt; will help you in working with deferred calculations in <code>Monix</code> , <code>IO</code> and other similar <code>Monix</code> . <br><br>  There is also a symmetric operation, &lt;*.  So, in the case of the previous example: <br><br><pre> <code class="scala hljs">success1 &lt;* success2 <span class="hljs-comment"><span class="hljs-comment">//Right(a)</span></span></code> </pre> <br>  Finally, if the use of characters is alien to you, it is not necessary to resort to it.  *&gt; Is just the <code>productR</code> alias, and &lt;is the <code>productL</code> alias. <br><br><h3>  <b>Note</b> </h3><br>  In a personal conversation, Adam Warski (thank you, Adam!) Rightly noted that in addition to *&gt; ( <code>productR</code> ), there is also &gt;&gt; from <code>FlatMapSyntax</code> .  &gt;&gt; is defined in the same way as <code>fa.flatMap(_ =&gt; fb)</code> , but with two nuances: <br><br><ul><li>  it is determined independently of <code>productR</code> , and therefore, if for any reason the contract of this method changes (theoretically, it can be changed without violating monadic laws, but I am not sure about <code>MonadError</code> ), you will not suffer; </li><li>  more importantly, the &gt;&gt; has a second operand called by-name-name, i.e.  <code>fb: =&gt; F[B]</code> .  The difference in semantics becomes fundamental if you perform calculations that can lead to a stack explosion. </li></ul><br>  Based on this, I began to use *&gt; more often.  One way or another, do not forget about the factors listed above. <br><br><h3>  <b>7) Raise the sail!</b> </h3><br>  It takes time for many to lay down the concept of <code>lift</code> .  But when you succeed, you will find that it is everywhere. <br><br>  Like many terms hovering in the air of functional programming, <code>lift</code> comes from <a href="https://en.wikipedia.org/wiki/Lift_(mathematics)">category theory</a> .  I will try to explain: take an operation, change the signature of its type so that it becomes directly related to the abstract type F. <br><br>  In Cats, the simplest example is <a href="https://typelevel.org/cats/api/cats/Functor.html">Functor</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = map(_)(f)</code> </pre> <br>  This means: change this function so that it acts on a given type of functor F. <br><br>  The lift function is often synonymous with nested constructors for a given type.  So, <code>EitherT.liftF</code> is essentially <code>EitherT.right.</code>  <a href="https://typelevel.org/cats/api/cats/data/EitherT%2524.html">Scaladoc example</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">EitherT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">EitherT</span></span>.liftF(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some) <span class="hljs-comment"><span class="hljs-comment">//EitherT(Some(Right(a))) EitherT.liftF(none[String]) //EitherT(None)</span></span></code> </pre> <br>  Cherry on the cake: <code>lift</code> present in the standard Scala library everywhere.  The most popular (and, perhaps, the most useful in daily work) example is <code>PartialFunction</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intMatcher: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"jak siƒô masz!"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> liftedIntMatcher: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = intMatcher.lift liftedIntMatcher(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some(jak siƒô masz!) liftedIntMatcher(0) //None intMatcher(1) //jak siƒô masz! intMatcher(0) //Exception in thread "main" scala.MatchError: 0</span></span></code> </pre> <br>  Now you can go to more pressing issues. <br><br><h3>  <b>6) mapN</b> </h3><br>  <code>mapN</code> is a useful helper function for working with tuples.  Again, this is not a novelty, but a replacement for the good old operator <code>|@|</code>  , he's ‚ÄúScream‚Äù. <br><br>  Here is what mapN looks like in the case of a two-element tuple: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// where t2: Tuple2[F[A0], F[A1]] def mapN[Z](f: (A0, A1) =&gt; Z)(implicit functor: Functor[F], semigroupal: Semigroupal[F]): F[Z] = Semigroupal.map2(t2._1, t2._2)(f)</span></span></code> </pre> <br>  In essence, it allows us to map the values ‚Äã‚Äãinside a tuple from any F that are a semigroup (product) and a functor (map).  So: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ (<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-string"><span class="hljs-string">"b"</span></span>.some).mapN(_ ++ _) <span class="hljs-comment"><span class="hljs-comment">//Some(ab) (List(1, 2), List(3, 4), List(0, 2).mapN(_ * _ * _)) //List(0, 6, 0, 8, 0, 12, 0, 16)</span></span></code> </pre> <br>  By the way, do not forget that with cats you get a map and <code>leftmap</code> for tuples: <br><br><pre> <code class="scala hljs">(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-string"><span class="hljs-string">"b"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>).mapN(_ ++ _)) <span class="hljs-comment"><span class="hljs-comment">//won't compile, because outer type is not the same ("a".some, List("b", "c")).leftMap(_.toList).mapN(_ ++ _) //List(ab, ac)</span></span></code> </pre> <br>  Another useful feature of <code>.mapN</code> is instantiating case classes: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mead</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, honeyRatio: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">, agingYears: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">"p√≥≈Çtorak".some, 0.5.some, 3d.some</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapN</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//Some</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span><span class="hljs-class"><span class="hljs-params">(p√≥≈Çtorak,0.5,3.0</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  Of course, you would rather use the for loop operator for this, but mapN avoids monad transformers in simple cases. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.effect.<span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-comment"><span class="hljs-comment">//interchangable with eg Monix's Task type Query[T] = IO[Option[T]] def defineMead(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = (for { name &lt;- OptionT(qName) honeyRatio &lt;- OptionT(qHoneyRatio) agingYears &lt;- OptionT(qAgingYears) } yield Mead(name, honeyRatio, agingYears)).value def defineMead2(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = for { name &lt;- qName honeyRatio &lt;- qHoneyRatio agingYears &lt;- qAgingYears } yield (name, honeyRatio, agingYears).mapN(Mead)</span></span></code> </pre> <br>  Methods have a similar result, but the latter goes without monadic transformers. <br><br><h3>  <b>5) Nested</b> </h3><br>  <code>Nested</code> - in fact, a generalizing twin monadny transformers.  As the name suggests, it allows you to perform attachments under certain conditions.  Here is an example for <code>.map(_.map( :</code> <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">Nested</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someValue: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]] = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight.some <span class="hljs-type"><span class="hljs-type">Nested</span></span>(someValue).map(_ * <span class="hljs-number"><span class="hljs-number">3</span></span>).value <span class="hljs-comment"><span class="hljs-comment">//Some(Right(aaa))</span></span></code> </pre> <br>  In addition to the <code>Functor</code> , <code>Nested</code> summarizes the operations <code>Applicative</code> , <code>ApplicativeError</code> and <code>Traverse</code> .  Additional information and examples are <a href="https://typelevel.org/cats/datatypes/nested.html">here</a> . <br><br><h3>  <b>4) .recover / .recoverWith / .handleError / .handleErrorWith / .valueOr</b> </h3><br>  Functional programming in Scala is largely due to the processing of the effect of an error.  <code>ApplicativeError</code> and <code>MonadError</code> have several useful methods, and it may be useful for you to learn the subtle differences between the main four.  So, with <code>ApplicativeError F[A]:</code> <br><br><ul><li>  <code>handleError</code> converts <u>all</u> errors at the dial peer to A according to the specified function. </li><li>  <code>recover</code> works in a similar way, but accepts partial functions, and therefore can convert to A errors you have selected. </li><li>  <code>handleErrorWith</code> is similar to <code>handleError</code> , but its result should look like <code>F[A]</code> , which means it helps you convert errors. </li><li>  <code>recoverWith</code> acts as recover, but also requires <code>F[A]</code> as a result. </li></ul><br>  As you can see, you can restrict <code>handleErrorWith</code> and <code>recoverWith</code> , which cover all possible functions.  However, each method has its advantages and is convenient in its own way. <br><br>  In general, I advise you to familiarize yourself with the <a href="https://typelevel.org/cats/api/cats/ApplicativeError.html">ApplicativeError</a> API, which is one of the richest in Cats and inherited from MonadError - and therefore supported in <code>cats.effect.IO</code> , <code>monix.Task</code> , etc. <br><br>  There is another method for <code>Either/EitherT</code> , <code>Validated</code> and <code>Ior</code> - <code>.valueOr</code> .  In fact, it works like <code>.getOrElse</code> for <code>Option</code> , but it is generalized for classes that contain something ‚Äúleft‚Äù. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] failure.valueOr(code =&gt; <span class="hljs-string"><span class="hljs-string">s"Got error code </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//"Got error code 400"</span></span></code> </pre> <br><h3>  <b>3) alley-cats</b> </h3><br>  <a href="https://github.com/typelevel/cats/tree/master/alleycats-core">alley-cats</a> is a convenient solution for two cases: <br><br><ul><li>  instances of the secret classes that do not follow their laws by 100%; </li><li>  unusual auxiliary taykklassy that can be used properly. </li></ul><br>  Historically, the monad instance for <code>Try</code> most popular in this project, because <code>Try</code> , as you know, does not satisfy all monadic laws in terms of fatal errors.  Now he is truly represented in the Cats. <br><br>  Despite this, I recommend reading <a href="https://github.com/typelevel/cats/tree/master/alleycats-core"><u>this module</u></a> , it may seem useful to you. <br><br><h3>  <b>2) Responsible to import</b> </h3><br>  You must know ‚Äî from the documentation, the book, or from somewhere else ‚Äî that cats uses a particular import hierarchy: <br><br>  <code>cats.x</code> for basic (kernel) types; <br>  <code>cats.data</code> for data types like Validated, monad transformers, etc .; <br>  cats.syntax.x._ to support extensible methods so that you can call sth.asRight, sth.pure, and others; <br> <code>cats.instances.x.</code>  _ to directly import the implementation of various timeclasses to the implicit scope for individual concrete types, so that when calling, for example, sth.pure, the error "implicit not found" does not occur. <br><br>  Of course, you noticed <code>cats.implicits._</code> import, which imports all the syntax and all instances of the type class into the implicit scope. <br><br>  In principle, when developing with Cats, you should start with a certain sequence of imports from the FAQ, namely: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._</code> </pre> <br>  Acquainted with the library closer, you can combine to your taste.  Follow the simple rule: <br><br><ul><li>  <code>cats.syntax.x</code> provides the extension syntax related to x; </li><li>  <code>cats.instances.x</code> provides the <code>cats.instances.x</code> instances. </li></ul><br>  For example, if you need <code>.asRight</code> , which is an <code>.asRight</code> method for <code>Either</code> , do the following: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.either._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Right[Int, String](a)</span></span></code> </pre> <br>  On the other hand, to get <code>Option.pure</code> you must import <code>cats.syntax.monad</code> <b>And</b> <code>cats.instances.option</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.applicative._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.option._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.pure[<span class="hljs-type"><span class="hljs-type">Option</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Some(a)</span></span></code> </pre> <br>  Thanks to manual optimization of your import, you limit implicit scopes in your Scala files and thereby shorten the compilation time. <br><br>  However, please: do not do this if the following conditions are not met: <br><br><ul><li>  you have already mastered the Cats </li><li>  your team owns the library at the same level </li></ul><br>  Why?  Because: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   `pure`, //    import cats.implicits._ import cats.instances.option._ "a".pure[Option] //could not find implicit value for parameter F: cats.Applicative[Option]</span></span></code> </pre> <br>  This happens because <code>cats.implicits</code> and <code>cats.instances.option</code> are extensions of <code>cats.instances.OptionInstances</code> .  In fact, we import its implicit scope twice, which confuses the compiler. <br><br>  At the same time, there is no magic in the hierarchy of implications - this is a clear sequence of type extensions.  You only need to refer to the definition of <code>cats.implicits</code> and explore the type hierarchy. <br><br>  For some 10-20 minutes you can study it enough to avoid problems like these - believe me, this investment will definitely pay off. <br><br><h3>  <b>1) Do not forget the cats update!</b> </h3><br>  You may think that your FP library is timeless, but in fact <code>cats</code> and <code>scalaz</code> actively updated.  Take cats as an example.  Here are just the latest changes: <br><br><ul><li>  now <a href="https://github.com/typelevel/cats/pull/2511">you don‚Äôt need to add a Throwable exception when using raiseError</a> ; </li><li>  now there are instances for <a href="https://github.com/typelevel/cats/pull/2515">Duration</a> and <a href="https://github.com/typelevel/cats/pull/2544">FiniteDuration</a> , which means you can use d1&gt; d2 without using external libraries; </li><li>  as well as a bunch of other <a href="https://github.com/typelevel/cats/releases">small and large innovations</a> . </li></ul><br>  Therefore, when working with projects, do not forget to check the version of the library, read the notes to the new versions and be updated in time. </div><p>Source: <a href="https://habr.com/ru/post/448128/">https://habr.com/ru/post/448128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448118/index.html">SEO and contextual advertising - leads for 175 thousand rubles a day in Izhevsk</a></li>
<li><a href="../448120/index.html">About the proximity of the peaks</a></li>
<li><a href="../448122/index.html">How does ReactJS work? React package</a></li>
<li><a href="../448124/index.html">Mikrotik. SMS control using WEB server</a></li>
<li><a href="../448126/index.html">API secrets of Android devices. Yandex report</a></li>
<li><a href="../448130/index.html">De-design in video games</a></li>
<li><a href="../448136/index.html">Instruction: how to test ansible roles and learn about problems before production</a></li>
<li><a href="../448140/index.html">SNA Hackathon 2019 - results</a></li>
<li><a href="../448142/index.html">Where evidence, facts and imagination converge</a></li>
<li><a href="../448144/index.html">NASA: Space Travel Genetic Changes are Temporary</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>