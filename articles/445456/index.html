<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Search at a speed of 1 TB / s</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR: Four years ago, I left Google with the idea of ‚Äã‚Äãa new server monitoring tool. The idea was to combine into one service the usually isolated f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Search at a speed of 1 TB / s</h1><div class="post__text post__text-html js-mediator-article">  TL; DR: Four years ago, I left Google with the idea of ‚Äã‚Äãa new server monitoring tool.  The idea was to combine into one service the usually isolated functions of <a href="https://www.scalyr.com/product">collecting</a> and analyzing logs, collecting metrics, <a href="https://www.scalyr.com/server-log-alerts">alerts</a> and a dashboard.  One of the principles is that the service should be really <i>fast</i> , providing devops with an easy, interactive, enjoyable job.  This requires processing data sets of several gigabytes in a fraction of a second, without going beyond the budget.  Existing tools for working with logs are often slow and clumsy, so we are faced with a good task: to competently develop a tool to give users new sensations of work. <br><br>  This article describes how we in Scalyr solved this problem by applying the methods of the old school, the approach of brute force, eliminating the extra layers and avoiding complex data structures.  You can apply these lessons to your own engineering tasks. <br><a name="habracut"></a><br><h1>  The power of the old school </h1><br>  Log analysis usually begins with a search: find all messages matching a certain pattern.  In Scalyr, there are dozens or hundreds of gigabytes of logs from many servers.  Modern approaches, as a rule, involve the construction of some complex data structure that is optimized for search.  I, of course, saw this in Google, where they are pretty good at these things.  But we stopped at a much more crude approach: linear scanning of logs.  And it worked - we provide an interface with the search an order of magnitude faster than the competition (see the animation at the end). <br><br>  The key insight was that modern processors are really very fast in simple, straightforward operations.  This is easy to miss in complex, multi-layered systems that depend on I / O speed and network operations, and such systems are very common today.  Thus, we have developed a design that minimizes the number of layers and excess garbage.  With multiple processors and servers in parallel, the search speed reaches 1 TB per second. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Key findings from this article: <br><br><ul><li>  Rough search is a viable approach to solving real, large-scale problems. <br></li><li>  Brute force is a design technique, not a release from work.  Like any technique, it is better suited for some problems than for others, and it can be implemented poorly or well. <br></li><li>  Brute force is especially good for <i>stable</i> performance. <br></li><li>  Efficient use of brute force requires code optimization and the timely use of sufficient resources.  It is suitable if your servers are under heavy load, not user-related, and user operations remain in priority. <br></li><li>  Performance depends on the design of the entire system, and not only on the internal loop algorithm. </li></ul><br>  (This article describes the search for data in memory. In most cases, when a user performs a search by logs, Scalyr servers have already cached it. resources). <br><br><h1>  Brute force method </h1><br>  Traditionally, a search in a large dataset is performed by an index of keywords.  For server logs, this means searching for each unique word in the log.  For each word you need to make a list of all inclusions.  This makes it easy to find all the messages with this word, for example, 'error', 'firefox' or "transaction_16851951" - just look in the index. <br><br>  I used this approach in Google, and it worked well.  But in Scalyr we are looking for byte by byte logs. <br><br>  Why?  From an abstract algorithmic point of view, keyword indexes are much more efficient than a coarse search.  However, we do not sell algorithms, we sell performance.  And performance is not only algorithms, but also system engineering.  We have to take everything into account: the amount of data, the type of search, the available hardware, and the software context.  We decided that for our particular problem, an option like 'grep' is better suited than an index. <br><br>  Indexes are great, but they have limitations.  One word is easy to find.  Finding messages with a few words, such as 'googlebot' and '404', is much more difficult.  Searching for a phrase like 'uncaught exception' requires a more cumbersome index, which registers not only all the messages with this word, but also the specific location of the word. <br><br>  The real difficulty arises when you are not looking for words.  Suppose you want to see how much traffic comes from bots.  The first thought is a search in the logs for the word 'bot'.  So you will find some bots: Googlebot, Bingbot and many others.  But here 'bot' is not a word, but part of it.  If we search for 'bot' in the index, we will not find messages with the word 'Googlebot'.  If you check each word in the index and then scan the index for the keywords found, the search will slow down greatly.  As a result, some programs for working with logs do not allow searching by parts of a word or (at best) allow using a special syntax with lower performance.  We want to avoid this. <br><br>  Another problem is punctuation.  Want to find all requests from <code>50.168.29.7</code> ?  What about debugging logs that contain <code>[error]</code> ?  Indices usually miss punctuation. <br><br>  Finally, engineers love powerful tools, and sometimes a problem can be solved only by a regular expression.  Keyword index is not very suitable for this. <br><br>  In addition, indexes <i>are complex</i> .  Each message needs to be added to multiple keyword lists.  These lists should always be kept in a searchable format.  Queries with phrases, fragments of words or regular expressions should be translated into operations with several lists, and the results should be scanned and merged to obtain a result set.  In the context of a large-scale multi-user service, such complexity creates performance problems that are not visible when analyzing algorithms. <br><br>  Keyword indices also take up a lot of space, and storage is the main expense item in the log management system. <br><br>  On the other hand, you can spend a lot of computing power on each search.  Our users value high-speed search for unique queries, but such queries are relatively rare.  For typical search queries, for example, for the dashboard, we use special techniques (we will describe them in the next article).  Other requests are rare, so rarely do you have to process more than one at a time.  But this does not mean that our servers are not busy: they are loaded with work on receiving, analyzing and compressing new messages, evaluating alerts, compressing old data, and so on.  Thus, we have a fairly substantial stock of processors that can be used to fulfill requests. <br><br><h1>  Brute force works if you have a brute force (and a lot of power) </h1><br>  Brute force works best on simple tasks with small internal cycles.  Often you can optimize the inner loop for very high speeds.  If the code is complex, it is much more difficult to optimize it. <br><br>  Initially, our search code had a rather large inner loop.  We store messages on 4K pages;  Each page contains some messages (in UTF-8) and metadata for each message.  Metadata is a structure in which the length of the value, the internal message ID, and other fields are encoded.  The search cycle looked like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/700/659/eb8/700659eb85e63ee1b7493c995ed8b235.png"><br><br>  This is a simplified version compared to the actual code.  But even here you can see several object locations, copies of data, and function calls.  The JVM optimizes function calls fairly well and allocates ephemeral objects, so this code worked better than we deserved.  During testing, clients used it quite successfully.  But in the end we moved to a new level. <br><br>  (You may ask why we store messages in such a format with 4K pages, text and metadata, rather than working directly with logs. There are many reasons that boil down to the internal Scalyr engine more like a distributed database than file system. Text search is often combined with DBMS-style filters in the fields after log parsing. We can simultaneously search for many thousands of logs at the same time, and simple text files are not suitable for our transactional, replicated, distributed control  data). <br><br>  Initially, it seemed that such a code was not very suitable for optimization under the brute force method.  The ‚Äúreal work‚Äù in <code>String.indexOf()</code> did not even dominate the CPU profile.  That is, the optimization of this method alone would not have had a significant effect. <br><br>  It so happened that we store metadata at the beginning of each page, and the text of all messages in UTF-8 is packed at the other end.  Taking advantage of this, we rewrote the cycle to search right across the page: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc2/c88/cf3/cc2c88cf34b05cdc752c2a117fde8079.png"><br><br>  This version works directly on the <code>raw byte[]</code> view and searches for all messages on the entire 4K page at once. <br><br>  It is much easier to optimize for the brute force method.  The internal search cycle is called simultaneously for the entire 4K page, and not separately for each message.  There is no copying data or selection of objects.  And more complex operations with metadata are invoked only with a positive result, and not for each message.  Thus, we have eliminated a ton of overhead, and the remaining workload is concentrated in a small internal search cycle, which is well suited for further optimization. <br><br>  Our actual search algorithm is based on <a href="http://volnitsky.com/project/str_search/">Leonid Volnitsky's great idea</a> .  It is similar to the Boyer-Moore algorithm with a gap of approximately the length of the search string at each step.  The main difference is that it checks two bytes at a time to minimize false matches. <br><br>  Our implementation requires creating a 64K lookup table for each search, but this is nothing compared to the gigabytes of data we are looking for.  The internal loop processes several gigabytes per second on a single core.  In practice, stable performance is about 1.25 GB per second on each core, and there is room for improvement.  You can eliminate some of the overhead outside the inner loop, and we plan to experiment with the inner loop in C instead of Java. <br><br><h1>  We use force </h1><br>  We discussed that the search by logs can be implemented ‚Äúroughly‚Äù, but how much ‚Äúpower‚Äù do we have?  A lot. <br><br>  <b>1 core</b> : when used correctly, one core of a modern processor is quite powerful in itself. <br><br>  <b>8 cores</b> : we are currently working on Amazon hi1.4xlarge and i2.4xlarge SSD servers, each with 8 cores (16 threads).  As mentioned above, these kernels are usually occupied by background operations.  When the user performs a search, the background operations are suspended, freeing up all 8 cores for the search.  The search is usually completed in a split second, after which background work resumes (the program-controller ensures that a barrage of search queries does not interfere with important background work). <br><br>  <b>16 cores</b> : for reliability, we organize servers into master / slave groups.  Each master submits one SSD server and one EBS.  If the main server crashes, the server on the SSD immediately takes its place.  Almost all the time, master and slave work fine, so each data block is searchable on two different servers (the slave EBS server has a weak processor, so we do not consider it).  We divide the task between them, so we have a total of 16 cores available. <br><br>  <b>Many cores</b> : in the near future, we will distribute data across servers in such a way that they all participate in the processing of each non-trivial request.  Each core will work.  [Note: <i>we implemented the plan and increased the search speed to 1 TB / s, see the note at the end of the article</i> ]. <br><br><h1>  Simplicity provides reliability </h1><br>  Another advantage of the brute force method is fairly stable performance.  As a rule, the search is not very sensitive to the details of the task and the data set (I think this is why it is called ‚Äúrough‚Äù). <br><br>  The keyword index sometimes gives an incredibly fast result, but in other cases it does not.  Suppose you have 50 GB of logs in which the term 'customer_5987235982' occurs exactly three times.  A search on this term counts three locations directly from the index and will end instantly.  But a complex wildcard search can scan thousands of keywords and take a long time. <br><br>  On the other hand, the brute force search for any query is performed at more or less the same speed.  The search for long words is better, but even the search for one character is quite fast. <br><br>  The simplicity of the brute force method means that its performance is close to the theoretical maximum.  There are fewer options for unexpected disk overload, lock contention, pointer chase, and thousands of other reasons for crashes.  I just looked at the requests made by Scalyr users last week on our busiest server.  There were 14,000 requests.  Exactly eight of them took more than one second;  99% completed within 111 milliseconds (if you didn‚Äôt use the log analysis tools, believe me: <i>this is fast</i> ). <br><br>  Stable, reliable performance is important for service usability.  If it periodically slows down, users will perceive it as unreliable and reluctant to use. <br><br><h1>  Search by logs in action </h1><br>  Here is a small animation that shows the Scalyr search in action.  We have a demo account where we import every event in every public Github repository.  In this demonstration, I study the data for the week: approximately 600 MB of raw logs. <br><br>  The video was recorded live, without special training, on my desktop (about 5000 kilometers from the server).  The performance you see is largely due to the <a href="https://www.scalyr.com/blog/optimizing-angularjs-1200ms-to-35ms/">optimization of the web client</a> , as well as the fast and reliable backend.  Whenever there is a pause without the 'loading' indicator, I pause so that you can read what I‚Äôm about to click. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/159/bf8/c90/159bf8c9074eb627d27e7b5876e57740.gif"><br><br><h1>  Finally </h1><br>  When processing large amounts of data, it is important to choose a good algorithm, but ‚Äúgood‚Äù does not mean ‚Äúfancy‚Äù.  Think about how your code will work in practice.  From the theoretical analysis of algorithms, some factors that may be of great importance in the real world fall out.  Simpler algorithms are easier to optimize and more stable in borderline situations. <br><br>  Also think about the context in which the code will run.  In our case, we need powerful enough servers to manage background tasks.  Users rarely initiate a search, so we can borrow a whole group of servers for the short period necessary to complete each search. <br><br>  Using the brute force method, we implemented a fast, reliable, flexible search for a set of logs.  We hope that these ideas will be useful for your projects. <br><br>  Edit: The <i>title and text changed from ‚ÄúSearch at 20 GB per second‚Äù to ‚ÄúSearch at 1 TB per second‚Äù to reflect an increase in performance over the past few years.</i>  <i>This increase in speed is primarily due to the change in the type and number of EC2 servers that we are raising today to serve the increased client base.</i>  <i>Changes are expected in the near future, which will provide another sharp increase in work efficiency, and we are looking forward to the opportunity to talk about it.</i> </div><p>Source: <a href="https://habr.com/ru/post/445456/">https://habr.com/ru/post/445456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445446/index.html">How we used deferred replication for disaster recovery with PostgreSQL</a></li>
<li><a href="../445448/index.html">Configuring automatic receipt of letsencrypt certificates using docker for linux</a></li>
<li><a href="../445450/index.html">Browser extension for the site toster.ru</a></li>
<li><a href="../445452/index.html">Useful repositories with Eloquent?</a></li>
<li><a href="../445454/index.html">Raspberry Pi Zero inside Handy Tech Active Star 40 Braille Display</a></li>
<li><a href="../445458/index.html">Electronic Arts will deal with 350 employees and "reduce presence" in Russia</a></li>
<li><a href="../445460/index.html">Interactivity without gadgets</a></li>
<li><a href="../445464/index.html">Reducing the sample size of experimental data without losing information</a></li>
<li><a href="../445468/index.html">Team from Russia ranked third in the Imagine Cup competition in Europe, Africa and the Middle East</a></li>
<li><a href="../445472/index.html">The decision on YouTube is made, censored to be! and as always, Russia didn‚Äôt do without</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>