<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Horizontal scaling. What, why, when and how?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexander Makarov ( SamDark ) 
 Hello! I am Alexander Makarov, and you can know me by the framework "Yii" - I am one of its developers. I also have a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Horizontal scaling. What, why, when and how?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a00/749/132/a00749132bc14dce86b62da036b2b567.jpg" alt="Alexander Makarov"><br><br><h2>  Alexander Makarov ( <a href="https://habrahabr.ru/users/samdark/" class="user_link">SamDark</a> ) </h2><br>  Hello!  I am Alexander Makarov, and you can know me by the framework "Yii" - I am one of its developers.  I also have a full-time job - and this is no longer a startup - Stay.com, which deals with travel. <br><br>  Today I will talk about horizontal scaling, but in very, very general words. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is scaling, in general?  This is an opportunity to increase project performance in minimal time by adding resources. <br><br>  Usually scaling does not mean rewriting the code, but either adding servers or expanding existing resources.  For this type of allocate vertical and horizontal scaling. <br><a name="habracut"></a><br>  Vertical - this is when they add more RAM, disks, etc.  to an existing server, and a horizontal one is when more servers are put into data centers, and the servers there already interact somehow. <br><br>  The coolest question they ask is - why is it necessary, if everything on me and on one server works fine?  In fact, you need to check what will happen.  Ie, now it works, but what will happen next?  There are two wonderful utilities - ab and siege, which kind of overtake a competitor‚Äôs users cloud, who start to hammer the server, try to request pages, send some requests.  You have to specify what they should do, and the utilities generate the following reports: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c83/10b/222/c8310b2229fdc675ac065185407fa202.png"><br><br>  and <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/7f4/d1f/f727f4d1f61a01931c4e23a9fe140d01.png"><br><br>  The main two parameters: n - the number of requests that need to be made; s - the number of simultaneous requests.  In this way, they test competitiveness. <br><br>  The output is RPS, i.e.  the number of requests per second that the server is capable of processing, from which it will become clear how many users it can withstand.  All, of course, depends on the project, it happens in different ways, but usually it requires attention. <br><br>  There is one more parameter - Response time - response time, for which, on average, the server gave a page.  It can be different, but it is known that about 300 ms is the norm, and what is higher is no longer very good, because the server performs these 300 ms, 300-600 ms are added to this, which the client performs, i.e.  until everything is loaded - styles, pictures and the rest - time passes too. <br><br>  It happens that in fact so far and do not have to worry about scaling - we go to the server, update PHP, we get 40% performance increase and everything is cool.  Next, set up Opcache, tyunim it.  Opcache, by the way, is tuned in the same way as APC, a script that can be found in the repository of Rasmus Lerdorf and which shows hits and missions, where hits are how many times PHP went to the cache, and how many times did it go to the file system get files.  If you drive the entire site, or run some crawler under the links, or manually poke it, then we will have statistics on these hits and mismes.  If hits are 100%, and misy is 0%, then everything is fine, and if there are misy, then you need to allocate more memory so that all our code fits into Opcache.  This is a common mistake that is made - like Opcache exists, but something does not work ... <br><br>  They also often begin to scale, but they don‚Äôt look, in general, because of which everything works slowly.  Most often we climb into the database, we look - there are no indices, we put indices - everything flies right away, another 2 years is enough, beauty! <br><br>  Well, you also need to enable the cache, replace apache with nginx and php-fpm to save memory.  Everything will be cool. <br><br>  All of the above is simple enough and gives you time.  Time for the fact that once this will be enough, and for this we must now prepare. <br><br>  How, in general, to understand what the problem?  Either you have already reached highload, and this is not necessarily some crazy number of requests, etc., this is when your project does not cope with the load, and this is no longer solved by trivial methods.  It is necessary to grow either in breadth or up.  It is necessary to do something and, most likely, this is not enough time, something needs to be invented. <br><br>  The first rule is that you can never do anything blindly, i.e.  we need great monitoring.  First, we gain time for some obvious optimization such as cache enablement or Main cache, etc.  Then we set up monitoring, it shows us what is missing.  And all this is repeated many times - you can never stop monitoring and refinement. <br><br>  What can monitoring show?  We can rest against the disk, i.e.  in the file system, in memory, in the processor, in the network ... And it may be that, like, everything is more or less, but some errors fall.  All this is allowed in different ways.  You can, for example, solve a problem with a disk by adding a new disk to the same server, or you can install a second server that will only deal with files. <br><br>  What you need to pay attention right now when monitoring?  It: <br><br><ol><li>  availability, i.e.  whether the server is alive, in general, or not; <br></li><li>  lack of disk resources, processor, etc .; <br></li><li>  mistakes. <br></li></ol><br>  How to monitor all this? <br><br>  Here is a list of great tools that allow you to monitor resources and show results in a very convenient way: <br><br><ul><li>  <a href="http://mmonit.com/monit/">Monit</a> - <a href="http://mmonit.com/monit/">mmonit.com/monit</a> </li><li>  <a href="http://www.zabbix.com/">Zabbix</a> - <a href="http://www.zabbix.com/">www.zabbix.com</a> </li><li>  <a href="http://munin-monitoring.org/">Munin</a> - <a href="http://munin-monitoring.org/">munin-monitoring.org</a> </li><li>  <a href="http://www.nagios.org/">Nagios</a> - <a href="http://www.nagios.org/">www.nagios.org</a> </li><li>  <a href="https://www.serverdensity.com/">ServerDensity</a> - <a href="https://www.serverdensity.com/">www.serverdensity.com</a> </li></ul><br>  The first 4 tools can be put on the server, they are powerful, cool.  And ServerDensity is hosted by someone, i.e.  we pay money for it, and it can collect all data from the servers and display them for analysis. <br><br>  There are two good services for monitoring bugs: <br><br><ul><li>  <a href="https://rollbar.com/">Rollbar</a> - <a href="https://rollbar.com/">rollbar.com</a> </li><li>  <a href="https://getsentry.com/">Sentry</a> - <a href="https://getsentry.com/">getsentry.com</a> </li></ul><br>  Usually we monitor errors like this - either we write everything to the log and then we look at it, or in addition we start emails or send sms to the developers.  This is all normal, but as soon as we have a cloud of people on the service, and there is some kind of error, it starts repeating a very large number of times, it starts frantically spamming the email, or it overflows, or the developer completely loses attention and he starts to ignore letters.  The above services take and errors of the same type are collected in one big pack, plus they consider how many times errors have occurred recently and in priorities the whole business is raised automatically. <br><br>  Sentry can be delivered to your server, there is a source, and Rollbar is not, but Rollbar is better because it takes money for the number of errors, i.e.  encourages to correct them. <br><br>  About the notification, I repeat that you should not spam, attention is lost. <br><br>  What, in general, need to analyze? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/acc/c9d/cce/accc9dccefe0243b90dc760ec9733cd3.png"><br><br>  RPS and Response time - if the response time begins to fall, then we need to do something. <br><br>  The number of processes, threads and queue sizes - if it all starts to multiply, get clogged up, etc., then something is wrong again, you need to analyze in more detail and somehow change the infrastructure. <br><br>  Also worth looking at business analysis.  Google Analytics for site types is great, and mixpanel - for event logging, it works on desktop applications, on mobile, on the web.  It is possible and on the basis of some of their data to write, but I would advise the finished services.  The point is that our monitoring can show that the service is alive, that everything works, that the overall Responce time is normal, but when we, for example, register in the mixpanel, we start tracking, it shows that they are somehow not enough.  In this case, it is necessary to look at how quickly certain events, pages, and what the problems are.  The project should always be ‚Äúhung‚Äù with analysis in order to always know what is happening, and not to work blindly. <br><br>  The load, in general, arises or is planned, or not, may occur gradually, maybe not gradually: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a59/76f/c7a/a5976fc7af184c25a5f2d1713e5a236c.png"><br><br>  How to deal with the load?  All business solves, and only the issue price is important.  Important: <br><br><ol><li>  for the service to work, <br></li><li>  so that it is not very expensive, do not ruin the company. <br></li></ol><br>  The rest is not very important. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46a/7ff/cf3/46a7ffcf3ac85eba0d1c124a166e1753.png"><br><br>  If it is cheaper to scan, optimize, write to the cache, fix some configs, then this should be done without thinking about scaling and buying additional hardware, etc.  But it happens that "hardware" becomes cheaper than the work of a programmer, especially if programmers are very savvy.  In this case, the scaling begins. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/882/032/063882032865cc5b186ab9108f518c15.png"><br><br>  In the figure, the blue thing is the Internet, from which requests are coming.  A balancer is put, the only task of which is to distribute requests to separate front-end servers, accept responses from them and give them to the client.  The point here is that 3 servers can handle (ideally) 3 times as many requests, excluding any overhead for the network and for the work of the balancer itself. <br><br>  What does this give us?  The above ability to handle more requests, and more reliability.  If the traditional scheme falls nginx or application, or rested on the disk, etc., then everything fell.  Here, if we have one frontend fell off, then that's okay, the balancer, most likely, it will understand and send requests to the remaining 2 servers.  Maybe it will be a little slower, but it's not scary. <br><br>  In general, PHP is a great thing to scale, because it follows the Share nothing principle by default.  This means that if we take, say, Java for the web, then the application starts, reads all the code, writes the maximum data to the program memory, everything is spinning, working, the request takes very little time, very few additional resources.  However, there is an ambush - because  the application is written in such a way that it should work on one instance, be cached, read from its own memory, then nothing good can happen when scaling.  And in PHP, by default, there is nothing in common, and this is good.  All that we want to share, we put it in memcahed, and memcahed can be read from several servers, so everything is fine.  Those.  weak connectivity is achieved for the application server layer.  It's fine. <br><br>  What, in general, to balance the load? <br><br>  Most often this was done by Squid or HAProxy, but this is before.  Now the author of nginx took and parted from nginx + balancer in nginx, so now he can do all the things that Squid or HAProxy used to do before.  If it starts not to withstand, you can put some cool expensive hardware balancer. <br><br>  The problems that the balancer solves are how to choose a server and how to store sessions?  The second problem is purely PHP's, and the server can be selected either in turn from the list, or by the geography of some IP's, or by some statistics (nginx supports least-connected, that is, to which server there are fewer connections , he will throw it on him).  We can write for the balancer some code that will choose how to work with it. <br><br>  Here, this link describes a balancer svezhepartirovanny in nginx: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a3/001/d0c/2a3001d0c62d564079e69c4ebdfbbd0d.png"><br><br>  I recommend it to everyone, there are very simple configs, everything is as simple as possible. <br><br>  What if we hit the balancer? <br><br>  There is such a thing as DNS Round robin is a great trick that allows us not to spend money on a hardware balancer.  What are we doing?  We take a DNS server (no one hosts the host DNS server, it‚Äôs expensive, not very reliable, if it fails, then nothing good will happen, everyone uses some companies), we write more than one server in the A record, and a few.  These will be A-records of different balancers.  When the browser goes there (there are no guarantees, in fact, but all modern browsers do this), it selects one of the A-records from the A-records in turn and gets either to one balancer or to the second.  The load, of course, may not be spread evenly, but at least it is smeared, and the balancer can withstand a little more. <br><br>  What to do with the sessions? <br><br>  Sessions are default files.  This is not the case, because each of the frontend servers will have sessions in its file system, and the user may fall for one, then the second, then the third, i.e.  session, he will lose every time. <br><br>  There is an obvious desire to make a shared file system, connect NFS.  But you don‚Äôt need to do that - it‚Äôs dreadfully slow. <br><br>  You can write to the database, but also not worth it, because  The database is not optimal for this work, but if you have no other choice, then, in principle, it will do. <br><br>  You can write in memcached, but very, very carefully, because memcached is, after all, a cache and it has the ability to wipe out as soon as it has few resources, or there is no place to write new keys - then it starts to lose old without warning session start to get lost.  For this, you must either follow, or choose the same Redis. <br><br>  Redis is a normal solution.  The point is that we have Redis on a separate server, and all our frontends break in there and start reading their sessions with Redis.  But Redis is single-threaded and sooner or later we can properly rest on it.  Then do sticky sessions.  The same nginx is put and it is informed to it that it is necessary to make the session so that the user, when he came to the server and was given a session cookie, so that later he would only go to this server.  Most often this is done by IP-hash.  It turns out that if Redis is on each instance, respectively, there are different sessions there, and the read-write throughput will be much better. <br><br>  What about cookies?  You can write to cookies, there will be no repositories, everything is fine, but, first, we still need to have session data somewhere, and if we start writing cookies, it can grow and not get into the repository, but , secondly, you can only store IDs in cookies, and we still have to contact the database for some session data.  In principle, this is normal, solves the problem. <br><br>  There is a cool thing - a proxy for memcached and Redis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/415/fb9/e5f/415fb9e5f840075e9e3addc72817b662.png"><br><br>  They, it seems, support parallelization out of the box, but this is done, I would not say that it is very optimal.  But this thing - twemproxy - it works something like nginx with PHP, i.e.  as soon as the answer is received, it immediately sends the data and closes the connection in the background, it turns out faster, consumes less resources.  Very nice stuff. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ce/340/313/2ce340313bccc407eba07217e0b26ae3.png"><br><br>  Very often there is such a mistake of ‚Äúcycling‚Äù when they start writing, such as ‚ÄúI don‚Äôt need sessions!  I will now make a wonderful token that will be transferred back and forth ‚Äù... But, if you think about it, this is again a session. <br><br>  In PHP, there is a mechanism like session handler, i.e.  we can put our handler and write to cookies, to the database, to Redis - anywhere, and all this will work with standard session start, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5f/4ce/3f5/d5f4ce3f5beb279bcf7d03159125ae63.png"><br><br>  Sessions should be closed by this wonderful method. <br><br>  As soon as we read everything from the session, we are not going to write there, it needs to be closed, because the session is often blocked.  It should, in general, be blocked, because without locks there will be problems with competitiveness.  On the files, this can be seen immediately, in other repositories the blockers are not on the whole file at once, and this is a little easier. <br><br>  What to do with the files? <br><br>  You can cope with them in two ways: <br><br><ol><li>  some kind of specialized solution that gives an abstraction, and we work with files as with a file system.  This is something like NFS, but NFS is not necessary. <br></li><li>  Sharding with PHP. <br></li></ol><br>  Specialized solutions from what really works are GlusterFS.  This is what you can set yourself.  It works, it is fast, gives the same interface as NFS, only works at a normal, tolerable speed. <br><br>  And Amazon S3 is, if you're in the Amazon cloud, is also a good file system. <br><br>  If you implement from the side of PHP, there is a wonderful library Flysystem, covered with excellent tests, it can be used to work with all sorts of file systems, which is very convenient.  If you immediately write all the work with files with this library, then it will be easy to transfer from the local file system to Amazon S3 or others - to rewrite the line in the config file. <br><br>  How it works?  A user loads a file from a browser, he can either get to the frontend and crawl out of file servers from there, or a script for the upload is made on each file server and the file is uploaded directly to the file system.  Well and, in parallel, it is written to the database, which file on which server is lying, and we can read it directly from there. <br><br>  It is best to distribute files with nginx or Varnish, but it's best to do everything with nginx, since  we all love and use him - he will cope, he is good. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/943/c2a/04c/943c2a04cdaab8c419dbdcfb234a3e88.png"><br><br>  What is going on with the database? <br><br>  If everything has come up against the PHP code, we are doing a bunch of front-ends and still accessing the same database - it will cope for a long time.  If the load is not terrible, then the database lives well.  For example, we did JOINs with 160 million rows in the table, and everything was fine, everything ran well, but there, however, the RAM needed to be allocated more for buffers, for cache ... <br><br>  What to do with the database, if we rested in it?  There are techniques such as replication.  Usually, master slave replication is done; there is a replication master master.  You can replicate manually, you can do sharding and you can do partitioning. <br><br>  What is a master slave? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c51/962/949/c519629494f87f8a4e711dd31f15989a.png"><br><br>  One server is selected as the main server and a bunch of servers are secondary.  It is written on the main one, and we can read from the master, but we can also read from the slaves (in the picture, the red arrows are what we write, the green arrows are what we read).  In a typical project, we have read operations much more than write operations.  There are atypical projects. <br><br>  In the case of a typical project, a large number of slaves can relieve both the master and, in general, increase the speed of reading. <br><br>  It also provides fault tolerance - if one of the slaves has fallen, then nothing needs to be done.  If a master falls, we can quickly make one of the slaves a master.  True, this is usually not done automatically, it is an emergency situation, but there is a possibility. <br><br>  Well, and backups.  Database backups do everything differently, sometimes it is done by a MySQL dump, while it freezes the entire project tightly, which is not very good.  But if you make a backup from some slave, after stopping it, the user will not notice anything.  It's fine. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, on the slaves, you can do heavy calculations, so as not to affect the main base, the main project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is such a thing as read / write split. There are 2 server pools being made - a master, a slave, a connection on demand, and the logic for choosing a connection varies. </font><font style="vertical-align: inherit;">The point is that if we always read from slaves, and always write to the master, there will be a small ambush:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b53/af2/2c9/b53af22c9edc748aa2d44f65a09effdb.png"><br><br>  those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">replication is not immediate, and there is no guarantee that it will be executed when we make any request. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two types of samples:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for reading or for output; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for recording, i.e., when we have chosen something and then it needs to be changed and written back. </font></font><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the sample is for recording, then we can either always read from the master and write to the master, or we can execute ‚ÄúSHOW SLAVE STATUS‚Äù and see Seconds_Behind_Master there (for PostgreSQL there is also a super query in the picture) - it will show us a number. If this is 0 (zero), it means that everything has already been replicated in our country, we can safely read it from the slave. If the number is greater than zero, then we must look at the value ‚Äî either we should wait a bit and then read from the slave, or read from the master immediately. If we have NULL, it means that we have not yet replicated, something is stuck, and we need to look at the logs.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reasons for this lag are either a slow network, or the replica fails, or too many slaves (more than 20 to 1 master). If the network is slow, then it is understandable, it must be somehow accelerated, assembled into single data centers, etc. If the replica fails, then you need to add replicas. If there are too many slaves, then you have to come up with something interesting, most likely, to do some kind of hierarchy. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is a master master?</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ab/53a/7c3/8ab53a7c3a34a292b6b793b4c9b38cae.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a situation where there are several servers, and it is written everywhere and read. The advantage is that it can be faster, it is fault tolerant. In principle, everything is the same as that of the slaves, but the logic, in general, is simple - we simply choose a random connection and work with it. Cons: the replication lag is higher, there is a chance to get some inconsistent data, and if any breakdown occurred, it starts to spread over all the masters, and no one knows what kind of master is normal, what kind of broken ... This whole thing begins to replicate by circle, i.e. very weakly clogs the network. In general, if you had to do a master-master, you need to think 100 times. Most likely, you can get by with a master slave. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can always replicate with your hands, i.e. organize a couple of connections and write immediately in 2, 3, or something to do in the background.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is sharding? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, this spreading data across multiple servers. You can shard individual tables. Take, for example, a photo table, a user table, etc., we take them to separate servers. If the tables were large, then everything becomes smaller, memory eats less, everything is fine, only JOIN'it is impossible and you have to make queries of the WHERE IN type, i.e. First we select a bunch of ID's, then we substitute all these ID's for the request, but to another connection, to another server. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can shard some of the same data, that is, for example, we take and make several databases with users.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f45/a27/de8/f45a27de87c67a83309d979fb0d37bb2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can simply select the server - the remainder of the division by the number of servers. </font><font style="vertical-align: inherit;">The alternative is to get a card, i.e. </font><font style="vertical-align: inherit;">for each record, keep in some Redis or the like. </font><font style="vertical-align: inherit;">value key, i.e. </font><font style="vertical-align: inherit;">where is the record. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is an easier option: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/edc/9b1/287/edc9b1287eb42cf2e84b44d3dac2ffb9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harder is when you cannot group the data. </font><font style="vertical-align: inherit;">You need to know the ID of the data to get them. </font><font style="vertical-align: inherit;">No JOIN, ORDER, etc. </font><font style="vertical-align: inherit;">In fact, we are reducing our MySQL or PostgreSQL to a key-valuation storage, because we can not do anything with them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Common tasks become unusual:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Select TOP 10. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Page breakdown. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Choose the lowest cost. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Select user posts X. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we zashardirovali so that everything scattered across all servers, it is already beginning to be solved very nontrivially. </font><font style="vertical-align: inherit;">In this situation, the question arises - why should we, in general, SQL? </font><font style="vertical-align: inherit;">Shouldn't we write to Redis right away? </font><font style="vertical-align: inherit;">Did we choose the right storage? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Out of the box, sharding is supported by such things as:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memcache; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Redis; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cassandra (but she, they say, does not cope at some point and begins to fall). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to deal with statistics? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often they like to count statistics from the main server - from a single database server. This is fine, but requests in statistics are usually creepy, multi-page, etc., therefore, it is a big mistake to consider statistics on the main data. For statistics, in most cases, realtime is not needed, so we can set up a master slave replication and already calculate these statistics on the slave. Or we can take something ready - Mixpanel, Google Analytics or the like.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d6/0da/227/9d60da227f59afd30af4e683928e0368.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the main idea that helps to spread everything across different servers and scale. Firstly, a profit is immediately visible from this - even if you have one server and you start to do something in the background, the user gets an answer much faster, but later spreads the load, i.e. we can drag all this processing to another server, we can even process it in PHP. For example, in Stay.com, the pictures are resized on Go.</font></font><br><br>  How? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can immediately take Gearman. This is a finished piece for processing in the background. There are libraries for PHP, drivers ... And you can use queues, i.e. ActiveMQ, RabbitMQ, but the queues send only messages, they don‚Äôt call the handlers themselves, they don‚Äôt execute, and then you have to think of something. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The general sense is always the same - there is the main software, which places some data in the queue (usually this is ‚Äúwhat to do?‚Äù And data for this), and some service ‚Äî it either gets enough or it arrives (if the queue is able to actively to lead) this data, it processes everything in the background. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's go to the architecture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most important thing when scaling is to make as little connectivity as possible in the project. The less connectedness, the easier it is to change one solution to another, the easier it is to transfer part to another server.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connectivity happens in the code. SOLID, GRASP - these are the principles that allow to avoid cohesion precisely in the code. But coherence in the code for the separation of the servers, of course, affects, but not as much as the coherence of the domain layer with our environment. If we write a lot of code in the controller, it turns out that we will probably not be able to use it in another place. It will not be easy for us to transfer all this from the web controller to the console and, accordingly, it is more difficult to transfer to other servers and process there differently. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/7b2/bfd/4797b2bfdf92e8d8d819b4c910a6c276.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service-oriented architecture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 2 approaches to partitioning systems:</font></font><br><br><ol><li>     , .., ,  ,   ,   ,      .. <br><br>  ,    ,   ..      ‚Ä¶ ,     Sales   Customer ‚Äî   ,     ,    ,      .      ,    ; <br></li><li>   ‚Äî     , ..    Sales  Customer   user,    2  user.        ,      -.     ,           . <br><br>   ,       . ,   ,  Sales  - ,      ,    ,     ¬´¬ª   . <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is with the domain layer? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The domain layer is divided into some services, etc. </font><font style="vertical-align: inherit;">- This is important for the development of the application, but for scaling its design is not very important. </font><font style="vertical-align: inherit;">In the domain layer, it is extremely important to separate it from the environment, the context in which it runs, i.e. </font><font style="vertical-align: inherit;">from the controller, console environment, etc., so that all models can be used in any context. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are 2 books about the domain layer, which I advise everyone:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúDomain-Driven Design: Tackling Complexity in the Heart of Software‚Äù by Eric Evans, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Implementing Domain-Driven Design, Implementing Domain-Driven Design". </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I also advise you to follow the links: </font></font><br><br><ul><li>  BoundedContext ‚Äî <a href="http://martinfowler.com/bliki/BoundedContext.html">http://martinfowler.com/bliki/BoundedContext.html</a> (,     ‚Äî        ,   <br> ,     ,    user); <br></li><li>  DDD   ‚Äî <a href="http://martinfowler.com/tags/domain%2520driven%2520design.html">http://martinfowler.com/tags/domain%20driven%20design.html</a> ‚Äî     . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In architecture, again, it is necessary to adhere to the principle of share nothing, i.e. if you want to do something general, always do it consciously. Logic is preferably thrown on the side of the application, but in this it is worth knowing the measure. You should never, say, do stored procedures in a DBMS, because it is very difficult to scale. If it is transferred to the application side, then it becomes easier - we will make several servers and everything will be executed there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Don't underestimate browser optimization. As I have already said, of those 300-600 ms, which requests are executed on the server, 300-600 ms are added to them, which are spent on the client. The client doesn‚Äôt care if the server is fast or if the site worked so quickly, so I advise using Google PageSpeed, etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As usual, abstraction and fragmentation are not at all free. If we break up the service into many microservices, then we will no longer be able to work with beginners and will have to pay our team a lot and a lot to dig through all the layers, to sort through all the layers, besides this the service may start to work more slowly. If in compiled languages ‚Äã‚Äãit is not scary, then in PHP, at least until version 7, it is not very ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never act blindly, always monitor, analyze. Blindly, almost all the default solutions are wrong. Think! Do not believe that there is a "silver bullet", always check. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some more useful links: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/2d2/292/4ea2d2292ff8b8c042ea454189e2be26.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On </font></font><a href="http://ruhighload.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruhighload.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost all principles are painted in a super-accessible form, very superficially, but coolly, with drawings, etc. </font><font style="vertical-align: inherit;">I advise you there to look at the reviews of how various large companies found cool solutions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the English-speaking Internet, the word ‚Äúhighload‚Äù is not known, so search there by the word ‚Äúsclability‚Äù. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/42b/2a8/06442b2a88d7fd3fc0f67f0a0a2e5c23.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often it is tried on live servers. </font><font style="vertical-align: inherit;">To do this in any case is not necessary, there are such cool things as DigitalOcean and Linode, where you can raise the node, deploy any environment there, any server, potest everything, paying for it 1-2 bucks, maximum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Full slides of this speech, see </font></font><a href="http://slides.rmcreative.ru/2015/horizontal-scaling-highload/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slides.rmcreative.ru/2015/horizontal-scaling-highload/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and blog </font></font><a href="http://rmcreative.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rmcreative.ru</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://habrahabr.ru/users/samdark/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SamDark</font></font></a> <br><br><blockquote> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This report is a transcript of one of the best speeches at the </font><font style="vertical-align: inherit;">2015 </font></font><a href="http://junior.highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++ Junior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> high-load system developers training conference </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Junk! </font><font style="vertical-align: inherit;">- you say. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Eternal values! </font><font style="vertical-align: inherit;">- we will answer.</font></font><br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> <font color="gray"><br><br></font>  <font color="gray">Well, the main news is that we have begun preparations for the spring festival " <a href="http://ritfest.ru/">Russian Internet Technologies</a> ", which includes eight conferences, including <strong>HighLoad ++ Junior</strong> .</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/319526/">https://habr.com/ru/post/319526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319514/index.html">Translation of Nuxt.JS documentation</a></li>
<li><a href="../319516/index.html">My home data center</a></li>
<li><a href="../319518/index.html">Neurogrid plays dota</a></li>
<li><a href="../319520/index.html">Uncontrolled components in React</a></li>
<li><a href="../319524/index.html">Sound generation for Unity projects using Chuck and OSC</a></li>
<li><a href="../319528/index.html">A person. Commander Norton</a></li>
<li><a href="../319530/index.html">Shadow on the fence, or 25 trees for Adam Jensen</a></li>
<li><a href="../319532/index.html">Indecently simple implementation of indecently simple maze generation algorithm</a></li>
<li><a href="../319534/index.html">Registration is open or NeoQUEST, you are just a space</a></li>
<li><a href="../319536/index.html">Performance Optimization in React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>