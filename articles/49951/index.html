<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>1. Metaprogramming patterns - 25 kyu. Eval method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programming, which I occasionally continue to do, is gradually changing its style and is increasingly associated with metaprogramming. At the same tim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>1. Metaprogramming patterns - 25 kyu. Eval method</h1><div class="post__text post__text-html js-mediator-article"> Programming, which I occasionally continue to do, is gradually changing its style and is increasingly associated with metaprogramming.  At the same time, it is impossible to say that normal programming is disgusted with me.  Just like any programmer, I am looking for ways to become increasingly modular, short, intelligible, and flexible code, and in metaprogramming I see an untapped potential (despite the long-term endless Internet flood on metaprogramming going from Lisp).  :) <br><br>  I want to start a blog dedicated to Ruby metaprogramming. <br><a name="habracut"></a><br>  The choice of Ruby is connected with the fact that the culture of metaprogramming in the environment of Ruby programmers has already been largely formed, and the elements of metaprogramming have become the fabric of the daily work of the Ruby programmer, and, besides, he is better known to me than other dynamic languages. <br><br>  I read and lecture on Ruby &amp; Rails &amp; Metaprogramming at the Physics and Technology Institute;  materials of one of the lectures can be found <a href="http://acm.mipt.ru/twiki/bin/view/Ruby/MetaProgrammingInRubyLecture">here</a> .  It is briefly about the main thing in the pictures. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this blog I will try to present the topic consistently and in detail.  I take a deep breath in advance, because the task is not simple.  I hope for your encouraging feedback. <br><br>  I'll start with a simple one - with a definition. <br><br>  Metaprogramming in scripting languages ‚Äã‚Äãis a style of writing programs, which usefully uses the ability to change the namespace at runtime. <br><br>  The namespace refers to classes, methods, and variables (global, local, instance variable, and class variables).  Change means creating, changing, and deleting classes, methods, and variables. <br><br>  It must be said that in most scripting languages ‚Äã‚Äãthe namespace is constructed in no other way than in runtime mode.  But many do not remember this, so I emphasized it in the definition.  If we remove the unnecessary mention of runtime from the definition, then the phrase ‚Äúwith benefit‚Äù will remain.  So the essence of it. <br><br>  An example of useless programming: <code>eval "s = 'eval s'; eval s"</code> <br><br><h2>  Calculator </h2><br><br>  I remember how in deep childhood I wrote for BK-0010 a program for plotting functions.  The functions are hardcoded and when the program was running you could only select one function from the list and specify the range [x0, x1], and the range along the Y axis (about the miracle of programmer thought! Capable of automating everything and everyone) was automatically selected by the program. <br><br>  I looked at my program in BASIC and experienced ecstasy.  But then a sad thought came to me: ‚ÄúEhh !!!  And it‚Äôs a pity all the same, that it‚Äôs impossible to drive a formula of the function I need right during the program‚Äôs execution. <br><br>  NDA ... 8th grade, 1992, Kirovo-Chepetsk.  A lot of water has flowed since then, but the problems are the same! <br><br>  Why am I doing this? <br><br>  Here is the code for an interactive ‚Äúcalculator‚Äù in Ruby: <br><br><pre> while line = readline
   puts eval (line) .inspect
 end
</pre><br>  or better <br><pre> while (print "&gt;"; true) and line = readline
   puts eval (line) .inspect
 end
</pre><br>  or right <br>  <font><font color="#a020f0">require</font> <font color="#6a5acd">'</font> <font color="#ff00ff">readline</font> <font color="#6a5acd">'</font></font> <font><br></font>  <font><font color="#804040"><b>while</b></font> line = <font color="#2e8b57"><b>Readline</b></font> .readline ( <font color="#6a5acd">"</font> <font color="#ff00ff">&gt;</font> <font color="#6a5acd">"</font> )</font> <font><br></font>  <font><font color="#804040"><b>begin</b></font></font> <font><br></font>  <font>puts <font color="#804040"><b>eval</b></font> (line) .inspect</font> <font><br></font>  <font><font color="#804040"><b>rescue</b></font> =&gt; e</font> <font><br></font>  <font>puts e.to_s + <font color="#6a5acd">"</font> <font color="#6a5acd">\ n</font> <font color="#6a5acd">"</font> + e.backtrace.join ( <font color="#6a5acd">"</font> <font color="#6a5acd">\ n</font> <font color="#6a5acd">"</font> )</font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br><br></font> <br>  Execution Example: <br><pre> artem @ laptop: ~ / meta-lectures $ ruby ‚Äã‚Äãconsole.rb 
 &gt; 1 + 2
 3
 &gt; "hello"
 "hello"
 &gt; def fib (n) (0..1) === n?  1: fib (n-1) + fib (n-2) end
 nil
 &gt; (0 ... 10) .map {| n |  fib (n)}
 [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
 &gt; 1/0
 (eval): 1: in `/ ': divided by 0
 console.rb: 4
 (eval): 1  
 &gt; exit
 artem @ laptop: ~ / meta-lectures $
</pre><br>  In scripting languages, there is an <code>eval</code> method that receives a string and executes this string in the current context as (almost so) as if it were written by a programmer at the place of the <code>eval</code> call. <br><br>  Actually, the means similar to <code>eval</code> are in compiled programming languages. <br><br>  By the way, I would not refer the <code>eval</code> method to metaprogramming and would even call it an extremely harmful method for this occupation.  Interactive ruby ‚Äã‚Äã| python | perl | ...- shell - perhaps one of the few examples where it should be used.  Let's talk about the harm of the <code>eval</code> method further. <br><br><h2>  attr_accessor </h2><br><br>  To determine the attributes of instances of a class, the <code>attr_accessor</code> construct <code>attr_accessor</code> used even by ruby ‚Äã‚Äãnovices, it is not always true that this is a beast. <br><br>  The meaning of the expression <code>attr_accessor</code> from the following statement: code <br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Song</b></font></font> <font><br></font>  <font><font color="#804040"><b>attr_accessor</b></font> <font color="#ff00ff">: title</font> <font color="#804040"><b>,:</b></font> <font color="#ff00ff">length</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br>  equivalent to (by result) code <br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Song</b></font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">title</font></font> <font><br></font>  <font><font color="#008080">@title</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">title =</font> (v)</font> <font><br></font>  <font><font color="#008080">@title</font> = v</font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">length</font></font> <font><br></font>  <font><font color="#008080">@length</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">length =</font> (v)</font> <font><br></font>  <font><font color="#008080">@length</font> = v</font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br>  So much for the definition! <br><br>  With the naked eye, it can be seen that <code>attr_accessor</code> is useful because it responds to the programmer‚Äôs internal desire to <code>attr_accessor</code> code short and intelligible.  The <code>attr_accessor</code> construction can be translated as ‚ÄúI want set- and get-methods for the following attributes of class instances‚Äù. <br><br>  The design of <code>attr_accessor</code> not even an unknown beast at all (read - it is not a built-in language construct), but an ordinary method that you can program yourself.  Let's do this with the <code>eval</code> method. <br><br>  <font><font color="#a020f0">def</font> <font color="#008080">attr_accessor</font> (* methods)</font> <font><br></font>  <font>methods.each <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">method</font> |</font> <font><br></font>  <font><font color="#804040"><b>eval</b></font> <font color="#6a5acd">% {</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= (v)</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= v</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br><font color="#ff00ff">&nbsp;&nbsp;&nbsp;&nbsp;</font></font>  <font><font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br>  Now, <code>attr_accessor</code> , receiving as an argument an array of attribute names, for each name, executes lines of code that define the corresponding set and get methods. <br><br>  The ability to write methods like <code>attr_accessor</code> appeared because Ruby does not have the concept of defining a class or method.  Having written the line " <code>class Song</code> " we just moved to some new context in which you can do normal calculations, and the construction " <code>def xxx() ... end</code> " is just one of the expressions, the result of which is always <code>nil</code> (in ruby ‚Äã‚Äãv1.8 ), and the side effect is manifested in the emergence of the " <code>xxx</code> " method in the class in the context of which this construction was executed. <br><br>  Function definition fulfilled?  Switched to class context?  What kind of nonsense?  - it is not known from where the C ++ programmer, who came here, asks.  Yes exactly. <br><br>  A ‚Äú <code>class Song</code> ‚Äù does not frame the definition of a class in front, but makes a transition to a special context in which the namespace scope changes;  that is, there are some new methods that we can call in this context, the meanings and effects of certain instructions change, etc.  etc. <br><br>  The text " <code>def xxx() ... end</code> " is really an expression and is executed by the Ruby virtual machine.  In this case, the inside of the method definition is not executed, but the code is translated into byte and is stored under the method name. <br><br><h4>  Q: What does class context mean? </h4><br>  A: This is the context in which the expression self equals some class. <br><br>  Run the following code: <br>  <font>puts <font color="#6a5acd">"</font> <font color="#ff00ff">hi1 from</font> <font color="#6a5acd"># {</font> <font color="#ff00ff">self</font> .inspect <font color="#6a5acd">}</font> <font color="#6a5acd">"</font></font> <font><br></font>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Abc</b></font></font> <font><br></font>  <font>puts <font color="#6a5acd">"</font> <font color="#ff00ff">hi2 from</font> <font color="#6a5acd"># {</font> <font color="#ff00ff">self</font> .inspect <font color="#6a5acd">}</font> <font color="#6a5acd">"</font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">hi</font></font> <font><br></font>  <font>puts <font color="#6a5acd">"</font> <font color="#ff00ff">hi3 from</font> <font color="#6a5acd"># {</font> <font color="#ff00ff">self</font> .inspect <font color="#6a5acd">}</font> <font color="#6a5acd">"</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br>  Lines with hi1 and hi2 will be printed.  You will see the line with hi3 if you add <br><pre> Abc.new.hi
</pre><br>  Total get: <br><pre> artem @ laptop: ~ / meta-lectures $ ruby ‚Äã‚Äãself_in_contexts.rb 
 hi1 from main
 hi2 from abc
 hi3 from # &lt;Abc: 0xb7c3d9dc&gt;
 artem @ laptop: ~ / meta-lectures $
</pre><br>  You need to understand that when you write <br><pre> my_method (arg1, arg2)
</pre><br>  then essentially the front is implicitly substituted with " <code>self.</code> ": <br><pre> self.my_method (arg1, arg2)
</pre><br><br><div class="spoiler">  <b class="spoiler_title">But these two expressions are not equivalent in some cases.</b> <div class="spoiler_text">  For example, when <code>my_method</code> is a <code>private</code> method, the expression <code>self.my_method</code> will fail to invoke the <code>private</code> method.  These features of the Ruby implementation are <code>private</code> methods and there are some methods that cannot be called via a dot. <br></div></div><br><br>  Okay, stop talking.  <code>attr_accessor</code> above <code>attr_accessor</code> code to make it work: <br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Module</b></font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">attr_accessor</font> (* methods)</font> <font><br></font>  <font>methods.each <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">method</font> |</font> <font><br></font>  <font><font color="#804040"><b>class_eval</b></font> <font color="#6a5acd">% {</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= (v)</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= v</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br><font color="#ff00ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font>  <font><font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br>  What have we done?  We placed the method definition in the context of the <code>Module</code> class and replaced <code>eval</code> with <code>class_eval</code> . <br><br>  Why did we do that?  There are reasons: <br>  * It is not good to write methods without understanding for what objects they will be available.  We need to write a method <code>attr_accessor</code> , which can be used in the context of classes (instances of class <code>Class</code> ) and modules (instances of class <code>Module</code> ).  The <code>Class</code> class inherits from the <code>Module</code> class, therefore it is sufficient to define this method as a method of <code>Module</code> instances, then it will be available for both modules and classes. <br>  * The <code>class_eval</code> method has its differences from <code>eval</code> , in particular, the latter, when executing the expression " <code>def ... end</code> ", will create a definition of a method locally living inside the <code>attr_accessor</code> method and available only during the execution of the <code>attr_accessor</code> method (this is the undocumented <code>def</code> <code>attr_accessor</code> inside <code>def</code> ).  The <code>class_eval</code> method executes the given code in the correct context, so that the " <code>def</code> " begin to produce the desired result.  The <code>class_eval</code> method <code>class_eval</code> actively used in metaprogramming precisely in the variant where its argument is a block, not a string. <br><br>  So now the code works.  But he is wrong.  There are other <b>wrong decisions</b> , including without the " <code>class Module</code> " and " <code>class_eval</code> ".  Here is one of them: <br><br>  <font><font color="#a020f0">def</font> <font color="#008080">attr_accessor</font> (* methods)</font> <font><br></font>  <font>methods.each <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">method</font> |</font> <font><br></font>  <font><font color="#804040"><b>eval</b></font> <font color="#6a5acd">% {</font></font> <font><br></font>  <font><font color="#ff00ff">class</font> <font color="#6a5acd"># {</font> <font color="#ff00ff">self</font> <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= (v)</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= v</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br><font color="#ff00ff">&nbsp;&nbsp;&nbsp;&nbsp;</font></font>  <font><font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br><br></font> <br>  The last option is bad because you can call it not in the context of a class and get something bad, depending on what the <code>self</code> expression is in this context.  For example: <br>  <font>s = <font color="#6a5acd">"</font> <font color="#ff00ff">Class</font> <font color="#6a5acd">"</font></font> <font><br></font>  <font>s.instance_eval { <font color="#804040"><b>attr_accessor</b></font> <font color="#ff00ff">: hahaha</font> }</font> <font><br></font>  <font><font color="#2e8b57"><b>Array</b></font> .hahaha = <font color="#ff00ff">3</font> <font color="#0000ff"># in an unexpected way. The haray attribute of Array appeared.</font></font> <font><br></font>  <font>puts <font color="#2e8b57"><b>Array</b></font> .hahaha <font color="#0000ff">#</font></font> <font><br></font> <br><br>  THE MOST IMPORTANT: <br>  The described definitions of <code>attr_assessor</code> using <code>eval</code> are bad because they are not protected from the malicious intent of the enemy, nor from the stupidity of the programmer: if the value of the <code>method</code> variable is not a valid string for the method name, for example, the string " <code>llalala(); puts `cat /etc/passwd`; puts</code> ", the consequences will be unpredictable.  You may not see any errors (exceptions) while executing the program;  surprises will get only when ‚Äúwhen the rocket will already fly‚Äù (c).  There is nothing worse than errors that appear late, when the ends are no longer found. <br><br>  Let's write, finally, the correct definition of <code>attr_accessor</code> .  He, unlike the wrong, is unique: <br><br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Module</b></font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">attr_accessor</font> (* methods)</font> <font><br></font>  <font>methods.each <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">method</font> |</font> <font><br></font>  <font><font color="#804040"><b>raise</b></font> <font color="#2e8b57"><b>TypeError</b></font> .new ( <font color="#6a5acd">"</font> <font color="#ff00ff">method name is not symbol</font> <font color="#6a5acd">"</font> ) <font color="#804040"><b>unless</b></font> method.is_a? ( <font color="#2e8b57"><b>Symbol</b></font> )</font> <font><br></font>  <font>define_method (method) <font color="#804040"><b>do</b></font></font> <font><br></font>  <font>instance_variable_get ( <font color="#6a5acd">"</font> <font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#6a5acd">"</font> )</font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font>define_method ( <font color="#6a5acd">"</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">=</font> <font color="#6a5acd">"</font> ) <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">v</font> |</font> <font><br></font>  <font>instance_variable_set ( <font color="#6a5acd">"</font> <font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#6a5acd">"</font> , v)</font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br><br><h2>  <code>attr_accessor</code> with default value </h2><br>  We often write attributes with a default value.  We do this using the idiom " <code>||=</code> ", which roughly translates as "initialize what is left, what is right if it has not yet been initialized": <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Song</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class"> ||= 0 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class"> ||= "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class">" </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Song</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">length</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#=&gt; 0 Song.new.title #=&gt; "no title"</span></span></span></span></code> </pre><br>  after this definition, the value of the <code>length</code> attribute of the new song will be 0. <br><br>  According to my wish, according to my wish ... let this code work the way I want !!!: <br><pre> class Song
   attr_accessor: length,: default =&gt; 0
   attr_accessor: title,: default =&gt; "no title"
 end
</pre><br>  Let's write for learning purposes the wrong code using <code>class_eval</code> from the string: <br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Module</b></font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">attr_accessor</font> (* methods)</font> <font><br></font>  <font>options = methods.last.is_a? ( <font color="#2e8b57"><b>Hash</b></font> )?</font>  <font>methods.pop: {}</font> <font><br></font>  <font>methods.each <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">method</font> |</font> <font><br></font>  <font><font color="#804040"><b>class_eval</b></font> <font color="#6a5acd">% {</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">\ # never write like that!</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font></font> <font><font color="#ff00ff">&nbsp;</font></font>  <font><font color="#6a5acd"># {</font> <font color="#6a5acd">"</font> <font color="#ff00ff">|| =</font> <font color="#6a5acd"># {</font> options [ <font color="#ff00ff">: default</font> ] <font color="#6a5acd">}</font> <font color="#6a5acd">"</font> <font color="#804040"><b>if</b></font> options [ <font color="#ff00ff">: default</font> ] <font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br></font>  <font><font color="#ff00ff">def</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= (v)</font></font> <font><br></font>  <font><font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">= v</font></font> <font><br></font>  <font><font color="#ff00ff">end</font></font> <font><br><font color="#ff00ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></font>  <font><font color="#6a5acd">}</font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <br>  May there be a miracle !!! <br><pre> class Song
   attr_accessor: length,: default =&gt; 42
 end
 puts Song.new.length # prints 42 !!!
</pre><br><br>  Wrong code also sometimes works.  But this, of course, is no reason not to be fired by the programmer who writes it. <br><br>  By doing <br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Song</b></font></font> <font><br></font>  <font><font color="#804040"><b>attr_accessor</b></font> <font color="#ff00ff">: length</font> <font color="#804040"><b>,:</b></font> <font color="#ff00ff">default</font> =&gt; <font color="#ff00ff">42</font></font> <font><br></font>  <font><font color="#804040"><b>attr_accessor</b></font> <font color="#ff00ff">: title</font> <font color="#804040"><b>,:</b></font> <font color="#ff00ff">default</font> =&gt; <font color="#6a5acd">"</font> <font color="#ff00ff">no title</font> <font color="#6a5acd">"</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font>puts <font color="#2e8b57"><b>Song</b></font> .new.length <font color="#0000ff"># prints 42 !!!</font></font> <font><br></font>  <font>puts <font color="#2e8b57"><b>Song</b></font> .new.title <font color="#0000ff"># oooooops !!!</font></font> <font><br><br></font> <br>  we get mysterious: <br><pre> artem @ laptop: ~ / meta-lectures $ ruby ‚Äã‚Äãbad_attr_accessor.rb 
 42
 (eval): 5: in `title ': stack level too deep (SystemStackError)
	 from (eval): 5: in `title '
	 from bad_attr_accessor.rb: 27
 artem @ laptop: ~ / meta-lectures $ 
</pre><br>  Why did such a nuisance arise?  The fact is that there is a fundamental problem: inserting some objects into the line is simply impossible. <br><br>  Correctly the problem of <code>attr_accessor</code> with the default value is solved as follows: <br><br>  <font><font color="#a020f0">class</font> <font color="#2e8b57"><b>Module</b></font></font> <font><br></font>  <font><font color="#a020f0">def</font> <font color="#008080">attr_accessor</font> (* methods)</font> <font><br></font>  <font>options = methods.last.is_a? ( <font color="#2e8b57"><b>Hash</b></font> )?</font>  <font>methods.pop: {}</font> <font><br></font>  <font>methods.each <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">method</font> |</font> <font><br></font>  <font><font color="#804040"><b>raise</b></font> <font color="#2e8b57"><b>TypeError</b></font> .new ( <font color="#6a5acd">"</font> <font color="#ff00ff">method name is not symbol</font> <font color="#6a5acd">"</font> ) <font color="#804040"><b>unless</b></font> method.is_a? ( <font color="#2e8b57"><b>Symbol</b></font> )</font> <font><br></font>  <font>define_method (method) <font color="#804040"><b>do</b></font></font> <font><br></font>  <font>instance_variable_get ( <font color="#6a5acd">"</font> <font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#6a5acd">"</font> ) ||</font> <font><br></font>  <font>instance_variable_set ( <font color="#6a5acd">"</font> <font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#6a5acd">"</font> , options [ <font color="#ff00ff">: default</font> ])</font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font>define_method ( <font color="#6a5acd">"</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#ff00ff">=</font> <font color="#6a5acd">"</font> ) <font color="#804040"><b>do</b></font> |</font>  <font><font color="#008080">v</font> |</font> <font><br></font>  <font>instance_variable_set ( <font color="#6a5acd">"</font> <font color="#ff00ff">@</font> <font color="#6a5acd"># {</font> method <font color="#6a5acd">}</font> <font color="#6a5acd">"</font> , v)</font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#804040"><b>end</b></font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font>  <font><font color="#a020f0">end</font></font> <font><br></font> <br><br>  So, in the examples reviewed, metaprogramming looks like writing methods that define methods. <br><br>  It makes sense for a beginner metaprogrammer to google such search queries: <br>  1. ruby ‚Äã‚Äãdoc attr_accessor <br>  2. ruby ‚Äã‚Äãdoc Kernel <a href="http://www.ruby-doc.org/core/classes/Kernel.html">eval</a> <br>  3. ruby ‚Äã‚Äãdoc Module <a href="http://www.ruby-doc.org/core/classes/Module.html">class_eval</a> <br>  4. ruby ‚Äã‚Äãdoc Object <a href="http://www.ruby-doc.org/core/classes/Object.html">instance_eval</a> <br>  5. ruby ‚Äã‚Äãdoc Object <a href="http://www.ruby-doc.org/core/classes/Object.html">is_a?</a> <br>  The first links are correct. <br><br>  How to metaprogram without <code>eval</code> , as well as about impurities, modifier methods, which allow to transfer abstraction tasks related to caching, RPC, DSL, patterns, continuing ideas of deferred (lazy) calculations, etc. to a new level. Read in future releases of the blog. </div><p>Source: <a href="https://habr.com/ru/post/49951/">https://habr.com/ru/post/49951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../49946/index.html">Want to seduce a girl? Buy a laptop!</a></li>
<li><a href="../49947/index.html">Fresh Trojan for MacOS</a></li>
<li><a href="../49948/index.html">Performance Trick in Windows 7</a></li>
<li><a href="../49949/index.html">Use Python to process HTML forms.</a></li>
<li><a href="../49950/index.html">Official Comic Fallout 3</a></li>
<li><a href="../49953/index.html">I would go to Jabbers ...</a></li>
<li><a href="../49955/index.html">Dynamic creation of exCanvas</a></li>
<li><a href="../49956/index.html">Startup behind glass - minds are invited. Part 2</a></li>
<li><a href="../49957/index.html">Patch and collect pidgin at home</a></li>
<li><a href="../49958/index.html">Jabber bot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>