<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of Microsoft web frameworks. ASP.NET vNext</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prerequisites for change 
 The news about the release of ASP.NET vNext on the network spread quite quickly along with the announcement of the most int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of Microsoft web frameworks. ASP.NET vNext</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/34c/7a0/001/34c7a00016a5527738114609ddc77444.png"><br><br><h4>  Prerequisites for change </h4><br>  The news about the release of ASP.NET vNext on the network spread quite quickly along with the announcement of the most interesting innovations proposed in the update.  ASP.NET MVC 6 has received a new name and is positioned as something really new in the environment of Microsoft web frameworks (MS). <a name="habracut"></a>  In order to most fully understand the importance of the stated changes in vNext, recall the features of the current implementation of web applications on the .NET platform. <br><br>  A typical ASP.NET MVC application consists of a Global.asax file in which we extend the HttpApplication class (System.Web) and thus add the desired behavior for handling Http requests by configuring the individual components of MVC.  In the classic ASP.NET MVC, the Router class (System.Web.Routing) is an integral part of processing Http requests by redirecting them to the desired HttpHandler in standard behavior (MvcRouteHandler) which creates a factory of controllers and starts a further request processing pipe.  These components are obviously closely tied to a web server from MS - Internet Information Services (IIS), which uses HttpHandlers and HttpContext (access to http request / response parameters) to process requests.  The widespread use of these components in MVC inherited from ASP.NET Web Forms assumed close integration with IIS, which made it impossible to use an alternative web server for hosting applications.  Over time, these circumstances caused more and more criticism from the developer community and were not really a very favorable factor for the development of ASP.NET MVC, which, being an Open Source project, is developing much faster than Microsoft is developing updates for the System.Web components. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/55a/22e/0e4/55a22e0e46532c81f2d1e757de061985.png"><br><br>  An attempt to rectify the situation was undertaken as part of the development of the Web Api project.  During the migration from the MS WCF framework, developers abandoned the approach to building RESTful services based on the concept of "binding contracts", in favor of a more convenient MVC, which predetermined a lot in common and consonant name - ASP.NET Web Api.  In fact, the developers of the new framework were able to do it with an eye to the ASP.NET MVC shortcomings described above.  Web Api did not use these very System.Web components directly due to adapters for HttpContext.Request, HttpContext.Response - abstractions with the updated structure HttpRequestMessage, HttpResponseMessage, into which HttpControllerHandler (entry point to the Web Api application) produced  The IIS HttpHandler dependency was also eliminated by processing requests through a chain of HttpMessageHandlers (System.Net.Http) nested into each other, based on which the updated stack was implemented (filters, dispatchers, delegating handlers, controllers). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/426/426/ff8/426426ff8a9bfb831d4398b0b34416c8.png"><br><br>  All these changes allowed to make the Web Api application independent of the host and to develop the OWIN (Open Web Interface) specifications.  The key concept was the middleware - web application components (in IIS - HttpModules) and application delegate, which instead of HttpContext, interacts with a much more abstract set of request / response parameters in the hash map of the form IDictionary &lt;string, object&gt;. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed1/28d/3f5/ed128d3f5cc1a717e923fd59e6632d1f.png"><br><br>  Despite all the advantages, flexibility, improved extensibility and a number of fixes for architectural flaws, Web Api still could not become a full-fledged replacement for MVC while being focused on Single Page Applications (SPA).  At the same time, one framework did not interfere with another.  Moreover, they got along perfectly well in the same web application if IIS was used for hosting and even could use common Http modules, for example, for authentication.  Nevertheless, the considered approach required a clear division of responsibility in the application and taking into account the peculiarities that, nevertheless, Web Api and Mvc use a completely different pipeline for processing requests.  The latter added another kind of complexity to the developers and suggested the subsequent refactoring in the new version of the framework, which was called vNext. <br><br><h4>  ASP.NET vNext project template </h4><br>  The first thing that catches the eye in a new web application is the lack of web.config, packages.config, and even AssemblyInfo.cs files. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/e21/60a/11fe2160afb1ea8d23ea32c4fadbb90e.png"><br><br>  We have only two files in the solution structure: <br><ul><li>  project.json - configuration file for a project, where dependencies are located with indication of versions of connected assemblies, project compilation parameters, metadata, list of dependencies for deployment in .NET and Core CLR modes. </li><li>  Startup.cs - entry point, web application class. </li></ul><br>  Now looking at the properties of the VS project, we will not see the abundance of options with which ASP.NET projects were previously provided.  There are two tabs available: General - configuration of the namespace and type of application during the construction;  on the Debugging tab - the port number on which our application will be available. <br>  Further more interesting is the actual project.json configuration file.  It looks approximately as follows. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b33/2c2/d8e/b332c2d8ec63b0f21c07abde7af43915.png"><br><br>  The primary set provides only two keys. <br><ul><li>  dependencies - specifying dependencies for a project obtained from assemblies, NuGet Packages and even source codes on disk; </li><li>  configurations - a list of dependencies when building a project for a specific target environment: .NET or Core CLR. </li></ul><br>  Such drastic changes in the project structure are due to the use of the new Roslyn compiler, which allows compiling source code into IL at runtime and executing it.  The capabilities of Roslyn formed the basis of the new K Language Runtime (KLR) runtime.  At the moment, there are two options for launching the project in .NET Desktop mode, or Core CLR (in the alpha version, the mode is available only in KLR from under Win 8).  You can also build a project using K Versions Manager (KVM) / K Packages Manager (KPM) - console utilities supplied with K, which allow you to independently manage installed versions of KRE (K Runtime Engine), unpack applications based on project.json and run them.  For more information, check out <a href="https://github.com/aspnet/home">github.com/aspnet/home</a> . <br><br><h4>  The structure of an ASP.NET vNext web application </h4><br>  The only source code file in the project is Startup.cs, which contains a reference to the Microsoft.AspNet.Builder namespace and a class with a structure similar to OWIN based applications.  It has one method - Configure with an input parameter of type IBuilder.  The project compiles and runs, but returns nothing as an answer (or rather, returns ‚Äú403rd‚Äù, because IIS, not finding the request handler, is trying to access the file system), which is logical, since we did not add any middleware. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aac/ffe/500/aacffe500224b052486cb56bc5bb7104.png"><br><br>  On <a href="http://www.asp.net/vnext">www.asp.net/vnext</a> we are offered to call a static extension method (UseWelcomePage) to add the simplest Request Handler, but it is of little interest to us, since it hides all the specifics of the operation of the IBuilder interface.  Let's try to "dig" deeper looking at his definition: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Microsoft.AspNet.Builder</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBuilder</span></span> { IServiceProvider ApplicationServices { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IServerInformation Server { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-function">RequestDelegate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-function">IBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-function">IBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre> <br><br>  In order to navigate the code, you need to remember that the concept of middleware in OWIN directly refers to the Application Delegate, which receives the list of parameters for the Http request and performs some kind of conversion on it, returning Task. <br><br><pre> <code class="cs hljs">Func&lt;IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;, Task&gt;</code> </pre><br><br>  For OWIN, we also had a static Extensions method at the IAppBuilder interface level, which allowed adding middleware using a more convenient structured version of the context - IOwinContext.  In vNext, it has changed a bit, because it involves working with HttpContext directly.  The latter is now in the Microsoft.AspNet.Http namespace, and has nothing to do with the HttpContext from System.Web, as was the case with the HttpContextBase wrapper in ASP.NET MVC: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestDelegate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><br>  Thus, everything gradually falls into place - RequestDelegate in vNext and is thus the OWIN Application Delegate. <br>  To add a new middleware in the original implementation of the Use method, we pass a generic delegate that contains a nested delegate of the type RequestDelegate as a parameter.  The external Generic delegate refers to the entire further pipeline processing the http request, RequestDelegate - performs the work of Http Handler. <br>  Let's take a look at the example with the addition of modules - this should clarify the situation a little. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.Use(next =&gt; httpContext =&gt; httpContext.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Executed before all followers."</span></span> + Environment.NewLine) .ContinueWith(task =&gt; next(httpContext))); app.Use(next =&gt; httpContext =&gt; next(httpContext) .ContinueWith(task =&gt; httpContext.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Executed after all followers."</span></span> + Environment.NewLine))); app.Use((httpContext, next) =&gt; httpContext.Response.WriteAsync(<span class="hljs-string"><span class="hljs-string">"Hello world middleware."</span></span> + Environment.NewLine)); }</code> </pre><br><br>  As you can see, when configuring middleware, we have behavior in many ways similar to Delegating Handlers Web Api, where we can flexibly control the sequence of execution from the current module of the entire further pipeline (parameter next).  Simply add the processing of the Http request within the lambda expressions passed to Use. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/176/c17/3cc/176c173ccf79c4e67c4ec5b6582ef44e.png"><br><br>  As for OWIN itself, vNext is fully compatible with this interface.  The Microsoft.AspNet.Builder namespace contains a class of static extension methods for IBuilder, which create transition adapters from Owin Application Delegate to vNext RequestDelegate. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AddMiddleware = Action&lt;Func&lt;Func&lt;IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;, Task&gt;, Func&lt;IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;, Task&gt;&gt;&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AddMiddleware </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UseOwin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IBuilder builder</span></span></span><span class="hljs-function">)</span></span> { .... }</code> </pre><br><br>  In our application, we can use the AddMiddleware to interact between the OWIN Environment dictionary and vNext HttpContext, relying on the internal implementation of the platform.  The extension will make it quite easy to use OWIN components in the new version of the framework. <br><br>  Among the important features, it is worth noting that, unlike OWIN AppBuilder, the vNext IBuilder interface also contains the application service locator built-in, which is initialized by the application by the web server.  This property provides access to Web Host Application Level Services. <br><br><h4>  vNext HttpContext </h4><br>  With the structure of the application a little figured out what exactly is the updated vNext HttpContext.  As expected, the context class itself, Request and Response, is declared abstract.  The HttpContext in the implementation of the Microsoft.AspNet.Hosting host delivered from the ‚Äúcrumbs‚Äù is instantiated by the DefaultHttpContext object before each call to the middleware chain.  The context has an Abort method, implements the IDisposable interface, and provides two ApplicationServices and RequestServices locator services with a corresponding container life cycle, which clearly supports the more convenient formation of a Structure Map at the application level compared to previous versions of ASP.NET MVC. <br><br>  A new context extensibility mechanism has been added to vNext by using HttpFeatures.  At the level of the context interface, it provides two sets of methods for obtaining and adding extensions (via packing in the object and generic wrapper): <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFeature</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFeature</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> instance</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> T GetFeature&lt;T&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T)GetFeature(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SetFeature&lt;T&gt;(T instance) { SetFeature(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T), instance); }</code> </pre><br><br>  In the updated version of ASP.NET, this approach is used to dynamically form a context, starting from the first access to HttpContext, where Host Application / Server Specific Features are initialized to the level used by separate middleware components of the request, authentication, caching, and web sockets parameters.  In the basic implementation, Request almost completely uses the interfaces defined in Microsoft.AspNet.Builder to get components from HttpFeatures.  Forming a context in this way allows you to hide the specific implementation of the web server-specific implementation of the host-level functionality behind a specific interface of a separate component, not limited to the basic structure of HttpContex. <br><br><h4>  vNext MVC </h4><br>  The most expected innovation from the point of view of building the web application itself is certainly the combination of ASP.NET MVC and Web Api functionality within one framework, which will allow using a common pipeline to process Http requests. <br><br>  Adding MVC behavior to vNext involves connecting and configuring two middleware modules: <br><ul><li>  vNext Dependency Resolver with a list of services that form the vNext MVC stack. </li><li>  Router middleware is a MVC router module. </li></ul><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseServices(services =&gt; services.AddMvc()); app.UseMvc(router =&gt; router.MapRoute(<span class="hljs-string"><span class="hljs-string">"DefaultHome"</span></span>, <span class="hljs-string"><span class="hljs-string">"{controller}/{action}/{id?}"</span></span>, defaults: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Controller = <span class="hljs-string"><span class="hljs-string">"Home"</span></span>, Action = <span class="hljs-string"><span class="hljs-string">"Index"</span></span> })); }</code> </pre><br><br>  The first of these is a set of services that provides an implementation of standard MVC components and is used throughout the pipeline to process a request at the level of individual abstractions.  We are talking about suppliers of Action context, factory of controllers, model bindings, View Engine provision, etc.  Description of services with DI mappings is available for reference in the class Microsoft.AspNet.Mvc.MvcServices.cs. <br><br>  The second is RouterHandler, which is represented in the vNext by the IRouter interface with the asynchronous RouteAsync method: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRouter</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RouteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RouteContext context</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVirtualPath</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VirtualPathContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><br>  By default, the interface implements the MvcRouteHandler class.  Unlike previous versions of routing based on framework-specific functionality (in MVC - HttpHandler, Web Api - DelegatingHandler), this time it provides only a call for separate interface methods obtained from the service locator with a set of MVC components.  It is this class that receives the ActionContext and starts the further pipeline processing the request using the IActionInvoker service in conjunction with the ControllerFactory.  The main advantage of using this approach is obvious, it provides the necessary versatility to merge frameworks, which was absent before. <br><br>  Another positive change in the new edition of MVC was the fully asynchronous mode of executing service methods.  In a similar way, pipe was implemented in Web Api and allowed to completely remove from the workflow pool of the web server the operations associated with waiting for resources.  MVC until now only provided asynchronous controllers "out of the box". <br><br>  The Controller from MVC was taken as the main working unit for processing the Http request in vNext.  For post-processing and serialization of results of actions, the IActionResult interface is used.  The MVC functionality in this respect has remained conceptually the same.  As for the main extensions that are well proven in Web Api, they are not currently added to the vNext pipeline.  Like for example the formatting mechanism by using Content Negotiation services.  If an instance of a class that does not implement an IActionResult is returned from the controller action, a JSON formatter is used. <br><br>  The configuration mechanism of the application has been heavily modified due to the transition to the updated project template.  Now, instead of the previous web.config, config.json is used, which represents the hierarchical structure of key-value pairs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e64/53d/59f/e6453d59ff1e01dc744433aa2905d2a5.png"><br><br>  Directly at the code level, a set of utilities from the Microsoft.Framework.ConfigurationModel namespace is provided, which merges keys from various configuration sources, for example, the launch parameters of the host application passed to console K;  The pairs of web applications defined in the project.json, config.json files. <br><br>  About each of the components, as well as those that were not mentioned, you can write a separate review and for sure it will not be one.  Considering that the list of functional components of the new framework has not yet been finally approved, we restrict ourselves to the basic understanding of the work of its main components. <br><br><h4>  Results </h4><br>  After reading the alpha version of ASP.NET MVC vNext, you can really say that the changes of the developers are expected to be quite dramatic.  They are connected not only with a thorough refactoring of ASP.NET, but also with the adaptation of the framework under the updated Runtime. <br><br>  At the application level, the change in internal concepts is rather limited and will be intuitive for developers who have dealt with OWIN and previous versions of ASP.NET MVC. <br><br>  From the point of view of the framework itself, the most important is the transition to an open web interface and a clear division of responsibility between the host and the web application.  The qualitative update of the composition of abstractions and the addition of flexible extensibility opportunities open up new perspectives in the development of web applications. <br><br><h5>  Useful resources: </h5><br>  <a href="http://www.asp.net/vnext">www.asp.net/vnext</a> <br>  <a href="https://github.com/aspnet/">github.com/aspnet</a> <br>  <a href="http://blogs.msdn.com/b/webdev/archive/2014/06/03/asp-net-vnext-in-visual-studio-14-ctp.aspx">blogs.msdn.com/b/webdev/archive/2014/06/03/asp-net-vnext-in-visual-studio-14-ctp.aspx</a> <br>  <a href="http://www.asp.net/aspnet/overview/owin-and-katana">www.asp.net/aspnet/overview/owin-and-katana</a> <br>  <a href="http://blogs.msdn.com/b/dotnet/archive/2014/05/12/the-next-generation-of-net-asp-net-vnext.aspx">blogs.msdn.com/b/dotnet/archive/2014/05/12/the-next-generation-of-net-asp-net-vnext.aspx</a> </div><p>Source: <a href="https://habr.com/ru/post/226427/">https://habr.com/ru/post/226427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226417/index.html">Logic of auto-robot: from engine vision to transmission control</a></li>
<li><a href="../226419/index.html">Django on production. uWSGI + nginx. Detailed guide</a></li>
<li><a href="../226421/index.html">Shadow rendering using Parallel-Split Shadow Mapping</a></li>
<li><a href="../226423/index.html">Launch Internet Explorer Developer Channel</a></li>
<li><a href="../226425/index.html">About encryption of referrers in Yandex</a></li>
<li><a href="../226429/index.html">Amateur astronomy: a view from the inside of the community on hobbies and newcomers' rakes</a></li>
<li><a href="../226431/index.html">Wi-Fi networks: penetration and protection. 3) WPA. OpenCL / CUDA. Pick statistics</a></li>
<li><a href="../226433/index.html">The digest of interesting news and materials from the world of PHP No. 42 (June 1 - 16, 2014)</a></li>
<li><a href="../226437/index.html">Nissan and BMW will join Tesla's plans to develop electric stations</a></li>
<li><a href="../226439/index.html">Creating audio plugin, part 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>