<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apollo: 9 months - normal flight</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone, my name is Semyon Levenson, I work as a teamlead on the project ‚Äú Flow ‚Äù from the Rambler Group and I want to tell you about our exper...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apollo: 9 months - normal flight</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ww/0p/je/ww0pjeoegdfxhlx-zfh54jbxvyw.png" alt="image"></p><br><p>  Hello everyone, my name is Semyon Levenson, I work as a teamlead on the project ‚Äú <a href="https://potok.smbn.ru/">Flow</a> ‚Äù from the Rambler Group and I want to tell you about our experience in using Apollo. </p><br><p>  Let me explain what "flow".  This is an automated service for entrepreneurs that allows you to attract clients from the Internet to your business, without getting involved in advertising, and quickly create simple websites, without being an expert in layout. </p><a name="habracut"></a><br><p>  The screenshot shows one of the steps for creating a landing page. </p><br><p><img src="https://habrastorage.org/webt/rf/vg/dj/rfvgdjmcvzpwydgz9qcdu8_3eay.png"></p><br><h3 id="chto-bylo-vnachale">  What was at the beginning? </h3><br><p>  And in the beginning there was MVP, a lot of Twig, jQuery and very tight deadlines.  But we went an unusual way and decided to make a redesign.  The redesign is not in the sense of ‚Äúpatching styles‚Äù, but decided to revise the entire system operation.  And it was for us a good stage in order to assemble the perfect frontend.  After all, we, the development team, will continue to support this and implement other tasks based on this, to achieve new goals set by the product team. </p><br><p>  Our department has already gained enough expertise in using React.  I did not want to spend 2 weeks on setting up a webpack, so we decided to use the <a href="https://github.com/facebook/create-react-app">CRA</a> (Create React App).  Styles were taken for <a href="https://www.styled-components.com/">styled components</a> , and where without typing they took <a href="https://flow.org/en/">Flow</a> .  For State Management they took <a href="https://redux.js.org/">Redux</a> , but as a result it turned out that we don‚Äôt need it at all, but more on that later. </p><br><p>  We gathered our perfect frontend and realized that we had forgotten about something.  As it turned out, we forgot about the backend, but rather about the interaction with it.  When you think about what we can use to organize this interaction, the first thing that came to mind is, of course, Rest.  No, we did not go to rest (smile), but began to talk about the RESTful API.  In principle, the story is familiar, it has been dragging on for a long time, but we also know problems with it.  We will talk about them. </p><br><p>  The first problem is the documentation.  RESTful, of course, does not tell you how to organize the documentation.  Here there is a variant of using the same swagger, but in fact it is the introduction of an additional entity and the complication of processes. </p><br><p>  The second problem is how to organize support for versioning APIs. </p><br><p>  The third important problem is a large number of requests or custom endpoints that we can pile on.  Suppose we need to request posts, for these posts - comments and more authors of these comments.  In classic Rest, we have to make 3 requests at least.  Yes, we can pile up custom endpoints, and all of this is collapsed into 1 request, but this is already a complication. </p><br><p><img src="https://habrastorage.org/webt/mo/os/uv/moosuvdayfwhr7r2dqswlg9nuuk.png"><br>  <em>Thank you for the illustration, <a href="https://blog.apollographql.com/graphql-vs-rest-5d425123e34b">Sashko Stubailo</a></em> </p><br><h3 id="reshenie">  Decision </h3><br><p>  And at this moment Facebook comes to the rescue with GraphQL.  What is GraphQL?  This is a platform, but today we will look at one of its parts - it is Query Language for your API, just a language, and a rather primitive one.  And it works as simply as possible - as we request an entity, we also get it. </p><br><p>  Request: </p><br><pre><code class="hljs objectivec">{ me { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> isAcceptedFreeOffer balance } }</code> </pre> <br><p>  Answer: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"me"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"balance"</span></span>: <span class="hljs-number"><span class="hljs-number">100000</span></span> } }</code> </pre> <br><p>  But GraphQL is not only about reading, it is about changing data.  For this, there are mutations in GraphQL.  Mutations are notable in that we can declare the desired response from the backend, with a successful change.  However, there are some nuances.  For example, if our mutation affects data beyond the graph. </p><br><p>  An example of a mutation in which we use a free offer: </p><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">mutation</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">acceptOffer</span></span> (_type: FREE) { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> isAcceptedFreeOffer } }</code> </pre> <br><p>  In response, we get the same structure that was requested </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"acceptOffer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"isAcceptedFreeOffer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p>  Interaction with GraphQL backend can be accomplished using normal fetch. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/graphql'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: { <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> }, body: <span class="hljs-type"><span class="hljs-type">JSON</span></span>.stringify({ query: <span class="hljs-string"><span class="hljs-string">'{me { id balance } }'</span></span> }) });</code> </pre> <br><h3 id="kakie-zhe-plyusy-u-graphql">  What are the advantages of GraphQL? </h3><br><p>  The first and very cool advantage that you can appreciate when you start working with it is that this language is strictly typed and self-documenting.  When designing a GraphQL scheme on the server, we can immediately describe the types and attributes directly in the code. </p><br><p><img src="https://habrastorage.org/webt/7l/oh/ze/7lohze1ioujv7qchctics80_qd8.png"></p><br><p>  As mentioned above, RESTful has a versioning problem.  In GraphQL, a very elegant solution is implemented for this - deprecated. </p><br><p><img src="https://habrastorage.org/webt/zr/la/rr/zrlarrevkaenkyjdx7yzm6wbm5a.png"></p><br><p>  Suppose we have a Film, we expand it, so we have the director.  And at some point we just take out the director in a separate type.  The question arises, what to do with the last field director?  There are two answers to it: either we delete this field, or we mark it deprecated, and it automatically disappears from the documentation. </p><br><p>  Independently decide what we need. </p><br><p>  We recall the previous picture, where everything went with us REST, here we have everything combined into one request and does not require any customization from the backend development.  They once described it all, and we are already twisting, turning, juggling. </p><br><p><img src="https://habrastorage.org/webt/k2/rs/rp/k2rsrp234e3xoe6gs8jmwpy1rse.png"></p><br><p>  But not without a fly in the ointment.  In principle, GraphQL has not so many minuses on the frontend, because it was originally designed to solve the problems of the frontend.  But backend doesn't have everything as smoothly ... They have a problem like N + 1.  Take for example the query: </p><br><pre> <code class="hljs objectivec">{ landings(_page: <span class="hljs-number"><span class="hljs-number">0</span></span>, limit: <span class="hljs-number"><span class="hljs-number">20</span></span>) { nodes { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> title } totalCount } }</code> </pre> <br><p>  A simple request, we request 20 sites and the number of sites we have.  And in the backend, this can result in 21 queries to the database.  This problem is known, solved.  For Node JS there is a <a href="https://github.com/facebook/dataloader">dataloader</a> package from Facebook.  For other languages, you can find your own solutions. </p><br><p>  There is also the problem of deep nesting.  For example, we have albums, these albums have songs, and through a song we can also get albums.  To do this, make the following requests: </p><br><pre> <code class="hljs objectivec">{ album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { title artists } } }</code> </pre> <br><pre> <code class="hljs dos">{ song(id: <span class="hljs-number"><span class="hljs-number">1337</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> album { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br><p>  Thus, we get a recursive query, which also elementarily lays the base for us. </p><br><pre> <code class="hljs objectivec">query evil { album(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>) { songs { album { songs { album {</code> </pre> <br><p>  This problem is also known, the solution for Node JS is GraphQL depth limit, for other languages ‚Äã‚Äãthere are also solutions. </p><br><p>  Thus, we decided on GraphQL.  It's time to choose a library that will work with the GraphQL API.  An example of a couple of lines with the fetch shown above is only a transport.  But thanks to the scheme and declarativeness, we can also cache requests on the front, and work with greater performance with the GraphQL backend. </p><br><p>  So we have two main players - Relay and Apollo. </p><br><h3 id="relay">  Relay </h3><br><p>  Relay is Facebook development, they use it themselves.  Like Oculus, Circle CI, Arsti and Friday. </p><br><h4 id="kakie-plyusy-est-u-relay">  What are the advantages of Relay? </h4><br><p>  The immediate plus is that the developer is Facebook.  React, Flow, and GraphQL are Facebook‚Äôs development, all of which are jigsaw puzzles.  Where are we without stars on Github, Relay has almost 11,000, Apollo has 7600 for comparison. The cool thing Relay has is Relay-compiler, a tool that optimizes and analyzes your GraphQL queries at the build level of your project .  We can assume that this uglify only for GraphQL: </p><br><pre> <code class="hljs scala">#  <span class="hljs-type"><span class="hljs-type">Relay</span></span>-compiler foo { # <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooType</span></span></span><span class="hljs-class"> </span></span>{ # matches the parent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extraneous</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">#</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span></span>{ id }</code> </pre> <br><h4 id="kakie-minusy-u-relay">  What are the cons of Relay </h4><br><p>  The first minus * is the absence of SSR from the box.  There is still an <a href="https://github.com/facebook/relay/issues/1881">issue</a> on Github.  Why under the asterisk - because there are already solutions, but they are third-party, and besides, rather ambiguous. </p><br><p><img src="https://habrastorage.org/webt/ee/1b/rc/ee1brchbmmgdpqka4kpf3ogo2my.png"></p><br><p>  Again, Relay is a specification.  The fact is that GraphQL is already a specification, and Relay is a specification over a specification. </p><br><p><img src="https://habrastorage.org/webt/f6/ds/nl/f6dsnlwzog77hrwpboaru95u7_y.png"></p><br><p>  For example, Relay pagination is implemented differently, cursors appear here. </p><br><pre> <code class="hljs pgsql">{ friends(first: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">after</span></span>: "opaqueCursor") { edges { <span class="hljs-keyword"><span class="hljs-keyword">cursor</span></span> node { id <span class="hljs-type"><span class="hljs-type">name</span></span> } } pageInfo { hasNextPage } } }</code> </pre> <br><p>  We no longer use the usual offsets and limits.  For feeds in the feed, this is a great topic, but when we start making all sorts of grids, then there is pain. </p><br><p>  Facebook solved its problem by writing its own library for React.  There are solutions for other libraries, for vue.js, for example - <a href="https://github.com/ntkme/vue-relay">vue-relay</a> .  But if we pay attention to the number of asterisks and commit-s, then everything is also not so smooth and may be unstable.  For example, the Create React App from the CRA box does not allow using Relay-compiler.  But you can circumvent this limitation with the help of <a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> . </p><br><p><img src="https://habrastorage.org/webt/dj/wb/i2/djwbi2it6brz4qxdipg0wcdyhpa.png"></p><br><h2 id="apollo">  Apollo </h2><br><p>  Our second candidate is <a href="https://www.apollographql.com/">Apollo</a> .  It is developed by the <a href="https://www.meteor.com/">Meteor</a> team.  Apollo uses such well-known commands as: AirBnB, ticketmaster, Opentable, etc. </p><br><h3 id="kakie-est-plyusy-u-apollo">  What are the advantages of Apollo </h3><br><p>  The first significant plus is that Apollo was developed as a framework agnostic library.  For example, if we want to rewrite everything now on Angular, this will not be a problem, Apollo works with it.  And you can even write everything on Vanilla. </p><br><p>  Apollo has cool documentation, there are ready-made solutions for common problems. </p><br><p><img src="https://habrastorage.org/webt/tq/wu/ko/tqwukoydh-b7fem6dwusyuwklgw.png"></p><br><p>  Another plus Apollo - a powerful API.  In principle, those who worked with Redux will find common approaches here: there is an ApolloProvider (as Provider for Redux), and instead of a store for Apollo, this is called a client: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloProvider } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApolloClient } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./ApolloClient'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">client</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{ApolloClient}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ApolloProvider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><p>  At the level of the component itself, we have provided graphql HOC, like connect.  And we are already writing a GraphQL query inside, like a MapStateToProps in Redux. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { graphql } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gql <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Landing } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Landing'</span></span>; graphql(gql<span class="hljs-string"><span class="hljs-string">` { landing(id: 1) { id title } } `</span></span>)(Landing);</code> </pre> <br><p>  But when we make MapStateToProps in Redux, we take the data local.  If there is no local data, then Apollo itself follows it to the server.  Very convenient Props fall into the component itself. </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ data, loading, error, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  It: <br>  ‚Ä¢ data; <br>  ‚Ä¢ download status; <br>  ‚Ä¢ error if it occurred; <br>  helper functions, such as refetch for reloading data or fetchMore for pagination.  There is also a huge plus for both Apollo and Relay, this is the Optimistic UI.  It allows you to perform undo / redo at the query level: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.setNotificationStatusMutation({ variables: { ‚Ä¶ }, optimisticResponse: { ‚Ä¶ } });</code> </pre> <br><p>  For example, a user clicked the like button, and the like was immediately credited.  In this case, the request to the server will be sent in the background.  If some kind of error occurs during the sending process, then the changed data will return to its original state on its own. </p><br><p>  Server side rendering is implemented well, we set one flag on the client and everything is ready. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ApolloClient</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">ssrMode</span></span>: true, ... });</code> </pre> <br><p>  But here I would like to tell you about Initial State.  When Apollo prepares it for himself, everything works well. </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = client.extract(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  But we don‚Äôt have Server side rendering, and the backend slips a certain GraphQL query into the global variable.  Here you need a small crutch, you need to write a Transform-function, which the graphQL-response from the backend will turn into the necessary format for Apollo. </p><br><pre> <code class="hljs javascript">&lt;script&gt; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__ = transform({‚Ä¶}); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApolloClient({ <span class="hljs-attr"><span class="hljs-attr">cache</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InMemoryCache().restore(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__APOLLO_STATE__), link });</code> </pre> <br><p>  Another advantage of Apollo is that it is well customized.  We all remember middleware from Redux, here everything is the same, only this is called link. </p><br><p><img src="https://habrastorage.org/webt/va/gw/-z/vagw-zeeg2j0t7pjuawtw4tllq8.png"></p><br><p>  I would like to separately note two links: <a href="https://github.com/apollographql/apollo-link-state">apollo-link-state</a> , which is needed to store the local state in the absence of Redux, and <a href="https://github.com/apollographql/apollo-link-rest">apollo-link-rest</a> , if we want to write GraphQL queries to the Rest API.  However, with the latter you need to be extremely careful, because  There may be some problems. </p><br><h4 id="minusy-u-apollo-tozhe-est">  Apollo also has disadvantages </h4><br><p>  Consider an example.  There was an unexpected performance problem: they requested 2000 elements on the frontend (it was a reference book), and performance problems started.  After viewing in the debugger, it turned out that Apollo ate a lot of resources on reading, the issue was basically closed, now everything is fine, but there was such a sin. </p><br><p>  Also refetch was very unobvious ... </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Landing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ loading, refetch, </span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...other</span></span></span></span><span class="hljs-function"><span class="hljs-params"> })</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  It would seem that when we do a re-request of data, especially if the previous request was completed with an error, then loading should become true.  But no! </p><br><p>  In order for this to be, you need to specify notifyOnNetworkStatusChange: true in the graphql HOC, or store the state's refetch. </p><br><h3 id="apollo-vs-relay">  Apollo vs.  Relay </h3><br><p>  Thus, we got such a table, we all weighed, calculated, and we have 76% turned out for Apollo. </p><br><p><img src="https://habrastorage.org/webt/ry/if/wx/ryifwxtkdmb4yvc2xczme5xoqkc.png"></p><br><p>  So we chose a library and went to work. </p><br><p>  But I would like to say more about the toolchain. </p><br><p>  Everything is very good here, there are various additions for editors, somewhere better, somewhere worse.  There is also apollo-codegen, which generates useful files, for example, flow-types, and basically pulls the circuit out of the GraphQL API. </p><br><h3 id="rubrika-ochumelye-ruchki-ili-chto-my-sdelali-u-sebya">  Rubric "crazy hands" or what we have done </h3><br><p>  The first thing we encountered was that, in principle, we need to somehow request data. </p><br><pre> <code class="hljs lisp">graphql(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>)(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  We have common states: loading, error handling.  We wrote our hock (asyncCard), which is connected via the composition graqhql and asyncCard. </p><br><pre> <code class="hljs lisp">compose( <span class="hljs-name"><span class="hljs-name">graphql</span></span>(<span class="hljs-name"><span class="hljs-name">BalanceQuery</span></span>), AsyncCard )(<span class="hljs-name"><span class="hljs-name">BalanceItem</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  I would like to tell you more about the fragments.  There is a LandingItem component and it knows what data it needs from the GraphQL API.  We set the fragment property where we specified the fields from the Landing entity. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ‚Ä¶ </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); LandingItem.fragment = gql<span class="hljs-string"><span class="hljs-string">` fragment LandingItem on Landing { ... } `</span></span>;</code> </pre> <br><p>  Now, at the component usage level, we use its fragment in the final query. </p><br><pre> <code class="hljs bash">query LandingsDashboard { landings(...) { nodes { ...LandingItem } totalCount } <span class="hljs-variable"><span class="hljs-variable">${LandingItem.Fragment}</span></span> }</code> </pre> <br><p>  And let's say a task arrives to us to add status to this landing page - not a problem.  We add a property to the render and in the fragment.  And everything is ready.  Single responsibility principle in all its glory. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LandingItem = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content }: Props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ‚Ä¶ </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStatus</span></span></span></span><span class="xml"><span class="hljs-tag"> ‚Ä¶ /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">LandingItemStyle</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); LandingItem.fragment = gql` fragment LandingItem on Landing { ... status } `;</span></span></code> </pre> <br><h4 id="kakaya-u-nas-esche-byla-problema">  What was our problem? </h4><br><p>  We have a number of widgets on our site that made their own separate requests. </p><br><p><img src="https://habrastorage.org/webt/ab/li/-x/abli-xjzcmoq9_p2rtnorl-y3qu.png"></p><br><p>  During testing, it turned out that all this slows down.  We have very long security checks, and every request is very expensive.  It was also not a problem, there is Apollo-link-batch-http </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BatchHttpLink</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">batchMax</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, batchInterval: <span class="hljs-number"><span class="hljs-number">10</span></span> });</code> </pre> <br><p>  It is configured as follows: we transmit the number of requests that we can combine and how long this link will wait for the first request. <br>  And it turned out like this: at the same time everything is loading, and at the same time everything comes.  It should be noted that if during this merging one of the subqueries returns with an error, then only he will have an error, and not the entire query. </p><br><h4 id="hochetsya-otdelno-rasskazat-chto-proshloy-osenyu-proizoshlo-obnovlenie-s-pervogo-apollo-na-vtoroy">  I would like to tell you separately that last autumn there was an update from the first Apollo to the second </h4><br><p>  First was Apollo and Redux </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span></code> </pre> <br><p>  Then Apollo became more modular and expandable, these modules can be developed independently.  The same apollo-cache-inmemory. </p><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">'react-apollo'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-client'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-link-batch-http'</span></span> <span class="hljs-string"><span class="hljs-string">'apollo-cache-inmemory'</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-tag'</span></span></code> </pre> <br><p>  It is worth noting that there is no Redux, and as it turned out, it is, in principle, not needed. </p><br><h2 id="vyvody">  Findings: </h2><br><ol><li>  Feature-delivery time has decreased with us, we do not waste time on the description of action, reduce in Redux, and less touch the backend </li><li>  Appeared anti-fragility, because  Static API analysis reduces problems to zero when the frontend expects one thing and the backend gives up something completely different. </li><li>  If you start working with GraphQL, try Apollo, you will not be disappointed. </li></ol><br><p>  PS You can also watch the video from my presentation on Rambler Front &amp; Meet up # 4 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rCEoy-V3x8k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418417/">https://habr.com/ru/post/418417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418403/index.html">FPGA Accelerator Programming Example</a></li>
<li><a href="../418405/index.html">The principle of the inverted pyramid in analytics. We build a clear dashboard</a></li>
<li><a href="../418407/index.html">Cloud mining Hashflare closed. Money does not return</a></li>
<li><a href="../418411/index.html">Browser Network Shooter on Node.js</a></li>
<li><a href="../418415/index.html">Telegram introduced its own Passport service to verify and authorize users.</a></li>
<li><a href="../418419/index.html">How Dodo Pizza solves business problems with machine learning</a></li>
<li><a href="../418421/index.html">The best reports about machine learning with ICML 2018 according to the version of Yandex employees</a></li>
<li><a href="../418423/index.html">Smart home: a new dimension of comfort and commitment to excellence. Part one</a></li>
<li><a href="../418425/index.html">FAS proposes a law on the mandatory installation of Russian software on smartphones</a></li>
<li><a href="../418427/index.html">Mobile-first indexing. How and why does the reference graph change?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>