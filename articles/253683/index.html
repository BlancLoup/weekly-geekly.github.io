<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to deal with OutOfMemoryError in practice, or oh, these databases</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, Habr! 
 Some lyrics  Today, 2015-03-21, I decided to do half the work, and still start writing an article about how to start to understand ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to deal with OutOfMemoryError in practice, or oh, these databases</h1><div class="post__text post__text-html js-mediator-article">  Greetings, Habr! <br><div class="spoiler">  <b class="spoiler_title">Some lyrics</b> <div class="spoiler_text">  Today, 2015-03-21, I decided to do half the work, and still start writing an article about how to start to understand what to do with OOM, and generally learn how to pick heap-dumps ( I‚Äôll just call them dumps for ease of speech. I‚Äôll also try to avoid Anglicisms where possible). <br>  The amount of ‚Äúwork‚Äù I have planned on writing this article seems to me not a one-day, and therefore the article should appear only <s>a couple of weeks</s> later a day. </div></div><br>  In this article I will try to chew on what to do with dumps in Java, how to understand the reason or get closer to the cause of OOM, look at the tools for analyzing dumps, the tool (one, yes) for monitoring the hip, and in general go into this matter for common development .  Such tools as JVisualVM (I will consider some plug-ins to it and OQL Console), Eclipse Memory Analyzing Tool are investigated. <br>  I have written a lot, but I hope that everything is only in business :) <br><a name="habracut"></a><br><h4>  Prehistory </h4><br>  First you need to understand how OOM arises.  Someone may not yet know. <br>  Imagine that there is some upper limit of the RAM for the application.  Let it be gigabytes of RAM. <br>  In itself, the occurrence of OOM in one of the threads does not mean that it is this thread that ‚Äúdevoured‚Äù all the free memory, and in general does not mean that the particular piece of code that led to the OOM is to blame for this. <br>  The situation is quite normal when some kind of flow was engaged in something, eating memory, ‚Äúgot busy‚Äù with this to the state ‚Äúa little more, and I would burst‚Äù, and completed the execution, pausing.  At that time, some other thread decided to request some more memory for its little work, the garbage collector tried, of course, but I did not find any garbage in my memory.  In this case, just the OOM, which is not related to the source of the problem, occurs when the glass flow shows the wrong cause of the application crash. <br><br>  There is another option.  For about a week, I explored how to improve the lives of a couple of our applications so that they stop being unstable.  And another week or two spent on it in order to bring them in order.  In total, a couple of weeks of time, which stretched for a month and a half, because I was engaged not only in these problems. <br>  From the found: a third-party library, and, of course, some unaccounted things in calls to stored procedures. <br>  In one application, the symptoms were as follows: depending on the load on the service, it could fall in a day, and could in two.  If you monitor the state of the memory, it was clear that the application gradually gained "size", and at a certain moment it simply went down. <br>  With another application is somewhat more interesting.  It may behave well for a long time, and could stop responding 10 minutes after the reboot, or suddenly fall down, devouring all the free memory (I can already see it, watching it).  And after updating the version, when the Tomcat version was changed from 7th to 8th, and the JRE, it suddenly on one of Fridays (having worked before that, as many as 2 weeks) started doing such things that it was embarrassing to admit it.  :) <br><br>  In both stories, dumps turned out to be very useful, thanks to them they managed to find all the causes of falls, making friends with tools like JVisualVM (I‚Äôll call it JVVM), Eclipse Memory Analyzing Tool (MAT) and OQL (maybe I don‚Äôt know how to properly prepare it). MAT, but it turned out to be easier for me to make friends with the implementation of OQL in the JVVM). <br>  You also need a free RAM in order to download dumps.  Its volume should be commensurate with the size of the dump being opened. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Start </h4><br>  So, I will begin to slowly reveal the cards, and I will begin with the JVVM. <br><img src="https://habrastorage.org/files/940/c14/76c/940c1476c6224e05a8ddcf5f8288a46d.png"><br>  This tool in conjunction with jstatd and jmx allows you to remotely monitor the life of an application on a server: Heap, processor, PermGen, the number of threads and classes, the activity of threads, allows profiling. <br>  JVVM is also expandable, and I didn‚Äôt fail to take advantage of this opportunity by installing some plugins that allowed a lot more things, for example, to monitor and interact with MBeans, watch the details of the hip, keep a long look at the application, holding much more period of metrics than the hour provided by the Monitor tab. <br><br><img src="https://habrastorage.org/files/54d/2d9/1fe/54d2d91fe8004bc78d7b0d71e0ed09fb.png"><br>  Here is a set of installed plugins. <br>  Visual GC (VGC) allows you to see the metrics associated with the heap. <br><div class="spoiler">  <b class="spoiler_title">Learn more about what hip is made of in our Java.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/cdd/7cf/a21/cdd7cfa21e5e4938a9265b766920ac46.png"><br><img src="https://habrastorage.org/files/0d8/8c0/a05/0d88c0a055fc4137863aa8fba5b309e5.png"><br>  Here are two screenshots of the VGC tab that show how two different applications behave. <br>  On the left, you can see the heap sections such as Perm Gen, Old Gen, Survivor 0, Survivor 1, and Eden Space. <br>  All these components are areas in the RAM, into which the objects are added. <br>  PermGen - Permanent Generation is a JVM memory area for storing descriptions of Java classes and some additional data. <br>  The Old Gen is a memory area for fairly old objects that have experienced several shifts from place to place in Survivor-areas, and at the time of some regular transfusion they fall into the area of ‚Äã‚Äã‚Äúold‚Äù objects. <br>  Survivor 0 and 1 are areas in which objects that, after creating an object in Eden Space, survived its cleaning, that is, did not become rubbish at the time when Eden Space started cleaning with Garbage Collector (GC).  Each time you start Eden Space cleaning, objects from the currently active Survivor are transferred to the passive, plus new ones are added, and after that the Survivors change their status, the passive becomes active and the active passive. <br>  Eden Space is the memory area in which new objects are spawned.  If there is not enough memory in this area, the GC cycle starts. <br><br>  Each of these areas can be adjusted in size while the application is running by the virtual machine itself. <br>  If you specify -Xmx in 2 gigabytes, for example, this does not mean that all 2 gigabytes will be immediately occupied (if you do not immediately start something actively eaten memory, of course).  The virtual machine will first try to keep itself "in check." <br>  The third screenshot shows the inactive stage of the application, which is not used at the weekend - Eden grows evenly, Survivors are shifted at regular intervals, Old practically does not grow.  The application has worked for more than 90 hours, and in principle the JVM believes that the application does not need too much, about 540 MB. <br><img src="https://habrastorage.org/files/745/1c7/70f/7451c770f3394426adda7934590d34f4.png"><br>  There are peak situations where a virtual machine even allocates much more memory for the hip, but I think these are some other ‚Äúunrecognized‚Äù ones, which I will discuss in more detail below, or maybe the virtual machine allocated more memory for Eden, for example so that the objects in it have time to become trash before the next cleaning cycle. <br><img src="https://habrastorage.org/files/b48/760/f41/b48760f41f734d019654b4622d3c17dc.png"><br>  The areas that I marked in red in the next screenshot are just the growth of Old, when some objects do not have time to become garbage to be removed from memory earlier, and still get into Old.  The blue patch is an exception.  Over the red areas you can see the comb - this is what Eden behaves like. <br><img src="https://habrastorage.org/files/2a1/41d/f5d/2a141df5dc9b4ab0953da0e50aa916ef.png"><br>  Throughout the blue area, the virtual machine most likely decided that it was necessary to increase the size of the Eden-region, because when you increase the scale in Tracer, it is clear that the GC stopped ‚Äúdividing‚Äù and such small oscillations as before, now no, the oscillations became slow and rare. <br><img src="https://habrastorage.org/files/c13/0d1/63d/c130d163dbdb407296ca63750dab63da.png"><br><br>  Let's move to the second application: <br><img src="https://habrastorage.org/files/0d8/8c0/a05/0d88c0a055fc4137863aa8fba5b309e5.png"><br>  In it, Eden reminds me of a level from Mortal Kombat, a spiked arena.  It was such, it seems ... And the Graph GC - spikes from NFS Hot Pursuit, here they are, flat yet. <br>  The numbers to the right of the area names indicate: <br>  1) that Eden has a size of 50 megabytes, and what is drawn at the end of the graph, the last of the current values ‚Äã‚Äãis 25 megabytes.  In total, it can grow up to 546 megabytes. <br>  2) that Old can grow up to 1.333 gigabytes, now occupies 405 MB, and is scored at 145.5 MB. <br>  Also for Survivor-areas and Perm Gen. <br>  For comparison - here you have the Tracer-schedule for 75 hours of the second application, I think you can draw some conclusions from it.  For example, that the active phase of this application is from 8:30 to 17:30 on weekdays, and that even on the weekend it also works :) <br><img src="https://habrastorage.org/files/a20/d35/574/a20d355740ce42988d7795645db6e853.png"><br>  If you suddenly see in your application that the Old-area is full - try to just wait until it overflows, most likely it is already filled with garbage. <br><br>  Garbage is objects that are not actively referenced from other objects, or whole complexes of such objects (for example, some kind of ‚Äúcloud‚Äù of interrelated objects can become garbage, if a set of links points only to objects inside this ‚Äúcloud‚Äù, and neither one object in this ‚Äúcloud‚Äù nothing refers to ‚Äúoutside‚Äù). <br><br>  It was a brief retelling of what I learned about the structure of the hip during the time while I was googling. </div></div><br><h4>  Prerequisites </h4><br>  So, two things happened right away: <br>  1) after switching to newer libraries / tomkety / java on one of Fridays, the application, which I have been running for a long time, suddenly began to behave badly two weeks after the exhibit. <br>  2) I was given a refactoring project, which also behaved until some time is not very good. <br><br>  I don‚Äôt remember exactly in what order these events took place, but after the ‚ÄúBlack Friday‚Äù I decided to finally deal with memory dumps in more detail, so that it would no longer be a black box for me.  I warn you that I could already forget some details. <br><br>  On the first occasion, the symptoms were as follows: all the threads responsible for processing requests were burned out, only 11 connections were open to the database, and they did not say that they were used, the base said that they were able to recv sleep, that is, they were waiting for them will start to use. <br>  After the reboot, the application came to life, but it could not live long, on the evening of the same Friday it lived the longest, but after the end of the working day it fell again.  The picture was always the same: 11 connections to the base, and only one, it seems, is doing something. <br>  Memory, by the way, was at a minimum.  I cannot say that OOM led me to search for causes, but the knowledge gained in searching for causes allowed me to begin an active struggle against OOM. <br><br>  When I opened the dump in JVVM, it was difficult to understand anything from it. <br><img src="https://habrastorage.org/files/57a/401/9ce/57a4019ceb6441fb947ddab4915ee98e.png"><br><img src="https://habrastorage.org/files/2ab/f8c/6a0/2abf8c6a0c49455aa219f35354daea2f.png"><br><br>  Subconsciousness suggested that the reason was somewhere in the work with the base. <br>  A search among the classes told me that there are already 29 DataSource in memory, although there should be a total of 7. <br><img src="https://habrastorage.org/files/4a8/838/745/4a88387457c54eb6a07233fa6adb7f13.png"><br><br>  This gave me a point from which it would be possible to push off, to begin to unravel the tangle. <br><br><h5>  Oql </h5><br>  There was no time to sit around pereklitsyvat in the viewer, and my attention was finally attracted by the OQL Console tab, I thought that here it is, the moment of truth - either I will start using it to its fullest, or I will score on all of this. <br><img src="https://habrastorage.org/files/071/4b0/7d3/0714b07d314741da8badb2bc6afade86.png"><br><br>  Before starting, of course, Google was asked a question, and he kindly provided a cheat sheet on how to use OQL in the JVVM: <a href="http://visualvm.java.net/oqlhelp.html">http://visualvm.java.net/oqlhelp.html</a> <br><br>  At first, the abundance of compressed information disheartened me, but after using Google-Fu, the following OQL query appeared: <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">instance</span></span>: x, uri: x.url.toString(), connPool: x.connectionPool} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> org.apache.tomcat.dbcp.dbcp2.BasicDataSource x <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x.url != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; x.url.toString() == <span class="hljs-string"><span class="hljs-string">"jdbc:sybase:Tds::/"</span></span></code> </pre> <br>  This is a revised and updated final version of this request :) <br>  The result can be seen in the screenshot: <br><img src="https://habrastorage.org/files/962/6e8/ace/9626e8acea1e4b939a5442a540992741.png"><br>  After clicking on BasicDataSource # 7 we get to the desired object in the Instances tab: <br><img src="https://habrastorage.org/files/e26/a7d/624/e26a7d62450849f9b83fe1479771db21.png"><br>  After some time, it dawned on me that there is one incompatibility with the configuration specified in the Resource tag in the volume in the /conf/context.xml file.  Indeed, in the dump, the maxTotal parameter is set to 8, while we specified maxActive equal to 20 ... <br><img src="https://habrastorage.org/files/05f/1ae/c9b/05f1aec9b82640f994f0d3a363fd65a3.png"><br>  It was then that it began to come to me that the application lived with the wrong configuration of the connection pool all these two weeks! <br>  For the sake of brevity, I‚Äôll write here that if you use Tomcat and DBCP as a connection pool, DBCP version 1.4 is used in the 7th volume, and DBCP 2.0, which I later found out, decided to rename some of them in the 8th volume. options!  And about maxTotal in general on the main page of the site is written :) <br>  <a href="http://commons.apache.org/proper/commons-dbcp/">http://commons.apache.org/proper/commons-dbcp/</a> <br>  "Users should also be aware of this option." <br><br><h5>  The reasons </h5><br>  I called them in every way, calmed down, and decided to figure it out. <br>  As it turned out, the BasicDataSourceFactory class simply simply receives this very Resource, looks at whether it has the necessary parameters, and takes them into the generated BasicDataSource object, silently ignoring everything that it does not interest. <br>  So it happened that they renamed the most fun parameters, maxActive =&gt; maxTotal, maxWait =&gt; maxWaitMillis, removeAbandoned =&gt; removeAbandonedOnBorrow &amp; removeAbandonedOnMaintenance. <br>  By default, maxTotal, as before, is equal to 8;  removeAbandonedOnBorrow, removeAbandonedOnMaintenance = false, maxWaitMillis is set to "wait forever." <br>  It turned out that the pool was configured with a minimum number of connections;  if free connections end - the application silently waits for them to be released;  and finishes all silence in the logs about the "abandoned" connections - something that could immediately show exactly where the <s>programmer asshole</s> code lacks the connection, but does not give it back at the end of their work. <br>  It is now the entire mosaic has developed quickly, and this knowledge has been extracted longer. <br><br>  ‚ÄúIt shouldn‚Äôt be like that,‚Äù I decided, and patched down the patch ( <a href="https://issues.apache.org/jira/browse/DBCP-435">https://issues.apache.org/jira/browse/DBCP-435</a> , put it in <a href="">http://svn.apache.org/viewvc/commons/proper/ dbcp / tags / DBCP_2_1 / src / main / java / org / apache / commons / dbcp2 / BasicDataSourceFactory.java? view = markup</a> ), the patch was accepted and entered into the version of DBCP 2.1.  When and if Tomcat 8 updates the DBCP version to 2.1+, I think that admins will open many secrets about their configuration Resource :) <br><br>  Regarding this incident, I just had to tell one more detail - what the heck in the dump was already 29 DataSource instead of just 7 pieces.  The answer lies in the banal arithmetic, 7 * 4 = 28 + 1 = 29. <br><div class="spoiler">  <b class="spoiler_title">More details about why you can not throw the Resource in the file /conf/context.xml tomket</b> <div class="spoiler_text">  Each subfolder inside the / webapps folder has its own copy of /conf/context.xml, which means that the number of Resource that is there should be multiplied by the number of applications to get the total number of pools raised in the tomkette memory.  To the question ‚Äúwhat to do in this case?‚Äù The answer will be this: you need to move all the Resource declarations from /conf/context.xml to the /conf/server.xml file, inside the GlobalNamingResources tag.  There you can find one, available by default, Resource name = "UserDatabase", here below it and place your pools.  Next, you need to use the ResourceLink tag, it is desirable to put it in the application, in the project, inside the file /META-INF/context.xml - this is the so-called "per-app context", that is, the context that contains the component declarations that will be available only for deployable application.  In ResourceLink, the name and global parameters can contain the same values. <br>  For example: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ResourceLink</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc/MyDB"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">global</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc/MyDB"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  This link will grab from the globally declared DataSource resource named "jdbc / MyDB", and the resource will be available to the application. <br>  ResourceLink can (but does not have to) be placed in /conf/context.xml, but in this case all applications will have access to globally declared resources, even if there are not so many copies of the DataSource in memory. <br>  You can see the details here: GlobalNamingResources - <a href="http://tomcat.apache.org/tomcat-7.0-doc/config/globalresources.html">http://tomcat.apache.org/tomcat-7.0-doc/config/globalresources.html#Environment_Entries</a> , ResourceLink - <a href="http://tomcat.apache.org/tomcat-7.0-doc/config/globalresources.html">http://tomcat.apache.org/tomcat-7.0-doc /config/globalresources.html#Resource_Links</a> , also see this page: <a href="http://tomcat.apache.org/tomcat-7.0-doc/config/context.html">tomcat.apache.org/tomcat-7.0-doc/config/context.html</a> . <br>  For TC8, the same pages: <a href="http://tomcat.apache.org/tomcat-8.0-doc/config/globalresources.html">http://tomcat.apache.org/tomcat-8.0-doc/config/globalresources.html</a> and <a href="http://tomcat.apache.org/tomcat-8.0-doc/config/globalresources.html">http://tomcat.apache.org/tomcat-8.0-doc/config/context.html</a> . </div></div><br>  After that, everything became clear: 11 connections were because in one, active DataSource 8 connections were eaten (maxTotal = 8), and another by minIdle = 1 in three other unused DataSource copies. <br><br>  That Friday we rolled back to Tomcat 7, which lay side by side, and waited to get rid of it, it gave time to calmly figure everything out. <br>  Plus, later, on TC7, there was a leak of connections, thanks to removeAbandoned + logAbandoned.  DBCP happily reported to catalina.log that <br><pre> <code class="hljs dos">"org.apache.tomcat.dbcp.dbcp.AbandonedTrace$AbandonedObjectException: DBCP object created <span class="hljs-number"><span class="hljs-number">2015</span></span>-<span class="hljs-number"><span class="hljs-number">02</span></span>-<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span> by the following code was never closed: <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> org.apache.tomcat.dbcp.dbcp.AbandonedTrace.setStackTrace(AbandonedTrace.java:<span class="hljs-number"><span class="hljs-number">139</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> org.apache.tomcat.dbcp.dbcp.AbandonedObjectPool.borrowObject(AbandonedObjectPool.java:<span class="hljs-number"><span class="hljs-number">81</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> org.apache.tomcat.dbcp.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:<span class="hljs-number"><span class="hljs-number">106</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> org.apache.tomcat.dbcp.dbcp.BasicDataSource.getConnection(BasicDataSource.java:<span class="hljs-number"><span class="hljs-number">1044</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> ...getConnection(.java:<span class="hljs-number"><span class="hljs-number">100500</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> ...(.java:<span class="hljs-number"><span class="hljs-number">100800</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> ...<span class="hljs-number"><span class="hljs-number">2</span></span>(.java:<span class="hljs-number"><span class="hljs-number">100700</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">at</span></span> ...<span class="hljs-number"><span class="hljs-number">1</span></span>(.java:<span class="hljs-number"><span class="hljs-number">100600</span></span>)   ..."</code> </pre><br>  This one here is a bad Bad Method has Connection con in the signature, but inside was the construction ‚Äúcon = getConnection ();‚Äù, which became a stumbling block.  Superclass is rarely called, so it was not paid attention to him for so long.  Plus, the calls did not happen during the working day, as I understand it, so even if something was hanging, no one was concerned about it.  And at TusamPayutnitsa just the stars came together, the head of the department of the customer needed to see something :) <br><br><h4>  Appendix ‚Ññ2 </h4><br>  As for the "event number 2" - they gave me the application for refactoring, and it immediately dared to crash on the servers. <br>  Dumps came to me already, and I decided to try to pick them up too. <br>  Opened a dump in the JVVM, and "something desponded": <br><img src="https://habrastorage.org/files/55a/822/c89/55a822c89d1b4964872038cc01a8495a.png"><br>  What can be understood from Object [], and even in such numbers? <br>  (An experienced person, of course, already saw the reason, right? :)) <br><br>  So, the thought ‚ÄúI didn‚Äôt really have done it before, because I probably already have a finished tool!‚Äù  So I came across this question on StackOverflow: <a href="http://stackoverflow.com/questions/2064427/recommendations-for-a-heap-analysis-tool-for-java">http://stackoverflow.com/questions/2064427/recommendations-for-a-heap-analysis-tool-for-java</a> . <br>  Having looked at the proposed options, I decided to stop at MAT, I had to try at least something, and this is an open project, and even with a much larger number of votes than the other points. <br><br><h4>  Eclipse Memory Analyzing Tool </h4><br>  So MAT. <br>  I recommend downloading the latest version of Eclipse, and installing the MAT there, because the independent version of the MAT behaves badly, there is some kind of devilry with the dialogues, they do not see the contents in the fields.  Maybe someone will tell in the comments what he is missing, but I solved the problem by installing the MAT in Eclipse. <br><br>  Having opened a dump in MAT, I requested the execution of the Leak Suspects Report. <br><img src="https://habrastorage.org/files/de7/059/9f2/de70599f2a2d4a2395ac391722196ed1.png"><br><img src="https://habrastorage.org/files/3c6/07c/6c3/3c607c6c3ae040298e47af17a6d146ef.png"><br>  Surprise knew no bounds, to be honest. <br><img src="https://habrastorage.org/files/6c9/18d/90b/6c918d90b6bc4bed886c84c420107468.png"><br>  1.2 gigabytes weigh connections to the base. <br><img src="https://habrastorage.org/files/d90/177/594/d90177594b2146ae8bf647dc5c842a07.png"><br>  Each connection weighs from 17 to 81 megabytes. <br><img src="https://habrastorage.org/files/036/21e/f8b/03621ef8b54547418d1f3d59de8862e3.png"><br>  Well, another "little" pool itself. <br>  The Dominator Tree report helped to visualize the problem: <br><img src="https://habrastorage.org/files/d36/a6a/6a6/d36a6a6a69154557a7425bb5ba410fc9.png"><br>  The cause of all the drops was the kilometers of SQLWarning, the base tried hard to make it clear that ‚Äú010SK: Database cannot set connection option SET_READONLY_TRUE.‚Äù And the BoneCP connection pool does not clear SQLWarning after it is released and the connections are returned to the pool (maybe this is where- Can I configure it? Tell me, if anyone knows). <br>  Google said that this problem with Sybase ASE has been known since 2004: <a href="https://forum.hibernate.org/viewtopic.php%3Ff%3D1%26t%3D932731">https://forum.hibernate.org/viewtopic.php?f=1&amp;t=932731</a> <br>  In short, ‚ÄúSybase ASE doesn't require any optimizations, therefore setReadOnly () produces a SQLWarning.‚Äù, And these solutions still work. <br>  However, this is not exactly the solution to the problem, because the solution to the problem is when all the database notifications are cleared when the connection to the pool returns, because no one will ever need them. <br>  And DBCP can do it: <a href="">http://svn.apache.org/viewvc/commons/proper/dbcp/tags/DBCP_1_4/src/java/org/apache/commons/dbcp/PoolableConnectionFactory.java?view=markup</a> , method passivateObject (Object obj), in line 687 you can see conn.clearWarnings () ;, this call saves you from kilometers of SQLWarning in memory. <br>  I learned about this from the ticket: <a href="https://issues.apache.org/jira/browse/DBCP-102">https://issues.apache.org/jira/browse/DBCP-102</a> <br>  Also, I was prompted about such a ticket in the bug tracker: <a href="https://issues.apache.org/jira/browse/DBCP-234">https://issues.apache.org/jira/browse/DBCP-234</a> , but it already concerns the version of DBCP 2.0. <br><br>  As a result, I transferred the application to DBCP (albeit version 1.4).  Let the load on the service and rather big (from 800 to 2k requests per minute), but still the application behaves well, and this is important.  And I did it right, because BoneCP has not been supported for five months already, however, HikariCP came to replace it.  It will be necessary to see how things are in his source ... <br><br><h4>  Fighting OOM </h4><br>  Impressed by how MAT laid everything out for me, I decided not to throw this effective tool, and later it came in handy for me, because the first application still had all sorts of ‚Äúunrecognized‚Äù things unaccounted for in the application code or stored procedure code that sometimes result to the fact that the application glues fins.  I still catch them. <br><br>  Armed with both tools, I began to pick each sent dump in search of the reasons for the fall of the OOM. <br>  As a rule, all OOM led me to TaskThread. <br><img src="https://habrastorage.org/files/a11/947/8c9/a119478c911a4766992b9be7688273eb.png"><br>  And if you click on the See stacktrace sign, then yes, it will be just a banal case, when some thread suddenly fell down while trying to marshal the result of your work. <br><img src="https://habrastorage.org/files/346/7b7/11b/3467b711bede4ca2a6d44a74e29a54bb.png"><br>  However, here nothing indicates the cause of the OOM, here only the result.  Find the reason for me so far, because of the ignorance of all the OQL magic in MAT, it is JVVM that helps. <br>  Download the dump there, and try to find the cause! <br><img src="https://habrastorage.org/files/da2/0ee/e81/da20eee816ec4e45b0b6ac6ea76a3206.png"><br>  I should, of course, look for exactly the things associated with the database, and therefore we will first try to see if there are statements in memory. <br><img src="https://habrastorage.org/files/320/b5e/9ef/320b5e9efa7a4133b1cb30d1d8806602.png"><br>  Two SybCallableStatement, and one SybPreparedStatement. <br>  I think that the matter will become more complicated if the statements are much more, but having slightly edited one of the following queries, specifying the necessary conditions in where, I think everything will work out for you.  Plus, of course, it‚Äôs worth a good look at MAT, what kind of results a stream is trying to stream, which object, and it will become clearer which particular Statement should be searched for. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span>: x, stmtQuery: x._query.toString(), params: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(x._paramMgr._params, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(obj1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj1._parameterAsAString != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'\''</span></span>+obj1._parameterAsAString.toString()+<span class="hljs-string"><span class="hljs-string">'\''</span></span>; } else { return "null"; } } else { return "null"; } }) } from com.sybase.jdbc4.jdbc.SybCallableStatement x where x._query != null</code> </pre> <br><br><img src="https://habrastorage.org/files/6ed/d33/306/6edd33306f8f4fcd93e232ef89c2a01d.png"><br>  This is not the "internal" calls. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span>: x, stmtQuery: x._query.toString(), params: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>(x._paramMgr._params, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(obj1) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj1._parameterAsAString != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'\''</span></span>+obj1._parameterAsAString.toString()+<span class="hljs-string"><span class="hljs-string">'\''</span></span>; } else { return "null"; } } else { return "null"; } }) } from com.sybase.jdbc4.jdbc.SybPreparedStatement x where x._query != null</code> </pre> <br><br><img src="https://habrastorage.org/files/1e8/8b3/1b4/1e88b31b4adc4837b66ff2e2dfb04ddd.png"><br>  And here is the game! <br>  For the purity of the experiment, you can throw the same query in your favorite DB-IDE, and it will work for a very long time, and if you dig into the depths of the storehouse, it will be clear that there simply 2 million lines are selected from the base that does not belong to us with such parameters.  These two million even intermeddle in the memory of the application, but the attempt to marshal the result becomes fatal for the application.  Such a hara-kiri.  :) <br>  In this case, the GC diligently removes all the evidence, but it did not save it, yet the source remained in the memory, and he will be punished. <br><br>  For some reason, after all this story, I felt that I was still a loser. <br><br><h4>  Parting </h4><br>  That ended my story, I hope you enjoyed it :) <br>  I would like to thank my boss, he gave me time to figure it all out.  I think this new knowledge is very useful. <br>  Thanks to the girls from Scorini for the invariably delicious coffee, but they will not read these words of gratitude - I even doubt that they know about the existence of Habrahabr :) <br>  I would like to see in the comments even more useful information and additions, I will be very grateful. <br><br>  I think it's time to read the documentation for the MAT ... <br><br>  <b>UPD1</b> : Yes, I forgot to tell you about such useful things as creating memory dumps. <br>  <a href="https://docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html">docs.oracle.com/javase/7/docs/webnotes/tsg/TSG-VM/html/clopts.html#gbzrr</a> <br>  Options <br>  -XX: + HeapDumpOnOutOfMemoryError <br>  -XX: HeapDumpPath = / disk2 / dumps <br>  very useful for generating dumps when an application crashes using OutOfMemoryError, <br>  and there is also the possibility to remove a memory dump from the application ‚Äúprofitably‚Äù, in the middle of its work. <br>  For this there is a utility jmap. <br>  Example call for Windows: <br>  "C: \ install \ PSTools \ PsExec.exe" -s "C: \ Program Files \ Java \ jdk1.7.0_55 \ bin \ jmap.exe" -dump: live, format = b, file = C: \ dump. hprof 3440 <br>  the last parameter is the PID of the java process.  The PsExec application from the PSTools suite allows you to run other applications with system privileges, for this the "-s" key is used.  The live option is useful so that before saving the dump, call the GC, clearing the memory of garbage.  In the case when an OOM occurs, there is no need to clean the memory, there is no more garbage left, so do not look for how to set the live option in case of an OOM. <br><br>  <b>UPD2 (2015-10-28) |</b>  <b>Case number <s>two</s> three</b> <br>  (It was decided to add it here as an update, and not to cut a new article about the same): <br>  Another interesting case, but already with the Oracle base. <br>  One of the projects uses a feature with XML, conducts searches on the contents of a saved XML document.  In general, this project sometimes made itself felt by the fact that suddenly one of the instances ceased to show signs of life. <br>  Sensing a "good" case to practice <s>on cats</s> , I decided to watch its memory dumps. <br><img src="https://habrastorage.org/files/dd4/4e8/fb5/dd44e8fb5abb4fdcac3a722dfc227d17.png"><br>  The first thing I saw was ‚Äúyou have a lot of connections left in your memory‚Äù.  21k !!!  And some interesting oracle.xdb.XMLType also gave heat.  ‚ÄúBut this is Orakl!‚Äù, It turned in my head.  Looking ahead I will say that yes, he is guilty. <br><img src="https://habrastorage.org/files/a1d/378/d3b/a1d378d3b1e14f03be63ad1768f4952b.png"><br>  So, we see a bunch of T4CConnection, which are in the HashMap $ Entry.  Immediately I noticed that it seems like SoftHashMap, which, it seems, should mean that it should not grow to such size.  But you can see the result yourself - 50-60 kilobytes in a connection, and there are really a LOT of them. <br><img src="https://habrastorage.org/files/9f3/479/5e4/9f34795e452147258f24b80ad1657054.png"><br>  Having looked at what HashMap $ Entry represents, I saw that the picture is about the same, everything is connected with SoftHashMap, with Oracle connections. <br><img src="https://habrastorage.org/files/3ed/9bf/1f9/3ed9bf1f97e7441684a91b62b857aa3e.png"><br>  What, in fact, was confirmed by such a picture.  HashMap $ Entry was just a sea, and they more or less sakummulirovalis inside oracle.xdb.SoftHashMap. <br>  In the next dump, the picture was about the same.  According to the Dominator Tree, it was obvious that inside each Entry there is a heavy BinXmlProcessorImpl. <br><img src="https://habrastorage.org/files/143/46b/7c9/14346b7c907041f19be433b4aa1e4e1e.png"><img src="https://habrastorage.org/files/7dd/959/eb8/7dd959eb842d4733bd4226f0dd53f850.png"><img src="https://habrastorage.org/files/665/c5b/fc9/665c5bfc981440d48b80ffd1df70179f.png"><img src="https://habrastorage.org/files/aea/6ab/ae6/aea6abae6b024fc49043fa5d3e116cd3.png"><br>  - = - = - <br>  If we consider that at that moment I was not strong in what xdb is and how it is related to XML, then, somewhat confused, I decided that it would be necessary to google it, maybe someone already knows that with all this needs to be done.  And the flair did not deceive, on request "oracle.xdb.SoftHashMap T4CConnection" was found <br>  times <a href="http://piotr.bzdyl.net/2014/07/memory-leak-in-oracle-softhashmap.html">piotr.bzdyl.net/2014/07/memory-leak-in-oracle-softhashmap.html</a> <br>  and two <a href="http://leakfromjavaheap.blogspot.com/2014/02/memory-leak-detection-in-real-life.html">leakfromjavaheap.blogspot.com/2014/02/memory-leak-detection-in-real-life.html</a> <br>  Having established that there is still a jamb at Orakla, the matter remained for small. <br>  I asked the database administrator to look at the information on the detected problem: <br><blockquote>  xxx: Keywords: SoftHashMap XMLType <br>  yyy: Bug 17537657 Memory leak from XDB in oracle.xdb.SoftHashMap <br>  yyy: The fix for 17537657 is first included in <br>  12.2 (Future Release) <br>  12.1.0.2 (Server Patch Set) <br>  12.1.0.1.4 Database Patch Set Update <br>  12.1.0.1 Patch 11 on Windows Platforms <br>  yyy: nda.  Description <br>  Description <br>  When you call getDocument () using the thin driver, or getBinXMLStream () <br>  memory leaks occur in the oracle.xdb.SoftHashMap class. <br>  BinXMLProcessorImpl classes accumulate in this SoftHashMap, but are never <br>  removed. <br>  xxx: That's right :) </blockquote><br><br>  Here is a description of the fix: <a href="https://updates.oracle.com/Orion/Services/download%3Ftype%3Dreadme%26aru%3D18629243">updates.oracle.com/Orion/Services/download?type=readme&amp;aru=18629243</a> (access requires Oracle accounting). <br>  - = - = - <br>  After applying fixes, instances of our application have been living for a month, and so far without excesses  * tapped the tree * * spat over the left shoulder * <br>  Successes you in search! </div><p>Source: <a href="https://habr.com/ru/post/253683/">https://habr.com/ru/post/253683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253665/index.html">Using Log4php in Magento Applications</a></li>
<li><a href="../253671/index.html">Who might need K-Meleon?</a></li>
<li><a href="../253675/index.html">A simple explanation of the movement of money in the banking system</a></li>
<li><a href="../253679/index.html">Solution Management at SEBoK</a></li>
<li><a href="../253681/index.html">Electronic digital signature (EDS) documents in 1C for a couple of clicks using the utility CRYPTO-PRO PDF</a></li>
<li><a href="../253685/index.html">Demonstration of the program ZyXEL Wireless Optimizer</a></li>
<li><a href="../253687/index.html">CompTIA certifications for IT professionals. Part 7 of 7. CompTIA CTT + (Certified Technical Trainer)</a></li>
<li><a href="../253689/index.html">HP Software: Application Monitoring Systems</a></li>
<li><a href="../253691/index.html">Demonstration of little-known features of Windows Server 2012R2, Office 365, Microsoft Azure and a free webinar on Hyper-V</a></li>
<li><a href="../253693/index.html">Video stream: module review from the HP ArcSight Bootcamp course</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>