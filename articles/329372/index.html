<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit tests: what, how and when to test?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Testing software code is a painstaking and complicated process. The lion's share of work in it is done by unit tests. Until they ‚Äúlight up green‚Äù, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit tests: what, how and when to test?</h1><div class="post__text post__text-html js-mediator-article">  Testing software code is a painstaking and complicated process.  The lion's share of work in it is done by unit tests.  Until they ‚Äúlight up green‚Äù, there is no sense to test further. <br><br>  How to write unit-tests correctly?  Should I chase the 100% coverage?  What difficulties do engineers face in practice?  Marc Philipp and Vsevolod Brekelov share their experiences. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/0ed/984/924/0ed9849246554439aa28c3469957544e.png"></div><a name="habracut"></a><br><img src="https://habrastorage.org/web/ae6/72a/0ed/ae672a0edbbb4afc9a4ffc303e809a91.jpg" align="left">  Marc Philipp is one of the main developers of the JUnit 5 framework - a tool for Java testers.  Currently working as an engineer in the German company LogMeIn on cloud SaaS-solutions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/fee/36d/839/fee36d8394354a8b80688dd6697e1a41.jpg" align="right">  Vsevolod Brekelov - Senior QA Engineer in the company Grid Dynamics, has been testing for more than 5 years, has experience in building test automation from scratch. <br><br>  <b>- In articles about unit testing, examples of calculator methods and classes are usually given as examples.</b>  <b>Such examples can show the complexity of real problems?</b>  <b>What does a tester of full-featured programs face?</b> <br><br>  <b>Marc Philipp:</b> Indeed, with examples with a calculator, it is impossible to show the complexity of real tasks.  They are selected in articles to enable readers to focus on understanding unit-testing approaches without the need to parse complex code.  Although these examples are very simple, they demonstrate well the basic idea and principles of unit testing.  In real life, the code under test should be originally written taking into account the fact that Unit testing will be carried out on it.  One way to ensure this is to write tests before writing the code or almost simultaneously with it.  When you have code adapted for testing, writing unit tests is not much more difficult than for a calculator. <br><br>  <b>Vsevolod Brekelov:</b> I think that the complexity of real tasks can be understood only on real tasks.  Seriously, there are some good articles where nontrivial examples are considered in great detail.  I think that they will help to approach in reality. <br><br>  For example, on request ‚Äúunit testing java‚Äù you can quickly <a href="https://habrahabr.ru/post/169381">find an article on Habr√©</a> .  It was published for a long time, but has not lost its relevance. <br><br>  As for the features of the work, I would single out the following groups of testers (I hope not to offend anyone): <br><br><ul><li>  Back-end - can write system, integration, component, unit tests (why not?). </li><li>  Front-end - can write both e2e tests, and component, and unit tests. </li><li>  DB - are engaged in testing data / the database itself. </li><li>  Performance - here it seems to be obvious. </li><li>  Infrastructure - deal more with ‚Äúnear-loop‚Äù issues. </li><li>  Mobile testing (iOS, Androind, IoT) - now it has become very fashionable to separate such engineers, although in my opinion it's all about the same Back-end / Front-end. </li></ul><br>  These people usually do not only test the software itself, but also the requirements and the process itself.  True, they approach this more often formally, which, in my opinion, is wrong. <br><br>  I would like to draw attention to the process.  I believe that every tester should be well versed in building the development process, as in my practice, the legs, bugs, and the main waste of time on the implementation of what is not needed grow right from there. <br><br>  <b>- Each test should check one thing.</b>  <b>How fully in practice can this condition be met?</b>  <b>How do you fight addictions, what frameworks do you use?</b> <b><br><br></b>  <b>Marc Philipp:</b> When writing unit tests, usually one sample of the input data from the equivalence class in the tested problem area is taken.  Of course, you must first define these equivalence classes.  In each test, you add assertion only for those properties that are relevant to your test.  You should not copy the same assertions into each new test and drive them away.  When you have dependencies that affect the operation of a unit, consider using stubs or mocks to keep the test independent. <br><br>  Many of our unit tests for JUnit 5 use mocks created by the mocking framework (the Mockito in our case).  As I said above, they are very useful for testing isolated code.  The main task here is to make sure that your mox behaves like a real code.  Otherwise, the tests will become meaningless. <br><br>  <b>Vsevolod Brekelov:</b> Yes, there is an opinion: one unit test - one assertion.  In practice, I have seen this very rarely.  I think that this is the philosophy of the team.  Multiple assertions are quite self-occurring. <br><br>  If we conduct unit tests, not component tests, we isolate all dependencies (mocks, stubs - everything is in your hands).  There are no difficulties in my opinion.  And if they do, StackOverflow will definitely help. <br><br>  As I write in Java / JavaScript (Angular), I use the usual popular tools: <br>  in Java - Mockito / EasyMock.  For component tests, writing your responsive mock is also a good idea!  I advise everyone. <br><br>  JavaScript - ngMock.  By the way, for component tests a very cool topic - <a href="http://www.angularplayground.it/">AngularPlayground</a> . <br><br>  <b>- How to find a compromise between the labor and financial costs of testing and the quality of the final software in the implementation of "burning" projects?</b>  <b>How do you usually argue the importance of full testing in such cases?</b> <br><br>  <b>Marc Philipp</b> : In my experience, you cannot save a ‚Äúburning‚Äù project by skipping tests.  Writing unit tests is an integral part of software development.  Without it, you will not be able to find out if your code really does what you think it should do.  You will not be able to quickly fix anything, because you will not understand where that has broken.  As UncleBob <a href="http://butunclebob.com/ArticleS.UncleBob.VehementMediocrity">said</a> , ‚Äúthe only way to go quickly is to go well.‚Äù <br><br>  <b>Vsevolod Brekelov:</b> I think there is no definite answer.  Rather, it helps experience and type of project.  If you are doing a medical project or building a rocket, then the importance of testing does not have to say.  If you saw a startup in a week - what tests? <br><br>  It is very important to organize the process to avoid sudden bugs and incorrectly implemented requirements.  What is the correct process?  Of course, there is Agile Manifesto, which many people look at when organizing the process, but still something does not work.  You can take and build a process for the sake of the process.  And you can, and vice versa, follow <a href="http://programming-motherfucker.com/">http://programming-motherfucker.com/</a> . <br><br>  It seems to me that the main thing is to have requirements, the details of which suit developers and testers in a team.  This means that they have the same understanding of what will be output. <br><br>  <b>- What techniques help reduce the time and labor costs for testing?</b> <br><br>  <b>Marc Philipp:</b> ‚ÄúTesting‚Äù is an overloaded term.  It can mean anything: unit testing, manual testing, performance testing ... In my experience, manual testing, that is, manual execution of the test case walkthrough plan, is really expensive and often not as effective as you think.  Moreover, automating these boring tests only makes sense to a certain extent.  However, you should really follow the <a href="https://martinfowler.com/bliki/TestPyramid.html">test pyramid</a> , and not write too many of these end-to-end / UI tests.  Most of your tests should be real unit tests: independent, fast tests that you can perform very often.  Writing these tests is relatively cheap, especially if you know your tools.  They are very reliable, so you will not waste time updating them.  UI and Integration tests will always be more fragile due to the sheer number of components involved. <br><br>  <b>Vsevolod Brekelov:</b> There is a good technique - write less code. <br><br>  The main thing is to understand the process and what you want to decide (or test). <br>  Always need to adequately assess the budget and time.  What does it mean?  If you can afford to pour a lot of money into approaching 100% coverage - why not?  The owner is the master. <br><br>  If you do not have money for autotests (which, as you know, are fighting off mainly in long-running projects), then a crowd of manual testers is your option. <br><br>  If you don‚Äôt go to extremes, the most common mistake is writing e2e tests in batches before losing a pulse before unit tests, component tests, integration tests for Backend, Frontend, DB, Performance, etc. are written.  This trend probably follows the trendy BDD approaches (I don‚Äôt really like them).  What does all this lead to? <br><br>  The first degree of "intoxication" - automation starts to work for you.  You replace manual test cases with automatic ones.  Testers are starting to rejoice.  Managers are starting to think they are about to save. <br><br>  Second degree - there are a lot of tests; for some reason, some of them periodically fall.  Testers are not very happy.  Need to sit and understand the reasons.  But bugs still get through.  And, probably, they are even on QA environment by manual (maybe even monkey) testing. <br><br>  Third degree - everyone starts to go to conferences about Selenium (I have nothing against these conferences), learn how to deal with Flaky tests, try different solutions.  Let tests in parallel. <br><br>  The fourth degree is to build the entire hierarchy of the launch of 500 e2e tests on 50 agents, so that everything can fly fast, in as little as 10 minutes (I'm exaggerating here, of course).  And still there are bugs. <br><br>  Fifth degree - I will call it unreachable.  There comes the realization that most of the e2e tests are not needed.  Looking for other tests that no one ever wrote.  For example, component tests on the back-end or the same on the UI.  Or maybe not they, maybe system tests?  And maybe the layout tests?  Or maybe your {username} option? <br><br>  Certainly there are projects where everything is done "correctly."  But often there is the problem of misunderstanding what needs to be tested.  Only proper understanding can save your time and finances.  And what's more, improve the quality of the product. <br><br>  <b>- How does the development of development tools and code creation approaches affect testers tools and approaches?</b>  <b>What innovations make it easier</b> <b><br></b>  <b>unit-testing (for example, the presentation of methods in the form of lambda functions)?</b> <br><br>  <b>Marc Philipp:</b> New tools are trying to make life easier for developers, giving them more flexibility.  However, in the end, I believe that it does not matter if you present your tests as methods or as lambda functions.  Understanding what to test and how to test is the hardest part. <br><br>  <b>Vsevolod Brekelov:</b> The development of tools and approaches affects positively if they are used.  It is not always possible to apply HYIP technologies or approaches at work.  We still solve business problems.  But you can always find a balance. <br><br>  Which makes testing easier is a strange question.  I think that technology can not greatly facilitate life.  Since, in order to use something new (technology, tool), it needs to be studied by the whole team, by adopting some kind of ‚Äúpolicy‚Äù, code style.  This in the future can, of course, make life easier, but at short distances it is not very useful, as it is labor-intensive, IMHO. <br><br>  By the way, the option of switching to Kotlin (if we are talking about Java tests) may be a good idea.  I have not tried it in my practice yet. <br><br>  Regarding the innovations of the language (lambdas and other utilities) - this is all well and good, of course, but it is difficult for me to say how much they make life easier, as it should be measured.  I did not measure.  But just do not write me down as opponents of progress, I believe that the practice of learning / using something new should always be present.  This is the usual continuos improvement story. <br><br>  <b>- How much do you cover unit-tests your production projects?</b>  <b>Is it worth spending time on 100% coverage?</b> <b><br><br></b>  <b>Marc Philipp:</b> Depending on the programming language and the frameworks you use, there may be some template code in the project that does not contain any logic.  But apart from such pieces, in my opinion, you should write unit tests for all your code.  Thus, I would recommend coverage of more than 90%. <br><br>  <b>Vsevolod Brekelov:</b> In projects in which I had to work, the developers most often try to bring the tests to a coverage of 90%.  Is it worth spending time - usually decided by managers.  I am not a manager, but unit tests are a very good practice for me, it‚Äôs good to have 100% coverage when there are resources for it. <br><br>  The main thing is to remember that 100% coverage, unfortunately, does not guarantee that you do not have bugs. <br><br>  From what seems more useful than the race from 90% to 100% coverage, this is writing mutation tests.  I will not say anything new about the <a href="https://habrahabr.ru/post/139337/">2012 article</a> .  But in practice, I did not often see that this approach was applied (and I myself, too, repent).  So maybe it's time to start? <br><br>  <b>- How do test frameworks help with unit tests?</b>  <b>What part of the work do they take on?</b>  <b>What not to expect when using frameworks?</b> <br><br>  <b>Marc Philipp:</b> A good framework makes it very quick and easy to write simple unit tests and at the same time contain powerful mechanisms for conducting more complex tests.  For example, it should help you prepare test data and provide extension points that allow you to reuse the same logic in many tests.  But no framework decides for you what to do and how to test it.  Also, he cannot magically improve your project to make it well testable. <br><br>  <b>- Which elements of the code are the most difficult to unit test?</b>  <b>How do you solve this problem with you?</b> <b><br><br></b>  <b>Vsevolod Brekelov:</b> The more dependencies - the more routine, the harder it is to write a unit test.  But in general, I do not see any particular problems, to be honest.  Although a large number of books have been written on the subject of unit tests, of which I have not read one to the end.  Maybe that's why I'm not burdened with problems. <br><br>  For example, it is difficult to write a unit-test, when, say, the object constructor contains code vermicels, but then you can advise comrades to read books, <br>  <a href="https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683">for example</a> , enter code review practice. <br><br>  As for JavaScript code, there you can meet with various difficulties and surprises (yes, I really like JavaScript), rather related to the framework used, for example, working with digest.  I used only AngularJS / Angular2 / Angular4.  Despite the efforts of the Angular team to make a conveniently-tested framework, you still occasionally encounter problems that certainly have solutions, because we are engineers. <br><br><hr><br>  <i>A huge array of information about all aspects of testing is waiting for participants at the nearest Heisenbag, where Mark Phillip will read the report "JUnit 5 - The New Testing Framework for Java and Platform for the JVM".</i> <i><br><br></i>  <i>You can find out what other significant figures will perform at the conference and be able to answer the most pressing questions on the sidelines on the <a href="https://heisenbug-piter.ru/">site</a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/329372/">https://habr.com/ru/post/329372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329360/index.html">Type hinting according to all canons of polymorphism in old versions of PHP</a></li>
<li><a href="../329362/index.html">DevConf 2017: Effective WEB-project management - voting for reports ends</a></li>
<li><a href="../329366/index.html">A closer look at cyber attacks 3.0 (WannaCry video reviews)</a></li>
<li><a href="../329368/index.html">Customer scoring: what is it and why is it needed?</a></li>
<li><a href="../329370/index.html">5 reasons to attend a data visualization course</a></li>
<li><a href="../329374/index.html">Mobile market in numbers</a></li>
<li><a href="../329376/index.html">Pentestit Security Conference 2017: see you in July</a></li>
<li><a href="../329380/index.html">React Native from the bell tower of Android development part 1</a></li>
<li><a href="../329382/index.html">Top 11 free resources for learning English grammar</a></li>
<li><a href="../329384/index.html">GeekUniversity opens faculty of iOS development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>