<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basics of branching for parallel development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 As Fred Brooks rightly pointed out, there is no silver bullet capable of hitting the beast of software development. While new requirem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basics of branching for parallel development</h1><div class="post__text post__text-html js-mediator-article">  <b>Introduction</b> <br><br>  As <a href="http://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a> rightly pointed out, there is no <a href="http://en.wikipedia.org/wiki/No_Silver_Bullet">silver bullet</a> capable of hitting the beast of software development.  While new requirements arise, ideas and new bugs are found, programs are living and changing.  The path that code travels from version to version can be extremely complicated and tortuous.  Many people are involved in its creation: developers, testers, business analysts, customers, etc.  Despite the fact that there are many different types of development - outsourcing, product development, open-source, etc., the problems facing the team remain about the same.  Software is a complicated thing, the consumer wants to get it as quickly as possible (and cheaper).  The quality should be acceptable.  The development team is faced with a serious task - to establish effective interaction.  One of the most important means of collaboration within the development team is the code that they write. <br><br><a name="habracut"></a>  At the moment, distributed version control systems ( <a href="http://en.wikipedia.org/wiki/Distributed_revision_control">DVCS)</a> are widely distributed on the market.  However, the lion‚Äôs share of the market is kept by traditional and easier-to-use centralized systems, such as, for example, SVN.  A version control system, or rather its competent use, plays a key role in ensuring effective interaction.  Remember how long you read a book about your VCS?  A team in which there are no people capable of building competent interaction through VCS, based on the needs of the project, will not be envied. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Release Management</b> <br><br>  Let's imagine the perfect release management.  The release manager can evaluate the status of the code and select the implemented functionality to be included in the release.  This functionality should be ready and tested.  Also, the release manager can include bug fixes from the previous release.  The unavailable, unstable and untested functionality should not be released.  If QA-specialists receive information on the instability of a particular functional, the release manager should be able to remove it from the release.  Often there is a need to transfer defect fixes to the version that is already working for the end user, because for some reason it cannot switch to a new one. <br><br>  If you change the point of view a little and look at the process of working on the code by the developer, he should sit in his sandbox and not be influenced by destabilizing commits by his colleagues.  Ideally, developers should only exchange complete and stable sets of changes.  So it's easier to understand what has been done, right?  However, commits should not dictate to the developer the style of his work, and he should always be able to insert only partially completed functionality. <br>  The problems described above have several solutions.  One of them is the right choice and proper use of the project version control system.  One more thing is an understanding of possible brunching (branching) strategies and the price you have to pay for all this luxury. <br><br>  The use of branching allows us to kill two birds with one stone: to stabilize the release version (a process better known as bug fixing) and at the same time to extend the application with new functionality for the next release.  These are the two main, though not the only, ways of using branching on a project. <br><br>  <b>Retreat about code versioning</b> <br><br>  As a rule, version control systems store a history of changes in the form of a line (centralized) or a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">graph</a> (distributed).  A branch (brunch) is simply a line of code development that has a common history with other branches and exists in parallel with them.  Jeff Atwood in his <a href="http://www.codinghorror.com/blog/2007/10/software-branching-and-parallel-universes.html">blog</a> compares branches with parallel universes.  In such a universe, at some point, the story went differently relative to others.  This gives us limitless possibilities that are balanced by the limitless complexity of our universes. <br><br>  As a rule, one of our stories is the main one and wears the proud name of a trunk or mainline.  By analogy with a tree, other branches depart from it.  Sooner or later, ready-made (or not quite) functional and error fixes fall into this thread. <br><br>  <b>Branch per release</b> <br><br>  Consider the first of these cases, when a separate branch is created for each release.  This is done in order to correct defects found after the release of the release or during its testing.  This process is usually called stabilization.  At the same time, the fixes themselves (bugfixes) do not remain only in the release branches, but are transferred to the mainline (if the release history and the mainline are not too diverged), making it more stable.  The code in the release branch is isolated from the destabilizing effect of developing new functionality and does not block it.  By itself, the release branch provides an easy way to support the release version.  When release support stops, its branch is frozen.  In the meantime, the project goes on, mainline continues its development, being the point at which new functionality accumulates for the next releases. <br><br>  In the same way, you can support releases for different customers, highlighting a branch for each, if for some reason they cannot deliver the same version.  I want to note that the support of different variations of the same version is a laborious task and should be avoided as far as possible. <br><br><img src="https://habrastorage.org/storage2/20f/d9c/cc8/20fd9ccc8de638f960948133e5b95291.png"><br><br>  <b>Branch per feature</b> <br><br>  The next case is the <a href="http://martinfowler.com/bliki/FeatureBranch.html">allocation of a separate branch for the development of a new functional</a> .  As a rule, it is one logically complete functional area, or just a feature.  The new functionality is merged with the main branch only after it is fully completed, which allows you to avoid the negative impact of unfinished work on other lines of development.  After the new functionality is ready and merged with the main branch, other development branches should be integrated with the mainline so that the delayed integration effect does not accumulate.  The use of branches for releases and development allows us not to wait until the testing and release stabilization ends, but to immediately start developing the functionality for the next one. <br><br><img src="https://habrastorage.org/storage2/bc4/549/b70/bc4549b70e3657728b37125a1a764dc4.png"><br><br>  You can also create sub-branches for release and development branches, if you still need isolation levels.  In all cases, the creation of a new branch should understand the price of its support, which will be mentioned a little later. <br><br>  <b>Integration between branches</b> <br><br>  The main branch (mainline, trunk) is the main integration point using code.  Anyway, all the changes made by the developers get here.  However, it should not turn into a dump of unstable and unfinished code.  That is why it is recommended to develop new features in a separate branch, integrate it with the main one, test it and only then merge the changes.  In other words, the mainline should contain a fairly complete code that can serve as the basis for the stabilization release branch.  Also, bug fixes from the release branches, after passing through the mainline, fall into the branches for development, thus, work is being done on a more stable code.  The good rule is that we should not give unstable changes to other branches and that we should accept stable changes from other branches. <br><br><img src="https://habrastorage.org/storage2/8bc/032/6ba/8bc0326bab71f51712df6e9a0ecec19b.png"><br><br>  Consider the situation depicted in the picture: <br><br><ul><li>  At some point in the Mainline has accumulated a sufficient amount of the finished functionality for the release of Release 1.x.  A branch was created for it, and after testing and stabilization, the release went to the customers. </li><li>  In parallel with this, the development of a new functional started: feature A and feature B, each on its own branch. </li><li>  The bugs found by the releasers in Release 1.0 were fixed on the release branch, and Release 1.1 was released.  The bugfixes from it were merged with Mainline, from where they fell into branches for feature A and feature B. Thus, the work was done on a more stable code. </li><li>  One of the customers for their own reasons could not upgrade to version 1.1 and was faced with a number of specific defects.  This was fixed on a branch specifically made for him - Release 1.0.x. </li><li>  The development of feature A was completed, and, after integration and testing, these completed changes entered the Mainline.  The feature B branch receives these changes immediately after they hit the Mainline in order to work on the most current version of the code. </li><li>  A decision is made to release a new Release 2.x, including feature A, and a branch is created for it, on which the service for this release is provided - 2.1, 2.2.  Moreover, the bugfixes for release version 2.2 are not merged with Mainline, since the histories of these lines of code development have already diverged too much. </li></ul><br><br>  In assessing the pros and cons of this approach, one should take into account: <br><ul><li>  Feature branches do not stand in the way of Continuous Integration </li><li>  Semantic conflicts are not specific to branching. </li><li>  Feature toggling and Branch-by-abstraction have several disadvantages compared to the Feature branches. </li></ul><br><br>  Integration via Mainline is not the only way to integrate - integration is possible directly between branches.  <a href="http://martinfowler.com/">Martin Fowler</a> calls this method <a href="http://martinfowler.com/bliki/FeatureBranch.html">Promiscuous Integration</a> .  For this integration method, communication within the project team is very important. <br><br>  <b>Branch stability</b> <br><br>  Such a model has a gradation of stability, where the most stable release branches are, the mainline is less stable, and the most unstable are the development branches.  As a rule, in the diagrams the most stable branches are displayed above all, and unstable - below all. <br><br><img src="https://habrastorage.org/storage2/443/e01/a2b/443e01a2b5908c8d35e17c8505fb1189.png"><br><br>  <b>Branching overhead</b> <br><br>  The following costs are associated with branching: <br><br><ul><li>  <b>Mechanical</b> - these are the actions that need to be done to create a branch, switch from branch to branch, merge changes, etc.  As a rule, such actions are laborious for centralized systems and relatively simple for decentralized ones. </li><li>  <b>Intellectual</b> - these are the efforts that have to make to keep in mind all existing branches and their purpose.  As a rule, there are tools that facilitate this task.  This may include the training curve for employees associated with the development of a version control system. </li><li>  <b>Price for testing</b> - the use of parallel development can seriously increase the price of manual testing.  Deferred testing reduces costs, but at the same time has several disadvantages.  Any automatic testing significantly reduces the cost of testing when using branching.  In general, this point depends on the testing strategy adopted on the project. </li></ul><br><br>  <b>Types of dependencies between branches and how to solve them</b> <br><br>  The following dependencies may occur between branches: <br><br><ul><li>  <b>Architectural</b> - if we change the architecture on one branch, other branches may depend on these changes. </li><li>  <b>Functional</b> - some new functionality cannot be completed or has no special value, until the other functionality on which it depends is completed. </li><li>  <b>Dependencies on the correction of defects</b> - in the case of the correction of a defect on one branch, there may be several branches that should receive this change. </li></ul><br><br>  There are several typical solutions for working with such dependencies: <br><br><ul><li>  <b>Sub-branching</b> - dependent functionality is implemented in a separate sub-brunch and then merged with all interested branches. </li><li>  <b>Stop</b> - development on a branch is frozen until the desired functionality is ready. </li><li>  <b>Architectural abstraction</b> ‚Äî by abstraction, boundaries are created in the system that isolate different parts of the functionality.  In this case, the problem is solved not only at the level of the version control system, but also at the level of the application design. </li><li>  <b>Using stubs</b> - the system uses fakes / stubs, which are replaced with real functionality as it is ready. </li><li>  <b>Release, patch, re-release</b> - the system is released not fully finished and patches are brought to perfection (this practice in some industries is called paid beta testing). </li></ul><br><br>  <b>Conclusion</b> <br><br>  It is important to understand that a competent modular design of an application can greatly reduce or negate the need for branching and is a powerful tool for solving problems associated with parallel development. <br>  Branching allows us to simultaneously conduct two types of development: stabilization and implementation of new functionality.  However, this is not the only way to use it.  For example, individual branches can be allocated to separate iterations or to isolate different commands. <br>  The correct choice of branching strategy depends on the needs of the project and the possibilities / limitations of the version control system used (which, however, no one forbids changing).  Real-world constraints that are imposed on a process are often impossible to solve without the possibility of parallel development.  However, illiterate understanding and use of branching often leads to <a href="http://msdn.microsoft.com/en-us/library/aa730834(VS.80).aspx">anti-patterns</a> that complete this material. <br><br>  Anti branching patterns: <br><br><ul><li>  <b>Merge Paranoia</b> - developers are afraid to combine the code, so the negative effect of delayed integration is accumulating. </li><li>  <b>Merge Mania</b> - developers spend more time merging changes than developing. </li><li>  <b>Big Bang Merge</b> - branches do not exchange finished changes, so one giant union occurs at the end. </li><li>  <b>Never-Ending Merge</b> - the union never stops, as there is always something to unite. </li><li>  <b>Wrong Way Merge</b> - combining a later development branch with an earlier version. </li><li>  <b>Branch Mania</b> - creating a large number of branches for no reason at all. </li><li>  <b>Cascading Branches</b> - creating branches without merging them with the mainline at the end of development. </li><li>  <b>Mysterious Branches</b> - creating a branch for no reason. </li><li>  <b>Temporary Branches</b> - creating a branch with a changing reason for its existence: the branch becomes a temporary workspace. </li><li>  <b>Volatile Branches</b> - start a branch in an unstable state or transfer unstable changes to other branches. </li><li>  <b>Development Freeze</b> - stop all development to create branches, merge or create releases. </li><li>  <b>Berlin Wall</b> - using branches to divide people in a team, instead of dividing the areas they are working on. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/170589/">https://habr.com/ru/post/170589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../170579/index.html">Android tablet from Hewlett Packard for $ 169</a></li>
<li><a href="../170581/index.html">Atlassian Bamboo in pictures</a></li>
<li><a href="../170583/index.html">The film, funded by Kickstarter, won an Oscar</a></li>
<li><a href="../170585/index.html">How can I defend a thesis on QA in Russia?</a></li>
<li><a href="../170587/index.html">Announcement of the first wave of key speakers of the conference DevCon 2013</a></li>
<li><a href="../170597/index.html">Why do you need OOP patterns?</a></li>
<li><a href="../170599/index.html">Estonia was the first in the world to cover the country with a network of gas stations for electric vehicles</a></li>
<li><a href="../170603/index.html">Practical necromancy on the example of the game Gulf War: Operation Desert Hammer (1999)</a></li>
<li><a href="../170605/index.html">NoSQL DBMS MarkLogic - a brief overview</a></li>
<li><a href="../170607/index.html">A simple example of creating an ActiveX-control on Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>