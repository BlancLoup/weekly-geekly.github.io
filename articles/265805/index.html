<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>gRPC - framework for remote procedure call from Google</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the case of the remote procedure call, the case has long been exactly like in the famous ‚Äú14 standards‚Äù comic book - which is not the point : ancie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>gRPC - framework for remote procedure call from Google</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/e2d/7a5/31f/e2d7a531f783426fa5537acdbaeb42f1.png"><br>  In the case of the remote procedure call, the case has long been exactly like in the famous <a href="http://xkcd.ru/927/">‚Äú14 standards‚Äù</a> comic book - which is not the <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">point</a> : ancient DCOM and Corba, strange SOAP and .NET Remoting, modern REST and AMQP (yes, I know that some - that from this formally not RPC, in order to discuss the terminology, even here a <a href="http://habrahabr.ru/post/264181/">special topic was</a> recently created, however it is all used as RPC, and if something looks like a duck and swims like a duck - well, <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">you know</a> ) . <br><br>  And of course, in full accordance with the script of the comic, Google came to the market and announced that now he finally created another, the last and most correct RPC standard.  Google can be understood - to continue in the 21st century to drive petabytes of data through the old and inefficient HTTP + REST, losing money on every byte - just stupid.  At the same time, to take someone else‚Äôs standard and say ‚Äúwe couldn‚Äôt think of anything better‚Äù is absolutely not in their style. <br><br>  Therefore, meet, <a href="http://www.grpc.io/">gRPC</a> , which stands for ‚ÄúgRPC Remote Procedure Calls‚Äù - a new framework for remote call procedures from Google.  In this article we will talk about why, unlike the previous 14 standards, it will still take over the world (or at least part of it), we will try to build the gRPC build under Windows + Visual Studio (and don‚Äôt even tell me that the instruction is not needed - in the official documentation 5 pieces of important steps were missed, without which nothing is going to), and also try to write a simple service and client exchanging requests and answers. <br><a name="habracut"></a><br><h4>  Why do we need another standard? </h4><br>  First of all, let's look around.  What do we see?  We see REST + HTTP / 1.1.  No, there is everyone, but it is this cloud that closes a good three-fourths of the sky of client-server communications.  Looking a little closer, we see that REST degenerates into <a href="https://ru.wikipedia.org/wiki/CRUD">CRUD</a> in 95% of cases. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result, we have: <br><ul><li>  The ineffectiveness of the HTTP / 1.1 protocol - uncompressed headers, the lack of full two-way communication, an inefficient approach to the use of OS resources, excess traffic, unnecessary delays. </li><li>  The need to pull our data model and events on REST + CRUD, which often turns out like a balloon on a globe, forces Yandex to write these, no doubt, <a href="http://habrahabr.ru/company/yandex/blog/265569/">very good articles</a> , which, however, would not be needed if people did not have to think " What is the trigger spell to call elemental - PUT'om or POST'om?  And what is the HTTP code to return, so that it means ‚ÄúGo forward 3 cells and draw a new card?‚Äù </li></ul><br><br>  This is where gRPC begins.  So, out of the box we have: <br><ul><li>  <a href="https://ru.wikipedia.org/wiki/Protocol_Buffers">Protobuf</a> as a tool for describing data types and serialization.  Very cool and well-proven in practice stuff.  As a matter of fact, those who needed performance - they used to take Protobuf before, and then they would bother with transport separately.  Now everything is included. </li><li>  HTTP / 2 as a transport.  And this is an incredibly powerful move!  The beauty of full data compression, traffic control, event initiation from the server, re-use of one socket for several parallel requests is beautiful. </li><li>  Static paths - no more ‚Äúservice / collection / resource / query?  parameter = value ".  Now only "service", and what is inside - describe in terms of your model and its events. </li><li>  No binding of methods to HTTP methods, no binding of returned values ‚Äã‚Äãto HTTP statuses.  Write what you want. </li><li>  SSL / TLS, OAuth 2.0, authentication via Google services, plus you can tie your own (for example, two-factor) </li><li>  Support for 9 languages: C, C ++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP, C # plus, of course, no one forbids taking and implementing your version at least for Brainfack. </li><li>  Support gRPC in public APIs from Google.  Already working <a href="https://github.com/google/googleapis">for some services</a> .  No, of course, the REST versions will also remain.  But judge for yourself if you have a choice of using, say, from a mobile application, a REST version that gives data for 1 second or with the same development costs, take a gRPC version that works for 0.5 seconds - what would you choose?  And what will your competitor choose? </li></ul><br><br><h4>  Build gRPC </h4><br>  We need: <br><ul><li>  Git </li><li>  Visual Studio 2013 + Nuget </li><li>  CMake </li></ul><br><br><h4>  Pick up code </h4><br><ol><li>  We take <a href="https://github.com/grpc/grpc">gRPC repository</a> from Gitkhab </li><li>  We execute the command <br><pre><code class="bash hljs">git submodule update --init</code> </pre> <br>  - this is necessary in order to download the dependencies (protobuf, openssl, etc.). </li></ol><br><br><h4>  We collect Protobuf </h4><br><ul><li>  Go to the grpc \ third_party \ protobuf \ cmake folder and create the build folder there, go to it. </li><li>  We execute the command <br>  cmake -G "Visual Studio 12 2013" -DBUILD_TESTING = OFF ... </li><li>  Open the protobuf.sln file created in the previous step in Visual Studio and compile (F7). <br>  At this stage, we get valuable artifacts - the protoc.exe utility, which we need to generate serialization / data deserialization code and lib files, which will be needed when linking gRPC. </li><li>  Copy the grpc \ third_party \ protobuf \ cmake \ build \ Debug folder to the grpc \ third_party \ protobuf \ cmake folder. <br>  Once again - the Debug folder needs to be copied 1 level up.  This is some kind of inconsistency in the gRPC and Protobuf documentation.  Protobuf says that you need to build everything in the build folder, but the gRPC project sources do not know anything about this folder and are looking for Protobuf libraries directly in grpc \ third_party \ protobuf \ cmake \ Debug </li></ul><br><br><h4>  We collect gRPC </h4><br><ol><li>  Open the grpc \ vsprojects \ grpc_protoc_plugins.sln file and compile it. <br>  If you have completed Protobuf correctly in the previous step, everything should go smoothly.  Now you have plugins for protoc.exe, which allow it not only to generate serialization / deserialization code, but also to add gRPC functionality to it (strictly speaking, remote procedure call).  Plugins and protoc.exe should be put in one folder, for example, in grpc \ vsprojects \ Debug. </li><li>  Open the grpc \ vsprojects \ grpc.sln file and build it. <br>  In the course of the build, Nuget should start and download the necessary dependencies (openssl, zlib).  If you do not have Nuget or for some reason it did not download dependencies, there will be problems. <br>  At the end of the build, we will have all the necessary libraries that we can use in our project for communication via gRPC. </li></ol><br><br><h4>  Our project </h4><br>  Let's write such an API for Habrahabr using gRPC <br>  We will have the following methods: <br><ul><li>  GetKarma will receive a string with the username, and return a fractional number with the value of its karma </li><li>  PostArticle will receive a request to create a new article with all its metadata, and return the result of the publication - the structure with reference to the article, the time of publication, and the text of the error, if the publication failed. </li></ul><br><br>  This is all we need to describe in terms of gRPC.  It will look something like this (the description of the types can be found in the documentation for <a href="https://developers.google.com/protocol-buffers/docs/proto3">protobuf</a> ): <br><br><pre> <code class="javascript hljs">syntax = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; package HabrahabrApi; message KarmaRequest { string username = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message KarmaResponse { string username = <span class="hljs-number"><span class="hljs-number">1</span></span>; float karma = <span class="hljs-number"><span class="hljs-number">2</span></span>; } message PostArticleRequest { string title = <span class="hljs-number"><span class="hljs-number">1</span></span>; string body = <span class="hljs-number"><span class="hljs-number">2</span></span>; repeated string tag = <span class="hljs-number"><span class="hljs-number">3</span></span>; repeated string hub = <span class="hljs-number"><span class="hljs-number">4</span></span>; } message PostArticleResponse { bool posted = <span class="hljs-number"><span class="hljs-number">1</span></span>; string url = <span class="hljs-number"><span class="hljs-number">2</span></span>; string time = <span class="hljs-number"><span class="hljs-number">3</span></span>; string error_code = <span class="hljs-number"><span class="hljs-number">4</span></span>; } service HabrApi { rpc GetKarma(KarmaRequest) returns (KarmaResponse) {} rpc PostArticle(PostArticleRequest) returns (PostArticleResponse) {} }</code> </pre><br><br>  Go to the grpc \ vsprojects \ Debug folder and run 2 commands there (by the way, please note that there are errors in the official documentation, incorrect arguments): <br><pre> <code class="bash hljs">protoc --grpc_out=. --plugin=protoc-gen-grpc=grpc_cpp_plugin.exe habr.proto protoc --cpp_out=. habr.proto</code> </pre><br>  At the output we get 4 files: <br><ul><li>  habr.pb.h </li><li>  habr.pb.cc </li><li>  habr.grpc.pb.h </li><li>  habr.grpc.pb.cc </li></ul><br><br>  It is not difficult to guess, the procurement of our future client and service, which will be able to exchange messages according to the protocol described above. <br><br><h4>  Let's create a project already! </h4><br><ol><li>  Create a new solution in Visual Studio, let's call it HabrAPI. </li><li>  Add to it two console applications - HabrServer and HabrClient. </li><li>  Add the h and cc files generated in the previous step to them.  It is necessary to include all 4 in the server, in the client - only habr.pb.h and habr.pb.cc. </li><li>  Add the path to the grpc \ third_party \ protobuf \ src and grpc \ include folders in the settings of Additional Include Directories </li><li>  Add the path to grpc \ third_party \ protobuf \ cmake \ Debug in the project settings in Additional Library Directories </li><li>  Add in the project settings in Additional Dependencies library libprotobuf.lib </li><li>  We set the link type to be the same as Protobuf was built (Runtime Library property on the Code Generation tab).  At this point, it may be that you did not assemble Protobuf in the configuration you need, and you have to go back and rebuild it.  I chose both there and there / MTd. </li><li>  We add dependencies on zlib and openssl via Nuget. </li></ol><br><br>  Now we have everything going.  True, nothing is working yet. <br><br><h5>  Customer </h5><br>  Everything is simple here.  First, we need to create a class inherited from the stub generated in habr.pb.h.  Second, implement the GetKarma and PostArticle methods.  Third, call them and, for example, display the results in the console.  It turns out something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;grpc/grpc.h&gt; #include &lt;grpc++/channel.h&gt; #include &lt;grpc++/client_context.h&gt; #include &lt;grpc++/create_channel.h&gt; #include &lt;grpc++/credentials.h&gt; #include "habr.grpc.pb.h" using grpc::Channel; using grpc::ChannelArguments; using grpc::ClientContext; using grpc::Status; using HabrahabrApi::KarmaRequest; using HabrahabrApi::KarmaResponse; using HabrahabrApi::PostArticleRequest; using HabrahabrApi::PostArticleResponse; using HabrahabrApi::HabrApi; class HabrahabrClient { public: HabrahabrClient(std::shared_ptr&lt;Channel&gt; channel) : stub_(HabrApi::NewStub(channel)) {} float GetKarma(const std::string&amp; username) { KarmaRequest request; request.set_username(username); KarmaResponse reply; ClientContext context; Status status = stub_-&gt;GetKarma(&amp;context, request, &amp;reply); if (status.ok()) { return reply.karma(); } else { return 0; } } bool PostArticle(const std::string&amp; username) { PostArticleRequest request; request.set_title("Article about gRPC"); request.set_body("bla-bla-bla"); request.set_tag("UFO"); request.set_hab("Infopulse"); PostArticleResponse reply; ClientContext context; Status status = stub_-&gt;PostArticle(&amp;context, request, &amp;reply); return status.ok() &amp;&amp; reply.posted(); } private: std::unique_ptr&lt;HabrApi::Stub&gt; stub_; }; int main(int argc, char** argv) { HabrahabrClient client( grpc::CreateChannel("localhost:50051", grpc::InsecureCredentials(), ChannelArguments())); std::string user("tangro"); std::string reply = client.GetKarma(user); std::cout &lt;&lt; "Karma received: " &lt;&lt; reply &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br><h5>  Server </h5><br>  There is a similar history with the server - we inherit from the class of service generated in habr.grpc.pb.h and implement its methods.  Next, we run the listener on a certain port, and wait for the clients.  Something like that: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;memory&gt; #include &lt;string&gt; #include &lt;grpc/grpc.h&gt; #include &lt;grpc++/server.h&gt; #include &lt;grpc++/server_builder.h&gt; #include &lt;grpc++/server_context.h&gt; #include &lt;grpc++/server_credentials.h&gt; #include "habr.grpc.pb.h" using grpc::Server; using grpc::ServerBuilder; using grpc::ServerContext; using grpc::Status; using HabrahabrApi::KarmaRequest; using HabrahabrApi::KarmaResponse; using HabrahabrApi::PostArticleRequest; using HabrahabrApi::PostArticleResponse; using HabrahabrApi::HabrApi; class HabrahabrServiceImpl final : public HabrApi::Service { Status GetKarma(ServerContext* context, const KarmaRequest* request, KarmaResponse* reply) override { reply-&gt;set_karma(42); return Status::OK; } Status PostArticle(ServerContext* context, const PostArticleRequest* request, PostArticleResponse* reply) override { reply-&gt;set_posted(true); reply-&gt;set_url("some_url"); return Status::OK; } }; void RunServer() { std::string server_address("0.0.0.0:50051"); HabrahabrServiceImpl service; ServerBuilder builder; builder.AddListeningPort(server_address, grpc::InsecureServerCredentials()); builder.RegisterService(&amp;service); std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart()); std::cout &lt;&lt; "Server listening on " &lt;&lt; server_address &lt;&lt; std::endl; server-&gt;Wait(); } int main(int argc, char** argv) { RunServer(); return 0; }</span></span></span></span></code> </pre><br><br>  Good luck with gRPC. </div><p>Source: <a href="https://habr.com/ru/post/265805/">https://habr.com/ru/post/265805/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265795/index.html">Encodings and web pages</a></li>
<li><a href="../265797/index.html">Creating domain zones in AzureDns [cheat sheet]</a></li>
<li><a href="../265799/index.html">Perl5 plugin for IntelliJ IDEA</a></li>
<li><a href="../265801/index.html">Webpack for Single Page App</a></li>
<li><a href="../265803/index.html">Samsung SSDs high capacity for servers</a></li>
<li><a href="../265807/index.html">About duplicating web map tiles</a></li>
<li><a href="../265809/index.html">How to make tetris for half a year on cocos2dx</a></li>
<li><a href="../265811/index.html">Say a word about poor XWiki</a></li>
<li><a href="../265813/index.html">Translation of Richard Bartle's book Designing Virtual Worlds. Chapter 1. Basics</a></li>
<li><a href="../265815/index.html">[libGDX] Experience developing a game using Box2D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>