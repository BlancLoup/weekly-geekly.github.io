<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interface Inheritance and Contracts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the Code Contracts library, which kindly provides contract programming capabilities on the .NET platform, calls for static methods of the Contract ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interface Inheritance and Contracts</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://research.microsoft.com/en-us/projects/contracts/">Code Contracts</a> library, which kindly provides contract programming capabilities on the .NET platform, calls for static methods of the <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.contract.aspx">Contract</a> class are used to set preconditions and postconditions.  On the one hand, this is good, since an attribute-based alternative implementation would be too limited.  On the other hand, it adds certain difficulties when it comes to interface contracts or abstract methods, which, by their nature, do not contain any code, and therefore they simply have no reason to call methods. <br><br>  This is solved using two attributes: <b>ContractClassAttribute</b> , which hangs on the interface or an abstract class, and <b>ContractClassForAttribute</b> - which hangs on the contract itself. <br><a name="habracut"></a><br><pre><code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Custom collection interface /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [ContractClass(typeof(CollectionContract))] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface ICollection { <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(string s); <span class="hljs-type"><span class="hljs-type">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> Contains(string s); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Contract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> &lt;see cref="ICollection"/&gt;. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; [ContractClassFor(typeof(ICollection))] <span class="hljs-type"><span class="hljs-type">internal</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CollectionContract : ICollection { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(string s) { Contract.Ensures(Count &gt;= Contract.OldValue(Count)); Contract.Ensures(Contains(s)); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { Contract.Ensures(Contract.Result&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;() &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span>); } } [Pure] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span> Contains(string s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(<span class="hljs-type"><span class="hljs-type">bool</span></span>); } }</code> </pre> <br><br>  The benefits of this <b>ICollection</b> interface seem doubtful, but with their help we will be able to see all the necessary possibilities and limitations of contracts, with respect to the inheritance of interfaces.  This example focuses on the two members of the <b>CollectionContract</b> class: the <b>Add</b> method and the <b>Count</b> property, which define the preconditions / postconditions of the corresponding methods. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now, if some class implements our <b>ICollection</b> interface and violates the postcondition, we will see it at runtime as an exception (with a certain CONTRACT_FULL symbol), and also, possibly, during static analysis of the Static Checker code: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomCollection</span></span> : <span class="hljs-title"><span class="hljs-title">ICollection</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; _backingList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ok, we're crazy enough to violate precondition // of ICollection interface if (Contains(s)) _backingList.Remove(s); else _backingList.Add(s); } public int Count { get { // We should add some hints to static checker to eliminate a warning Contract.Ensures(Contract.Result&lt;int&gt;() == _backingList.Count); return _backingList.Count; } } public bool Contains(string s) { return _backingList.Contains(s); } }</span></span></code> </pre><br><br>  In this case, this is exactly what happens: Static Checker determines that in some cases the postcondition of the <b>Add</b> method fails (when adding an existing element, we delete itJ).  But if we do not believe him, we can see a breach of contract during the execution. <br><br><pre> <code class="hljs pgsql">[Test] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> TestAddTwiceAddsTwoElements() { var collection = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> CustomCollection(); <span class="hljs-type"><span class="hljs-type">int</span></span> oldCount = collection.Count; collection.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(""); collection.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(""); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.That(collection.Count, <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span>.EqualTo(oldCount + <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre><br><br>  This test will not <b>crash</b> when calling <b>Assert.</b>  <b>That</b> , and earlier, when trying to call the <b>Add</b> method again, with the following exception: <font>System.Diagnostics.Contracts .__ ContractsRuntime + ContractException: Postcondition failed: Count&gt; = Contract.OldValue (Count)</font> <br><br>  <font color="#526e66"><strong>NOTE</strong></font> <font color="#526e66"><br></font>  <font color="#526e66">Static analysis is one of the most interesting features of "contract programming", but now we can safely say that this thing in the Code Contracts library is not yet ready for real projects.</font>  <font color="#526e66">Firstly, the compilation time can increase by an order of magnitude (!), Secondly, it is necessary not to jump around with a tambourine around him so that he understands what is happening, but even in this case he will be little able to help in difficult cases.</font>  <font color="#526e66">Even in such a simple example, as with the <b>CustomCollection</b> class, <b>we</b> had to add the postcondition to the <b>Count</b> property manually, because without it, the static analyzer did not understand what was happening and gave a lot of warnings.</font>  <font color="#526e66">All other advantages of contracts, such as declarativeness, documentation, formalization of relations, etc.</font>  <font color="#526e66">remain, but they will work at runtime (for example, in conjunction with unit tests), and not at compile time.</font> <br><br><h5>  <b>Weakening of precondition and postcondition strengthening</b> </h5><br><br>  Contracts allow you to formalize relationships not only between classes and their clients, but also between classes and their heirs.  The preconditions of the virtual method will tell the client what to do to call this method, and the postcondition what the method will do in return;  Moreover, the client code can count on the execution of this contract, regardless of what the dynamic type of the object it works with will be.  This is what the principle of replacing Liskov says, which we discussed <a href="http://sergeyteplyakov.blogspot.com/2012/02/lsp.html">last time</a> and to which we will return. <br><br>  However, the principle of substitution does not prohibit heirs from making changes to the semantics of the method, unless it ‚Äúbreaks‚Äù the assumptions of customers.  Thus, the precondition of a method redefined in the successor may be less stringent to the calling code (it may contain a weaker precondition), and the postcondition may be more stringent ‚Äî the inheritor method may produce a more ‚Äúaccurate‚Äù result.  To translate from Russian into Russian, let's consider a simple example: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { Contract.Requires(!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(s)); Contract.Ensures(Contract.Result&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Derived</span></span> : <span class="hljs-title"><span class="hljs-title">Base</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Now we're requiring empty string Contract.Requires(s != null); // And returning only strings Contract.Ensures(Contract.Result&lt;object&gt;() is string); return s; } }</span></span></code> </pre><br><br>  In this example, the inheritor method requires less: the empty string is now a valid value;  and gives a more ‚Äúaccurate‚Äù result: it returns not just the <b>object</b> , but the type <b>string</b> (although this is guaranteed not by the compiler, but by the Static Checker). <br><br>  <font color="#526e66"><b>NOTE</b></font> <font color="#526e66"><b><br></b></font>  <font color="#526e66">A typical example of post-condition enhancement is the ability of derived classes to return a more specific type.</font>  <font color="#526e66">This feature is called covariance on the return type and is available in languages ‚Äã‚Äãsuch as C ++ or Java.</font>  <font color="#526e66">If C # supported this feature, it would be possible to change the signature of the method Derived.Foo and return a <b>string</b> , not an <b>object</b> .</font>  <font color="#526e66">Another example of weakening preconditions and enhancing postconditions is the covariance and contravariance of delegates and interfaces, available from the 4th version of the C # language.</font>  <font color="#526e66">You can read more about the ‚Äústrictness‚Äù of the conditions in the article</font> <a href="http://sergeyteplyakov.blogspot.com/2010/05/design-by-contract.html"><font color="#526e66">Design by Contract.</font></a>  <a href="http://sergeyteplyakov.blogspot.com/2010/05/design-by-contract.html"><font color="#526e66">On the correctness of software</font></a> <font color="#526e66">, and on contracts and inheritance - in the article</font> <a href="http://sergeyteplyakov.blogspot.com/2010/05/blog-post_17.html"><font color="#526e66">Design by contract.</font></a>  <a href="http://sergeyteplyakov.blogspot.com/2010/05/blog-post_17.html"><font color="#526e66">Inheritance</font></a> <font color="#526e66">.</font> <br><br>  The developers of <b>Code</b> <b>Contracts</b> considered the possibility of weakening the postconditions to be meaningless, so we have no such possibility.  The above <b>Derived</b> class code is compiled, but the precondition of the <b>Derived</b> method <b>.</b>  <b>Foo is</b> not weakened, which means that when a blank line is passed, the precondition will be violated.  However, unlike the preconditions, with the post-conditions we are <s>almost</s> all in order.  Postconditions (by the way, like class invariants) are "summed up", which really allows us to guarantee more.  (If you change the body of the method <b>Derived</b> <b>.</b> <b>Foo</b> so that in some cases it returns an <b>int</b> rather than a <b>string</b> , then this violation will be detected by Static Checker and will also be checked at runtime.) <br><br><h5>  <b>Postconditions and interfaces</b> </h5><br><br>  Now let's move from base classes to interfaces.  In the first section, we looked at the <b>ICollection</b> interface, the <b>post</b> -condition of which was ‚Äúnot decreasing‚Äù the number of elements in the collection.  This postcondition is derived from the <b>ICollection</b> <b>of</b> <b>T</b> interface contract from the BCL.  After installing Code Contracts, we have at our disposal not only the possibility of creating contracts for our own classes, but also the possibility of using contracts of standard classes from the BCL. <br><br>  But before proceeding to the analysis of contracts of standard interfaces, let's try to create our own hierarchy of interfaces, and play around with the postconditions of the <b>Add</b> method. <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">ContractClass(typeof(ListContract))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IList</span></span> : <span class="hljs-title"><span class="hljs-title">ICollection</span></span> { } [ContractClassFor(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IList))] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListContract</span></span> : <span class="hljs-title"><span class="hljs-title">IList</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Lets create stronger postcondition than ICollection.Add Contract.Ensures(Count == Contract.OldValue(Count) + 1); } //   Count   Contains   }</span></span></code> </pre><br><br>  This <b>IList</b> interface adds not only post-conditions, but also a bunch of other interesting things, but in this case it does not matter.  Now add a class that implements the <b>IList</b> interface, which violates the post-condition of the interface: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomList</span></span> : <span class="hljs-title"><span class="hljs-title">IList</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; _backingList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// IList postcondition is Count = OldCount + 1, // we're violating it _backingList.Add(s); _backingList.Add(s); } public int Count { get { return _backingList.Count; } } public bool Contains(string s) { return _backingList.Contains(s); } }</span></span></code> </pre><br><br>  We clearly violate the post-condition of the <b>Add</b> method of the <b>IList</b> interface, since it increases the number of elements not by one, but immediately by 2. However, the sad thing is that neither the static analyzer, nor even the rewriter does not react to the increased post-conditions at the interfaces.  Now, as a matter of fact, this possibility is not supported by the Code Contract library (and the developers consider this a feature, not a bug, see the details <a href="http://social.msdn.microsoft.com/Forums/en-US/codecontracts/thread/db80fea9-65d2-4fe0-be9c-38b5daf3d418">here</a> ).  So at the moment we can strengthen the post-conditions of virtual methods, we can strengthen the post-condition in a class that implements some interface, but <strong>we cannot strengthen the post-conditions in the heirs of interfaces</strong> ! <br><br>  The trouble with this point is the following: first, the only way to find out about the existence of more strictly interface postconditions is to manually search for the contract code (recall that neither the Static Checker nor the rewriter adds information about the postcondition of the successor to the result code);  secondly, this example is not artificial, this problem can be encountered using standard interfaces of the BCL collections. <br><br><h5>  <b>Contracts</b> <b>ICollection of T</b> <b>and</b> <b>IList of T</b> </h5><br><br>  If you rummage properly in the <b>mscorlib</b> assembly <b>.</b>  <b>Contracts</b> <b>.</b>  <b>dll</b> , which appears after installing Code Contracts, then you can find a lot of interesting things about the contracts of the standard .NET Framework classes and collection contracts, in particular.  Here are the contracts for the basic methods of the <b>ICollection</b> <b>of</b> <b>T</b> and <b>IList</b> <b>of</b> <b>T</b> interfaces: <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> mscorlib.Contracts.dll [ContractClassFor(typeof(ICollection&lt;&gt;))] <span class="hljs-type"><span class="hljs-type">internal</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ICollectionContract&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>([MarshalAs(UnmanagedType.Error)] T item) { Contract.Ensures(this.Count &gt;= Contract.OldValue&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(this.Count), "this.Count &gt;= Contract.OldValue(this.Count)"); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Clear() { Contract.Ensures(this.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>, "this.Count == 0"); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-type"><span class="hljs-type">int</span></span> num = <span class="hljs-number"><span class="hljs-number">0</span></span>; Contract.Ensures(Contract.Result&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;() &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>, "Contract.Result&lt;int&gt;() &gt;= 0"); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num; } } } // <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> mscorlib.Contracts.dll [ContractClassFor(typeof (IList&lt;&gt;))] <span class="hljs-type"><span class="hljs-type">internal</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> IListContract&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable { <span class="hljs-type"><span class="hljs-type">void</span></span> ICollection&lt;T&gt;.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>([MarshalAs(UnmanagedType.Error)] T item) { Contract.Ensures(this.Count == (Contract.OldValue&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(this.Count) + <span class="hljs-number"><span class="hljs-number">1</span></span>), "Count == Contract.OldValue(Count) + 1"); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-type"><span class="hljs-type">int</span></span> num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num; } } }</code> </pre><br><br>  <font color="#526e66"><b>NOTE</b></font> <font color="#526e66"><br></font>  <font color="#526e66">Contracts for different versions of the .NET Framework are located in different places, contracts for the 4th version of the framework, for example, are located in the following path: ‚Äú% PROGRAMS% \ Microsoft \ Contracts \ Contracts \ .NETFramework \ v.4.0 \‚Äù.</font>  <font color="#526e66">Assemblies with contracts are called as follows: OriginalAssemblyName.Contracts.dll: mscorlib.Contracts.dll, System.Contracts.dll, System.Xml.Contracts.dll.</font> <br><br>  As we can see, the post-condition of the list is really stronger and it requires that when calling the <b>Add</b> method a new element appears in the list, and only one.  The difference in the postconditions of the two interfaces is due to the fact that not all BCL collections add a new element when calling the <b>Add</b> method ( <b>HashSet</b> and <b>SortedSet</b> do not add an element if it is already present in the collection);  however, all lists add only one new item.  This problem is solved by adding an explicit postcondition to a specific collection class ( <b>List</b> <b>of</b> <b>T</b> or, in our case, the <b>DoubleList</b> class), but in this case the main feature of interface contracts is lost: the ability to specify the behavior of the class family. <br><br><h5>  <b>Conclusion</b> </h5><br><br>  Not all developers are comfortable thinking about interface contracts or abstract methods, because in .NET they do not contain any information about the intended behavior.  But if you look at it from the other side, the importance of contracts specifically for such methods is much higher.  In the case of a specific method, we can look at its implementation and define explicit or implicit preconditions and postconditions.  But to define an interface contract, we can repel only scanty and informal documentation or analyze all implementations of this interface to determine the ‚Äúcommon‚Äù denominator of behavior that should not be violated according to the substitution principle. <br><br><h5>  <b>Additional links</b> </h5><br><ol><li>  <a href="https://github.com/SergeyTeplyakov/ContractsAndInheritance">ContractsAndInheritance project on GitHub</a> .  Contains all the examples of this article with tests and comments. <br></li><li>  Bertrand Meyer.  <a href="http://www.ozon.ru/context/detail/id/2336754/">Object-oriented design of software systems</a> <br></li><li>  <a href="http://sergeyteplyakov.blogspot.com/2010/05/blog-post_17.html">Design by contract.</a>  <a href="http://sergeyteplyakov.blogspot.com/2010/05/blog-post_17.html">Inheritance</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/139443/">https://habr.com/ru/post/139443/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139433/index.html">Running multiple node.js sites on the same server</a></li>
<li><a href="../139434/index.html">MIT opened Google App Inventor in beta</a></li>
<li><a href="../139435/index.html">Documentation for Grab - library for parsing sites</a></li>
<li><a href="../139438/index.html">Common work space for home and office</a></li>
<li><a href="../139439/index.html">Download without haste</a></li>
<li><a href="../139444/index.html">Google.Maps + 1c: Enterprise 8.2</a></li>
<li><a href="../139445/index.html">Mini-report from the international conference Cloud Services Russia 2012</a></li>
<li><a href="../139447/index.html">Android Robot has become more popular Opera</a></li>
<li><a href="../139449/index.html">New life of your postal addresses in Rambler-Mail</a></li>
<li><a href="../139450/index.html">Top up in the ASA lineup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>