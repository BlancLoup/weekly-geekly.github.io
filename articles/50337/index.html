<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a parser for ini-files in Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I will tell you how to write your Haskell ini-file parser. I will take as a basis the context-free grammar built in my previous artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a parser for ini-files in Haskell</h1><div class="post__text post__text-html js-mediator-article">  In this article, I will tell you how to write your Haskell ini-file parser.  I will take as a basis the context-free grammar built <a href="http://avsmal.habrahabr.ru/blog/50973/">in my previous article</a> .  To build the parser, <a href="http://www.haskell.org/haskellwiki/Parsec">Parsec</a> library will be used, which allows you to build your own parsers by combining ready-made <i>primitive</i> parsers using <i>parser combinators</i> . <br><br>  <b>Important:</b> This article assumes that the reader is familiar with the basics of Haskell.  If this is not the case, then I advise you first to read a couple of articles for beginners (they can be found including on Habr√©). <br><a name="habracut"></a><br><h2>  Grammar </h2><br>  First, let us recall which grammar for ini-files we built in the previous article: <br> <code>inidata = spaces, {section} . <br> section = "[", ident, "]", stringSpaces, "\n", {entry} . <br> entry = ident, stringSpaces, "=", stringSpaces, value, "\n", spaces . <br> ident = identChar, {identChar} . <br> identChar = letter | digit | "_" | "." | "," | ":" | "(" | ")" | "{" | "}" | "-" | "#" | "@" | "&amp;" | "*" | "|" . <br> value = {not "\n"} . <br> stringSpaces = {" " | "\t"} . <br> spaces = {" " | "\t" | "\n" | "\r"} . <br></code> <br>  We will need her description soon. <br><br><h2>  Haskell and Parsec </h2><br>  Start by installing Parsec (you can take it on the official website or search for ready-made packages for your OS).  The installation process for different systems may be different, so I will not describe it here. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will try to describe in detail the process of creating a parser on Haskell.  Let's start with connecting the necessary modules.  In addition to the standard System (for getting parameters), Data.Char (for the isSpace function) and Data.List (for the find function), you need to connect the Parsec module - Text.ParserCombinators.Parsec. <br> <code>1 <font color="#00ff00"><b>module</b></font> Main <font color="#00ff00"><b>where</b></font> <br> 2 <br> 3 <font color="#ff6060"><b>import</b></font> System.Environment <br> 4 <font color="#ff6060"><b>import</b></font> Data.Char <br> 5 <font color="#ff6060"><b>import</b></font> Data.List <br> 6 <font color="#ff6060"><b>import</b></font> Text.ParserCombinators.Parsec <br></code> <br>  We define data types: a record is a key ‚Äì value pair, a section is a key ‚Äì list of records pair, all ini-file data is a list of sections. <br> <code>8 <font color="#00ff00">type</font> Entry <font color="#ff6060"><b>=</b></font> (String, String) <br> 9 <font color="#00ff00">type</font> Section <font color="#ff6060"><b>=</b></font> (String, [Entry]) <br> 10 <font color="#00ff00">type</font> IniData <font color="#ff6060"><b>=</b></font> [Section] <br></code> <br>  Now we will transfer the grammar from the Backus-Naur notation into Haskell.  Let's start with inidata. <br> <code>12 inidata <font color="#ff6060"><b>=</b></font> spaces <font color="#ff6060"><b>&gt;&gt;</b></font> many section <font color="#ff6060"><b>&gt;&gt;=</b></font> return <br></code> <br>  Let me explain what is written here: inidata consists of spaces (this is a primitive parser of the Parsec library), followed by (indicated by the monadic operator &gt;&gt;) many sections, the values ‚Äã‚Äãof which we return (&gt;&gt; = return). <br>  What does it mean returning values?  The task of the parser is not only to check the correspondence of the grammar and data, but also to convert the data into some kind of structural form.  In our case, this is the data type IniData.  The many function is a parser combinator that builds a parser for {A} for some non-terminal A parser. <br><br>  Now let's translate the nonterminal section into Haskell.  section is much more complicated than inidata and therefore I will write it in do-notation. <br> <code>14 section <font color="#ff6060"><b>=</b></font> <font color="#8080ff"><b>do</b></font> <br> 15          char <font color="#0000ff">'['</font> <br> 16          name <font color="#ff6060"><b>&lt;-</b></font> ident <br> 17          char <font color="#0000ff">']'</font> <br> 18          stringSpaces <br> 19          char <font color="#0000ff">'</font> <font color="#0000ff">\n</font> <font color="#0000ff">'</font> <br> 20          spaces <br> 21          el <font color="#ff6060"><b>&lt;-</b></font> many entry <br> 22          return (name, el) <br></code> <br>  This code is an almost literal translation of the nonterminal section from Backus-Naur notation.  The char function creates a primitive parser that parses one character.  It is worth paying attention to lines 16, 21 and 22. In line 16 we save the value of the ident non terminal (section name), and in line 21 we save the list of records that follow the section header.  In line 22, we return the read section name and the list of entries (this corresponds to the Section type). <br><br>  Go to the records. <br> <code>24 entry <font color="#ff6060"><b>=</b></font> <font color="#8080ff"><b>do</b></font> <br> 25          k <font color="#ff6060"><b>&lt;-</b></font> ident <br> 26          stringSpaces <br> 27          char <font color="#0000ff">'='</font> <br> 28          stringSpaces <br> 29          v <font color="#ff6060"><b>&lt;-</b></font> value <br> 30          spaces <br> 31          return (k, v) <br></code> <br>  If you understand how we built the parser for a section, then there should not be any problems.  In short: in lines 25 and 29 we save the name of the parameter and its value, and return a pair composed of them (corresponds to the type Entry). <br><br>  Write a nonterminal for the identifier.  We will use the fact that in Parsec there is a combinator many1, which will allow to splices the non-terminals identChar and ident into one (we could not do it in Backus-Naur notation, because there is no such designation). <br> <code>32 ident <font color="#ff6060"><b>=</b></font> many1 (letter <font color="#ff6060"><b>&lt;|&gt;</b></font> digit <font color="#ff6060"><b>&lt;|&gt;</b></font> oneOf <font color="#0000ff">"_.,:(){}-#@&amp;*|"</font> ) <font color="#ff6060"><b>&gt;&gt;=</b></font> return <font color="#ff6060"><b>.</b></font> trim <br></code> <br>  The combinator many1 means that the identifier consists of at least one character.  Operator &lt;|&gt; matches the character "|"  in the Backus-Naur notation.  letter and digit are <i>primitive</i> parsers for letters and numbers, respectively.  The oneOf function for a string is equivalent to (char '_' &lt;|&gt; char '.' &lt;|&gt; .....).  Note also that when returning a value, the resulting string is truncated (using the trim function). <br><br>  We do the same with non-terminal for a value, but using the noneOf parser, which is inverse to oneOf. <br> <code><br> 34 value <font color="#ff6060"><b>=</b></font> many (noneOf <font color="#0000ff">"</font> <font color="#0000ff">\n</font> <font color="#0000ff">"</font> ) <font color="#ff6060"><b>&gt;&gt;=</b></font> return <font color="#ff6060"><b>.</b></font> trim <br></code> <br><br>  The last nonterminal remained - stringSpaces (nonterminal spaces already exist in Parsec). <br> <code>36 stringSpaces <font color="#ff6060"><b>=</b></font> many (char <font color="#0000ff">' '</font> <font color="#ff6060"><b>&lt;|&gt;</b></font> char <font color="#0000ff">'</font> <font color="#0000ff">\t</font> <font color="#0000ff">'</font> ) <br></code> <br>  With grammar everything.  It remains to identify several useful functions and, of course, the main itself. <br><br>  The trim function is needed to remove extra spaces at the beginning and end of a line. <br> <code>38 trim <font color="#ff6060"><b>=</b></font> f <font color="#ff6060"><b>.</b></font> f <br> 39 <font color="#00ff00"><b>where</b></font> f <font color="#ff6060"><b>=</b></font> reverse <font color="#ff6060"><b>.</b></font> dropWhile isSpace <br></code> <br>  The split function splits text into lines using the delim separator, with the separator itself remaining at the end of the line. <br> <code>41 split delim <font color="#ff6060"><b>=</b></font> foldr f [[]] <br> 42 <font color="#00ff00"><b>where</b></font> <br> 43     f x rest <font color="#ff6060"><b>@</b></font> (r <font color="#ff6060"><b>:</b></font> rs) <br> 44 <font color="#ff6060"><b>|</b></font> x <font color="#ff6060"><b>==</b></font> delim <font color="#ff6060"><b>=</b></font> [delim] <font color="#ff6060"><b>:</b></font> rest <br> 45 <font color="#ff6060"><b>|</b></font> otherwise <font color="#ff6060"><b>=</b></font> (x <font color="#ff6060"><b>:</b></font> r) <font color="#ff6060"><b>:</b></font> rs <br></code> <br>  The removeComments function removes comments and empty lines: it breaks the text into lines, removes those that begin with ";"  or "\ n", and then sticks them together again. <br> <code>47 removeComments <font color="#ff6060"><b>=</b></font> foldr ( <font color="#ff6060"><b>++</b></font> ) [] <font color="#ff6060"><b>.</b></font> filter comment <font color="#ff6060"><b>.</b></font> split <font color="#0000ff">'</font> <font color="#0000ff">\n</font> <font color="#0000ff">'</font> <br> 48 <font color="#00ff00"><b>where</b></font> comment [] <font color="#ff6060"><b>=</b></font> False <br> 49                   comment (x <font color="#ff6060"><b>:</b></font> _) <font color="#ff6060"><b>=</b></font> (x <font color="#ff6060"><b>/=</b></font> <font color="#0000ff">';'</font> ) <font color="#ff6060"><b>&amp;&amp;</b></font> (x <font color="#ff6060"><b>/=</b></font> <font color="#0000ff">'</font> <font color="#0000ff">\n</font> <font color="#0000ff">'</font> ) <br></code> <br>  The findValue function searches IniData for the parameter value by the section name and the parameter name (the calculation occurs in the Maybe monad).  First we find the section by name, and then among the records from the section we find the necessary parameter.  If at some point we find nothing, the function will simply return Nothing. <br> <code>51 findValue ini s p <font color="#ff6060"><b>=</b></font> <font color="#8080ff"><b>do</b></font> <br> 52             el <font color="#ff6060"><b>&lt;-</b></font> find ( <font color="#ff6060"><b>\</b></font> x <font color="#ff6060"><b>-&gt;</b></font> fst x <font color="#ff6060"><b>==</b></font> s) ini <br> 53             v <font color="#ff6060"><b>&lt;-</b></font> find ( <font color="#ff6060"><b>\</b></font> x <font color="#ff6060"><b>-&gt;</b></font> fst x <font color="#ff6060"><b>==</b></font> p) (snd el) <br> 54             return <font color="#ff6060"><b>$</b></font> snd <font color="#ff6060"><b>$</b></font> v <br></code> <br><br>  Go to the last step - the function main. <br><br> <code>56 main <font color="#ff6060"><b>=</b></font> <font color="#8080ff"><b>do</b></font> <br> 57       args <font color="#ff6060"><b>&lt;-</b></font> getArgs <br> 58       prog <font color="#ff6060"><b>&lt;-</b></font> getProgName <br> 59 <font color="#8080ff"><b>if</b></font> (length args) <font color="#ff6060"><b>/=</b></font> <font color="#0000ff">3</font> <br> 60 <font color="#8080ff"><b>then</b></font> putStrLn <font color="#ff6060"><b>$</b></font> <font color="#0000ff">"Usage: "</font> <font color="#ff6060"><b>++</b></font> prog <font color="#ff6060"><b>++</b></font> <font color="#0000ff">" &lt;file.ini&gt; &lt;section&gt; &lt;parameter&gt;"</font> <br> 61 <font color="#8080ff"><b>else</b></font> <font color="#8080ff"><b>do</b></font> <br> 62             file <font color="#ff6060"><b>&lt;-</b></font> readFile <font color="#ff6060"><b>$</b></font> head args <br> 63             [s,p] <font color="#ff6060"><b>&lt;-</b></font> return <font color="#ff6060"><b>$</b></font> tail args <br> 64             lns <font color="#ff6060"><b>&lt;-</b></font> return ( removeComments file ) <br> 65 <font color="#8080ff"><b>case</b></font> (parse inidata <font color="#0000ff">"some text"</font> lns) <font color="#8080ff"><b>of</b></font> <br> 66                Left  err <font color="#ff6060"><b>-&gt;</b></font> putStr <font color="#0000ff">"Parse error: "</font> <font color="#ff6060"><b>&gt;&gt;</b></font> print err <br> 67                Right x <font color="#ff6060"><b>-&gt;</b></font> <font color="#8080ff"><b>case</b></font> (findValue x s p) <font color="#8080ff"><b>of</b></font> <br> 68                                 Just x <font color="#ff6060"><b>-&gt;</b></font> putStrLn x <br> 69                                 Nothing <font color="#ff6060"><b>-&gt;</b></font> putStrLn <font color="#0000ff">"Can't find requested parameter"</font> <br> 70             return () <br></code> <br>  Everything is simple here as in the good old C. Lines 57-58 - we get the parameters and the name of the program.  Further, if the parameters are not 3, then print the usage.  If everything is ok with the parameters, then we read the file (62) and delete the comments (64). <br>  Now you need to run the parser.  For this there is a function parse (65), which needs to transfer the main non-terminal, the name of the text (used for error output) and the text itself.  The parse function returns either an error description (Left, 65), or data received (Right, 66).  If everything is parsed, then in the data we are looking for a record by section name and parameter name (67).  The search can return either the value found (Just, 68), then we display it, or nothing (Nothing, 69) - then we display an error message. <br><br>  Now the code is completely written.  Compile it and run it on a test sample. <br> <code>$ ghc --make ini.hs -o ini_hs <br> [1 of 1] Compiling Main ( ini.hs, ini.o ) <br> Linking ini_hs ... <br> <br> $ ./ini_hs /usr/lib/firefox-3.0.5/application.ini App ID <br> {ec8030f7-c20a-464f-9b0e-13a3a9e97384} <br> <br> $ ./ini_hs /usr/lib/firefox-3.0.5/application.ini App IDD <br> Can't find requested parameter <br></code> <br><br>  I hope that this article will help you write your own parser =) <br><br>  <b>An interesting note:</b> you can compare the parser from this article with the C ++ parser from the article <a href="http://habrahabr.ru/blogs/cpp/50976/">‚ÄúCreate a parser for ini-files in C ++‚Äù</a> . <br><br>  Ps.  Thank you for helping move this post to the Haskell blog. </div><p>Source: <a href="https://habr.com/ru/post/50337/">https://habr.com/ru/post/50337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../50326/index.html">An indispensable assistant for large MySQL dumps</a></li>
<li><a href="../50327/index.html">Laws for life</a></li>
<li><a href="../50328/index.html">Methods for protecting a web form without captcha</a></li>
<li><a href="../50333/index.html">Ubuntu Open Week: Ubuntu hike to servers</a></li>
<li><a href="../50335/index.html">Sample pen to run applications through X-forwarding on a server on the Internet</a></li>
<li><a href="../50338/index.html">Where are my pictures ?!</a></li>
<li><a href="../50340/index.html">QIP Infium - Carl at Clara ...</a></li>
<li><a href="../50341/index.html">Comparison of PHP frameworks: CakePHP, CodeIgniter and Yii</a></li>
<li><a href="../50345/index.html">About computer science in general</a></li>
<li><a href="../50346/index.html">About knowledge and skills of the programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>