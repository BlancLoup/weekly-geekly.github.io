<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simplifying code with if constexpr in C ++ 17</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Several new features of C ++ 17 allow you to write more compact and clear code. This is especially important with template meta-programming, the resul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simplifying code with if constexpr in C ++ 17</h1><div class="post__text post__text-html js-mediator-article"><p>  Several new features of C ++ 17 allow you to write more compact and clear code.  This is especially important with template meta-programming, the result of which often looks creepy ... </p><br><p> For example, if you want to express <code>if</code> , which is calculated at compile time, you will be forced to write code using <a href="https://habrahabr.ru/post/205772/">SFINAE</a> techniques (for example, <code>enable_if</code> ) or static dispatching (tag dispatching).  Such expressions are hard to understand, and they look like magic to developers unfamiliar with advanced meta-programming templates. </p><br><p>  Fortunately, with the advent of C ++ 17, we get <code>if constexpr</code> .  Now the majority of SFINAE techniques and static dispatching disappears, and the code is reduced, becoming similar to the "normal" <code>if</code> . </p><br><p>  This article demonstrates several techniques for using <code>if constexpr</code> . </p><a name="habracut"></a><br><h1 id="vvedenie">  Introduction </h1><br><p>  Static <code>if</code> in form <code>if constexpr</code> useful feature that appeared in C ++ 17.  Recently, the Meeting C ++ website published a story about how the author of the article Jens simplified code using <code>if constexpr</code> : <a href="http://meetingcpp.com/blog/items/How-if-constexpr-simplifies-your-code-in-Cpp17.html">How if constexpr simplifies your code in C ++ 17</a> . </p><br><p>  I found a couple of additional examples that can demonstrate how the new feature works. </p><br><ul><li>  Comparison of numbers </li><li>  Variable Factor Factories </li></ul><br><p>  I hope these examples will help you understand the static <code>if</code> from C ++ 17. <br>  But first, I'd like to refresh the basics of <code>enable_if</code> . </p><br><h1 id="dlya-chego-nuzhen-if-vo-vremya-kompilyacii">  What is the need for if at compile time? </h1><br><p>  Hearing this for the first time, you might ask, why do we need a static <code>if</code> and these complex patterned expressions ... Wouldn't a normal <code>if</code> not work? </p><br><p>  Consider an example: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;) <span class="hljs-comment"><span class="hljs-comment">//      return t; else return std::to_string(t); }</span></span></code> </pre><br><p>  This function can serve as a simple tool for displaying textual representation of objects.  Since <code>to_string</code> does not accept a parameter of type <code>std::string</code> , we can check this and simply return <code>t</code> if <code>t</code> is a string.  It sounds simple ... But let's try to compile this code: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     auto t = str("10"s);</span></span></code> </pre> <br><p>  We get something like this: </p><br><p> <code>In instantiation of 'std::__cxx11::string str(T) [with T = std::__cxx11::basic_string&lt;char&gt;; std::__cxx11::string = std::__cxx11::basic_string&lt;char&gt;]': required from here error: no matching function for call to 'to_string(std::__cxx11::basic_string&lt;char&gt;&amp;)' return std::to_string(t);</code> </p> <br><p>  <code>is_same</code> gives <code>true</code> for the type used (string), and we can simply return <code>t</code> without conversions ... but what went wrong? </p><br><p>  The main reason for this is that the compiler tried to parse both conditional branches and found an error in the <code>else</code> case.  It cannot discard the "wrong" code in our particular case of instantiation of the template. </p><br><p>  For this we need a static <code>if</code> , which will "exclude" the code and compile only the block that fits the condition. </p><br><h1 id="stdenable_if">  std :: enable_if </h1><br><p>  One way to write a static <code>if</code> in C ++ <code>enable_if</code> is to use <code>enable_if</code> (and <code>enable_if_v</code> starting with C ++ 14).  It has a rather strange syntax: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> B, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p>  <code>enable_if</code> displays type T if condition B is true.  Otherwise, according to SFINAE, the partial overload of the function is removed from the available overload functions. </p><br><p>  We can rewrite our simple example like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; str(T t) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; str(T t) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(t); }</code> </pre> <br><p>  It is not easy, is it? </p><br><p>  <em>I used <code>enable_if</code> to separate the case when type is a string ... But the exact same effect can be achieved by simply overloading the function, avoiding the use of <code>enable_if</code> .</em> </p><br><p>  Further we will simplify the similar code with the help <code>if constexpr</code> from C ++ 17.  After that, we can quickly rewrite our <code>str</code> function. </p><br><h1 id="ispolzovanie-pervoe---sravnenie-chisel">  Use the first - a comparison of numbers </h1><br><p>  Let's start with a simple example: the <code>close_enough</code> function that works with two numbers.  If the numbers are not floating point (for example, when we have two integer <code>int</code> ), we can simply compare them.  For floating-point numbers, it is better to use some small value epsilon. </p><br><p>  I found this example in the <a href="https://h-deb.clg.qc.ca/WG21/PracticalCpp/Temperature.html">Practical Modern C ++ Teaser (Practical Modern C ++ Teaser) Practical Puzzle</a> - a fantastic introduction to the capabilities of the modern C ++ from <a href="https://twitter.com/PatriceRoy1">Patrice Roy</a> .  He kindly allowed me to include his example. </p><br><p>  Version for C ++ 11/14: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">absolute</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -arg : arg; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if_t</span></span></span><span class="hljs-class">&lt;is_floating_point&lt;T&gt;::value, bool&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">close_enough</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> absolute(a - b) &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&gt;(<span class="hljs-number"><span class="hljs-number">0.000001</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if_t</span></span></span><span class="hljs-class">&lt;!is_floating_point&lt;T&gt;::value, bool&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">close_enough</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a == b; }</code> </pre> <br><p>  As you can see, <code>enable_if</code> used here.  This is very similar to our <code>str</code> function.  The code checks whether the type of incoming numbers satisfies the <code>is_floating_point</code> condition.  Then the compiler can remove one of their function overloads. </p><br><p>  Now let's see how this is done in C ++ 17: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">absolute</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arg &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -arg : arg; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">precision_threshold</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">(0.000001);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">close_enough</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_floating_point_v&lt;T&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;&lt; !! return absolute(a - b) &lt; precision_threshold&lt;T&gt;; else return a == b; }</span></span></span></span></code> </pre> <br><p>  This is just one function that basically looks like a normal function.  With an almost "normal" <code>if</code> . </p><br><p>  <code>if constexpr</code> at compile time and then the code of one of the branches of the expression is skipped. </p><br><p>  <em>It uses a bit more features of C ++ 17.</em>  <em>Do you see which ones?</em> </p><br><h1 id="ispolzovanie-vtoroe---fabrika-s-peremennym-kolichestvom-parametrov">  Using the second - a factory with a variable number of parameters </h1><br><p>  Chapter 18 of Scott Mirs‚Äôs book Effective Use of C ++ describes a method called <code>makeInvestment</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Investment&gt; makeInvestment(Ts&amp;&amp;... params);</code> </pre><br><p>  This is a factory method that creates heirs of the <code>Investment</code> class, and the main advantage in it is the support of a different number of parameters! </p><br><p>  For example, below are the types of heirs: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Investment</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Investment() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcRisk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stock</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Investment { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcRisk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bond</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Investment { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bond</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcRisk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RealEstate</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Investment { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RealEstate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcRisk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ } };</code> </pre> <br><p>  The example from the book is too idealized and not working - it works as long as the constructors of your classes accept the same number and the same types of input arguments. <br>  Scott Mires comments in the corrections and additions to his book "Effective use of C ++" as follows: </p><br><blockquote>  The <code>makeInvestment</code> interface <code>makeInvestment</code> not practical because it is assumed that heirs can be created from the same sets of arguments.  This is especially noticeable in the implementation of the choice of the constructed object, where the arguments are passed to the constructors of all classes using the perfect-forwarding mechanism ( <a href="https://habrahabr.ru/post/242639/">perfect transmission</a> ). </blockquote><p>  For example, if you have two classes, the constructor of one takes two arguments, and the other three, then this code will not compile: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// : Bond(int, int, int) { } Stock(double, double) { } make(args...) { if (bond) new Bond(args...); else if (stock) new Stock(args...) }</span></span></code> </pre> <br><p>  If you write <code>make(bond, 1, 2, 3)</code> , then the expression under the <code>else</code> will not be compiled, so there is no suitable constructor for <code>Stock(1, 2, 3)</code> !  For this to work, we need something similar to <code>static if</code> - to compile it only when it satisfies the condition, otherwise drop it. </p><br><p>  Here is the code that could work: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Investment&gt; makeInvestment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;name, Ts&amp;&amp;... params) { <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Investment&gt; pInv; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-string"><span class="hljs-string">"Stock"</span></span>) pInv = constructArgs&lt;Stock, Ts...&gt;(forward&lt;Ts&gt;(params)...); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-string"><span class="hljs-string">"Bond"</span></span>) pInv = constructArgs&lt;Bond, Ts...&gt;(forward&lt;Ts&gt;(params)...); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-string"><span class="hljs-string">"RealEstate"</span></span>) pInv = constructArgs&lt;RealEstate, Ts...&gt;(forward&lt;Ts&gt;(params)...); <span class="hljs-comment"><span class="hljs-comment">//      pInv... return pInv; }</span></span></code> </pre> <br><p>  As we see, "magic" occurs inside the <code>constructArgs</code> function. </p><br><p>  The basis of the idea is to return <code>unique_ptr&lt;Type&gt;</code> when <code>Type</code> constructed from a given set of attributes, or <code>nullptr</code> otherwise. </p><br><h2 id="do-c17">  Up to C ++ 17 </h2><br><p>  In this case, we would use <code>std::enable_if</code> like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  C++17 template &lt;typename Concrete, typename... Ts&gt; enable_if_t&lt;is_constructible&lt;Concrete, Ts...&gt;::value, unique_ptr&lt;Concrete&gt;&gt; constructArgsOld(Ts&amp;&amp;... params) { return std::make_unique&lt;Concrete&gt;(forward&lt;Ts&gt;(params)...); } template &lt;typename Concrete, typename... Ts&gt; enable_if_t&lt;!is_constructible&lt;Concrete, Ts...&gt;::value, unique_ptr&lt;Concrete&gt; &gt; constructArgsOld(...) { return nullptr; }</span></span></code> </pre> <br><blockquote>  <code>std::is_constructible</code> allows <code>std::is_constructible</code> to quickly check whether a given type will be constructed from a given list of arguments.  <em>// @ cppreference.com</em> </blockquote><p>  In C ++ 17, a little easier, a new assistant appeared: </p><br><pre> <code class="cpp hljs">is_constructible_v = is_constructible&lt;T, Args...&gt;::value;</code> </pre> <br><p>  So we can make the code a bit shorter ... However, using <code>enable_if</code> is still awful and difficult.  What about C ++ 17? </p><br><h2 id="s-if-constexpr">  With <code>if constexpr</code> </h2><br><p>  Updated version: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concrete, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Concrete&gt; constructArgs(Ts&amp;&amp;... params) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_constructible_v&lt;Concrete, Ts...&gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> make_unique&lt;Concrete&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forward&lt;Ts&gt;(params)...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br><p>  We can even extend the functionality by logging actions using the expression convolution: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Concrete, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Concrete&gt; constructArgs(Ts&amp;&amp;... params) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : ((cout &lt;&lt; params &lt;&lt; ", "), ...); cout &lt;&lt; "\n"; if constexpr (std::is_constructible_v&lt;Concrete, Ts...&gt;) return make_unique&lt;Concrete&gt;(forward&lt;Ts&gt;(params)...); else return nullptr; }</span></span></code> </pre> <br><p>  Cool ... isn't it? </p><br><p>  The whole complex syntax of expressions with <code>enable_if</code> gone away;  we don't even need an overload function.  We can write expressive code in just one function. </p><br><p>  Depending on the result of evaluating the condition of the expression <code>if constexpr</code> only one block of code will be compiled.  In our case, if an object can be constructed from a given set of attributes, then we compile the <code>make_unique</code> call.  If not, then return <code>nullptr</code> (and <code>make_unique</code> doesn't even compile). </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Compile-time conditional expressions are a great feature that greatly simplifies the use of templates.  In addition, the code becomes clearer than when using existing solutions: static dispatching (tag dispatching) or <code>enable_if</code> (SFINAE).  Now you can express your intentions "like" the code in runtime. </p><br><p>  This article has covered only simple expressions, and I urge you to explore more widely the applicability of new features. </p><br><p>  Going back to our example of the <code>str</code> function: can you now rewrite it using <code>if constexpr?</code> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351970/">https://habr.com/ru/post/351970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351958/index.html">FastTrack Training. "Network Basics". "Cisco Software Products for Security." Eddie Martin December 2012</a></li>
<li><a href="../351960/index.html">3 years of ‚Äúright to oblivion‚Äù: Google has disclosed statistics on requests to ‚Äúdelete‚Äù information</a></li>
<li><a href="../351964/index.html">FastTrack Training. "Network Basics". "The value of Cisco products for security." Eddie Martin December 2012</a></li>
<li><a href="../351966/index.html">The digest of interesting materials for the mobile developer # 246 (March 19 - March 25)</a></li>
<li><a href="../351968/index.html">Check Point R80.20. What will be new?</a></li>
<li><a href="../351972/index.html">UWP Game: Advanced Splash Screen</a></li>
<li><a href="../351974/index.html">Testing and continuous integration for Ansible roles with Molecule and Jenkins</a></li>
<li><a href="../351976/index.html">FastReport.Mono. Part 1: Run the Web demo report</a></li>
<li><a href="../351978/index.html">Unity posted the original C # code on Github</a></li>
<li><a href="../351980/index.html">FastReport.Mono. Part 2: Web Report in Docker Container</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>