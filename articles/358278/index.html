<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guice Almighty: assistedinject, multibindings, generics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, teams that use Guice as a DI framework have become more frequent. He began to be afraid of him (get off his beloved Spring !?), And, as is u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guice Almighty: assistedinject, multibindings, generics</h1><div class="post__text post__text-html js-mediator-article">  Recently, teams that use <b>Guice</b> as a <b><abbr title="Dependency Injection">DI</abbr></b> framework have become more frequent.  He began to be afraid of him (get off his beloved <b>Spring</b> !?), And, as is usually the case in life, my fears materialized - I got on a project that actively uses <b>Guice</b> ... <br><br>  The Internet has already accumulated a fair amount of publications (including Russian-speaking) on ‚Äã‚Äãthis framework, which is good news.  However, on the project I was faced with a situation, a ready solution for which I could not find. <br><br>  In the article, I will once again show the practical use of <b>Guice</b> and some of its <i>extensions</i> : <b>assistedinject</b> , <b>mutibindings</b> , and also work with <b>generics</b> .  First, I will describe the essence of the problem, and then iteratively come to its solution. <a name="habracut"></a>  I imply that the reader has a basic understanding of the framework and of <b>DI</b> as a whole, therefore I will omit the basics.  Moreover, there is excellent <a href="https://github.com/google/guice/wiki/GettingStarted">documentation</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The source code of the project and the history of its iterations can be found on the <a href="https://github.com/Blackmorse/Guice-Extensions">githab</a> . <br><br><h2>  1. Request Handler </h2><br>  The situation is as follows.  Imagine that a request arrives for us (for example, by <b>REST</b> ) with the parameter, on the basis of which you want to create an executor of this request, and with an argument that will be used by the executor for his further work. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String parameter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argument; }</code> </pre> <br>  We have a lot of <i>Worker</i> executors (an entire hierarchy) and each needs dependencies in the form of services to perform its work, and the sets of dependencies may differ for different performers.  Consider this on the example of a simple hierarchy of an abstract class and two heirs.  In fact, of course, this should work for any <b>N.</b> <br><br>  In line with this, the prototype <i>Worker</i> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argument; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.argument = argument; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  The <i>Worker</i> implementations themselves: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceA serviceA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceB serviceB; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceA serviceA, ServiceB serviceB, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(argument); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceA = serviceA; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceB = serviceB; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(String.format(<span class="hljs-string"><span class="hljs-string">"Worker1 starts work with argument %d services %s and %s"</span></span>, argument, serviceA, serviceB)); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceB serviceB; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceC serviceC; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceB serviceB, ServiceC serviceC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(argument); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceB = serviceB; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceC = serviceC; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(String.format(<span class="hljs-string"><span class="hljs-string">"Worker2 starts work with argument %d services %s and %s"</span></span>, argument, serviceB, serviceC)); } }</code> </pre><br><h3>  Simple handler implementation </h3><br>  When I first saw the handler code, it looked something like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ServiceA serviceA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ServiceB serviceB; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ServiceC serviceC; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceA serviceA, ServiceB serviceB, ServiceC serviceC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceA = serviceA; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceB = serviceB; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceC = serviceC; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Worker worker = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case1"</span></span>)) { worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker1(request.argument); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case2"</span></span>)) { worker = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker2(request.argument); } <span class="hljs-comment"><span class="hljs-comment">//          //,     worker.setServiceA(serviceA); worker.setServiceB(serviceB); worker.setServiceC(serviceC); worker.doWork(); } }</span></span></code> </pre><br>  Why is this approach bad?  I will try to form a short list of the disadvantages of this code: <br><br><ul><li>  dependency injection is immediately apparent through <b>set</b> * methods.  I had to add these methods to the abstract class; </li><li>  This means that all three dependencies on <i>ServiceA</i> , <i>ServiceB</i> and <i>ServiceC</i> moved up to an abstract class.  But he does not necessarily know about the services, this is the business of his heirs.  For example, <i>Worker1</i> absolutely does not need <i>ServiceC</i> ; </li><li>  <b>if - else if -</b> structure.  It will look very scary when the number of heirs in the <i>Worker</i> hierarchy increases; </li><li>  passing dependencies to the handler constructor.  The request handler itself about these dependencies should not know - they do not need it.  They are needed only by the <i>Worker</i> instances themselves, </li><li>  Too many responsibilities for the <i>RequestHandler</i> class: it can map a request to the desired <i>Worker</i> , create it and add dependencies.  Ideally (according to the principles of <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID</a> ) I want to follow the paradigm ‚ÄúOne class - one responsibility‚Äù. </li></ul><br>  For myself, I summed up this: I want to translate the <i>Worker</i> 's to <b>Guice</b> ! <br><br><h2>  2. Connecting Guice </h2><br>  First of all, add the <b>Maven</b> dependency to <i><u>pom.xml</u></i> : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.google.inject<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>guice<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>${guice.version}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The latest version of <b>Guice</b> at the time of this writing is 4.2.0. <br><br>  I promised to move iteratively, so for the beginning we will simplify the task.  Let us have no arguments in <i>Request</i> .  <i>Worker</i> is an extremely simple class with a couple of dependencies in the form of services.  Those.  abstract class is extremely simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  And its implementations look like this (the implementation of <i>Worker2</i> looks similar): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceA serviceA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceB serviceB; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceA serviceA, ServiceB serviceB)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceA = serviceA; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceB = serviceB; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(String.format(<span class="hljs-string"><span class="hljs-string">"Worker1 starts work with %s and %s"</span></span>, serviceA, serviceB)); } }</code> </pre><br>  The <b>@Inject annotation</b> in this case tells the framework that to create a <i>Worker</i> instance, you need to use the constructor marked with this annotation, and also, during creation, provide the constructor with all input parameters.  We can not care about where to get the services, <b>Guice</b> will do everything for us. <br><br>  <i>RequestHandler</i> will look like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Provider&lt;Worker1&gt; worker1Provider; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Provider&lt;Worker2&gt; worker2Provider; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Provider&lt;Worker1&gt; worker1Provider, Provider&lt;Worker2&gt; worker2Provider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.worker1Provider = worker1Provider; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.worker2Provider = worker2Provider; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Worker worker = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case1"</span></span>)) { worker = worker1Provider.get(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case2"</span></span>)) { worker = worker2Provider.get(); } worker.doWork(); } }</code> </pre><br>  Immediately striking that we got rid of dependencies on services in this class.  Instead, an Injectable <i>Provider</i> typed by <i>Worker</i> .  From the documentation: <br><blockquote>  Provider &lt;T&gt; - an object capable of providing instances of type T </blockquote>  In this case, the <i>Provider</i> is a factory provided by the <b>Guice</b> framework.  After a dependency is obtained on a provider typed by the <i>Worker</i> class, each time the <code>.get()</code> method is <code>.get()</code> we get a new instance of the <i>Worker</i> class (unless, of course, the <i>Worker</i> is declared as a <b>Singleton</b> ). <br><br>  Notice that <i>RequestHandler</i> , in turn, is just marked with the @ <b>Singleton</b> annotation.  This means <b>Guice</b> will make sure that we don‚Äôt have two instances of this class in the application. <br><br>  Run the code: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String[] args )</span></span></span><span class="hljs-function"> </span></span>{ Request request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(); request.parameter = <span class="hljs-string"><span class="hljs-string">"case1"</span></span>; request.argument = <span class="hljs-number"><span class="hljs-number">5</span></span>; Injector injector = Guice.createInjector(); RequestHandler requestHandler = injector.getInstance(RequestHandler.class); requestHandler.handleRequest(request); request.parameter = <span class="hljs-string"><span class="hljs-string">"case2"</span></span>; requestHandler.handleRequest(request); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Execution result</b> <div class="spoiler_text">  Worker1 starts work with ServiceA and ServiceB <br>  Worker2 starts work with ServiceB and ServiceC <br></div></div><br><h2>  3. throwing arguments </h2><br>  Now let's return the original view of the <i>Worker</i> classes.  To do this, pass a new <i>argument</i> parameter to the constructor: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceA serviceA, ServiceB serviceB, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span><span class="hljs-function"> </span></span>{</code> </pre> <br>  The problem is that if there is an annotation, @ <b>Inject</b> <b>Guice</b> will provide all the parameters specified in the constructor, which makes it difficult to pass a parameter that is formed in <i>Runtime</i> . <br><br>  Of course, you can solve this problem by creating your own <i>Factory</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Worker Factory</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceA serviceA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceB serviceB; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceC serviceC; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkerFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceA serviceA, ServiceB serviceB, ServiceC serviceC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceA = serviceA; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceB = serviceB; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serviceC = serviceC; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Worker1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWorker1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker1(serviceA, serviceB, argument); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Worker2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWorker2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Worker2(serviceB, serviceC, argument); } }</code> </pre><br>  Run the code in the same way as shown above and see the same result. <br></div></div><br>  Such factories contain quite a lot of template code: you must explicitly specify all the dependencies that will be used in the created class, inject them and explicitly transfer them to the constructor, calling it using the <b>new</b> operator.  <b>Guice</b> avoids this chore with its extensions. <br><br><h3>  Guice AssistedInject </h3><br>  We connect dependence on expansion ( <i>extension</i> ) for <b>Guice</b> : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.google.inject.extensions<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>guice-assistedinject<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>${guice.version}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Now, instead of writing a large class <i>WorkerFactory</i> , we are doing an interface with the same name: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Worker1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWorker1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Worker2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWorker2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span></span>; }</code> </pre><br>  We will not write interface implementation, <b>Guice</b> will do it for us!  We configure this using the <i>Module</i> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ install(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactoryModuleBuilder().implement(Worker1.class, Worker1.class) .implement(Worker2.class, Worker2.class) .build(WorkerFactory.class)); } }</code> </pre><br>  You can look at the module as a class for supporting <b>Guice</b> configuration.  It is possible to connect several modules when creating an <b>Injector</b> , and it is also possible to connect modules to modules, which makes it possible to create a flexible, customizable and readable system of configurations. <br><br>  To create a factory, we used <b>FactoryModuleBuilder</b> .  From the documentation: <br><blockquote>  FactoryModuleBuilder - provides a number of construct objects. </blockquote>  We have the opportunity to combine user options with objects provided by <b>Guice</b> . <br><br>  Let us examine the creation of the factory more: <br><br><ul><li>  The <code>build(WorkerFactory.class)</code> method <code>build(WorkerFactory.class)</code> tells Guice to provide an implementation of the <i>WorkerFactory</i> factory; </li><li>  the <i>implement</i> method takes two arguments: <pre> <code class="java hljs">implement (Class&lt;T&gt; source, Class&lt;? extends T&gt; target)</code> </pre>  <i>source</i> - the return value interface, <i>target</i> - its implementation, which our factory will provide; </li><li>  In this case, we had to explicitly define the creation of <i>Worker1</i> and <i>Worker2</i> , although they have a common <i>Worker</i> interface.  Patience, in the next step we will fix it; </li><li>  <code>install(new FactoryModuleBuilder())</code> - we complete the configuration by adding a new module to ours. </li></ul><br>  It is imperative not to forget to tell <b>Guice</b> about which parameters in the <i>Worker</i> constructor will be passed through the factory, and which parameters are left to the framework to be torn apart.  We do this using the @ <b>Assisted</b> annotation: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AssistedInject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Worker1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ServiceA serviceA, ServiceB serviceB, @Assisted </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span></span></code> </pre><br>  The @ <b>Assisted</b> annotation is placed above the arguments that we ourselves will provide to <b>Guice</b> from the factory.  Also, usually in this case, @ <b>AssistedInject</b> is put over the constructor instead of @ <b>Inject</b> . <br><br>  <i>Rewrite RequestHandler</i> , adding a dependency to it on the <i>WorkerFactory</i> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WorkerFactory workerFactory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkerFactory workerFactory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.workerFactory = workerFactory; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Worker worker = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case1"</span></span>)) { worker = workerFactory.createWorker1(request.argument); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case2"</span></span>)) { worker = workerFactory.createWorker2(request.argument); } worker.doWork(); } }</code> </pre><br>  The final touch remains - to raise the context, <b>Guice</b> needs to learn about our module.  Nothing changes, just to get the <i>Injector we</i> specify the module: <br><br><pre> <code class="java hljs"> Injector injector = Guice.createInjector(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Module());</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Execution result</b> <div class="spoiler_text">  Worker1 starts with 5 services ServiceA and ServiceB <br>  Worker2 starts with 5 services ServiceB and ServiceC <br></div></div><br><h2>  4. Parameterize Factory </h2><br>  Really, every time when we have a new successor, the <i>Worker</i> will have to add it to the <i>WorkerFactory</i> interface, and report it to the <i>Module</i> ? <br>  Let's try to get rid of this by making the <i>WorkerFactory</i> parameterized by <i>Worker</i> , and at the same time we will find out how <b>Guice</b> does it. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerFactory</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createWorker</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argument)</span></span></span></span>; }</code> </pre><br>  Now you need to specify the <b>Guice</b> framework that you need to create two different factories of the factories - one for each <i>Worker</i> .  Just how to make the factory typed?  After all, <b>Java</b> does not allow writing such constructs: <i>WorkerFactory &lt;Worker1&gt; .class</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractModule</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ install(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactoryModuleBuilder().implement(Worker.class, Worker1.class) .build(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker1&gt;&gt;() {})); install(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactoryModuleBuilder().implement(Worker.class, Worker2.class) .build(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker2&gt;&gt;() {})); } }</code> </pre><br>  This time, in the arguments of the <i>implement</i> method, we can indicate what its signature required: <i>Worker</i> is an abstract class, parent, and <i>Worker1</i> or <i>Worker2</i> are its heirs, which will be created by the corresponding factory. <br><br>  We solved the problem with <b>generics</b> using the <i>TypeLiteral</i> class.  From the <b>Guice</b> documentation: <br><blockquote>  TypeLiteral &lt;T&gt; - represents a generic type of T. Java doesn‚Äôt </blockquote>  Thus, since <b>Java</b> has no idea of ‚Äã‚Äãa parameterized class, <b>Guice</b> created its own. <br><br>  Usually, instead of the <i>Class &lt;T&gt;</i> argument, you can use <i>TypeLiteral &lt;T&gt;</i> , just look at the overloaded methods.  Do not forget to set <i>{}</i> when creating a <i>TypeLiteral</i> , since its constructor is declared as <b>protected</b> . <br><br>  Now let's see how to connect the dependencies of factories to <i>RequestHandler</i> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WorkerFactory&lt;Worker1&gt; worker1Factory; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> WorkerFactory&lt;Worker2&gt; worker2Factory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkerFactory&lt;Worker1&gt; worker1Factory, WorkerFactory&lt;Worker2&gt; worker2Factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.worker1Factory = worker1Factory; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.worker2Factory = worker2Factory; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Worker worker = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case1"</span></span>)) { worker = worker1Factory.createWorker(request.argument); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request.parameter.equals(<span class="hljs-string"><span class="hljs-string">"case2"</span></span>)) { worker = worker2Factory.createWorker(request.argument); } worker.doWork(); } }</code> </pre><br><h2>  5. Multibindings </h2><br>  So, we have parameterized the <i>WorkerFactory</i> , leaving a single interface for all factories, which will not have to be expanded when adding new heirs of the <b>Worker</b> class.  But instead, you will need to implement a new dependency on the <code>WorkerFactory&lt;WorkerN&gt; workerNFactory</code> every time in <code>WorkerFactory&lt;WorkerN&gt; workerNFactory</code> .  Now let's fix this using the <b>multibindings</b> extension.  In particular, we will use <b>MapBinder</b> : <br><blockquote>  MapBinder - an API for bind multiple maps. </blockquote>  <i>MapBinder</i> allows <i>you</i> to collect all the dependencies together in one map, and then inject it all at once. <br><br>  We connect the <b>multibinings</b> extension to the project: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.google.inject.extensions<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>guice-multibindings<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>4.2.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  And immediately go to finish the <i>Module</i> - all the magic happens in it.  First, create a <i>MapBinder</i> : <br><br><pre> <code class="java hljs">MapBinder&lt;String, WorkerFactory&gt; binder = MapBinder.newMapBinder(binder(), String.class, WorkerFactory.class);</code> </pre><br>  Nothing special, just specify the mapping types: set the <i>String</i> request parameter to the desired <i>WorkerFactory</i> factory.  It remains to implement the mapping itself. <br><br>  So, with our help, <b>Guice</b> has already created a factory for <i>Worker</i> : <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker1&gt;&gt;(){}</code> </pre> <br>  Build an argument on the same object.  To do this, we use the <code>addBinding()</code> and <code>to()</code> methods.  Note the presence of an overloaded version of the method that accepts <i>TypeLiteral</i> .  This is how the module will look like: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractModule</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ install(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactoryModuleBuilder().implement(Worker.class, Worker1.class) .build(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker1&gt;&gt;() {})); install(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FactoryModuleBuilder().implement(Worker.class, Worker2.class) .build(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker2&gt;&gt;() {})); MapBinder&lt;String, WorkerFactory&gt; binder = MapBinder.newMapBinder(binder(), String.class, WorkerFactory.class); binder.addBinding(<span class="hljs-string"><span class="hljs-string">"case1"</span></span>).to(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker1&gt;&gt;(){}); binder.addBinding(<span class="hljs-string"><span class="hljs-string">"case2"</span></span>).to(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeLiteral&lt;WorkerFactory&lt;Worker2&gt;&gt;(){}); } }</code> </pre><br>  All the most interesting has already happened, it remains only to get the <i>Map</i> with the objects we need in <i>RequestHandler</i> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, WorkerFactory&gt; workerFactoryMap; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, WorkerFactory&gt; workerFactoryMap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.workerFactoryMap = workerFactoryMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Worker worker = workerFactoryMap.get(request.parameter) .createWorker(request.argument); worker.doWork(); } }</code> </pre><br>  As you can see, we just do @ <b>Inject</b> mapy with dependencies, and then we get the necessary factory through the <code>get()</code> method. <br><br>  And that's it!  Now <i>RequestHandler is</i> responsible only for creating and launching the <i>Worker</i> , and all the mapping is transferred to the module.  When new heirs appear, the <i>Worker</i> will need to add information about this to the same place, without changing anything else. <br><br><h3>  Small conclusion </h3><br>  In general, I will say that <b>Guice</b> pleasantly surprised me due to its simplicity and, as is now fashionable to say, ‚Äúlow threshold of entry‚Äù.  Often, in simple applications, you can not write a configuration at all and get by with one annotation @ <b>Inject</b> .  For more information, read the <a href="https://github.com/google/guice/wiki">wiki on github</a> . </div><p>Source: <a href="https://habr.com/ru/post/358278/">https://habr.com/ru/post/358278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358262/index.html">Unreal Engine 4 Tutorial: Paint Filter</a></li>
<li><a href="../358264/index.html">Kubernetes-ha. Deploy Kubernetes failover cluster with 5 masters</a></li>
<li><a href="../358268/index.html">New trend at IT interviews: whole days of unpaid homework</a></li>
<li><a href="../358274/index.html">Patch Tuesday: critical patches you might have missed</a></li>
<li><a href="../358276/index.html">Survey from Veeam Academy. Do you want to go through intensive C # in the summer?</a></li>
<li><a href="../358282/index.html">Messenger problems: vanishing messages in Signal for Mac are not permanently deleted</a></li>
<li><a href="../358284/index.html">1000 + 1 way to determine if all items in the list are the same.</a></li>
<li><a href="../358286/index.html">DevConf: promising highload databases</a></li>
<li><a href="../358292/index.html">Apollo graphql client - developing applications on react.js without redux</a></li>
<li><a href="../358296/index.html">Tea, coffee, cookies and a pleasant atmosphere. We invite everyone to the next Hiring Tournament in Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>