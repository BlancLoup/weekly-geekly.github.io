<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lesson 1.4 - Hello Triangle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last lesson, we still mastered the opening of the window and the primitive user input. In this tutorial, we will analyze all the basics of disp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lesson 1.4 - Hello Triangle</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" align="left" width="300">  In the last lesson, we still mastered the opening of the window and the primitive user input.  In this tutorial, we will analyze all the basics of displaying vertices on the screen and use all the features of OpenGL, like VAO, VBO, EBO, in order to display a pair of triangles. <br>  Interested please under the cat. <br><a name="habracut"></a><br><cut></cut><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">3D model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br>  Part 5. Advanced Lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li><li>  <a href="https://habr.com/post/354208/">Omnidirectional shadow maps</a> </li></ol><br></div></div><br><br>  In OpenGL, everything is in 3D space, but at the same time the screen and the window are a 2D matrix of pixels.  Therefore, most of the work of OpenGL is the transformation of 3D coordinates into 2D space for drawing on the screen.  The process of converting 3D coordinates to 2D coordinates is controlled by the OpenGL graphics pipeline.  The graphics pipeline can be divided into 2 large parts: the first part converts the 3D coordinates to 2D coordinates, and the second part converts the 2D coordinates to color pixels.  In this lesson we will discuss in detail the graphics pipeline and how we can use it as a plus to create beautiful pixels. <br><blockquote>  There is a difference between 2D coordinates and a pixel.  A 2D coordinate is a very accurate representation of a point in 2D space, while a 2D pixel is an approximate location within your screen / window. </blockquote><br>  The graphics pipeline takes a set of 3D coordinates and converts them to color 2D pixels on the screen.  This graphic container can be divided into several stages, where each stage requires the input of the result of the past.  All these stages are extremely specialized and can easily be performed in parallel.  Due to their parallel nature, most modern GPUs have thousands of small processors for fast processing of the graphics pipeline by running a large number of small programs at each stage of the pipeline.  These small programs are called <b>shaders</b> . <br><br>  Some of these shaders can be customized by the developer, which allows us to write our own shaders to replace the standard ones.  This gives us much more opportunities to fine-tune specific areas of the pipeline, and it is because of the fact that they work on the GPU, which allows us to save processor time.  Shaders are written in OpenGL Shading Language (GLSL) and we will delve more into it in the next lesson. <br><br>  In the image below you can see an approximate representation of all stages of the graphics pipeline.  The blue parts describe the stages for which we can specify our own shaders. <br><br><img src="https://habrastorage.org/files/2c9/de0/40a/2c9de040a67946109f15dd9283da9aa2.png"><br><br>  As you can see, the graphics pipeline contains a large number of sections, where each is engaged in its part of processing vertex data into a fully rendered pixel.  We will describe each section of the conveyor a bit in a simplified way to give you a good idea of ‚Äã‚Äãhow the conveyor works. <br><br>  An array of 3D coordinates is transmitted to the input of the conveyor, from which triangles can be formed, called vertex data;  vertex data is a collection of vertices.  A vertex is a data set on top of a 3D coordinate.  This data is represented using vertex attributes, which can contain any data, but for simplicity, we assume that the vertex consists of a 3D position and a color value. <br><blockquote>  Since OpenGL wants to know what to make of the collection of coordinates and color values ‚Äã‚Äãpassed to it, OpenGL requires you to specify which shape you want to form from the data.  Do we want to draw a set of points, a set of triangles, or just one long line?  Such shapes are called <b>primitives</b> and are passed to OpenGL during the invocation of drawing commands.  Some of the primitives are: <b>GL_POINTS</b> , <b>GL_TRIANGLES</b> and <b>GL_LINE_STRIP</b> . </blockquote><br>  The first stage of the pipeline is the vertex shader, which takes one vertex at the input.  The main task of the vertex shader is to convert 3D coordinates to other 3D coordinates (more on this later) and the fact that we have the ability to change this shader allows us to perform some basic transformations on the values ‚Äã‚Äãof the vertex. <br><br>  Assembly of primitives is a stage that takes as input all vertices (or one vertex if <b>GL_POINTS</b> primitive is <b>selected</b> ) from the vertex shader, which form the primitive and assembles the primitive from them;  in our case it will be a triangle. <br><br>  The result of the primitive assembly step is passed to the geometry shader.  He, in turn, at the input accepts a set of vertices that form primitives and can generate other shapes by generating new vertices to form new (or other) primitives.  For example, in our case, it will generate a second triangle in addition to this shape. <br><br>  The result of the work of the geometric shader is transferred to the rasterization stage, where the resulting primitives will correspond to the pixels on the screen, forming a fragment for the fragment shader.  Before the fragment shader starts, it is cut.  It discards all fragments that are out of sight, thus improving performance. <br><blockquote>  A fragment in OpenGL is all the data that OpenGL needs in order to draw a pixel. </blockquote><br>  The main purpose of the fragment shader is to calculate the final color of a pixel, as well as, most often, the stage when all the additional OpenGL effects are executed.  Often, the fragment shader contains all the information about the 3D scene, which can be used to modify the final color (such as lighting, shadows, light source colors, etc.). <br><br>  After all relevant color values ‚Äã‚Äãhave been defined, the result will go through another step, called alpha testing and blending.  This stage checks the appropriate depth (and pattern) value (we will return to this later) of the fragment and uses them to check the location of the fragment relative to other objects: in front or behind.  This step also checks the transparency values ‚Äã‚Äãand mixes colors, if necessary.  Thus, when drawing multiple primitives, the resulting pixel color may differ from the color computed by the fragment shader. <br><br>  As you can see, the graphics pipeline is quite complex and contains many configurable parts.  In spite of this, we will mainly work with the vertex and fragment shaders.  A geometric shader is optional and is often left standard. <br><br>  In modern OpenGL, you are <b>forced to</b> specify at least a vertex shader (there is no standard vertex / fragment shader on video cards).  For this reason, it can often be difficult to study modern OpenGL, since you need to learn a fairly large amount of theory before drawing your first triangle.  At the end of this tutorial you will learn a lot about graphic programming. <br><br><h2>  Transfer vertices </h2><br>  In order to draw something to begin with, we need to pass the vertex data to OpenGL.  OpenGL is a 3D library and therefore all coordinates that we report to OpenGL are in three-dimensional space (x, y and z).  OpenGL does not convert <b>all</b> 3D coordinates transferred to it to 2D pixels on the screen;  OpenGL only processes 3D coordinates in a certain interval between <b>-1.0</b> and <b>1.0</b> for all 3 coordinates (x, y and z).  All such coordinates are called coordinates, normalized by the device (or simply normalized). <br><br>  Since we want to draw one triangle, we must provide 3 vertices, each of which is in three-dimensional space.  We define them in normalized form in the <b>GLfloat</b> array. <br><br><pre><code class="hljs go">GLfloat vertices[] = { <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> };</code> </pre> <br>  Since OpenGL works with three-dimensional space, we draw a two-dimensional triangle with a z coordinate equal to 0.0.  Thus, the <i>depth of the</i> triangle will be the same and it will look two-dimensional. <br><blockquote>  <b>Normalized Device Coordinates (NDC)</b> <br>  After the vertex coordinates are processed in the vertex shader, they should be normalized to NDC, which is a small space where the x, y and z coordinates are in the range from <b>-1.0</b> to <b>1.0</b> .  Any coordinates that go beyond this limit will be dropped and not displayed on the screen.  Below you can see the triangle defined by us: <br><br><img src="https://habrastorage.org/files/b5e/861/5c2/b5e8615c2eac4c488adc727685ce14c8.png"><br><br>  Unlike the screen coordinates, the positive value of the y axis points to the top, and the coordinates <b>(0, 0)</b> is the center of the graph, instead of the upper left corner. <br><br>  Your NDC coordinates will then be converted to screen space coordinates via Viewport using the data provided via the <b>glViewport</b> call.  The coordinates of the screen space are then transformed into fragments and fed to the input of the fragment shader. </blockquote><br>  After determining the vertex data, it is required to transfer them to the first stage of the graphics pipeline: to the vertex shader.  This is done as follows: allocate memory on the GPU, where we will save our vertex data, specify OpenGL how it should interpret the data transferred to it and transfer the amount of the data transferred by us to the GPU.  Then the vertex shader will process the number of vertices that we told it. <br><br>  We manage this memory through so-called vertex buffer objects (vertex buffer objects (VBO)), which can store a large number of vertices in the GPU memory.  The advantage of using such buffer objects is that we can send a large number of data sets to a video card at a time, without having to send one vertex at a time.  Sending data from the CPU to the GPU is rather slow, so we will try to send as much data as possible at a time.  But as soon as the data is in the GPU, the vertex shader will get it almost instantly. <br><br>  VBO is our first encounter with the objects described in the first lesson.  Like any object in OpenGL, this buffer has a unique identifier.  We can create a VBO using the <b>glGenBuffers</b> function: <br><br><pre> <code class="hljs 1c">GLuint VBO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-meta"><span class="hljs-meta">&amp;VBO);</span></span></code> </pre><br>  OpenGL has a large number of different types of buffer objects.  VBO type - <i>GL_ARRAY_BUFFER</i> .  OpenGL allows you to bind multiple buffers if they have different types.  We can bind <i>GL_ARRAY_BUFFER</i> to our buffer using <b>glBindBuffer</b> : <br><br><pre> <code class="hljs lisp">glBindBuffer(<span class="hljs-name"><span class="hljs-name">GL_ARRAY_BUFFER</span></span>, VBO)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  From now on, any call using the buffer will work with VBO.  Now we can call <b>glBufferData</b> to copy the vertex data to this buffer. <br><br><pre> <code class="hljs lisp">glBufferData(<span class="hljs-name"><span class="hljs-name">GL_ARRAY_BUFFER</span></span>, sizeof(<span class="hljs-name"><span class="hljs-name">vertices</span></span>), vertices, GL_STATIC_DRAW)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  <b>glBufferData</b> is a function whose purpose is to copy user data to the specified buffer.  Its first argument is the type of buffer to which we want to copy data (our VBO is now bound to <i>GL_ARRAY_BUFFER</i> ).  The second argument specifies the amount of data (in bytes) that we want to transfer to the buffer.  The third argument is the data itself. <br><br>  The fourth argument determines how we want the video card to work with the data passed to it.  There are 3 modes: <br><br><ol><li>  <i>GL_STATIC_DRAW</i> : either the data will never change or will change very rarely; </li><li>  <i>GL_DYNAMIC_DRAW</i> : data will change quite often; </li><li>  <i>GL_STREAM_DRAW</i> : data will change with each drawing. </li></ol><br>  Triangle position data will not change and therefore we select <i>GL_STATIC_DRAW</i> .  If, for example, we would have a buffer, the value of which would change very often - then we would use <i>GL_DYNAMIC_DRAW</i> or <i>GL_STREAM_DRAW</i> , thus providing the video card with the information that the data of this buffer needs to be stored in the memory area that is the fastest to write. <br><br>  We have now saved the vertex data on the GPU to a buffer object called a VBO. <br>  Next we need to create vertex and fragment shaders for actual data processing, so let's start. <br><br><h2>  Vertex shader </h2><br>  The vertex shader is one of the programmable shaders.  Modern OpenGL requires that a vertex and fragment shaders be specified if we want to draw something, so we will provide two very simple shaders to draw our triangle.  In the next lesson, we will discuss shaders in more detail. <br><br>  In the beginning, we have to write the shader itself in a special GLSL (OpenGL Shading Language) language, and then compile it so that the application can work with it.  Here is the simplest shader code: <br><br><pre> <code class="hljs lisp">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core layout (<span class="hljs-name"><span class="hljs-name">location</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) in vec3 position<span class="hljs-comment"><span class="hljs-comment">; void main() { gl_Position = vec4(position.x, position.y, position.z, 1.0); }</span></span></code> </pre><br>  As you can see, GLSL is very similar to C. Each shader begins with the installation of its version.  With OpenGL version 3.3 and higher, the GLSL versions are the same as the OpenGL versions (For example, the GLSL 420 version is the same as the OpenGL version 4.2).  We also clearly indicated that we are using the core profile. <br><br>  Next, we specified all input vertex attributes in the vertex shader using the in keyword.  Now we need to work only with position data, so we specify only one vertex attribute.  In GLSL, there is a vector data type containing from 1 to 4 floating point numbers.  Since the vertices have three-dimensional coordinates, we create a <b>vec3</b> with the name <i>position</i> .  We also explicitly specified the position of our variable through the <b>layout (location = 0)</b> later you will see why we did it. <br><blockquote>  <b>Vector</b> <br>  In graphic programming, we quite often use the mathematical concept of a vector, since it perfectly represents positions / directions in any space, and also has useful mathematical properties.  The maximum size of a vector in GLSL is 4 elements, and access to each of the elements can be obtained through <b>vec.x</b> , <b>vec.y</b> , <b>vec.z</b> and <b>vec.w</b> respectively.  Notice that the <b>vec.w</b> component <b>is</b> not used as a position in space (we work in 3D, not in 4D), but it can be useful when working with perspective division.  We will discuss vectors more deeply in the next lesson. </blockquote><br>  To indicate the result of the vertex shader, we must assign the value of the predefined variable <i>gl_Position</i> , which is of type <b>vec4</b> .  After the end of the main function, no matter what we pass to gl_Position, it will be used as the result of the vertex shader.  Since our input vector is three-dimensional, we must convert it to four-dimensional.  We can do this simply by passing the <b>vec3</b> components to <b>vec4</b> , and setting the <b>w</b> component to the value 1.0f (We will explain why so later). <br><br>  This vertex shader is probably the easiest shader you can think of, since it does not process any data, but simply passes this data to the output.  In real-world applications, the input data is not normalized, so at the beginning they need to be normalized. <br><br><h2>  Shader build </h2><br>  We wrote the shader source code (stored in the C string), but in order for the shaders to use OpenGL, it needs to be compiled. <br><br>  In the beginning, we need to create a shader object.  And since access to the created objects is done through the identifier, we will store it in a variable with the <b>GLuint</b> type, and we will create it through <b>glCreateShader</b> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">GLuint</span></span> vertexShader; <span class="hljs-attribute"><span class="hljs-attribute">vertexShader</span></span> = glCreateShader(GL_VERTEX_SHADER);</code> </pre><br>  During the creation of the shader, we must specify the type of shader to create.  Since we need a vertex shader, we specify <i>GL_VERTEX_SHADER</i> . <br><br>  Next, we bind the shader source code to the shader object and compile it. <br><br><pre> <code class="hljs lisp">glShaderSource(<span class="hljs-name"><span class="hljs-name">vertexShader</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;vertexShaderSource</span></span>, NULL)<span class="hljs-comment"><span class="hljs-comment">; glCompileShader(vertexShader);</span></span></code> </pre><br>  The <b>glShaderSource</b> function <b>takes</b> as its first argument a shader that needs to be built.  The second argument describes the number of lines.  In our case, the line is only one.  The third parameter is the shader source code itself, and the fourth parameter is left in NULL. <br><blockquote>  Most likely you will want to check the success of the shader assembly.  And if the shader was not compiled - get errors that occurred during the build.  Check for errors is as follows: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GLint</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">success</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">GLchar</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">infoLog</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[512]</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">glGetShaderiv</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexShader</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_COMPILE_STATUS</span></span>, &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">success</span></span>);</code> </pre><br>  To begin with, we declare a number to determine the success of the assembly and a container for storing errors (if they appear).  We then test success with <b>glGetShaderiv</b> .  If the build fails, then we will be able to get an error message with <b>glGetShaderInfoLog</b> and output this error: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!success) { glGetShaderInfoLog(vertexShader, <span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, infoLog); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span></span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> </blockquote><br>  After that, if no compilation errors occurred - the shader will be compiled. <br><br><h2>  Fragment Shader </h2><br>  The fragment shader is the second and last shader that we need to draw a triangle.  The fragment shader is responsible for calculating pixel colors.  In the name of simplicity, our fragment shader will display only orange color. <br><blockquote>  Color in computer graphics is represented as an array of 4 values: red, green, blue and transparency;  Such component base is called RGBA.  When we set a color in OpenGL or in GLSL we set the size of each component between 0.0 and 1.0.  If, for example, we set the magnitude of the red and green components to 1.0f, then we get a mixture of these colors ‚Äî yellow.  The combination of 3 components gives about 16 million different colors. </blockquote><br><pre> <code class="hljs go">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 color; void main() { color = vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre><br>  The fragment shader output requires only a color value, which is the 4 component vector.  We can specify the output variable using the out keyword, and we call this variable <b>color</b> .  Then we simply set the value of this variable to vec4 with an opaque orange color. <br><br>  The process of assembling a fragmentary shader is similar to that of a vertex one, it is only necessary to specify a different type of shader: <i>GL_FRAGMENT_SHADER</i> : <br><br><pre> <code class="hljs objectivec">GLuint fragmentShader; fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;fragmentShaderSource, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glCompileShader(fragmentShader);</code> </pre><br>  Both shaders were assembled and now it only remains to link them into the program so that we can use them when drawing. <br><br><h2>  Shader program </h2><br>  A shader program is an object that is the final result of a combination of several shaders.  In order to use the assembled shaders, you need to connect them into an object of a shader program, and then activate this program when rendering objects, and this program will be used when invoking the draw commands. <br><br>  When connecting shaders to a program, the output values ‚Äã‚Äãof one shader are matched with the input values ‚Äã‚Äãof another shader.  You can also get errors during the connection of shaders, if the input and output values ‚Äã‚Äãdo not match. <br><br>  Creating a program is very simple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">GLuint</span></span> shaderProgram; <span class="hljs-attribute"><span class="hljs-attribute">shaderProgram</span></span> = glCreateProgram();</code> </pre><br>  The <b>glCreateProgram</b> function creates a program and returns the ID of this program.  Now we need to attach our assembled shaders to the program, and then link them with the <b>glLinkProgram</b> : <br><br><pre> <code class="hljs lisp">glAttachShader(<span class="hljs-name"><span class="hljs-name">shaderProgram</span></span>, vertexShader)<span class="hljs-comment"><span class="hljs-comment">; glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram);</span></span></code> </pre><br>  This code completely describes itself.  We add shaders to the program, and then link them. <br><blockquote>  As with the shader build, we can get a successful binding and an error message.  The only difference is that instead of <b>glGetShaderiv</b> and <b>glGetShaderInfoLog</b> we use: <br><br><pre> <code class="hljs lisp">glGetProgramiv(<span class="hljs-name"><span class="hljs-name">shaderProgram</span></span>, GL_LINK_STATUS, <span class="hljs-symbol"><span class="hljs-symbol">&amp;success</span></span>)<span class="hljs-comment"><span class="hljs-comment">; If (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ‚Ä¶ }</span></span></code> </pre></blockquote><br>  To use the created program, call <b>glUseProgram</b> : <br><br><pre> <code class="hljs lisp">glUseProgram(<span class="hljs-name"><span class="hljs-name">shaderProgram</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Each call to the shader and drawing functions will use our program object (and, accordingly, our shaders). <br><br>  Oh yes, do not forget to delete the created shaders after binding.  We will not need them anymore. <br><br><pre> <code class="hljs lisp">glDeleteShader(<span class="hljs-name"><span class="hljs-name">vertexShader</span></span>)<span class="hljs-comment"><span class="hljs-comment">; glDeleteShader(fragmentShader);</span></span></code> </pre><br>  At this point, we passed the vertex data to the GPU and told the GPU how to process it.  We are almost done.  OpenGL still doesn‚Äôt know how to present vertex data in memory and how to merge vertex data into vertex shader attributes.  Well, let's get started. <br><br><h2>  Vertex attribute binding </h2><br>  The vertex shader allows us to specify any data in each vertex attribute, but this does not mean that we will have to specify which data element belongs to which attribute.  This means that we need to tell OpenGL to interpret the vertex data before rendering. <br><br>  The format of our vertex buffer is as follows: <br><br><img src="https://habrastorage.org/files/f8a/ac4/1b5/f8aac41b555b4487a68c8a71dfcf3c55.png"><br><br><ul><li>  Position information is stored in a 32 bit (4 byte) floating point value; </li><li>  Each position is formed from 3 values; </li><li>  There is no separator between sets of 3 values.  This buffer is called <i>tightly packed</i> ; </li><li>  The first value in the transmitted data is the beginning of the buffer. </li></ul><br>  Knowing these features, we can tell OpenGL how it should interpret the vertex data.  This is done using the <b>glVertexAttribPointer</b> function: <br><br><pre> <code class="hljs objectivec">glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), (GLvoid*)<span class="hljs-number"><span class="hljs-number">0</span></span>); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  The <b>glVertexAttribPointer</b> function has some parameters, let's quickly run through them: <br><br><ul><li>  The first argument describes which shader argument we want to configure.  We want to specify the value of the <i>position</i> argument, the position of which was specified as follows: <i>layout (location = 0).</i> <br><br></li><li>  The following argument describes the size of the argument in the shader.  Since we used <i>vec3,</i> we specify 3. <br><br></li><li>  The third argument describes the data type used.  We specify <i>GL_FLOAT</i> , because <i>vec</i> in the shader uses floating point numbers. <br><br></li><li>  The fourth argument indicates the need to normalize the input data.  If we specify <i>GL_TRUE</i> , then all data will be located between 0 (-1 for character values) and 1. We do not need normalization, so we leave <i>GL_FALSE</i> ; <br><br></li><li>  The fifth argument is called <i>step</i> and describes the distance between the data sets.  We can also specify a step equal to 0 and then OpenGL will calculate the step (works only with tightly packed data sets).  How to gain substantial benefits from this argument, we will look at later. <br><br></li><li>  The last parameter is of type <i>GLvoid *</i> and therefore requires such a strange type conversion.  This is the offset of the beginning of the data in the buffer.  Our buffer has no offset and therefore we specify 0. </li></ul><br><blockquote>  Each vertex attribute gets a value from VBO-managed memory that is currently bound to <i>GL_ARRAY_BUFFER</i> .  Accordingly, if we called <b>glVertexAttribPointer</b> with another VBO, then the vertex data would be taken from another VBO. </blockquote><br>  After we tell OpenGL how it should interpret the vertex data, we need to include the attribute with <b>glEnableVertexAttribArray</b> .  Thus, we will pass the position of the argument to the vertex attribute.  After we set everything up, we initialized the vertex data in the buffer using VBO, installed the vertex and fragment shader, and told OpenGL how to link the vertex shader and the vertex data.  Drawing an object in OpenGL will look something like this: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ 0.       OpenGL glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.       glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.     glUseProgram(shaderProgram); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3.     someOpenGlFunctionThatDrawsOutTriangle();</span></span></code> </pre><br>  We must repeat this process every time we draw an object.  It seems that this is not very difficult, but now imagine that you have more than 5 vertex attributes and something in the region of 100 different objects.  And immediately the constant installation of these configurations for each object becomes a wild routine.  That would be some way to store all these states and that we would only need to be attached to some state to draw ... <br><br><h2>  Vertex Array Object </h2><br>  A vertex array object (VAO) can also be bound as a VBO and after that all subsequent calls to the vertex attributes will be stored in the VAO.  The advantage of this method is that we only need to configure the attributes once, and all subsequent times the VAO configuration will be used.  Also, this method makes it easy to change vertex data and attribute configurations by simply binding different VAOs. <br><blockquote>  Core OpenGL <b>requires</b> that we use VAO in order for OpenGL to know how to work with our input vertices.  If we do not specify a VAO, OpenGL may refuse to draw anything. </blockquote><br>  VAO stores the following calls: <br><br><ul><li>  Calls <b>glEnableVertexAttribArray</b> or <b>glDisableVertexAttribArray</b> . </li><li>  Attribute configuration via <b>glVertexAttribPointer</b> . </li><li>  VBO associated with vertex attributes using <b>glVertexAttribPointer</b> </li></ul><br><img src="https://habrastorage.org/files/0b5/11d/dfa/0b511ddfa0f94b4a90f51026869a0d4d.png"><br><br>  The VAO generation process is very similar to the VBO generation: <br><br><pre> <code class="hljs 1c">GLuint VAO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-meta"><span class="hljs-meta">&amp;VAO);</span></span></code> </pre><br>  In order to use VAO, all you have to do is bind the VAO with <b>glBindVertexArray</b> .  Now we have to adjust / bind the required VBO and attribute pointers, and at the end untie the VAO for later use.  And now, every time when we want to draw an object, we simply bind the VAO with the required settings before drawing the object.  It all should look something like this: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ..::   (  (, ,     )) :: .. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.  VAO glBindVertexArray(VAO); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.        OpenGL glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3.      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); glEnableVertexAttribArray(0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/4.  VAO glBindVertexArray(0); [...] /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ..::   (  ) :: .. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5.   glUseProgram(shaderProgram); glBindVertexArray(VAO); someOpenGLFunctionThatDrawsOurTriangle(); glBindVertexArray(0);</span></span></code> </pre><br><blockquote>  Unlocking objects in OpenGL is common.  At least just to not accidentally spoil the configuration. </blockquote><br>  That's all!  Everything we have done over millions of pages has brought us to this point.  VAO storing vertex attributes and required VBO.  Often, when we have multiple objects to render, we first generate and configure VAO and save them for later use.  And when we need to draw one of our objects, we simply use the saved VAO. <br><br><h3>  The triangle we were waiting for </h3><br>  To render our objects, OpenGL provides us with the <b>glDrawArrays</b> function.  It uses the active shader and the installed VAO to render the specified primitives. <br><br><pre> <code class="hljs lisp">glUseProgram(<span class="hljs-name"><span class="hljs-name">shaderProgram</span></span>)<span class="hljs-comment"><span class="hljs-comment">; glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(0);</span></span></code> </pre><br>  The <b>glDrawArrays</b> function takes the primitive to be drawn as the first argument of OpenGL.  Since we want to draw a triangle and since we do not want to lie to you, we specify <i>GL_TRIANGLES</i> .        ,    ,    0.       ,    3 (   ‚Äî 3 ). <br><br>       .    : <br><br><img src="https://habrastorage.org/files/709/5ad/69c/7095ad69c2a5431083ec84dc25b35cdb.png"><br><br>     <a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/hellotriangle"></a> . <br><br>     , ,  - .        . <br><br><h2> Element Buffer Object </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing we‚Äôll talk about today on vertex drawing is element buffer objects (EBO). </font><font style="vertical-align: inherit;">In order to explain what this is and how it works it is better to give an example: suppose that we need to draw not a triangle, but a quadrilateral. </font><font style="vertical-align: inherit;">We can draw a quad with 2 triangles (OpenGL basically works with triangles).</font></font><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A note from the translator.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As noted by the </font></font><a href="https://habr.com/users/proydakov/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proydakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> user </font><font style="vertical-align: inherit;">, this object is also called the Index Buffer Object, respectively IBO.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accordingly, it will be necessary to declare the following set of vertices: </font></font><br><br><pre> <code class="hljs ruby">GLfloat vertices[] = { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    /<span class="hljs-regexp"><span class="hljs-regexp">/   0.5f, -0.5f, 0.0f, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    -0.5f, -0.5f, 0.0f, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    -0.5f, 0.5f, 0.0f /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    };</span></span></code> </pre><br>    :          .      ,      4   6.     ,             1000 .      ‚Äî     ,            .         4 ,         .   ,   OpenGL   . <br><br>   EBO   ,   . EBO ‚Äî  ,  VBO,    ,  OpenGL ,     .      (indexed drawing)     .               : <br><br><pre> <code class="hljs ruby">GLfloat vertices[] = { <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>.0f /<span class="hljs-regexp"><span class="hljs-regexp">/    }; GLuint indices[] = { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,     0! 0, 1, 3, /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   1, 2, 3 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   };</span></span></code> </pre><br>    ,    4   6.     EBO: <br><br><pre> <code class="hljs 1c">GLuint EBO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-meta"><span class="hljs-meta">&amp;EBO);</span></span></code> </pre><br>     VBO   EBO        <b>glBufferData</b> . ,    VBO         ( <b>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)</b> ,        <i>GL_ELEMENT_ARRAY_BUFFER</i> . <br><br><pre> <code class="hljs swift">glBindBuffer(<span class="hljs-type"><span class="hljs-type">GL_ELEMENT_ARRAY_BUFFER</span></span>, <span class="hljs-type"><span class="hljs-type">EBO</span></span>); glBufferData(<span class="hljs-type"><span class="hljs-type">GL_ELEMENT_ARRAY_BUFFER</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">indices</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">indices</span></span>, <span class="hljs-type"><span class="hljs-type">GL_STATIC_DRAW</span></span>);</code> </pre><br> ,     <i>GL_ELEMENT_ARRAY_BUFFER</i>    .      ‚Äî    <b>glDrawArrays</b>   <b>glDrawElements</b>  ,  ,         .   <b>glDrawElements</b>        EBO: <br><br><pre> <code class="hljs lisp">glBindBuffer(<span class="hljs-name"><span class="hljs-name">GL_ELEMENT_ARRAY_BUFFER</span></span>, EBO)<span class="hljs-comment"><span class="hljs-comment">; glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span></code> </pre><br>    ,    ,     <b>glDrawArrays</b> .   ‚Äî   ,    .   6 ,     6 .   ‚Äî    ,    ‚Äî  <i>GL_UNSIGNED_INT</i> .        EBO (     ,    EBO   ),     0. <br><br>  <b>glDrawElements</b>       <i>GL_ELEMENT_ARRAY_BUFFER</i> EBO.  ,         EBO.  VAO    EBO. <br><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png"><br><br><blockquote> VAO   glBindBuffer,    GL_ELEMENT_ARRAY_BUFFER.   ,      ,   ,      EBO     VAO,        EBO. </blockquote><br>       : <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ..::   :: .. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.  VAO glBindVertexArray(VAO); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.       OpenGL glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3.        OpenGL glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 3.      glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0); glEnableVertexAttribArray(0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 4.  VAO ( EBO) glBindVertexArray(0); [...] /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ..::   (  ) :: .. glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0) glBindVertexArray(0);</span></span></code> </pre><br>       .         ,   ‚Äî      wireframe.        2 . <br><br><img src="https://habrastorage.org/files/08c/613/f57/08c613f57eb241268e9f24c32646f059.png"><br><br><blockquote> <b> Wireframe</b> <br><br>         ,  OpenGL,      <b>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</b> .   ,          ,   ,      .  ,      ‚Äî  <b>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL).</b> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have any problems, go over the lesson, maybe you forgot something. </font><font style="vertical-align: inherit;">You can also check with the </font></font><a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/hellotriangle2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If everything worked out for you, congratulations, you just went through one of the most difficult parts of studying modern OpenGL: the output of the first triangle. </font><font style="vertical-align: inherit;">This part is so complex because it requires a certain amount of knowledge before it is possible to draw the first triangle. </font><font style="vertical-align: inherit;">Fortunately, we have already gone through this and subsequent lessons should be easier.</font></font><br><br><h2>  Additional resources </h2><br><ul><li> <a href="https://capnramses.github.io/opengl/hellotriangle.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antongerdelan.net/hellotriangle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Anton Gerdelans draws the first triangle ..</font></font></li><li> <a href="http://open.gl/drawing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open.gl/drawing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alexander Overvoordes draws the first triangle.</font></font></li><li> <a href="https://capnramses.github.io/opengl/vertexbuffers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antongerdelan.net/vertexbuffers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a small depression in the VBO.</font></font></li><li> <a href="http://learnopengl.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">learnopengl.com/#!In-Practice/Debugging</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : In this lesson a lot has been taken from this lesson; </font><font style="vertical-align: inherit;">if you are stuck somewhere, you can turn to this page. </font><font style="vertical-align: inherit;">(After translating this page, I will link to the translation).</font></font></li></ul><br><h2>  Exercises </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To consolidate the studied I will propose several exercises: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Try drawing 2 triangles one by one using glDrawArrays by adding more vertices. </font></font><a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/hello-triangle-exercise1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decision</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create 2 triangles using 2 different VAO and VBO. </font></font><a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/hello-triangle-exercise2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decision</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a second fragment shader so that it displays a yellow color. </font><font style="vertical-align: inherit;">And make the second triangle be yellow. </font></font><a href="http://learnopengl.com/code_viewer.php%3Fcode%3Dgetting-started/hello-triangle-exercise3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decision</font></font></a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/311808/">https://habr.com/ru/post/311808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311796/index.html">Banking Trojan Qadars returned and attacks banks in the UK</a></li>
<li><a href="../311800/index.html">Design as a coder</a></li>
<li><a href="../311802/index.html">Service Desk - quick start. 3 part. Creating a single entry point</a></li>
<li><a href="../311804/index.html">Once again about the promises</a></li>
<li><a href="../311806/index.html">How the use of redundancy codes in SDS helps Yandex keep data cheaply and securely</a></li>
<li><a href="../311812/index.html">Deep Learning Course Overview</a></li>
<li><a href="../311816/index.html">How to stop being afraid and fall in love with mbed [Part 5]</a></li>
<li><a href="../311818/index.html">Barrier control with Arduino UNO and 433 MHz radio transmitter</a></li>
<li><a href="../311820/index.html">Meet the dictator! Small and kind</a></li>
<li><a href="../311822/index.html">Universal data management system based on scaffolding technology and the .NET Core platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>