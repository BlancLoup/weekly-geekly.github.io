<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The challenge with the skyscraper and the eggs - not binomial Newton?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Actually, he is the most. But first things first. 

 Formulation of the problem 
 I master a python, I solve everything on Codewars. I come across a w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The challenge with the skyscraper and the eggs - not binomial Newton?</h1><div class="post__text post__text-html js-mediator-article">  Actually, he is the most.  But first things first. <br><br><h3>  Formulation of the problem </h3><br>  I master a python, I solve everything on Codewars.  I come across a well-known task about skyscraper and eggs.  The only difference is that the source data is not 100 floors and 2 eggs, but a little more. <br>  Given: N eggs, M attempts to throw them, an endless skyscraper. <br><br>  Define: the maximum floor from which you can throw an egg without breaking.  Eggs are spherical in a vacuum and, if one of them has not broken, having fallen, for example, from the 99th floor, then the others will also withstand a fall from all floors less than a hundredth. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      0 &lt;= N, M &lt;= 20000. <br>  Run time of two dozen tests - 12 seconds. <br><a name="habracut"></a><br><h3>  Finding a solution </h3><br>  We need to write the height (n, m) function, which will return the floor number for given n, m.  Since it will be mentioned very often, and writing ‚Äúheight‚Äù every time is lazy, then everywhere, except for the code, I will designate it as f (n, m). <br><br>  Let's start with zeros.  Obviously, if there are no eggs or attempts to throw them, then nothing can be determined and the answer will be zero.  <b>f (0, m) = 0, f (n, 0) = 0.</b> <br><br>  Suppose there is one egg, and 10 attempts. You can risk everything and throw it right away from the hundredth floor, but if it fails, you will not be able to determine anything else, so it‚Äôs more logical to start from the first floor and go up one floor after each throw until either the attempt or the egg is over.  Maximum where you can get if the egg doesn't fail - floor number 10. <b>f (1, m) = m</b> <br><br>  Take the second egg, trying again 10. Now is it possible to risk the hundredth?  It will break - there will be one more and 9 attempts, at least 9 floors will be able to pass.  So maybe you need to risk not from the hundredth, but from the tenth?  Is logical.  Then, if successful, there will be 2 eggs and 9 attempts.  By analogy, now you need to climb another 9 floors.  With a series of successes - another 8, 7, 6, 5, 4, 3, 2 and 1. Total, we are on the 55th floor with two whole eggs and no attempts.  The answer is the sum of the first M members of the arithmetic progression with the first member 1 and step 1. <b>f (2, m) = (m * m + m) / 2</b> .  It is also clear that at each step the function f (1, m) was called, as it were, but this is not yet accurate. <br><br>  Continue with three eggs and ten attempts.  In case of an unsuccessful first throw, the floors will be covered from below, defined by 2 eggs and 9 attempts, which means that the first throw must be made from the floor f (2, 9) + 1. Then, if successful, we have 3 eggs and 9 attempts .  And for the second attempt, you need to climb f (2.8) + 1 floors.  And so on, until 3 eggs and 3 attempts remain on the hands.  And here is the time to be distracted by the consideration of cases with N = M, when there are as many eggs as there are attempts. <br><br><div class="spoiler">  <b class="spoiler_title">And at the same time and those when more eggs.</b> <div class="spoiler_text">  But here everything is obvious - we will not need eggs over and above those that are broken, even if each throw is unsuccessful.  <b>f (n, m) = f (m, m) if n&gt; m</b> .  And that's all equally, 3 eggs, 3 throws.  If the first egg is broken, then you can check f (2, 2) floors to the bottom, and if not broken, then f (3,2) floors to the top, that is, the same f (2, 2).  Total f (3, 3) = 2 * f (2, 2) + 1 = 7. And f (4, 4), by analogy, consists of two f (3, 3) and one, and will be equal to 15. Everything this is reminiscent of a power of two, and <b>let‚Äôs</b> write: <b>f (m, m) = 2 ^ m - 1</b> . <br><br>  It looks like a binary search in the physical world: we start from the floor number 2 ^ (m-1), if we succeed, we go up 2 ^ (m-2) floors up, and if we fail, we go down as many down, and so until the attempts are over.  In our case, all the time we go up. <br></div></div><br>  Returning to f (3, 10).  In fact, at each step, everything comes down to the sum of f (2, m-1) - the number of floors that can be determined in case of failure, the units and f (3, m-1) - the number of floors that can be determined in case of success.  And it becomes clear that the increase in the number of eggs and attempts is unlikely that something will change.  <b>f (n, m) = f (n - 1, m - 1) + 1 + f (n, m - 1)</b> .  And this is a universal formula that can be embodied in the code. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lru_cache @lru_cache() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n,m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m**<span class="hljs-number"><span class="hljs-number">2</span></span>+m)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n&gt;=m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>**n<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>+height(n,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br>  Of course, I had previously stepped on the rake of non-nemoisation of recursive functions and found out that f (10, 40) takes almost 40 seconds and the number of calls to itself is 97806983. But memoization also saves only at the initial intervals.  If f (200,400) is executed in 0.8 seconds, then f (200, 500) in 31 seconds already.  It's funny that when measuring the execution time using% timeit, the result is much less real.  Obviously, the first run of the function takes most of the time, and the others simply use the results of its memoization.  Lies, blatant lies and statistics. <br><br><h3>  Recursion is not needed, looking further </h3><br>  So, for example, f (9477, 10000) appears in the tests, but my miserable f (200, 500) does not fit the right time anymore.  So there is another solution, without recursion, we continue its search.  I added code with counting function calls with certain parameters in order to look at what it ultimately decomposes.  For 10 attempts, the following results were obtained: <br><br>  f (3,10) = 7+ 1 * f (2.9) + 1 * f (2.8) + 1 * f (2.7) + 1 * f (2.6) + 1 * f (2 , 5) + 1 * f (2.4) + 1 * f (2.3) + 1 * f (3.3) <br>  f (4,10) = 27 + 1 * f (2.8) + 2 * f (2.7) + 3 * f (2.6) + 4 * f (2.5) + 5 * f (2 , 4) + 6 * f (2,3) + 6 * f (3,3) + 1 * f (4,4) <br>  f (5,10) = 55+ 1 * f (2.7) + 3 * f (2.6) + 6 * f (2.5) + 10 * f (2.4) + 15 * f (2 , 3) + 15 * f (3.3) + 5 * f (4.4) + 1 * f (5.5) <br>  f (6.10) = 69+ 1 * f (2.6) + 4 * f (2.5) + 10 * f (2.4) + 20 * f (2.3) + 20 * f (3 , 3) + 10 * f (4.4) + 4 * f (5.5) + 1 * f (6.6) <br>  f (7.10) = 55+ 1 * f (2.5) + 5 * f (2.4) + 15 * f (2.3) + 15 * f (3.3) + 10 * f (4 , 4) + 6 * f (5.5) + 3 * f (6.6) + 1 * f (7.7) <br>  f (8,10) = 27 + 1 * f (2.4) + 6 * f (2.3) + 6 * f (3.3) + 5 * f (4.4) + 4 * f (5 , 5) + 3 * f (6.6) + 2 * f (7.7) + 1 * f (8.8) <br>  f (9,10) = 7+ 1 * f (2.3) + 1 * f (3.3) + 1 * f (4.4) + 1 * f (5.5) + 1 * f (6 , 6) + 1 * f (7.7) + 1 * f (8.8) + 1 * f (9.9) <br><br>  Some regularity can be seen: <br><br><img src="https://habrastorage.org/webt/tz/vf/gv/tzvfgvzzjnvtp4oqmb3sbgyhehk.png"><br><br>  These coefficients are theoretically calculated.  Each blue is the sum of the top and left.  And purple - the same blue, only in reverse order.  You can calculate, but this is recursion again, and I was disappointed in it.  Most likely, many (it is a pity that I am not) have already learned these numbers, but for the time being I will keep the intrigue by following my own solution path.  I decided to spit on them and go to the other side. <br><br>  He opened the Excel, built a sign with the results of the function and began to look out for patterns.  C3 = IF (C $ 2&gt; $ B3; 2 ^ $ B3-1; C2 + B2 + 1), where $ 2 is a row with the number of eggs (1-13), $ B is a column with the number of attempts (1-20), C3 is a cell at the intersection of two eggs and one attempt. <br><br><img src="https://habrastorage.org/webt/da/u4/uz/dau4uz9wluuwrll54ugfiol02uq.png"><br><br>  The gray diagonal is N = M and here it is clearly seen that nothing changes to the right of it (for N&gt; M).  It can be seen that it cannot be otherwise, because these are all the results of the formula in which it is given that each cell is equal to the sum of the top, top left, and one.  But some universal formula, where you can substitute N and M and get the number of the floor, could not be found.  Spoiler: it does not exist.  But on the other hand, just creating this table in Excel looks like, maybe you can generate the same python and drag answers from it? <br><br><h3>  NumPy, you do not </h3><br>  I remember that there is NumPy, which is just designed to work with multidimensional arrays, why not try it?  To begin, we need a one-dimensional array of zeros N + 1 in size. And a one-dimensional array of units of size N. We take the first array from the zero to the penultimate element, add element by element with the first array from the first element to the last and with an array of units.  We add a zero to the resulting array at the beginning.  Repeat M times.  Element number N of the resulting array will be the answer.  The first 3 steps look like this: <br><br><img src="https://habrastorage.org/webt/4w/hf/ki/4whfkie9lt2lkiyywknshrit0h4.png"><br><br>  NumPy works so fast that I didn‚Äôt save the whole table - every time I read the necessary line again.  But one thing - the result of work on large numbers was wrong.  Older categories like those, and younger - no.  This is how the errors of arithmetic of floating-point numbers accumulated from the multiple addition look like.  It does not matter - you can also change the type of the array to int.  No, trouble - it turned out that for speed, NumPy works only with its data types, and its int, unlike Python int, can be no more than 2 ^ 64-1, after which it overflows silently and continues from -2 ^ 64.  And I actually expect the numbers under three thousand characters.  But it works very fast, f (9477, 10000) is performed for 233 ms, just some kind of nonsense is obtained at the output.  I will not even give the code, since this is the case.  I'll try to do the same thing with a clean python. <br><br><h3>  Iterated, iterated, but not vyiteriroval </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y+<span class="hljs-number"><span class="hljs-number">1</span></span>, arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[n]</code> </pre> <br>  44 seconds to calculate f (9477, 10000), a bit too much.  But absolutely for sure.  What can be optimized?  The first is that there is no need to count everything that is to the right of the diagonal M, M.  The second is to count the last array as a whole, for the sake of a single cell.  For this, the last two cells of the previous one will fit.  To calculate f (10, 20), only these gray cells will suffice: <br><br><img src="https://habrastorage.org/webt/zc/zm/zg/zczmzgfzspyvo2zenqsk4p9y1jo.png"><br><br>  And so it looks like in code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i &lt; mn: <span class="hljs-comment"><span class="hljs-comment">#    m,m arr = [0] + list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr += [arr[-1]] i+=1 arr.pop(-1) while i &lt; n or i &lt; mn: #        arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr = arr + [arr[-1]+1] if n &gt; len(arr) else [0] + arr i+=1 while i &lt; m: # ,     -  arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) i+=1 return arr[0]</span></span></code> </pre> <br>  And what do you think?  f (9477, 10000) in 2 seconds!  But these inputs are too good, the length of the array at any stage will be no more than 533 elements (10000-9477).  Check on f (5477, 10000) - 11 seconds.  Too good, but only compared to 44 seconds - twenty tests with such time will not pass. <br><br>  It's not that.  But once there is a problem, then there is a solution, the search continues.  I again began to look at the Excel table.  The cell to the left of (m, m) is always one less.  And the cell to the left of it is already gone, the difference in each row becomes larger.  The cell below (m, m) is always twice as large.  And the cell below it is no longer double, but a little less, but for each column it is different, the farther, the more.  And the numbers on one line first grow fast, and slowly after the middle.  Let me build a table of differences between neighboring cells, maybe there will be some pattern? <br><br><h3>  Warmer </h3><br><img src="https://habrastorage.org/webt/6b/vn/we/6bvnwew8keybhtyzxprylcwir6i.png"><br><br>  Bah, familiar numbers!  That is, the sum of these N numbers in row number M is the answer?  True, counting them is about the same thing as I have already done; this is unlikely to speed up the work greatly.  But we must try: <br><br><div class="spoiler">  <b class="spoiler_title">f (9477, 10000): 17 seconds</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y, arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:], arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>])) + [<span class="hljs-number"><span class="hljs-number">1</span></span>] m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:n+<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Or 8, if you count only half of the triangle</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(arr) &lt; n+<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    ,  n &lt;  arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr += [arr[-1]] m-=2 while m &gt; 1: arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) m-=1 if len(arr) &lt; n+1: arr += arr[::-1][1:] #  n   ,   return sum(arr[1:n+1])</span></span></code> </pre><br></div></div><br>  Not to say that a more optimal solution.  On some data it works faster, on some slower.  Must go deeper.  What is this triangle with numbers that appeared in the solution twice?  I am ashamed to admit, but the highest mathematics, where the triangle probably figured, I safely forgot, so I had to google. <br><br><h3>  Bingo! </h3><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B5%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D0%25BA_%25D0%259F%25D0%25B0%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258F">Pascal's triangle</a> , so it is officially called.  An infinite table of binomial coefficients.  So the answer to the problem with N eggs and M throws is the sum of the first N coefficients in the expansion of the Newton binomial of the Mth degree, except for the zero one. <br><br>  An arbitrary binomial coefficient can be calculated through the factorials of the line number and the number of the coefficient in the line: bk = m! / (N! * (Mn!)).  But the most pleasant thing is that you can successively calculate the numbers in a line, knowing its number and the zero coefficient (always one): bk [n] = bk [n-1] * (m - n + 1) / n.  At each step, the numerator is reduced by one, and the denominator increases.  And the concise final solution looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> h, bk = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#      for i in range(1, n + 1): bk = bk * m // ih += bk m-=1 return h</span></span></code> </pre><br>  33 ms  on the calculation of f (9477, 10000)!  This solution can also be optimized, although in the specified ranges and it works fine.  If n lies in the second half of the triangle, then you can invert it into mn, count the sum of the first n coefficients and take it away from 2 ^ m-2.  If n is close to the middle and m is odd, then calculations can also be reduced: the sum of the first half of the line will be 2 ^ (m-1) -1, the last coefficient in the first half can be calculated through factorials, its number is (m-1) / 2, and then either continue to add the coefficients, if n is in the right half of the triangle, or subtract, if in the left.  If m is even, then half of the line is no longer calculated, but you can find the sum of the first m / 2 + 1 coefficients by calculating the average factorial and adding half of it to 2 ^ (m-1) -1.  On the input data in the region of 10 ^ 6, this significantly reduces the execution time. <br><br>  Already after a successful decision, I began to look for someone else's research on this issue, but found only the very thing from interviews, with only two eggs, and this is not sporting.  The Internet will be incomplete without my decision, I decided, and here it is. </div><p>Source: <a href="https://habr.com/ru/post/423679/">https://habr.com/ru/post/423679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423669/index.html">How is it to be a team leader in Avito?</a></li>
<li><a href="../423671/index.html">Tesla's competitors received investments of $ 1 billion from Saudi Arabia</a></li>
<li><a href="../423673/index.html">Risks in software development</a></li>
<li><a href="../423675/index.html">Security Week 35: Winter Is Near, How to Assemble a Tesla Trojan</a></li>
<li><a href="../423677/index.html">Jetpack Pilots: Frankie Zapata</a></li>
<li><a href="../423683/index.html">Based on common sense: we grow DevOps from scratch</a></li>
<li><a href="../423685/index.html">Parallelism in PostgreSQL: not spherical, not a horse, not in a vacuum</a></li>
<li><a href="../423687/index.html">HyperX Pulsefire FPS Pro - faster, meaner, more affordable</a></li>
<li><a href="../423689/index.html">ROS MAX - free? We plan to open a license for free commercial use.</a></li>
<li><a href="../423693/index.html">Another way to use Webpack 4 and code sharing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>