<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Preparing for C ++ 20. Coroutines TS on a real example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In C ++ 20, it is about to be possible to work with the cortices out of the box. This topic is close and interesting to us at Yandex.Taxi (we develop ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Preparing for C ++ 20. Coroutines TS on a real example</h1><div class="post__text post__text-html js-mediator-article">  In C ++ 20, it is about to be possible to work with the cortices out of the box.  This topic is close and interesting to us at Yandex.Taxi (we develop an asynchronous framework for our own needs).  Therefore, today we are using a real example to show Habr's readers how to work with C ++ stackless cortutins. <br><br>  As an example, let's take something simple: without working with asynchronous network interfaces, asynchronous timers, consisting of one function.  For example, we will try to realize and rewrite just such a ‚Äúnoodle‚Äù from Kolbeks: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  Qorutin or coroutine is the ability to stop the function in a predetermined place;  pass somewhere the entire state of the stopped function along with local variables;  start the function from the same place where we stopped it. <br>  There are several varieties of coroutines: stackless and stackful.  We will talk about this later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Formulation of the problem </h2><br>  We have several task queues.  Certain tasks are placed in each queue: there is a queue for drawing graphics, there is a queue for network interactions, there is a queue for working with the disk.  All queues are WorkQueue instances that have a void PushTask method (std :: function &lt;void ()&gt; task) ;.  Queues live longer than all tasks placed in them (the situation that we have destroyed a queue when there are unfulfilled tasks in it should not occur). <br><br>  The FuncToDealWith () function from the example executes some logic in different queues and, depending on the execution results, puts a new task in the queue. <br><br>  Let's rewrite the "noodles" of callbacks in the form of a linear pseudo-code, marking in which queue the underlying code should be executed: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  Approximately this result and I want to achieve. <br><br>  However, there are limitations: <br><br><ul><li>  Queue interfaces cannot be changed - they are used in other parts of the application by third-party developers.  Breaking developer code or adding new queue instances is not possible. </li><li>  You cannot change the way FuncToDealWith is used.  You can only change her name, but you can not make her return any objects that the user must store. </li><li>  The resulting code must be as productive as the original (or even more productive). </li></ul><br><h2>  Decision </h2><br><h3>  Rewrite the function FuncToDealWith </h3><br>  In Coroutines TS, the adjustment of the coroutine is made by setting the type of the return value of the function.  If the type meets certain requirements, then inside the function body, you can use the new keywords co_await / co_return / co_yield.  In this example, to switch between queues we will use co_yield: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  It turned out very similar to the pseudocode from the previous section.  All the "magic" of working with Coroutines is hidden in the CoroTask class. <br><br><h3>  CoroTask </h3><br>  In the simplest (in our) case, the contents of the coroutine's ‚Äúcustomizer‚Äù class consist of only one alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  promise_type is the data type we have to write.  It contains logic describing: <br><br><ul><li>  what to do when exiting cortina </li><li>  what to do when you first enter the korutina </li><li>  who frees up resources </li><li>  how to deal with exceptions departing from korutiny </li><li>  how to create a CoroTask object </li><li>  what to do if inside the cortina called co_yield </li></ul><br>  Alias ‚Äã‚Äãpromise_type must be called that way.  If you change the name of the alias to something else, the compiler will swear and say that you have incorrectly written CoroTask.  The name CoroTask can be changed as you like. <br><br><div class="spoiler">  <b class="spoiler_title">And why even this CoroTask, if everything is described in promise_type?</b> <div class="spoiler_text">  In more complex cases, you can create such CoroTask, which will allow you to communicate with the stopped cororne, transmit and receive data from it, awaken and destroy it. <br></div></div><br><h3>  PromiseType </h3><br>  Getting to the most interesting.  We describe the behavior of corutin: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  In the code above, you can see the data type std :: experimental :: suspend_never.  This is a special data type that says you don‚Äôt need to stop corutin.  There is also its opposite - the type std :: experimental :: suspend_always, which tells you to stop the quortenna.  These types are the so-called Awaitables.  If you are interested in their internal structure, then do not worry, we will soon write our Awaitables. <br><br>  The most non-trivial place in the above code is final_suspend ().  The function has unexpected effects.  So, if in this function we <b>do</b> not stop execution, then the resources allocated for the compiler compiler will clean up the compiler for us.  But if in this function we stop the execution of the coroutine (for example, by returning std :: experimental :: suspend_always {}), then the release of resources will have to be done manually from somewhere outside: you will have to save a smart pointer to coroutine somewhere and explicitly call it destroy ().  Fortunately, for our example it is not necessary. <br><br><h3>  <b>INCORRECT</b> PromiseType :: yield_value </h3><br>  It seems that writing PromiseType :: yield_value is quite simple.  We have a queue;  Korutina, which must be suspended and put in this turn: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  And here we are waiting for a very large and difficult to detect problem.  The fact is that we first put the quail in a queue and only then suspend.  It may happen that the quorutine is removed from the queue and will start to be executed before we suspend it in the current thread.  This will lead to a race condition, unspecified behavior and absolutely insane runtime errors. <br><br><h3>  <b>Correct</b> PromiseType :: yield_value </h3><br>  So, we need to first stop the quartz and then add it to the queue.  To do this, we will write our Awaitable and call it schedule_for_execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  The classes std :: experimental :: suspend_always, std :: experimental :: suspend_never, schedule_for_execution and other Awaitables must contain 3 functions.  await_ready is called to check if the coroutine should be stopped.  await_suspend is called after the program is stopped, and the handle of the stopped korutina is transferred to it.  await_resume is called when the execution of the corortina is resumed. <br><div class="spoiler">  <b class="spoiler_title">And what can you write in triangular scraps std :: experimental :: coroutine_handle &lt;&gt;?</b> <div class="spoiler_text">  You can specify the type of PromiseType there, and the example will work exactly the same :) <br><br>  std :: experimental :: coroutine_handle &lt;&gt; (also known as std :: experimental :: coroutine_handle &lt;void&gt;) is the base type for all std :: experimental :: coroutine_handle &lt;Data Type&gt;, where Data Type must be the promise_type of the current coroutine.  If you don‚Äôt need to access the internal data type, you can write std :: experimental :: coroutine_handle &lt;&gt;.  This can be useful in places where you want to abstract from a specific type of promise_type and use type erasure. <br></div></div><br><h3>  Is done </h3><br>  You can <a href="https://wandbox.org/permlink/qVUTKIvvzxbYUR2o">compile, run the example online and experiment in every way</a> . <br><br><div class="spoiler">  <b class="spoiler_title">And if I don‚Äôt like co_yield, can I replace it with something?</b> <div class="spoiler_text">  Can be replaced by co_await.  To do this, you need to add the following function to PromiseType: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">And if I don‚Äôt like co_await?</b> <div class="spoiler_text">  The case is bad.  Nothing can be changed. <br></div></div><br></div></div><br><h3>  Crib </h3><br>  CoroTask is a class that customizes the behavior of cortina.  In more complex cases, it allows you to communicate with the stopped corutine and collect any data from it. <br><br>  CoroTask :: promise_type describes how and when to stop Coroutin, how to free resources and how to construct CoroTask. <br><br>  Awaitables (std :: experimental :: suspend_always, std :: experimental :: suspend_never, schedule_for_execution, etc.) tell the compiler what to do with corutine at a particular point (do you need to stop corutin, what to do with stopped corutina and what to do when corutin is awakened) . <br><br><h3>  Optimization </h3><br>  Our PromiseType has a flaw.  Even if we are currently running in the correct task queue, the call to co_yield will still suspend the quortenine and re-place it in the same task queue.  It would be far better not to stop the execution of the coroutine, but immediately continue the execution. <br><br>  Let's fix this flaw.  To do this, add a private field to PromiseType: <br><br><pre> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  In it, we will hold a pointer to the queue in which we are currently running. <br><br>  Further we will correct PromiseType :: yield_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  Here we have fixed schedule_for_execution :: await_ready ().  Now this function informs the compiler that the coruntine does not need to be suspended if the current task queue is the same as the one on which we are trying to run. <br><br>  Is done.  You can <a href="https://wandbox.org/permlink/QVminRtb6s09lNun">experiment in every way</a> . <br><br><h2>  Pro performance </h2><br>  In the original example, each time we called WorkQueue :: PushTask (std :: function &lt;void ()&gt; f), we created an instance of the class std :: function &lt;void ()&gt; from the lambda.  In real code, these lambdas are often quite large in size, which is why std :: function &lt;void ()&gt; is forced to dynamically allocate memory for storing lambdas. <br><br>  In the corortine example, we create instances of std :: function &lt;void ()&gt; from std :: experimental :: coroutine_handle &lt;&gt;.  The size of std :: experimental :: coroutine_handle &lt;&gt; depends on the implementation, but most implementations try to keep its size as small as possible.  So on clang its size is equal to sizeof (void *).  When constructing std :: function &lt;void ()&gt; from small objects, dynamic allocation does not occur. <br>  Total - with korutinami we got rid of a few extra dynamic allocations. <br><br>  But!  The compiler often cannot simply keep all of the quandic on the stack.  Because of this, one additional dynamic allocation is possible when entering CoroToDealWith. <br><br><h2>  Stackless vs Stackful </h2><br>  We have just worked with Stackless Korutin, which requires support from the compiler to work with.  There are also Stackful Cortinas that can be implemented entirely at the library level. <br><br>  The first ones allow you to allocate memory more economically, potentially they are better optimized by the compiler.  The latter are easier to implement in existing projects, as they require fewer code modifications.  However, in this example, the difference is not felt, the examples are more difficult. <br><br><h2>  Results </h2><br>  We looked at the basic example and got the universal class CoroTask, which can be used to create other coroutines. <br><br>  The code with it becomes more readable and slightly more productive than with the naive approach: <br><table><tbody><tr><th>  It was </th><th>  With korutinami </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  Moments left behind: <br><br><ul><li>  how to call another korutina from korutina and wait for its completion </li><li>  that useful can be crammed in CoroTask </li><li>  an example of the difference between Stackless and Stackful </li></ul><br><h2>  Other </h2><br>  If you want to learn about other C ++ language innovations or to talk personally with colleagues about advantages, take a look at the C ++ Russia conference.  The nearest will be held <a href="http://cpp-russia.ru/%3Fp%3D1486">on October 6 in Nizhny Novgorod</a> . <br><br>  If you have pain associated with C ++, and you want to improve something in the language, or just want to discuss possible innovations, then welcome to <a href="https://stdcpp.ru/">https://stdcpp.ru/</a> . <br><br>  Well, if you are surprised that Yandex.Taxi has a huge number of tasks not related to graphs, then I hope that this turned out to be a pleasant surprise for you :) Come <a href="https://events.yandex.ru/events/meetings/11-oct-2018/">visit us on October 11, let's</a> talk about C ++ and not only. </div><p>Source: <a href="https://habr.com/ru/post/420861/">https://habr.com/ru/post/420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420845/index.html">Taming of the Shrew with the use of a crutch: WF2190 Wi-Fi Hole (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../420847/index.html">An introduction to programming shaders for web designers</a></li>
<li><a href="../420853/index.html">Meet the Windows pseudo console (ConPTY)</a></li>
<li><a href="../420857/index.html">Seamless Wi-Fi roaming: theory in practice</a></li>
<li><a href="../420859/index.html">On the issue of virt and chains</a></li>
<li><a href="../420863/index.html">As we did the first Russian smartphone, continued</a></li>
<li><a href="../420865/index.html">The principle of least action. Part 1</a></li>
<li><a href="../420867/index.html">Calculation of certain integrals: basic algorithms</a></li>
<li><a href="../420869/index.html">Evacuation, HAMR and MAMR - three ways to increase the capacity of modern HDD to the maximum</a></li>
<li><a href="../420871/index.html">How we relocated a web studio in Bali</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>