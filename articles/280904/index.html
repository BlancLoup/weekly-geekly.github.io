<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>man! (C => D => Rust)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The previous article was perceived better than I expected, so I decided to continue the experiment. This is a kind of answer to the translation of the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>man! (C => D => Rust)</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://habrahabr.ru/post/280642/">The previous article was</a> perceived better than I expected, so I decided to continue the experiment.  This is a kind of answer to the <a href="https://habrahabr.ru/post/276227/">translation of the article</a> <a href="http://dlang.org/ctod.html">Programming in D for C Programmers</a> by Dmitry aka <a href="https://habrahabr.ru/users/vintage/" class="user_link">vintage</a> .  It seems to me that in the field of application C Rust is more appropriate than the replacement of Go, as suggested in the last article.  The more interesting it will be to compare.  Again, I will not give the code on C, especially since the analogue on D still looks laconic. </p><a name="habracut"></a><br><br><h4>  Get type size in bytes </h4><br><p> Let me remind you that in C (and in C ++) for this purpose there is a special operator <code>sizeof</code> , which can be applied to both types and variables.  In D, the size is accessible through a property (which can also be applied to variables): </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*).<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> Foo.<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span></code> </pre> <br><p>  Rust uses a function that refers to the internals of the compiler (corresponding to <a href="https://doc.rust-lang.org/std/intrinsics/index.html">intrinsic</a> ): </p><br><pre> <code class="rust hljs">size_of::&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;() size_of::&lt;*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>&gt;() size_of::&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt;() size_of::&lt;Foo&gt;()</code> </pre> <br><p>  At the same time, due to the lack of overloading of functions, another function is used to obtain the size of variables - <code>size_of_val</code> .  Perhaps this separation is somewhat less convenient, but it is not necessary to enter special keywords ‚Äî the usual language mechanisms are used: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">10i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, size_of_val(&amp;a));</code> </pre> <br><p>  Funny thing: in Rust, empty structures (such as Foo from the example) occupy 0 bytes, respectively, an array of any size of such structures will also occupy 0 bytes. <br>  <a href="http://is.gd/s4Y5ay">[Play around with the code]</a> <br><br></p><br><h4>  We get the maximum and minimum value of the type </h4><br><p>  In D, again, type properties are used: </p><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">char</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span> ulong.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> double.min_normal</code> </pre> <br><p>  Rust uses C-like constants: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>::MAX <span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>::MIN <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>::MAX <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::MIN</code> </pre> <br><p>  <a href="http://is.gd/qxj1wG">[Run]</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><h4>  Type Mapping Table </h4><br><pre> <code class="hljs cpp">CD Rust ----------------------------------------------------- <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> i8 <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ubyte u8 <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> i16 <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ushort u16 <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> wchar <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32 <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> uint u32 <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32 <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> uint u32 <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i64 <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ulong u64 <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f32 <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f64 <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> real <span class="hljs-keyword"><span class="hljs-keyword">_Imaginary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ireal <span class="hljs-keyword"><span class="hljs-keyword">_Complex</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> creal</code> </pre> <br><p>  The comparison is not entirely correct, since C uses platform-dependent types, and in D, on the contrary, it is of a fixed size.  For Rust, I picked exactly analogs of fixed size. <br><br></p><br><h4>  Special values ‚Äã‚Äãof floating point numbers </h4><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">infinity</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>.dig <span class="hljs-type"><span class="hljs-type">double</span></span>.epsilon <span class="hljs-type"><span class="hljs-type">double</span></span>.mant_dig <span class="hljs-type"><span class="hljs-type">double</span></span>.max_10_exp <span class="hljs-type"><span class="hljs-type">double</span></span>.max_exp <span class="hljs-type"><span class="hljs-type">double</span></span>.min_10_exp <span class="hljs-type"><span class="hljs-type">double</span></span>.min_exp</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::NAN <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::INFINITY <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::DIGITS <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::EPSILON <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::MANTISSA_DIGITS <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::MAX_10_EXP <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::MAX_EXP <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::MIN_10_EXP <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>::MIN_EXP</code> </pre> <br><p>  As you can see, Rust uses constants again, which, by the way, are usually written in upper case. <br><br></p><br><h4>  The remainder of dividing real numbers </h4><br><p>  There are no revelations - in Rust, as in D, there is the <a href="https://doc.rust-lang.org/std/ops/trait.Rem.html">operator%</a> . <br><br></p><br><h4>  Processing NaN Values </h4><br><p>  In both D and Rust, a comparison with NaN will result in <code>false</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1f64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = NAN; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x &lt; y); <span class="hljs-comment"><span class="hljs-comment">// false println!("{}", y &lt; x); // false println!("{}", x == y); // false</span></span></code> </pre> <br><p>  <a href="http://is.gd/syDu0Y">[Run]</a> <br><br></p><br><h4>  Acerta - a useful error detection mechanism </h4><br><p>  Both languages ‚Äã‚Äãprovide assertions out of the box, but in D they are a special language construct: </p><br><pre> <code class="hljs lisp">assert( <span class="hljs-name"><span class="hljs-name">e</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  A in Rust - just macros: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(condition); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(a, b);</code> </pre> <br><p>  However, there is an interesting difference: in D, the asserts in the release assembly are disabled, except for the special case <code>assert(0)</code> , which is used to indicate the unattainable code in normal execution. <br><br>  In Rust, they remain in the release, however, similar behavior can be obtained using the macro <code>debug_assert!</code>  .  For a more explicit designation of the unattainable when using a <a href="https://doc.rust-lang.org/std/macro.unreachable!.html">separate macro</a> <code>unreachable!</code>  . <br><br></p><br><h4>  Iteration over an array (collection) </h4><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> ) { func( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ); }</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &amp;array { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, value); }</code> </pre> <br><p>  There is not much difference, although the <a href="https://doc.rust-lang.org/book/loops.html"><code>for</code></a> loop in Rust is not similar to its relative from C. <br><br></p><br><h4>  Array elements initialization </h4><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>;</code> </pre> <br><p>  In D, we can initialize an array with a single value, as shown above.  It is worth noting that after creating the array, it will first be initialized with the default value of the type it contains. <br><br></p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = [value; <span class="hljs-number"><span class="hljs-number">17</span></span>];</code> </pre> <br><p>  Rust has a <a href="http://is.gd/Vb71tM">special syntax</a> for this case. <br><br></p><br><h4>  Creating variable length arrays </h4><br><p>  D has built-in support for variable-length arrays: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[ <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.length - <span class="hljs-number"><span class="hljs-number">1</span></span> ] = x;</code> </pre> <br><p>  Rust, following its "philosophy of clarity," requires you to specify a value with which new elements will be initialized when calling the <code>resize</code> method.  Therefore, it is more correct to write the example as follows: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> array = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); array.push(value);</code> </pre> <br><p>  Please note that we <a href="http://is.gd/fQojq7">do not have</a> to specify the type of elements contained in the vector - they will be displayed automatically. <br><br></p><br><h4>  String concatenation </h4><br><p>  In D, there are special overloaded operators ~ and ~ = designed to join lists: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] s1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] s2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] s; s = s1 ~ s2; s ~= <span class="hljs-string"><span class="hljs-string">"hello"</span></span>;</code> </pre> <br><p>  Official documentation <a href="https://dlang.org/spec/arrays.html">argues</a> for the presence of individual operators so that overloading the operator <code>+</code> can lead to surprises. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = <span class="hljs-string"><span class="hljs-string">"eee"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s = s1.to_owned() + s2; s.push_str(<span class="hljs-string"><span class="hljs-string">"world"</span></span>);</code> </pre> <br><p>  <a href="http://is.gd/xkDv2j">In Rust</a> , on the one hand, these problems are impossible because of the need for explicit type conversions.  On the other hand, the <code>+=</code> operator for strings is still not implemented. <br><br></p><br><h4>  Formatted output </h4><br><pre> <code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> std.stdio;</span></span> writefln( <span class="hljs-string"><span class="hljs-string">"Calling all cars %s times!"</span></span> , ntimes );</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Calling all cars {} times!"</span></span> , ntimes);</code> </pre> <br><p>  <a href="http://is.gd/bseIqb">[Run]</a> <br><br>  As you can see, the languages ‚Äã‚Äãin this regard are not particularly different.  Is that in Rust <a href="https://doc.rust-lang.org/std/fmt/index.html">formatting is</a> not similar to the "usual" from C. <br><br></p><br><h4>  Appeal to functions before the announcement </h4><br><p>  Both languages ‚Äã‚Äãuse <a href="https://doc.rust-lang.org/book/crates-and-modules.html">modules</a> , so the order of definition does not matter and preliminary declarations are not needed. <br><br>  <a href="http://is.gd/XewL6K">Rust example:</a> </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() -&gt; Test { bar() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() -&gt; Test { Test { a: <span class="hljs-number"><span class="hljs-number">10</span></span>, b: <span class="hljs-number"><span class="hljs-number">20</span></span> } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><h4>  Functions without Arguments </h4><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... }</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { ... }</code> </pre> <br><p>  Comparison loses some sense in isolation from C, since both languages ‚Äã‚Äãdo not require to specify <code>void</code> to indicate the absence of arguments. <br><br></p><br><h4>  Exit from multiple code blocks </h4><br><pre> <code class="hljs matlab">Louter: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++ ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> ; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> Louter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> Louter; } }</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-symbol"><span class="hljs-symbol">'outer</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-symbol"><span class="hljs-symbol">'inner</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'outer</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j == <span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'inner</span></span>; } } }</code> </pre> <br><p>  The <a href="https://doc.rust-lang.org/book/loops.html">break / continue</a> syntax with a label is almost identical. <br><br></p><br><h4>  Structure namespace </h4><br><p>  Again, in both languages ‚Äã‚Äãthere is no separate namespace for structures. <br><br></p><br><h4>  Branching by string values ‚Äã‚Äã(for example, processing command line arguments) </h4><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dostring</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>( s ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"goodbye"</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"maybe"</span></span>: ... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ... } }</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_string</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> s { <span class="hljs-string"><span class="hljs-string">"hello"</span></span> =&gt; {}, <span class="hljs-string"><span class="hljs-string">"goodbye"</span></span> =&gt; {}, <span class="hljs-string"><span class="hljs-string">"maybe"</span></span> =&gt; {}, _ =&gt; {}, } }</code> </pre> <br><p>  <a href="http://is.gd/udWdkB">In this case,</a> there is not much difference, but in Rust the <code>match</code> construction is a full-fledged comparison with the sample, which <a href="http://is.gd/wUHoZF">allows you to do</a> more clever things: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span></span> { Common, Secret, Unknown, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span></span> { id: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, data_type: Type, info: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt;, } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_data</span></span></span></span>(data: &amp;Data) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> *data { Data { id: <span class="hljs-number"><span class="hljs-number">42</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"The Ultimate Question..."</span></span>), Data { data_type: Type::Secret, info: <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> i, .. } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i.is_empty() =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Empty secret data!"</span></span>), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Some data..."</span></span>), } }</code> </pre> <br><p>  Read more in the <a href="https://doc.rust-lang.org/book/patterns.html">documentation</a> ( <a href="http://rurust.github.io/rust_book_ru/src/patterns.html">translation</a> ). <br><br></p><br><h4>  Alignment of structure fields </h4><br><p>  D has a special syntax with which you can fine-tune the alignment of individual fields: </p><br><pre> <code class="hljs coffeescript">struct ABC { int z; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> z <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> aligned to the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> align(<span class="hljs-number"><span class="hljs-number">1</span></span>) int x; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> byte aligned align(<span class="hljs-number"><span class="hljs-number">4</span></span>) { ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> declarations <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {} are dword aligned } align(<span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> to word alignment <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> here <span class="hljs-literal"><span class="hljs-literal">on</span></span> int y; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> word aligned }</code> </pre> <br><p>  In Rust, you can only completely disable alignment for individual structures: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(packed)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Abc</span></span></span></span> { ... }</code> </pre> <br><h4>  Anonymous structures and associations </h4><br><p>  D supports anonymous structures, which allows you to save a flat front end for nested entities: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> y; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* p; } } Foo f; fi; fx; fy; fp;</code> </pre> <br><p>  There are no anonymous structures or unions in Rust, so similar code would look like this: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span> { Baz {x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { i: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, e: Bar, }</code> </pre> <br><p>  Moreover, Rust will not allow to accidentally turn to the wrong join field that was initialized.  Therefore, you will have to address them <a href="http://is.gd/cfcDgJ">differently</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> fe { Bar::Val(a) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, a), Bar::Baz { x, y } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{} and {}"</span></span>, x, y), }</code> </pre> <br><p>  Thus, associations cannot be used as (semi) legal type conversions, but potential errors are eliminated. <br><br></p><br><h4>  Defining structures and variables </h4><br><p>  Both languages ‚Äã‚Äãrequire separate type and variable declarations, that is, as in C, it will not work: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } foo;</code> </pre> <br><br><h4>  Getting the offset field structure </h4><br><p>  In D, fields have a special <code>offsetof</code> property: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Foo { <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> x; <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> y; } <span class="hljs-attribute"><span class="hljs-attribute">off</span></span> = Foo.y.offsetof;</code> </pre> <br><p>  At the moment, Rust does not support this feature, so if necessary, you will have to manually calculate the displacements by manipulating pointers to members of the structure.  However, <code>offsetof</code> is a reserved keyword, which means that such functionality should appear over time. <br><br></p><br><h4>  Initializing associations </h4><br><p>  D requires an explicit indication of which join field is assigned a value: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">union</span></span> U { <span class="hljs-attribute"><span class="hljs-attribute">int</span></span> a; <span class="hljs-attribute"><span class="hljs-attribute">long</span></span> b; } <span class="hljs-attribute"><span class="hljs-attribute">U</span></span> x = { <span class="hljs-attribute"><span class="hljs-attribute">a</span></span> : <span class="hljs-number"><span class="hljs-number">5</span></span> };</code> </pre> <br><p>  Rust does likewise, moreover, as already mentioned, it will not allow accessing the wrong join field that was initialized. </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span></span> { A(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), B(<span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>), } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> u = U::A(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><h4>  Initialization of structures </h4><br><p>  In the D structure, you can initialize both in order and with the indication of the field names: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d; } S x = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> }; S y = { b : <span class="hljs-number"><span class="hljs-number">3</span></span> , a : <span class="hljs-number"><span class="hljs-number">5</span></span> , c : <span class="hljs-number"><span class="hljs-number">2</span></span> , d : <span class="hljs-number"><span class="hljs-number">10</span></span> };</code> </pre> <br><p>  In Rust, the names <a href="http://is.gd/tuju0K">must be</a> indicated: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, c: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, d: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = s { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Erorr. let y = S { a: 1, b: 2, c: 3, d: 4 }; // Ok.</span></span></code> </pre> <br><h4>  Array initialization </h4><br><p>  In D, there are many ways to initialize an array, including specifying the indexes of elements to be initialized: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] a = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] a = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// unsupplied initializers are 0, just like in C int[3] a = [ 2 : 0, 0 : 3, 1 : 2 ]; int[3] a = [ 2 : 0, 0 : 3, 2 ]; // if not supplied, the index is the previous one plus one.</span></span></code> </pre> <br><p>  <a href="http://is.gd/2NL0Q7">In Rust,</a> it is possible either to list all the values ‚Äã‚Äãwith which we want to initialize the array, or to specify one value for all the elements of the array: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a1 = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a2 = [<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br><h4>  Escaping special characters in strings </h4><br><p>  Both languages, along with the screening of individual characters, support the so-called "raw lines": </p><br><pre> <code class="hljs python">string file = <span class="hljs-string"><span class="hljs-string">"c:\\root\\file.c"</span></span>; string file = <span class="hljs-string"><span class="hljs-string">r"c:\root\file.c"</span></span>; // c:\root\file.c string quotedString = `<span class="hljs-string"><span class="hljs-string">"[^\\]*(\\.[^\\]*)*"</span></span>`;</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file = <span class="hljs-string"><span class="hljs-string">"c:\\root\\file.c"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file = <span class="hljs-string"><span class="hljs-string">r"c:\root\file.c"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quoted_string = <span class="hljs-string"><span class="hljs-string">r#""[^\\]*(\\.[^\\]*)*""#</span></span>;</code> </pre> <br><p>  In Rust, "raw lines" are formed <a href="https://doc.rust-lang.org/reference.html">quite simply</a> : they begin with the character <code>r</code> , followed by an arbitrary number of characters <code>#</code> , followed by a quote ( <code>"</code> ). The lines are completed with a quote with the same number <code>#</code> . In D, the number of lines is <a href="https://dlang.org/spec/lex.html">noticeably larger</a> . <br><br></p><br><h4>  ASCII versus multibyte encodings </h4><br><p>  D supports several types of strings that store different types of characters: </p><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> utf8 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> wstring utf16 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-16</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> dstring utf32 = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; // UTF<span class="hljs-number"><span class="hljs-number">-32</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span></code> </pre> <br><p>  In Rust, there is only one type of string that represents a sequence of UTF-8 bytes: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>;</code> </pre> <br><p>  Konstantin aka <a href="https://habrahabr.ru/users/kstep/" class="user_link">kstep</a> published on Habr√© a <a href="https://habrahabr.ru/post/274485/">series of</a> <a href="https://habrahabr.ru/post/274455/">translations</a> about <a href="https://habrahabr.ru/post/274565/">string types</a> in Rust, so if you are interested in the details, I recommend reading them.  Well, or with <a href="https://doc.rust-lang.org/book/strings.html">official documentation</a> ( <a href="http://rurust.github.io/rust_book_ru/src/strings.html">translation</a> ). <br><br></p><br><h4>  Display enumeration on array </h4><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">COLORS</span></span></span><span class="hljs-class"> </span></span>{ red, blue, green } string[ <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> ] cstring = [ <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.red : <span class="hljs-string"><span class="hljs-string">"red"</span></span>, <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.blue : <span class="hljs-string"><span class="hljs-string">"blue"</span></span>, <span class="hljs-type"><span class="hljs-type">COLORS</span></span>.green : <span class="hljs-string"><span class="hljs-string">"green"</span></span>, ];</code> </pre> <br><p>  Analog on Rust using the macro collect!  would look like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::BTreeMap; <span class="hljs-meta"><span class="hljs-meta">#[derive(PartialOrd, Ord, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Colors</span></span></span></span> { Red, Blue, Green, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cstring: BTreeMap&lt;_, _&gt; = collect![ Colors::Red =&gt; <span class="hljs-string"><span class="hljs-string">"red"</span></span>, Colors::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"blue"</span></span>, Colors::Green =&gt; <span class="hljs-string"><span class="hljs-string">"green"</span></span>, ];</code> </pre> <br><h4>  Creating new types </h4><br><p>  D allows you to create new types of existing (strong typedef): </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.typecons; alias Handle = Typedef!( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Handle )</span></span></span></span>; Handle h; foo( h ); <span class="hljs-comment"><span class="hljs-comment">// syntax error bar( h ); // ok</span></span></code> </pre> <br><p>  Including, with the task of default value: </p><br><pre> <code class="hljs swift">alias <span class="hljs-type"><span class="hljs-type">Handle</span></span> = <span class="hljs-type"><span class="hljs-type">Typedef!</span></span>( void* , cast( void* ) -<span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-type"><span class="hljs-type">Handle</span></span> h; h = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( h != <span class="hljs-type"><span class="hljs-type">Handle</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span> ) { ... }</code> </pre> <br><p>  In Rust, this is done through the use of a tuple structure ( <a href="https://doc.rust-lang.org/book/structs.html">tuple struct</a> , <a href="http://rurust.github.io/rust_book_ru/src/structs.html">translation</a> ): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(_: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>(_: Handle) {} foo(h); <span class="hljs-comment"><span class="hljs-comment">// error bar(h); // ok</span></span></code> </pre> <br><p>  Creating a value without initializing Rust will not allow it, and to create a default value, it will be correct to implement the <a href="https://doc.rust-lang.org/std/default/trait.Default.html">Default</a> trait: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Handle</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Handle { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { Handle(std::ptr::null_mut()) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h = Handle::<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>();</code> </pre> <br><p>  <a href="http://is.gd/nT3wq0">[Run]</a> <br><br></p><br><h4>  Comparison of structures </h4><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1 == a2) { ... }</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a1 == a2 { ... }</code> </pre> <br><p>  The only difference is that D implicitly implements a comparison operator for us, and Rust needs to ask about it, <a href="http://is.gd/HuR9UV">which we do</a> through <code>#[derive(PartialEq)]</code> . <br><br></p><br><h4>  String comparison </h4><br><pre> <code class="hljs axapta">string <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> == <span class="hljs-string"><span class="hljs-string">"betty"</span></span> ) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> &lt; <span class="hljs-string"><span class="hljs-string">"betty"</span></span> ) { ... }</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> == <span class="hljs-string"><span class="hljs-string">"betty"</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span> &lt; <span class="hljs-string"><span class="hljs-string">"betty"</span></span> { ... }</code> </pre> <br><p>  In both languages, strings can be compared for equality and more / less. <br><br></p><br><h4>  Sorting arrays </h4><br><p>  D uses generic implementations of algorithms: </p><br><pre> <code class="hljs lua">import std.algorithm; <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>[] array; ... <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>( array ); // <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-place array.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>!<span class="hljs-string"><span class="hljs-string">"a&gt;b"</span></span> // using custom compare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array.sort</span></span></span><span class="hljs-function">!</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ( a , b )</span></span></span></span> =&gt; ( a &gt; b ) ) // same as above</code> </pre> <br><p>  Rust uses a slightly different approach: sorting, like some other algorithms, is implemented for "slices" (slice), and those containers for which it makes sense can be brought to them. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> array = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]; array.sort(); array.sort_by(|a, b| b.cmp(a));</code> </pre> <br><p>  <a href="http://is.gd/xZEupU">[Run]</a> <br>  From small differences: the comparison should return not <code>bool</code> , but <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html">Ordering</a> (more / less / equal). <br><br>  This comparison made you wonder why in Rust it was done differently from D or C ++.  Offhand I do not see the advantages and disadvantages of both approaches, so we will write off simply on the peculiarities of the language. </p><br><h4>  String literals </h4><br><pre> <code class="hljs pgsql">"This text \"spans\" multiple lines "</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-string"><span class="hljs-string">"This text \"spans\" multiple lines "</span></span></code> </pre> <br><p>  Both languages ‚Äã‚Äãsupport multiline string constants. <br><br></p><br><h4>  Crawling data structures </h4><br><p>  Despite the name, in this paragraph, in my opinion, only the ability of nested functions to access variables declared in external is demonstrated, so I took the liberty to rewrite the code: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { a = <span class="hljs-number"><span class="hljs-number">20</span></span>; } bar(); }</code> </pre> <br><p>  In Rust, you can declare nested functions, but they cannot capture variables, for this they use closures: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//a = 20; // Error. } let mut baz = || { a = 20 }; baz(); }</span></span></code> </pre> <br><p>  <a href="http://is.gd/DkGuzc">[Run]</a> <br><br></p><br><h4>  Dynamic closures </h4><br><p>  Rust also has lyabmdy / delegates / closures.  The example was higher in the text, but if you are interested in the details, check out the <a href="https://doc.rust-lang.org/book/closures.html">documentation</a> ( <a href="http://rurust.github.io/rust_book_ru/src/closures.html">translation</a> ). <br><br></p><br><h4>  Variable number of arguments </h4><br><p>  In D, there is a special "..." construct that allows you to take several parameters as a single typed array: </p><br><pre> <code class="hljs perl">import std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ... ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> += <span class="hljs-keyword"><span class="hljs-keyword">x</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { writefln( <span class="hljs-string"><span class="hljs-string">"sum = %d"</span></span>, sum( <span class="hljs-number"><span class="hljs-number">8</span></span> , <span class="hljs-number"><span class="hljs-number">7</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] ints = [ <span class="hljs-number"><span class="hljs-number">8</span></span> , <span class="hljs-number"><span class="hljs-number">7</span></span> , <span class="hljs-number"><span class="hljs-number">6</span></span> ]; writefln( <span class="hljs-string"><span class="hljs-string">"sum = %d"</span></span>, sum( ints ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Rust does not have direct support for a variable number of arguments, instead it is proposed to use slices or iterators: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(values: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values { res += *val; } res } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, sum(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ints = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, sum(&amp;ints)); }</code> </pre> <br><p>  <a href="http://is.gd/edtGTv">[Run]</a> <br><br></p><br><h4>  Conclusion </h4><br><p>  That's all.  Of course, a comparison of two languages, based on the characteristics of the third, is quite specific, but certain conclusions can be made.  I suggest you make them yourself. <br><br>  Well, according to tradition, we will make the title <a href="http://is.gd/SBC5Uq">compiled</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> man { (C =&gt; D) =&gt; {{ <span class="hljs-string"><span class="hljs-string">"https://habrahabr.ru/post/276227/"</span></span> }}; (C =&gt; D =&gt; Rust) =&gt; {{ <span class="hljs-string"><span class="hljs-string">"https://habrahabr.ru/post/280904/"</span></span> }}; (Rust =&gt; $any:tt) =&gt; {{ <span class="hljs-string"><span class="hljs-string">"You are doing it wrong!"</span></span> }}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, man!(C =&gt; D)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, man!(C =&gt; D =&gt; Rust)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, man!(Rust =&gt; C)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, man!(Rust =&gt; D)); }</code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/280904/">https://habr.com/ru/post/280904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280894/index.html">Wi-Fi module WF121 and HTTP server in addition</a></li>
<li><a href="../280896/index.html">Personal data of 50 million Turkish citizens leaked to the network</a></li>
<li><a href="../280898/index.html">Debugging Office Add-ins on iOS (iPad)</a></li>
<li><a href="../280900/index.html">RUVDS introduces new Huawei FusionSphere OpenStack virtualization systems</a></li>
<li><a href="../280902/index.html">Rust and Swift (third, fourth, fifth and sixth parts)</a></li>
<li><a href="../280906/index.html">5th International Mobile Conference MBLT16 in a month</a></li>
<li><a href="../280908/index.html">Guiding Eyes transfers data to the IBM Cloud to improve the quality of care for blind people.</a></li>
<li><a href="../280910/index.html">Vulnerabilities in MyChat by NetworkSoftwareSolutions (fixed and none)</a></li>
<li><a href="../280912/index.html">PostgreSQL useful tricks</a></li>
<li><a href="../280914/index.html">Sandbox for programmers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>