<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to run a program without an operating system: part 4. Parallel computing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After a long break, we continue to do interesting things, as always on a clean iron without an operating system. In this part of the article, we will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to run a program without an operating system: part 4. Parallel computing</h1><div class="post__text post__text-html js-mediator-article">  After a long break, we continue to do interesting things, as always on a clean iron without an operating system.  In this part of the article, we will learn how to use the full potential of processors: we will run the program on several processor cores in a completely parallel mode at once.  To do this, we need to do a lot to extend the functionality of the program obtained <a href="http://habrahabr.ru/company/neobit/blog/176707/">in Part 3</a> . <br><br>  Just because doing some calculations on the processor cores is boring, so we need a task that requires large computational resources, is well decomposed into parallel computing, and it looks cool.  We propose to make a program that renders a simple 3D scene using the ray tracing algorithm, or, in a simple way, <b>Ray Tracing</b> . <br><br>  Let's start from the beginning: our goal is parallel computing on all processor cores.  All modern processors for the PC, and the ARM already too (I am silent about the GPU) are multi-core processors.  What does this mean?  This means that instead of a single computing core, the processor on one computer has several cores.  In general, everything looks somewhat more complicated: several sockets (processor chips) can be installed on a computer, several physical cores can be located within each chip (within one crystal), and several logical cores can be located within each physical core ( for example, those that arise when using technology Hyper Threading).  All this is schematically represented in the figure below, and is called a topology. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/951/809/702/9518097028d41853443ed1d5cc7ab1c0.jpg"><br><a name="habracut"></a><br>  Obviously, sockets are just several installed processors of the same motherboard.  Below are some more pictures for clarity. <br><br><img src="https://habrastorage.org/storage2/65f/804/096/65f8040963b56c64b8b5a7492689a22b.jpg"><br><br><img src="https://habrastorage.org/storage2/0fa/6bf/eda/0fa6bfedab8c2efb09322f27b37aa610.jpg"><br><br>  Among all this, the most interesting is the presence of <i>logical cores</i> .  This is the principle of <b>SMT</b> (Simultaneous Multithreading), which means, in practice, the execution of successive instructions from another logical stream, during which parts of the processor were released, waiting for the end of the execution of instructions from the main thread.  Each physical processor core consists of many components (cache, pipelines, ALU, FPU, ...), many parts operate independently of each other and need to be synchronized, so while the instruction waits for data from the cache or memory before the end of execution, why not execute others instructions from another thread using the same instructions?  More information and pictures can be found <a href="https://computing.llnl.gov/tutorials/linux_clusters/">on this link</a> or in official documents of Intel, AMD, ARM. <br><br>  In this article, the details of the topology will be important only to improve the optimization (and all the cores will be perceived as the same).  You can get the topology programmatically using the CPUID instructions, but more on that next time. <br><br>  Let's introduce some more concepts: <br><br>  <b>SMP</b> (Symmetric Multiprocessing) - means the symmetric use of all processors;  for example, all processor cores can access the same RAM in full, all processor cores are the same and behave the same. <br><br>  <b>AMP</b> (Asymmetric Multiprocessing) as opposed to the previous concept, means that at least one core behaves differently than others.  For example, the joint work of CPU and GPU can be considered as an example of AMP. <br><br>  <b>NUMA</b> (Non-Uniform Memory Access) - non-uniform access of processors to different areas of memory.  In fact, it means that each processor core can access the entire memory, but for each core there is a memory area to which it refers faster than the rest.  Again used for optimization. <br><br>  In modern computer has all of these principles and technologies. <br><br>  We will consider the SMP in its purest form.  When the system starts, the processor itself selects one arbitrary core and calls it the <b>Boot Strap Processor</b> (BSP), all others become the <b>Application Processor</b> (AP).  BSP begins to execute the BIOS code, which, in turn, finds and starts all the processor cores in the system, performs their preliminary initialization and safely turns them off.  Thus, our program after the start will work on one BSP core of the processor, so our goal looks, at first glance, quite simple: find out how many cores are on a computer, then run and configure each core in the system, and make all cores perform one computational task for the common good. <br><br>  In order to achieve our goal you need to answer a few questions: <br><br>  <i>How to determine the number and topology of processors and cores in the system?</i> <br>  To do this, you need to use the wonderful ACPI interface, and to determine the topology, use the CPUID. <br><br>  <i>How to identify a specific processor core?</i> <br>  To do this, use an APIC device, or rather LAPIC, which each processor core in the system has, possesses a unique identifier for the system (such as the PID for processes), and is responsible for delivering interrupts to a specific processor core. <br><br>  <i>How to run one core from another core?</i> <br>  It is enough to send an interrupt from one processor core to another.  This signal is called IPI (Inter Processor Interrupt).  To send it, it is enough to use the LAPIC device on one of the cores, writing a certain value to its register. <br><br>  <i>How to stop the execution of the processor core?</i> <br>  It is enough to call the HLT instruction on this kernel. <br><br>  Now a little more.  <b>ACPI</b> (not to be confused with <b><u>APIC</u></b> ) - this is the Advanced Configuration and Power Interface - in fact it is a standard interface through which the operating system can obtain information about the computer, its detailed configuration, and control the power of the computer.  This interface consists of a power management device (which is called an ACPI device, and, by the way, is present in PCI ( <a href="http://habrahabr.ru/company/neobit/blog/162769/">look at the article</a> )), and several ACPI tables that are located in the computer‚Äôs RAM and contain information about the system.  In addition to information about the processor cores on a computer, some ACPI tables store information even about the physical dimensions and form factor of the computer (for example, you can learn from them that the program runs on a tablet ...).  There are a lot of tables, and their full description can be found <a href="http://www.acpi.info/spec.htm">here</a> , and we are only interested in the MADP referenced by the RSDT, the pointer to which is in the RSDP table, which can be found somewhere in the vicinity of the BIOS.  A simplified diagram of the main ACPI tables is presented as follows: <br><br><img src="https://habrastorage.org/storage2/a43/9ec/5b7/a439ec5b7c8ef6836fa0e0e0b29beafa.jpg"><br><br>  For now, all you need to know is that MADT contains records with information about the processor cores.  Each entry contains the LAPIC identifier of this core (8 bits long, which means no more than 256 cores of any type in the system) and the Enable bit (which indicates whether this core can be used or reserved). <br>  Now <b>LAPIC</b> is Local APIC, and <b>APIC</b> (not to be confused with <u><b>ACPI</b></u> ) is the Advanced Programmable Interrupt Controller, which replaces the old PIC (Programmable Interrupt Controller).  PIC used to immediately deliver interrupts to the processor, and now it does it through LAPIC.  Local APIC is not the only type of APIC - there is also IO APIC - which is a separate interrupt controller and is responsible for distributing interrupts between the processor cores on the system.  Total picture is as follows: <br><br><img src="https://habrastorage.org/storage2/1bd/7fc/5bb/1bd7fc5bb2b3f0ed4a71811a63ebf490.jpg"><br><br>  At first glance, it looks difficult, but if you look at it, then everything is quite reasonable: the <b>PIC</b> ‚Äî an interrupt controller that has been used for a long time ‚Äî has remained and has not gone anywhere, it is still part of the chipset on the motherboard.  With the advent of multi-core <b>IO APIC</b> added, which now distributes interrupts from the PIC and other sources between the cores, because someone needs to do this.  Each LAPIC is provided with a unique identifier that is used in IPI and IO APIC configuration.  Also in the number LAPIC coded its topology.  BSP always has a LAPIC ID of 0. <br>  To program LAPIC, you need to read and write data to its registers (as with any other device), its registers are located in memory at 0xFEE00000.  In fact, this address may be different, but you can always find it through a special MSR (Model Specific Register - these registers are read and written via the rdmsr / wrmsr instructions).  For all cores, this address is often the same, but each core at this address has its own personal LAPIC.  This device has many registers, but we need only one - <b>ICR</b> (Interrupt Control Register) which allows you to send IPI. <br>  To start a processor core, this core needs to send as many as three IPIs that will force the other core to turn on: INIT IPI, then STARTUP IPI, and another STARTUP IPI. The second STARTUP IPI (or SIPI) is needed to complete the initialization process, since the first could be canceled, and the second will be ignored if the first SIPI is successful.  Nothing can be done - such rules.  To send each IPI, you simply need to write certain bytes to the ICR register of your LAPIC.  These bytes will include the LAPIC identifier byte to which the IPI is sent, and the type of IPI to be sent.  For SIPI, 2 more bytes will be used, from which the memory address from which the AP will be launched will be determined. <br>  The latter is very convenient, since we will need to start the processor first from our code, which will transfer the processor to Protected Mode (yes, the processor after INIT-SIPI-SIPI runs in Real Mode, which does not suit us).  The processor initialization code will be discussed in detail later.  Yes, we won't do without a raw assembler. <br>  You can read more about LAPIC and IO APIC <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">in the Intel processor manual</a> . <br><br>  Now it remains to deal with several trifles: <b>Lock</b> , <b>FPU</b> and the <b>Ray Tracing</b> algorithm itself (payload). <br><br>  The first thing we still need is the ability to synchronize the work of all the cores.  To do this, you need to write the <b>Lock</b> code, which would expect to appear in the memory, for example, ones.  How to make Lock correctly?  The most obvious option is to write a simple while (1), which expects the appearance of a zero at a certain address, and immediately write down the unit at this address, while the other cores did not have time to do this.  And to unlock the lock you need to write a zero. <br><br>  Now <b>FPU</b> (Floating Point Unit) is a special module on the processor, which is used for arithmetic calculations with a floating point.  In other words, if you want to use variables of type float and double in your program, then you need to initialize this module.  In all modern operating systems, this makes the core of the operating system for you, but in our case it will be necessary.  However, it is not difficult at all - just a couple of instructions in assembly language.  We will need float because Ray Tracing will not work otherwise. <br><br>  How do we do <b>Ray Tracing</b> ?  This algorithm is beyond the scope of this article, so it will not be explained here, but there are <a href="http://habrahabr.ru/post/112944">many good articles about it</a> .  For our case, we just take the finished program and modify it a little. <br><br>  Now that the theory is over, let's start writing the program. <br><br>  <u><b>!</b></u>  <u><b>IMPORTANT !: All further actions can be successfully carried out only after successful completion of all 6 steps from the <a href="http://habrahabr.ru/company/neobit/blog/176707/">third part of the article ‚ÄúHow to run a program without an operating system‚Äù</a></b></u> <br><br><h5>  Step 1. First clean the excess. </h5><br>  First of all, you need to slightly clear the existing code from unnecessary files and functions.  We need a full-fledged mathematical library, so we need to delete the extra files from common: we delete the file <b>common / s_floor.c</b> . <br>  We don‚Äôt need to draw a fractal - we need Ray Tracing, so you can delete fractal.c.  But since the graphics mode is still needed, we write the following code in kernel.c: <br>  1. add a few declarations in front of the main function, which, among other things, define the screen resolution and the image that will be rendered: <br>  i <pre><code class="cpp hljs">nt vbe_screen_w = <span class="hljs-number"><span class="hljs-number">800</span></span>, vbe_screen_h = <span class="hljs-number"><span class="hljs-number">600</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VBE_SetMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ulong mode )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VBE_Setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ulong vbe_lfb_addr; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ulong vbe_selected_mode; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> ulong vbe_bytes; <span class="hljs-comment"><span class="hljs-comment">//     int ray_main(); void SmpPrepare(void);</span></span></code> </pre> <br><br>  2. change the main function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clear_screen(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\n&gt;&gt;&gt; Hello World!\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      SmpPrepare(); VBE_Setup(vbe_screen_w, vbe_screen_h); VBE_SetMode(vbe_selected_mode | 0x4000); //      ray_main(); }</span></span></code> </pre><br><br>  3. delete the line: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawFractal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br><br><h5>  Step 2. Add the fdlibm math library. </h5><br><br>  Now you can add a complete mathematical library.  In fact, we only need the functions sqrt, tan and pow - they are used in the Ray Tracing algorithm. <br><br>  1. create the <b>fdlibm</b> directory in the root <b>.</b> <br>  2. in this directory, download the fdlibm library <a href="http://www.netlib.org/fdlibm/">from here</a> .  You need to download all the files from this folder. <br>  3. Now you need to replace the makefile with a simpler one (at the same time you can check the list of files).  Compiling will use the same flags as the main makefile in the root.  This will build a simple library <b>fdlibm.a.</b>  Contents of the new makefile: <br><pre> <code class="bash hljs">CC = gcc CFLAGS = -Wall -fno-builtin -nostdinc -nostdlib -ggdb3 LD = ld OBJFILES = \ e_acos.o e_acosh.o e_asin.o e_atan2.o e_atanh.o e_cosh.o e_exp.o \ e_fmod.o e_gamma.o e_gamma_r.o e_hypot.o e_j0.o e_j1.o e_jn.o \ e_lgamma.o e_lgamma_r.o e_log.o e_log10.o e_pow.o e_remainder.o \ e_rem_pio2.o e_scalb.o e_sinh.o e_sqrt.o \ k_cos.o k_rem_pio2.o k_sin.o k_tan.o \ s_asinh.o s_atan.o s_cbrt.o s_ceil.o s_copysign.o s_cos.o s_erf.o s_expm1.o \ s_fabs.o s_finite.o s_floor.o s_frexp.o s_ilogb.o s_isnan.o s_ldexp.o s_lib_version.o \ s_log1p.o s_logb.o s_matherr.o s_modf.o s_nextafter.o s_rint.o s_scalbn.o s_signgam.o \ s_significand.o s_sin.o s_tan.o s_tanh.o \ w_acos.o w_acosh.o w_asin.o w_atan2.o w_atanh.o w_cosh.o w_exp.o w_fmod.o w_gamma.o \ w_gamma_r.o w_hypot.o w_j0.o w_j1.o w_jn.o w_lgamma.o w_lgamma_r.o w_log.o \ w_log10.o w_pow.o w_remainder.o w_scalb.o w_sinh.o w_sqrt.o k_standard.o all: fdlibm.a rebuild: clean all .so: as -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> $&lt; .co: $(CC) -Ix86emu ‚ÄìI../include $(CFLAGS) -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> -c $&lt; .cpp.o: $(CC) -Ix86emu -I. -Iustl ‚ÄìI../include $(CFLAGS) -o <span class="hljs-variable"><span class="hljs-variable">$@</span></span> -c $&lt; fdlibm.a: $(OBJFILES) ar -rv fdlibm.a $(OBJFILES) ranlib fdlibm.a clean: rm -f $(OBJFILES) fdlibm.a</code> </pre><br><br>  4. so that everything is going to make a change to <b>k_standard.c</b> .  We need to declare errno and define an empty function fputs, which in our case has no meaning without a file system and a graphic display.  To do this, replace the lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USE_WRITE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; /* fputs(), stderr */ #define WRITE2(u,v) fputs(u, stderr) #else /* !defined(_USE_WRITE) */</span></span></span></span></code> </pre><br><br>  on the lines: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fputs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *u, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">stderr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errno = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USE_WRITE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WRITE2(u,v) fputs(u, 0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* !defined(_USE_WRITE) */</span></span></span></span></code> </pre><br><br><h5>  Step 3. Add the necessary definitions and headings. </h5><br><br>  As usual, you need to slightly expand the definitions that will be used later in the program. <br>  1. This time C ++ will be used, even with templates, therefore, to avoid a number of errors, you need to correct the <b>include / string.h</b> file.  In it, you need to add an explicit type conversion in all places where void * is converted to char *.  I got this line: 42, 53,54,79,80.  Everywhere a similar change, for example, the corrected line 42 looks like this: <br>  p = (char *) addr; <br>  2. You need to add a few definitions for the math library.  These include several global variable definitions, several types, several constants, and error codes that fdlibm uses.  As a result, we add the following code to <b>include / types.h</b> (before the last #endif at the end of the file): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> u64; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FLT_MAX 1E+37 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DBL_MAX 1E+37 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LDBL_MAX 1E+37 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> INFINITY # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INFINITY (__builtin_inff()) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUM 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NAN 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INF 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> M_PI 3.14159265358979323846 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pi */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __PI 3.14159265358979323846 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __SQRT_HALF 0.70710678118654752440 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __PI_OVER_TWO 1.57079632679489661923132 typedef const union { long l[2]; double d; } udouble; typedef const union { long l; float f; } ufloat; extern double BIGX; extern double SMALLX;</span></span></code> </pre><br><br>  3. Add the file <b>include / errno.h</b> with the following code: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _ERRNO_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _ERRNO_H extern int errno; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EDOM -6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ERANGE -8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  4. Now, you need to add a lot of definitions related to hardware, SMP setup, ACPI, LAPIC, and special processor register setup functions.  To do this, create a file include / hardware.h, to which we add the <a href="">following code</a> .  This time we placed two files with ready-made code on github.  This is due to the fact that the code is relatively long (~ 500 lines), therefore, it is inconvenient to write it in the framework of the article.  We emphasize that the code is supplied with a large number of comments in Russian, so the code on github can be considered a continuation of the article.  In the paragraph we will give the contents of the file: <br><br>  a.  definitions of structures used to parse ACPI tables.  This code is based on the official ACPI specification.  The code contains only definitions for the tables we need (RSDP, RSDT, MADT). <br><br>  b.  The following file declares several inline functions containing assembler instructions.  For the most part, the functions are very small, although they look cumbersome due to the peculiarities of using assembler in gcc, where a typical construction looks like this: __asm__ __volatile__ ("&lt;instructions&gt;": &lt;output parameters&gt;: &lt;input parameters&gt;);  The code of these functions by name can be found on the Internet in different places, like in the code of FreeBSD, Linux, and such projects as Bitvisor.  We also need the following functions: rdtsc, __rdmsr, __rdmsrl, __wrmsr, __wrmsrl, __rep_nop and __cpuid_count, __get_cr0, __set_cr0. <br><br>  c.  I especially want to highlight two functions that we called SmpSpinlock_LOCK and SmpSpinlock_UNLOCK.  Both functions are taken from <a href="">orangetide.com/src/bitvisor-1.3/include/core/spinlock.h</a> and are also written in assembler.  They are functions of working with a synchronization object for processor cores operating simultaneously.  These are simple locks.  The essence of their work is simple: as a lock, one byte is used in memory, which can take the value 0 or 1. If 0, then the lock is open, and if 1, then it is closed.  The essence of the SmpSpinlock_LOCK function is to wait for the 0 value in the lock byte and set this byte to 1. The normal cycle is used for waiting using the ‚Äúpause‚Äù instruction, which allows you to optimize the processor performance and reduce its power consumption during the wait cycles.  To read and simultaneously set the value of 1 to the memory byte, the instruction ‚Äúxchg‚Äù is used, which allows atomic exchange of values ‚Äã‚Äãbetween the memory and the register.  Atomicity means that another processor core will not be able to disrupt the operation of this instruction and will stick into the middle of its operation. <br><br>  d.  The hardware.h code contains a description of several constants associated with LAPIC.  They are taken from the Intel documentation. <br><br>  e.  At the end of the file, another assembler function __enable_fpu is declared, which performs the inclusion of FPU on the processor.  Recall that this is necessary for working with types of float.  The function is the execution of two instructions: ‚Äúfnclex‚Äù and ‚Äúfninit‚Äù, which are necessary to enable FPU on the core. <br><br><h5>  Step 4. Add the initialization code of the processor cores. </h5><br><br>  Now, you can start creating the smp.c file, which will contain functions for working with several processor cores.  The most important part of this file is assembler code that will be executed on newly launched kernels.  The code <a href="">smp.c is also located on github</a> and is provided with a large number of comments with explanations;  Part of the code had to be collected from a variety of sources on the Internet, and some had to be written by myself.  The fact is that multi-core configuration is a specific case for each OS, so the code contains a lot of what a particular OS needs.  The purpose of the author of the article was to simplify this code so that it was possible to demonstrate the essence of what is happening and the minimum of actions that must be performed to use SMP.  The smp.c code contains two parts: <br><br>  1. code to search and enable each AP.  The beginning of the entire initialization occurs with the call to the SmpPrepare function.  For the operation of some subfunctions, it is necessary to observe not a large time delay.  Correctly, these delays should be done using a timer or CMOS, but for example, a delay is used based on waiting for a certain value of the TSC counter (processor clock counter that has passed since its start).  The following steps are performed within SmpPrepare: <br><ul><li>  a.  check for LAPIC using the CPUID. </li><li>  b.  getting the base address of LAPIC through MSR. </li><li>  c.  getting pointers to two parts of the 64-bit ICR register.  These are ordinary pointers to a specific area in memory.  They will be used to send IPI. </li><li>  d.  then the RSDP address is searched.  It determines the address of the TSDT table.  The RSDT table contains the address on the MADT.  The entire MADT table is scanned and all records related to Local APIC are analyzed.  Each such entry contains a LAPIC ID and a kernel enable flag.  As a result, an array of all the LAPIC IDs found and included that are in the system is collected. </li><li>  e.  The next step is to reserve memory pot stack of each processor core.  The stack is allocated at 64Kb and is located starting from the 5th megabyte of physical memory. </li><li>  f.  then at the physical address 0x6000 an assembly code is copied, which initializes each core of the AP.  About this code is described below. </li><li>  g.  after that, each processor core AP is started.  To this end, INIT-SIPI-SIPI signals are sequentially sent to each core by writing certain bytes to the ICR.  This code is taken from (http://fxr.watson.org/fxr/source/i386/i386/mp_machdep.c).  For execution, the code uses the LAPIC ID obtained earlier and vector 6, corresponding to the address 0x6000 which is located on the initialization code. </li><li>  h.  then BSP expects the inclusion of all processor cores, for which it waits for the moment when the counter of the enabled cores equals their total number.  Each AP core increases this counter by 1. </li><li>  i.  this function completes its work. </li></ul><br>  2. code running on each AP.  This code starts with an assembler.  It is located immediately at the beginning of the smp.c. file.  In this assembly code, each line is commented.  If we describe this assembly code briefly, it performs the following actions: <br><ul><li>  a.  collecting several flags in the flag register, and resetting the base registers to get started. </li><li>  b.  the inclusion of cr0 protected mode without page addressing. </li><li>  c.  transition to a 32-bit code segment. </li><li>  d.  load GDTR and all segments as 32 bits (code and data). </li><li>  e.  read LAPIC base address from MSR. </li><li>  f.  read the register LAPIC to determine its ID (for the current kernel). </li><li>  g.  getting a stack pointer for the current kernel.  For each core, memory is pre-reserved for its personal stack. </li><li>  h.  function call on C (SmpApMain). </li></ul><br><br>  The function SmpApMain defines the index of the processor.  The index is its number from 0 to N - where N-1 is the total number of cores on the computer.  Then the counter of running cores increases synchronously, which is used to wait for all processors to start.  Then the processor core goes into waiting for the launch of the payload flag.  As soon as the flag is turned on, the ap_cpu_worker function is called ‚Äî which performs the payload (Ray-Tracing). <br><br><h5>  Step 5. Add the Ray Tracing Algorithm. </h5><br><br>  The most difficult part behind.  Now we need to add the payload in the form of the Ray Tracing algorithm.  The algorithm itself is beyond the scope of this article, so theory and practice can be obtained from <a href="http://www.codermind.com/articles/Raytracer-in-C%2B%2B-Introduction-What-is-ray-tracing.html">these resources</a> .  We will not comment the Ray Tracing code.  Instead, we take the ready code as a basis and tell you how to change it in order to compile it in our program.  We take the code <a href="http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-1-writing-a-simple-raytracer/">from here as a</a> basis.  It will need to remove the dynamic allocation of memory and STL, replacing everything with a static array.  Then, you need to fix the render function so that it can render only the area of ‚Äã‚Äãthe image in rows.  Last, you will need to implement the ap_cpu_worker function, which calls render with certain parameters. <br><br>  1. create a <b>ray.cpp</b> file.  Copy the <a href="http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-1-writing-a-simple-raytracer/">final code into it</a> . <br><br>  2. replace the lines in it: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;cassert&gt;</span></span></span></span></code> </pre><br>  On the lines: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"string.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hardware.h"</span></span></span><span class="hljs-meta"> double tan(double x); double sqrt(double x); double pow (double x, double y); extern int vbe_screen_w; extern int vbe_screen_h; extern ulong vbe_lfb_addr; extern ulong vbe_bytes; extern u32 cpu_count; extern ulong SmpStartedCpus; void SmpReleaseAllAps(); } namespace std { template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class T&gt; const T&amp; max (const T&amp; a, const T&amp; b) { return (a&lt;b)?b:a; // or: return comp(a,b)?b:a; for version (2) } template &lt;class T&gt; const T&amp; min (const T&amp; a, const T&amp; b) { return !(b&lt;a)?a:b; // or: return !comp(b,a)?a:b; for version (2) } }</span></span></span></span></code> </pre><br>  3. delete the following lines: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp;os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3&lt;T&gt; &amp;v) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; vx &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; vy &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; vz &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  and these: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Save result to a PPM image (keep these flags if you compile under Windows) std::ofstream ofs("./untitled.ppm", std::ios::out | std::ios::binary); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (unsigned i = 0; i &lt; width * height; ++i) { ofs &lt;&lt; (unsigned char)(std::min(T(1), image[i].x) * 255) &lt;&lt; (unsigned char)(std::min(T(1), image[i].y) * 255) &lt;&lt; (unsigned char)(std::min(T(1), image[i].z) * 255);</span></span></code> </pre><br>  4. replace: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Sphere&lt;T&gt; *&gt; &amp;spheres, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;depth)</code> </pre><br>  On: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Sphere&lt;T&gt; **spheres, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> spheres_size, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;depth)</code> </pre><br><br>  5. in the whole <b>ray.cpp</b> file <b>,</b> replace <b>spheres.size ()</b> with <b>spheres_size</b> (only 3 replacements). <br>  6. replace the render function in this way: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere&lt;T&gt; **spheres, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> spheres_size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y_start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y_end)</span></span></span><span class="hljs-function"> </span></span>{ Vec3&lt;T&gt; pixel; T invWidth = <span class="hljs-number"><span class="hljs-number">1</span></span> / T(vbe_screen_w), invHeight = <span class="hljs-number"><span class="hljs-number">1</span></span> / T(vbe_screen_h); T fov = <span class="hljs-number"><span class="hljs-number">30</span></span>, aspectratio = vbe_screen_w / T(vbe_screen_h); T angle = <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(M_PI * <span class="hljs-number"><span class="hljs-number">0.5</span></span> * fov / T(<span class="hljs-number"><span class="hljs-number">180</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// Trace rays for (unsigned y = y_start; y &lt; y_end; ++y) { for (unsigned x = 0; x &lt; (unsigned)vbe_screen_w; ++x) { T xx = (2 * ((x + 0.5) * invWidth) - 1) * angle * aspectratio; T yy = (1 - 2 * ((y + 0.5) * invHeight)) * angle; Vec3&lt;T&gt; raydir(xx, yy, -1); raydir.normalize(); pixel = trace(Vec3&lt;T&gt;(0), raydir, spheres, spheres_size, 0); //   int color = ((int)(pixel.x * 255) &lt;&lt; 16) | ((int)(pixel.y * 255) &lt;&lt; 8) | (int)(pixel.z * 255); //     *(int *)((char *)vbe_lfb_addr + y * vbe_screen_w * vbe_bytes + x * vbe_bytes + 0) = color &amp; 0xFFFFFF; } } }</span></span></code> </pre><br>  7. Accordingly, in the entire file, correct the two remaining calls to the trace function, adding another spheres_size parameter: <br><pre> <code class="cpp hljs">Vec3&lt;T&gt; reflection = trace(phit + nhit * bias, refldir, spheres, depth + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  replaced by: <br><pre> <code class="cpp hljs">Vec3&lt;T&gt; reflection = trace(phit + nhit * bias, refldir, spheres, spheres_size, depth + <span class="hljs-number"><span class="hljs-number">1</span></span>) ;</code> </pre> <br>  and this: <br><pre> <code class="cpp hljs">refraction = trace(phit - nhit * bias, refrdir, spheres, depth + <span class="hljs-number"><span class="hljs-number">1</span></span>) ;</code> </pre> <br>  on: <br><pre> <code class="cpp hljs">refraction = trace(phit - nhit * bias, refrdir, spheres, spheres_size, depth + <span class="hljs-number"><span class="hljs-number">1</span></span>) ;</code> </pre> <br>  8. at the end of the file, instead of the main function, <b>we</b> add the <b>ray_main</b> and <b>ap_cpu_worker functions</b> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RAY_SHAPES_COUNT 6 Sphere</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;float&gt; *ray_spheres[RAY_SHAPES_COUNT]; extern "C" void ap_cpu_worker( int index ) { __enable_fpu(); render&lt;float&gt;((const Sphere&lt;float&gt; **)ray_spheres, 6, vbe_screen_h/cpu_count * index, vbe_screen_h/cpu_count * index + vbe_screen_h/cpu_count); forever(); } extern "C" int ray_main() { Sphere&lt;float&gt; sp1 (Vec3&lt;float&gt;(0, -10004, -20), 10000, Vec3&lt;float&gt;(0.2), 0, 0.0); Sphere&lt;float&gt; sp2 (Vec3&lt;float&gt;(0, 0, -20), 4, Vec3&lt;float&gt;(1.00, 0.32, 0.36), 1, 0.0); Sphere&lt;float&gt; sp3 (Vec3&lt;float&gt;(5, -1, -15), 2, Vec3&lt;float&gt;(0.90, 0.76, 0.46), 1, 0.0); Sphere&lt;float&gt; sp4 (Vec3&lt;float&gt;(5, 0, -25), 3, Vec3&lt;float&gt;(0.65, 0.77, 0.97), 1, 0.0); Sphere&lt;float&gt; sp5 (Vec3&lt;float&gt;(-5.5, 0, -15), 3, Vec3&lt;float&gt;(0.90, 0.90, 0.90), 1, 0.0); Sphere&lt;float&gt; sp6 (Vec3&lt;float&gt;(0, 20, -30), 3, Vec3&lt;float&gt;(0), 0, 0, Vec3&lt;float&gt;(3)); ray_spheres[0] = &amp;sp1; ray_spheres[1] = &amp;sp2; ray_spheres[2] = &amp;sp3; ray_spheres[3] = &amp;sp4; ray_spheres[4] = &amp;sp5; ray_spheres[5] = &amp;sp6; SmpReleaseAllAps(); ap_cpu_worker(0); forever (); return 0; }</span></span></span></span></code> </pre><br><br><h5>  Step 6. Last revision and launch. </h5><br><br>  It remains only to modify the makefile so that everything compiles.  To do this, we make the following changes: <br>  1. update OBJFILES: <br><pre> <code class="cpp hljs">OBJFILES = \ loader.o \ common/<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>.o \ common/screen.o \ common/bios.o \ common/vbe.o \ common/qdivrem.o \ common/udivdi3.o \ common/umoddi3.o \ common/divdi3.o \ common/moddi3.o \ common/setjmp.o \ common/<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.o \ x86emu/x86emu.o \ x86emu/x86emu_util.o \ smp.o \ ray.o \ kernel.o</code> </pre><br>  2. add a target for compiling C ++: <br><pre> <code class="cpp hljs">.cpp.o: $(CC) -Ix86emu -I. -Iustl -Iinclude $(CFLAGS) -o $@ -c $&lt;</code> </pre><br>  3. Next, you need to change the call line of the binder to connect the new library: <br><pre> <code class="cpp hljs">$(LD) -T linker.ld -o $@ $^ fdlibm/fdlibm.a</code> </pre><br>  4. Now you need to build a library: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> fdlibm make rebuild</code> </pre><br>  5. Now you can rebuild the project: <br><pre> <code class="bash hljs">make rebuild sudo make image</code> </pre><br><br>  6. we start the project with an option of emulation of the 4th nuclear processor to be convinced that everything works: <br><pre> <code class="bash hljs">sudo qemu-system-i386 -hda hdd.img ‚Äìsmp 4</code> </pre><br><br>  If everything is done correctly, then we should see such beauty here: <br><img src="http://habrastorage.org/storage2/9fe/4ca/339/9fe4ca339d85a4d1a150419d08eea341.gif"><br><br>  As in the previous parts of the article, using the dd command, you can copy the hdd.img image to a USB flash drive and test the operation of the program on a real computer. <br><br>  The result was an interesting program that uses all the cores of modern processors.  This article opens up opportunities for developing programs that are sharpened by time-consuming calculations.  It is important to note that, as in previous articles, there is no operating system; therefore, all calculations are performed using all available hardware resources.  The program does not even handle interrupts - they are just turned off.  Therefore, at what speed everything will be drawn and will determine the actual computational capabilities of your processor.  Of course, this is all true if the program is running on bare metal.  Our Intel i5 spends about 800 milliseconds to draw this picture.  It will be interesting to see in the comments information about the speed that you got on real hardware. <br><br>  Links to the following articles of the cycle: <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/211470/">part 5. Accessing the BIOS from the OS</a></b> " <br>  " <b>How to run a program without an operating system: <a href="http://habrahabr.ru/company/neobit/blog/203706/">part 6. Support for working with disks with the FAT file system</a></b> " </div><p>Source: <a href="https://habr.com/ru/post/181626/">https://habr.com/ru/post/181626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181610/index.html">We write the client for your favorite site on phoneGap</a></li>
<li><a href="../181614/index.html">SaaS Site Builders. Google sites</a></li>
<li><a href="../181616/index.html">Generate 3D grids with predefined surface regions using NetGen</a></li>
<li><a href="../181618/index.html">Popularity of Javascript Framework</a></li>
<li><a href="../181624/index.html">Three new Evernote security features</a></li>
<li><a href="../181630/index.html">Learn Pebble Watch to understand Russian.</a></li>
<li><a href="../181632/index.html">We create Apple-media storage on a PC-based</a></li>
<li><a href="../181634/index.html">A quick look at DesignSpark PCB</a></li>
<li><a href="../181636/index.html">How we arranged brunches for each task</a></li>
<li><a href="../181638/index.html">Public VPS templates for Linux / Windows - invite authors and admins to create a service like AWS AMI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>