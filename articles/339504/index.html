<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generalized search for paths for AI in platformers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 If you are creating a platform game in the ‚Äúrun and jump‚Äù style, you may have already thought about adding an AI to it. He can control oppo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generalized search for paths for AI in platformers</h1><div class="post__text post__text-html js-mediator-article"><h1>  Foreword </h1><br>  If you are creating a platform game in the ‚Äúrun and jump‚Äù style, you may have already thought about adding an AI to it.  He can control opponents, objects that the player must pursue, and so on ... And too often, for the sake of simplicity, the implementation programmer abandons the intelligent AI, which results in the AI ‚Äã‚Äãnot being able to cope with cunning jumps, an especially intelligent player or moving objects level <br><br>  This article presents a technique that allows you to send an AI to any static location on the map.  The path chosen by the AI ‚Äã‚Äãrequires a lot of jumps with precisely chosen time or bypassing parts of the scene if this path begins and ends from a static point (but this condition is not always necessary). <br><br>  We will look at the main idea and create a complete implementation.  More complex cases, including moving platforms / destructible walls, we will look at in another article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This technique is used in the game Nomera, see on <a href="http://www.dotstarmoney.com/">www.dotstarmoney.com</a> or on <a href="https://twitter.com/DotStarMoney">Twitter</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/510/368/f50/510368f50ecc2efdfead46ca9bb99b7e.png" alt="e3iKSJ7.png"></div><br><br>  Before you begin, check that you may be able to implement a simpler algorithm that corresponds to the simplified map geometry.  For example, if the collisions in the levels are recognized by a grid of squares (as in most 2D games).  In such cases, you can implement a reliable search for AI paths using more simple techniques.  My method is mainly suitable for those who want a more "humane" behavior of AI. <br><a name="habracut"></a><br><h2>  Training </h2><br>  Before starting work, it will be nice to refresh your knowledge of <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">mathematical graphs</a> and algorithms for <a href="http://en.wikipedia.org/wiki/Graph_traversal">traversing graphs</a> .  Also, for preprocessing and determining distances along surfaces, you should understand vector mathematics well. <br><br>  This technique is applicable to levels composed mainly of static parts of a level with moving objects, and <b>not</b> to levels that are constantly changing on the fly.  It is important to have access to static level collision data as straight line segments;  this simplifies the work, however, this technique can be easily extended to support any geometric objects used for collisions. <br><br><h2>  main idea </h2><br>  In simple terms: you, as a developer, move around the level and jump on platforms, and the engine records the user input used at the point where you jump / fall from the platform until you find yourself in the next one.  This data is considered the ‚Äúedge‚Äù in which the recorded player input is stored.  When an AI wants to create a path through a level, it processes a series of platforms (from now on, we will call them <b>nodes</b> ) as vertices, and edges written between them will act as a graph.  The AI ‚Äã‚Äãthen travels the path, moving along different nodes and using the recorded input in the edges to reach the end point.  We need to consider many more important details, but first we will focus on more general concepts. <br><br>  The technique we use will be a combination of two algorithms.  This is the <b>creation of a path graph</b> , or ‚Äúthe creation of a data structure that the AI ‚Äã‚Äãwill use to find a path through a level‚Äù and <b>bypassing the path graph</b> , or ‚Äúdirecting the enemy along the level to a given point‚Äù.  Obviously, the second algorithm requires the first.  <b>Creating a path graph</b> can be described as follows: <br><br><ol><li>  We load static data of collisions of level and we calculate from them a set of nodes. </li><li>  We load all the edges (paths) written for the level and add them to the corresponding starting nodes. </li><li>  Using the model of collisions and parameters of the movement of enemies, we write the paths between the nodes and add them to the graph. </li><li>  When exiting the level, we export the edges recorded for the level. </li></ol><br>  <i>While this may seem confusing, but below we will analyze the algorithm in detail.</i>  <i>Now it‚Äôs enough to have a general idea of ‚Äã‚Äãthe stages.</i> <br><br>  And now a general view <b>of the path graph traversal</b> : <br><br><ol><li>  We get the end point in the form of the end node, and the distance in the direction of this node;  we calculate similar parameters for the initial (initial) node. </li><li>  We calculate the path using any algorithm for traversing the graph from the source to the end point, where the path is a set of nodes and edges. </li><li>  We carry out the AI ‚Äã‚Äãthrough the knot to the edge by walking (or running, ie, by any movement known to the AI) to achieve the desired initial speed of the next edge on the way. </li><li>  When the AI ‚Äã‚Äãreaches the starting point of the next node on the path with a certain tolerance of position and speed, disable the automatic control of the AI ‚Äã‚Äãand execute control through the frame data entered frame by frame. </li><li>  When the recorded data is completed, we return control to the automatic movement for the node where the AI ‚Äã‚Äãis located. </li><li>  Repeat the last three steps until the end point is reached. </li></ol><br>  Already starting to understand?  Let's take a closer look at each stage. <br><br><h1>  We realize the search for ways step by step </h1><br><h2>  Creating a path graph </h2><br>  The path graph consists of platforms / nodes connected by records / edges.  It is important to begin to clearly define what is the platform and what is the record. <br><br>  <b>The node / platform has the following properties</b> : <br><br><ul><li>  This is a subset of line segments that form the level geometry. </li><li>  In normal gravity, all segments of the node are oriented in such a way that their first vertex has a strictly smaller x coordinate than the second (if the gravity is inverted, the situation will be reversed). </li><li>  Each subsequent segment of the node begins where the last segment ended. </li><li>  Each segment of the node can be passed by AI, walking on its surface. </li></ul><br>  What does this give us?  The next important idea is that a <i>node can be completely passed by an AI moving along its surface without jumping or falling, and the AI ‚Äã‚Äãcan pass to any point along the node from any other point.</i> <br><br>  Here is an image of the level collision geometry: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/9a7/798/7f69a7798d99ba5d3dceeef2a8d9dc18.png" alt="gMek452.png"></div><br>  But the image of the nodes extracted from it (for clarity, they are marked with numbers and different colors).  In my implementation, the extraction of nodes is performed at boot level.  Thus, when the level is already built, you do not need to go back and mark the surface.  You will notice that, in essence, this is the extraction of "all surfaces we can walk on": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec7/d96/fff/ec7d96ffff8abc529d28f9f233247f64.png" alt="MGnhyFZ.png"></div><br>  <b>Note:</b> <i>There is a small error in this image: 26 and 1 are different nodes, but as you can see, they must be one.</i> <br><br>  Depending on the method of storing the level geometry, you may need a little extra processing to convert arbitrary straight line segments into connected nodes. <br><br>  Another important note: <i>if you have static geometry that makes it difficult to move along a node (for example, a wall that does not touch the floor), then you will have to divide the nodes along this obstacle.</i>  In my example, they are not, but if you do not perform such a test, it can lead to serious complications. <br><br>  After receiving the nodes, you complete the first step of creating a path graph.  We also need to figure out how to quantify a position.  <b>The position</b> that we use when determining the start and end points when searching for paths is the node (in our case by the number) and the horizontal displacement along this node relative to its leftmost point.  Why horizontal offset instead of arc length along a node?  For example, an AI collider is a square or circle that runs along a flat surface towards a rising slope.  Can its surface touch the inner corner point of the slope?  No, therefore, the position is measured as a horizontal displacement, so that we can consider the horizontal displacement as a ‚Äúcurved horizontal line‚Äù. <br><br>  To complete the second and third stages, we need to decide what the edge / entry is. <br><br>  <b>The edge has the following properties:</b> <br><br><ul><li>  The edge has a start and end position in two different nodes (however, it can be one node if you want to create a jump on the platform using a jump!) </li><li>  The edge has a set of pre-frame recorded data that, when specifying the AI ‚Äã‚Äãin the edge of the initial position and initial velocity, will direct the AI ‚Äã‚Äãto the position defined by the final position. </li></ul><br>  Here it is necessary to note the following: it is absolutely necessary that the generated set of the recorded frame-by-frame input have the <b>SAME</b> properties of collisions and movement, which is the AI ‚Äã‚Äãfor which the path is being created.  The big question here is where do the recorded frame-by-frame data come from.  The correct answer is from the developer! <br><br>  Here is the jump: <br>  <b>In the developer mode of the Nomera game engine, you can turn on recording, that is, as soon as a player jumps from a node or falls from a node, a node is created with a starting position equal to the position from which he fell / jumped.</b>  <b>From this point on, user input is recorded frame by frame.</b>  <b>When a player lands on a node from free fall / jump, the recording ends and is added as an edge between the starting node and the current node (of course, with positions).</b> <br><br>  In other words, fragments of the recorded player input are created.  If the AI ‚Äã‚Äãis set to the initial position, then it can transfer control of this input data to reach the final position. <br><br>  It is also important that when recording the properties of collisions and player movement, they instantly switch to the AI ‚Äã‚Äãproperties, and the edge is marked as ‚Äúaccessible to reach‚Äù only by the AI ‚Äã‚Äãitself, with whose properties it was recorded. <br><br>  The second step in creating a path graph is loading all previously created edges, and the third is the recording process itself.  The recording method is completely up to you.  Here is a screenshot of Nomera with ribs painted on the screen.  Lines connect only the initial and final position, and do not track the path, but clearly explain the technique: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/40f/817/aed40f817adb09849f4b627dc7cd8719.png"></div><br><br>  In the upper left corner are visible marks in-game edge editor.  It allows you to remove any edges that you do not like, or which the AI ‚Äã‚Äãdoes not need to take into account.  It also shows the number of frames for which input was recorded. <br><br>  Of course, an edge needs more properties than just recorded frames and a start with an end position.  As I said earlier, the speed at the beginning of the edge is critical, and this will become more apparent later.  It is also useful to have convenient access to the number of frames occupied by the edge, because it helps to find the shortest path to the final position. <br><br>  At this stage, you already have the knowledge to build a graph of the paths of the nodes of the platforms and the recorded edges connecting them.  However, it is more interesting how the AI ‚Äã‚Äãperforms navigation using this graph. <br><br><h2>  Traversing path graph </h2><br>  Before you start using the path graph, talk a little about implementation.  Since we, in essence, record the actions of AI along the paths, it would be nice if the AI ‚Äã‚Äãwas controlled by an interface similar to the player's interface.  Suppose we have a player class that looks something like this: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Player</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... void setInputs(int left, int right, int jump); // ... private: // ... }</span></span></code> </pre> <br>  Where "left, right, jump" are entered from the keyboard.  First of all, these will be the values ‚Äã‚Äãthat you will record while edge recording.  Secondly, since the AI ‚Äã‚Äãalso needs a ‚ÄúsetInputs‚Äù control interface, why not write a REAL interface?  Then the code becomes more modular: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> PC_ControlMode{ MANUAL, RECORDED } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlatformController</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... void setManualInput(int left, int right, int jump); void bindRecordedInput(RecordedFrames newRecord); int getLeft(); int getRight(); int getJump(); void step(timestep as double); // ... protected: PC_ControlMode controlMode; RecordedFrames curRecord; void setInputs(int left, int right, int jump); // ... } class Player : public PlatformController{ // ... } class AI : public PlatformController{ // ... }</span></span></code> </pre> <br>  Now both AI and player classes are controlled by an interface that expands and can switch between manual and recorded controls.  This scheme is also convenient for pre-recorded cutscenes in which the player loses control. <br><br>  Okay, now in the controller of the AI, we need black-box-style methods: <br><br><pre> <code class="cpp hljs">createPath(positionType destination); step(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> timestep);</code> </pre> <br>  The first line sets the path between the current position and the end position, and the second line passes the input to <em>setInputs ()</em> to bring the AI ‚Äã‚Äãto the end position.  In our step-by-step statement of the algorithm, <em>createPath</em> performs the first two steps, and <em>step the</em> last three.  Let's look at creating a path. <br><br>  The path will consist of an ordered sequence of different nodes and edges, starting at the edge and ending at the last edge, leading us to the final node. <br><br>  First we need to be able to determine the current position, whether it is in the air or in a node.  When we are in a node, we need a reference to this node and the horizontal position along it (remember, our general <b>position</b> ?). <br><br>  To build the path, we use the graph traversal algorithm.  In my implementation, I used the Dijkstra algorithm.  For each stored node, we also store the position in which we find ourselves by choosing a leading edge (for future generations, we will call it <em>edgeStartNodeCurrentPositionX</em> ).  Thus, the edge weights for a given edge are calculated as follows: <br><br><pre> <code class="cpp hljs">edgeFrameLength =      walkToEdgeDist = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(edgeStartX - edgeStartNodeCurrentPositionX) edgeWeight = edgeFrameLength * TIMESTEP + walkToEdgeDist / (HORIZONTAL_WALKING_SPEED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(edgeDestinationNode == destinationPositionNode){ edgeWeight += <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(edgeEndX - destinationPositionX) / (HORIZONTAL_WALKING_SPEED) }</code> </pre><br>  As you can see, the weight of the final edge is expressed in seconds and is the sum of the time spent on the record and the time taken to walk to the beginning of the edge.  This calculation is inaccurate, and will be different if running is used in the movement of the enemy.  We also check whether we are in the final node, and if this is the case, then the time of walking from the final position of the rib to the final position of the path is added to the weight. <br><br>  If we can calculate the weights of our ribs, then we can use the Dijkstra algorithm!  (Or any other algorithm for traversing a graph, A * is well suited here if you use heuristics like ‚ÄúEuclidean distance to final position‚Äù). <br><br>  At this stage you should have a way!  We have almost completed and completed 4 stages of our algorithm.  In essence, we have two procedures, between which we switch depending on whether we are in a node or edge-controlled. <br><br>  <b>If we are in a node</b> , we go from our current position towards the edge that we need next.  Earlier, I mentioned that we also need to know the initial velocity of the recorded edges.  It is needed because very often the AI ‚Äã‚Äãhas a slight acceleration or deceleration at the beginning or end of the walk.  One of these transient velocities can be the starting point of the target edge.  So when we go to the starting point of the edge, we sometimes have to slow down a bit or increase our speed to get ready for the start of the run / walk. <br><br>  When we reach the initial position of the edge, along which we will move, then most likely, our position will not <i>exactly</i> correspond to the initial position of the edge.  In my implementation, the position was rarely shifted by more than a pixel.  It is important that we reach the initial position of the edge with a certain tolerance, and as soon as we reach it, we will change the position / speed of the AI ‚Äã‚Äãto the initial position / speed of the edge. <br><br>  Now we are ready to transfer control to the edge record. <br><br>  <b>If we are on the edge</b> , then each frame simply receives the control transmitted by the edge record and increases the number of the read frame read.  And it's all!  Sooner or later the recording will end, and if it was accurate before the frame, the AI ‚Äã‚Äãwill be in the next node and control will be transferred to the node. <br><br><h2>  Additions </h2><br>  To configure this technique in the game, you can make some changes to it. <br><br>  It is highly recommended to add an in-game interface to record and erase paths, which will help you conveniently create paths through the level: in Nomera, creating paths in a level takes about 10 minutes, and this is quite fun. <br><br>  It is also convenient to provide automatic extraction of nodes.  Although technically you can do it yourself, adding automatic extraction makes the workflow <b>MUCH</b> easier. <br><br>  To quickly get the parameters of the nodes, Nomera stores all the nodes in a hash table, and all the edges in the lists for each of the nodes.  For ease of display, the edges are also saved in a general list, allowing them to show the lines of the start / end points on the screen. <br><br>  If you have not yet noticed, static interactive elements like ladders or ropes that are not objects with collisions are processed by this technique automatically.  Suppose to climb the ladder, you need to press "up", then if this press "up" is recorded and the AI ‚Äã‚Äãuses an interface similar to the one offered above, then it will register the entered data and lead to climbing. <br><br><h1>  Summarize </h1><br>  We studied the way of conducting AI on a level with platforms, which works regardless of the geometry of collisions.  It allows AI to take advantage of all the control potential in the platformers.  First, we generated a path graph for the level, then built a path for the graph, and finally, we spent the AI ‚Äã‚Äãon this path. <br><br>  But does it work?  How does it work?  Here is the gif: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/b5c/bcc/413b5cbccd1f4ddc03c439e0ed8e374e.gif" alt="Ynhun7J.gif"></div><br>  <i>These guys are in "hug mode."</i>  <i>They are trying to get close to me, wherever I go.</i> <br><br>  If you have questions or suggestions, email me at chris@dotstarmoney.com.  Thanks for reading! </div><p>Source: <a href="https://habr.com/ru/post/339504/">https://habr.com/ru/post/339504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339492/index.html">C / C ++ code optimization</a></li>
<li><a href="../339496/index.html">Fuel for AI: a selection of open datasets for machine learning</a></li>
<li><a href="../339498/index.html">Overview of one Russian RTOS, part 7. Means of data exchange between tasks</a></li>
<li><a href="../339500/index.html">What the Android DevOps-engineer head hurts</a></li>
<li><a href="../339502/index.html">Fintech track GenerationS - another chance for your fintech startup</a></li>
<li><a href="../339506/index.html">OpenCV. Search for road signs using contour analysis in Android</a></li>
<li><a href="../339508/index.html">How to run docker-voting on Swarm, Kubernetes and Nomad</a></li>
<li><a href="../339510/index.html">As we scrum scaled</a></li>
<li><a href="../339512/index.html">Uneducated youth: yes, another post from the student‚Äôs point of view</a></li>
<li><a href="../339516/index.html">Zabbix conference 2017: how was the first day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>